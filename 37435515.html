<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694250058644" as="style"/><link rel="stylesheet" href="styles.css?v=1694250058644"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bitbashing.io/async-rust.html">Maybe Rust isn’t a good tool for massively concurrent, userspace software</a> <span class="domain">(<a href="https://bitbashing.io">bitbashing.io</a>)</span></div><div class="subtext"><span>mrkline</span> | <span>438 comments</span></div><br/><div><div id="37437676" class="c"><input type="checkbox" id="c-37437676" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37435839">next</a><span>|</span><label class="collapse" for="c-37437676">[-]</label><label class="expand" for="c-37437676">[96 more]</label></div><br/><div class="children"><div class="content">OK, I suppose I should write to this.<p>As I&#x27;ve mentioned before, I&#x27;m writing a high performance metaverse client. Here&#x27;s a demo video.[1]
It&#x27;s about 40,000 lines of Rust so far.<p>If you are doing a non-crappy metaverse, which is rare, you need to wrangle a rather excessive amount of data in near real time. In games, there&#x27;s heavy optimization during game development to prevent overloading the play engine. In a metaverse, as with a web browser, you have to take what the users create and deal with it. You need 2x-3x the VRAM a comparable game would need, a few hundred megabits per second of network bandwidth to load all the assets from servers, a half dozen or so CPUs running flat out, and Vulkan to let you put data into the GPU from one thread while another thread is rendering.<p>So there will be some parallelism involved.<p>This is not like &quot;web-scale&quot; concurrency, which is typically a large number of mini-servers, each doing their own thing, that just happen to run in the same address space. This is different. There&#x27;s a high priority render thread drawing the graphics. There&#x27;s a update thread processing incoming events from the network. There are several asset loading and decompression threads, which use up more CPU time than I&#x27;d like. There are about a half dozen other threads doing various miscellaneous tasks - handling moving objects, updating levels of detail, purging caches, and such.<p>There&#x27;s considerable locking, but no &quot;static&quot; data other than constants. No globals. 
Channels are used where appropriate to the problem. The main object tree is single ownership, and used mostly by the update thread. Its links to graphics objects are Arc reference counted, and those are updated by both the update thread and the asset loading threads. They in turn use reference counted handles into the Rend3 library, which, via WGPU and Vulkan, puts graphics content (meshes and textures) into the GPU. Rendering is a loop which just tells Rend3 &quot;Go&quot;, over and over.<p>This works out quite well in Rust. If I had to do this in C++, I&#x27;d be fighting crashes all the time.
There&#x27;s a reason most of the highly publicized failed metaverse projects didn&#x27;t reach this level of concurrency.
In Rust, I have about one memory related crash per year, and it&#x27;s <i>always</i> been in someone else&#x27;s &quot;unsafe&quot; code. My own code has no &quot;unsafe&quot;, and I have &quot;unsafe&quot; locked out to prevent it from creeping in. The normal development process is that it&#x27;s hard to get things to compile, and then it Just Works.
That&#x27;s great! I hate using a debugger, especially on concurrent programs. Yes, sometimes you can get stuck for a day, trying to express something within the ownership rules. Beats debugging.<p>I have my complaints about Rust. The main ones are:<p>- Rust is race condition free, but not deadlock free. It needs a static deadlock analyzer, one that tracks through the call chain and finds that lock A is locked before lock B on path X, while lock B is locked before path A on path Y. Deadlocks, though, tend to show up early and are solid problems, while race conditions show up randomly and are hard to diagnose.<p>- Async contamination. Async is all wrong when there&#x27;s considerable compute-bound work, and incompatible with threads running at multiple priorities. It keeps creeping in. I need to contact a crate maintainer
and get them to make their unused use of &quot;reqwest&quot; dependent on a feature, so I don&#x27;t pull in Tokio. I&#x27;m not using it, but it&#x27;s there.<p>- Single ownership with a back reference is a very common need, and it&#x27;s too hard to do. I use Rc and Weak for that, but shouldn&#x27;t have to. What&#x27;s needed is a set of traits to manage consistent forward and back links (that&#x27;s been done by others) and static analysis to eliminate the reference counts.
The basic constraints are ordinary borrow checker restrictions - if you have mutable access to either parent or child, you can&#x27;t have access to the other one. But you can have non-mutable access to both.
If I had time, I&#x27;d go work on that.<p>- I&#x27;ve learned to live without objects, but the trait system is somewhat convoluted.
There&#x27;s one area of asset processing that really wants to be object oriented, and I have more duplicate code
there than I like. I could probably rewrite it to use traits more, but it would take some bashing to make
it fit the trait paradigm.<p>- The core graphics crates aren&#x27;t finished. There was an article on HN a few days ago about this. &quot;Rust has 5 games and 50 game engines&quot;. That&#x27;s not a language problem, that&#x27;s an ecosystem problem. Not enough people are doing non-toy graphics in Rust. Watch my video linked below.[1] Compared to a modern AAA game title, it&#x27;s not that great. Compared to anything else being done in Rust (see [2]) it&#x27;s near the front.
This indicates a lack of serious game dev in Rust.
I&#x27;ve been asked about this by some pro game devs.
My comment is that if you have a schedule to meet, the Rust game ecosystem isn&#x27;t ready.
It&#x27;s probably about five people working for a year from being ready.<p>[1] <a href="https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;tp9mLAQoHaFR32YAVKVDrz" rel="nofollow noreferrer">https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;tp9mLAQoHaFR32YAVKVDrz</a><p>[2] <a href="https:&#x2F;&#x2F;gamedev.rs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gamedev.rs&#x2F;</a></div><br/><div id="37439589" class="c"><input type="checkbox" id="c-37439589" checked=""/><div class="controls bullet"><span class="by">Dinux</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37443248">next</a><span>|</span><label class="collapse" for="c-37439589">[-]</label><label class="expand" for="c-37439589">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been building our robotic simulators in Rust for the past 3 years and I have the exact same experience. So far, I think, we&#x27;ve encountered maybe 5 actual runtime bugs over the last 3 years. Sure rust has some problems and yes the async isn&#x27;t fully there yet, but overal the benefits outweigh the problems.</div><br/><div id="37443451" class="c"><input type="checkbox" id="c-37443451" checked=""/><div class="controls bullet"><span class="by">NalNezumi</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439589">parent</a><span>|</span><a href="#37440171">next</a><span>|</span><label class="collapse" for="c-37443451">[-]</label><label class="expand" for="c-37443451">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, is this robotics simulator open source&#x2F;available?</div><br/></div></div><div id="37440171" class="c"><input type="checkbox" id="c-37440171" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439589">parent</a><span>|</span><a href="#37443451">prev</a><span>|</span><a href="#37443248">next</a><span>|</span><label class="collapse" for="c-37440171">[-]</label><label class="expand" for="c-37440171">[2 more]</label></div><br/><div class="children"><div class="content">Async as a paradigm seems so against what GP was discussing. If I understood, and from my experience, we&#x27;re talking more about concurrent execution with carefully-designed priorities, locks, and timing requirements. This is closer to the embedded &#x2F; systems-level concurrency, if I understand it right. Are we really expecting a coroutine&#x2F; async style to just lift into this world?</div><br/><div id="37440393" class="c"><input type="checkbox" id="c-37440393" checked=""/><div class="controls bullet"><span class="by">acedTrex</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440171">parent</a><span>|</span><a href="#37443248">next</a><span>|</span><label class="collapse" for="c-37440393">[-]</label><label class="expand" for="c-37440393">[1 more]</label></div><br/><div class="children"><div class="content">This was my thoughts, async is just ONE valid approach to the ultimate problem of &quot;do multiple things at once&quot; it is not the end all be all of approaches</div><br/></div></div></div></div></div></div><div id="37443248" class="c"><input type="checkbox" id="c-37443248" checked=""/><div class="controls bullet"><span class="by">Reticularas</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37439589">prev</a><span>|</span><a href="#37439780">next</a><span>|</span><label class="collapse" for="c-37443248">[-]</label><label class="expand" for="c-37443248">[1 more]</label></div><br/><div class="children"><div class="content">What you&#x27;ve just described is basically every networked video game, the majority of which are happily running via c++.<p>(Plus some increase in content load over the network, which does exist ala runtime mod loading, streaming, etc)</div><br/></div></div><div id="37439780" class="c"><input type="checkbox" id="c-37439780" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37443248">prev</a><span>|</span><a href="#37443355">next</a><span>|</span><label class="collapse" for="c-37439780">[-]</label><label class="expand" for="c-37439780">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is race condition free, but not deadlock free. It needs a static deadlock analyzer, one that tracks through the call chain and finds that lock A is locked before lock B on path X, while lock B is locked before path A on path Y.<p>That sounds like a great idea. Something in the style of lockdep, that (when enabled) analyzes what locks are currently held while any other lock is taken, and reports any potential deadlocks (even if they haven&#x27;t actually deadlocked).<p>That would require some annotation to handle cases of complex locking, so that the deadlock detection knows (for instance) that a given class of locks are always obtained in address order so they can&#x27;t deadlock. But it&#x27;s doable.</div><br/><div id="37442084" class="c"><input type="checkbox" id="c-37442084" checked=""/><div class="controls bullet"><span class="by">elabajaba</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439780">parent</a><span>|</span><a href="#37441238">next</a><span>|</span><label class="collapse" for="c-37442084">[-]</label><label class="expand" for="c-37442084">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s tracing-mutex that builds a dag of your locks when you acquire them and panics (at runtime) if it could deadlock: <a href="https:&#x2F;&#x2F;github.com&#x2F;bertptrs&#x2F;tracing-mutex">https:&#x2F;&#x2F;github.com&#x2F;bertptrs&#x2F;tracing-mutex</a><p>parking_lot has a deadlock detection feature for when you deadlock that iirc tells you what deadlocked (so you&#x27;re not trying to figure it out with a debugger and a lot of time) <a href="https:&#x2F;&#x2F;amanieu.github.io&#x2F;parking_lot&#x2F;parking_lot&#x2F;deadlock&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;amanieu.github.io&#x2F;parking_lot&#x2F;parking_lot&#x2F;deadlock&#x2F;i...</a><p>I also just found out about <a href="https:&#x2F;&#x2F;github.com&#x2F;BurtonQin&#x2F;lockbud">https:&#x2F;&#x2F;github.com&#x2F;BurtonQin&#x2F;lockbud</a> which seems to detect deadlocks and a few other issues statically? (seems to require compiling your crate with the same version of rust as lockbud uses, which from the docs is an old 1.63 nightly build?)</div><br/></div></div><div id="37441238" class="c"><input type="checkbox" id="c-37441238" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439780">parent</a><span>|</span><a href="#37442084">prev</a><span>|</span><a href="#37442296">next</a><span>|</span><label class="collapse" for="c-37441238">[-]</label><label class="expand" for="c-37441238">[1 more]</label></div><br/><div class="children"><div class="content">Google has acquired before: <a href="https:&#x2F;&#x2F;abseil.io&#x2F;docs&#x2F;cpp&#x2F;guides&#x2F;synchronization#thread-annotations" rel="nofollow noreferrer">https:&#x2F;&#x2F;abseil.io&#x2F;docs&#x2F;cpp&#x2F;guides&#x2F;synchronization#thread-ann...</a><p>It&#x27;s quite nice, but for cpp not rust</div><br/></div></div><div id="37442296" class="c"><input type="checkbox" id="c-37442296" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439780">parent</a><span>|</span><a href="#37441238">prev</a><span>|</span><a href="#37443355">next</a><span>|</span><label class="collapse" for="c-37442296">[-]</label><label class="expand" for="c-37442296">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if locks may have some thread-local registry, at least in debug builds.<p>If locks can be numbered or otherwise ordered, it would be easy to enforce a strict order of taking locks and an inverse strict order of releasing them, by looking up in the registry which locks your thread is currently holding. This would prevent deadlocks.<p>This, of course, would require to have an idea of all the locks you may want to hold, and their relative order (at least partial), as Dijkstra described back in the day. But thinking about locks is ahead of time is a good idea anyway.</div><br/></div></div></div></div><div id="37443355" class="c"><input type="checkbox" id="c-37443355" checked=""/><div class="controls bullet"><span class="by">ay</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37439780">prev</a><span>|</span><a href="#37440885">next</a><span>|</span><label class="collapse" for="c-37443355">[-]</label><label class="expand" for="c-37443355">[1 more]</label></div><br/><div class="children"><div class="content">As a past active SecondLife user back in the day (circa 15 years ago), and a short-stunt OpenSimulator dev, I had been thinking a lot about how much better SecondLife could be if it had the modern tech absorbed - thanks for doing this! :-) I did a short return to try SL recently, and the lagginess of the viewer made me sad.<p>Is there a ML to subscribe to, to learn when the viewer is more generally available for testing? Thanks again!</div><br/></div></div><div id="37440885" class="c"><input type="checkbox" id="c-37440885" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37443355">prev</a><span>|</span><a href="#37438421">next</a><span>|</span><label class="collapse" for="c-37440885">[-]</label><label class="expand" for="c-37440885">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Async is all wrong when there&#x27;s considerable compute-bound work, and incompatible with threads running at multiple priorities</i><p>The priority thing is relatively easy to fix:<p>Either create multiple thread pools, and route your futures to them appropriately.<p>Or, write your own event loop, and have it pull from more than one event queue (each with a different priority).<p>It should be even easier than that, but I don’t know of a crate that does the above out of the box.<p>One advantage of the second approach is (if your task runtime is bounded) that you can have soft realtime guarantees for high priority stuff even when you are making progress on low priority stuff and running at 100% CPU.</div><br/><div id="37441949" class="c"><input type="checkbox" id="c-37441949" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440885">parent</a><span>|</span><a href="#37438421">next</a><span>|</span><label class="collapse" for="c-37441949">[-]</label><label class="expand" for="c-37441949">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t help with priority inversions; since you don&#x27;t know who is waiting on a future&#x2F;promise until it starts waiting on it, you can&#x27;t resolve them until then, which means you can have work running at too low a priority. It&#x27;s not structured enough.</div><br/></div></div></div></div><div id="37438421" class="c"><input type="checkbox" id="c-37438421" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37440885">prev</a><span>|</span><a href="#37438823">next</a><span>|</span><label class="collapse" for="c-37438421">[-]</label><label class="expand" for="c-37438421">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m doing basically the same thing in Java for an MMO and the JDK makes it so easy. Just move objects via concurrent queues from network to model creation to UI threads. It&#x27;s actually quite boring, and fast!</div><br/><div id="37438644" class="c"><input type="checkbox" id="c-37438644" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438421">parent</a><span>|</span><a href="#37438823">next</a><span>|</span><label class="collapse" for="c-37438644">[-]</label><label class="expand" for="c-37438644">[5 more]</label></div><br/><div class="children"><div class="content">Is there video or a demo?</div><br/><div id="37438725" class="c"><input type="checkbox" id="c-37438725" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438644">parent</a><span>|</span><a href="#37438823">next</a><span>|</span><label class="collapse" for="c-37438725">[-]</label><label class="expand" for="c-37438725">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have anything recorded from the past few years. Here&#x27;s an old video:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;L7XIFC2SawY?si=qN7TNxZi-P05uXVa" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;L7XIFC2SawY?si=qN7TNxZi-P05uXVa</a><p>It&#x27;s basically a custom 3D multithreaded OSM renderer, and the assets are a custom binary format. Uses very little network bandwidth.<p>Hoping to have an update this year that shows the updated graphics. I wrote a UI framework to improve my productivity (live hot reloading of UI components written with HTML with one way data binding. I had to do this because the game is gonna have so many UIs and I got tired of writing them in Java 8 style Java. Soon I can resume work on the game after sidewaysdata.com is doneish (also using the UI library to build the desktop&#x2F;mobile timing application).</div><br/><div id="37438838" class="c"><input type="checkbox" id="c-37438838" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438725">parent</a><span>|</span><a href="#37438911">next</a><span>|</span><label class="collapse" for="c-37438838">[-]</label><label class="expand" for="c-37438838">[1 more]</label></div><br/><div class="children"><div class="content">You can sign up to be notified if I ever get it done :) here <a href="https:&#x2F;&#x2F;tdworldgame.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tdworldgame.com&#x2F;</a></div><br/></div></div><div id="37438911" class="c"><input type="checkbox" id="c-37438911" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438725">parent</a><span>|</span><a href="#37438838">prev</a><span>|</span><a href="#37438823">next</a><span>|</span><label class="collapse" for="c-37438911">[-]</label><label class="expand" for="c-37438911">[2 more]</label></div><br/><div class="children"><div class="content">Nice.<p>The &quot;many UI&quot; problem is large in Rust. Egui needs far too much Rust code per dialog box. Someone was working on a generator, but I haven&#x27;t looked in on that project in a while.</div><br/><div id="37439433" class="c"><input type="checkbox" id="c-37439433" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438911">parent</a><span>|</span><a href="#37438823">next</a><span>|</span><label class="collapse" for="c-37439433">[-]</label><label class="expand" for="c-37439433">[1 more]</label></div><br/><div class="children"><div class="content">I actually quite liked egui. It was Rust that felt too slow to write. Also the egui template project with eframe and no app code yet took 15 seconds for an incremental compile. The entire game so far compiles and starts faster than that in Java, so...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37438823" class="c"><input type="checkbox" id="c-37438823" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37438421">prev</a><span>|</span><a href="#37438677">next</a><span>|</span><label class="collapse" for="c-37438823">[-]</label><label class="expand" for="c-37438823">[1 more]</label></div><br/><div class="children"><div class="content">Good luck on the metaverse app! I&#x27;d love to see more interesting metaverse takes.<p>One quibble though. Rust isn&#x27;t race condition free, it&#x27;s data race free. You can still end up with race conditions outside of data access. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23599598">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23599598</a></div><br/></div></div><div id="37438677" class="c"><input type="checkbox" id="c-37438677" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37438823">prev</a><span>|</span><a href="#37441520">next</a><span>|</span><label class="collapse" for="c-37438677">[-]</label><label class="expand" for="c-37438677">[6 more]</label></div><br/><div class="children"><div class="content">Cheering for your metaverse app. Hope to hear more about it. I suspected you might be doing gamedev but this is the first time you’ve shown extensive work.<p>One challenge with rust is that (for better or worse) most gamedev talent is C++. If you ever open source it I’d be interested in contributing, though I’m not sure how effective the contributions would be.<p>Good luck!</div><br/><div id="37438755" class="c"><input type="checkbox" id="c-37438755" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438677">parent</a><span>|</span><a href="#37441520">next</a><span>|</span><label class="collapse" for="c-37438755">[-]</label><label class="expand" for="c-37438755">[5 more]</label></div><br/><div class="children"><div class="content">Email sent.<p>I&#x27;m not that interested in self-promotion here as I am in getting more activity on Rust graphics development. I think the Rust core graphics ecosystem needs about five good graphics people for a year to get unstuck.
Rust is a good language for this sort of thing, but you&#x27;ve got to have reliable heavy machinery down in the graphics engine room.<p>Until that exists, nobody can bet a project with a schedule and a budget on Rust. The only successful commercial high-detail game title I know of that uses Rust is a sailing race simulator. They simply linked directly to &quot;good old DX11&quot; (Microsoft Direct-X 11) and wrote the game logic in Rust. Bypassed Rust&#x27;s own 3D ecosystems completely.</div><br/><div id="37443016" class="c"><input type="checkbox" id="c-37443016" checked=""/><div class="controls bullet"><span class="by">d3ckard</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438755">parent</a><span>|</span><a href="#37439712">next</a><span>|</span><label class="collapse" for="c-37443016">[-]</label><label class="expand" for="c-37443016">[1 more]</label></div><br/><div class="children"><div class="content">Any pointers on what exactly is missing?<p>I am neither a Rust guy or a graphics guy, but I have some interest in what is missing in the ecosystem.</div><br/></div></div><div id="37439712" class="c"><input type="checkbox" id="c-37439712" checked=""/><div class="controls bullet"><span class="by">xeonmc</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438755">parent</a><span>|</span><a href="#37443016">prev</a><span>|</span><a href="#37441520">next</a><span>|</span><label class="collapse" for="c-37439712">[-]</label><label class="expand" for="c-37439712">[3 more]</label></div><br/><div class="children"><div class="content">Is it the one by the same guy who made the gold-standard moddable racing simulator?</div><br/><div id="37440587" class="c"><input type="checkbox" id="c-37440587" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439712">parent</a><span>|</span><a href="#37441177">next</a><span>|</span><label class="collapse" for="c-37440587">[-]</label><label class="expand" for="c-37440587">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s &quot;Hydrofoil Generation&quot;.[1] The only game on the &quot;Released&quot; page of the Rust gaming group that looks post-2000.<p>[1] <a href="https:&#x2F;&#x2F;arewegameyet.rs&#x2F;games&#x2F;released&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;arewegameyet.rs&#x2F;games&#x2F;released&#x2F;</a></div><br/></div></div><div id="37441177" class="c"><input type="checkbox" id="c-37441177" checked=""/><div class="controls bullet"><span class="by">thegeekpirate</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439712">parent</a><span>|</span><a href="#37440587">prev</a><span>|</span><a href="#37441520">next</a><span>|</span><label class="collapse" for="c-37441177">[-]</label><label class="expand" for="c-37441177">[1 more]</label></div><br/><div class="children"><div class="content">He co-founded and was the lead dev of Kunos Simulazioni, which made Assetto Corsa (<a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;244210&#x2F;Assetto_Corsa&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;244210&#x2F;Assetto_Corsa&#x2F;</a>).<p>I miss his Twitch streams! <a href="https:&#x2F;&#x2F;www.twitch.tv&#x2F;kunosstefano" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.twitch.tv&#x2F;kunosstefano</a></div><br/></div></div></div></div></div></div></div></div><div id="37441520" class="c"><input type="checkbox" id="c-37441520" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37438677">prev</a><span>|</span><a href="#37441178">next</a><span>|</span><label class="collapse" for="c-37441520">[-]</label><label class="expand" for="c-37441520">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Single ownership with a back reference is a very common need, and it&#x27;s too hard to do.<p>I&#x27;ve been collecting a list[1] of what memory-management policies programmers actually <i>want</i> in their code; it is far more extensive than any particular language actually implements. Contributions are welcome!<p>I already had back reference on the list, but added some details. When the ownership is indirect (really common) it is difficult to automate.<p>One thing that always irritates me: Rust&#x27;s decision to make <i>all</i> objects moveable really hurts it at times.<p>[1] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;o11c&#x2F;dee52f11428b3d70914c4ed5652d43f7" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;o11c&#x2F;dee52f11428b3d70914c4ed5652d43f...</a></div><br/><div id="37442197" class="c"><input type="checkbox" id="c-37442197" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441520">parent</a><span>|</span><a href="#37441178">next</a><span>|</span><label class="collapse" for="c-37442197">[-]</label><label class="expand" for="c-37442197">[1 more]</label></div><br/><div class="children"><div class="content">Yes, back-linked objects are probably going to have to be pinned.</div><br/></div></div></div></div><div id="37441178" class="c"><input type="checkbox" id="c-37441178" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37441520">prev</a><span>|</span><a href="#37440347">next</a><span>|</span><label class="collapse" for="c-37441178">[-]</label><label class="expand" for="c-37441178">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Async contamination<p>I&#x27;ve always wondered why the &quot;color&quot; of a function can&#x27;t be a property of its <i>call site</i> instead of its <i>definition</i>. That would completely solve this problem - you declare your functions <i>once</i>, colorlessly, and then can invoke them as async anywhere you want.</div><br/><div id="37441545" class="c"><input type="checkbox" id="c-37441545" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441178">parent</a><span>|</span><a href="#37443027">next</a><span>|</span><label class="collapse" for="c-37441545">[-]</label><label class="expand" for="c-37441545">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve always wondered why the &quot;color&quot; of a function can&#x27;t be a property of its call site instead of its definition. That would completely solve this problem - you declare your functions once, colorlessly, and then can invoke them as async anywhere you want.<p>If you have a non-joke type system (which is to say, Haskell or Scala) you can. I do it all the time. But you need HKT and in Rust each baby step towards that is an RFC buried under a mountain of discussion.</div><br/><div id="37441636" class="c"><input type="checkbox" id="c-37441636" checked=""/><div class="controls bullet"><span class="by">OvermindDL1</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441545">parent</a><span>|</span><a href="#37443027">next</a><span>|</span><label class="collapse" for="c-37441636">[-]</label><label class="expand" for="c-37441636">[1 more]</label></div><br/><div class="children"><div class="content">You can do it without HKTs with an effects system, which you can think of as another kind of generics that causes the function to be sliced in different ways depending on how it&#x27;s called.  There is movement in Rust to try to do this, but I wish it was done before async was implemented considering async could be implemented within it...</div><br/></div></div></div></div><div id="37443027" class="c"><input type="checkbox" id="c-37443027" checked=""/><div class="controls bullet"><span class="by">ditsuke</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441178">parent</a><span>|</span><a href="#37441545">prev</a><span>|</span><a href="#37441256">next</a><span>|</span><label class="collapse" for="c-37443027">[-]</label><label class="expand" for="c-37443027">[1 more]</label></div><br/><div class="children"><div class="content">The rust guys are working on this very problem with the keyword generics proposal
<a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2022&#x2F;07&#x2F;27&#x2F;keyword-generics.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2022&#x2F;07&#x2F;27&#x2F;keyword-ge...</a></div><br/></div></div><div id="37441256" class="c"><input type="checkbox" id="c-37441256" checked=""/><div class="controls bullet"><span class="by">kprotty</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441178">parent</a><span>|</span><a href="#37443027">prev</a><span>|</span><a href="#37441482">next</a><span>|</span><label class="collapse" for="c-37441256">[-]</label><label class="expand" for="c-37441256">[2 more]</label></div><br/><div class="children"><div class="content">If a function calls something that does something async, that can&#x27;t be evaluated synchronously due to 1) no setup; could be async IO and require being called in the context of an async runtime (library feature, not language feature) and 2) blocking synchronously on an async task in an async runtime can result in deadlocks from task waiting on runtime IO polling but the waiting preventing the runtime from being polled.</div><br/><div id="37441588" class="c"><input type="checkbox" id="c-37441588" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441256">parent</a><span>|</span><a href="#37441482">next</a><span>|</span><label class="collapse" for="c-37441588">[-]</label><label class="expand" for="c-37441588">[1 more]</label></div><br/><div class="children"><div class="content">&gt; could be async IO and require being called in the context of an async runtime<p>The compiler already has knowledge that a function is being called as async - what prevents it from ensuring that a runtime is present when it does?<p>&gt; blocking synchronously on an async task in an async runtime can result in deadlocks from task waiting on runtime IO polling but the waiting preventing the runtime from being polled<p>What prevents the runtime from preempting a task?</div><br/></div></div></div></div><div id="37441482" class="c"><input type="checkbox" id="c-37441482" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441178">parent</a><span>|</span><a href="#37441256">prev</a><span>|</span><a href="#37440347">next</a><span>|</span><label class="collapse" for="c-37441482">[-]</label><label class="expand" for="c-37441482">[1 more]</label></div><br/><div class="children"><div class="content">I most runtimes you can just call something like `block_on`. There are some things to be careful about to avoid starving other takes but most general-purpose runtimes will spawn more threads as needed. Similarly blocking in an asynx task is generally not much of an issue for these runtimes for the same reasons.<p>It isn&#x27;t like JavaScript where there is truly only one thread of execution at a time and blocking it will block <i>everything</i>.</div><br/></div></div></div></div><div id="37440347" class="c"><input type="checkbox" id="c-37440347" checked=""/><div class="controls bullet"><span class="by">bigyikes</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37441178">prev</a><span>|</span><a href="#37441345">next</a><span>|</span><label class="collapse" for="c-37440347">[-]</label><label class="expand" for="c-37440347">[4 more]</label></div><br/><div class="children"><div class="content">I’m working on an unrelated project that does some stuff similarly to you. I’m at 4k lines right now.<p>Just wondering, how long did it take you to hit 40k lines? I’m a new Rust developer and it’s taken me ages to get this far.<p>I totally relate to your experience though. When I finally get my code to compile, it “just works” without crashes. I’ve never felt so confident in my code before.</div><br/><div id="37440383" class="c"><input type="checkbox" id="c-37440383" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440347">parent</a><span>|</span><a href="#37442441">next</a><span>|</span><label class="collapse" for="c-37440383">[-]</label><label class="expand" for="c-37440383">[2 more]</label></div><br/><div class="children"><div class="content">&gt; how long did it take you to hit 40k lines?<p>3 years.</div><br/><div id="37440404" class="c"><input type="checkbox" id="c-37440404" checked=""/><div class="controls bullet"><span class="by">bigyikes</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440383">parent</a><span>|</span><a href="#37442441">next</a><span>|</span><label class="collapse" for="c-37440404">[-]</label><label class="expand" for="c-37440404">[1 more]</label></div><br/><div class="children"><div class="content">Impressive dedication! I hope I can make it that long. The project looks cool and the technical details sound even cooler.<p>Thanks for the perspective.</div><br/></div></div></div></div><div id="37442441" class="c"><input type="checkbox" id="c-37442441" checked=""/><div class="controls bullet"><span class="by">jksmith</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440347">parent</a><span>|</span><a href="#37440383">prev</a><span>|</span><a href="#37441345">next</a><span>|</span><label class="collapse" for="c-37442441">[-]</label><label class="expand" for="c-37442441">[1 more]</label></div><br/><div class="children"><div class="content">&gt;When I finally get my code to compile, it “just works” without crashes. I’ve never felt so confident in my code before.<p>This isn&#x27;t a new idea for a desirable state. Same experience with Modula-2 three decades ago. A page or more of compiler errors to clear, then suddenly adiabatic. A very satisfying experience.</div><br/></div></div></div></div><div id="37441345" class="c"><input type="checkbox" id="c-37441345" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37440347">prev</a><span>|</span><a href="#37438978">next</a><span>|</span><label class="collapse" for="c-37441345">[-]</label><label class="expand" for="c-37441345">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, why not go all in on Tokio? Make everything a future, including writing to the GPU.<p>And are you using an ECS based architecture? Do you feel you’d have a different opinion if you were?</div><br/></div></div><div id="37438978" class="c"><input type="checkbox" id="c-37438978" checked=""/><div class="controls bullet"><span class="by">jstx1</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37441345">prev</a><span>|</span><a href="#37439958">next</a><span>|</span><label class="collapse" for="c-37438978">[-]</label><label class="expand" for="c-37438978">[36 more]</label></div><br/><div class="children"><div class="content">&gt;  Yes, sometimes you can get stuck for a day, trying to express something within the ownership rules.<p>This is a big problem. Fast iteration time is very valuable.<p>And who likes doing this to themselves anyway? Isn&#x27;t it a very frustrating experience? How is this the most loved language?</div><br/><div id="37439853" class="c"><input type="checkbox" id="c-37439853" checked=""/><div class="controls bullet"><span class="by">ghosty141</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438978">parent</a><span>|</span><a href="#37441167">next</a><span>|</span><label class="collapse" for="c-37439853">[-]</label><label class="expand" for="c-37439853">[17 more]</label></div><br/><div class="children"><div class="content">&gt; And who likes doing this to themselves anyway? Isn&#x27;t it a very frustrating experience? How is this the most loved language?<p>The thing is, these dependencies do exist no matter what language you use if they stem from an underlying concept. In that case rust just makes you explicitly write them which is a good thing since in C++ all these dependencies would be more or less implicit and everytime somebody edits the code he needs to think all these cases through and get a mental model (if he sees it at all!). In Rust you at least have the lifetime annotations which make it A: obvious there is some special dependency going on and B: show the explicit lifetimes etc.<p>So what I&#x27;m saying, you need to put in this work no matter which language you choose, writing it down is then not a big problem anymore. If you don&#x27;t think about these rules your program will probably work most of the time but only most of the time, and that can be very bad for certain scenarios.</div><br/><div id="37441120" class="c"><input type="checkbox" id="c-37441120" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439853">parent</a><span>|</span><a href="#37441602">next</a><span>|</span><label class="collapse" for="c-37441120">[-]</label><label class="expand" for="c-37441120">[10 more]</label></div><br/><div class="children"><div class="content">&gt; So what I&#x27;m saying, you need to put in this work no matter which language you choose<p>This is very false. Managed-memory languages don&#x27;t require you to even <i>think</i> about lifetimes, let alone write them down.<p>Yes, I understand that this is for efficiency - but claiming that you have to think about lifetimes everywhere is just wrong, and irrelevant when discussing topics (prototyping&#x2F;design work&#x2F;scripting) where you don&#x27;t <i>care</i> about efficiency.</div><br/><div id="37442957" class="c"><input type="checkbox" id="c-37442957" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441120">parent</a><span>|</span><a href="#37441310">next</a><span>|</span><label class="collapse" for="c-37442957">[-]</label><label class="expand" for="c-37442957">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Managed-memory languages don&#x27;t require you to even think about lifetimes, let alone write them down.<p>Memory is only one of many types of resources applications use. Memory-managed languages do nothing to help you with those resources, and effectively managing those resources is way harder in those languages than in Rust or C++.</div><br/></div></div><div id="37441310" class="c"><input type="checkbox" id="c-37441310" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441120">parent</a><span>|</span><a href="#37442957">prev</a><span>|</span><a href="#37441602">next</a><span>|</span><label class="collapse" for="c-37441310">[-]</label><label class="expand" for="c-37441310">[8 more]</label></div><br/><div class="children"><div class="content">Lifetimes are still important in managed languages. You just have to track them in your head, which is fallible. The difference is that if you get it wrong in a managed language, you get leaks or stale objects or other logic bugs. In rust you get compile time errors.</div><br/><div id="37442330" class="c"><input type="checkbox" id="c-37442330" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441310">parent</a><span>|</span><a href="#37441329">next</a><span>|</span><label class="collapse" for="c-37442330">[-]</label><label class="expand" for="c-37442330">[2 more]</label></div><br/><div class="children"><div class="content">While this is correct, it&#x27;s still <i>much</i> easier to think about lifetimes in managed languages. The huge majority of allocated objects gets garbage-collected after a very short time, when they leave the context (similar to RAII).<p>Mostly you need to think about large and&#x2F;or important objects, and avoid cycles, and avoid unneeded references to such objects that would live for too long. Such cases are few.<p>The silver lining is that if you make a mistake and a large object would have to live slightly longer, you won&#x27;t have to wrangle with the lifetime checker for that small sliver of lifetime. But if you make a big mistake, nothing will warn you about a memory leak, before the prod monitoring does.</div><br/><div id="37442980" class="c"><input type="checkbox" id="c-37442980" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37442330">parent</a><span>|</span><a href="#37441329">next</a><span>|</span><label class="collapse" for="c-37442980">[-]</label><label class="expand" for="c-37442980">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The huge majority of allocated objects gets garbage-collected after a very short time, when they leave the context (similar to RAII).<p>Those objects are also virtually no problem in languages like Rust or C++. Those are local objects whose lifetimes are trivial and they are managed automatically with no additional effort from the developer.</div><br/></div></div></div></div><div id="37441329" class="c"><input type="checkbox" id="c-37441329" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441310">parent</a><span>|</span><a href="#37442330">prev</a><span>|</span><a href="#37441602">next</a><span>|</span><label class="collapse" for="c-37441329">[-]</label><label class="expand" for="c-37441329">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The difference is that if you get it wrong in a managed language, you get leaks or stale objects or other logic bugs.<p>Can you provide concrete examples of this? I&#x27;ve literally never had a bug due to the nature of a memory-managed language.</div><br/><div id="37442407" class="c"><input type="checkbox" id="c-37442407" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441329">parent</a><span>|</span><a href="#37441957">next</a><span>|</span><label class="collapse" for="c-37442407">[-]</label><label class="expand" for="c-37442407">[1 more]</label></div><br/><div class="children"><div class="content">Once upon a time (at least through IE7) Internet Explorer had separate memory managers for javascript and the DOM. If there was a cycle between a JS object and a DOM object (a DOM node is assigned as a property of an object, and another property was assigned as an event handler to the DOM node) then IE couldn&#x27;t reclaim the memory.<p>Developers of anything resembling complex scripts (for the time) had to manually break these cycles by setting to null the attributes of the DOM node that had references to any JS objects.<p>Douglas Crockford has a little writeup here[0] with a heavy-handed solution, but it was better than doing it by hand if you were worried another developer would come along and add something and forget to remove it.<p>Other memory managed languages also have to deal with the occasional sharp corners. Most of the time, this can be avoided by knowing to clean up resources properly, but some are easier to fall for than others.<p>Oracle has a write up on hunting Java memory leaks [1]
Microsoft has a similar, but less detailed article here[2]<p>Of course, sometimes a &quot;leak&quot; is really a feature. One notorious example is variable shadowing in the bad old days of JS prior to the advent of strict mode. I forget the name of the company, but someone&#x27;s launch was ruined because a variable referencing a shopping cart wasn&#x27;t declared with `var` and was treated as a global variable, causing concurrent viewers to accidentally get other user&#x27;s shopping cart data as node runs in a single main thread, and concurrency was handled only by node&#x27;s event loop.<p>[0] <a href="https:&#x2F;&#x2F;www.crockford.com&#x2F;javascript&#x2F;memory&#x2F;leak.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.crockford.com&#x2F;javascript&#x2F;memory&#x2F;leak.html</a><p>[1] <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;17&#x2F;troubleshoot&#x2F;troubleshooting-memory-leaks.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;17&#x2F;troubleshoot&#x2F;troub...</a><p>[2] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;diagnostics&#x2F;debug-memory-leak" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;diagnostics&#x2F;de...</a></div><br/></div></div><div id="37441957" class="c"><input type="checkbox" id="c-37441957" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441329">parent</a><span>|</span><a href="#37442407">prev</a><span>|</span><a href="#37441652">next</a><span>|</span><label class="collapse" for="c-37441957">[-]</label><label class="expand" for="c-37441957">[2 more]</label></div><br/><div class="children"><div class="content">You can certainly get memory abandonment, which is like a leak but for memory that&#x27;s still referenced and is just never going to be used again.</div><br/><div id="37442943" class="c"><input type="checkbox" id="c-37442943" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441957">parent</a><span>|</span><a href="#37441652">next</a><span>|</span><label class="collapse" for="c-37442943">[-]</label><label class="expand" for="c-37442943">[1 more]</label></div><br/><div class="children"><div class="content">I will note that in GC literature at least, that is still considered a leak.<p>In an ideal world, we could have a GC that reclaimed all unused memory, but that turns out to be impossible because of the halting problem. So, we settle for GCs that reclaim only unreachable memory, which is a strict subset of unused memory. Unused reachable memory is a leak.</div><br/></div></div></div></div><div id="37441652" class="c"><input type="checkbox" id="c-37441652" checked=""/><div class="controls bullet"><span class="by">OvermindDL1</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441329">parent</a><span>|</span><a href="#37441957">prev</a><span>|</span><a href="#37441602">next</a><span>|</span><label class="collapse" for="c-37441652">[-]</label><label class="expand" for="c-37441652">[1 more]</label></div><br/><div class="children"><div class="content">CMEs in Java are a constant thorn to many Java programmers as a lifetime violation bug.  Hell even NPEs are too for that matter, lol.</div><br/></div></div></div></div></div></div></div></div><div id="37441602" class="c"><input type="checkbox" id="c-37441602" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439853">parent</a><span>|</span><a href="#37441120">prev</a><span>|</span><a href="#37441167">next</a><span>|</span><label class="collapse" for="c-37441602">[-]</label><label class="expand" for="c-37441602">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The thing is, these dependencies do exist no matter what language you use<p>Sure, but in a lot of cases, these invariants can be trivially explained, or intuitive enough that it wouldn&#x27;t even need explanation. While in Rust, you can easily spend a full day just explaining it to the compiler.<p>I remember spending litteral _days_ tweaking intricate lifetimes and scopes just to promise Rust that some variables won&#x27;t be used _after_ a thread finishes.<p>Some things I even never managed to be able to express in Rust, even if trivial in C, so I just rely on having a C core library for the hot path, and use it from Rust.<p>Overall, performance sensitive lifetime and memory management in Rust (especially in multithreaded contexts) often comes down to:<p>1) Do it in _sane_ Rust, and copy everything all over the place, use fancy smart pointers, etc.<p>2) Do it in a performant manner, without useless copies, without over the top memory management, but prepare a week of frustrating development and a PhD in Rust idiosyncrasies.</div><br/><div id="37441920" class="c"><input type="checkbox" id="c-37441920" checked=""/><div class="controls bullet"><span class="by">efficax</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441602">parent</a><span>|</span><a href="#37443312">next</a><span>|</span><label class="collapse" for="c-37441920">[-]</label><label class="expand" for="c-37441920">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Some things I even never managed to be able to express in Rust, even if trivial in C, so I just rely on having a C core library for the hot path, and use it from Rust.<p>i can’t think of anything you can do in c that you can’t do in unsafe rust, and that has the advantage that you can both narrow it down to exactly where you need it and only there, and your can test it in miri to find bugs</div><br/><div id="37442250" class="c"><input type="checkbox" id="c-37442250" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441920">parent</a><span>|</span><a href="#37442112">next</a><span>|</span><label class="collapse" for="c-37442250">[-]</label><label class="expand" for="c-37442250">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, unsafe Rust has an entirely new set of idiosyncrasies that you have to learn for your code not to cause UB. Most of them revolve around the many ways in which using references can invalidate raw pointers, and using raw pointers can invalidate references, something that simply doesn&#x27;t exist in C apart from the rarely-used restrict qualifier.<p>(In particular, it&#x27;s very easy to inadvertently trigger the footgun of converting a pointer to a reference, then back to a pointer, so that using the original pointer again can invalidate the new pointer.)<p>Extremely pointer-heavy code is entirely possible in unsafe Rust, but often it&#x27;s far more difficult to correctly express what you want compared to C. With that in mind, a tightly-scoped core library in C can make a lot of sense; more lines of unsafe code in either language leave more room for bugs to slip in.</div><br/></div></div><div id="37442112" class="c"><input type="checkbox" id="c-37442112" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441920">parent</a><span>|</span><a href="#37442250">prev</a><span>|</span><a href="#37443312">next</a><span>|</span><label class="collapse" for="c-37442112">[-]</label><label class="expand" for="c-37442112">[1 more]</label></div><br/><div class="children"><div class="content">&gt; i can’t think of anything you can do in c that you can’t do in unsafe rust<p>That is not my point.<p>There is a world between &quot;you can do it&quot; and &quot;you will do it&quot;.<p>Some things in Rust are doable in theory, but end up being so insane to implement that you won&#x27;t do it in practice. That is my point.</div><br/></div></div></div></div><div id="37443312" class="c"><input type="checkbox" id="c-37443312" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441602">parent</a><span>|</span><a href="#37441920">prev</a><span>|</span><a href="#37441167">next</a><span>|</span><label class="collapse" for="c-37443312">[-]</label><label class="expand" for="c-37443312">[2 more]</label></div><br/><div class="children"><div class="content">&gt;use fancy smart pointers, etc.<p>The thing is, you think your code is safe and it most likely is, but mathematically speaking, what you are doing is difficult or even impossible to prove correct. It is akin to running an NP complete algorithm on a problem that is easier than NP. Most practical problem instances are easy to solve, but the worst case which can&#x27;t be ruled out is utterly, utterly terrible, which forces you to use a more general solution than is actually necessary.</div><br/><div id="37443391" class="c"><input type="checkbox" id="c-37443391" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37443312">parent</a><span>|</span><a href="#37441167">next</a><span>|</span><label class="collapse" for="c-37443391">[-]</label><label class="expand" for="c-37443391">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t let perfect be the enemy of good.<p>Since smart pointers because ubiquitous in c++, I&#x27;ve (personally) had only a handful of memory and lifetime issues. They were all deduceable by looking at where we &quot;escape hatched&quot; and stored a raw ptr that was actually a unique pointer, or something similar. I&#x27;ll take having one of those every 18 months over throwing away my entire language, toolchain,ecosystem and iteration times.</div><br/></div></div></div></div></div></div></div></div><div id="37441167" class="c"><input type="checkbox" id="c-37441167" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438978">parent</a><span>|</span><a href="#37439853">prev</a><span>|</span><a href="#37439605">next</a><span>|</span><label class="collapse" for="c-37441167">[-]</label><label class="expand" for="c-37441167">[3 more]</label></div><br/><div class="children"><div class="content">&gt; How is this the most loved language?<p>Personal preference and pain tolerance. Just like learning Emacs[1] - there&#x27;s lots of things that programmers can prioritize, ignore, enjoy, or barely tolerate. Some people are alright with the fact that they&#x27;re prototyping their code 10x more slowly than in another language because they enjoy performance optimization and seeing their code run fast, and there&#x27;s nothing wrong with that. I, myself, have wasted a lot of time trying to get the types in some of my programs <i>just right</i> - but I enjoy it, so it&#x27;s worth it, even though my productivity has decreased.<p>Plus, Rust seems to have pushed out the language design performance-productivity-safety efficiency frontier in the area of performance-focused languages. If you&#x27;re a performance-oriented programmer used to buggy programs that take a long time to build, then a language that gives you the performance you&#x27;re used to with far fewer bugs and faster development time is <i>really cool</i>, even if it&#x27;s still very un-productive next to productivity-oriented languages (e.g. Python). If something similar happened with productivity languages, I&#x27;d get excited, too - actually, I think that&#x27;s what&#x27;s happening with Mojo currently (same productivity, greater performance) and I&#x27;m very interested.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37438842">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37438842</a></div><br/><div id="37442779" class="c"><input type="checkbox" id="c-37442779" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441167">parent</a><span>|</span><a href="#37443380">next</a><span>|</span><label class="collapse" for="c-37442779">[-]</label><label class="expand" for="c-37442779">[1 more]</label></div><br/><div class="children"><div class="content">&gt; even if it&#x27;s still very un-productive next to productivity-oriented languages (e.g. Python).<p>The thing is, for many people, including me,  Rust is actually a more productive language than Python or other dynamic languages. Actually writing Python was an endless source of pain for me - this was the only language where my code did <i>not</i> initially work as expected more times than it did. Where in Rust it works fine from the first go in 99% of cases after it compiles, which is a huge productivity boost. And quite surprisingly, even <i>writing</i> the code in Rust was faster for me, due to more reliable autocomplete &#x2F; inline docs features of my IDE.</div><br/></div></div><div id="37443380" class="c"><input type="checkbox" id="c-37443380" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441167">parent</a><span>|</span><a href="#37442779">prev</a><span>|</span><a href="#37439605">next</a><span>|</span><label class="collapse" for="c-37443380">[-]</label><label class="expand" for="c-37443380">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some people are alright with the fact that they&#x27;re prototyping their code 10x more slowly than in another language because they enjoy performance optimization and seeing their code run fast, and there&#x27;s nothing wrong with that.<p>Disclaimer: I&#x27;ve sort of bounced off of Rust 3 or so times and while I&#x27;ve created both long-running services in it as well as smaller tools I&#x27;ve basically mostly had a hard time (not enjoying it at all, feeling like I&#x27;m paying a lot in terms of development friction for very little gain, etc.) and if you&#x27;re the type to write off most posts with &quot;You just don&#x27;t get it&quot; this would probably just be one more on the pile.<p>From personal experience: You could be prototyping your code faster and get performance in simpler ways than dealing with the borrow checker by being able to express allocation patterns and memory usage in better, clearer ways instead and avoid both of the stated problems.<p>Odin (&amp; Zig and other simpler languages) with access to these types of facilities are just an install away and are considerably easier to learn anyway. In fact, I think you could probably just learn both of them on top of what you&#x27;re doing in Rust since the time investment is negligible compared to it in the long run.<p>With regards to the upsides in terms of writing code in a performance-aware manner:<p>- It&#x27;s easier to look at a piece of code and confidently say it&#x27;s not doing any odd or potentially bad things with regards to performance in both Odin and Zig<p>- Both languages emphasize custom allocators which are a great boon to both application simplicity, flexibility and performance (set up limited memory space temporarily and make sure we can never use more, set up entire arenas that can be reclaimed or reused entirely, segment your resources up in different allocators that can&#x27;t possibly interfere with eachother and have their own memory space guaranteed, etc.)<p>- No one can use one-at-a-time constructs like RAII&#x2F;`Drop` behind your back so you don&#x27;t have to worry about stupid magic happening when things go out of scope that might completely ruin your cache, etc.<p>To borrow an argument from Rust proponents, you should be thinking about these things (allocation patterns) anyway and you&#x27;re doing yourself a disservice by leaving them up to magic or just doing them wrong. If your language can&#x27;t do what Odin and Zig does (pass them around, and in Odin you can inherit them from the calling scope which coupled with passing them around gives you incredible freedom) then you probably should try one where you can and where the ecosystem is based on that assumption.<p>My personal experience with first Zig and later Odin is that they&#x27;ve provided the absolute most productive experience I&#x27;ve ever had when it comes to the code that I had to write. I had to write more code because both ecosystems are tiny and I don&#x27;t really like extra dependencies regardless. Being able to actually write your dependencies yourself but have it be such a productive experience is liberating in so many ways.<p>Odin is my personal winner in the race between Odin and Zig. It&#x27;s a very close race but there are some key features in Odin that make it win out in the end:<p>- There is an implicit `context` parameter primarily used for passing around allocator and a logger that can be implicitly used for calls if you don&#x27;t specify one. This makes your code less chatty and let&#x27;s you talk only about the important things in some cases. I still prefer to be explicit about allocators in most plumbing but I&#x27;ll set `context.allocator` to some appropriate choice for smaller programs in `main` and let it go<p>- We can have proper tagged unions as errors and the language is built around it. This gives you code that looks and behaves a lot like you&#x27;ll be used to with `Result` and `Option` in Rust, with the same benefits.<p>- Errors are just values but the last value in a multiple-value-return function is understood as the error position if needed so we avoid the `if error != nil { ... }` that would otherwise exist if the language wasn&#x27;t made for this. We can instead use proper error values (that can be tagged unions) and `or_return`, i.e.:<p><pre><code>    doing_things :: proc() ParsingError {
        parsed_data := parse_config_file(filename) or_return
        ...
    }
</code></pre>
If we wanted to inspect the error this would instead be:<p><pre><code>    &#x2F;&#x2F; The zero value for a union is `nil` by default and the language understands this
    ParsingError :: union {
        UnparsableHeader,
        UnparsableBody,
    }

    UnparsableHeader :: struct {
        ...
    }

    UnparsableBody :: struct {
        ...
    }

    doing_things :: proc() {
        parsed_data, parsing_error := parse_config_file(filename)
        &#x2F;&#x2F; `p in parsing_error` here unpacks the tag of the union
        &#x2F;&#x2F; Notably there are no actual &quot;constructors&quot; like in Haskell
        &#x2F;&#x2F; and so a type can be part of many different unions with no syntax changes
        &#x2F;&#x2F; for checking for it.
        switch p in parsing_error {
        case UnparsableHeader:
            &#x2F;&#x2F; In this scope we have an `UnparsableHeader`
            function_that_deals_with_unparsable_header(p)
        case UnparsableBody:
            function_that_deals_with_unparsable_body(p)
        }

        ...
    }
</code></pre>
- ZVI or &quot;zero-value initialization&quot; means that all values are by default zero-initialized and have to have zero-values. The entire language and ecosystem is built around this idea and it works terrifically to allow you to actually talk only about the things that are important, once again.<p>P.S. If you want to make games or the like Odin has the absolute best ecosystem of any C alternative or C++ alternative out there, no contest. Largely this is because it ships with tons of game related bindings and also has language features dedicated entirely to dealing with vectors, matrices, etc., and is a joy to use for those things. I&#x27;d still put it forward as a winner with regards to most other areas but it really is an unfair race when it comes to games.</div><br/></div></div></div></div><div id="37439605" class="c"><input type="checkbox" id="c-37439605" checked=""/><div class="controls bullet"><span class="by">pshc</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438978">parent</a><span>|</span><a href="#37441167">prev</a><span>|</span><a href="#37442424">next</a><span>|</span><label class="collapse" for="c-37439605">[-]</label><label class="expand" for="c-37439605">[13 more]</label></div><br/><div class="children"><div class="content">Debugging rare crashes and heisenbugs is more frustrating, and in non-safe languages, a chronic problem.<p>Whereas after you prove the safety of a design once, it stays with you.</div><br/><div id="37439731" class="c"><input type="checkbox" id="c-37439731" checked=""/><div class="controls bullet"><span class="by">jstx1</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439605">parent</a><span>|</span><a href="#37441123">next</a><span>|</span><label class="collapse" for="c-37439731">[-]</label><label class="expand" for="c-37439731">[4 more]</label></div><br/><div class="children"><div class="content">It stays with you until you need to change something and find yourself unable to make incremental changes.<p>And in many use cases people are throwing Rust (and especially async Rust) on problems solved just fine with GC languages so the safety argument doesn’t apply there.</div><br/><div id="37439848" class="c"><input type="checkbox" id="c-37439848" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439731">parent</a><span>|</span><a href="#37443320">next</a><span>|</span><label class="collapse" for="c-37439848">[-]</label><label class="expand" for="c-37439848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; change something and find yourself unable to make incremental changes<p>why do you believe this becomes the case with rust code?</div><br/></div></div><div id="37443320" class="c"><input type="checkbox" id="c-37443320" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439731">parent</a><span>|</span><a href="#37439848">prev</a><span>|</span><a href="#37441123">next</a><span>|</span><label class="collapse" for="c-37443320">[-]</label><label class="expand" for="c-37443320">[2 more]</label></div><br/><div class="children"><div class="content">The safety argument is actually the reason why you can use Rust in those cases to begin with. If it was C or C++ you simply couldn&#x27;t use it for things like webservers due to the safety problems inherent to these languages. So Rust creeps into the part of the market that used to be exclusive to GC languages.</div><br/><div id="37443402" class="c"><input type="checkbox" id="c-37443402" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37443320">parent</a><span>|</span><a href="#37441123">next</a><span>|</span><label class="collapse" for="c-37443402">[-]</label><label class="expand" for="c-37443402">[1 more]</label></div><br/><div class="children"><div class="content">What do you think nginx and Apache are written in?</div><br/></div></div></div></div></div></div><div id="37441123" class="c"><input type="checkbox" id="c-37441123" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439605">parent</a><span>|</span><a href="#37439731">prev</a><span>|</span><a href="#37442424">next</a><span>|</span><label class="collapse" for="c-37441123">[-]</label><label class="expand" for="c-37441123">[8 more]</label></div><br/><div class="children"><div class="content">So you use a safe, garbage-collected language like Python, and iterate 5x as fast as Rust. Problem solved. It&#x27;s 2023 - there are at least a dozen production-quality safe languages.</div><br/><div id="37443013" class="c"><input type="checkbox" id="c-37443013" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441123">parent</a><span>|</span><a href="#37441206">next</a><span>|</span><label class="collapse" for="c-37443013">[-]</label><label class="expand" for="c-37443013">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and iterate 5x as fast as Rust.<p>I&#x27;ve been involved in Java, Python, PHP, Scala, C++, Rust, JS projects in my career. I think I&#x27;d notice a 5x speed difference in favor of Python if it existed. But I haven&#x27;t.</div><br/></div></div><div id="37441206" class="c"><input type="checkbox" id="c-37441206" checked=""/><div class="controls bullet"><span class="by">buildartefact</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441123">parent</a><span>|</span><a href="#37443013">prev</a><span>|</span><a href="#37442424">next</a><span>|</span><label class="collapse" for="c-37441206">[-]</label><label class="expand" for="c-37441206">[6 more]</label></div><br/><div class="children"><div class="content">You’re seriously suggesting writing a game engine in Python?</div><br/><div id="37441320" class="c"><input type="checkbox" id="c-37441320" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441206">parent</a><span>|</span><a href="#37442424">next</a><span>|</span><label class="collapse" for="c-37441320">[-]</label><label class="expand" for="c-37441320">[5 more]</label></div><br/><div class="children"><div class="content">You accidentally responded to the wrong comment. I never mentioned a game engine.</div><br/><div id="37441634" class="c"><input type="checkbox" id="c-37441634" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441320">parent</a><span>|</span><a href="#37442172">next</a><span>|</span><label class="collapse" for="c-37441634">[-]</label><label class="expand" for="c-37441634">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t really matter, there doesn&#x27;t exist a problem space where both Rust and Python are reasonable choices.<p>Case in point, I once wrote a program to take a 360 degree image and rotate it so that the horizon followed the horizontal line along the middle, and it faced north.  I wrote it in python first and running it on a 2k image took on the order of 5 minutes.  I rewrote it in rust and it took on the order of 200ms.<p>Could I iterate in Python faster? Yes, but the end result was useless.</div><br/><div id="37441667" class="c"><input type="checkbox" id="c-37441667" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441634">parent</a><span>|</span><a href="#37442172">next</a><span>|</span><label class="collapse" for="c-37441667">[-]</label><label class="expand" for="c-37441667">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there doesn&#x27;t exist a problem space where both Rust and Python are reasonable choices<p>This thread, and many other threads about Rust, are <i>filled</i> with people arguing the exact opposite - that Rust is a good, productive language for high-level application development. I agree with you, there&#x27;s relatively little overlap - that&#x27;s what I&#x27;m arguing for!</div><br/></div></div></div></div><div id="37442172" class="c"><input type="checkbox" id="c-37442172" checked=""/><div class="controls bullet"><span class="by">SantalBlush</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441320">parent</a><span>|</span><a href="#37441634">prev</a><span>|</span><a href="#37442424">next</a><span>|</span><label class="collapse" for="c-37442172">[-]</label><label class="expand" for="c-37442172">[2 more]</label></div><br/><div class="children"><div class="content">This thread is about writing a game engine, so GP didn&#x27;t &quot;accidentally&quot; respond to the wrong comment.  Their question is on-topic.<p>If your comments aren&#x27;t relevant to writing a game engine, then they&#x27;re not relevant to this thread.</div><br/><div id="37442585" class="c"><input type="checkbox" id="c-37442585" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37442172">parent</a><span>|</span><a href="#37442424">next</a><span>|</span><label class="collapse" for="c-37442585">[-]</label><label class="expand" for="c-37442585">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This thread is about writing a game engine<p>This is false. This &quot;thread&quot; is not &quot;about&quot; anything. The top-level comment was about writing a game engine, and various replies to that thread deviated from that topic to a greater or lesser extent. Nobody has the authority to decide what a thread is &quot;about&quot;.<p>Additionally, the actual article under consideration is about Rust&#x27;s design in general. That makes my comments <i>more</i> on topic than one about game engines in particular, and so it should be pretty clear that if you&#x27;re going to assume anything about my comments, then it would not be that they&#x27;re about game engines.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37442424" class="c"><input type="checkbox" id="c-37442424" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438978">parent</a><span>|</span><a href="#37439605">prev</a><span>|</span><a href="#37440184">next</a><span>|</span><label class="collapse" for="c-37442424">[-]</label><label class="expand" for="c-37442424">[1 more]</label></div><br/><div class="children"><div class="content">I think you may be misunderstanding what GP means. It&#x27;s about spending a day working on issues. You&#x27;re either doing it before you launch your iteration, or you&#x27;re doing it after. GP thinks it&#x27;s better to spend the time before you push the change. From a quality perspective it&#x27;s hard to see how anyone could disagree with that, but I can certainly see why there would be different preferences from programmers.<p>I don&#x27;t personally mind debugging, too much, but if your goal is to avoid bugs in your running software, then Rust has some serious advantages. We mainly use TypeScript to do things, which isn&#x27;t really comparable to Rust. But we do use C when we need performance, and we looked into Rust, even did a few PoCs on real world issues, and we sort of ended up in a situation similar to GP. Rust is great though a bit &quot;verbose&quot; to write, but its eco-system is too young to be &quot;boring&quot; enough for us, so we&#x27;re sticking with C for the time being. But being able to avoid running into crashes by doing the work before your push your code is immensely valuable in fault-intolerant systems. Like, we do financial work with C, it cannot fail. So we&#x27;re actually still doing a lot of the work up-front, and then we handle it by rigorously testing everything. Because it&#x27;s mainly used for small performance enhancement, our C programs are small enough to where this isn&#x27;t an issue, but it would be a nightmare to do with 40.000 lines of C code.</div><br/></div></div><div id="37440184" class="c"><input type="checkbox" id="c-37440184" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438978">parent</a><span>|</span><a href="#37442424">prev</a><span>|</span><a href="#37439958">next</a><span>|</span><label class="collapse" for="c-37440184">[-]</label><label class="expand" for="c-37440184">[1 more]</label></div><br/><div class="children"><div class="content">The “beats debugging” part I took it as meaning “it is better than spending that day debugging”.<p>I have fought the ownership rules and lost (replaced references by integers to a common vector-ugly stuff, but I was time constrained). But I have seen people spend <i>several weeks</i> debugging a single problem, and that was really soul-crushing.</div><br/></div></div></div></div><div id="37439958" class="c"><input type="checkbox" id="c-37439958" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37438978">prev</a><span>|</span><a href="#37440309">next</a><span>|</span><label class="collapse" for="c-37439958">[-]</label><label class="expand" for="c-37439958">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know what you mean by web-scale, you’d be mistaken if you meant “the multi-threaded services that power giant internet properties”.<p>If you want extreme low contention extreme high-utilization, you’re doing threading and event-driven simultaneously, there are no easy answers on heavily contended data structures because you can’t duplicate to exploit immutability if mere insane complexity is an alternative, and mistakes cost millions in real time.<p>There’s a reason why those places scout so heavily for the lock-free&#x2F;wait-free galaxy brains the minute they finish their PhDs.</div><br/></div></div><div id="37440309" class="c"><input type="checkbox" id="c-37440309" checked=""/><div class="controls bullet"><span class="by">rhaps0dy</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37439958">prev</a><span>|</span><a href="#37440170">next</a><span>|</span><label class="collapse" for="c-37440309">[-]</label><label class="expand" for="c-37440309">[2 more]</label></div><br/><div class="children"><div class="content">What’s the server for a metaverse client? Is there a standardized protocol, or a particularly popular one you’re targeting?</div><br/><div id="37440386" class="c"><input type="checkbox" id="c-37440386" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440309">parent</a><span>|</span><a href="#37440170">next</a><span>|</span><label class="collapse" for="c-37440386">[-]</label><label class="expand" for="c-37440386">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a client for Second Life or Open Simulator.</div><br/></div></div></div></div><div id="37440170" class="c"><input type="checkbox" id="c-37440170" checked=""/><div class="controls bullet"><span class="by">LukaD</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37440309">prev</a><span>|</span><a href="#37438119">next</a><span>|</span><label class="collapse" for="c-37440170">[-]</label><label class="expand" for="c-37440170">[1 more]</label></div><br/><div class="children"><div class="content">Rust is not race condition free, it guarantees no data races though.</div><br/></div></div><div id="37438119" class="c"><input type="checkbox" id="c-37438119" checked=""/><div class="controls bullet"><span class="by">0xDEF</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37440170">prev</a><span>|</span><a href="#37439235">next</a><span>|</span><label class="collapse" for="c-37438119">[-]</label><label class="expand" for="c-37438119">[8 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &quot;I&#x27;ve learned to live without objects, but the trait system is somewhat convoluted. There&#x27;s one area of asset processing that really wants to be object oriented, and I have more duplicate code there than I like. I could probably rewrite it to use traits more, but it would take some bashing to make it fit the trait paradigm.&quot;
</code></pre>
Can you expand on this? I come from the C# world and the Rust trait system feels expressive enough to implement the good parts of OOP.</div><br/><div id="37438247" class="c"><input type="checkbox" id="c-37438247" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438119">parent</a><span>|</span><a href="#37439235">next</a><span>|</span><label class="collapse" for="c-37438247">[-]</label><label class="expand" for="c-37438247">[7 more]</label></div><br/><div class="children"><div class="content">I understand this not as objects are missing, after all, struct with methods and traits are objects aren&#x27;t they? But more like the lack of hierarchical inheritance, that is most often used in OOP to conveniently share common code with added specialization. Override only the methods you want. You can do it with Traits of course, but it&#x27;s much more verbose. You can technically use the defer trait to simulate a sort of method inheritance, but it is frowned upon as it should be reserved for smart-pointer like objects (so the doc says).</div><br/><div id="37438626" class="c"><input type="checkbox" id="c-37438626" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438247">parent</a><span>|</span><a href="#37439271">next</a><span>|</span><label class="collapse" for="c-37438626">[-]</label><label class="expand" for="c-37438626">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s about what I was going to say. Traits have no data of their own. If you need that, you have to construct it, with a data object in each trait instance and access functions for it. It turns the notion of inheritance inside out. Awkward enough that it&#x27;s only done if absolutely necessary.</div><br/></div></div><div id="37439271" class="c"><input type="checkbox" id="c-37439271" checked=""/><div class="controls bullet"><span class="by">radicalbyte</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438247">parent</a><span>|</span><a href="#37438626">prev</a><span>|</span><a href="#37441568">next</a><span>|</span><label class="collapse" for="c-37439271">[-]</label><label class="expand" for="c-37439271">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m from the C# world and am working through learning Rust... in C# we&#x27;ve largely moved away from using inheritance. Not sure that it&#x27;s a good thing but &quot;best practise&quot; results in serialisation being implemented differently (serialisers which use attributes, or for more advanced teams serialisation wired in at compile time targeted by attributes - advantage here being that the state doesn&#x27;t have to be public).</div><br/><div id="37441025" class="c"><input type="checkbox" id="c-37441025" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439271">parent</a><span>|</span><a href="#37441650">next</a><span>|</span><label class="collapse" for="c-37441025">[-]</label><label class="expand" for="c-37441025">[2 more]</label></div><br/><div class="children"><div class="content">I still use inheritance in C# although it is only used for is-a relationships and those aren&#x27;t that common.  But when you need it for that, it&#x27;s usually pretty important.<p>I also think it&#x27;s much more common to see it in library &#x2F; framework code and not in application code.</div><br/><div id="37441213" class="c"><input type="checkbox" id="c-37441213" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441025">parent</a><span>|</span><a href="#37441650">next</a><span>|</span><label class="collapse" for="c-37441213">[-]</label><label class="expand" for="c-37441213">[1 more]</label></div><br/><div class="children"><div class="content">UI in Rust without inheritance is tricky. There&#x27;s still no great UI framework written in Rust yet, though not for lack of trying! I&#x27;m interested to see how Bevy&#x27;s UI turns out. They&#x27;re currently exploring the design space and requirements for production-grade UI, actually.</div><br/></div></div></div></div><div id="37441650" class="c"><input type="checkbox" id="c-37441650" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439271">parent</a><span>|</span><a href="#37441025">prev</a><span>|</span><a href="#37441568">next</a><span>|</span><label class="collapse" for="c-37441650">[-]</label><label class="expand" for="c-37441650">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s &quot;prefer composition over inheritance&quot; though, not &quot;never use inheritance&quot;.<p>There is a time and a place for it.</div><br/></div></div></div></div><div id="37441568" class="c"><input type="checkbox" id="c-37441568" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37438247">parent</a><span>|</span><a href="#37439271">prev</a><span>|</span><a href="#37439235">next</a><span>|</span><label class="collapse" for="c-37441568">[-]</label><label class="expand" for="c-37441568">[1 more]</label></div><br/><div class="children"><div class="content">Does delegate support delegating everything (except what you&#x27;re specifically implementing for your own struct) yet? That&#x27;s the way to do it.</div><br/></div></div></div></div></div></div><div id="37439235" class="c"><input type="checkbox" id="c-37439235" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37438119">prev</a><span>|</span><a href="#37440093">next</a><span>|</span><label class="collapse" for="c-37439235">[-]</label><label class="expand" for="c-37439235">[2 more]</label></div><br/><div class="children"><div class="content">Looks great!<p>Without judgment I must ask, what made you decide to target metaverse specifically?  Is it more of a fun challenge, or do you see it having a bright&#x2F;popular future?</div><br/><div id="37440539" class="c"><input type="checkbox" id="c-37440539" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439235">parent</a><span>|</span><a href="#37440093">next</a><span>|</span><label class="collapse" for="c-37440539">[-]</label><label class="expand" for="c-37440539">[1 more]</label></div><br/><div class="children"><div class="content">I was really bored during COVID lockdown and needed a hard problem. I may say more about metaverse stuff in another place, but don&#x27;t want to derail the Rust issues.</div><br/></div></div></div></div><div id="37440093" class="c"><input type="checkbox" id="c-37440093" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37439235">prev</a><span>|</span><a href="#37439844">next</a><span>|</span><label class="collapse" for="c-37440093">[-]</label><label class="expand" for="c-37440093">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There was an article on HN a few days ago about this. &quot;Rust has 5 games and 50 game engines&quot;.<p>That&#x27;s not a serious article. That&#x27;s a humourous video.<p>Source: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;TGfQu0bQTKc?t=169" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;TGfQu0bQTKc?t=169</a></div><br/><div id="37441172" class="c"><input type="checkbox" id="c-37441172" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37440093">parent</a><span>|</span><a href="#37439844">next</a><span>|</span><label class="collapse" for="c-37441172">[-]</label><label class="expand" for="c-37441172">[2 more]</label></div><br/><div class="children"><div class="content">It has some truth to it, still.</div><br/><div id="37443389" class="c"><input type="checkbox" id="c-37443389" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441172">parent</a><span>|</span><a href="#37439844">next</a><span>|</span><label class="collapse" for="c-37443389">[-]</label><label class="expand" for="c-37443389">[1 more]</label></div><br/><div class="children"><div class="content">Not really. To get to 50 game engines you need some creative accounting. The real joke would be 3 engines and 0 profitable games.</div><br/></div></div></div></div></div></div><div id="37439844" class="c"><input type="checkbox" id="c-37439844" checked=""/><div class="controls bullet"><span class="by">m4tthumphrey</span><span>|</span><a href="#37437676">parent</a><span>|</span><a href="#37440093">prev</a><span>|</span><a href="#37435839">next</a><span>|</span><label class="collapse" for="c-37439844">[-]</label><label class="expand" for="c-37439844">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As I&#x27;ve mentioned before, I&#x27;m writing a high performance metaverse client.<p>Why? (Serious question)</div><br/><div id="37441099" class="c"><input type="checkbox" id="c-37441099" checked=""/><div class="controls bullet"><span class="by">ipaddr</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37439844">parent</a><span>|</span><a href="#37435839">next</a><span>|</span><label class="collapse" for="c-37441099">[-]</label><label class="expand" for="c-37441099">[2 more]</label></div><br/><div class="children"><div class="content">Started 3 years ago during covid when metaverse looked attractive.  In 3 years many of these AI applications will face the same questions.</div><br/><div id="37443177" class="c"><input type="checkbox" id="c-37443177" checked=""/><div class="controls bullet"><span class="by">PUSH_AX</span><span>|</span><a href="#37437676">root</a><span>|</span><a href="#37441099">parent</a><span>|</span><a href="#37435839">next</a><span>|</span><label class="collapse" for="c-37443177">[-]</label><label class="expand" for="c-37443177">[1 more]</label></div><br/><div class="children"><div class="content">Will they? AI has adoption already, the metaverse is still waiting for meaningful adoption. You could argue that it’s never coming.</div><br/></div></div></div></div></div></div></div></div><div id="37435839" class="c"><input type="checkbox" id="c-37435839" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#37437676">prev</a><span>|</span><a href="#37436274">next</a><span>|</span><label class="collapse" for="c-37435839">[-]</label><label class="expand" for="c-37435839">[135 more]</label></div><br/><div class="children"><div class="content">I find myself in this weird corner when it comes to async rust.<p>The guy&#x27;s got a point in that doing a bunch of Arc, RwLock, and general sharing of state is going to get messy. Especially once you are sprinkling &#x27;static all over the place, it infects everything, much like colored functions. I did this whole thing once back when I was starting off where I would Arc&lt;RwLock&gt; stuff, and try to be smart about borrow lifetimes. Total mess.<p>But then rust also has channels. When you read about it, it talks about &quot;messages&quot;, which to me means little objects. Like a few bytes little. This is the solution, pretty much everything I write now is just a few tasks that service some channels. They look at what&#x27;s arrived and if there&#x27;s something to output, they will put a message on the appropriate channel for another task to deal with. No sharing objects or anything. If there&#x27;s a large object that more than one task needs, either you put it in a task that sends messages containing the relevant query result, or you let each task construct its own copy from the stream of messages.<p>And yet I see a heck of a lot of articles about how to Arc or what to do about lifetimes. They seem to be things that the language needs, especially if you are implementing the async runtime, but I don&#x27;t understand why the average library user needs to focus so much on this.</div><br/><div id="37436095" class="c"><input type="checkbox" id="c-37436095" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37435946">next</a><span>|</span><label class="collapse" for="c-37436095">[-]</label><label class="expand" for="c-37436095">[30 more]</label></div><br/><div class="children"><div class="content">I find the criticisms a little strange - async doesn’t imply multithreaded, and you don’t need to annotate everything shared with magic keywords if you’re async within the same thread because there’s no sharing. Only one future at a time is running on the thread and they’re within the same context.<p>When moving between threads I do what you suggest here and use channels to send signals rather than having a lot of shared state. Sometimes there is a crucial global state something that’s easier to just directly access, but I just write struct that manages all the Arc&#x2F;RwLock or whatever other exclusive access mechanism I need for the access patterns. From the callers point of view everything is just a simple function call. When writing the struct I need to be thoughtful of sharing semantics but it’s a very small struct and I write it once and move on.<p>I also don’t understand their concern about making things Send+Sync. In my experience almost everything is easily Send+Sync, and things that aren’t shouldn’t or couldn’t be.<p>I get that sometimes you just want to wear sweatpants and write code without thought of the details, but most languages that offer that out of the box don’t really offer efficient concurrency and parallelism.  And frankly you rarely actually need those things even if the “but it’s cool” itch is driving you. Most of the time a nodejs-esque single threaded async program is entirely sufficient, and a lot of the time Async isn’t even necessary or particularly useful. But when you need all these things, you probably need to hike up your sweatpants and write some actual computer code - because microseconds matter, profiled throughput is crucial, and nothing in life that’s complex is easy and anyone selling you otherwise is lying.</div><br/><div id="37436287" class="c"><input type="checkbox" id="c-37436287" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436095">parent</a><span>|</span><a href="#37437163">next</a><span>|</span><label class="collapse" for="c-37436287">[-]</label><label class="expand" for="c-37436287">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Sometimes there is a crucial global state something that’s easier to just directly access, but I just write struct that manages all the Arc&#x2F;RwLock or whatever other exclusive access mechanism I need for the access patterns. From the callers point of view everything is just a simple function call. When writing the struct I need to be thoughtful of sharing semantics but it’s a very small struct and I write it once and move on.<p>This is a recurring pattern I&#x27;ve started to notice with Rust: most things that repeatedly feel clunky, or noisy, or arduous, can be wrapped in an abstraction that allows your business logic to come back into focus. I&#x27;ve started to think this mentality is essential to any significant Rust project.</div><br/><div id="37436520" class="c"><input type="checkbox" id="c-37436520" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436287">parent</a><span>|</span><a href="#37437163">next</a><span>|</span><label class="collapse" for="c-37436520">[-]</label><label class="expand" for="c-37436520">[15 more]</label></div><br/><div class="children"><div class="content">Yeah it was a bit of a block for me as well, I don’t know where it came from, but I resisted wrapping things. Reality is breaking things up into crates is encouraged anyway, and just abstracting complexity away is Not That Hard, and can usually be pretty small and concise to boot.<p>I think I’m used to other languages provided a lot of these abstractions or having some framework that manages it all. The frameworks in rust tend to be pretty low level (with a few notable exceptions) so perhaps that’s where it comes from.</div><br/><div id="37436688" class="c"><input type="checkbox" id="c-37436688" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436520">parent</a><span>|</span><a href="#37437163">next</a><span>|</span><label class="collapse" for="c-37436688">[-]</label><label class="expand" for="c-37436688">[14 more]</label></div><br/><div class="children"><div class="content">Well for one- creating abstractions always comes with a tradeoff, so it&#x27;s good to have some basic skepticism around them. But Rust embraces them, for better and worse. It equips you to write extremely safe and scalable abstractions, but it&#x27;s also designed in a way that assumes you&#x27;re going to use those capabilities (mainly, being really low-level and explicit by default), and so you&#x27;re going to have a harder time if you avoid them<p>Another thing, for me, was that I came from mostly writing TypeScript, which is the opposite: the base language is breezy without abstractions, and the type system equips you to strongly-type plain data and language features, so you&#x27;ll have a great time if you stick to those<p>But yeah, it&#x27;s been interesting to see how different the answers to these questions can be in different languages!</div><br/><div id="37436983" class="c"><input type="checkbox" id="c-37436983" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436688">parent</a><span>|</span><a href="#37437163">next</a><span>|</span><label class="collapse" for="c-37436983">[-]</label><label class="expand" for="c-37436983">[13 more]</label></div><br/><div class="children"><div class="content">Rust embraces abstractions because Rust abstractions are zero-cost. So you can liberally create them and use them without paying a runtime cost.<p>That makes abstractions far more useful and powerful, since you never need to do a cost-benefit analysis in your head, abstractions are just always a good idea in Rust.</div><br/><div id="37438871" class="c"><input type="checkbox" id="c-37438871" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436983">parent</a><span>|</span><a href="#37437628">next</a><span>|</span><label class="collapse" for="c-37438871">[-]</label><label class="expand" for="c-37438871">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Zero-cost abstractions&quot; can be a confusing term and it is often misunderstood, but it has a precise meaning. Zero-cost abstractions doesn&#x27;t mean that using them has no runtime cost, just that the abstraction itself causes no additional runtime cost.<p>These can also be quite narrow: Rc is a zero-cost abstraction for refcounting with both strong and weak references allocated with the object on the heap. You cannot implement something the same more efficiently, but you can implement something different but similar that is both faster and lighter than Rc. You can make a CheapRc that only has strong counts, and that will be both lighter and faster by a tiny amount, or a SeparateRc that stores the counts separately on the heap, which offers cheaper conversions to&#x2F;from Rc.</div><br/><div id="37439029" class="c"><input type="checkbox" id="c-37439029" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37438871">parent</a><span>|</span><a href="#37437628">next</a><span>|</span><label class="collapse" for="c-37439029">[-]</label><label class="expand" for="c-37439029">[4 more]</label></div><br/><div class="children"><div class="content">I am very aware of the definition of zero-cost.<p>We&#x27;re talking about the comparison between using an abstraction vs not using an abstraction.<p>When I said &quot;doesn&#x27;t have a runtime cost&quot;, I meant &quot;the abstraction doesn&#x27;t have a runtime cost compared to not using the abstraction&quot;.<p>If you want your computer to do anything useful, then you have to write code, and that code has a runtime cost.<p>That runtime cost is unavoidable, it is a simple necessity of the computer doing useful work, regardless of whether you use an abstraction or not.<p>Whenever you create or use an abstraction, you do a cost-benefit analysis in your head: &quot;does this abstraction provide enough value to justify the <i>EXTRA</i> cost of the abstraction?&quot;<p>But if there is no <i>extra</i> cost, then the abstraction is free, it is truly zero cost, because the code needed to be written no matter what, and the abstraction is the same speed as <i>not</i> using the abstraction. So there is no cost-benefit analysis, because the abstraction is always worth it.</div><br/><div id="37439134" class="c"><input type="checkbox" id="c-37439134" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439029">parent</a><span>|</span><a href="#37437628">next</a><span>|</span><label class="collapse" for="c-37439134">[-]</label><label class="expand" for="c-37439134">[3 more]</label></div><br/><div class="children"><div class="content">The way you used it in your parent comment didn&#x27;t make it clear that you were using it properly, hence my clarification. I&#x27;m honestly still not sure you&#x27;ve got it right, because Rust abstractions, in general, are not zero-cost. Rust has some zero-cost abstractions in the standard library and Rust has made choices, like monomorphization for generics, that make writing zero-cost abstractions easier and more common in the ecosystem. But there&#x27;s nothing in the language or compiler that forces all abstractions written in Rust to be free of extra runtime costs.</div><br/><div id="37440919" class="c"><input type="checkbox" id="c-37440919" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439134">parent</a><span>|</span><a href="#37437628">next</a><span>|</span><label class="collapse" for="c-37440919">[-]</label><label class="expand" for="c-37440919">[2 more]</label></div><br/><div class="children"><div class="content">I never said that ALL abstractions in Rust are zero-cost, though the vast majority of them are, and you actually have to explicitly go out of your way to use non-zero-cost abstractions.</div><br/><div id="37443270" class="c"><input type="checkbox" id="c-37443270" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37440919">parent</a><span>|</span><a href="#37437628">next</a><span>|</span><label class="collapse" for="c-37443270">[-]</label><label class="expand" for="c-37443270">[1 more]</label></div><br/><div class="children"><div class="content">Are you sure about that?<p>&gt;<i>Rust embraces abstractions because Rust abstractions are zero-cost. So you can liberally create them and use them without paying a runtime cost.</i><p>&gt;<i>you never need to do a cost-benefit analysis in your head, abstractions are just always a good idea in Rust</i><p>Again though, and ignoring that, &quot;zero-cost abstraction&quot; can be very narrow and context specific, so you really don&#x27;t need to go out of your way to find &quot;costly&quot; abstractions in Rust. As an example, if you have any uses of Rc that don&#x27;t use weak references, then Rc is not zero-cost for those uses. This is rarely something to bother about, but rarely is not never, and it&#x27;s going to be more common the more abstractions you roll yourself.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37437628" class="c"><input type="checkbox" id="c-37437628" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436983">parent</a><span>|</span><a href="#37438871">prev</a><span>|</span><a href="#37438313">next</a><span>|</span><label class="collapse" for="c-37437628">[-]</label><label class="expand" for="c-37437628">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s always a complexity cost even when there isn&#x27;t a runtime cost. It just so happens that in Rust, the benefits tend to outweigh the costs</div><br/><div id="37438932" class="c"><input type="checkbox" id="c-37438932" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437628">parent</a><span>|</span><a href="#37438313">next</a><span>|</span><label class="collapse" for="c-37438932">[-]</label><label class="expand" for="c-37438932">[4 more]</label></div><br/><div class="children"><div class="content">The whole point of an abstraction is to remove complexity for the user.<p>So I assume you mean &quot;implementation complexity&quot; but that&#x27;s irrelevant, because that cost only needs to be paid once, and then you put the abstraction into a crate, and then millions of people can benefit from that abstraction.</div><br/><div id="37439498" class="c"><input type="checkbox" id="c-37439498" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37438932">parent</a><span>|</span><a href="#37438313">next</a><span>|</span><label class="collapse" for="c-37439498">[-]</label><label class="expand" for="c-37439498">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve got a very narrow view that I&#x27;d encourage you to be more open-minded about<p>No abstraction is perfect. Every abstraction, when encountered by a user, requires them to ask &quot;what does this do?&quot;, because they don&#x27;t have the implementation in front of their eyes<p>This may be an easy question to answer- maybe it maps very obviously to a pattern or domain concept they already know, or maybe they&#x27;ve seen this exact abstraction before and just have to recall it<p>It may be slightly harder- a new but well-documented concept, or a concept that&#x27;s intuitive but complex, or a concept that&#x27;s simple but poorly-named<p>Or it may be very hard- a badly-designed abstraction, or one that&#x27;s impossible to understand without understanding the entire system<p>But the simplest, most elegant, most intuitive abstraction in the world has nonzero cognitive cost. We abstract despite the cost, when that cost is smaller than the cost of not abstracting.</div><br/><div id="37443331" class="c"><input type="checkbox" id="c-37443331" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439498">parent</a><span>|</span><a href="#37440933">next</a><span>|</span><label class="collapse" for="c-37443331">[-]</label><label class="expand" for="c-37443331">[1 more]</label></div><br/><div class="children"><div class="content">The whole point of abstraction is to replace the need of understanding all the details of the implementation with a more general and <i>simpler</i> concept. So while the abstraction itself may have a non zero cognitive cost for the end user, this cost should be lower than the cognitive cost of the full implementation that the abstraction hides. Hence the net cognitive cost of proper abstraction is negative.<p>Abstractions allow systems to scale. Without them, it would be impossible to work on a system that&#x27;s 1M lines of code long, because you&#x27;d have to read and understand all 1M lines before doing anything.</div><br/></div></div><div id="37440933" class="c"><input type="checkbox" id="c-37440933" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439498">parent</a><span>|</span><a href="#37443331">prev</a><span>|</span><a href="#37438313">next</a><span>|</span><label class="collapse" for="c-37440933">[-]</label><label class="expand" for="c-37440933">[1 more]</label></div><br/><div class="children"><div class="content">Even the costs you are talking about are a one-time cost to read the documentation and learn the abstraction. And the long-term benefits of the abstraction are far greater than the one-time costs. That&#x27;s why we create abstractions, because they are a net gain. If they were not a net gain, we would simply not create them.</div><br/></div></div></div></div></div></div></div></div><div id="37438313" class="c"><input type="checkbox" id="c-37438313" checked=""/><div class="controls bullet"><span class="by">politician</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436983">parent</a><span>|</span><a href="#37437628">prev</a><span>|</span><a href="#37437163">next</a><span>|</span><label class="collapse" for="c-37438313">[-]</label><label class="expand" for="c-37438313">[2 more]</label></div><br/><div class="children"><div class="content">&gt; abstractions are just always a good idea<p>The &quot;zero-cost&quot; phrase is deceptive. There&#x27;s a non-zero cognitive cost to the author and all subsequent readers. A proliferation of abstractions increases the cost of every other abstraction further due to complex interactions. This is true of in all languages where the community has embraced the idea of abstraction without moderation.</div><br/><div id="37438901" class="c"><input type="checkbox" id="c-37438901" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37438313">parent</a><span>|</span><a href="#37437163">next</a><span>|</span><label class="collapse" for="c-37438901">[-]</label><label class="expand" for="c-37438901">[1 more]</label></div><br/><div class="children"><div class="content">Well, the intent of an abstraction is it comes at a non zero cost to the author but a substantial benefit to the user&#x2F;reader. If it’s a cost to everyone why are you doing it at all?<p>Rust embraces zero to low cost abstraction at the machine performance level, although to get reflective or runtime adaptive abstractions you end up losing some of that zero cost as you need to start boxing and moving things into heaps and using vtables, etc. IMO this is where rust is weakest and most complex.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37437163" class="c"><input type="checkbox" id="c-37437163" checked=""/><div class="controls bullet"><span class="by">likeabbas</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436095">parent</a><span>|</span><a href="#37436287">prev</a><span>|</span><a href="#37437406">next</a><span>|</span><label class="collapse" for="c-37437163">[-]</label><label class="expand" for="c-37437163">[12 more]</label></div><br/><div class="children"><div class="content">&gt; async doesn’t imply multithreaded<p>Async the keyword doesn’t, but Tokio forces all of your async functions to be multi thread safe. And at the moment, tokio is almost exclusively the only async runtime used today. 95% of async libraries only support tokio. So you’re basically forced to write multi thread safe code even if you’d benefit more from a single thread event loop.<p>Rust async’s set up is horrid and I wish the community would pivot away to something else like Project Loom.</div><br/><div id="37437591" class="c"><input type="checkbox" id="c-37437591" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437163">parent</a><span>|</span><a href="#37437621">next</a><span>|</span><label class="collapse" for="c-37437591">[-]</label><label class="expand" for="c-37437591">[7 more]</label></div><br/><div class="children"><div class="content">No, tokio does not require your Futures to be thread-safe.<p>Every executor (including tokio) provides a `spawn_local` function that spawns Futures on the current thread, so they don&#x27;t need to be Send:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;1.32.0&#x2F;tokio&#x2F;task&#x2F;fn.spawn_local.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;1.32.0&#x2F;tokio&#x2F;task&#x2F;fn.spawn_local.html</a><p>I have used Rust async extensively, and it works great. I consider Rust&#x27;s Future system to be superior to JS Promises.</div><br/><div id="37439216" class="c"><input type="checkbox" id="c-37439216" checked=""/><div class="controls bullet"><span class="by">likeabbas</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437591">parent</a><span>|</span><a href="#37438484">next</a><span>|</span><label class="collapse" for="c-37439216">[-]</label><label class="expand" for="c-37439216">[5 more]</label></div><br/><div class="children"><div class="content">So you’re stuck choosing a single CPU or having to write send and sync everywhere. There’s a lot of use cases where you would want a thread-per-core model like Glommio to take advantage of multiple cores while still being able to write code like it’s a single thread.<p>&gt; I have used Rust async extensively, and it works great. I consider Rust&#x27;s Future system to be superior to JS Promises.<p>Sure, but it’s a major headache compared to Java VirtualThreads or goroutines</div><br/><div id="37440959" class="c"><input type="checkbox" id="c-37440959" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439216">parent</a><span>|</span><a href="#37440074">next</a><span>|</span><label class="collapse" for="c-37440959">[-]</label><label class="expand" for="c-37440959">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  So you’re stuck choosing a single CPU or having to write send and sync everywhere. There’s a lot of use cases where you would want a thread-per-core model like Glommio to take advantage of multiple cores while still being able to write code like it’s a single thread.<p>thread_local! exists, and you can just call spawn_local on each thread. You can even call spawn_local multiple times on the same thread if you want.<p>You can have some parts of your programs be multi-threaded, and then other parts of your program can be single-threaded, and the single-threaded and multi-threaded parts can communicate with an async channel...<p>Rust gives you an exquisite amount of control over your programs, you are not &quot;stuck&quot; or &quot;locked in&quot;, you have the flexibility to structure your code however you want, and do async however you want.<p>You just have to uphold the basic Rust guarantees (no data races, no memory corruption, no undefined behavior, etc.)<p>The abstractions in Rust are designed to always uphold those guarantees, so it&#x27;s very easy to do.</div><br/><div id="37441958" class="c"><input type="checkbox" id="c-37441958" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37440959">parent</a><span>|</span><a href="#37440074">next</a><span>|</span><label class="collapse" for="c-37441958">[-]</label><label class="expand" for="c-37441958">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust gives you an exquisite amount of control over your programs<p>It does.<p>Problem is that there isn&#x27;t the documentation, examples etc to help navigate the many options.</div><br/></div></div></div></div><div id="37440074" class="c"><input type="checkbox" id="c-37440074" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439216">parent</a><span>|</span><a href="#37440959">prev</a><span>|</span><a href="#37438484">next</a><span>|</span><label class="collapse" for="c-37440074">[-]</label><label class="expand" for="c-37440074">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So you’re stuck choosing a single CPU or having to write send and sync everywhere. There’s a lot of use cases where you would want a thread-per-core model like Glommio to take advantage of multiple cores while still being able to write code like it’s a single thread.<p>No your not, you spawn a runtime on each thread and use spawn_local on each runtime. This is how actix-web works and it uses tokio under the hood.<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;actix-rt&#x2F;latest&#x2F;actix_rt&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;actix-rt&#x2F;latest&#x2F;actix_rt&#x2F;</a></div><br/><div id="37440541" class="c"><input type="checkbox" id="c-37440541" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37440074">parent</a><span>|</span><a href="#37438484">next</a><span>|</span><label class="collapse" for="c-37440541">[-]</label><label class="expand" for="c-37440541">[1 more]</label></div><br/><div class="children"><div class="content">Yea this is exactly what I do. It makes everything much cleaner.</div><br/></div></div></div></div></div></div><div id="37438484" class="c"><input type="checkbox" id="c-37438484" checked=""/><div class="controls bullet"><span class="by">adamch</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437591">parent</a><span>|</span><a href="#37439216">prev</a><span>|</span><a href="#37437621">next</a><span>|</span><label class="collapse" for="c-37438484">[-]</label><label class="expand" for="c-37438484">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I&#x27;ve been using tokio for years and never knew about this. Thanks!</div><br/></div></div></div></div><div id="37437621" class="c"><input type="checkbox" id="c-37437621" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437163">parent</a><span>|</span><a href="#37437591">prev</a><span>|</span><a href="#37437317">next</a><span>|</span><label class="collapse" for="c-37437621">[-]</label><label class="expand" for="c-37437621">[1 more]</label></div><br/><div class="children"><div class="content">&gt;but Tokio forces all of your async functions to be multi thread safe<p>While there are other runtimes that are always single-threaded, you can do it with tokio too. You can use a single threaded tokio runtimes and !Send tasks with LocalSet and spawn_local. There are a few rough edges, and the runtime internally uses atomics where a from-the-ground-up single threaded runtime wouldn&#x27;t need them, but it works perfectly fine and I use single threaded tokio event loops in my programs because the tokio ecosystem is broader.</div><br/></div></div><div id="37437317" class="c"><input type="checkbox" id="c-37437317" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437163">parent</a><span>|</span><a href="#37437621">prev</a><span>|</span><a href="#37437406">next</a><span>|</span><label class="collapse" for="c-37437317">[-]</label><label class="expand" for="c-37437317">[3 more]</label></div><br/><div class="children"><div class="content">So with another async runtime it&#x27;s possible to write async Rust that doesn&#x27;t need to be thread-safe??? Can you show some example?</div><br/><div id="37437598" class="c"><input type="checkbox" id="c-37437598" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437317">parent</a><span>|</span><a href="#37437600">next</a><span>|</span><label class="collapse" for="c-37437598">[-]</label><label class="expand" for="c-37437598">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need other runtimes for this. Tokio includes a single-threaded runtime and tools for dealing with tasks that aren&#x27;t thread safe, like LocalSet and spawn_local, that don&#x27;t require the future to be Send.</div><br/></div></div><div id="37437600" class="c"><input type="checkbox" id="c-37437600" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437317">parent</a><span>|</span><a href="#37437598">prev</a><span>|</span><a href="#37437406">next</a><span>|</span><label class="collapse" for="c-37437600">[-]</label><label class="expand" for="c-37437600">[1 more]</label></div><br/><div class="children"><div class="content">Every executor (including tokio) supports spawning Futures that aren&#x27;t Send:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;1.32.0&#x2F;tokio&#x2F;task&#x2F;fn.spawn_local.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;1.32.0&#x2F;tokio&#x2F;task&#x2F;fn.spawn_local.html</a><p>There is a lot of misinformation in this thread, with people not knowing what they&#x27;re talking about.</div><br/></div></div></div></div></div></div></div></div><div id="37435946" class="c"><input type="checkbox" id="c-37435946" checked=""/><div class="controls bullet"><span class="by">Cu3PO42</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37436095">prev</a><span>|</span><a href="#37436627">next</a><span>|</span><label class="collapse" for="c-37435946">[-]</label><label class="expand" for="c-37435946">[13 more]</label></div><br/><div class="children"><div class="content">I really like the message passing paradigm. And languages like Erlang have shown that its an excellent choice... for distributed systems. But writing code like that is a very diffferent experience from, say, async JavaScript, which feels more like writing synchronous code with green threads (except you have to deal with function coloring as well). I believe people will try to write code in a way that is already familiar to them, leading them down the path of Arc and RwLock in Rust.</div><br/><div id="37440199" class="c"><input type="checkbox" id="c-37440199" checked=""/><div class="controls bullet"><span class="by">rkangel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435946">parent</a><span>|</span><a href="#37436033">next</a><span>|</span><label class="collapse" for="c-37440199">[-]</label><label class="expand" for="c-37440199">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But writing code like that is a very diffferent experience from, say, async JavaScript,<p>I write a fair amount of code in Elixir professionally and this isn&#x27;t how I view it.<p>There are some specific Elixir&#x2F;Erlang bits of ceremony you need to do to set up your supervision tree of GenServers, but then once that&#x27;s done you get to write code that feels like so gle threaded &quot;ignore the rest of the world&quot; code. Some of the function calls you&#x27;re making might be &quot;send and message and wait for a response&quot; from GenServers etc. but the framework takes care of that.<p>I wrote some driver code for an NXP tag chip. Driving the inventory process is a bit involved, you have to do a series of things, set up hardware, turn on radio, wait a bit, send data, service the SPI the whole time in parallel. With the right setup for the hardware interface I just wrote the whole thing as a sequence, it was the simplest possible code you could imagine for it. And this at the same time as running a web server, and servicing hardware interrupts that cause it to reload the state of some registers and show them to each connected web session.</div><br/></div></div><div id="37436033" class="c"><input type="checkbox" id="c-37436033" checked=""/><div class="controls bullet"><span class="by">johnmaguire</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435946">parent</a><span>|</span><a href="#37440199">prev</a><span>|</span><a href="#37436627">next</a><span>|</span><label class="collapse" for="c-37436033">[-]</label><label class="expand" for="c-37436033">[11 more]</label></div><br/><div class="children"><div class="content">Go also uses goroutines and channels to facilitate message passing, or as they describe it, &quot;sharing memory by communicating.&quot;<p>I imagine Rust to be a language far more similar to Go, in both use cases and functionality, than JS.</div><br/><div id="37436408" class="c"><input type="checkbox" id="c-37436408" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436033">parent</a><span>|</span><a href="#37436284">next</a><span>|</span><label class="collapse" for="c-37436408">[-]</label><label class="expand" for="c-37436408">[9 more]</label></div><br/><div class="children"><div class="content">And in the end, almost everything ends up using Mutex, RWMutex, WaitGroup, Once, and some channels that exist only to ever be closed (like Context.Done), and only if you need to select around them.<p>It&#x27;s great, but message passing it is not.</div><br/><div id="37436513" class="c"><input type="checkbox" id="c-37436513" checked=""/><div class="controls bullet"><span class="by">jzelinskie</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436408">parent</a><span>|</span><a href="#37437021">next</a><span>|</span><label class="collapse" for="c-37436513">[-]</label><label class="expand" for="c-37436513">[4 more]</label></div><br/><div class="children"><div class="content">As a quite senior Go developer, I&#x27;d like to +1 this a ton. You&#x27;re far more likely to have shocking edge cases unaccounted for when using channels. I consider every usage very, very carefully. Just like every other language, I think the ultimate solution is to build higher-level abstractions for concurrency patterns (e.g. errgroup) and, now that Go has generics, it&#x27;s the right time to start building them.<p>If you haven&#x27;t seen this paper, I bet you&#x27;ll find at least one or two new bugs that you didn&#x27;t know about: <a href="https:&#x2F;&#x2F;songlh.github.io&#x2F;paper&#x2F;go-study.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;songlh.github.io&#x2F;paper&#x2F;go-study.pdf</a></div><br/><div id="37439580" class="c"><input type="checkbox" id="c-37439580" checked=""/><div class="controls bullet"><span class="by">bboozzoo</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436513">parent</a><span>|</span><a href="#37440143">next</a><span>|</span><label class="collapse" for="c-37439580">[-]</label><label class="expand" for="c-37439580">[1 more]</label></div><br/><div class="children"><div class="content">The first one is indeed non-obvious, but the remaining snippets presented as bugs would not pass a review unless hidden inside 1k+ LOC PRs. Some are so blatantly obvious (seriously for loop and not passing current value as variable?) that I&#x27;m surprised that authors have listed them as if they&#x27;re somehow special.</div><br/></div></div><div id="37440143" class="c"><input type="checkbox" id="c-37440143" checked=""/><div class="controls bullet"><span class="by">xh-dude</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436513">parent</a><span>|</span><a href="#37439580">prev</a><span>|</span><a href="#37437021">next</a><span>|</span><label class="collapse" for="c-37440143">[-]</label><label class="expand" for="c-37440143">[2 more]</label></div><br/><div class="children"><div class="content">I still like channels because they may be a net reduction in the number of concurrency primitives in use, which complicates quantification in the paper - their taxonomy is great, though. Channels have some sharp corners.</div><br/><div id="37440823" class="c"><input type="checkbox" id="c-37440823" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37440143">parent</a><span>|</span><a href="#37437021">next</a><span>|</span><label class="collapse" for="c-37440823">[-]</label><label class="expand" for="c-37440823">[1 more]</label></div><br/><div class="children"><div class="content">Reducing the number of concurrency primitives does not imply reduction in complexity. On the contrary in fact, I&#x27;ve seen the messes created by golang in large production systems. Here&#x27;s a good article: <a href="https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;data-race-patterns-in-go&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;data-race-patterns-in-go&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37437021" class="c"><input type="checkbox" id="c-37437021" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436408">parent</a><span>|</span><a href="#37436513">prev</a><span>|</span><a href="#37437321">next</a><span>|</span><label class="collapse" for="c-37437021">[-]</label><label class="expand" for="c-37437021">[3 more]</label></div><br/><div class="children"><div class="content">If you choose to use Mutex, that&#x27;s on you.<p>Rust gives you channels (both synchronous blocking channels and async channels), and they work great, there is nothing stopping you from using them.</div><br/><div id="37437180" class="c"><input type="checkbox" id="c-37437180" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437021">parent</a><span>|</span><a href="#37437321">next</a><span>|</span><label class="collapse" for="c-37437180">[-]</label><label class="expand" for="c-37437180">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure the gp was talking about Go Mutex, not Rust Mutex.</div><br/><div id="37437613" class="c"><input type="checkbox" id="c-37437613" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437180">parent</a><span>|</span><a href="#37437321">next</a><span>|</span><label class="collapse" for="c-37437613">[-]</label><label class="expand" for="c-37437613">[1 more]</label></div><br/><div class="children"><div class="content">Ah, my mistake.</div><br/></div></div></div></div></div></div><div id="37437321" class="c"><input type="checkbox" id="c-37437321" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436408">parent</a><span>|</span><a href="#37437021">prev</a><span>|</span><a href="#37436284">next</a><span>|</span><label class="collapse" for="c-37437321">[-]</label><label class="expand" for="c-37437321">[1 more]</label></div><br/><div class="children"><div class="content">Because all languages and developers assume that Erlang is only about message passing. And they completely ignore literally everything else: from immutable structures to the VM providing insane guarantees (like processes not crashing the VM, and monitoring)</div><br/></div></div></div></div><div id="37436284" class="c"><input type="checkbox" id="c-37436284" checked=""/><div class="controls bullet"><span class="by">Cu3PO42</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436033">parent</a><span>|</span><a href="#37436408">prev</a><span>|</span><a href="#37436627">next</a><span>|</span><label class="collapse" for="c-37436284">[-]</label><label class="expand" for="c-37436284">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I imagine Rust to be a language far more similar to Go, in both use cases and functionality, than JS.<p>I mostly agree. But I would wager that for a significant amount of people their first exposure to &quot;async&quot; is JS and not any number of other languages. And when you try to write async Rust the same way as you might write async JS, things just aren&#x27;t that pretty.</div><br/></div></div></div></div></div></div><div id="37436627" class="c"><input type="checkbox" id="c-37436627" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37435946">prev</a><span>|</span><a href="#37436748">next</a><span>|</span><label class="collapse" for="c-37436627">[-]</label><label class="expand" for="c-37436627">[12 more]</label></div><br/><div class="children"><div class="content">&gt; <i>But then rust also has channels. When you read about it, it talks about &quot;messages&quot;, which to me means little objects. Like a few bytes little. This is the solution, pretty much everything I write now is just a few tasks that service some channels. They look at what&#x27;s arrived and if there&#x27;s something to output, they will put a message on the appropriate channel for another task to deal with. No sharing objects or anything. If there&#x27;s a large object that more than one task needs, either you put it in a task that sends messages containing the relevant query result, or you let each task construct its own copy from the stream of messages.</i><p>The dream of Smalltalk and true OOP is still alive.</div><br/><div id="37436874" class="c"><input type="checkbox" id="c-37436874" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436627">parent</a><span>|</span><a href="#37436732">next</a><span>|</span><label class="collapse" for="c-37436874">[-]</label><label class="expand" for="c-37436874">[9 more]</label></div><br/><div class="children"><div class="content">Why does Smalltalk constantly get credit for being true OOP?   Simula was doing OOP long before Smalltalk. Most languages choose Simula style OOP, and reject the things that make Smalltalk different.<p>If you say Smalltalk is better OOP I might agree, but calling it &quot;true&quot; is not correct.</div><br/><div id="37437255" class="c"><input type="checkbox" id="c-37437255" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436874">parent</a><span>|</span><a href="#37438617">next</a><span>|</span><label class="collapse" for="c-37437255">[-]</label><label class="expand" for="c-37437255">[4 more]</label></div><br/><div class="children"><div class="content">Because the term was coined by Alan Kay, who apparently later said he probably should have called it message oriented (paraphrasing).<p>There&#x27;s also a written conversation you can find online where he disqualifies pretty much all of the mainstream languages of being OO.<p>A lot of people, like you, say that OO == ADTs. Or rather, what ever Simula, C++ and Java are doing. Some will say that inheritance is an integral part of it, other&#x27;s say it&#x27;s all about interfaces.<p>But then there&#x27;s people who say that Scheme and JavaScript are more object oriented than Java and C#. Or that when we&#x27;re using channels or actors we&#x27;re now _really_ doing OOP.<p>There&#x27;s people who talk about patterns, SOLID, clean code and all sorts of things that you should be adhering to when structuring OO code.<p>Then there&#x27;s people who say that OO is all about the mental model of the user and their ability to understand your program in terms of operational semantics. They should be able to understand it to a degree that they can manipulate and extend it themselves.<p>It&#x27;s all very confusing.</div><br/><div id="37438646" class="c"><input type="checkbox" id="c-37438646" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437255">parent</a><span>|</span><a href="#37438617">next</a><span>|</span><label class="collapse" for="c-37438646">[-]</label><label class="expand" for="c-37438646">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Because the term was coined by Alan Kay</i><p>This is pretty unlikely. See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36879311">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36879311</a>.</div><br/><div id="37439996" class="c"><input type="checkbox" id="c-37439996" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37438646">parent</a><span>|</span><a href="#37438617">next</a><span>|</span><label class="collapse" for="c-37439996">[-]</label><label class="expand" for="c-37439996">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The term &quot;object-oriented&quot; was applied to a programming language for the first time in the MIT CSG Memo 137 (April 1976)<p>That&#x27;s publications though.
Alan Kay says he used it in conversation in 1967:
<a href="http:&#x2F;&#x2F;userpage.fu-berlin.de&#x2F;~ram&#x2F;pub&#x2F;pub_jf47ht81Ht&#x2F;doc_kay_oop_en" rel="nofollow noreferrer">http:&#x2F;&#x2F;userpage.fu-berlin.de&#x2F;~ram&#x2F;pub&#x2F;pub_jf47ht81Ht&#x2F;doc_kay...</a><p>There&#x27;s probably also a distinction to be made between &quot;object-oriented&quot; and &quot;object-oriented programming&quot;.</div><br/><div id="37440133" class="c"><input type="checkbox" id="c-37440133" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439996">parent</a><span>|</span><a href="#37438617">next</a><span>|</span><label class="collapse" for="c-37440133">[-]</label><label class="expand" for="c-37440133">[1 more]</label></div><br/><div class="children"><div class="content">The referenced research also considers the publications by Kay and his team (including his theses and the Smalltalk-72 and 76 manuals) and other uses of the term. I think Kay mixes things up in retrospective; in his 1968 thesis he used the terms &quot;object language&quot; and &quot;object machine&quot;, but not &quot;object-oriented&quot;; imagine giving your new breakthrough method a name, but then not using that name anywhere in the publication; that seems unthinkable, especially with an accomplished communicator like Kay. The first time &quot;object-oriented&quot; appears in a publication of his or his team is in 1978.</div><br/></div></div></div></div></div></div></div></div><div id="37438617" class="c"><input type="checkbox" id="c-37438617" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436874">parent</a><span>|</span><a href="#37437255">prev</a><span>|</span><a href="#37437113">next</a><span>|</span><label class="collapse" for="c-37438617">[-]</label><label class="expand" for="c-37438617">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Most languages choose Simula style OOP</i><p>Right, including Smalltalk 76 and 80 onwards themselves. Remember Kay&#x27;s statement &quot;<i>actually I made up the term object-oriented and I can tell you I did not have C++ in mind, so the important thing here is I have many of the same feelings about Smalltalk</i>&quot; (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=oKg1hTOQXoY&amp;t=636s);">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=oKg1hTOQXoY&amp;t=636s);</a> the reason he refers to Smalltalk this way in his 1997 talk was likely the fact that Smalltalk-80 has more in common with Simula 67 than his brain child Smalltalk-72. Ingalls explicitly refers to Simula 67 in his 2020 HOPL paper.<p>&gt; <i>and reject the things that make Smalltalk different</i><p>Which would mostly be its dynamic nature (Smalltalk-76 can be called the first dynamic OO language) and the use of runtime constructs instead dedicated syntax for conditions and loops (as it is e.g. the case in Lisp). There are a lot of dynamic OO languages still in use today, e.g. Python. Also Smalltalk-80 descendants are still in use, e.g. Pharo.</div><br/></div></div><div id="37437113" class="c"><input type="checkbox" id="c-37437113" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436874">parent</a><span>|</span><a href="#37438617">prev</a><span>|</span><a href="#37436732">next</a><span>|</span><label class="collapse" for="c-37437113">[-]</label><label class="expand" for="c-37437113">[3 more]</label></div><br/><div class="children"><div class="content">Alan Kay is generally credited with coming up with the term &quot;object-oriented&quot;, so for better or for worse, many people defer to his definition and his embodiment of ideas when looking for a strict definition of the term.</div><br/><div id="37438859" class="c"><input type="checkbox" id="c-37438859" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437113">parent</a><span>|</span><a href="#37437248">next</a><span>|</span><label class="collapse" for="c-37438859">[-]</label><label class="expand" for="c-37438859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>many people defer to his definition and his embodiment of ideas when looking for a strict definition of the term.</i><p>I consider the definition e.g. used by IEEE as sufficiently strict, see e.g. <a href="https:&#x2F;&#x2F;ethw.org&#x2F;Milestones:Object-Oriented_Programming,_1961-1967" rel="nofollow noreferrer">https:&#x2F;&#x2F;ethw.org&#x2F;Milestones:Object-Oriented_Programming,_196...</a>, but - as you say - it&#x27;s not the defintion used by Kay.</div><br/></div></div><div id="37437248" class="c"><input type="checkbox" id="c-37437248" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437113">parent</a><span>|</span><a href="#37438859">prev</a><span>|</span><a href="#37436732">next</a><span>|</span><label class="collapse" for="c-37437248">[-]</label><label class="expand" for="c-37437248">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, though, that’s like crediting William Burroughs with Blade Runner.</div><br/></div></div></div></div></div></div><div id="37436732" class="c"><input type="checkbox" id="c-37436732" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436627">parent</a><span>|</span><a href="#37436874">prev</a><span>|</span><a href="#37442874">next</a><span>|</span><label class="collapse" for="c-37436732">[-]</label><label class="expand" for="c-37436732">[1 more]</label></div><br/><div class="children"><div class="content">Erlang often crops up in these conversations.</div><br/></div></div><div id="37442874" class="c"><input type="checkbox" id="c-37442874" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436627">parent</a><span>|</span><a href="#37436732">prev</a><span>|</span><a href="#37436748">next</a><span>|</span><label class="collapse" for="c-37442874">[-]</label><label class="expand" for="c-37442874">[1 more]</label></div><br/><div class="children"><div class="content">OOP was a shit idea that needed to die.</div><br/></div></div></div></div><div id="37436748" class="c"><input type="checkbox" id="c-37436748" checked=""/><div class="controls bullet"><span class="by">harpiaharpyja</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37436627">prev</a><span>|</span><a href="#37435894">next</a><span>|</span><label class="collapse" for="c-37436748">[-]</label><label class="expand" for="c-37436748">[4 more]</label></div><br/><div class="children"><div class="content">I remember picking up this sort of advice from a professor way back in college. It&#x27;s a godsend. Structure the problem as data flowing between tasks and connect them up with queues, avoid sharing state. It&#x27;s just a better way to deal with multithreading no matter what language you use.</div><br/><div id="37436966" class="c"><input type="checkbox" id="c-37436966" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436748">parent</a><span>|</span><a href="#37439878">next</a><span>|</span><label class="collapse" for="c-37436966">[-]</label><label class="expand" for="c-37436966">[1 more]</label></div><br/><div class="children"><div class="content">There is a time any place for sharing state and data.  However it is extremely complex to make that work, and so if at all possible don&#x27;t.  In general the only time I can&#x27;t use queues is when I&#x27;m writing the queue implementation (I&#x27;ve done this several times - turns out there are a number of different special cases in my embedded system where it was worth it to avoid some obscure downside to the queues I already had).<p>When you need the absolute best performance sharing state is sometimes better - but you need a deep understanding of how your CPUs share state.  A mutex or atomic write operation is almost always needed (the exceptions are really weird), and those will kill performance so you better spend a lot of time minimizing where you have them.</div><br/></div></div><div id="37439878" class="c"><input type="checkbox" id="c-37439878" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436748">parent</a><span>|</span><a href="#37436966">prev</a><span>|</span><a href="#37437592">next</a><span>|</span><label class="collapse" for="c-37439878">[-]</label><label class="expand" for="c-37439878">[1 more]</label></div><br/><div class="children"><div class="content">Async is not a solution for data parallelism.</div><br/></div></div><div id="37437592" class="c"><input type="checkbox" id="c-37437592" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436748">parent</a><span>|</span><a href="#37439878">prev</a><span>|</span><a href="#37435894">next</a><span>|</span><label class="collapse" for="c-37437592">[-]</label><label class="expand" for="c-37437592">[1 more]</label></div><br/><div class="children"><div class="content">I like this too.<p>I would also suggest looking into ringbuffers and LMAX Disruptor pattern.<p>There is also Red Planet Lab&#x27;s Rama, which takes the data flow idea and uses it to scale.</div><br/></div></div></div></div><div id="37435894" class="c"><input type="checkbox" id="c-37435894" checked=""/><div class="controls bullet"><span class="by">mrkline</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37436748">prev</a><span>|</span><a href="#37437357">next</a><span>|</span><label class="collapse" for="c-37435894">[-]</label><label class="expand" for="c-37435894">[42 more]</label></div><br/><div class="children"><div class="content">Hoare Was Right.<p>(But if you&#x27;re only firing up a few tasks, why not just use threads? To get a nice wrapper around an I&#x2F;O event loop?)</div><br/><div id="37436018" class="c"><input type="checkbox" id="c-37436018" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435894">parent</a><span>|</span><a href="#37436206">next</a><span>|</span><label class="collapse" for="c-37436018">[-]</label><label class="expand" for="c-37436018">[15 more]</label></div><br/><div class="children"><div class="content">Exactly. People are too afraid of using threads these days for some perceived cargo-cult scalability reasons. My rule of thumb is just to use threads if the total number of threads per process won&#x27;t exceed 1000.<p>(This is assuming you are already switching to communicating using channels or similar abstraction.)</div><br/><div id="37436393" class="c"><input type="checkbox" id="c-37436393" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436018">parent</a><span>|</span><a href="#37436279">next</a><span>|</span><label class="collapse" for="c-37436393">[-]</label><label class="expand" for="c-37436393">[2 more]</label></div><br/><div class="children"><div class="content">The performance overhead of threads is largely unrelated to how many you have. The thing being minimized with async code is the rate at which you switch between them, because those context switches are expensive. On modern systems there are many common cases where the CPU time required to do the work between a pair of potentially blocking calls is much less than the CPU time required to yield when a blocking call occurs. Consequently, most of your CPU time is spent yielding to another thread. In good async designs, almost no CPU time is spent yielding. Channels will help batch up communication but you still have to context switch to read those channels. This is where thread-per-core software architectures came from; they use channels but they never context switch.<p>Any software that does a lot of fine-grained concurrent I&#x2F;O has this issue. Database engines have been fighting this for many years, since they can pervasively block both on I&#x2F;O <i>and</i> locking for data model concurrency control.</div><br/><div id="37442885" class="c"><input type="checkbox" id="c-37442885" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436393">parent</a><span>|</span><a href="#37436279">next</a><span>|</span><label class="collapse" for="c-37442885">[-]</label><label class="expand" for="c-37442885">[1 more]</label></div><br/><div class="children"><div class="content">The cost of context switching in &quot;async&quot; code is very rarely smaller than the cost of switching OS threads. (Exception is when you&#x27;ree using a GC language with some sort of global lock.)<p>&quot;Async&quot; in native code is cargo cult, unless you&#x27;re trying to run on bare metal without OS support.</div><br/></div></div></div></div><div id="37436279" class="c"><input type="checkbox" id="c-37436279" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436018">parent</a><span>|</span><a href="#37436393">prev</a><span>|</span><a href="#37439841">next</a><span>|</span><label class="collapse" for="c-37436279">[-]</label><label class="expand" for="c-37436279">[5 more]</label></div><br/><div class="children"><div class="content">The challenge is that async colors functions and many of the popular crates will force you to be async, so it isn&#x27;t always a choice depending on which crates you need.</div><br/><div id="37436484" class="c"><input type="checkbox" id="c-37436484" checked=""/><div class="controls bullet"><span class="by">adrienthebo</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436279">parent</a><span>|</span><a href="#37439841">next</a><span>|</span><label class="collapse" for="c-37436484">[-]</label><label class="expand" for="c-37436484">[4 more]</label></div><br/><div class="children"><div class="content">Please excuse my ignorance, I haven&#x27;t done a ton of async Rust programming - but if you&#x27;re trying to call async Rust from sync Rust, can you not just create a task, have that task push a value through a mpsc channel, shove the task on the executor, and wait for the value to be returned? Is the concern that control over the execution of the task is too coarse grained?</div><br/><div id="37437034" class="c"><input type="checkbox" id="c-37437034" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436484">parent</a><span>|</span><a href="#37436724">next</a><span>|</span><label class="collapse" for="c-37437034">[-]</label><label class="expand" for="c-37437034">[2 more]</label></div><br/><div class="children"><div class="content">Yes, you can do that. You can use `block_on` to convert an async Future into a synchronous blocking call. So it is entirely possible to convert from the async world back into the sync world.</div><br/><div id="37441986" class="c"><input type="checkbox" id="c-37441986" checked=""/><div class="controls bullet"><span class="by">likeabbas</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437034">parent</a><span>|</span><a href="#37436724">next</a><span>|</span><label class="collapse" for="c-37441986">[-]</label><label class="expand" for="c-37441986">[1 more]</label></div><br/><div class="children"><div class="content">But you have to pull in an async runtime to do it. So library authors either have to force everyone to pull in an async runtime or write two versions of their code (sync and async).</div><br/></div></div></div></div><div id="37436724" class="c"><input type="checkbox" id="c-37436724" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436484">parent</a><span>|</span><a href="#37437034">prev</a><span>|</span><a href="#37439841">next</a><span>|</span><label class="collapse" for="c-37436724">[-]</label><label class="expand" for="c-37436724">[1 more]</label></div><br/><div class="children"><div class="content">There are ways to call both from both for sure, but my point is if you don&#x27;t want any async in your code at all...that often isn&#x27;t a choice if you want to use the popular web frameworks for example.</div><br/></div></div></div></div></div></div><div id="37439841" class="c"><input type="checkbox" id="c-37439841" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436018">parent</a><span>|</span><a href="#37436279">prev</a><span>|</span><a href="#37436104">next</a><span>|</span><label class="collapse" for="c-37439841">[-]</label><label class="expand" for="c-37439841">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t both perform blocking I&#x2F;O and wait for a cancellation signal from another thread. So I need to use poll(), and async is a nice interface to that.</div><br/></div></div><div id="37436104" class="c"><input type="checkbox" id="c-37436104" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436018">parent</a><span>|</span><a href="#37439841">prev</a><span>|</span><a href="#37436206">next</a><span>|</span><label class="collapse" for="c-37436104">[-]</label><label class="expand" for="c-37436104">[6 more]</label></div><br/><div class="children"><div class="content">99% of the use cases that ought to use async are server-side web services.  If you&#x27;re not writing one of those, you almost certainly don&#x27;t need async.</div><br/><div id="37436262" class="c"><input type="checkbox" id="c-37436262" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436104">parent</a><span>|</span><a href="#37436426">next</a><span>|</span><label class="collapse" for="c-37436262">[-]</label><label class="expand" for="c-37436262">[3 more]</label></div><br/><div class="children"><div class="content">Or desktop programs. Many GUI frameworks have a main thread that updates the layout (among other things) and various background ones.</div><br/><div id="37437063" class="c"><input type="checkbox" id="c-37437063" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436262">parent</a><span>|</span><a href="#37436426">next</a><span>|</span><label class="collapse" for="c-37437063">[-]</label><label class="expand" for="c-37437063">[2 more]</label></div><br/><div class="children"><div class="content">Async and GUI threads are different concepts.  Of course most GUIs have an event loop which can be used as a form of async, but with async you do your calculations in the main thread, while with GUIs you typically spin your calculations off to a different thread.<p>Most often when doing async you have a small number of tasks repeated many times, then you spin up one thread per CPU, and &quot;randomly&quot; assign each task as it comes in to a thread.<p>When doing GUI style programming you have a lot of different tasks and each task is done in exactly one thread.</div><br/><div id="37439389" class="c"><input type="checkbox" id="c-37439389" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437063">parent</a><span>|</span><a href="#37436426">next</a><span>|</span><label class="collapse" for="c-37439389">[-]</label><label class="expand" for="c-37439389">[1 more]</label></div><br/><div class="children"><div class="content">Hmm I would say the concepts are intertwined.  Lots of GUI frameworks use async&#x2F;await and the GUI thread is just another concurrency pattern that adds lock free thread exclusivity to async tasks that are pinned to a single thread.</div><br/></div></div></div></div></div></div><div id="37436426" class="c"><input type="checkbox" id="c-37436426" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436104">parent</a><span>|</span><a href="#37436262">prev</a><span>|</span><a href="#37436265">next</a><span>|</span><label class="collapse" for="c-37436426">[-]</label><label class="expand" for="c-37436426">[1 more]</label></div><br/><div class="children"><div class="content">Async for GUIs is also nice. Not essential, but allows you to simply lot of callback code</div><br/></div></div><div id="37436265" class="c"><input type="checkbox" id="c-37436265" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436104">parent</a><span>|</span><a href="#37436426">prev</a><span>|</span><a href="#37436206">next</a><span>|</span><label class="collapse" for="c-37436265">[-]</label><label class="expand" for="c-37436265">[1 more]</label></div><br/><div class="children"><div class="content">Note that if you &quot;just&quot; write responses to queries without yielding execution, you don&#x27;t need async, you just write Sync handlers to an async framework. (Hitting dB requests in a synchronous way is not good for your perf though, you better have a mostly read &#x2F; well cached problem)</div><br/></div></div></div></div></div></div><div id="37436206" class="c"><input type="checkbox" id="c-37436206" checked=""/><div class="controls bullet"><span class="by">adrienthebo</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435894">parent</a><span>|</span><a href="#37436018">prev</a><span>|</span><a href="#37435919">next</a><span>|</span><label class="collapse" for="c-37436206">[-]</label><label class="expand" for="c-37436206">[1 more]</label></div><br/><div class="children"><div class="content">A particularly interesting use case for async Rust without threads is cooperative scheduling on microcontrollers[1]; this article also does a really good job of explaining some of the complications referenced in TFA.<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36790238">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36790238</a></div><br/></div></div><div id="37435919" class="c"><input type="checkbox" id="c-37435919" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435894">parent</a><span>|</span><a href="#37436206">prev</a><span>|</span><a href="#37436646">next</a><span>|</span><label class="collapse" for="c-37435919">[-]</label><label class="expand" for="c-37435919">[21 more]</label></div><br/><div class="children"><div class="content">Waiting asynchronously on multiple channels&#x2F;signals. Heterogenous select is really nice.</div><br/><div id="37436413" class="c"><input type="checkbox" id="c-37436413" checked=""/><div class="controls bullet"><span class="by">simias</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435919">parent</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37436413">[-]</label><label class="expand" for="c-37436413">[18 more]</label></div><br/><div class="children"><div class="content">It really is, but I still favour &quot;unsexy&quot; manual poll&#x2F;select code with a lot of if&#x2F;elseing if it means not having to deal with async.<p>I fully acknowledge that I&#x27;m an &quot;old school&quot; system dev who&#x27;s coming from the C world and not the JS world, so I probably have a certain bias because of that, but I genuinely can&#x27;t understand how anybody could look at the mess that&#x27;s Rust&#x27;s async and think that it was a good design for a language that already had the reputation of being very complicated to write.<p>I tried to get it, I really did, but my god what a massive mess that is. And it contaminates everything it touches, too. I really love Rust and I do most of my coding in it these days, but every time I encounter async-heavy Rust code my jaw clenches and my vision blurs.<p>At least my clunky select &quot;runtime&quot; code can be safely contained in a couple functions while the rest of the code remains blissfully unaware of the magic going on under the hood.<p>Dear people coming from the JS world: give system threads and channels a try. I swear that a lot of the time it&#x27;s vastly simpler and more elegant. There are very, very few practical problems where async is clearly superior (although plenty where it&#x27;s <i>arguably</i> superior).</div><br/><div id="37441383" class="c"><input type="checkbox" id="c-37441383" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436413">parent</a><span>|</span><a href="#37441852">next</a><span>|</span><label class="collapse" for="c-37441383">[-]</label><label class="expand" for="c-37441383">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but I genuinely can&#x27;t understand how anybody could look at the mess that&#x27;s Rust&#x27;s async and think that it was a good design for a language that already had the reputation of being very complicated to write.<p>Rust adopted the stackless coroutine model for async tasks based on its constraints, such as having a minimal runtime by default, not requiring heap allocations left and right, and being amenable to aggressive optimizations such as inlining. The function coloring problem (&quot;contamination&quot;) is an unfortunate consequence. The Rust devs are currently working on an effects system to fix this. Missing features such as standard async traits, async functions in traits, and executor-agnosticism are also valid complaints. Considering Rust&#x27;s strict backwards compatibility guarantee, some of these will take a long time.<p>I like to think of Rust&#x27;s &quot;async story&quot; as a good analogue to Rust&#x27;s &quot;story&quot; in general. The Rust devs work hard to deliver backwards compatible, efficient, performant features at the cost of programmer comfort (ballooning complexity, edge cases that don&#x27;t compile, etc.) and compile time, mainly. Of course, they try to resolve the regressions too, but there&#x27;s only so much that can be done after the fact. Those are just the tradeoffs the Rust language embodies, and at this point I don&#x27;t expect anything more or less. I like Rust too, but there are many reasons others may not. The still-developing ecosystem is a prominent one.</div><br/></div></div><div id="37441852" class="c"><input type="checkbox" id="c-37441852" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436413">parent</a><span>|</span><a href="#37441383">prev</a><span>|</span><a href="#37439174">next</a><span>|</span><label class="collapse" for="c-37441852">[-]</label><label class="expand" for="c-37441852">[1 more]</label></div><br/><div class="children"><div class="content">I read comments like this and feel like I’m living in some weird parallel universe. The vast majority of Rust I write day in and day out for my job is in an async context. It has some rough edges, but it’s not particularly painful and is often pleasant enough. Certainly better than promises in JS. I have also used system threads, channels, etc., and indeed there are some places where we communicate between long running async tasks with channels, which is nice, and some very simple CLI apps and stuff where we just use system threads rather than pulling in tokio and all that.<p>Anyway, while I have some issues with async around futur composition and closures, I see people with the kind of super strong reaction here and just feel like I must not be seeing something. To me, it solves the job well, is comprehensible and relatively easy to work with, and remains performant at scale without too much fiddling.</div><br/></div></div><div id="37439174" class="c"><input type="checkbox" id="c-37439174" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436413">parent</a><span>|</span><a href="#37441852">prev</a><span>|</span><a href="#37442453">next</a><span>|</span><label class="collapse" for="c-37439174">[-]</label><label class="expand" for="c-37439174">[7 more]</label></div><br/><div class="children"><div class="content">&gt; It really is, but I still favour &quot;unsexy&quot; manual poll&#x2F;select code with a lot of if&#x2F;elseing if it means not having to deal with async.<p>&gt; I fully acknowledge that I&#x27;m an &quot;old school&quot; system dev who&#x27;s coming from the C world and not the JS world, so I probably have a certain bias because of that, but I genuinely can&#x27;t understand how anybody could look at the mess that&#x27;s Rust&#x27;s async and think that it was a good design for a language that already had the reputation of being very complicated to write.<p>I&#x27;m in the same &quot;old school&quot; system dev category as you, and I think that modern languages have gone off the deep end, <i>and</i> I complained about async specifically in a recent comment on HN: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37342711">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37342711</a><p>&gt; At least my clunky select &quot;runtime&quot; code can be safely contained in a couple functions while the rest of the code remains blissfully unaware of the magic going on under the hood.<p>And we could have had that for async as well, if languages were designed by the in-the-trenches industry developer, and not the &quot;I think Haskell and Ocaml is great readability&quot; academic crowd.<p>With async in particular, the most common implementation is to color the functions by qualifying the <i>specific function</i> as async, which IMO is exactly the wrong way to do it.<p>The correct way would be for the caller to mark a <i>specific call</i> as async.<p>IOW, which of the following is clearer to the reader at the point where `foo` is called?<p>Option 1: color the function<p><pre><code>      async function foo () {
         &#x2F;&#x2F; ...
      }
      ...
      let promise = foo ();
      let bar = await promise;

</code></pre>
Option 2: schedule any function<p><pre><code>      function foo () {
         &#x2F;&#x2F; ...
      }

      let sched_id = schedule foo ();

      ...

      let bar = await sched_id;

</code></pre>
Option 1 results in compilation errors for code in the call-stack that isn&#x27;t async, results in needing two different functions (a wrapper for sync execution), and means that async only works for that specific function. Option 2 is more like how humans think - schedule this for later execution, when I&#x27;m done with my current job I&#x27;ll wait for you if you haven&#x27;t finished.</div><br/><div id="37442914" class="c"><input type="checkbox" id="c-37442914" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439174">parent</a><span>|</span><a href="#37439592">next</a><span>|</span><label class="collapse" for="c-37442914">[-]</label><label class="expand" for="c-37442914">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and not the &quot;I think Haskell and Ocaml is great readability&quot; academic crowd.<p>Actually, Rust could still learn a lot from these languages. In Haskell, one declares the call site as async, rather than the function. OCaml 5 effect handlers would be an especially good fit for Rust and solve the &quot;colouration&quot; problem.</div><br/></div></div><div id="37439592" class="c"><input type="checkbox" id="c-37439592" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439174">parent</a><span>|</span><a href="#37442914">prev</a><span>|</span><a href="#37439784">next</a><span>|</span><label class="collapse" for="c-37439592">[-]</label><label class="expand" for="c-37439592">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t mixing async and sync code like this a recipe for deadlocks?<p>What if your example code is holding onto a thread that foo() is waiting to use?<p>Said another way, explain how you solved the problems of just synchronously waiting for async.  If that just worked then we wouldn&#x27;t need to proliferate the async&#x2F;await through the stack.</div><br/><div id="37439924" class="c"><input type="checkbox" id="c-37439924" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439592">parent</a><span>|</span><a href="#37439784">next</a><span>|</span><label class="collapse" for="c-37439924">[-]</label><label class="expand" for="c-37439924">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Said another way, explain how you solved the problems of just synchronously waiting for async.<p>Why? It isn&#x27;t solved for async functions, is it? Just because the async is propagated up the call-stack doesn&#x27;t mean that the call can&#x27;t deadlock, does it?<p>Deadlocks aren&#x27;t solved for a purely synchronous callstack either - A grabbing a resource, then calling B which calls C which calls A ...<p>Deadlocks are potentially there whether or not you mix sync&#x2F;async. All that colored functions will get you is the ability to ignore the deadlock because <i>that</i> entire call-stack is stuck.<p>&gt;  If that just worked then we wouldn&#x27;t need to proliferate the async&#x2F;await through the stack.<p>It&#x27;s why I called it a leaky abstraction.</div><br/><div id="37440115" class="c"><input type="checkbox" id="c-37440115" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439924">parent</a><span>|</span><a href="#37439784">next</a><span>|</span><label class="collapse" for="c-37440115">[-]</label><label class="expand" for="c-37440115">[2 more]</label></div><br/><div class="children"><div class="content">Yes actually it is solved.  If you stick to async then it cannot deadlock (in this way) because you yield execution to await.</div><br/><div id="37442999" class="c"><input type="checkbox" id="c-37442999" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37440115">parent</a><span>|</span><a href="#37439784">next</a><span>|</span><label class="collapse" for="c-37442999">[-]</label><label class="expand" for="c-37442999">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yes actually it is solved. If you stick to async then it cannot deadlock (in this way) because you yield execution to await.<p>Maybe I&#x27;m misunderstanding what you are saying. I use the word &quot;_implementation_type_&quot; below to mean &quot;either implemented as option 1 or option 2 from my post above.&quot;<p>With current asynchronous implementations (like JS, Rust, etc), any time you use `await` or similar, <i>that statement may never return</i> due to a deadlock in the callstack (A is awaiting B which is awaiting C which is awaiting A).<p>And if you <i>never</i> `await`, then deadlocking is irrelevant to the _implementation_type_ anyway.<p>So I am trying to understand what you mean by &quot;it cannot deadlock in this way&quot; - in what way do you mean? async functions can accidentally await on each other without knowing it, which is the deadlock I am talking about.<p>I think I might understand better if you gave me an example call-chain that, in option 1, sidesteps the deadlock, and in option 2, deadlocks.</div><br/></div></div></div></div></div></div></div></div><div id="37439784" class="c"><input type="checkbox" id="c-37439784" checked=""/><div class="controls bullet"><span class="by">jose_zap</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439174">parent</a><span>|</span><a href="#37439592">prev</a><span>|</span><a href="#37442453">next</a><span>|</span><label class="collapse" for="c-37439784">[-]</label><label class="expand" for="c-37439784">[1 more]</label></div><br/><div class="children"><div class="content">That’s how Haskell async works. You mark the call as async, not the function itself.</div><br/></div></div></div></div><div id="37442453" class="c"><input type="checkbox" id="c-37442453" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436413">parent</a><span>|</span><a href="#37439174">prev</a><span>|</span><a href="#37436896">next</a><span>|</span><label class="collapse" for="c-37442453">[-]</label><label class="expand" for="c-37442453">[1 more]</label></div><br/><div class="children"><div class="content">Actually, this &quot;old school&quot; approach is more readable even for folks who have never worked in the low-level C world. At-least everything is in front of your eyes and you can follow the logic. Unless code leveraging async is <i>very</i> well-structured, it requires too much brain-power to process and understand.</div><br/></div></div><div id="37436896" class="c"><input type="checkbox" id="c-37436896" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436413">parent</a><span>|</span><a href="#37442453">prev</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37436896">[-]</label><label class="expand" for="c-37436896">[7 more]</label></div><br/><div class="children"><div class="content">I think Rust’s async stuff is a little half baked now but I have hope that it will be improved as time goes on.<p>In the mean time it is a little annoying to use, but I don’t mind designing against it by default. I feel less architecturally constrained if more syntactically constrained.</div><br/><div id="37439096" class="c"><input type="checkbox" id="c-37439096" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436896">parent</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37439096">[-]</label><label class="expand" for="c-37439096">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what things you consider to be half-baked about Rust async.<p>I&#x27;ve used Rust async extensively for years, and I consider it to be the cleanest and most well designed async system out of <i>any</i> language (and yes, I have used many languages besides Rust).</div><br/><div id="37440274" class="c"><input type="checkbox" id="c-37440274" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439096">parent</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37440274">[-]</label><label class="expand" for="c-37440274">[5 more]</label></div><br/><div class="children"><div class="content">Async traits come to mind immediately, generally needing more capability to existentially quantify Future types without penalty. Async function types are a mess to write out. More control over heap allocations in async&#x2F;await futures (we currently have to Box&#x2F;Pin more often than necessary). Async drop. Better cancellation. Async iteration.</div><br/><div id="37441014" class="c"><input type="checkbox" id="c-37441014" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37440274">parent</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37441014">[-]</label><label class="expand" for="c-37441014">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Async traits come to mind immediately,<p>I agree that being able to use `async` inside of traits would be very useful, and hopefully we will get it soon.<p>&gt; generally needing more capability to existentially quantify Future types without penalty<p>Could you clarify what you mean by that? Both `impl Future` and `dyn Future` exist, do they not work for your use case?<p>&gt; Async function types are a mess to write out.<p>Are you talking about this?<p><pre><code>    fn foo() -&gt; impl Future&lt;Output = u32&gt;
</code></pre>
Or this?<p><pre><code>    async fn foo() -&gt; u32

</code></pre>
&gt; More control over heap allocations in async&#x2F;await futures (we currently have to Box&#x2F;Pin more often than necessary).<p>I&#x27;m curious about your code that needs to extensively Box. In my experience Boxing is normally just done 1 time when spawning the Future.<p>&gt; Async drop.<p>That would be useful, but I wouldn&#x27;t call the lack of it &quot;half-baked&quot;, since no other mainstream language has it either. It&#x27;s just a nice-to-have.<p>&gt; Better cancellation.<p>What do you mean by that? All Futures&#x2F;Streams&#x2F;etc. support cancellation out of the box, it&#x27;s just automatic with all Futures&#x2F;Streams.<p>If you want really explicit control you can use something like `abortable`, which gives you an AbortHandle, and then you can call `handle.abort()`<p>Rust has some of the best cancellation support out of <i>any</i> async language I&#x27;ve used.<p>&gt; Async iteration.<p>Nicer syntax for Streams would be cool, but the combinators do a good job already, and StreamExt already has a similar API as Iterator.</div><br/><div id="37443425" class="c"><input type="checkbox" id="c-37443425" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37441014">parent</a><span>|</span><a href="#37441364">next</a><span>|</span><label class="collapse" for="c-37443425">[-]</label><label class="expand" for="c-37443425">[1 more]</label></div><br/><div class="children"><div class="content">Re: existential quantification and async function types<p>It&#x27;d be very nice to be able to use `impl` in more locations, representing a type which needs not be known to the user but is constant. This is a common occurrence and may let us write code like `fn foo(f: impl Fn() -&gt; impl Future)` or maybe even eventually syntax sugar like `fn foo(f: impl async Fn())` which would be ideal.<p>Re: Boxing<p>I find that a common technique needed to get make abstraction around futures to work is the need to Box::pin things regularly. This isn&#x27;t always an issue, but it&#x27;s frequent enough that it&#x27;s annoying. Moreover, it&#x27;s not strictly necessary given knowledge of the future type, it&#x27;s again more of a matter of Rust&#x27;s minimal existential types.<p>Re: async drop and cancellation.<p>It&#x27;s not always possible to have good guarantees about the cleanup of resources in async contexts. You can use abort, but that will just cause the the next yield point to not return and then the Drops to run. So now you&#x27;re reliant on Drops working. I usually build in a &quot;kind&quot; shutdown with a timer before aborting in light of this.<p>C# has a version of this with their CancelationTokens. They&#x27;re possible to get wrong and it&#x27;s easy to fail to cancel promptly, but by convention it&#x27;s also easy to pass a cancelation request and let tasks do resource cleanup before dying.<p>Re: Async iteration<p>Nicer syntax is definitely the thing. Futures without async&#x2F;await also could just be done with combinators, but at the same time it wasn&#x27;t popular or easy until the syntax was in place. I think there&#x27;s a lot of leverage in getting good syntax and exploring the space of streams more fully.</div><br/></div></div><div id="37441364" class="c"><input type="checkbox" id="c-37441364" checked=""/><div class="controls bullet"><span class="by">kprotty</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37441014">parent</a><span>|</span><a href="#37443425">prev</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37441364">[-]</label><label class="expand" for="c-37441364">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That would be useful, but I wouldn&#x27;t call the lack of it &quot;half-baked&quot;, since no other mainstream language has it either. It&#x27;s just a nice-to-have.<p>Golang supports running asynchronous code in defers, similar with Zig when it still had async.<p>Async-drop gets upgraded from a nice-to-have into an efficiency concern as the current scheme of &quot;finish your cancellation in Drop&quot; doesn&#x27;t support borrowed memory in completion-based APIs like Windows IOCP, Linux io_uring, etc. You have to resort to managed&#x2F;owned memory to make it work in safe Rust which adds unnecessary inefficiency. The other alternatives are blocking in Drop or some language feature to statically guarantee a Future isn&#x27;t cancelled once started&#x2F;initially polled.</div><br/><div id="37443375" class="c"><input type="checkbox" id="c-37443375" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37441364">parent</a><span>|</span><a href="#37436097">next</a><span>|</span><label class="collapse" for="c-37443375">[-]</label><label class="expand" for="c-37443375">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Golang supports running asynchronous code in defers, similar with Zig when it still had async.<p>So does Rust. You can run async code inside `drop`.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37436097" class="c"><input type="checkbox" id="c-37436097" checked=""/><div class="controls bullet"><span class="by">mrkline</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435919">parent</a><span>|</span><a href="#37436413">prev</a><span>|</span><a href="#37436646">next</a><span>|</span><label class="collapse" for="c-37436097">[-]</label><label class="expand" for="c-37436097">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great! But there&#x27;s nothing about it that requires futures.<p>It really annoys me that something like this isn&#x27;t built-in: <a href="https:&#x2F;&#x2F;github.com&#x2F;mrkline&#x2F;channel-drain">https:&#x2F;&#x2F;github.com&#x2F;mrkline&#x2F;channel-drain</a></div><br/><div id="37436437" class="c"><input type="checkbox" id="c-37436437" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436097">parent</a><span>|</span><a href="#37436646">next</a><span>|</span><label class="collapse" for="c-37436437">[-]</label><label class="expand" for="c-37436437">[1 more]</label></div><br/><div class="children"><div class="content">That works for channels, but being able to wait other asynchronous things is better. Timeouts for instance.<p>We could imagine extending this to arbitrary poll-able things. And now we have futures, kind of.</div><br/></div></div></div></div></div></div><div id="37436646" class="c"><input type="checkbox" id="c-37436646" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435894">parent</a><span>|</span><a href="#37435919">prev</a><span>|</span><a href="#37437011">next</a><span>|</span><label class="collapse" for="c-37436646">[-]</label><label class="expand" for="c-37436646">[3 more]</label></div><br/><div class="children"><div class="content">&gt; (But if you&#x27;re only firing up a few tasks, why not just use threads? To get a nice wrapper around an I&#x2F;O event loop?)<p>To get easier timers, to make cancellation at all possible (how to cancel a sync I&#x2F;O operation?), and to write composable code.<p>There are patterns that become simpler in async code and much more complicated in sync code.</div><br/><div id="37441386" class="c"><input type="checkbox" id="c-37441386" checked=""/><div class="controls bullet"><span class="by">kprotty</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436646">parent</a><span>|</span><a href="#37437011">next</a><span>|</span><label class="collapse" for="c-37441386">[-]</label><label class="expand" for="c-37441386">[2 more]</label></div><br/><div class="children"><div class="content">You cancel a sync IO op similar to how you cancel an async one: have another task (i.e OS thread in this case) issue the cancellation. Select semantically spawns a task per case&#x2F;variant and does something similar under the hood if cancellation is implemented.</div><br/><div id="37442083" class="c"><input type="checkbox" id="c-37442083" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37441386">parent</a><span>|</span><a href="#37437011">next</a><span>|</span><label class="collapse" for="c-37442083">[-]</label><label class="expand" for="c-37442083">[1 more]</label></div><br/><div class="children"><div class="content">You can do that, but then the logic of your cancellable thread gets intermingled with the cancellation logic.<p>And since the cancellation logic runs on the cancellable thread, you can&#x27;t really cancel a blocking operation. What you can do is to let it run to completion, check that it was canceled, and discard the value.</div><br/></div></div></div></div></div></div><div id="37437011" class="c"><input type="checkbox" id="c-37437011" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435894">parent</a><span>|</span><a href="#37436646">prev</a><span>|</span><a href="#37437357">next</a><span>|</span><label class="collapse" for="c-37437011">[-]</label><label class="expand" for="c-37437011">[1 more]</label></div><br/><div class="children"><div class="content">He didn&#x27;t say queues though. CSP isn&#x27;t processes streaming data to each other through buffered channels, it&#x27;s one process synchronously passing one message to another. Whichever one gets the the communication point waits for the other.</div><br/></div></div></div></div><div id="37437357" class="c"><input type="checkbox" id="c-37437357" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37435894">prev</a><span>|</span><a href="#37436071">next</a><span>|</span><label class="collapse" for="c-37437357">[-]</label><label class="expand" for="c-37437357">[5 more]</label></div><br/><div class="children"><div class="content">The author does mention that you should probably stop at using Threads and passing data around via channels... but then mentions the C10K problem and says that sometimes you need more... but does not answer the question that I think is begging to be asked: does using Rust async with all the complications (Arc, cloning, Mutex whatever) does actually outperform Threads&#x2F;channels?? Even if it does, by how much? It would be really interesting to know the answer. I have a feeling that Threads&#x2F;channels may be more performant in practice, despite the imagined overhead.</div><br/><div id="37437736" class="c"><input type="checkbox" id="c-37437736" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437357">parent</a><span>|</span><a href="#37441060">next</a><span>|</span><label class="collapse" for="c-37437736">[-]</label><label class="expand" for="c-37437736">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not a good distributed concurrent benchmark in the Techempower Web Framework benchmarks, because the Multiple Queries and Fortunes test programs don&#x27;t use any parallelism or concurrency primitives to win at fast SQL queries.
<a href="https:&#x2F;&#x2F;www.techempower.com&#x2F;benchmarks&#x2F;#section=data-r21&amp;test=query" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.techempower.com&#x2F;benchmarks&#x2F;#section=data-r21&amp;tes...</a><p>From <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37289579">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37289579</a> :<p>&gt; <i>I haven&#x27;t checked, but by the end of the day, I doubt eBPF is much slower than select() on a pipe()?</i><p>Channels have a per-platform implementation.<p>- &quot;Patterns of Distributed Systems (2022)&quot; (2023) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36504073">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36504073</a></div><br/></div></div><div id="37441060" class="c"><input type="checkbox" id="c-37441060" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437357">parent</a><span>|</span><a href="#37437736">prev</a><span>|</span><a href="#37437573">next</a><span>|</span><label class="collapse" for="c-37441060">[-]</label><label class="expand" for="c-37441060">[2 more]</label></div><br/><div class="children"><div class="content">Threads cannot scale at all, because you&#x27;re limited to the number of threads (which is usually quite small).<p>Async code can scale essentially infinitely, because it can multiplex thousands of Futures onto a single thread. And you can have millions of Futures multiplexed onto a dozen threads.<p>This makes async ideal for situations where your program needs to handle a lot of simultaneous I&#x2F;O operations... such as a web server:<p><a href="http:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;08&#x2F;11&#x2F;futures&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;08&#x2F;11&#x2F;futures&#x2F;</a><p>Async wasn&#x27;t invented for the fun of it, it was invented to solve practical real world problems.</div><br/><div id="37441414" class="c"><input type="checkbox" id="c-37441414" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37441060">parent</a><span>|</span><a href="#37437573">next</a><span>|</span><label class="collapse" for="c-37441414">[-]</label><label class="expand" for="c-37441414">[1 more]</label></div><br/><div class="children"><div class="content">Threads, at least on Linux, are much more lightweight than you seem to think. Async Rust can scale better, of course, but you&#x27;re overexaggerating your case.</div><br/></div></div></div></div><div id="37437573" class="c"><input type="checkbox" id="c-37437573" checked=""/><div class="controls bullet"><span class="by">mrfox321</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37437357">parent</a><span>|</span><a href="#37441060">prev</a><span>|</span><a href="#37436071">next</a><span>|</span><label class="collapse" for="c-37437573">[-]</label><label class="expand" for="c-37437573">[1 more]</label></div><br/><div class="children"><div class="content">If your system cannot be decomposed away from shared mutable state, then you cannot avoid lifetime management and synchronization primitives.<p>Ultimately, it depends on your data model.</div><br/></div></div></div></div><div id="37436071" class="c"><input type="checkbox" id="c-37436071" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37437357">prev</a><span>|</span><a href="#37436864">next</a><span>|</span><label class="collapse" for="c-37436071">[-]</label><label class="expand" for="c-37436071">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If there&#x27;s a large object that more than one task needs, either you put it in a task that sends messages containing the relevant query result, or you let each task construct its own copy from the stream of messages.<p>When you can guarantee sole ownership, why not put that exclusive pointer in the message? I’d think that this sort of compile-time lock would be an important advantage for the type system. (I think some VMs actually do this sort of thing dynamically, but I can’t quite remember where I read about it.)<p>On a multiprocessor, there’s of course a balance to be determined between the overhead of shuffling the object’s data back and forth between CPUs and the overhead of serializing and shuffling the queries and responses to the object’s owning thread. But I don’t think the latter approach always wins, does it? At least I can’t tell why it obviously should.</div><br/></div></div><div id="37436864" class="c"><input type="checkbox" id="c-37436864" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37436071">prev</a><span>|</span><a href="#37435910">next</a><span>|</span><label class="collapse" for="c-37436864">[-]</label><label class="expand" for="c-37436864">[1 more]</label></div><br/><div class="children"><div class="content">Channels with passing messages has been around as a solid way for doing async and multi threading since forever. These systems are called actor based systems. Erlang is a good example which uses it as its core. Then on the jvm there is Akka. Axon is another.</div><br/></div></div><div id="37435910" class="c"><input type="checkbox" id="c-37435910" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37436864">prev</a><span>|</span><a href="#37436752">next</a><span>|</span><label class="collapse" for="c-37435910">[-]</label><label class="expand" for="c-37435910">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But then rust also has channels. When you read about it, it talks about &quot;messages&quot;, which to me means little objects. Like a few bytes little.<p>As a wise programmer once said, &quot;Do not communicate by sharing memory; instead, share memory by communicating&quot;</div><br/><div id="37436356" class="c"><input type="checkbox" id="c-37436356" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435910">parent</a><span>|</span><a href="#37436752">next</a><span>|</span><label class="collapse" for="c-37436356">[-]</label><label class="expand" for="c-37436356">[1 more]</label></div><br/><div class="children"><div class="content">Ooh, that&#x27;s very ezn. Ah crap I think I have a race condition.</div><br/></div></div></div></div><div id="37436752" class="c"><input type="checkbox" id="c-37436752" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37435910">prev</a><span>|</span><a href="#37440261">next</a><span>|</span><label class="collapse" for="c-37436752">[-]</label><label class="expand" for="c-37436752">[5 more]</label></div><br/><div class="children"><div class="content">That was the argument for Go. But Go is not used that way. People still share and lock stuff in Go. Go is only safe for race conditions that break the memory model, not all race conditions, as Rust is.</div><br/><div id="37436842" class="c"><input type="checkbox" id="c-37436842" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436752">parent</a><span>|</span><a href="#37440013">next</a><span>|</span><label class="collapse" for="c-37436842">[-]</label><label class="expand" for="c-37436842">[3 more]</label></div><br/><div class="children"><div class="content">Rust protects against data races, not race conditions.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;races.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;races.html</a></div><br/><div id="37439718" class="c"><input type="checkbox" id="c-37439718" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436842">parent</a><span>|</span><a href="#37440013">next</a><span>|</span><label class="collapse" for="c-37439718">[-]</label><label class="expand" for="c-37439718">[2 more]</label></div><br/><div class="children"><div class="content">Go doesn’t protect against even those, which is what the parent meant</div><br/><div id="37440020" class="c"><input type="checkbox" id="c-37440020" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439718">parent</a><span>|</span><a href="#37440013">next</a><span>|</span><label class="collapse" for="c-37440020">[-]</label><label class="expand" for="c-37440020">[1 more]</label></div><br/><div class="children"><div class="content">Go cannot catch data races at compile time (like Rust) but can catch a subset of data races at run time with the race detector. Go provides imperfect, opt-in protection.</div><br/></div></div></div></div></div></div><div id="37440013" class="c"><input type="checkbox" id="c-37440013" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436752">parent</a><span>|</span><a href="#37436842">prev</a><span>|</span><a href="#37440261">next</a><span>|</span><label class="collapse" for="c-37440013">[-]</label><label class="expand" for="c-37440013">[1 more]</label></div><br/><div class="children"><div class="content">Technically, you can break Go&#x27;s memory model via race conditions: Write to an interface on one thread while reading it from another and you may read the old vtable pointer but new data pointer &#x2F; the other way around. Same goes for slices with data&#x2F;length&#x2F;capacity.</div><br/></div></div></div></div><div id="37440261" class="c"><input type="checkbox" id="c-37440261" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37436752">prev</a><span>|</span><a href="#37437335">next</a><span>|</span><label class="collapse" for="c-37440261">[-]</label><label class="expand" for="c-37440261">[1 more]</label></div><br/><div class="children"><div class="content">how do you do bidirectional channels&#x2F;rpc?<p>like “send request to channel A with message 123, make sure to get a response back from channel B exactly for that message”</div><br/></div></div><div id="37437335" class="c"><input type="checkbox" id="c-37437335" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37440261">prev</a><span>|</span><a href="#37435891">next</a><span>|</span><label class="collapse" for="c-37437335">[-]</label><label class="expand" for="c-37437335">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need Rust for that. You can even do it in JavaScript.</div><br/></div></div><div id="37435891" class="c"><input type="checkbox" id="c-37435891" checked=""/><div class="controls bullet"><span class="by">artursapek</span><span>|</span><a href="#37435839">parent</a><span>|</span><a href="#37437335">prev</a><span>|</span><a href="#37436274">next</a><span>|</span><label class="collapse" for="c-37435891">[-]</label><label class="expand" for="c-37435891">[17 more]</label></div><br/><div class="children"><div class="content">this is what Go got right like 10 years ago</div><br/><div id="37436045" class="c"><input type="checkbox" id="c-37436045" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435891">parent</a><span>|</span><a href="#37436143">next</a><span>|</span><label class="collapse" for="c-37436045">[-]</label><label class="expand" for="c-37436045">[13 more]</label></div><br/><div class="children"><div class="content">In the sense that green threads are easier, sure.<p>But green threads were not and are not the right solution for Rust, so it&#x27;s kind of beside the point.  Async Rust is difficult, but it will eventually be possible to use Async Rust inside the Linux kernel, which is something you can&#x27;t do with the Go approach.</div><br/><div id="37436892" class="c"><input type="checkbox" id="c-37436892" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436045">parent</a><span>|</span><a href="#37436154">next</a><span>|</span><label class="collapse" for="c-37436892">[-]</label><label class="expand" for="c-37436892">[3 more]</label></div><br/><div class="children"><div class="content">Rust Futures are essentially green threads, except much lighter-weight, much faster, and implemented in user space instead of being built-in to the language.<p>Basically Rust Futures is what Go wishes it could have. Rust made the right choice in waiting and spending the time to design async <i>right</i>.</div><br/><div id="37441462" class="c"><input type="checkbox" id="c-37441462" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436892">parent</a><span>|</span><a href="#37436154">next</a><span>|</span><label class="collapse" for="c-37441462">[-]</label><label class="expand" for="c-37441462">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re overstating your case. Rust&#x27;s async tasks (based on stackless coroutines) and Go&#x27;s goroutines (based on stackful coroutines) have important differences. Rust&#x27;s design introduces function coloring (tentative solution in progress) but is much more suited for the bare-metal scene that C and C++ are famous for. Go&#x27;s design has more overhead but, by virtue of not having colored functions, is simpler for programmers to write code for. Most things in computer science&#x2F;programming involve tradeoffs. Also, Rust&#x27;s async&#x2F;await <i>is</i> built-in to the language. It&#x27;s not a library implementation of stackless coroutines.</div><br/><div id="37443417" class="c"><input type="checkbox" id="c-37443417" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37441462">parent</a><span>|</span><a href="#37436154">next</a><span>|</span><label class="collapse" for="c-37443417">[-]</label><label class="expand" for="c-37443417">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go&#x27;s design has more overhead but, by virtue of not having colored functions, is simpler for programmers to write code for.<p>Colored functions is a debatable problem at best. I consider it a feature not a bug and it makes reasoning about programs easier at the expense of writing additional async&#x2F;await keywords which is really a very minor annoyance.<p>On the other hand Go&#x27;s need of using channels to do trivial and common tasks like communicating the result of an async task together with the lack of RAII and proper cleanup signaling in channels (you can very easily deadlock if nothing is attached on the other end of the channel), plus no compile time race detection - all that makes writing concurrent code harder.</div><br/></div></div></div></div></div></div><div id="37436154" class="c"><input type="checkbox" id="c-37436154" checked=""/><div class="controls bullet"><span class="by">bojo</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436045">parent</a><span>|</span><a href="#37436892">prev</a><span>|</span><a href="#37436889">next</a><span>|</span><label class="collapse" for="c-37436154">[-]</label><label class="expand" for="c-37436154">[4 more]</label></div><br/><div class="children"><div class="content">I think they are referring to channels, which came with the tagline &quot;share memory by communicating.&quot;</div><br/><div id="37436391" class="c"><input type="checkbox" id="c-37436391" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436154">parent</a><span>|</span><a href="#37436924">next</a><span>|</span><label class="collapse" for="c-37436391">[-]</label><label class="expand" for="c-37436391">[1 more]</label></div><br/><div class="children"><div class="content">Rust has had channels since before Go was even publicly announced. Remember that Rust, like Go, was inspired by Pike&#x27;s earlier language Limbo, which uses CSP. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Limbo_(programming_language)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Limbo_(programming_language)</a></div><br/></div></div><div id="37436924" class="c"><input type="checkbox" id="c-37436924" checked=""/><div class="controls bullet"><span class="by">Pauan</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436154">parent</a><span>|</span><a href="#37436391">prev</a><span>|</span><a href="#37439146">next</a><span>|</span><label class="collapse" for="c-37436924">[-]</label><label class="expand" for="c-37436924">[1 more]</label></div><br/><div class="children"><div class="content">Rust has had OS channels since forever, and async channels for 5 years.<p>Rust has changed a lot in the past 5 years, people just haven&#x27;t noticed, so they assume that Rust is still an old outdated language.</div><br/></div></div><div id="37439146" class="c"><input type="checkbox" id="c-37439146" checked=""/><div class="controls bullet"><span class="by">artursapek</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436154">parent</a><span>|</span><a href="#37436924">prev</a><span>|</span><a href="#37436889">next</a><span>|</span><label class="collapse" for="c-37439146">[-]</label><label class="expand" for="c-37439146">[1 more]</label></div><br/><div class="children"><div class="content">yes</div><br/></div></div></div></div><div id="37436889" class="c"><input type="checkbox" id="c-37436889" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436045">parent</a><span>|</span><a href="#37436154">prev</a><span>|</span><a href="#37436215">next</a><span>|</span><label class="collapse" for="c-37436889">[-]</label><label class="expand" for="c-37436889">[3 more]</label></div><br/><div class="children"><div class="content">We need a way to bridge the gap. Having a runtime may not be suitable for all apps but it can easily allow you to reach 95%+ concurrency performance. The async compile-to-state-machine model is only necessary for the last 5%. Most userland apps rarely need to maximize concurrency efficiency. They need concurrency yes, but performance at the 95th percentile is more than sufficient.</div><br/><div id="37439706" class="c"><input type="checkbox" id="c-37439706" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436889">parent</a><span>|</span><a href="#37436215">next</a><span>|</span><label class="collapse" for="c-37439706">[-]</label><label class="expand" for="c-37439706">[2 more]</label></div><br/><div class="children"><div class="content">I really don’t buy this argument that only some small “special” fraction of apps “actually” need async, and for the rest of us “plebs” we should be relegated to blocking.<p>Async is <i>just hard</i>. That’s it. It’s fundamentally difficult.<p>In my experience language implementations of async fall into 2-axes: clarity and control. C# is straightforward-enough (having cribbed its async design off functional languages) but I find it scores low on the “clarity” scale and moderate-high in control, because you could control it, but it was t always clear.<p>JS is moderate-high clarity, low control: easy to understand, because all the knobs are set for you. Before it got async&#x2F;await sugar, I’d have said it would have been low clarity, because I’ve seen the promise&#x2F;callback hell people wrote when given rope.<p>Python is the bottom of the barrel for both clarity and control. It genuinely has to have the most awful and confusing async design I’ve ever seen.<p>I personally find Rust scores high in both clarity and control. Playing with the Glommio executor was what <i>really</i> solidified my understanding of how async works however.</div><br/><div id="37441651" class="c"><input type="checkbox" id="c-37441651" checked=""/><div class="controls bullet"><span class="by">RickHull</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37439706">parent</a><span>|</span><a href="#37436215">next</a><span>|</span><label class="collapse" for="c-37441651">[-]</label><label class="expand" for="c-37441651">[1 more]</label></div><br/><div class="children"><div class="content">I learned concurrency and parallelism by confronting blocking behavior: waiting on a networking or filesystem request stops the world, so we need a new execution context to keep things moving.<p>What I realized, eventually, is that blocking is a beautiful thing.   Embrace the thread of execution going to sleep, as another thread may now execute on the (single core at the time) CPU.<p>Now you have an organization problem, how to distribute threads across different tasks, some sequential, some parallel, some blocking, some nonblocking.  Thread-per-request?  Thread-per-connection?<p>And now a management problem.  Spawning threads. Killing threads. Thread pools.  Multithreaded logging.  Exceptions and error handling.<p>Totally manageable in mild cases, and big wins in throughput, but scaling limits will present themselves.<p>I confront many of these tradeoffs in a fun little exercise I call &quot;Miner Mover&quot;, implemented in Ruby using many different concurrency primitives here: <a href="https:&#x2F;&#x2F;github.com&#x2F;rickhull&#x2F;miner_mover">https:&#x2F;&#x2F;github.com&#x2F;rickhull&#x2F;miner_mover</a></div><br/></div></div></div></div></div></div><div id="37436215" class="c"><input type="checkbox" id="c-37436215" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436045">parent</a><span>|</span><a href="#37436889">prev</a><span>|</span><a href="#37439143">next</a><span>|</span><label class="collapse" for="c-37436215">[-]</label><label class="expand" for="c-37436215">[1 more]</label></div><br/><div class="children"><div class="content">Maybe &quot;add a runtime that switches execution contexts on behalf of the user&quot; and &quot;force the programmer to reimplement everything&quot; are not the only options.</div><br/></div></div><div id="37439143" class="c"><input type="checkbox" id="c-37439143" checked=""/><div class="controls bullet"><span class="by">artursapek</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436045">parent</a><span>|</span><a href="#37436215">prev</a><span>|</span><a href="#37436143">next</a><span>|</span><label class="collapse" for="c-37439143">[-]</label><label class="expand" for="c-37439143">[1 more]</label></div><br/><div class="children"><div class="content">in the sense that sharing memory by communicating is the right approach</div><br/></div></div></div></div><div id="37436143" class="c"><input type="checkbox" id="c-37436143" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37435891">parent</a><span>|</span><a href="#37436045">prev</a><span>|</span><a href="#37436274">next</a><span>|</span><label class="collapse" for="c-37436143">[-]</label><label class="expand" for="c-37436143">[3 more]</label></div><br/><div class="children"><div class="content">Go: it turns out that generic is actually useful<p>Rust: it turns out that not every concurrency needs to be zero-cost abstraction</div><br/><div id="37438635" class="c"><input type="checkbox" id="c-37438635" checked=""/><div class="controls bullet"><span class="by">tumdum_</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37436143">parent</a><span>|</span><a href="#37436274">next</a><span>|</span><label class="collapse" for="c-37438635">[-]</label><label class="expand" for="c-37438635">[2 more]</label></div><br/><div class="children"><div class="content">Except that Rust hasn’t yet realised it</div><br/><div id="37441498" class="c"><input type="checkbox" id="c-37441498" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37435839">root</a><span>|</span><a href="#37438635">parent</a><span>|</span><a href="#37436274">next</a><span>|</span><label class="collapse" for="c-37441498">[-]</label><label class="expand" for="c-37441498">[1 more]</label></div><br/><div class="children"><div class="content">If Rust had gone with green threads as the core async strategy (I know it was a thing pre-1.0), that would be terrible. You&#x27;re not understanding Rust&#x27;s design goals. Rust&#x27;s async model, while it has several major pain points at present, is still undoubtedly superior for what Rust was <i>made for</i>. It would be a shame to throw all that away. Go can go do it&#x27;s own thing (it has, evidently).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37436274" class="c"><input type="checkbox" id="c-37436274" checked=""/><div class="controls bullet"><span class="by">grug_htmx_dev</span><span>|</span><a href="#37435839">prev</a><span>|</span><a href="#37435914">next</a><span>|</span><label class="collapse" for="c-37436274">[-]</label><label class="expand" for="c-37436274">[42 more]</label></div><br/><div class="children"><div class="content">Yes, async is effectively a much harder version of Rust, and it&#x27;s regrettable how it&#x27;s been shoved down the throats of everyone, while only 1% of projects using it really need it. Hover, async is also amazing in these 1% of cases when it&#x27;s useful.<p>If you have a service that handles massive amounts of network calls at the core (think linkerd, nginx, etc.), or you want to have a massive amount of lightweight tasks in your game, or working on an embedded software where you want cooperative concurrency, async Rust is an amazing super-power.<p>Most system&#x2F;application level things is not going to need async IO. Your REST app is going to be perfectly fine with a threadpool. Even when you do need async, you probably want to use it in a relatively small part of your software (network), while doing most of the things in threads, using channels to pass work around between async&#x2F;blocking IO parts (aka hybrid model).<p>Rust community just mindlessly over-did using async literally everywhere, to the point where the blocking IO Rust (the actually better UX one) became a second class citizen in the ecosystem.<p>Especially visible with web frameworks where there is N well designed async web frameworks (Axum, Wrap, etc.) and if you want a blocking one you get:<p><pre><code>  tiny_http, absolute bare bones but very well done
  rouille - more wholesome, on top of tiny_http, but APIs feel very meh comparing to e.g. Axum
  astra - very interesting but immature, and rather barebones</code></pre></div><br/><div id="37436404" class="c"><input type="checkbox" id="c-37436404" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#37436274">parent</a><span>|</span><a href="#37436638">next</a><span>|</span><label class="collapse" for="c-37436404">[-]</label><label class="expand" for="c-37436404">[32 more]</label></div><br/><div class="children"><div class="content">The argument here is that Rust chose to implement coroutines the wrong way. It went the route of stackless coroutines that need async&#x2F;await and colored functions. This creates all the friction the article laments over.<p>But it also praises Go for its implementation, which is also based on a coroutine of a different kind. Stackful coroutines, which do not have any of these problems.<p>Rust considered using those (and, at first, that was the project&#x27;s direction). Ultimately, they went to the stackless operation model because stackfull coroutine requires a runtime that preempts coroutines (to do essentially what the kernel does with threads). This was deemed too expensive.<p>Most people forget, however, that almost no one is using runtime-free async Rust. Most people use Tokio, which is a runtime that does essentially everything the runtime they were trying to avoid building would have done.<p>So we are left in a situation where most people using async Rust have the worst of both worlds.<p>That being said, you can use async Rust without an async runtime (or rather, an extremely rudimentary one with extremely low overhead). People in the embedded world do. But they are few, and even they often are unconvinced by async Rust for their own reasons.</div><br/><div id="37439886" class="c"><input type="checkbox" id="c-37439886" checked=""/><div class="controls bullet"><span class="by">withoutboats3</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436404">parent</a><span>|</span><a href="#37436588">next</a><span>|</span><label class="collapse" for="c-37439886">[-]</label><label class="expand" for="c-37439886">[6 more]</label></div><br/><div class="children"><div class="content">Rust chose to drop the green thread library so that it could have no runtime, supporting valuable use cases for Rust like embedding a Rust library into a C binary, which we cared about. Go is not really usable for this (technically it&#x27;s possible, but it&#x27;s ridiculous for exactly this reason). So those sorts of users are getting a lot of benefit from Rust not having a green threading runtime. As are any users who are not using async for whatever reason.<p><i>However</i>, async Rust is not using stackless coroutines for this reason - it&#x27;s using stackless coroutines because they achieve a better performance profile than stackful coroutines. You can read all about it on Aaron Turon&#x27;s blog from 2016, when the futures library was first released:<p><a href="http:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;08&#x2F;11&#x2F;futures&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;08&#x2F;11&#x2F;futures&#x2F;</a><p><a href="http:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;09&#x2F;07&#x2F;futures-design&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;09&#x2F;07&#x2F;futures-design&#x2F;</a><p>It is not the case that people using async Rust are getting the &quot;worst of both worlds.&quot; They are getting better performance by default and far greater control over their runtime than they would be using a stackful coroutine feature like Go provides. The trade off is that it&#x27;s a lot more complicated and has a bunch of additional moving parts they have to learn about and understand. There&#x27;s no free lunch.</div><br/><div id="37442019" class="c"><input type="checkbox" id="c-37442019" checked=""/><div class="controls bullet"><span class="by">likeabbas</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37439886">parent</a><span>|</span><a href="#37436588">next</a><span>|</span><label class="collapse" for="c-37442019">[-]</label><label class="expand" for="c-37442019">[5 more]</label></div><br/><div class="children"><div class="content">People love(d) rust because it’s a pleasant language to write code for while also being insanely performant. Async is taking away the first point and making it miserable to write code for. If this trend continues, it’ll ultimately destroy the credibility of the language and people will choose other languages. The proposers of async did not take this into account when they were proposing async</div><br/><div id="37443465" class="c"><input type="checkbox" id="c-37443465" checked=""/><div class="controls bullet"><span class="by">withoutboats3</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37442019">parent</a><span>|</span><a href="#37442692">next</a><span>|</span><label class="collapse" for="c-37443465">[-]</label><label class="expand" for="c-37443465">[1 more]</label></div><br/><div class="children"><div class="content">I designed async&#x2F;await and I absolutely did take this into account. I designed it to be as pleasant as possible under the constraints.</div><br/></div></div><div id="37442692" class="c"><input type="checkbox" id="c-37442692" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37442019">parent</a><span>|</span><a href="#37443465">prev</a><span>|</span><a href="#37436588">next</a><span>|</span><label class="collapse" for="c-37442692">[-]</label><label class="expand" for="c-37442692">[3 more]</label></div><br/><div class="children"><div class="content">Naive question, since I tried my hand at rust years ago, but haven&#x27;t looked at it since: isn&#x27;t it possible to write another crate to build go-like channels? A kind of &quot;write, then lose the reference&quot; function call that places a value on a queue, and an accompanying receiver. That could make life easier for &quot;normal&quot; software development.</div><br/><div id="37443306" class="c"><input type="checkbox" id="c-37443306" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37442692">parent</a><span>|</span><a href="#37436588">next</a><span>|</span><label class="collapse" for="c-37443306">[-]</label><label class="expand" for="c-37443306">[2 more]</label></div><br/><div class="children"><div class="content">There are many such primitives in Rust (including one in the standard library). And it&#x27;s effectively the default, the only annoying thing is the libraries which use async (it is possible to just wrap the async code in sync code, just a little annoying. But I think it&#x27;s what most users of the language should do.)</div><br/><div id="37443456" class="c"><input type="checkbox" id="c-37443456" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37443306">parent</a><span>|</span><a href="#37436588">next</a><span>|</span><label class="collapse" for="c-37443456">[-]</label><label class="expand" for="c-37443456">[1 more]</label></div><br/><div class="children"><div class="content">But &quot;most&quot; users can live with a bit of overhead in return for safe parallelism. It&#x27;s just a handful that wants to squeeze the last bit of power out of a CPU.<p>The other day, Intel revealed a processor with 66 thread support per core. 64 of those threads were called &quot;slow&quot;, because there&#x27;s no prefetching and speculative execution, as they are supposed to be waiting (mainly for memory, but networking could be another option). Perhaps very many cheap hardware threads is a way out of this.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37436588" class="c"><input type="checkbox" id="c-37436588" checked=""/><div class="controls bullet"><span class="by">grug_htmx_dev</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436404">parent</a><span>|</span><a href="#37439886">prev</a><span>|</span><a href="#37437045">next</a><span>|</span><label class="collapse" for="c-37436588">[-]</label><label class="expand" for="c-37436588">[2 more]</label></div><br/><div class="children"><div class="content">Threads are driven by the OS. Something needs to drive couritines, so there&#x27;s no way around needing <i>some</i> (even rudimentary, like in embedded) executor. But to be a versatile and universal systems language, Rust can&#x27;t just build-in executor into a language.<p>I think that stackless coroutines are better than stackfull, in particular for Rust. Everything was done correctly by the Rust team.<p>Again, this is all fair and good, as long as people understand the tradeoff and make good technical decisions around. If they all jump on async bandwagon blind o the obvious limitations, we get where Rust ecosystem is now.</div><br/><div id="37439324" class="c"><input type="checkbox" id="c-37439324" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436588">parent</a><span>|</span><a href="#37437045">next</a><span>|</span><label class="collapse" for="c-37439324">[-]</label><label class="expand" for="c-37439324">[1 more]</label></div><br/><div class="children"><div class="content">Well people who jumped on async bandwagon are deeply involved in Rust community. So if they do something, others have to assume they are doing it right.</div><br/></div></div></div></div><div id="37437045" class="c"><input type="checkbox" id="c-37437045" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436404">parent</a><span>|</span><a href="#37436588">prev</a><span>|</span><a href="#37436987">next</a><span>|</span><label class="collapse" for="c-37437045">[-]</label><label class="expand" for="c-37437045">[1 more]</label></div><br/><div class="children"><div class="content">For better or worse, when faced with choices like this Rust has consistently decided to make sure it&#x27;s workable for the lowest-level usecases (embedded, drivers, etc). I respect the consistency, and I appreciate that it&#x27;s focused on an under-served market, especially compared to eg. web applications (an over-served market, if anything), even if it&#x27;s sometimes a bummer for me personally</div><br/></div></div><div id="37436987" class="c"><input type="checkbox" id="c-37436987" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436404">parent</a><span>|</span><a href="#37437045">prev</a><span>|</span><a href="#37437216">next</a><span>|</span><label class="collapse" for="c-37436987">[-]</label><label class="expand" for="c-37436987">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Rust considered using those (and, at first, that was the project&#x27;s direction). Ultimately, they went to the stackless operation model because stackfull coroutine requires a runtime that preempts coroutines (to do essentially what the kernel does with threads). This was deemed too expensive.<p>Stackful coroutines don&#x27;t require a preemptive runtime. I certainly hope that we didn&#x27;t end up with colored functions in Rust because of such a misconception.</div><br/><div id="37437153" class="c"><input type="checkbox" id="c-37437153" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436987">parent</a><span>|</span><a href="#37437216">next</a><span>|</span><label class="collapse" for="c-37437153">[-]</label><label class="expand" for="c-37437153">[15 more]</label></div><br/><div class="children"><div class="content">They often implement soft preemption. Tokio and others like Glommio do. Usually, it&#x27;s based on interrupts. The runtime schedules a timer to fire an interrupt, and some code is injected into the interrupt handler.<p>This is used to keep track of task runtime quotas so they can yield as soon as possible afterward.<p>This is the same technique used in Go and many others for preemption. If you don&#x27;t add this, futures that don&#x27;t yield can run forever, stalling the system.<p>You are right that it is not strictly necessary, but in practice, it is so helpful as a guard against the yielding problem that it&#x27;s ubiquitous.<p>&gt; I certainly hope that we didn&#x27;t end up with colored functions in Rust because of such a misconception.<p>Misconceptions are everywhere unfortunately!</div><br/><div id="37439646" class="c"><input type="checkbox" id="c-37439646" checked=""/><div class="controls bullet"><span class="by">bboozzoo</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437153">parent</a><span>|</span><a href="#37437224">next</a><span>|</span><label class="collapse" for="c-37439646">[-]</label><label class="expand" for="c-37439646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is the same technique used in Go and many others for preemption. If you don&#x27;t add this, futures that don&#x27;t yield can run forever, stalling the system.<p>You may be referring to this particular issue in Go 
<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;10958">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;10958</a> which I think was somewhat addresses a couple releases back.</div><br/></div></div><div id="37437224" class="c"><input type="checkbox" id="c-37437224" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437153">parent</a><span>|</span><a href="#37439646">prev</a><span>|</span><a href="#37437216">next</a><span>|</span><label class="collapse" for="c-37437224">[-]</label><label class="expand" for="c-37437224">[13 more]</label></div><br/><div class="children"><div class="content">&gt; You are right that it is not strictly necessary, but in practice, it is so helpful as a guard against the yielding problem that it&#x27;s ubiquitous.<p>This is honestly shocking to hear. I would think that if people had bugs in their programs they would want them to fail loudly so they can be fixed.</div><br/><div id="37437796" class="c"><input type="checkbox" id="c-37437796" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437224">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37437796">[-]</label><label class="expand" for="c-37437796">[11 more]</label></div><br/><div class="children"><div class="content">As someone else said, it is not, strictly speaking, a bug. If your server receives a request that requires very computationally expensive work, is it okay to delay every other request on that core? That&#x27;s probably not okay, and it&#x27;ll show in your latency distribution.<p>Folks would rather have every future time sliced so that other tasks get some CPU time in a ~fair way (after all, there is no concept of task priority in most runtime).<p>But you&#x27;re right: it isn&#x27;t required, and you could sprinkle every loop of your code with yielding statements. But knowing when to yield is impossible for a future. If nothing else is running, it shouldn&#x27;t yield. If many things are running but the problem space of the future is small, it probably shouldn&#x27;t yield either, etc.<p>You simply do not have the necessary information in your future to make an informed decision. You need some global entity to keep track of everything and either yield for you or tell you when you should yield. Tokio does the former, Glommio does the latter.<p>It gets even more complex when you add IO into the mix because you need to submit IO requests in a way that saturates the network&#x2F;nvme drives&#x2F;whatever. So if a future submits an IO request, it&#x27;s probably advantageous to yield immediately afterward so that other futures may do so as well. That&#x27;s how you maximize throughput. But as I said, that&#x27;s a very hard problem to solve.</div><br/><div id="37438425" class="c"><input type="checkbox" id="c-37438425" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437796">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37438425">[-]</label><label class="expand" for="c-37438425">[10 more]</label></div><br/><div class="children"><div class="content">Trying to solve the problem by frequently invoking signal handlers will also show in your latency distribution!<p>I guess if someone wants to use futures as if they were goroutines then it&#x27;s not a bug, but this sort of presupposes that an opinionated runtime is already shooting signals at itself. Fundamentally the language gives you a primitive for switching execution between one context and another, and the premise of the program is probably that execution will switch back pretty quickly from work related to any single task.<p>I read the blog about this situation at <a href="https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2020-04-preemption" rel="nofollow noreferrer">https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2020-04-preemption</a> which is equally baffling. The described problem cannot even happen in the &quot;runtime&quot; I&#x27;m currently using because io_uring won&#x27;t just completely stop responding to other kinds of sqe&#x27;s and only give you responses to a multishot accept when a lot of connections are coming in. I strongly suspect equivalent results are achievable with epoll.</div><br/><div id="37439543" class="c"><input type="checkbox" id="c-37439543" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37438425">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37439543">[-]</label><label class="expand" for="c-37439543">[9 more]</label></div><br/><div class="children"><div class="content">&gt;Trying to solve the problem by frequently invoking signal handlers will also show in your latency distribution!<p>So just like any other kind of scheduling? &quot;Frequently&quot; is also very subjective, and there are tradeoffs between throughput, latency, and especially tail latency. You can improve throughput and minimum latency by never preempting tasks, but it&#x27;s bad for average, median, and tail latency when longer tasks starve others, otherwise SCHED_FIFO would be the default for Linux.<p>&gt;I read the blog about this situation at <a href="https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2020-04-preemption" rel="nofollow noreferrer">https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2020-04-preemption</a> which is equally baffling<p>You&#x27;ve misunderstood the problem somehow. There is definitely nothing about tokio (which uses epoll on Linux and can use io_uring) not responding in there. io_uring and epoll have nothing to do with it and can&#x27;t avoid the problem: the problem is with code that can make progress and doesn&#x27;t need to poll for anything. The problem isn&#x27;t unique to Rust either, and it&#x27;s going to exist in any cooperative multitasking system: if you rely on tasks to yield by themselves, some won&#x27;t.</div><br/><div id="37442357" class="c"><input type="checkbox" id="c-37442357" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37439543">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37442357">[-]</label><label class="expand" for="c-37442357">[8 more]</label></div><br/><div class="children"><div class="content">&gt; So just like any other kind of scheduling?<p>Yes. Industries that care about latency take some pains to avoid this as well, of course.<p>&gt; io_uring and epoll have nothing to do with it and can&#x27;t avoid the problem: the problem is with code that can make progress and doesn&#x27;t need to poll for anything.<p>They totally can though? If I write the exact same code that is called out as problematic in the post, my non-preemptive runtime will run a variety of tasks while non-preemptive tokio is claimed to run only one. This is because my `accept` method would either submit an &quot;accept sqe&quot; to io_uring and swap to the runtime or do nothing and swap to the runtime (in the case of a multishot accept). Then the runtime would continue processing all cqes in order received, not *only* the `accept` cqes. The tokio `accept` method and event loop could also avoid starving other tasks if the `accept` method was guaranteed to poll at least some portion of the time and all ready handlers from one poll were guaranteed to be called before polling again.<p>This sort of design solves the problem for any case of &quot;My task that is performing I&#x2F;O through my runtime is starving my other tasks.&quot; The remaining tasks that can starve other tasks are those that perform I&#x2F;O by bypassing the runtime and those that spend a long time performing computations with no I&#x2F;O. The former thing sounds like self-sabotage by the user, but unfortunately the latter thing probably requires the user to spend some effort on designing their program.<p>&gt; The problem isn&#x27;t unique to Rust either, and it&#x27;s going to exist in any cooperative multitasking system: if you rely on tasks to yield by themselves, some won&#x27;t.<p>If we leave the obvious defects in our software, we will continue running software with obvious defects in it, yes.</div><br/><div id="37442735" class="c"><input type="checkbox" id="c-37442735" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37442357">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37442735">[-]</label><label class="expand" for="c-37442735">[7 more]</label></div><br/><div class="children"><div class="content">&gt;This sort of design solves the problem for any case of &quot;My task that is performing I&#x2F;O through my runtime is starving my other tasks.&quot;<p>Yeah, there&#x27;s your misunderstanding, you&#x27;ve got it backwards. The problem being described occurs when I&#x2F;O isn&#x27;t happening because it isn&#x27;t needed, there isn&#x27;t a problem when I&#x2F;O does need to happen.<p>Think of buffered reading of a file, maybe a small one that fully fits into the buffer, and reading it one byte at a time. Reading the first byte will block and go through epoll&#x2F;io_uring&#x2F;kqueue to fill the buffer and other tasks can run, but subsequent calls won&#x27;t and they can return immediately without ever needing to touch the poller. Or maybe it&#x27;s waiting on a channel in a loop, but the producer of that channel pushed more content onto it before the consumer was done so no blocking is needed.<p>You can solve this by never writing tasks that can take &quot;a lot&quot; of time, or &quot;continue&quot;, whatever that means, but that&#x27;s pretty inefficient in its own right. If my theoretical file reading task is explicitly yielding to the runtime on every byte by calling yield(), it is going to be very slow. You&#x27;re not going to go through io_uring for every single byte of a file individually when running &quot;while next_byte = async_read_next_byte(file) {}&quot; code in any language if you have heap memory available to buffer it.</div><br/><div id="37443043" class="c"><input type="checkbox" id="c-37443043" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37442735">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37443043">[-]</label><label class="expand" for="c-37443043">[6 more]</label></div><br/><div class="children"><div class="content">Reading from a socket, as in the linked post, is an example of not performing I&#x2F;O? I&#x27;m not familiar with tokio so I did not know that it maintained buffers in userspace and filled them before the user called read(), but this is unimportant, it could still have read() yield and return the contents of the buffer.<p>I assumed that users would issue reads of like megabytes at a time and usually receive less. Does the example of reading from a socket in the blog post presuppose a gigabyte-sized buffer? It sounds like a bigger problem with the program is the per-connection memory overhead in that case.<p>The proposal is obviously not to yield 1 million times before returning a 1 meg buffer or to call read(2) passing a buffer length of 1, is this trolling? The proposal is also not some imaginary pie-in-the-sky idea; it&#x27;s currently trading millions of dollars of derivatives daily on a single thread.</div><br/><div id="37443214" class="c"><input type="checkbox" id="c-37443214" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37443043">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37443214">[-]</label><label class="expand" for="c-37443214">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;re confusing IO not happening because it&#x27;s not needed with IO never happening. Just because a method can perform IO doesn&#x27;t mean it actually does every time you call it. If I call async_read(N) for the next N bytes, that isn&#x27;t necessarily going to touch the IO driver. If your task can make progress without polling, it doesn&#x27;t need to poll.<p>&gt;I&#x27;m not familiar with tokio so I did not know that it maintained buffers in userspace<p>Most async runtimes are going to do buffering on some level, for efficiency if nothing else. It&#x27;s not strictly required but you&#x27;ve had an unusual experience if you&#x27;ve never seen buffering.<p>&gt;filled them before the user called read()<p>Where did you get this idea? Since you seem to be quick to accuse others of it, this does seem like trolling. At the very least it&#x27;s completely out of nowhere.<p>&gt;it could still have read() yield and return the contents of the buffer.<p>If I call a read_one_byte, read_line, or read(N) method and it returns past the end of the requested content that would be a problem.<p>&gt;I assumed that users would issue reads of like megabytes at a time and usually receive less.<p>Reading from a channel is the other easy example, if files were hard to follow. The channel read might implemented as a quick atomic check to see if something is available and consume it, only yielding to the runtime if it needs to wait. If a producer on the other end is producing things faster than the consumer can consume them, the consuming task will never yield. You can implement a channel read method that always yields, but again, that&#x27;d be slow.<p>&gt;The proposal is obviously not to yield 1 million times before returning a 1 meg buffer, is this trolling<p>No, giving a illustrative example is not trolling, even if I kept the numbers simple to make it easy to follow. But your flailing about with the idea of requiring gigabyte sized buffers probably is.</div><br/><div id="37443279" class="c"><input type="checkbox" id="c-37443279" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37443214">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37443279">[-]</label><label class="expand" for="c-37443279">[4 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re confusing IO not happening because it&#x27;s not needed with IO never happening. Just because a method can perform IO doesn&#x27;t mean it actually does every time you call it. If I call async_read(N) for the next N bytes, that isn&#x27;t necessarily going to touch the IO driver.<p>Maybe you can read the linked post again? The problem in the example in the post is that data keeps coming from the network. If you were to strace the program, you would see it calling read(2) repeatedly. The runtime chooses to starve all other tasks as long as these reads return more than 0 bytes. This is obviously not the only option available.<p>I apologize for charitably assuming that you were correct in the rest of my reply and attempting to fill in the necessary circumstances which would have made you correct</div><br/><div id="37443317" class="c"><input type="checkbox" id="c-37443317" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37443279">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37443317">[-]</label><label class="expand" for="c-37443317">[3 more]</label></div><br/><div class="children"><div class="content">Actually, no, I misread it trying to make sense of what you were posting so this post is edited.<p>This is just mundane non-blocking sockets. If the socket never needs to block, it won&#x27;t yield. Why go through epoll&#x2F;uring unless it returns EWOULDBLOCK?</div><br/><div id="37443447" class="c"><input type="checkbox" id="c-37443447" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37443317">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37443447">[-]</label><label class="expand" for="c-37443447">[2 more]</label></div><br/><div class="children"><div class="content">For io_uring all the reads go through io_uring and generally don&#x27;t send back a result until some data is ready. So you&#x27;ll receive a single stream of syscall results in which the results for all fds are interleaved, and you won&#x27;t even be able to write code that has one task doing I&#x2F;O starving other tasks. For epoll, polling the epoll instance is how you get notified of the readiness for all the other fds too. But the  important thing isn&#x27;t to poll the socket that you know is ready, it&#x27;s to yield to runtime at all, so that other tasks can be resumed. Amusingly upon reading the rest of the blog post I discovered that this is exactly what tokio does. It just always yields after a certain number of operations that could yield. It doesn&#x27;t implement preemption.</div><br/><div id="37443469" class="c"><input type="checkbox" id="c-37443469" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37443447">parent</a><span>|</span><a href="#37437382">next</a><span>|</span><label class="collapse" for="c-37443469">[-]</label><label class="expand" for="c-37443469">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I assumed you had read the article and were just confused about how tokio was pretending to have preemption. Now you reveal you hadn&#x27;t read the article so now I&#x27;m confused about you general, it seems like a waste of time. But I&#x27;m glad you agree with me that you need to yield even when something is ready so that other tasks can run.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37437382" class="c"><input type="checkbox" id="c-37437382" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437224">parent</a><span>|</span><a href="#37437796">prev</a><span>|</span><a href="#37437216">next</a><span>|</span><label class="collapse" for="c-37437382">[-]</label><label class="expand" for="c-37437382">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing buggy about a future that never yields because it can always make progress, but people prefer that a runtime doesn&#x27;t let all other execution get starved by one operation. That makes it a problem that runtimes and schedulers work to solve, but not a bug that needs to be prevented at a language level. A runtime that doesn&#x27;t solve it isn&#x27;t buggy, but probably isn&#x27;t friendly to use, like how Go used to have problems with tight loops and they put in changes to make them cause less starvation.</div><br/></div></div></div></div></div></div></div></div><div id="37437216" class="c"><input type="checkbox" id="c-37437216" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436404">parent</a><span>|</span><a href="#37436987">prev</a><span>|</span><a href="#37439644">next</a><span>|</span><label class="collapse" for="c-37437216">[-]</label><label class="expand" for="c-37437216">[5 more]</label></div><br/><div class="children"><div class="content">&gt;  because stackfull coroutine requires a runtime that preempts coroutines<p>I&#x27;ve used stackful coroutines many times in many codebases. It never required or used a runtime or preemption. I&#x27;m not sure why having a runtime that preempts them would even be useful, since it defeats the reason most people use stackful coroutines in the first place.</div><br/><div id="37437251" class="c"><input type="checkbox" id="c-37437251" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437216">parent</a><span>|</span><a href="#37438016">next</a><span>|</span><label class="collapse" for="c-37437251">[-]</label><label class="expand" for="c-37437251">[1 more]</label></div><br/><div class="children"><div class="content">&quot;stackful coroutines&quot; the control-flow primitive is cumbersome to build on top of &quot;green threads&quot; but for use cases that are mostly about blocking on lots of distinct I&#x2F;O calls at the same time people may be indifferent between these two things. These conversations are often muddled because the feature shipped most often is called &quot;async&quot; and not called &quot;jump to another stack please&quot; :(</div><br/></div></div><div id="37438016" class="c"><input type="checkbox" id="c-37438016" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437216">parent</a><span>|</span><a href="#37437251">prev</a><span>|</span><a href="#37439644">next</a><span>|</span><label class="collapse" for="c-37438016">[-]</label><label class="expand" for="c-37438016">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve used stackful coroutines many times in many codebases. It never required or used a runtime or preemption.<p>Can you tell us which? Go, Haskell and the other usual suspect all have runtime with automatic, transparent preemption.</div><br/><div id="37440293" class="c"><input type="checkbox" id="c-37440293" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37438016">parent</a><span>|</span><a href="#37438729">next</a><span>|</span><label class="collapse" for="c-37440293">[-]</label><label class="expand" for="c-37440293">[1 more]</label></div><br/><div class="children"><div class="content">It was always C++ for some type of high-performance data processing engine. Around half the stackful coroutine implementations were off-the-shelf libraries (e.g. Boost::Context) and the other half were purpose-built from scratch, depending on the feature requirements. The typical model is that you have stackful coroutines at a coarse level, e.g. per database query, which may dispatch hundreds of concurrent state machines. All execution and I&#x2F;O scheduling is explicitly done by the software, which enables some significant runtime optimizations.<p>If coroutines can be preempted then it introduces a requirement for concurrency control that otherwise doesn&#x27;t need to exist and interferes with dynamic cache locality optimizations. These are some of the primary benefits of using stackful coroutines in this context.<p>Being able to interrupt a stackful coroutine has utility for dealing with an extremely slow or stuck thread but you want this to be zero-overhead unless the thread is actually stuck. In most system designs, the time required to traverse any pair of sequential yield points is well-bounded so things getting &quot;stuck&quot; is usually a bug.<p>Letting end-users inject arbitrary code into these paths at runtime does require the ability to interrupt the thread but even that is often handled explicitly by more nuanced means than random preemption. Sometimes &quot;extremely slow&quot; is correct and expected behavior, so you have to schedule around it.</div><br/></div></div><div id="37438729" class="c"><input type="checkbox" id="c-37438729" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37438016">parent</a><span>|</span><a href="#37440293">prev</a><span>|</span><a href="#37439644">next</a><span>|</span><label class="collapse" for="c-37438729">[-]</label><label class="expand" for="c-37438729">[1 more]</label></div><br/><div class="children"><div class="content">Lua comes with this sort of thing. OCaml, Python, and C have libraries providing this sort of thing in decreasing order of adoption.<p>Python also comes with 2 features that seem to be stackless coroutines with attached syntax ceremonies, but one of those 2 features is commonly used with a hefty runtime instead of being used for control flow. JavaScript comes with 2 features named similarly to those of Python, but only one of them seems to be &quot;runtime-free&quot; stackless coroutines.</div><br/></div></div></div></div></div></div><div id="37439644" class="c"><input type="checkbox" id="c-37439644" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436404">parent</a><span>|</span><a href="#37437216">prev</a><span>|</span><a href="#37436638">next</a><span>|</span><label class="collapse" for="c-37439644">[-]</label><label class="expand" for="c-37439644">[1 more]</label></div><br/><div class="children"><div class="content">The reason Rust chose stackless coroutines is because it allows zero cost FFI, which for a systems language is extremely important.</div><br/></div></div></div></div><div id="37436638" class="c"><input type="checkbox" id="c-37436638" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37436274">parent</a><span>|</span><a href="#37436404">prev</a><span>|</span><a href="#37436541">next</a><span>|</span><label class="collapse" for="c-37436638">[-]</label><label class="expand" for="c-37436638">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, async is effectively a much harder version of Rust, and it&#x27;s regrettable how it&#x27;s been shoved down the throats of everyone, while only 1% of projects using it really need it.<p>Yes. I just noticed that Tokio was pulled into my program as a dependency. Again. It&#x27;s not being used, but I&#x27;m using a crate which has a function I&#x27;m not using which imports reqwest, which imports h2, which imports tokio.</div><br/><div id="37436690" class="c"><input type="checkbox" id="c-37436690" checked=""/><div class="controls bullet"><span class="by">grug_htmx_dev</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436638">parent</a><span>|</span><a href="#37438627">next</a><span>|</span><label class="collapse" for="c-37436690">[-]</label><label class="expand" for="c-37436690">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, because something somewhere needs to make one http call, and it&#x27;s would be impossible if it wasn&#x27;t done with scalable async executor. &#x2F;i</div><br/></div></div><div id="37438627" class="c"><input type="checkbox" id="c-37438627" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436638">parent</a><span>|</span><a href="#37436690">prev</a><span>|</span><a href="#37436541">next</a><span>|</span><label class="collapse" for="c-37438627">[-]</label><label class="expand" for="c-37438627">[2 more]</label></div><br/><div class="children"><div class="content">PR them to use ureq. ;)</div><br/><div id="37441196" class="c"><input type="checkbox" id="c-37441196" checked=""/><div class="controls bullet"><span class="by">wrapperup</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37438627">parent</a><span>|</span><a href="#37436541">next</a><span>|</span><label class="collapse" for="c-37441196">[-]</label><label class="expand" for="c-37441196">[1 more]</label></div><br/><div class="children"><div class="content">I recently did this in a relatively small crate, and it halved the dependencies. Highly recommended if you don&#x27;t need async.</div><br/></div></div></div></div></div></div><div id="37436541" class="c"><input type="checkbox" id="c-37436541" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#37436274">parent</a><span>|</span><a href="#37436638">prev</a><span>|</span><a href="#37435914">next</a><span>|</span><label class="collapse" for="c-37436541">[-]</label><label class="expand" for="c-37436541">[5 more]</label></div><br/><div class="children"><div class="content">Is there any reason to use async when your platform supports virtual threads?<p>I ask as someone who uses java and is about to rewrite a bunch of code to be able to chuck the entire async paradigm into the trash can and use a blocking model but on virtual threads where blocking is ok.</div><br/><div id="37436629" class="c"><input type="checkbox" id="c-37436629" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436541">parent</a><span>|</span><a href="#37440210">next</a><span>|</span><label class="collapse" for="c-37436629">[-]</label><label class="expand" for="c-37436629">[3 more]</label></div><br/><div class="children"><div class="content">Virtual threads or green threads, etc., are all names for the same thing: stackful coroutines. I would say yes! If your language&#x2F;platform&#x2F;runtime supports them, that should definitely be your starting point.</div><br/><div id="37437243" class="c"><input type="checkbox" id="c-37437243" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436629">parent</a><span>|</span><a href="#37440210">next</a><span>|</span><label class="collapse" for="c-37437243">[-]</label><label class="expand" for="c-37437243">[2 more]</label></div><br/><div class="children"><div class="content">&gt; that should definitely be your starting point.<p>Could you expand a bit? Why?</div><br/><div id="37437499" class="c"><input type="checkbox" id="c-37437499" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37437243">parent</a><span>|</span><a href="#37440210">next</a><span>|</span><label class="collapse" for="c-37437499">[-]</label><label class="expand" for="c-37437499">[1 more]</label></div><br/><div class="children"><div class="content">Not OP, but synchronous code is much, much easier to understand and write than asynchronous code. What Java is doing is making synchronous code have all the advantages of asynchronous code by making blocking a Thread become a cheap operation (instead of blocking a real OS Thread), making the whole benfit of async code go away while getting rid of async&#x27;s difficulties, specially in a language that doesn&#x27;t have async&#x2F;await (which makes async code &quot;look&quot; synchronous - but in Rust, as this blog post shows, that is not really the case).</div><br/></div></div></div></div></div></div><div id="37440210" class="c"><input type="checkbox" id="c-37440210" checked=""/><div class="controls bullet"><span class="by">carimura</span><span>|</span><a href="#37436274">root</a><span>|</span><a href="#37436541">parent</a><span>|</span><a href="#37436629">prev</a><span>|</span><a href="#37435914">next</a><span>|</span><label class="collapse" for="c-37440210">[-]</label><label class="expand" for="c-37440210">[1 more]</label></div><br/><div class="children"><div class="content">Hot off the presses from the JVM Language Summit a few weeks ago; The Challenges of Introducing Virtual Threads to the Java Platform [1]<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WsCJYQDPrrE">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WsCJYQDPrrE</a></div><br/></div></div></div></div></div></div><div id="37435914" class="c"><input type="checkbox" id="c-37435914" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37436274">prev</a><span>|</span><a href="#37435741">next</a><span>|</span><label class="collapse" for="c-37435914">[-]</label><label class="expand" for="c-37435914">[7 more]</label></div><br/><div class="children"><div class="content">Async is also spread through so many crates that your program will have to be async in its entirety, or at least depend on the tokio crate for a lot of things. Want a web server? Async + tokio or gtfo. Want an sql connector? You better write your own, unless you want async. Each with a different solution to the various problems async brings -- and dont even get me started on async closures and such shit, thats where hell pokes through the earth and does unholy things your compiler.<p>I enjoy Rust, and I love how the compiler helps me solve problems. However, the ecosystem is &quot;async or gtfo&quot;, or &quot;just write it yourself if you dont want async lmao&quot;, and that&#x27;s not good enough.</div><br/><div id="37436673" class="c"><input type="checkbox" id="c-37436673" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#37435914">parent</a><span>|</span><a href="#37435741">next</a><span>|</span><label class="collapse" for="c-37436673">[-]</label><label class="expand" for="c-37436673">[6 more]</label></div><br/><div class="children"><div class="content">A lot of that pain could have been avoided if the language had better primitives for async in the std or in the futures crate. Like a trait that executor must implement and a &quot;default&quot; blocking executor to execute async code from sync.<p>Right now even building a library that support multiple async runtimes is a PITA, I have done it a couple times. So you end up supporting either just tokio and maybe async-std.</div><br/><div id="37438066" class="c"><input type="checkbox" id="c-37438066" checked=""/><div class="controls bullet"><span class="by">half-kh-hacker</span><span>|</span><a href="#37435914">root</a><span>|</span><a href="#37436673">parent</a><span>|</span><a href="#37439839">next</a><span>|</span><label class="collapse" for="c-37438066">[-]</label><label class="expand" for="c-37438066">[4 more]</label></div><br/><div class="children"><div class="content">so it&#x27;s clear to non-Rust devs, we <i>do</i> have basic primitives for &quot;running async code from sync&quot;:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;executor&#x2F;fn.block_on.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;executor&#x2F;fn.block_on....</a><p>imagine you have an:<p><pre><code>    async fn do_things() -&gt; Something { &#x2F;* ... *&#x2F; }
</code></pre>
you can:<p><pre><code>    use futures::executor::block_on;
    fn my_normal_code() {
      let something = block_on(do_things());
    }

</code></pre>
but this does get messy if the async code you&#x27;re running isn&#x27;t runtime-agnostic :(</div><br/><div id="37438987" class="c"><input type="checkbox" id="c-37438987" checked=""/><div class="controls bullet"><span class="by">colinsane</span><span>|</span><a href="#37435914">root</a><span>|</span><a href="#37438066">parent</a><span>|</span><a href="#37438406">next</a><span>|</span><label class="collapse" for="c-37438987">[-]</label><label class="expand" for="c-37438987">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can break the chain by commanding the entire runtime to block on the completion of a future, but you probably shouldn’t do this pervasively since it isn’t composable. If a function blocks on a future, and that future calls a function that blocks on a future, congrats! The runtime panics!<p>article says you can panic if you use the pattern you show. specifically, if you call `my_normal_code()` from an async context.<p>is the author just talking about a quirk in tokio? or is this sort of wrapping intrinsically dangerous somehow?</div><br/><div id="37440194" class="c"><input type="checkbox" id="c-37440194" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#37435914">root</a><span>|</span><a href="#37438987">parent</a><span>|</span><a href="#37438406">next</a><span>|</span><label class="collapse" for="c-37440194">[-]</label><label class="expand" for="c-37440194">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not intrinsic to async functions; you can block on a future inside another future via e.g. pollster or even manual polling.</div><br/></div></div></div></div><div id="37438406" class="c"><input type="checkbox" id="c-37438406" checked=""/><div class="controls bullet"><span class="by">0xDEF</span><span>|</span><a href="#37435914">root</a><span>|</span><a href="#37438066">parent</a><span>|</span><a href="#37438987">prev</a><span>|</span><a href="#37439839">next</a><span>|</span><label class="collapse" for="c-37438406">[-]</label><label class="expand" for="c-37438406">[1 more]</label></div><br/><div class="children"><div class="content">In the .Net&#x2F;C# world library users just expect that the library has implemented both DoThings() and DoThingsAsync(). However that is easier said that done because many of the foundational low-level IO APIs were implemented by Microsoft that first implemented IoMethod() and then implemented IoMethodAsync() when async&#x2F;await became a thing in C#.</div><br/></div></div></div></div><div id="37439839" class="c"><input type="checkbox" id="c-37439839" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37435914">root</a><span>|</span><a href="#37436673">parent</a><span>|</span><a href="#37438066">prev</a><span>|</span><a href="#37435741">next</a><span>|</span><label class="collapse" for="c-37439839">[-]</label><label class="expand" for="c-37439839">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  A lot of that pain could have been avoided if the language had better primitives for async in the std or in the futures crate. Like a trait that executor must implement and a &quot;default&quot; blocking executor to execute async code from sync.<p>This is one of the goals of the async working group. Hopefully, when ready, that&#x27;ll make it possible to swap out async runtimes underneath arbitrary code without issues.</div><br/></div></div></div></div></div></div><div id="37435741" class="c"><input type="checkbox" id="c-37435741" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#37435914">prev</a><span>|</span><a href="#37436824">next</a><span>|</span><label class="collapse" for="c-37435741">[-]</label><label class="expand" for="c-37435741">[31 more]</label></div><br/><div class="children"><div class="content">&gt; Used pervasively, Arc gives you the world’s worst garbage collector. Like a GC, the lifetime of objects and the resources they represent (memory, files, sockets) is unknowable. But you take this loss without the wins you’d get from an actual GC!<p>The lifetime of an Arc isn’t unknowable, it’s determined by where and how you hold it.<p>I think maybe the disconnect in this article is that the author is coming at Rust and trying to force their previous mental models on to it (such as garbage collection) rather than learning how to work with the language. It’s a common trap for anyone trying a new programming language, but Rust seems to trip people up more than most.</div><br/><div id="37435853" class="c"><input type="checkbox" id="c-37435853" checked=""/><div class="controls bullet"><span class="by">mrkline</span><span>|</span><a href="#37435741">parent</a><span>|</span><a href="#37435991">next</a><span>|</span><label class="collapse" for="c-37435853">[-]</label><label class="expand" for="c-37435853">[23 more]</label></div><br/><div class="children"><div class="content">&gt; The lifetime of an Arc isn’t unknowable, it’s determined by where and how you hold it.<p>In the same sense that the lifetime of an object in a GC&#x27;d system has a lower bound of, &quot;as long as it&#x27;s referenced&quot;, sure. But that&#x27;s nearly the opposite of what the borrow checker tries to do by statically bounding objects, at compile time.<p>&gt; maybe the disconnect in this article is that the author is coming at Rust and trying to force their previous mental models on to it<p>The opposite actually! I spent about a decade doing systems programming in C, C++, and Rust before writing a bunch of Haskell at my current job. The degree to which a big language runtime and GC <i>weren&#x27;t</i> a boogeyman for some problem spaces was really eye-opening.</div><br/><div id="37436232" class="c"><input type="checkbox" id="c-37436232" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37435853">parent</a><span>|</span><a href="#37436003">next</a><span>|</span><label class="collapse" for="c-37436232">[-]</label><label class="expand" for="c-37436232">[6 more]</label></div><br/><div class="children"><div class="content">&gt; But that&#x27;s nearly the opposite of what the borrow checker tries to do by statically bounding objects, at compile time.<p>Arc isn&#x27;t an end-run around the borrow checker. If you need mutable references to the data inside of Arc, you still need to use something like a Mutex or Atomic types as appropriate.<p>&gt; The degree to which a big language runtime and GC weren&#x27;t a boogeyman for some problem spaces was really eye-opening.<p>I have the opposite experience, actually. I was an early adopter of Go and championed Garbage Collection for a long time. Then as our Go platforms scaled, we spent increasing amounts of our time playing games to appease the garbage collector, minimize allocations, and otherwise shape the code to be kind to the garbage collector.<p>The Go GC situation has improved continuously over the years, but it&#x27;s still common to see libraries compete to reduce allocations and add complexity like pools specifically to minimize GC burden.<p>It was great when we were small, but as the GC became a bigger part of our performance narrative it started to feel like a burden to constantly be structuring things in a way to appease the garbage collector. With Rust it&#x27;s nice to be able to handle things more explicitly and, importantly, without having to explain to newcomers to the codebase why we made a lot of decisions to appease the GC that appear unnecessarily complex at first glance.</div><br/><div id="37436332" class="c"><input type="checkbox" id="c-37436332" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436232">parent</a><span>|</span><a href="#37436003">next</a><span>|</span><label class="collapse" for="c-37436332">[-]</label><label class="expand" for="c-37436332">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a good chance this is rather a Go issue than a GC one. People get fooled by Go&#x27;s pretense to be a high level C replacement. It is highly inadequate at performing this role at best.<p>The reason for that is the compiler quality, the design tradeoffs and Go&#x27;s GC implementation throughput are simply not there for it to ever be a good general purpose systems-programming-oriented language.<p>Go receives undeserved hype, for use cases C# and Java are much better at due to their superior GC implementations and codegen quality (with C# offering better lower level features like structs+generics and first-class C interop).</div><br/><div id="37439155" class="c"><input type="checkbox" id="c-37439155" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436332">parent</a><span>|</span><a href="#37436669">next</a><span>|</span><label class="collapse" for="c-37439155">[-]</label><label class="expand" for="c-37439155">[2 more]</label></div><br/><div class="children"><div class="content">As an ops guy for decades, it makes me laugh to hear claims about Java GC superiority. Please go back in time and fix all the crashes and OOMs caused by enterprise JVM, as opposed to near-zero problems with the Go deployments.<p>Making stong statements without a backup in hard facts is a sign of zealotry...</div><br/><div id="37440052" class="c"><input type="checkbox" id="c-37440052" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37439155">parent</a><span>|</span><a href="#37436669">next</a><span>|</span><label class="collapse" for="c-37440052">[-]</label><label class="expand" for="c-37440052">[1 more]</label></div><br/><div class="children"><div class="content">I assure you if that code was to be ported to Go 1:1, Go GC would simply crawl to a halt. Write code badly enough and no matter how good hardware and software is, it won&#x27;t be able to cope at some point. Even a good tool will give, if you beat it down hard enough.<p>For example, you may be interested in this read: <a href="https:&#x2F;&#x2F;blog.twitch.tv&#x2F;en&#x2F;2019&#x2F;04&#x2F;10&#x2F;go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.twitch.tv&#x2F;en&#x2F;2019&#x2F;04&#x2F;10&#x2F;go-memory-ballast-how-i...</a><p>Issues like these simply don&#x27;t happen with GCs in modern JVM implementations or .NET (not saying they are perfect or don&#x27;t have other shortcomings, but the sheer amount of developer hours invested in tuning and optimizing them far outstrips Go).</div><br/></div></div></div></div><div id="37436669" class="c"><input type="checkbox" id="c-37436669" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436332">parent</a><span>|</span><a href="#37439155">prev</a><span>|</span><a href="#37436003">next</a><span>|</span><label class="collapse" for="c-37436669">[-]</label><label class="expand" for="c-37436669">[2 more]</label></div><br/><div class="children"><div class="content">Java GC has a non trivial overhead. I’ve moved workloads from Java to rust and gotten a 30x improvement from lack of GC. Likewise I’ve gotten 10x improvement in Java by preallocating objects and reusing then to avoid GC. (Fucking google and the cult of immutable objects).  Guess what, lots of things that “make it harder to introduce bugs” make your shit run a lot slower too.</div><br/><div id="37436867" class="c"><input type="checkbox" id="c-37436867" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436669">parent</a><span>|</span><a href="#37436003">next</a><span>|</span><label class="collapse" for="c-37436867">[-]</label><label class="expand" for="c-37436867">[1 more]</label></div><br/><div class="children"><div class="content">This is not an improvement from lack of GC per se but rather from zero cost abstractions (everything is monomorphised, no sin such as type erasure) first and foremost, and yes, deterministic memory management. Java is the worse language if you need to push performance to the limit since it does not offer convenient lower level language constructs to do so (unlike C#), but at reaching 80th percentile of performance, it is by far the best one.<p>But yes, GC is very much not free and is an explicit tradeoff vs compile time + manual memory management.</div><br/></div></div></div></div></div></div></div></div><div id="37436003" class="c"><input type="checkbox" id="c-37436003" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37435853">parent</a><span>|</span><a href="#37436232">prev</a><span>|</span><a href="#37437170">next</a><span>|</span><label class="collapse" for="c-37436003">[-]</label><label class="expand" for="c-37436003">[6 more]</label></div><br/><div class="children"><div class="content">Honestly, the biggest stumbling block for rust and async is the notion of memory pinning.<p>Rust will do a lot of invisible memory relocations under the covers.  Which can work great in single threaded contexts.  However, once you start talking about threading those invisible memory moves are a hazard.  The moment shared memory comes into play everything just gets a whole lot harder with the rust async story.<p>Contrast that with a language like java or go.  It&#x27;s true that the compiler won&#x27;t catch you when 2 threads access the same shared memory, but at the same time the mental burden around &quot;Where is this in memory, how do I make sure it deallocates correctly, etc&quot; just evaporates.  A whole host of complex types are erased and the language simply cleans up stuff when nothing references it.<p>To me, it seems like GCs simply make a language better for concurrency.  They generally solve a complex problem.</div><br/><div id="37436281" class="c"><input type="checkbox" id="c-37436281" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436003">parent</a><span>|</span><a href="#37436779">next</a><span>|</span><label class="collapse" for="c-37436281">[-]</label><label class="expand" for="c-37436281">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust will do a lot of invisible memory relocations under the covers.<p>I don&#x27;t think it&#x27;s quite accurate to point to &quot;invisible memory relocations&quot; as the problem that pinning solves. In most cases, memory relocations in Rust are very explicit, by moving an owned value when it has no live references (if it has any references, the borrow checker will stop you), or calling mem::replace() or mem::swap(), or something along those lines.<p>Instead, the primary purpose of pinning is to mark these explicit relocations as unsafe for certain objects (that are referenced elsewhere by raw pointer), so that external users must promise not to relocate certain objects on pain of causing UB with your interface. In C&#x2F;C++, or indeed in unsafe Rust, the same idea can be more trivially indicated by a comment such as &#x2F;* Don&#x27;t mess with this object until such-and-such other code is done using it! *&#x2F;. All pinning does is to enforce this rule at compile time for all safe code.</div><br/></div></div><div id="37436779" class="c"><input type="checkbox" id="c-37436779" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436003">parent</a><span>|</span><a href="#37436281">prev</a><span>|</span><a href="#37436350">next</a><span>|</span><label class="collapse" for="c-37436779">[-]</label><label class="expand" for="c-37436779">[3 more]</label></div><br/><div class="children"><div class="content">Memory pinning in Rust is not a problem that has to do with concurrency because the compiler will never relocate memory when something is referencing it. The problem is however with how stackless coroutines in general (even single-threaded ones, like generators) work. They are inherently self-referential structures, and Rust&#x27;s memory model likes to pretend such structures don&#x27;t exist, so you need library workarounds like `Pin` to work with them from safe code (and the discussion on whether they are actually sound is still open!)</div><br/><div id="37440244" class="c"><input type="checkbox" id="c-37440244" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436779">parent</a><span>|</span><a href="#37436350">next</a><span>|</span><label class="collapse" for="c-37440244">[-]</label><label class="expand" for="c-37440244">[2 more]</label></div><br/><div class="children"><div class="content">&gt;(and the discussion on whether they are actually sound is still open!)
Do you have a reference for this? Frankly, maybe I shouldn&#x27;t ask since I still don&#x27;t even understand why stackless coroutines are necessarily self-referential, but I am quite curious!</div><br/><div id="37440837" class="c"><input type="checkbox" id="c-37440837" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37440244">parent</a><span>|</span><a href="#37436350">next</a><span>|</span><label class="collapse" for="c-37440837">[-]</label><label class="expand" for="c-37440837">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I still don&#x27;t even understand why stackless coroutines are necessarily self-referential, but I am quite curious!<p>Because when stackless coroutines run they don’t have access to the stack that existed when they were created. everything that used to be on the stack needs to get packaged up in a struct (this is what `async fn` does). However now everything that used to point to something else on the stack (which rust understands and is fine with) now points to something else within the “impl Future” struct. Hence you have self referential structs.</div><br/></div></div></div></div></div></div><div id="37436350" class="c"><input type="checkbox" id="c-37436350" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436003">parent</a><span>|</span><a href="#37436779">prev</a><span>|</span><a href="#37437170">next</a><span>|</span><label class="collapse" for="c-37436350">[-]</label><label class="expand" for="c-37436350">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, the newest Java memory feature (Panama FFI&#x2F;M) actually can catch you if threads race on a memory allocation. They have done a lot of rather complex and little appreciated work to make this work in a very efficient way.<p>The new api lets you allocate &quot;memory segments&quot;, which are byte arrays&#x2F;C style structs. Such segments can be passed to native code easily or just used directly, deallocated with or without GC, bounds errors are blocked, use-after-free bugs are blocked, and segments can also be confined to a thread so races are also blocked (all at runtime though).<p>Unfortunately it only becomes available as a finalized non-preview API in Java 22, which is the release after the next one. In Java 21 it&#x27;s available but behind a flag.<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8310626" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8310626</a></div><br/></div></div></div></div><div id="37437170" class="c"><input type="checkbox" id="c-37437170" checked=""/><div class="controls bullet"><span class="by">dilippkumar</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37435853">parent</a><span>|</span><a href="#37436003">prev</a><span>|</span><a href="#37435991">next</a><span>|</span><label class="collapse" for="c-37437170">[-]</label><label class="expand" for="c-37437170">[10 more]</label></div><br/><div class="children"><div class="content">&gt; In the same sense that the lifetime of an object in a GC&#x27;d system has a lower bound of, &quot;as long as it&#x27;s referenced&quot;, sure.<p>These are not the same.<p>The problem with GC&#x27;d systems is that you don&#x27;t know when the GC will run and eat up your cpu cycles. It is impossible to determine when the memory will actually be freed in such systems. With ARC, you know exactly when you will release your last reference and that&#x27;s when the resource is freed up.<p>In terms of performance, ARC offers massive benefits because the memory that&#x27;s being dereferenced is already in the cache. It&#x27;s hard to understate how big of a deal this is. There&#x27;s a reason people like ARC and stay away from GC when performance actually begins to matter. :)</div><br/><div id="37443348" class="c"><input type="checkbox" id="c-37443348" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37437170">parent</a><span>|</span><a href="#37437365">next</a><span>|</span><label class="collapse" for="c-37443348">[-]</label><label class="expand" for="c-37443348">[1 more]</label></div><br/><div class="children"><div class="content">GC generally optimises for throughput over latency. But there is also another cost: high-throughput GC usually uses more memory (sometimes 2-3x as much!). Arc keeps your memory usage low and can keep your latency more consistent, but it will often sacrifice throughput compared to a GC tuned for it. (Of course, stack allocation, where possible, beats them all, which is why rust and C++ tend to win out over java in throughput even if the GC has an advantage over reference counting, because java has to GC a lot more than other languages due to no explicit stack allocation)</div><br/></div></div><div id="37437365" class="c"><input type="checkbox" id="c-37437365" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37437170">parent</a><span>|</span><a href="#37443348">prev</a><span>|</span><a href="#37438886">next</a><span>|</span><label class="collapse" for="c-37437365">[-]</label><label class="expand" for="c-37437365">[3 more]</label></div><br/><div class="children"><div class="content">&gt; With ARC, you know exactly when you will release your last reference and that&#x27;s when the resource is freed up.<p>It&#x27;s more like &quot;you notice when it happens&quot;. You don&#x27;t know in advance when the last reference will be released (if you did, there would be no point in using reference counting).<p>&gt; In terms of performance, ARC offers massive benefits because the memory that&#x27;s being dereferenced is already in the cache.<p>It all depends on your access patterns. When ARC adjusts the reference counter, the object is invalidated in all other threads&#x27; caches. If this happens with high frequency, the cache misses absolutely demolish performance. GC simply does not have this problem.<p>&gt; There&#x27;s a reason people like ARC and stay away from GC when performance actually begins to matter.<p>If you&#x27;re using a language without GC built in, you usually don&#x27;t have a choice. When performance <i>really</i> begins to matter, people reach for things like hazard pointers.</div><br/><div id="37437681" class="c"><input type="checkbox" id="c-37437681" checked=""/><div class="controls bullet"><span class="by">dilippkumar</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37437365">parent</a><span>|</span><a href="#37438886">next</a><span>|</span><label class="collapse" for="c-37437681">[-]</label><label class="expand" for="c-37437681">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s more like &quot;you notice when it happens&quot;. You don&#x27;t know in advance when the last reference will be released<p>A barista knows when a customer will pay for coffee (after they have placed their order). A barista does not know when that customer will walk in through the door.<p>&gt; (if you did, there would be no point in using reference counting).<p>There’s a difference between being able to deduce when the last reference is dropped (for example, by profiling code) and not being able to tell anything about when something will happen.<p>A particular developer may not know when the last reference to an object is dropped, but they can find out. Nobody can guess when GC will come and take your cycles away.<p>&gt; The cache misses absolutely demolish performance<p>With safe Rust, you shouldn’t be able to access memory that has been freed up. So cache misses on memory that has been released is not a problem in a language that prevents use-after-free bugs :)<p>&gt; If you’re using a language without GC built in, you usually don’t have a choice.<p>I’m pretty sure the choice of using Rust was made precisely because GC isn’t a thing (in all places that love and use rust that is)</div><br/><div id="37440638" class="c"><input type="checkbox" id="c-37440638" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37437681">parent</a><span>|</span><a href="#37438886">next</a><span>|</span><label class="collapse" for="c-37440638">[-]</label><label class="expand" for="c-37440638">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A barista knows when a customer will pay for coffee (after they have placed their order). A barista does not know when that customer will walk in through the door.<p>Sorry, no chance of deciphering that.<p>&gt; There’s a difference between being able to deduce when the last reference is dropped (for example, by profiling code) and not being able to tell anything about when something will happen.<p>&gt; A particular developer may not know when the last reference to an object is dropped, but they can find out.<p>The developer can figure out when the last reference to the object is dropped <i>in that particular execution of the program</i>, but not in the general sense, not anymore than they can in a GC&#x27;d language.<p>The only instance where they can point to a place in the code and with certainty say &quot;the reference counted object that was created over there is always destroyed at this line&quot; is in cases where reference counting was not needed in the first place.<p>&gt; With safe Rust, you shouldn’t be able to access memory that has been freed up. So cache misses on memory that has been released is not a problem in a language that prevents use-after-free bugs :)<p>I&#x27;m not sure why you&#x27;re talking about freed memory.<p>Say that thread A is looking at a reference-counted object. Thread B looks at the same object, and modifies the object&#x27;s reference counter as part of doing this (to ensure that the object stays alive). By doing so, thread B has invalidated thread A&#x27;s cache. Thread A has to spend time reloading its cache line the next time it accesses the object.<p>This is a performance issue that&#x27;s inherent to reference counting.<p>&gt; I’m pretty sure the choice of using Rust was made precisely because GC isn’t a thing (in all places that love and use rust that is)<p>Wanting to avoid &quot;GC everywhere&quot;, yes. But Rust&#x2F;C++ programs can have <i>parts</i> that would be better served by (tracing) garbage collection, but where they have to <i>make do</i> with reference counting, because garbage collection is not available.</div><br/></div></div></div></div></div></div><div id="37438886" class="c"><input type="checkbox" id="c-37438886" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37437170">parent</a><span>|</span><a href="#37437365">prev</a><span>|</span><a href="#37435991">next</a><span>|</span><label class="collapse" for="c-37438886">[-]</label><label class="expand" for="c-37438886">[5 more]</label></div><br/><div class="children"><div class="content">&gt; In terms of performance, ARC offers massive benefits<p>but it also has big disadvantage, that it communicates to actual malloc for memory management, which is usually much less performant than GC from various reasons.</div><br/><div id="37439723" class="c"><input type="checkbox" id="c-37439723" checked=""/><div class="controls bullet"><span class="by">dilippkumar</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37438886">parent</a><span>|</span><a href="#37435991">next</a><span>|</span><label class="collapse" for="c-37439723">[-]</label><label class="expand" for="c-37439723">[4 more]</label></div><br/><div class="children"><div class="content">&gt; which is usually much less performant than GC from various reasons.<p>Can you elaborate?<p>I&#x27;ve seen a couple of malloc implementations, and in all of them, free() is a cheap operation. It usually involves setting a bit somewhere and potentially merging with an adjacent free block if available&#x2F;appropriate.<p>malloc() is the expensive call, but I don&#x27;t see how a GC system can get around the same costs for similar reasons.<p>What am I missing?</div><br/><div id="37441254" class="c"><input type="checkbox" id="c-37441254" checked=""/><div class="controls bullet"><span class="by">mrkline</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37439723">parent</a><span>|</span><a href="#37439962">next</a><span>|</span><label class="collapse" for="c-37441254">[-]</label><label class="expand" for="c-37441254">[1 more]</label></div><br/><div class="children"><div class="content">- Like others have said, both malloc()&#x2F;free() touch a lot of global state, so you either have contention between threads, or do as jemalloc does and keep thread-local pools that you occasionally reconcile.<p>- A <i>moving</i> (and ideally, generational) GC means that you can recompact the heap, making malloc() little more than a pointer bump.<p>- This also suggests subsequent allocations will have good locality, helping cache performance.<p>Manual memory management isn&#x27;t magically pause-free, you just get to express some opinion about where you take the pauses. And I&#x27;ll contend that (A) most programmers aren&#x27;t especially good at choosing when that should be, and (B) lots (most?) software cares about overall throughput, so long as max latency stays under some sane bound.</div><br/></div></div><div id="37439962" class="c"><input type="checkbox" id="c-37439962" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37439723">parent</a><span>|</span><a href="#37441254">prev</a><span>|</span><a href="#37439964">next</a><span>|</span><label class="collapse" for="c-37439962">[-]</label><label class="expand" for="c-37439962">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can you elaborate?<p>I&#x27;ve seen some benchmarks, but can&#x27;t find them now, so maybe I am wrong about this.<p>&gt;  free() is a cheap operation. It usually involves setting a bit somewhere and potentially merging with an adjacent free block if available&#x2F;appropriate.<p>there is some tree like structure somewhere, which then would allow to locate this block for &quot;malloc()&quot;, this structure has to be modified in parallel by many concurrent threads, which likely will need some locks, meaning program operates outside of CPU cache.<p>In JVM for example, GC is integrated into thread models, so they can have heap per thread, and also &quot;free()&quot; happens asynchronously, so doesn&#x27;t block calling code. Additionally, malloc approaches usually suffer from memory fragmentation, while JVM GC is doing compactions all the time in background, tracks memory blocks generations, and many other optimizations.</div><br/></div></div><div id="37439964" class="c"><input type="checkbox" id="c-37439964" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37439723">parent</a><span>|</span><a href="#37439962">prev</a><span>|</span><a href="#37435991">next</a><span>|</span><label class="collapse" for="c-37439964">[-]</label><label class="expand" for="c-37439964">[1 more]</label></div><br/><div class="children"><div class="content">Sub (ignore pls)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37435991" class="c"><input type="checkbox" id="c-37435991" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#37435741">parent</a><span>|</span><a href="#37435853">prev</a><span>|</span><a href="#37436048">next</a><span>|</span><label class="collapse" for="c-37435991">[-]</label><label class="expand" for="c-37435991">[1 more]</label></div><br/><div class="children"><div class="content">This feels like a large portion of the criticism.  I thought this article was going to be more about how the async transformation gets in the way of a lot of transformations that the compiler could make in non-async code.<p>The point about wrangling with Weak suggests that they&#x27;re trying to build complex ownership structures (which, to be fair, would be easier in to deal with a single thread) which isn&#x27;t really something easy to express in Rust <i>in general</i>.  I use weak smart pointers <i>exceedingly rarely</i>.  Outside of the first section (which isn&#x27;t talking about async Rust specifically, it&#x27;s just speaking about concurrency generally) channels aren&#x27;t even mentioned.  They&#x27;re the <i>main thing</i> I use for communication between different parts of my program when writing async code and when interfacing between async and non-async code, plus the other signalling abstractions like Notify, semaphores, etc.  Mutexes are slow and bottlenecky and shared state quickly gets complicated to manage, this has been known for ages.  I think the problem might be more the `BIG_GLOBAL_STATIC_REF_OR_SIMILAR_HORROR` in the first place.<p>The comment about nothing stopping you from calling blocking code in an async context is valid, but it&#x27;s relatively manageable and you can use `tokio::spawn_blocking` or similar when you <i>must</i> do it.</div><br/></div></div><div id="37436048" class="c"><input type="checkbox" id="c-37436048" checked=""/><div class="controls bullet"><span class="by">colatkinson</span><span>|</span><a href="#37435741">parent</a><span>|</span><a href="#37435991">prev</a><span>|</span><a href="#37435843">next</a><span>|</span><label class="collapse" for="c-37436048">[-]</label><label class="expand" for="c-37436048">[3 more]</label></div><br/><div class="children"><div class="content">Reference counting is a type of GC [0]. Just not a very good one in many cases.<p>I think it&#x27;s a fair assumption to say that the author is aware of what Arcs are and how they work. I believe their point is more so that because of how async works in Rust, users have to reach for Arc over normal RAII far more often than in sync code. So at a certain point, if you have a program where 90% of objects are refcounted, you might as well use a tracing GC and not have the overhead of many small heap allocations&#x2F;frees plus atomic ops.<p>Perhaps there are in fact ways around Arc-ing things for the author&#x27;s use cases. But in my (limited) experience with Rust async I&#x27;ve definitely run into things like this, and plenty of example code out there seems to do the same thing [1].<p>For what it&#x27;s worth, I&#x27;ve definitely wondered whether a real tracing GC (e.g. [2]) could meaningfully speed up many common async applications like HTTP servers. I&#x27;d assume that other async use cases like embedded state machines would likely have pretty different performance characteristics, though.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Garbage_collection_(computer_science)#Reference_counting" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Garbage_collection_(computer_s...</a><p>[1] <a href="https:&#x2F;&#x2F;tokio.rs&#x2F;tokio&#x2F;tutorial&#x2F;shared-state" rel="nofollow noreferrer">https:&#x2F;&#x2F;tokio.rs&#x2F;tokio&#x2F;tutorial&#x2F;shared-state</a><p>[2] <a href="https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2015&#x2F;09&#x2F;01&#x2F;designing-a-gc-in-rust&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2015&#x2F;09&#x2F;01&#x2F;designing-a-gc...</a></div><br/><div id="37436252" class="c"><input type="checkbox" id="c-37436252" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436048">parent</a><span>|</span><a href="#37441994">next</a><span>|</span><label class="collapse" for="c-37436252">[-]</label><label class="expand" for="c-37436252">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think it&#x27;s a fair assumption to say that the author is aware of what Arcs are and how they work.<p>Fair, but when reading an article like this I have to refer to what&#x27;s written, not what we think the author knew but didn&#x27;t write.</div><br/></div></div><div id="37441994" class="c"><input type="checkbox" id="c-37441994" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#37435741">root</a><span>|</span><a href="#37436048">parent</a><span>|</span><a href="#37436252">prev</a><span>|</span><a href="#37435843">next</a><span>|</span><label class="collapse" for="c-37441994">[-]</label><label class="expand" for="c-37441994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Reference counting is a type of GC [0]. Just not a very good one in many cases.<p>…on a server where you can have a ton of RAM. It&#x27;s superior on client machines because it&#x27;s friendlier to swapped out memory, which is why Swift doesn&#x27;t have a GC.</div><br/></div></div></div></div><div id="37435843" class="c"><input type="checkbox" id="c-37435843" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#37435741">parent</a><span>|</span><a href="#37436048">prev</a><span>|</span><a href="#37435962">next</a><span>|</span><label class="collapse" for="c-37435843">[-]</label><label class="expand" for="c-37435843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The lifetime of an Arc isn’t unknowable, it’s determined by where and how you hold it.<p>Obviously it&#x27;s not random. It&#x27;s <i>statically</i> unknowable.</div><br/></div></div><div id="37435962" class="c"><input type="checkbox" id="c-37435962" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#37435741">parent</a><span>|</span><a href="#37435843">prev</a><span>|</span><a href="#37435836">next</a><span>|</span><label class="collapse" for="c-37435962">[-]</label><label class="expand" for="c-37435962">[1 more]</label></div><br/><div class="children"><div class="content">Arc in Rust can be moved or borrowed, and used without touching the reference count.<p>In many cases this means it&#x27;s much cheaper than objects in languages with implicit reference counting.</div><br/></div></div><div id="37435836" class="c"><input type="checkbox" id="c-37435836" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#37435741">parent</a><span>|</span><a href="#37435962">prev</a><span>|</span><a href="#37436824">next</a><span>|</span><label class="collapse" for="c-37435836">[-]</label><label class="expand" for="c-37435836">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s exactly that people trying to force other mental models onto rust and then complaining that it does things differently.</div><br/></div></div></div></div><div id="37436824" class="c"><input type="checkbox" id="c-37436824" checked=""/><div class="controls bullet"><span class="by">bionhoward</span><span>|</span><a href="#37435741">prev</a><span>|</span><a href="#37435785">next</a><span>|</span><label class="collapse" for="c-37436824">[-]</label><label class="expand" for="c-37436824">[6 more]</label></div><br/><div class="children"><div class="content">Admittedly, I’m no expert in async rust, but I’ve written several thousand lines of sync rust this month. One thing I’ve found is when rustc makes a particular approach hard to implement, it usually does so for a good reason (i.e. there is a better way to achieve a similar result).<p>If you’re learning the language, I would suggest starting out with some more vanilla sync code, loops and if statements, get used to the borrowing. Async is clearly still under heavy development, and not just from an implementation level, but also from the level of our philosophical paradigm about what async means and how it ought to work for the user. It’s entirely possible for humanity to have the wrong approach to this issue and maybe someone in this discussion will be able to answer it more effectively.<p>The compiler really depends on traits, and the ability for traits to handle async is not stable. Many highly intelligent people are hard at work thinking about how to make async rust more correct, readable, and accessible. For example, look here: <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2022&#x2F;11&#x2F;17&#x2F;async-fn-in-trait-nightly.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2022&#x2F;11&#x2F;17&#x2F;async-fn-i...</a><p>I would argue, if the async functionality of traits is not stable in rust, then it is silly for us to attack rust for not having nice async code, because we’re effectively criticizing an early rough draft of what will eventually be a correct and performant and accessible book.</div><br/><div id="37437265" class="c"><input type="checkbox" id="c-37437265" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37436824">parent</a><span>|</span><a href="#37436887">next</a><span>|</span><label class="collapse" for="c-37437265">[-]</label><label class="expand" for="c-37437265">[1 more]</label></div><br/><div class="children"><div class="content">I am curious what a &quot;good async design&quot; looks like, if we were going &quot;all the way&quot; with async and trying to design a highly scalable and maintainable and understandable server. The X11&#x2F;Wayland post yesterday was interesting in how it described async drawing APIs in X11.<p>What does a good async API look like?<p>Also how do you prevent it spreading throughout a codebase?<p>I am trying to design a scalable architecture pattern for multithreaded and async servers. My design is that you have IO threads have asynchronous events into two halves &quot;submit&quot; and &quot;handle&quot;. For example, system events from liburing or epoll are routed to other components. Those IO thread event loops run and block on epoll.poll&#x2F;io_uring_wait_cqe.<p>For example, if you create a &quot;tcp-connection&quot; you can subscribe to async events that are &quot;ready-for-writing&quot; and &quot;ready-for-reading&quot;. Ready-for-writing would take data out of a buffer (that was written to with a regular mutex) for the IO thread to send when EPOLLOUT&#x2F;io_uring_prep_writev.<p>We can use the LMAX Disruptor pattern - multiproducer multiconsumer ringbuffers to communicate events between threads. Your application or thread pool threads have their own event loops and they service these ringbuffers.<p>I am working on a syntax to describe async event firing sequences. It looks like a bash pipeline, I call it statelines:<p><pre><code>   initialstate1 initialstate2 = state1 | {state1a state1b state1c} {state2a state2b state2d} | state3
</code></pre>
It first waits for &quot;initialstate1&quot; and &quot;initialstate2&quot; in any order, then it waits for &quot;state1&quot;, then it waits for the states &quot;state1a state1b state1c&quot; and &quot;state2a state2b state2d&quot; in any order.</div><br/></div></div><div id="37436887" class="c"><input type="checkbox" id="c-37436887" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#37436824">parent</a><span>|</span><a href="#37437265">prev</a><span>|</span><a href="#37439188">next</a><span>|</span><label class="collapse" for="c-37436887">[-]</label><label class="expand" for="c-37436887">[3 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s not stable, then people shouldn&#x27;t use it in production either.</div><br/><div id="37436944" class="c"><input type="checkbox" id="c-37436944" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#37436824">root</a><span>|</span><a href="#37436887">parent</a><span>|</span><a href="#37439188">next</a><span>|</span><label class="collapse" for="c-37436944">[-]</label><label class="expand" for="c-37436944">[2 more]</label></div><br/><div class="children"><div class="content">People <i>who do not know what they are doing</i> should do research before using it in production.<p>Edit: Of course, since this is what &quot;unstable&quot; means, right?</div><br/><div id="37436991" class="c"><input type="checkbox" id="c-37436991" checked=""/><div class="controls bullet"><span class="by">lcnPylGDnU4H9OF</span><span>|</span><a href="#37436824">root</a><span>|</span><a href="#37436944">parent</a><span>|</span><a href="#37439188">next</a><span>|</span><label class="collapse" for="c-37436991">[-]</label><label class="expand" for="c-37436991">[1 more]</label></div><br/><div class="children"><div class="content">People who know what they are doing will understand the peril of using a moving-target interface in a production application. Depending on the project that may or may not be a problem.</div><br/></div></div></div></div></div></div><div id="37439188" class="c"><input type="checkbox" id="c-37439188" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#37436824">parent</a><span>|</span><a href="#37436887">prev</a><span>|</span><a href="#37435785">next</a><span>|</span><label class="collapse" for="c-37439188">[-]</label><label class="expand" for="c-37439188">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny how some commenters assume the author is a novice in Rust, what if his experience exceed their...</div><br/></div></div></div></div><div id="37435785" class="c"><input type="checkbox" id="c-37435785" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#37436824">prev</a><span>|</span><a href="#37435921">next</a><span>|</span><label class="collapse" for="c-37435785">[-]</label><label class="expand" for="c-37435785">[10 more]</label></div><br/><div class="children"><div class="content">I love Rust, but async is a hot mess and you cannot just write async code the same way that you write sync code. I&#x27;m getting more convinced that mixing the two is a bad idea, and that Go&#x27;s approach of making everything sync with a single async channel primitive might be right.<p>I&#x27;m currently plumbing through some logic to call a sync method on a struct that implements Future and it&#x27;s... an interesting challenge.<p>While we can make zero-cost async abstractions somewhat easy for users, the library developers are the ones who suffer the pain.</div><br/><div id="37436813" class="c"><input type="checkbox" id="c-37436813" checked=""/><div class="controls bullet"><span class="by">vilunov</span><span>|</span><a href="#37435785">parent</a><span>|</span><a href="#37435879">next</a><span>|</span><label class="collapse" for="c-37436813">[-]</label><label class="expand" for="c-37436813">[2 more]</label></div><br/><div class="children"><div class="content">I disagree with you in the last point, async is definitely painful for end users. It indeed feels like you&#x27;re using a completely different language, which has Rust&#x27;s core features removed – lifetimes and explicit types, sprinkled with a mess of Pins on top.<p>You cannot run scoped fibers, forcing you to &quot;Arc shit up&quot;, Pins are unusable without unsafe, and a tiniest change in an async-function could make the future !Send across the entire codebase.</div><br/><div id="37437575" class="c"><input type="checkbox" id="c-37437575" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#37435785">root</a><span>|</span><a href="#37436813">parent</a><span>|</span><a href="#37435879">next</a><span>|</span><label class="collapse" for="c-37437575">[-]</label><label class="expand" for="c-37437575">[1 more]</label></div><br/><div class="children"><div class="content">It may no longer be necessary for pins to exist for async implementation: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;rc&#x2F;struct.Rc.html#method.new_cyclic" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;rc&#x2F;struct.Rc.html#method.new_c...</a> (but the current async interface requires using them, so my point is definitely a whatifism).</div><br/></div></div></div></div><div id="37435879" class="c"><input type="checkbox" id="c-37435879" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#37435785">parent</a><span>|</span><a href="#37436813">prev</a><span>|</span><a href="#37435929">next</a><span>|</span><label class="collapse" for="c-37435879">[-]</label><label class="expand" for="c-37435879">[4 more]</label></div><br/><div class="children"><div class="content">Library developers can afford to deal with complexity much more than users of libraries. Offloading such work on highly skilled people developing the basic infrastructure is surely the right approach.</div><br/><div id="37438589" class="c"><input type="checkbox" id="c-37438589" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#37435785">root</a><span>|</span><a href="#37435879">parent</a><span>|</span><a href="#37439081">next</a><span>|</span><label class="collapse" for="c-37438589">[-]</label><label class="expand" for="c-37438589">[1 more]</label></div><br/><div class="children"><div class="content">I totally agree that library developers are the ones who _can_ handle complexity, but I have found even some of the top Rust devs are making async mistakes -- either the APIs are not correct from an async perspective, or there are basic bugs like losing wakers. The latter is so common it&#x27;s not funny.</div><br/></div></div><div id="37439081" class="c"><input type="checkbox" id="c-37439081" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37435785">root</a><span>|</span><a href="#37435879">parent</a><span>|</span><a href="#37438589">prev</a><span>|</span><a href="#37435920">next</a><span>|</span><label class="collapse" for="c-37439081">[-]</label><label class="expand" for="c-37439081">[1 more]</label></div><br/><div class="children"><div class="content">many of these libraries then are debugged and troubleshooted by users..</div><br/></div></div></div></div><div id="37435929" class="c"><input type="checkbox" id="c-37435929" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#37435785">parent</a><span>|</span><a href="#37435879">prev</a><span>|</span><a href="#37435921">next</a><span>|</span><label class="collapse" for="c-37435929">[-]</label><label class="expand" for="c-37435929">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen one wasm VM for Rust that offered what looked like transparent M:N, which should solve (in that case) most async difficulties. We&#x27;ll see how that evolves.</div><br/><div id="37436409" class="c"><input type="checkbox" id="c-37436409" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37435785">root</a><span>|</span><a href="#37435929">parent</a><span>|</span><a href="#37435921">next</a><span>|</span><label class="collapse" for="c-37436409">[-]</label><label class="expand" for="c-37436409">[2 more]</label></div><br/><div class="children"><div class="content">Which one? I wonder what its performance is like.<p>A good candidate for this is Graal. It can compile (JIT&#x2F;AOT) both WASM and also LLVM bitcode directly so Rust programs can have full hardware&#x2F;OS access without WASM limitations, and in theory it could allow apps to fully benefit from the work done on Loom and async. The pieces are all there. The main issue is you need to virtualize IO so that it goes back into the JVM, so the JVM controls all the code on the stack at all times. I think Graal can do this but only in the enterprise edition. Then you&#x27;d be able to run ~millions of Rust threads.</div><br/><div id="37436700" class="c"><input type="checkbox" id="c-37436700" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#37435785">root</a><span>|</span><a href="#37436409">parent</a><span>|</span><a href="#37435921">next</a><span>|</span><label class="collapse" for="c-37436700">[-]</label><label class="expand" for="c-37436700">[1 more]</label></div><br/><div class="children"><div class="content">Curious too. I follow Lunatic [0] as a candidate for future use, and also wasmCloud [1].<p>[0] <a href="https:&#x2F;&#x2F;lunatic.solutions&#x2F;">https:&#x2F;&#x2F;lunatic.solutions&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;wasmcloud.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;wasmcloud.com</a></div><br/></div></div></div></div></div></div></div></div><div id="37435921" class="c"><input type="checkbox" id="c-37435921" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#37435785">prev</a><span>|</span><a href="#37436342">next</a><span>|</span><label class="collapse" for="c-37435921">[-]</label><label class="expand" for="c-37435921">[9 more]</label></div><br/><div class="children"><div class="content">Async Everything is a bad language.<p>Async&#x2F;await was a terrible idea for fixing JavaScript&#x27;s lack of proper blocked threading that is currently being bolted onto every language. It splits every language and every library-ecosystem in half and will cause pains for many years to come.<p>Everyone who worked with multi-threading outside of JavaScript knows that using actors&#x2F;communicating sequential processes is the best way to do multi-threading.<p>I recently found an explanation for that in Joe Armstrong&#x27;s thesis. He argues that the only way to understand multi-threaded programs is writing strictly sequential code for every thread and not muddling all the code for all the threads in one place:<p>&quot;The structure of the program should exactly follow the structure of the problem. Each real world concurrent activity should be mapped onto exactly one concurrent process in our programming language. If there is a 1:1 mapping of the problem onto the program we say that the program is isomorphic to the problem.<p>It is extremely important that the mapping is exactly 1:1. The reason for this is that it minimizes the conceptual gap between the problem and the solution. If this mapping is not 1:1 the program will quickly degenerate, and become difficult to understand. This degeneration is often observed when non-CO languages [&quot;non concurrency-oriented&quot;, looking at you JavaScript!] are used to solve concurrent problems. Often the only way to get the program to work is to force several independent activities to be controlled by the same language thread or process. This leads to a inevitable loss of clarity, and makes the programs subject to complex and irreproducible interference errors.&quot; [0]<p>[0] <a href="https:&#x2F;&#x2F;erlang.org&#x2F;download&#x2F;armstrong_thesis_2003.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;erlang.org&#x2F;download&#x2F;armstrong_thesis_2003.pdf</a><p>There is also a good rant against async&#x2F;await by Ron Pressler who implemented project loom in java: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=oNnITaBseYQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=oNnITaBseYQ</a></div><br/><div id="37436037" class="c"><input type="checkbox" id="c-37436037" checked=""/><div class="controls bullet"><span class="by">mrkline</span><span>|</span><a href="#37435921">parent</a><span>|</span><a href="#37438486">next</a><span>|</span><label class="collapse" for="c-37436037">[-]</label><label class="expand" for="c-37436037">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Async&#x2F;await was a terrible idea for fixing JavaScript&#x27;s lack of proper blocked threading that is currently being bolted onto every language.<p>As fun as it is to hate on JavaScript, it&#x27;s really interesting to go back and watch Ryan Dahl&#x27;s talk introducing Node.js to the world (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=EeYvFl7li9E">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=EeYvFl7li9E</a>). He&#x27;s pretty ambivalent about it being JavaScript. His main goal was to find an abstraction around the epoll() I&#x2F;O event loop that didn&#x27;t make him want to tear his eyes out, and he tried a bunch of other stuff first.</div><br/><div id="37436990" class="c"><input type="checkbox" id="c-37436990" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37435921">root</a><span>|</span><a href="#37436037">parent</a><span>|</span><a href="#37436726">next</a><span>|</span><label class="collapse" for="c-37436990">[-]</label><label class="expand" for="c-37436990">[2 more]</label></div><br/><div class="children"><div class="content">If you look around at the other competition at the time, it&#x27;s worth noting that many other languages that already existed for decades ultimately came up with the same basic solution. In fact one of the weird things about the Node propaganda at the time was precisely that every other major scripting language tended to have not just one event-based library, but <i>choices</i> of event based libraries. Perl even had a metapackage abstracting several of them. It was actually a bog-standard choice, not some sort of incredible innovation.<p>I don&#x27;t think it&#x27;s a &quot;good&quot; solution in the abstract, but in the <i>concrete</i> of &quot;I have a dynamically-typed scripting language with already over a decade of development and many more years of development that will happen before the event-based stuff is really standard&quot;, it&#x27;s nearly the only choice. Python&#x27;s gevent was the only other thing I saw that kinda solved the problem, and I really liked it, but I&#x27;m not sure it&#x27;s a sustainable model in the end as it involves writing a package that aggressively reaches into other packages to do its magic; it is a constant game of catch-up.<p>I do think it&#x27;s a grave error in the 2020s to adopt async as the only model for a language, though. There are better choices. And I actually exclude Rust here, because async is not mandatory and not the only model; I think in some sense the community is making the error of not realizing that your task will never have more than maybe a hundred threads in it and a 2023 computer will chomp on that without you noticing. Don&#x27;t scale for millions of concurrent tasks when you&#x27;re only looking at a couple dozen max, no matter what language or environment you&#x27;re in. Very common problem for programmers this decade. It may well be the most impactful premature optimization in programming I see today.</div><br/><div id="37437495" class="c"><input type="checkbox" id="c-37437495" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#37435921">root</a><span>|</span><a href="#37436990">parent</a><span>|</span><a href="#37436726">next</a><span>|</span><label class="collapse" for="c-37437495">[-]</label><label class="expand" for="c-37437495">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t scale for millions of concurrent tasks when you&#x27;re only looking at a couple dozen max, no matter what language or environment you&#x27;re in. Very common problem for programmers this decade.<p>And also with fibers&#x2F;virtual threads (project loom) you  can actually have a million threads using blocking hand-off on one machine. So the performance argument is kind of gone.</div><br/></div></div></div></div><div id="37436726" class="c"><input type="checkbox" id="c-37436726" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#37435921">root</a><span>|</span><a href="#37436037">parent</a><span>|</span><a href="#37436990">prev</a><span>|</span><a href="#37438976">next</a><span>|</span><label class="collapse" for="c-37436726">[-]</label><label class="expand" for="c-37436726">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As fun as it is to hate on JavaScript, it&#x27;s really interesting to go back and watch Ryan Dahl&#x27;s talk introducing Node.js to the world<p>Agreed. JavaScript was actually my first language after TurboPascal in 1996.<p>I was also there listening to the first podcasts when node came out.<p>JavaScript is a very interesting language, especially with it&#x27;s prototype memory model. And the eventloop apart from the language is interesting as well. And it&#x27;s no coincidence Apple went as far as baking optimizations for JavaScript primitive operations into the M1 microcode.<p>But I still think multithreading is best done by using blocking operations.<p>NIO can be implemented on top of blocking IO as far as I know but not the other way round.<p>Also, sidenote, I think JavaScript&#x27;s only real failure is the lack of a canonical module&#x2F;import system. That error lead to countless re-implementations of buildsystems and tens of thousands of hours wasted debugging.</div><br/><div id="37436994" class="c"><input type="checkbox" id="c-37436994" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37435921">root</a><span>|</span><a href="#37436726">parent</a><span>|</span><a href="#37438976">next</a><span>|</span><label class="collapse" for="c-37436994">[-]</label><label class="expand" for="c-37436994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, sidenote, I think JavaScript&#x27;s only real failure is the lack of a canonical module&#x2F;import system. That error lead to countless re-implementations of buildsystems and tens of thousands of hours wasted debugging.<p>Agreed. I don&#x27;t hate on JS, in fact I think it&#x27;s the best tool for the several very common use cases it targets, and I&#x27;ll even defend the way objects work in it (i.e. lets me do what I want with minimal fuss). The import&#x2F;require drama was annoying, though.</div><br/></div></div></div></div><div id="37438976" class="c"><input type="checkbox" id="c-37438976" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#37435921">root</a><span>|</span><a href="#37436037">parent</a><span>|</span><a href="#37436726">prev</a><span>|</span><a href="#37438846">next</a><span>|</span><label class="collapse" for="c-37438976">[-]</label><label class="expand" for="c-37438976">[1 more]</label></div><br/><div class="children"><div class="content">He was strongly advocating callbacks with node.js, which is understandable given the time.  But a few years later when he wrote some Go code, he said that&#x27;s a better model for networked servers (sorry no reference right now, it was in a video I watched, not sure which one)<p>JS callbacks are indeed better than C callbacks because you can hold onto some state.  Although I guess the capture is implicit rather than explicit, so some people might say it&#x27;s more confusing.<p>I&#x27;m pretty sure Joyent adopted and funded node.js because they were doing lots of async code in C, and they liked the callback style in JavaScript better.  It does match the kind of problems that Go is now being used for, and this was pre-Go.<p>But anyway it is interesting how nobody really talks about callbacks anymore.  Seems like async&#x2F;await has taken over in most languages, although I sorta agree with the parent that it could have been better if designed from scratch.</div><br/></div></div><div id="37438846" class="c"><input type="checkbox" id="c-37438846" checked=""/><div class="controls bullet"><span class="by">yankput</span><span>|</span><a href="#37435921">root</a><span>|</span><a href="#37436037">parent</a><span>|</span><a href="#37438976">prev</a><span>|</span><a href="#37438486">next</a><span>|</span><label class="collapse" for="c-37438846">[-]</label><label class="expand" for="c-37438846">[1 more]</label></div><br/><div class="children"><div class="content">It’s so interesting that the async&#x2F;await stuff basically makes his presentation points meaningless? if you’re just using the async&#x2F;await why use the callback style in the first place…<p>but I get it, you can always go back to the promises and callbacks if you want.</div><br/></div></div></div></div><div id="37438486" class="c"><input type="checkbox" id="c-37438486" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37435921">parent</a><span>|</span><a href="#37436037">prev</a><span>|</span><a href="#37436342">next</a><span>|</span><label class="collapse" for="c-37438486">[-]</label><label class="expand" for="c-37438486">[1 more]</label></div><br/><div class="children"><div class="content">async&#x2F;await actually originated in C#, not Javascript. C#&#x27;s author, Anders Hejlsberg also authored Typescript. Typescript&#x27;s additional features like classes, arrow functions and async&#x2F;await eventually crept into ES6+.<p>I actually think it was a great solution in JS&#x2F;TS given it&#x27;s a single threaded event loop. The lower level the language the worse of an abstraction it is though. So I think most of the complaints here about async Rust are valid.</div><br/></div></div></div></div><div id="37436342" class="c"><input type="checkbox" id="c-37436342" checked=""/><div class="controls bullet"><span class="by">divyekapoor</span><span>|</span><a href="#37435921">prev</a><span>|</span><a href="#37443286">next</a><span>|</span><label class="collapse" for="c-37436342">[-]</label><label class="expand" for="c-37436342">[32 more]</label></div><br/><div class="children"><div class="content">We do not want red and blue functions. Any language that implements async &#x2F; await as coroutines instead of green threads is making a fundamental CS mistake. 
<a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-your-function&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-...</a><p>Concurrency&#x27;s correct primitive is Hoare&#x27;s Communicating Sequential Processes mapped onto green threads. Some languages that have it right are Java (since JDK17 - Java Virtual Threads), Go, Kotlin.</div><br/><div id="37436522" class="c"><input type="checkbox" id="c-37436522" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#37436342">parent</a><span>|</span><a href="#37443244">next</a><span>|</span><label class="collapse" for="c-37436522">[-]</label><label class="expand" for="c-37436522">[13 more]</label></div><br/><div class="children"><div class="content">Always with the blooming red and blue functions. You can say exactly the same thing about const.<p>The fact that a function can perform asynchronous operations matters to me and I want it reflected in the type system. I want to design my system on such a way that the asynchronous parts are kept where they belong, and I want the type system&#x27;s help in doing that. &quot;May perform asynchronous operations&quot; is a property a calling function inherits from its callee and it is correctly modelled as such. I don&#x27;t want to call functions that I don&#x27;t know this about.<p>Now you can make an argument that you don&#x27;t want to design your code this way and that&#x27;s great if you have another way to think about it all that leads to code that can be maintained and reasoned about equally well (or more so). But calling the classes of functions red and blue and pretending the distinction has no more meaning than that is not such an argument. It&#x27;s empty nonsense.<p>&quot;We&quot; don&#x27;t all agree on this.</div><br/><div id="37437047" class="c"><input type="checkbox" id="c-37437047" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436522">parent</a><span>|</span><a href="#37440822">next</a><span>|</span><label class="collapse" for="c-37437047">[-]</label><label class="expand" for="c-37437047">[4 more]</label></div><br/><div class="children"><div class="content">It would be swell if functions could be generic over this capability at compile time, so that you could get the same guarantees from the type system without implementing the same protocols more than one time.</div><br/><div id="37437464" class="c"><input type="checkbox" id="c-37437464" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37437047">parent</a><span>|</span><a href="#37441170">next</a><span>|</span><label class="collapse" for="c-37437464">[-]</label><label class="expand" for="c-37437464">[2 more]</label></div><br/><div class="children"><div class="content">Haskell supports this, but right from the start Rust was always wary of trying to add higher kinded types, which are necessary to support this.</div><br/><div id="37438446" class="c"><input type="checkbox" id="c-37438446" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37437464">parent</a><span>|</span><a href="#37441170">next</a><span>|</span><label class="collapse" for="c-37438446">[-]</label><label class="expand" for="c-37438446">[1 more]</label></div><br/><div class="children"><div class="content">As a Zig programmer I also get to enjoy this, but from the angle of language implementors not caring about type theory</div><br/></div></div></div></div><div id="37441170" class="c"><input type="checkbox" id="c-37441170" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37437047">parent</a><span>|</span><a href="#37437464">prev</a><span>|</span><a href="#37440822">next</a><span>|</span><label class="collapse" for="c-37441170">[-]</label><label class="expand" for="c-37441170">[1 more]</label></div><br/><div class="children"><div class="content">Keyword generics!</div><br/></div></div></div></div><div id="37440822" class="c"><input type="checkbox" id="c-37440822" checked=""/><div class="controls bullet"><span class="by">randyrand</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436522">parent</a><span>|</span><a href="#37437047">prev</a><span>|</span><a href="#37438235">next</a><span>|</span><label class="collapse" for="c-37440822">[-]</label><label class="expand" for="c-37440822">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a better example is returning errors, than const.<p>Either way, all of these changes are really annoying to make. We want less of these annoyances, not more.</div><br/></div></div><div id="37438235" class="c"><input type="checkbox" id="c-37438235" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436522">parent</a><span>|</span><a href="#37440822">prev</a><span>|</span><a href="#37436883">next</a><span>|</span><label class="collapse" for="c-37438235">[-]</label><label class="expand" for="c-37438235">[5 more]</label></div><br/><div class="children"><div class="content">We do not want functions that take floating point arguments, only u32 should be used. And don&#x27;t get me started on more than one argument!</div><br/><div id="37440789" class="c"><input type="checkbox" id="c-37440789" checked=""/><div class="controls bullet"><span class="by">randyrand</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37438235">parent</a><span>|</span><a href="#37436883">next</a><span>|</span><label class="collapse" for="c-37440789">[-]</label><label class="expand" for="c-37440789">[4 more]</label></div><br/><div class="children"><div class="content">you can convert a float to a u32.<p>you cannot convert an function that calls async code into a sync function.</div><br/><div id="37442682" class="c"><input type="checkbox" id="c-37442682" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37440789">parent</a><span>|</span><a href="#37440960">next</a><span>|</span><label class="collapse" for="c-37442682">[-]</label><label class="expand" for="c-37442682">[1 more]</label></div><br/><div class="children"><div class="content">An async function is some syntactic sugar around a sync function that returns a future. You can merrily call one from the other.<p>You can only convert an int to a float with significant caveats. It&#x27;s not a general trivial conversion. More complicated types may not be convertible at all or behave in all sorts of exciting ways (including having arbitrary side effects).<p>The point is that none of that is different to async functions. Of course you have to know what to do with them for them to be useful, but there is no requirement for them to &quot;infect&quot; calling code.</div><br/></div></div><div id="37440960" class="c"><input type="checkbox" id="c-37440960" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37440789">parent</a><span>|</span><a href="#37442682">prev</a><span>|</span><a href="#37436883">next</a><span>|</span><label class="collapse" for="c-37440960">[-]</label><label class="expand" for="c-37440960">[2 more]</label></div><br/><div class="children"><div class="content">You can call .Wait on the Task it returns :)</div><br/><div id="37441037" class="c"><input type="checkbox" id="c-37441037" checked=""/><div class="controls bullet"><span class="by">randyrand</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37440960">parent</a><span>|</span><a href="#37436883">next</a><span>|</span><label class="collapse" for="c-37441037">[-]</label><label class="expand" for="c-37441037">[1 more]</label></div><br/><div class="children"><div class="content">Right, but now you are forced to convert the calling function to async.<p>u32 &#x2F; float does not have the problem. It does not &quot;bubble up&quot;, unless you want it to.</div><br/></div></div></div></div></div></div></div></div><div id="37436883" class="c"><input type="checkbox" id="c-37436883" checked=""/><div class="controls bullet"><span class="by">assbuttbuttass</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436522">parent</a><span>|</span><a href="#37438235">prev</a><span>|</span><a href="#37443244">next</a><span>|</span><label class="collapse" for="c-37436883">[-]</label><label class="expand" for="c-37436883">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The fact that a function can perform asynchronous operations matters to me and I want it reflected in the type system.<p>async doesn&#x27;t tell you whether the function performs asynchronous operations, despite the name. async is an implementation detail about how the function must be invoked.<p>As TFA correctly points out, there&#x27;s nothing stopping you from calling a blocking function inside a future, and blocking the whole runtime thread.</div><br/><div id="37436908" class="c"><input type="checkbox" id="c-37436908" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436883">parent</a><span>|</span><a href="#37443244">next</a><span>|</span><label class="collapse" for="c-37436908">[-]</label><label class="expand" for="c-37436908">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t say it tells me whether the function does perform such operations, I said it tells me it <i>can</i>. More importantly it tells me which functions (most) <i>can&#x27;t</i>.</div><br/></div></div></div></div></div></div><div id="37443244" class="c"><input type="checkbox" id="c-37443244" checked=""/><div class="controls bullet"><span class="by">kasdi</span><span>|</span><a href="#37436342">parent</a><span>|</span><a href="#37436522">prev</a><span>|</span><a href="#37436468">next</a><span>|</span><label class="collapse" for="c-37443244">[-]</label><label class="expand" for="c-37443244">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the issue is that we overload the concept of a function with an entirely different thing, a Future &#x2F; Promise. Maybe if the syntax would have been entirely different too, it would have been easier to understand. We tend to have different syntax for different things.<p>I’m hesitant towards not distinguishing different things anymore and let the underlying system “figure it out”. I’m sure this could work as long as you’re on the happy path, but that’s not the only path there is.</div><br/></div></div><div id="37436468" class="c"><input type="checkbox" id="c-37436468" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37436342">parent</a><span>|</span><a href="#37443244">prev</a><span>|</span><a href="#37436611">next</a><span>|</span><label class="collapse" for="c-37436468">[-]</label><label class="expand" for="c-37436468">[3 more]</label></div><br/><div class="children"><div class="content">Virtual threading is fun and all until you find out SimpleDateFormat and a bunch of other classes built tight into your standard library aren&#x27;t thread safe and now you need to go through your program and find out what else you missed. Go too has these fancy green threads at the cost of manually locking resources and finding out about race conditions when you forget about them.<p>Futures aren&#x27;t a fundamental CS mistake, they&#x27;re a design decision. You may disagree with that decision, but the advantage Rust brings is that you don&#x27;t need to worry about thread safety once your program actually compiles, at the cost of different code styles.<p>Neither asynchronous processing design is fundamentally wrong, they both have their strengths and weaknesses.</div><br/><div id="37439308" class="c"><input type="checkbox" id="c-37439308" checked=""/><div class="controls bullet"><span class="by">SpaghettiCthulu</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436468">parent</a><span>|</span><a href="#37438592">next</a><span>|</span><label class="collapse" for="c-37439308">[-]</label><label class="expand" for="c-37439308">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Virtual threading is fun and all until you find out SimpleDateFormat and a bunch of other classes built tight into your standard library aren&#x27;t thread safe and now you need to go through your program and find out what else you missed. Go too has these fancy green threads at the cost of manually locking resources and finding out about race conditions when you forget about them.<p>Why would that ever be an issue? Instances of those classes shouldn&#x27;t be shared between virtual threads just the same as when using regular threads.</div><br/></div></div><div id="37438592" class="c"><input type="checkbox" id="c-37438592" checked=""/><div class="controls bullet"><span class="by">peoplefromibiza</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436468">parent</a><span>|</span><a href="#37439308">prev</a><span>|</span><a href="#37436611">next</a><span>|</span><label class="collapse" for="c-37438592">[-]</label><label class="expand" for="c-37438592">[1 more]</label></div><br/><div class="children"><div class="content">&gt; until you find out SimpleDateFormat and a bunch of other classes built tight into your standard library aren&#x27;t thread safe<p>true, but DateTimeFormatter has been available since Java 8, released almost 10 years ago.<p>VirtualThreads will be available in Java tomorrow<p>Also: <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;text&#x2F;SimpleDateFormat.html#synchronization" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;text&#x2F;SimpleDa...</a></div><br/></div></div></div></div><div id="37436611" class="c"><input type="checkbox" id="c-37436611" checked=""/><div class="controls bullet"><span class="by">vilunov</span><span>|</span><a href="#37436342">parent</a><span>|</span><a href="#37436468">prev</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37436611">[-]</label><label class="expand" for="c-37436611">[12 more]</label></div><br/><div class="children"><div class="content">I want colored functions. I want to know which code is running synchronously and which doesn&#x27;t, which raises errors and which doesn&#x27;t. Color is just a description of the function&#x27;s properties (and effects) and how it&#x27;s compatible with other colors.<p>There is also nothing fundamentally bad with cooperative scheduling in scope of a single process.</div><br/><div id="37436907" class="c"><input type="checkbox" id="c-37436907" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436611">parent</a><span>|</span><a href="#37437544">next</a><span>|</span><label class="collapse" for="c-37436907">[-]</label><label class="expand" for="c-37436907">[2 more]</label></div><br/><div class="children"><div class="content">I got into programming in the 1990s. At that point in time, there was still a large contingent of programmers loudly insisting they <i>needed</i> assembly language to do everything. And to be clear, I mean, everything. Not &quot;Yeah, I can&#x27;t really bring up an OS without a bit of specialized assembly&quot; but &quot;every programmer should write every program in assembly&quot;.<p>The vast majority of them were already wrong. They only got more wrong.<p>You may just be <i>used</i> to knowing what code is &quot;synchronous&quot; and what isn&#x27;t because it&#x27;s been shoved into your face and you&#x27;ve adapted your thought process to it. In practice, &quot;everything important is doing something &#x27;asynchronously&#x27;&quot; turns out to be the vast majority of what you need, and the vast majority of your mental energy you are dedicated to splitting the world in two is a waste. For the little bit that remains, by all means use something specialized, but it&#x27;s just not something that everyone, everywhere, needs to be doing all the time, any more than everyone everywhere should be manually allocating registers, or any more than programs <i>need</i> to have line numbers because otherwise how can they work? (One of my favorites because I remember having that conception myself.)</div><br/><div id="37440049" class="c"><input type="checkbox" id="c-37440049" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436907">parent</a><span>|</span><a href="#37437544">next</a><span>|</span><label class="collapse" for="c-37440049">[-]</label><label class="expand" for="c-37440049">[1 more]</label></div><br/><div class="children"><div class="content">I think you have your analogy backwards: the &quot;assembly programmer&quot; in this situation is the person who doesn&#x27;t understand why one would &quot;color&quot; functions and&#x2F;or express a fundamental property as part of their types. &quot;Why do we need to express this in their type? Every programmer should be able to understand this without help&quot;.</div><br/></div></div></div></div><div id="37437544" class="c"><input type="checkbox" id="c-37437544" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37436611">parent</a><span>|</span><a href="#37436907">prev</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37437544">[-]</label><label class="expand" for="c-37437544">[9 more]</label></div><br/><div class="children"><div class="content">To me this kind of sounds like circular reasoning. Without function coloring there&#x27;s no distinction that you need to know of.<p>Can you elaborate?</div><br/><div id="37438969" class="c"><input type="checkbox" id="c-37438969" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37437544">parent</a><span>|</span><a href="#37438316">next</a><span>|</span><label class="collapse" for="c-37438969">[-]</label><label class="expand" for="c-37438969">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Without function coloring there&#x27;s no distinction that you need to know of<p>Why do you think you don&#x27;t need to know of it? I want to know if the function I&#x27;m calling is going to make a network request. Just because I can have a programming language that hides that distinction from me doesn&#x27;t mean I want that.<p>Ideally I want to have the fundamental behavior of any function I call encoded in the function signature. So if it&#x27;s async, I know it&#x27;s going to reach out to some external system for some period of time.</div><br/><div id="37439734" class="c"><input type="checkbox" id="c-37439734" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37438969">parent</a><span>|</span><a href="#37438316">next</a><span>|</span><label class="collapse" for="c-37439734">[-]</label><label class="expand" for="c-37439734">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I want to know if the function I&#x27;m calling is going to make a network request.<p>That has nothing to do with function coloring.<p>&gt; Ideally I want to have the fundamental behavior of any function I call encoded in the function signature.<p>There is no distinction of async functions if you don&#x27;t have function coloring that you can encode in type signatures.</div><br/><div id="37439820" class="c"><input type="checkbox" id="c-37439820" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37439734">parent</a><span>|</span><a href="#37438316">next</a><span>|</span><label class="collapse" for="c-37439820">[-]</label><label class="expand" for="c-37439820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That has nothing to do with function coloring.<p>Sure, in the same way that types have nothing to do with enforcing logical correctness of software.<p>&gt; There is no distinction of async functions if you don&#x27;t have function coloring that you can encode in type signatures.<p>What are you trying to say with this statement?</div><br/></div></div></div></div></div></div><div id="37438316" class="c"><input type="checkbox" id="c-37438316" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37437544">parent</a><span>|</span><a href="#37438969">prev</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37438316">[-]</label><label class="expand" for="c-37438316">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nonsense. Async in rust is just syntactic sugar around a function signature. You can merrily call async functions from sync rust, you just have to know what to do with the future you get back.</div><br/><div id="37438515" class="c"><input type="checkbox" id="c-37438515" checked=""/><div class="controls bullet"><span class="by">vilunov</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37438316">parent</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37438515">[-]</label><label class="expand" for="c-37438515">[4 more]</label></div><br/><div class="children"><div class="content">&quot;you just have to know what to do&quot; is the problem. You can call any color from any color, but for some colors it&#x27;s trivial, e.g. sync function from a sync or async one, or a non-failing function from a failing or non-failing one.<p>I don&#x27;t want to be able to call fallible function from an infallible one trivially, I want the compiler to force me to specify what exactly I&#x27;m going to do with an error if it happens. Likewise for async-from-sync: there are many ways I could call these: I can either create a single threaded executor and use it to complete the future to completion, or maybe I want to create a multithreaded executor, or maybe I expect the future complete in a single poll and never suspend and I don&#x27;t even need a scheduler.</div><br/><div id="37439033" class="c"><input type="checkbox" id="c-37439033" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37438515">parent</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37439033">[-]</label><label class="expand" for="c-37439033">[3 more]</label></div><br/><div class="children"><div class="content">Well yes to all that. I still don&#x27;t see the problem. An async function isn&#x27;t really an async function, it&#x27;s a sync function that returns a future. Would it be better if all that was manual? I&#x27;ve done quite a bit of stuff using manual async traits and it&#x27;s painful and I highly value the syntax sugar that async brings. That said, I certainly don&#x27;t want some executor running quietly behind the scenes doing async stuff for me without my explicit and full control. If I want to manually poll a future, that&#x27;s for me to decide.</div><br/><div id="37439124" class="c"><input type="checkbox" id="c-37439124" checked=""/><div class="controls bullet"><span class="by">vilunov</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37439033">parent</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37439124">[-]</label><label class="expand" for="c-37439124">[2 more]</label></div><br/><div class="children"><div class="content">You seem to raise valid points and I don&#x27;t disagree with you, however I don&#x27;t see how it&#x27;s relevant to the original concern regarding colored functions.</div><br/><div id="37442664" class="c"><input type="checkbox" id="c-37442664" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#37436342">root</a><span>|</span><a href="#37439124">parent</a><span>|</span><a href="#37438863">next</a><span>|</span><label class="collapse" for="c-37442664">[-]</label><label class="expand" for="c-37442664">[1 more]</label></div><br/><div class="children"><div class="content">I suppose I&#x27;m struggling to understand what &quot;colour&quot; means in the context of Rust. It&#x27;s surely just another word for signature. For some reason it&#x27;s trotted out every time there&#x27;s a discussion about async. I can only assume it&#x27;s to do with the original use of the term for JavaScript async (which I know almost nothing about and have no opinion on), but I just cannot see its point in Rust async.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37438863" class="c"><input type="checkbox" id="c-37438863" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#37436342">parent</a><span>|</span><a href="#37436611">prev</a><span>|</span><a href="#37437388">next</a><span>|</span><label class="collapse" for="c-37438863">[-]</label><label class="expand" for="c-37438863">[1 more]</label></div><br/><div class="children"><div class="content">This classic article mixes two things:<p>1. inability to read an async result from a sync function, which is a legitimately major architectural limitation.<p>2. author&#x27;s opinion how function syntax should look like (fully implicit, hiding how the functions are run).<p>And from this there is the endless confusion and drama.<p>The problem 1 is mostly limited to JS. Languages that have threads can &quot;change colour&quot; of their  functions at will, so they don&#x27;t suffer from the dramatic problem described in the article.<p>But people see languages don&#x27;t fit the opinion 2, of having magic implicit syntax, and treat it as an equally big deal the dead-end problem 1. But two syntaxes are somewhere between minor inconvenience to actual feature. In systems programming it&#x27;s very important which type of locks you use, so you really need to know what runs async.</div><br/></div></div><div id="37437388" class="c"><input type="checkbox" id="c-37437388" checked=""/><div class="controls bullet"><span class="by">NSufi</span><span>|</span><a href="#37436342">parent</a><span>|</span><a href="#37438863">prev</a><span>|</span><a href="#37443286">next</a><span>|</span><label class="collapse" for="c-37437388">[-]</label><label class="expand" for="c-37437388">[1 more]</label></div><br/><div class="children"><div class="content">I think with stackful coroutines you lose low-overhead interoperability with C. Also, it possible to use stackless coroutines without introducing async&#x2F;await &#x27;colors&#x27;.</div><br/></div></div></div></div><div id="37443286" class="c"><input type="checkbox" id="c-37443286" checked=""/><div class="controls bullet"><span class="by">reacharavindh</span><span>|</span><a href="#37436342">prev</a><span>|</span><a href="#37436497">next</a><span>|</span><label class="collapse" for="c-37443286">[-]</label><label class="expand" for="c-37443286">[1 more]</label></div><br/><div class="children"><div class="content">Is it possible to use Rust and all the important 3rd party crates without using async?<p>Out of curiosity, could Rust be limited to a language subset to mimic the simplicity of Golang (with channels and message passing) and trade-off some of the powerful features that seem to be causing pain?<p>Pardon a naïve question. I’m a systems engineer who occasionally dabbles with simple cli tools in all languages for fun, but don’t have a serious need for them.</div><br/></div></div><div id="37436497" class="c"><input type="checkbox" id="c-37436497" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37443286">prev</a><span>|</span><a href="#37435966">next</a><span>|</span><label class="collapse" for="c-37436497">[-]</label><label class="expand" for="c-37436497">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been writing a lot of async lock free rust.  The main problem is that tokio futures are &#x27;static, which is because of a design mistake that&#x27;s baked deep into the rust ecosystem:  Leaking memory is &#x27;safe&#x27;.<p>This implies that you can&#x27;t statically guarantee that a future is cleaned up properly, which means that if you spawn some async work, something may std::mem::forget a future, and then the borrow checker won&#x27;t know that the references that were transitively handed out by the future are still live.<p>Rather than sprinkle Arc everywhere, I just use an unsafe crate like this:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;async-scoped&#x2F;latest&#x2F;async_scoped&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;async-scoped&#x2F;latest&#x2F;async_scoped&#x2F;</a><p>This catches 99% of the bugs I would have written in C++, so it&#x27;s a reasonable compromise.  There&#x27;s been some work to try to implement non-&#x27;static futures in a safe way.  I&#x27;m hoping it succeeds.<p>The other big problem with rust (but this is on the roadmap to be fixed this year) is that async trait&#x27;s currently require Box&#x27;ed futures, which adds a malloc&#x2F;free to function call boundaries(!!!)<p>As for the &quot;just use a channel&quot; advice:  I&#x27;ve dealt with large codebases that are structured this way.  It explodes your control flow all over the place.  I think of channels as the modern equivalent of GOTO.  (I do use them, but not often, and certainly not in cases where I just need to run a few things in parallel and then wait for completion.)</div><br/><div id="37438757" class="c"><input type="checkbox" id="c-37438757" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37436497">parent</a><span>|</span><a href="#37435966">next</a><span>|</span><label class="collapse" for="c-37438757">[-]</label><label class="expand" for="c-37438757">[5 more]</label></div><br/><div class="children"><div class="content">&gt; which is because of a design mistake that&#x27;s baked deep into the rust ecosystem: Leaking memory is &#x27;safe&#x27;.<p>Would you prefer not to have internal mutability, not to have `Rc`, or have them but with infectious unsafe trait bounds, or something else?</div><br/><div id="37439600" class="c"><input type="checkbox" id="c-37439600" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37436497">root</a><span>|</span><a href="#37438757">parent</a><span>|</span><a href="#37435966">next</a><span>|</span><label class="collapse" for="c-37439600">[-]</label><label class="expand" for="c-37439600">[4 more]</label></div><br/><div class="children"><div class="content">I don’t see why it would be an either&#x2F;or.  For instance, Rc does not leak memory, and neither do many cases of interior mutability.<p>If an API leaks memory, then I’d like it to be deemed unsafe.  That way, leaking a future would be unsafe, so the borrow checker could infer (transitively) that freeing the future means that any references it had are now dead (as it can already infer when a synchronous function call pops returns).<p>Am I missing something subtle?<p>Edit: Rc with cycles would be a problem.  I rarely intentionally use Rc though (certainly less often than I create a future).<p>Edit 2:  maybe an auto trait could statically disallow Rc cycles somehow?</div><br/><div id="37439770" class="c"><input type="checkbox" id="c-37439770" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37436497">root</a><span>|</span><a href="#37439600">parent</a><span>|</span><a href="#37435966">next</a><span>|</span><label class="collapse" for="c-37439770">[-]</label><label class="expand" for="c-37439770">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don’t see why it would be an either&#x2F;or. For instance, Rc does not leak memory, and neither do many cases of interior mutability.<p>`Rc` and internal mutability together do allow creating cycles and thus leaking with only safe code. I suggest you to read <a href="https:&#x2F;&#x2F;cglab.ca&#x2F;~abeinges&#x2F;blah&#x2F;everyone-poops&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cglab.ca&#x2F;~abeinges&#x2F;blah&#x2F;everyone-poops&#x2F;</a> if you haven&#x27;t done already, it explains the historical reasons for why `std::mem::forget` was changed to be safe.<p>&gt; Edit 2: maybe an auto trait could statically disallow Rc cycles somehow?<p>It could be done with an auto and implied trait that is implemented in the opposite case (the type can be safely leaked), but then all the ecosystem must be changed to use `?Leakable` and it would be a pain.</div><br/><div id="37440212" class="c"><input type="checkbox" id="c-37440212" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37436497">root</a><span>|</span><a href="#37439770">parent</a><span>|</span><a href="#37435966">next</a><span>|</span><label class="collapse" for="c-37440212">[-]</label><label class="expand" for="c-37440212">[2 more]</label></div><br/><div class="children"><div class="content">What about the other way?  There could be a trait that means “references have the same escape semantics as a stack frame”, perhaps called NotLeaky, and then a variant of tokio spawn could require NotLeaky, and return a non-‘static future.  NotLeaky could be inferred in the same way as Send and Sync.<p>As a bonus, high-availability systems could require NotLeaky at the top of their event loop, precluding runtime memory leaks.<p>Edit: that wouldn’t work, since the future could be leaked by the caller… will read that reference.</div><br/><div id="37442771" class="c"><input type="checkbox" id="c-37442771" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37436497">root</a><span>|</span><a href="#37440212">parent</a><span>|</span><a href="#37435966">next</a><span>|</span><label class="collapse" for="c-37442771">[-]</label><label class="expand" for="c-37442771">[1 more]</label></div><br/><div class="children"><div class="content">This won&#x27;t work because there&#x27;s nothing forcing you to pass `NotLeak` types to APIs that respect them. In other words, implementing a trait can only add capabilities to a type, not restrict it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37435966" class="c"><input type="checkbox" id="c-37435966" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#37436497">prev</a><span>|</span><a href="#37435802">next</a><span>|</span><label class="collapse" for="c-37435966">[-]</label><label class="expand" for="c-37435966">[11 more]</label></div><br/><div class="children"><div class="content">Promise&#x2F;Future style of async is just a bad idea regardless of language.<p>It was used because of ineptitude of languages where it become popular, and its far easier to implement into GC-less languages than message-passing-based asynchronous, but it&#x27;s just misery to write code in. I&#x27;d prefer to suffer Go ineptitudes just to use bastardised message passing called channels there rather than any of the Python&#x2F;JS&#x2F;Rust async.</div><br/><div id="37436081" class="c"><input type="checkbox" id="c-37436081" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37435966">parent</a><span>|</span><a href="#37436113">next</a><span>|</span><label class="collapse" for="c-37436081">[-]</label><label class="expand" for="c-37436081">[8 more]</label></div><br/><div class="children"><div class="content">Yes. That atomized model of concurrency where your state goes everywhere and you somehow collect it back at some point was always (literally) the textbook example of how not to do it.<p>It was created to be an improvement over the Javascript situation, and somehow every language that had a sane structure adopted it as if it was not only good, but the way to do things. This is insane.</div><br/><div id="37436821" class="c"><input type="checkbox" id="c-37436821" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37436081">parent</a><span>|</span><a href="#37438513">next</a><span>|</span><label class="collapse" for="c-37436821">[-]</label><label class="expand" for="c-37436821">[3 more]</label></div><br/><div class="children"><div class="content">And yet, people are going to use async in Rust. The feature has already proven itself useful long ago in other languages, beyond the timespan a fad could survive. Everyone started out doing it the other way and got sick of it.</div><br/><div id="37437483" class="c"><input type="checkbox" id="c-37437483" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37436821">parent</a><span>|</span><a href="#37438513">next</a><span>|</span><label class="collapse" for="c-37437483">[-]</label><label class="expand" for="c-37437483">[2 more]</label></div><br/><div class="children"><div class="content">&gt; beyond the timespan a fad could survive<p>On the voodoo ridden land that is software development, we have plenty of clearly harmful fads that are much older than Rust and yet practiced everywhere.<p>Up to now, rust async has lasted for less time than the NoSQL craziness. I&#x27;m hard pressed to think of any large fad that lasted less than it.</div><br/><div id="37437542" class="c"><input type="checkbox" id="c-37437542" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37437483">parent</a><span>|</span><a href="#37438513">next</a><span>|</span><label class="collapse" for="c-37437542">[-]</label><label class="expand" for="c-37437542">[1 more]</label></div><br/><div class="children"><div class="content">Async is much older in other languages. It&#x27;s new in Rust, and time will tell, but I don&#x27;t see it playing out differently this time.<p>Btw, the turnaround time is longer with a database, which often forms the foundation of a system. NoSQL bandwagoning was so destructive in part because of how long it looked like a good idea each time. Same with ORMs.</div><br/></div></div></div></div></div></div><div id="37438513" class="c"><input type="checkbox" id="c-37438513" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37436081">parent</a><span>|</span><a href="#37436821">prev</a><span>|</span><a href="#37439300">next</a><span>|</span><label class="collapse" for="c-37438513">[-]</label><label class="expand" for="c-37438513">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It was created to be an improvement over the Javascript situation<p>I see this repeated everywhere in this thread. async&#x2F;await originated in C# not JS.</div><br/><div id="37439704" class="c"><input type="checkbox" id="c-37439704" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37438513">parent</a><span>|</span><a href="#37439300">next</a><span>|</span><label class="collapse" for="c-37439704">[-]</label><label class="expand" for="c-37439704">[2 more]</label></div><br/><div class="children"><div class="content">The C# implementation is clearly an attempt of putting type-safety over exactly the same implementation JS promises use. Done because MS wanted to port the same behavior.</div><br/><div id="37440954" class="c"><input type="checkbox" id="c-37440954" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37439704">parent</a><span>|</span><a href="#37439300">next</a><span>|</span><label class="collapse" for="c-37440954">[-]</label><label class="expand" for="c-37440954">[1 more]</label></div><br/><div class="children"><div class="content">I honestly can&#x27;t tell if you&#x27;re trolling.<p>- the C# implementation predates even Promises in JS, so it is not &quot;the same implementation&quot; and your implication that C# was inspired by JS as opposed to the other way around is false. More background: [0]<p>- Typescript works fine with the JS implementation so any differences aren&#x27;t for type safety reasons, but largely because C# has a multithreaded event loop unlike JS<p>Also promises (or &quot;futures&quot; as they&#x27;re called elsewhere) aren&#x27;t unique to any language. They&#x27;re used in lots of places that predate both C# and JS&#x27;s use, for example the twisted framework in Python.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37438486">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37438486</a></div><br/></div></div></div></div></div></div><div id="37439300" class="c"><input type="checkbox" id="c-37439300" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37435966">root</a><span>|</span><a href="#37436081">parent</a><span>|</span><a href="#37438513">prev</a><span>|</span><a href="#37436113">next</a><span>|</span><label class="collapse" for="c-37439300">[-]</label><label class="expand" for="c-37439300">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  concurrency where your state goes everywhere and you somehow collect it back at some point was always (literally) the textbook example of how not to do it.<p>can you tell why it is not how not to do it in your opinion? What are the obvious issues with this approach?</div><br/></div></div></div></div><div id="37436113" class="c"><input type="checkbox" id="c-37436113" checked=""/><div class="controls bullet"><span class="by">smallerfish</span><span>|</span><a href="#37435966">parent</a><span>|</span><a href="#37436081">prev</a><span>|</span><a href="#37436943">next</a><span>|</span><label class="collapse" for="c-37436113">[-]</label><label class="expand" for="c-37436113">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Promise&#x2F;Future style of async is just a bad idea<p>JVM&#x27;s futures are a joy to work with compared to JS&#x27;s promises (or Kotlin&#x27;s coroutines for that matter). While similar, I don&#x27;t think you can conflate them.</div><br/></div></div><div id="37436943" class="c"><input type="checkbox" id="c-37436943" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37435966">parent</a><span>|</span><a href="#37436113">prev</a><span>|</span><a href="#37435802">next</a><span>|</span><label class="collapse" for="c-37436943">[-]</label><label class="expand" for="c-37436943">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re conflating the idea of using channels with green threads. They are different, you can easily use channels with async&#x2F;await and global state&#x2F;mutexes with green threads.</div><br/></div></div></div></div><div id="37435802" class="c"><input type="checkbox" id="c-37435802" checked=""/><div class="controls bullet"><span class="by">miguelmurca</span><span>|</span><a href="#37435966">prev</a><span>|</span><a href="#37436894">next</a><span>|</span><label class="collapse" for="c-37435802">[-]</label><label class="expand" for="c-37435802">[8 more]</label></div><br/><div class="children"><div class="content">This is bound to get some criticism (or some tangent-at-best discussion), but it seems like a pretty fair discussion to me.<p>What I&#x27;m missing at the end of the article is the author&#x27;s point: I believe they&#x27;re advocating for the use of raw threads and manual management of concurrency, and doing away with the async paraphernalia. But, at the same time, earlier in the article they give the example of networking-related tasks as something that isn&#x27;t so easy to deal with using only raw threads.<p>So, taking into account that await&amp;co. are basically syntactic sugar + an API standard (iirc, I haven&#x27;t used Rust so much lately), I wonder about what the alternative is. In particular, it seems to me like the alternative you could have would be everyone rolling their own &quot;concurrency API&quot;, where each crate (inconsistently) exposes some sort of `await()` function, and you have to manually roll your async runtime every time. This would obviously also not be ideal.</div><br/><div id="37435979" class="c"><input type="checkbox" id="c-37435979" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#37435802">parent</a><span>|</span><a href="#37435948">next</a><span>|</span><label class="collapse" for="c-37435979">[-]</label><label class="expand" for="c-37435979">[4 more]</label></div><br/><div class="children"><div class="content">I thought the author&#x27;s point was relatively clear: Rust might not be a good fit for the kind of tasks that need more concurrency than raw threads can give you. Such programs should be written in some other language instead.<p>&gt; Maybe Rust isn’t a good tool for massively concurrent, userspace software. We can save it for the 99% of our projects that don’t have to be.</div><br/><div id="37436554" class="c"><input type="checkbox" id="c-37436554" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37435802">root</a><span>|</span><a href="#37435979">parent</a><span>|</span><a href="#37435948">next</a><span>|</span><label class="collapse" for="c-37436554">[-]</label><label class="expand" for="c-37436554">[3 more]</label></div><br/><div class="children"><div class="content">So 99% of projects need raw threads only, according to the author. I doubt that.</div><br/><div id="37437003" class="c"><input type="checkbox" id="c-37437003" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#37435802">root</a><span>|</span><a href="#37436554">parent</a><span>|</span><a href="#37435948">next</a><span>|</span><label class="collapse" for="c-37437003">[-]</label><label class="expand" for="c-37437003">[2 more]</label></div><br/><div class="children"><div class="content">It sounds very reasonable to me. I would say 90% of programs don’t need threads or concurrency at all.</div><br/><div id="37437058" class="c"><input type="checkbox" id="c-37437058" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37435802">root</a><span>|</span><a href="#37437003">parent</a><span>|</span><a href="#37435948">next</a><span>|</span><label class="collapse" for="c-37437058">[-]</label><label class="expand" for="c-37437058">[1 more]</label></div><br/><div class="children"><div class="content">Anything that waits on I&#x2F;O needs concurrency (but not necessarily threads). Web backends, web frontends, deeper backends, desktop GUIs, that&#x27;s probably 90% of software right there.</div><br/></div></div></div></div></div></div></div></div><div id="37436718" class="c"><input type="checkbox" id="c-37436718" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#37435802">parent</a><span>|</span><a href="#37435948">prev</a><span>|</span><a href="#37436218">next</a><span>|</span><label class="collapse" for="c-37436718">[-]</label><label class="expand" for="c-37436718">[1 more]</label></div><br/><div class="children"><div class="content">I thought his point was async is not good for apps with lots of work to do, and that green threads are a much better idea. IDK.</div><br/></div></div><div id="37436218" class="c"><input type="checkbox" id="c-37436218" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37435802">parent</a><span>|</span><a href="#37436718">prev</a><span>|</span><a href="#37436894">next</a><span>|</span><label class="collapse" for="c-37436218">[-]</label><label class="expand" for="c-37436218">[1 more]</label></div><br/><div class="children"><div class="content">The author&#x27;s point is that Rust is not a good language for software like that example. But very, very little software is like that, and you can always divide it up in large blocks inside of what Rust fits quite well.<p>Personally, I&#x27;m a bit more radical than the author. You won&#x27;t be able to write software like the example correctly. It should just not be done, ever. Machines can still optimize some sanely organized software into the same thing, maybe, if it happens to be a tractable problem (I&#x27;m not sure anybody knows). But people shouldn&#x27;t touch that thing.</div><br/></div></div></div></div><div id="37436894" class="c"><input type="checkbox" id="c-37436894" checked=""/><div class="controls bullet"><span class="by">Taek</span><span>|</span><a href="#37435802">prev</a><span>|</span><a href="#37435902">next</a><span>|</span><label class="collapse" for="c-37436894">[-]</label><label class="expand" for="c-37436894">[6 more]</label></div><br/><div class="children"><div class="content">Rust made a critical safety mistake when it chose its async paradigm. It gave the code the option to decide when to yield.<p>What that means is that when I&#x27;m writing async code, I have to audit every library I import to make sure that library is guaranteed to yield after a few microseconds of execution, otherwise my own core loops starve. Importing unknown code when using async rust is not safe for any application that needs to know its own threads won&#x27;t starve.<p>A safe async language must guarantee that threads will make progress. Rust should change the scheduler so that it can pre-empt any code after that code has hogged a thread for too long.</div><br/><div id="37443340" class="c"><input type="checkbox" id="c-37443340" checked=""/><div class="controls bullet"><span class="by">kasdi</span><span>|</span><a href="#37436894">parent</a><span>|</span><a href="#37438791">next</a><span>|</span><label class="collapse" for="c-37443340">[-]</label><label class="expand" for="c-37443340">[1 more]</label></div><br/><div class="children"><div class="content">Naive question: Why not use OS concurrency then?</div><br/></div></div><div id="37438791" class="c"><input type="checkbox" id="c-37438791" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37436894">parent</a><span>|</span><a href="#37443340">prev</a><span>|</span><a href="#37437596">next</a><span>|</span><label class="collapse" for="c-37438791">[-]</label><label class="expand" for="c-37438791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust should change the scheduler<p>Rust doesn&#x27;t have a scheduler, and having one would be a no-go for any sufficiently low level code (e.g. in microcontrollers).</div><br/></div></div><div id="37437596" class="c"><input type="checkbox" id="c-37437596" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#37436894">parent</a><span>|</span><a href="#37438791">prev</a><span>|</span><a href="#37435902">next</a><span>|</span><label class="collapse" for="c-37437596">[-]</label><label class="expand" for="c-37437596">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A safe async language must guarantee that threads will make progress.<p>You might be looking for parallelism, not concurrency.</div><br/><div id="37439889" class="c"><input type="checkbox" id="c-37439889" checked=""/><div class="controls bullet"><span class="by">brickteacup</span><span>|</span><a href="#37436894">root</a><span>|</span><a href="#37437596">parent</a><span>|</span><a href="#37435902">next</a><span>|</span><label class="collapse" for="c-37439889">[-]</label><label class="expand" for="c-37439889">[2 more]</label></div><br/><div class="children"><div class="content">No? You don&#x27;t need parallelism to guarantee global progress as long as the scheduler has the ability to preempt tasks. Of course coroutines (as opposed to e.g. userspace threads) can&#x27;t really be preempted, which is the issue here.</div><br/><div id="37442077" class="c"><input type="checkbox" id="c-37442077" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#37436894">root</a><span>|</span><a href="#37439889">parent</a><span>|</span><a href="#37435902">next</a><span>|</span><label class="collapse" for="c-37442077">[-]</label><label class="expand" for="c-37442077">[1 more]</label></div><br/><div class="children"><div class="content">&gt; parallelism to guarantee global progress as long as the scheduler has the ability to preempt task<p>Preempting tasks is a single-core simulation of parallelism. I suspect there is confusion about what parallelism and concurrency are here: the terms are often used interchangeably (especially saying &quot;concurrency&quot; instead of &quot;parallelism&quot;), but they are definitely not interchangeable - or even, arguably, related at all. Concurrency, <i>by definition,</i> is concerned with continuations. If you remove continuations (async&#x2F;await and&#x2F;or futures&#x2F;promises - depending on the language choices) then you aren&#x27;t talking about concurrency any more.<p>Either way, you can use parallelism is Rust today - just use blocking APIs, locking, and threads. I don&#x27;t get what the big deal is. You can even use concurrency and parallelism together, just use await&#x2F;async across multiple threads.<p>I agree with the premise of the article, but the reasoning in this comment chain is something along the lines of &quot;cats are horrible, because 5.&quot; The criticism is foreign to the entire subject matter.</div><br/></div></div></div></div></div></div></div></div><div id="37435902" class="c"><input type="checkbox" id="c-37435902" checked=""/><div class="controls bullet"><span class="by">snailscale</span><span>|</span><a href="#37436894">prev</a><span>|</span><a href="#37435870">next</a><span>|</span><label class="collapse" for="c-37435902">[-]</label><label class="expand" for="c-37435902">[2 more]</label></div><br/><div class="children"><div class="content">I somewhat agree with the author, sometimes with async rust I need to figure out how to tell the compiler that yes I want to recursively call this async function. This can be a huge pain, especially because it’s not always clear what went wrong.<p>Other times however rust stops me from writing buggy code and where I didn’t quite understand what I was doing. In some sense it can help you understand what your software better (when the problem isn’t an implementation detail).<p>I get the authors frustration, I often have the same feelings. Sometimes you just want to tell rust to get out of your way.<p>As an aside, I think there is room for a language similar to golang with sum types and modules and be a joy.</div><br/><div id="37440455" class="c"><input type="checkbox" id="c-37440455" checked=""/><div class="controls bullet"><span class="by">zupa-hu</span><span>|</span><a href="#37435902">parent</a><span>|</span><a href="#37435870">next</a><span>|</span><label class="collapse" for="c-37440455">[-]</label><label class="expand" for="c-37440455">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean by modules?</div><br/></div></div></div></div><div id="37435870" class="c"><input type="checkbox" id="c-37435870" checked=""/><div class="controls bullet"><span class="by">TensorTinkerer</span><span>|</span><a href="#37435902">prev</a><span>|</span><a href="#37437056">next</a><span>|</span><label class="collapse" for="c-37435870">[-]</label><label class="expand" for="c-37435870">[1 more]</label></div><br/><div class="children"><div class="content">While the article elucidates well on the intricacies and challenges of async Rust, I feel it&#x27;s crucial to note that one of Rust&#x27;s core philosophies is ensuring memory safety without sacrificing performance.<p>The async patterns in Rust, especially with regards to data safety assurances for the compiler, are emblematic of this philosophy. Though there are complexities, the value proposition is a safer concurrency model that requires developers to think deeply about their data and execution flow. I do concur that Rust might not be the go-to for every massively concurrent userspace application, but for systems where robustness and safety are paramount, the trade-offs are justifiable. It&#x27;s also worth noting that as the ecosystem evolves, we&#x27;ll likely see more abstractions and libraries that ease these pain points.<p>Still, diving into the intricacies as this article does, gives developers a better foundational understanding, which in itself is invaluable.</div><br/></div></div><div id="37437056" class="c"><input type="checkbox" id="c-37437056" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37435870">prev</a><span>|</span><a href="#37437615">next</a><span>|</span><label class="collapse" for="c-37437056">[-]</label><label class="expand" for="c-37437056">[1 more]</label></div><br/><div class="children"><div class="content">I wish people would stop saying concurrency and parallelism are different.<p>Concurrency is a subtype of parallelism.  All concurrency is parallelism, but leaving some aspects of parallelism off the table.<p>I&#x27;ve worked in both worlds: I&#x27;ve built codes that manage thousands of connections through the ancient select() call on single processes (classic concurrency- IO multiplexing where most channels are not active simultaneously, and the amount of CPU work per channel is small) to synchronous parallelism on enormous supercomputers using MPI to eke out that last bit from Amdahl&#x27;s law.<p>Over time I&#x27;ve come to the conclusion that a thread pool (possibly managed by the language runtime) that uses channels for communication and has optimizations for work stealing (to keep queues balanced) and eliminating context switches.  Although it does not reach the optimal throughput of the machine (because shared memory is faster than message passing) it&#x27;s a straightforward paradigm to work with and the developers of the concurrency&#x2F;parallel frameworks are wise.</div><br/></div></div><div id="37437615" class="c"><input type="checkbox" id="c-37437615" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37437056">prev</a><span>|</span><a href="#37436737">next</a><span>|</span><label class="collapse" for="c-37437615">[-]</label><label class="expand" for="c-37437615">[5 more]</label></div><br/><div class="children"><div class="content">Async Rust also ends up with these super nasty types involving Future that can&#x27;t even be named half the time and you have to refer to them by existential types, like `impl Future&lt;Output = Foo&gt;`.<p>But these existential types can only be specified in function return or parameter position, so if you want to name a type for e.g.:<p><pre><code>  let x = async { };
</code></pre>
You can&#x27;t! Because you can only refer to it as `impl Future&lt;Output = ()&gt;` but that&#x27;s not allowed in a variable binding!</div><br/><div id="37437748" class="c"><input type="checkbox" id="c-37437748" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37437615">parent</a><span>|</span><a href="#37436737">next</a><span>|</span><label class="collapse" for="c-37437748">[-]</label><label class="expand" for="c-37437748">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not wrong, but I don&#x27;t really see the problem? Even well before async Rust, closures worked the same way with not being able to specify a concrete type, and `impl Trait` syntax didn&#x27;t even exist for a while. Annotating local variable types is a way to fix certain things that would otherwise be ambiguous; it&#x27;s a means to an end, only an end itself.</div><br/><div id="37438378" class="c"><input type="checkbox" id="c-37438378" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37437615">root</a><span>|</span><a href="#37437748">parent</a><span>|</span><a href="#37436737">next</a><span>|</span><label class="collapse" for="c-37438378">[-]</label><label class="expand" for="c-37438378">[3 more]</label></div><br/><div class="children"><div class="content">Ah that&#x27;s true, but I think it ends up hairier when you combine the two together and have closures that are async, e.g.:<p><pre><code>  let x = || -&gt; i32 { 1 };  &#x2F;&#x2F; fine
  let x = || -&gt; impl Future&lt;Output = i32&gt; { async { 1 } };  &#x2F;&#x2F; error: `impl Trait` only allowed in function and inherent method return types, not in closure return types
</code></pre>
Unless I&#x27;m missing something, sometimes you do have to name the return type of an async closure if it&#x27;s returning e.g Result&lt;T, Box&lt;dyn Error&gt;&gt;, and use of the ? operator means that the return type can&#x27;t be inferred without an explicit annotation.</div><br/><div id="37439059" class="c"><input type="checkbox" id="c-37439059" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37437615">root</a><span>|</span><a href="#37438378">parent</a><span>|</span><a href="#37439986">next</a><span>|</span><label class="collapse" for="c-37439059">[-]</label><label class="expand" for="c-37439059">[1 more]</label></div><br/><div class="children"><div class="content">I think part of the disconnect is that that what you&#x27;re calling an &quot;async closure&quot; is more directly an analog of a &quot;regular&quot; function that happens to return a future rather than an &quot;async fn&quot; declared function; you&#x27;d need similar syntactic boilerplate for annotating a function that&#x27;s not declared as &quot;async&quot;. Currently, there is no closure version of an &quot;async fn&quot; in Rust, but it&#x27;s arguably not particularly necessary because you can use a Future as the async version of a closure in a lot of cases due to them being lazy already. For example, spawning a task with tokio just takes a Future, not a closure like spawning a sync thread.</div><br/></div></div><div id="37439986" class="c"><input type="checkbox" id="c-37439986" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#37437615">root</a><span>|</span><a href="#37438378">parent</a><span>|</span><a href="#37439059">prev</a><span>|</span><a href="#37436737">next</a><span>|</span><label class="collapse" for="c-37439986">[-]</label><label class="expand" for="c-37439986">[1 more]</label></div><br/><div class="children"><div class="content">You can annotate the return type inside the closure in those cases, for example:<p><pre><code>    let x = || async {
        let file = std::fs::read_to_string(&quot;foo.txt&quot;)?;
        Ok::&lt;_, Box&lt;dyn std::error::Error&gt;&gt;(file)
    };</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="37436737" class="c"><input type="checkbox" id="c-37436737" checked=""/><div class="controls bullet"><span class="by">uhura</span><span>|</span><a href="#37437615">prev</a><span>|</span><a href="#37437423">next</a><span>|</span><label class="collapse" for="c-37436737">[-]</label><label class="expand" for="c-37436737">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the &quot;<i>Maybe Rust isn’t a good tool for massively concurrent, userspace software</i>&quot; conclusion.<p>Rust is all about lifetimes and the borrow checker. Async code (a la C#) will introduce overhead to reason about lifetime and it might not be as &quot;fun&quot; as it is with other languages that makes use of GCs and bigger runtimes.<p>The CSP vs Async&#x2F;Await discussion is valid, but like in the majority of the cases, the drawbacks and benefits are not language relevant.<p>In CSP, the concurrent snippets behave just like linear&#x2F;sequencial code as channels abstracts await a lot of the ugly bits. Sequential code tends to be easier to reason and this might be very important for Rust considering it design.<p>A good tool for massively concurrent software will as expected depend on the aspects you&#x27;re evaluating:
- Performance: the text does not show benchmarks evaluating Rust as a slow language.
- Code&#x2F;Feature throughput: the overall conclusion from the text if that Async Rust is a complex tool and expose the programmers in many ways to shoot themselves in the foot.<p>Assuming the &quot;<i>Maybe Rust...</i>&quot; is only talking about Async Rust, the existence of big Async Rust projects is a good counter argument. We also have the whole rest of the Rust language to code massively concurrent, userspace software.<p>Massively concurrent, userspace software tends to be complex and big to the point that design decisions generally impact way more the language decision.<p>Rust is a modern language with interesting features to prevent programmers from writing unsafe programs and this is a good head start to many when making those kind of programs, more than whether you want to use Async code or not.</div><br/></div></div><div id="37437423" class="c"><input type="checkbox" id="c-37437423" checked=""/><div class="controls bullet"><span class="by">whoknowsidont</span><span>|</span><a href="#37436737">prev</a><span>|</span><a href="#37435876">next</a><span>|</span><label class="collapse" for="c-37437423">[-]</label><label class="expand" for="c-37437423">[3 more]</label></div><br/><div class="children"><div class="content">Use Erlang&#x2F;Elixir for orchestration and call into rust implementations.<p>It&#x27;s an amazing combination.</div><br/><div id="37437631" class="c"><input type="checkbox" id="c-37437631" checked=""/><div class="controls bullet"><span class="by">technojamin</span><span>|</span><a href="#37437423">parent</a><span>|</span><a href="#37435876">next</a><span>|</span><label class="collapse" for="c-37437631">[-]</label><label class="expand" for="c-37437631">[2 more]</label></div><br/><div class="children"><div class="content">Elixir&#x2F;Rust is the new Python&#x2F;C++, and Rustler makes the communicating between the 2 languages super easy: <a href="https:&#x2F;&#x2F;github.com&#x2F;rusterlium&#x2F;rustler">https:&#x2F;&#x2F;github.com&#x2F;rusterlium&#x2F;rustler</a></div><br/><div id="37438787" class="c"><input type="checkbox" id="c-37438787" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#37437423">root</a><span>|</span><a href="#37437631">parent</a><span>|</span><a href="#37435876">next</a><span>|</span><label class="collapse" for="c-37438787">[-]</label><label class="expand" for="c-37438787">[1 more]</label></div><br/><div class="children"><div class="content">And if Zig feels like it fits the gestalt of Elixir&#x2F;Erlang better for you... then there&#x27;s Zigler (<a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;zigler&#x2F;Zig.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;zigler&#x2F;Zig.html</a>). The fact that you can just &quot;insert a little zig code right here&quot; in the middle of your Elixir code in a ~Z sigil is the coolest darn thing there is. I haven&#x27;t seen something that cool in the way of embedding performance enhancing fragments&#x2F;snippets in another dynamic&#x2F;expressive system since Klaus Gittinger&#x27;s Smalltalk&#x2F;X (<a href="https:&#x2F;&#x2F;live.exept.de&#x2F;doc&#x2F;online&#x2F;english&#x2F;programming&#x2F;primitive.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;live.exept.de&#x2F;doc&#x2F;online&#x2F;english&#x2F;programming&#x2F;primiti...</a>)</div><br/></div></div></div></div></div></div><div id="37435876" class="c"><input type="checkbox" id="c-37435876" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#37437423">prev</a><span>|</span><a href="#37442728">next</a><span>|</span><label class="collapse" for="c-37435876">[-]</label><label class="expand" for="c-37435876">[1 more]</label></div><br/><div class="children"><div class="content">Most of the rant, apart from the old man yells at function colors, is about lifetimes of arguments of async functions. And it&#x27;s presenting a special case as some kind of pervasive limitation.<p>Async functions don&#x27;t have to always own their arguments. Just the outermost future that is getting spawned on another thread has to. The rest of the async program can borrow arguments as usual. You don&#x27;t need to spawn() every task — there are other primitives for running multiple futures, with borrowed data, on the same thread.<p>In fact, this ability for a future to borrow from itself is the reason why Rust has native await instead of using callbacks. Futures can be &quot;self-referential&quot; in Rust, and nothing else is allowed to.</div><br/></div></div><div id="37442728" class="c"><input type="checkbox" id="c-37442728" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#37435876">prev</a><span>|</span><a href="#37436663">next</a><span>|</span><label class="collapse" for="c-37442728">[-]</label><label class="expand" for="c-37442728">[1 more]</label></div><br/><div class="children"><div class="content">Java performance is really good, and I find Java development much faster than Rust. Also the JVM has all these awesome performance monitoring and profiling tools. Rust is unmatched for very high performance concurrency, but for most things, a garbage collected language is going to do just great.</div><br/></div></div><div id="37436663" class="c"><input type="checkbox" id="c-37436663" checked=""/><div class="controls bullet"><span class="by">mightyham</span><span>|</span><a href="#37442728">prev</a><span>|</span><a href="#37436141">next</a><span>|</span><label class="collapse" for="c-37436663">[-]</label><label class="expand" for="c-37436663">[2 more]</label></div><br/><div class="children"><div class="content">I really can&#x27;t even begin to empathize with the author. I find async&#x2F;await to be significantly more ergonomic then the alternative in almost every use case.<p>The arguments about Arc fall flat because how else would you safely manage shared references, even in other lower level languages. And so called &quot;modern GCs&quot; still do come with a significant hit in performance; it&#x27;s not just some &quot;bizarre psyop&quot;.<p>Really the only problem I&#x27;ve run into with Rust&#x27;s async&#x2F;await is the fact that there is not much support for composing async tasks in a structured way (i.e. structured programming) and the author doesn&#x27;t even touch on this issue.<p>Ultimately the goals and criticism of the author are just downright confusing because at the end he admits that he doesn&#x27;t actually care for the fact that Rust is design constrained by being a low level language and instead advocates for using Haskell or Go for any application that requires significant concurrency. So to reformulate his argument: we should never use or design into low level languages an ergonomically integrated concurrency runtime because it may have a handful of engineering challenges. When put concisely, their thesis is really quite ridiculous.</div><br/><div id="37436846" class="c"><input type="checkbox" id="c-37436846" checked=""/><div class="controls bullet"><span class="by">drogus</span><span>|</span><a href="#37436663">parent</a><span>|</span><a href="#37436141">next</a><span>|</span><label class="collapse" for="c-37436846">[-]</label><label class="expand" for="c-37436846">[1 more]</label></div><br/><div class="children"><div class="content">I find this post extremely weird. The author starts with saying sharing state is bad and then continues to complain sharing state in async Rust is hard, which is like, use channels if you don&#x27;t want to pass mutexes everywhere?</div><br/></div></div></div></div><div id="37436141" class="c"><input type="checkbox" id="c-37436141" checked=""/><div class="controls bullet"><span class="by">addisonj</span><span>|</span><a href="#37436663">prev</a><span>|</span><a href="#37440280">next</a><span>|</span><label class="collapse" for="c-37436141">[-]</label><label class="expand" for="c-37436141">[1 more]</label></div><br/><div class="children"><div class="content">This is a pretty interesting article... and I generally agree with the pain points... but I don&#x27;t really like the conclusion<p>* While the author states that not many apps &quot;need&quot; high concurrency in userspace... I would invert that and say that we may be missing so much performance, new potential applications, etc <i>because</i> highly concurrent code is so hard to get right. One bit of evidence of this (to me at least) is how often in my career I have had to scale things up due to memory or other resource limitations and not CPU. And when it is CPU, so often looking into it more finds bugs with concurrency that are the root cause or at least exacerbate the issue<p>* While I completely agree that rust is <i>not easy</i> with async and have myself poked around at which magical type things I need to do each time I have touched async rust code, I don&#x27;t really like the suggestion being to &quot;go use a different language&quot;, first, because if you are picking up rust, you (IMHO) should have a very good reason to already have chosen it. Rust is not easy enough or ubiquitous enough that you should be choosing it &quot;just for fun&quot; and your reason for using Rust should be compelling enough that you (right now) are willing to put in the effort to learn async <i>when you need it</i><p>* What the other mentions in the body of the article, but I think is more of what my suggestion would be: <i>don&#x27;t use async unless you need it!</i>. While I would love to see Rust (and think it should) evolve to the point where async is &quot;easy&quot;, maybe we instead just need to get more pragmatic in what is taught and written about. I think when people start Rust they want to use all the fanciness, which includes async, and while some of that is just programmers, I think it is also how tutorials, docs, and general communication about a programming language happens where we show the breadth of capability, rather than the more realistic learning path, which leads people to feel like if they don&#x27;t use async, they aren&#x27;t doing it right<p>Finally, I do really hope Rust keeps working on the promise of these zero cost abstractions that can really simplify things... but if that doesn&#x27;t work, I am at least hopeful of what people can build on top of the rust featureset&#x2F;toolchain to help make things like async more realistic to be the default without the need for a complex VM&#x2F;runtime.</div><br/></div></div><div id="37440280" class="c"><input type="checkbox" id="c-37440280" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37436141">prev</a><span>|</span><a href="#37436054">next</a><span>|</span><label class="collapse" for="c-37440280">[-]</label><label class="expand" for="c-37440280">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if Rust should have gone down the same path as Java’s Project Loom and implemented async I&#x2F;O using the same memory model that is used with operating system threads.<p>I suspect that to take advantage of 1024-thread systems the only sane programming model will be structured concurrency with virtual threads instead of coroutines.<p>It’s the same progression as we saw in the industry going from unstructured imperative assembly programming to structured programming with modular features.<p>Both traditional mutexes and to a degree async programming are unstructured and global. They infect the whole codebase and can’t be reasoned about in isolation. This just doesn’t scale.</div><br/><div id="37440978" class="c"><input type="checkbox" id="c-37440978" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#37440280">parent</a><span>|</span><a href="#37436054">next</a><span>|</span><label class="collapse" for="c-37440978">[-]</label><label class="expand" for="c-37440978">[2 more]</label></div><br/><div class="children"><div class="content">I believe rust started with green threads early on, before ditching them.<p>To your point, the C# guys seem to be interested in experimenting with green threads: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;davidfowl&#x2F;status&#x2F;1532880744732758018" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;davidfowl&#x2F;status&#x2F;1532880744732758018</a></div><br/><div id="37441573" class="c"><input type="checkbox" id="c-37441573" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#37440280">root</a><span>|</span><a href="#37440978">parent</a><span>|</span><a href="#37436054">next</a><span>|</span><label class="collapse" for="c-37441573">[-]</label><label class="expand" for="c-37441573">[1 more]</label></div><br/><div class="children"><div class="content">It was looked at and deemed an inferior design. Especially so given that existing async&#x2F;await paradigm in .NET works really well with existing language features that would make adoption of green-threads-like approach problematic.</div><br/></div></div></div></div></div></div><div id="37436054" class="c"><input type="checkbox" id="c-37436054" checked=""/><div class="controls bullet"><span class="by">stallmanwasrigh</span><span>|</span><a href="#37440280">prev</a><span>|</span><a href="#37439192">next</a><span>|</span><label class="collapse" for="c-37436054">[-]</label><label class="expand" for="c-37436054">[9 more]</label></div><br/><div class="children"><div class="content">&gt; At this scale, threads won’t cut it—while they’re pretty cheap, fire up a thread per connection and your computer will grind to a halt.<p>Maybe in the 2000&#x27;s but I feel this reasoning is no longer valid in 2023 and should be put to rest.<p>10k problem.. Wouldn&#x27;t modern computing not work if my Linux box couldn&#x27;t spin up 10k threads? Htop says I&#x27;m currently at 4,000 threads on an 8 core machine.</div><br/><div id="37440290" class="c"><input type="checkbox" id="c-37440290" checked=""/><div class="controls bullet"><span class="by">mwcampbell</span><span>|</span><a href="#37436054">parent</a><span>|</span><a href="#37437685">next</a><span>|</span><label class="collapse" for="c-37440290">[-]</label><label class="expand" for="c-37440290">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe in the 2000&#x27;s but I feel this reasoning is no longer valid in 2023 and should be put to rest.<p>So do we discard existing ways of making software more efficient because we can be more wasteful on more recent hardware? What if we could develop our software such that 2000s computers are still useful, rather than letting those computers become e-waste?</div><br/></div></div><div id="37437685" class="c"><input type="checkbox" id="c-37437685" checked=""/><div class="controls bullet"><span class="by">ripley12</span><span>|</span><a href="#37436054">parent</a><span>|</span><a href="#37440290">prev</a><span>|</span><a href="#37436175">next</a><span>|</span><label class="collapse" for="c-37437685">[-]</label><label class="expand" for="c-37437685">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I think you&#x27;re generally right. I&#x27;m a big fan of this blog post: <a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2018&#x2F;measuring-context-switching-and-memory-overheads-for-linux-threads&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2018&#x2F;measuring-context-switchi...</a><p>&gt; The numbers reported here paint an interesting picture on the state of Linux multi-threaded performance in 2018. I would say that the limits still exist - running a million threads is probably not going to make sense; however, the limits have definitely shifted since the past, and a lot of folklore from the early 2000s doesn&#x27;t apply today. On a beefy multi-core machine with lots of RAM we can easily run 10,000 threads in a single process today, in production. As I&#x27;ve mentioned above, it&#x27;s highly recommended to watch Google&#x27;s talk on fibers; through careful tuning of the kernel (and setting smaller default stacks) Google is able to run an order of magnitude more threads in parallel.</div><br/><div id="37439656" class="c"><input type="checkbox" id="c-37439656" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37436054">root</a><span>|</span><a href="#37437685">parent</a><span>|</span><a href="#37436175">next</a><span>|</span><label class="collapse" for="c-37439656">[-]</label><label class="expand" for="c-37439656">[1 more]</label></div><br/><div class="children"><div class="content">so, in that benchmark, context switch is comparable to copying 64k mem, which is kinda significant, I run some heavy load database with few hundreds threads, and see that it does 100k context switching per sec some times.</div><br/></div></div></div></div><div id="37436175" class="c"><input type="checkbox" id="c-37436175" checked=""/><div class="controls bullet"><span class="by">efficax</span><span>|</span><a href="#37436054">parent</a><span>|</span><a href="#37437685">prev</a><span>|</span><a href="#37436109">next</a><span>|</span><label class="collapse" for="c-37436175">[-]</label><label class="expand" for="c-37436175">[4 more]</label></div><br/><div class="children"><div class="content">The context switch for threads remains very expensive. You have 4,000 threads but that&#x27;s lots of different processes spinning up their own threads. it&#x27;s still more efficient to have one thread per core for a single computational problem, or at most one per CPU thread (often 2 threads per core now). You can test this by using something like rayon or GNU parallel using more threads than you have cores. It won&#x27;t go faster, and after a certain point, it goes slower.<p>The async case is suited to situations where you&#x27;re blocking for things like network requests. In that case the thread will be doing nothing, so we want to hand off the work to another task of some kind that is active. Green threads mean you can do that without a context switch.</div><br/><div id="37436302" class="c"><input type="checkbox" id="c-37436302" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37436054">root</a><span>|</span><a href="#37436175">parent</a><span>|</span><a href="#37436310">next</a><span>|</span><label class="collapse" for="c-37436302">[-]</label><label class="expand" for="c-37436302">[2 more]</label></div><br/><div class="children"><div class="content">Since that time, context switching changed from a O(log(n)) operation to an O(1) one.<p>I have no doubt that having a thread per core and managing the data with only non-blocking operations is much faster. But I&#x27;m pretty current machines can manage a thousand or so threads locked almost the entire time just fine.</div><br/><div id="37436378" class="c"><input type="checkbox" id="c-37436378" checked=""/><div class="controls bullet"><span class="by">lossolo</span><span>|</span><a href="#37436054">root</a><span>|</span><a href="#37436302">parent</a><span>|</span><a href="#37436310">next</a><span>|</span><label class="collapse" for="c-37436378">[-]</label><label class="expand" for="c-37436378">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since that time, context switching changed from a O(log(n)) operation to an O(1) one.<p>I&#x27;m not sure how that&#x27;s relevant here, if for example something takes 1ms and I do it 1000 times a second, I&#x27;m using 1000 ms of CPU time vs not doing it at all.
So if you want to use big o notation in this context it should be O(n) where n is the number of context switches, because you are not comparing algorithms used to switch between threads but you are comparing doing context switch or not doing it at all.</div><br/></div></div></div></div><div id="37436310" class="c"><input type="checkbox" id="c-37436310" checked=""/><div class="controls bullet"><span class="by">lossolo</span><span>|</span><a href="#37436054">root</a><span>|</span><a href="#37436175">parent</a><span>|</span><a href="#37436302">prev</a><span>|</span><a href="#37436109">next</a><span>|</span><label class="collapse" for="c-37436310">[-]</label><label class="expand" for="c-37436310">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The context switch for threads remains very expensive<p>It got even more expensive in recent years after all the speculative execution vulnerabilities in CPUs, so now you have additional logic on every context switch with mitigations on in kernel.</div><br/></div></div></div></div><div id="37436109" class="c"><input type="checkbox" id="c-37436109" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37436054">parent</a><span>|</span><a href="#37436175">prev</a><span>|</span><a href="#37439192">next</a><span>|</span><label class="collapse" for="c-37436109">[-]</label><label class="expand" for="c-37436109">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 10k problem.. Wouldn&#x27;t modern computing not work if my Linux box couldn&#x27;t spin up 10k threads? Htop says I&#x27;m currently at 4,000 threads on an 8 core machine.<p>By the 2010s the problem had been updated to C10M. The people discussing it (well, perhaps some) aren&#x27;t idiots and understand that the threshold changes as hardware changes.<p>Also, the issue isn&#x27;t creating 10k <i>threads</i> it&#x27;s dealing with 10k concurrent users (or, again, a much higher number today).</div><br/></div></div></div></div><div id="37439192" class="c"><input type="checkbox" id="c-37439192" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#37436054">prev</a><span>|</span><a href="#37436222">next</a><span>|</span><label class="collapse" for="c-37439192">[-]</label><label class="expand" for="c-37439192">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some problems demand a lot of concurrency. The canonical example, described by Dan Kagel as the C10K problem back in 1999, is a web server connected to tens of thousands of concurrent users. At this scale, threads won’t cut it—while they’re pretty cheap,5 fire up a thread per connection and your computer will grind to a halt.<p>Try it. It&#x27;ll probably work fine. It may be very expensive, memory wise, but it&#x27;s easy to get a machine with a lot of memory.</div><br/></div></div><div id="37436222" class="c"><input type="checkbox" id="c-37436222" checked=""/><div class="controls bullet"><span class="by">jnxx</span><span>|</span><a href="#37439192">prev</a><span>|</span><a href="#37438541">next</a><span>|</span><label class="collapse" for="c-37436222">[-]</label><label class="expand" for="c-37436222">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We want to use the whole computer. Code runs on CPUs, and in 2023, even my phone has eight of the damn things. If I want to use more than 12% of the machine, I need several cores.<p>Isn&#x27;t that already, in this strong generality, an almost always wrong assumption?<p>Sure, one can do massively parallel or embarrassingly parallel computation.<p>Sure, graphic cards are parallel computers.<p>Sure, OS kernels use multiple cores.<p>Sure, languages and concepts like Clojure exist and work - for a specific domain, like web services (and for that, Clojure works fascinatingly well).<p>But there are many, even conceptually simple algorithms which are not easy to parallelize. There is no efficient parallel Fast Fourier Transform I know of.</div><br/><div id="37437114" class="c"><input type="checkbox" id="c-37437114" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37436222">parent</a><span>|</span><a href="#37436339">next</a><span>|</span><label class="collapse" for="c-37437114">[-]</label><label class="expand" for="c-37437114">[1 more]</label></div><br/><div class="children"><div class="content">And there are even different degrees of parallelization. Some things will scale almost linearly to CPU cores, some will share a little state and see diminishing returns, some will share a lot of state and maybe only make good use of 2 cores, and it&#x27;ll all depend on the hardware too.</div><br/></div></div><div id="37436339" class="c"><input type="checkbox" id="c-37436339" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37436222">parent</a><span>|</span><a href="#37437114">prev</a><span>|</span><a href="#37438541">next</a><span>|</span><label class="collapse" for="c-37436339">[-]</label><label class="expand" for="c-37436339">[1 more]</label></div><br/><div class="children"><div class="content">Well, if he wants to get close to using 12% of the machine, he&#x27;ll need the SIMD intrinsics that are hidden behind `unsafe` :(</div><br/></div></div></div></div><div id="37438541" class="c"><input type="checkbox" id="c-37438541" checked=""/><div class="controls bullet"><span class="by">poorman</span><span>|</span><a href="#37436222">prev</a><span>|</span><a href="#37440634">next</a><span>|</span><label class="collapse" for="c-37438541">[-]</label><label class="expand" for="c-37438541">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone have links to resources that someone new to Rust should read on how to conceptualize async code in Rust? Based on reading the comments, it would seem there are ways to start with writing synchronous code, and if necessary make it async but do it in such a way that is runtime agnostic... don&#x27;t just reach for Tokio.<p>If I&#x27;m implementing a library, how should I write it so that the consumer of the library doesn&#x27;t have to pull in Tokio if they don&#x27;t want to?</div><br/></div></div><div id="37440634" class="c"><input type="checkbox" id="c-37440634" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37438541">prev</a><span>|</span><label class="collapse" for="c-37440634">[-]</label><label class="expand" for="c-37440634">[2 more]</label></div><br/><div class="children"><div class="content">Rust still isn&#x27;t the language I&#x27;m looking for.<p>It&#x27;s too complex.<p>Something simpler is needed with the benefits of memory safety.</div><br/><div id="37440824" class="c"><input type="checkbox" id="c-37440824" checked=""/><div class="controls bullet"><span class="by">memsafmeme</span><span>|</span><a href="#37440634">parent</a><span>|</span><label class="collapse" for="c-37440824">[-]</label><label class="expand" for="c-37440824">[1 more]</label></div><br/><div class="children"><div class="content">So anything from Python, Perl, PHP, Visual Basic, Java, C#, Go, Ruby, Erlang, OCaml, Scheme, Common Lisp?</div><br/></div></div></div></div></div></div></div></div></div></body></html>