<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689584451521" as="style"/><link rel="stylesheet" href="styles.css?v=1689584451521"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://surma.dev/things/webgpu/">WebGPU – All of the cores, none of the canvas</a> <span class="domain">(<a href="https://surma.dev">surma.dev</a>)</span></div><div class="subtext"><span>pythops</span> | <span>21 comments</span></div><br/><div><div id="36752858" class="c"><input type="checkbox" id="c-36752858" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#36755405">next</a><span>|</span><label class="collapse" for="c-36752858">[-]</label><label class="expand" for="c-36752858">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a graphics programmer who has quite a bit of experience with WebGL, and (disclaimer) I&#x27;ve also contributed to the WebGPU spec.<p>&gt; Quite honestly, I have no idea how ThreeJS manages to be so robust, but it does manage somehow.<p>&gt; To be clear, me not being able to internalize WebGL is probably a shortcoming of my own. People smarter than me have been able to build amazing stuff with WebGL (and OpenGL outside the web), but it just never really clicked for me.<p>WebGL (and OpenGL) are awful APIs that can give you a very backwards impression about how to use them, and are <i>very</i> state-sensitive. It is not your fault for getting stuck here. Basically one of the first things everybody does is build a sane layer on top of OpenGL; if you are using gl.enable(gl.BLEND) in your core render loop, you have basically already failed.<p>The first thing everybody does when they start working with WebGL is basically build a little helper on top that makes it easier to control its state logic and do draws all in one go. You can find this helper in three.js here: <a href="https:&#x2F;&#x2F;github.com&#x2F;mrdoob&#x2F;three.js&#x2F;blob&#x2F;master&#x2F;src&#x2F;renderers&#x2F;webgl&#x2F;WebGLState.js">https:&#x2F;&#x2F;github.com&#x2F;mrdoob&#x2F;three.js&#x2F;blob&#x2F;master&#x2F;src&#x2F;renderers...</a><p>&gt; Luckily, accessing an array is safe-guarded by an implicit clamp, so every write past the end of the array will end up writing to the last element of the array<p>This article might be a bit out of date (mind putting a publish date on these articles?), but these days, the language has been a bit relaxed. From <a href="https:&#x2F;&#x2F;gpuweb.github.io&#x2F;gpuweb&#x2F;#security-shader" rel="nofollow noreferrer">https:&#x2F;&#x2F;gpuweb.github.io&#x2F;gpuweb&#x2F;#security-shader</a> :<p>&gt; If the shader attempts to write data outside of physical resource bounds, the implementation is allowed to:<p>&gt; * write the value to a different location within the resource bounds<p>&gt; * discard the write operation<p>&gt; * partially discard the draw or dispatch call<p>The rest seems accurate.</div><br/><div id="36754808" class="c"><input type="checkbox" id="c-36754808" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36752858">parent</a><span>|</span><a href="#36755238">next</a><span>|</span><label class="collapse" for="c-36754808">[-]</label><label class="expand" for="c-36754808">[1 more]</label></div><br/><div class="children"><div class="content">That is what I hate on Khronos APIs, it is almost a rite of passage into adulthood to create our own mini-engine on top of their APIs to make them usable.<p>I already have my toolbox, but that doesn&#x27;t mean I am fine with them being like that.</div><br/></div></div><div id="36755238" class="c"><input type="checkbox" id="c-36755238" checked=""/><div class="controls bullet"><span class="by">pythops</span><span>|</span><a href="#36752858">parent</a><span>|</span><a href="#36754808">prev</a><span>|</span><a href="#36753037">next</a><span>|</span><label class="collapse" for="c-36755238">[-]</label><label class="expand" for="c-36755238">[4 more]</label></div><br/><div class="children"><div class="content">if you any suggestion about articles to read about wgpu plz share. I kind of struggle to find good articles with good examples for beginners to get started with wgpu</div><br/><div id="36755524" class="c"><input type="checkbox" id="c-36755524" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36752858">root</a><span>|</span><a href="#36755238">parent</a><span>|</span><a href="#36755373">next</a><span>|</span><label class="collapse" for="c-36755524">[-]</label><label class="expand" for="c-36755524">[2 more]</label></div><br/><div class="children"><div class="content">Have you already been here?<p><a href="https:&#x2F;&#x2F;webgpufundamentals.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;webgpufundamentals.org&#x2F;</a><p><a href="https:&#x2F;&#x2F;webgpu.github.io&#x2F;webgpu-samples" rel="nofollow noreferrer">https:&#x2F;&#x2F;webgpu.github.io&#x2F;webgpu-samples</a></div><br/><div id="36755590" class="c"><input type="checkbox" id="c-36755590" checked=""/><div class="controls bullet"><span class="by">pythops</span><span>|</span><a href="#36752858">root</a><span>|</span><a href="#36755524">parent</a><span>|</span><a href="#36755373">next</a><span>|</span><label class="collapse" for="c-36755590">[-]</label><label class="expand" for="c-36755590">[1 more]</label></div><br/><div class="children"><div class="content">Thanks so much
This one <a href="https:&#x2F;&#x2F;webgpufundamentals.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;webgpufundamentals.org&#x2F;</a> is amzing</div><br/></div></div></div></div><div id="36755373" class="c"><input type="checkbox" id="c-36755373" checked=""/><div class="controls bullet"><span class="by">dezmou</span><span>|</span><a href="#36752858">root</a><span>|</span><a href="#36755238">parent</a><span>|</span><a href="#36755524">prev</a><span>|</span><a href="#36753037">next</a><span>|</span><label class="collapse" for="c-36755373">[-]</label><label class="expand" for="c-36755373">[1 more]</label></div><br/><div class="children"><div class="content">I find chatGPT 4 quite usefull for this, even if he may does some mistake, it can generate little examples and explain all lines</div><br/></div></div></div></div><div id="36753037" class="c"><input type="checkbox" id="c-36753037" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#36752858">parent</a><span>|</span><a href="#36755238">prev</a><span>|</span><a href="#36755405">next</a><span>|</span><label class="collapse" for="c-36753037">[-]</label><label class="expand" for="c-36753037">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate more on this? It seems interesting<p>&gt; if you are using gl.enable(gl.BLEND) in your core render loop, you have basically already failed.</div><br/><div id="36755427" class="c"><input type="checkbox" id="c-36755427" checked=""/><div class="controls bullet"><span class="by">tim1994</span><span>|</span><a href="#36752858">root</a><span>|</span><a href="#36753037">parent</a><span>|</span><a href="#36755405">next</a><span>|</span><label class="collapse" for="c-36755427">[-]</label><label class="expand" for="c-36755427">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also be interested in details on this but I assume the gl.enable() API changes fundamental things about the rendering pipeline. It allows enabling things like depth testing and stencil (both involve an extra buffer) and face culling (additional tests after vertex shader). For blending in particular I think it requires the fragment shader to first read the previous value from the frame buffer.
Changes this stuff is probably not a trivial operation and requires a lot of communication with the GPU which is slow (just a guess).<p>If you want to change blending for each draw call you can change the blending function or just return suitable alpha values from the fragment shader.</div><br/></div></div></div></div></div></div><div id="36755405" class="c"><input type="checkbox" id="c-36755405" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#36752858">prev</a><span>|</span><a href="#36752443">next</a><span>|</span><label class="collapse" for="c-36755405">[-]</label><label class="expand" for="c-36755405">[3 more]</label></div><br/><div class="children"><div class="content">My disappointment with WebGPU has been limited data type support. I wanted to write some compute stuff with it, but the limitation of not supporting a lot of integer sizes made it undesirable.<p>Does anyone know if the spec is likely to be revised to add more support over time?</div><br/><div id="36755436" class="c"><input type="checkbox" id="c-36755436" checked=""/><div class="controls bullet"><span class="by">dezmou</span><span>|</span><a href="#36755405">parent</a><span>|</span><a href="#36755532">next</a><span>|</span><label class="collapse" for="c-36755436">[-]</label><label class="expand" for="c-36755436">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;issues&#x2F;3620">https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;issues&#x2F;3620</a></div><br/></div></div><div id="36755532" class="c"><input type="checkbox" id="c-36755532" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36755405">parent</a><span>|</span><a href="#36755436">prev</a><span>|</span><a href="#36752443">next</a><span>|</span><label class="collapse" for="c-36755532">[-]</label><label class="expand" for="c-36755532">[1 more]</label></div><br/><div class="children"><div class="content">Eventually, but expect a progression rate measured in years.</div><br/></div></div></div></div><div id="36752443" class="c"><input type="checkbox" id="c-36752443" checked=""/><div class="controls bullet"><span class="by">xyhhx</span><span>|</span><a href="#36755405">prev</a><span>|</span><a href="#36752712">next</a><span>|</span><label class="collapse" for="c-36752443">[-]</label><label class="expand" for="c-36752443">[2 more]</label></div><br/><div class="children"><div class="content">can&#x27;t wait to see what exciting new exploits are in store for us with this</div><br/><div id="36755312" class="c"><input type="checkbox" id="c-36755312" checked=""/><div class="controls bullet"><span class="by">dezmou</span><span>|</span><a href="#36752443">parent</a><span>|</span><a href="#36752712">next</a><span>|</span><label class="collapse" for="c-36755312">[-]</label><label class="expand" for="c-36755312">[1 more]</label></div><br/><div class="children"><div class="content">Bitcoin mining gro brrrr
<a href="https:&#x2F;&#x2F;github.com&#x2F;dezmou&#x2F;SHA256-WebGPU">https:&#x2F;&#x2F;github.com&#x2F;dezmou&#x2F;SHA256-WebGPU</a></div><br/></div></div></div></div><div id="36752712" class="c"><input type="checkbox" id="c-36752712" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#36752443">prev</a><span>|</span><label class="collapse" for="c-36752712">[-]</label><label class="expand" for="c-36752712">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The most popular of the next-gen GPU APIs are Vulkan by the Khronos Group, Metal by Apple and DirectX 12 by Microsoft. ... (WebGPU) introduces its own abstractions and doesn’t directly mirror any of these native APIs.<p>Huh. I was wondering about that.<p>Until now I just figured every &quot;Web*&quot; thing was browsers exposing (to JS alone) something that they already compiled in:<p>- WebRTC is ffmpeg<p>- Canvas is Skia<p>- WebGL is ANGLE<p>- WebCodecs is also ffmpeg<p>- WebTransport is QUIC<p>- WebSockets are TCP<p>I might be wrong on some of those.</div><br/><div id="36752821" class="c"><input type="checkbox" id="c-36752821" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36752712">parent</a><span>|</span><a href="#36752845">next</a><span>|</span><label class="collapse" for="c-36752821">[-]</label><label class="expand" for="c-36752821">[5 more]</label></div><br/><div class="children"><div class="content">I think all of these are wrong.<p>&gt; WebRTC is ffmpeg<p>No. WebRTC is a transport protocol for media communications.<p>&gt; Canvas is Skia<p>Skia is a graphics engine you can build a Canvas implementation on top of<p>&gt; WebGL is ANGLE<p>I don&#x27;t know what ANGLE is, but WebGL is based on OpenGL. As this article says &quot;WebGL’s API is really just OpenGL ES 2.0&quot;<p>&gt; WebCodecs is also ffmpeg<p>Both allow conceptually similar things (low level access to specific parts of a media stream). But the APIs are dramatically different.<p>&gt; WebTransport is QUIC<p>No it is an API to expose lower level parts of HTTP&#x2F;3 to developers. HTTP&#x2F;3 uses QUIC as a transport protocol, but it is very wrong to say it &quot;is&quot; QUIC.<p>&gt; WebSockets are TCP<p>Well WebSockets is built on top of TCP. As is HTTP&#x2F;1 and HTTP&#x2F;2. (HTTP&#x2F;3 uses UDP via QUIC)</div><br/><div id="36753620" class="c"><input type="checkbox" id="c-36753620" checked=""/><div class="controls bullet"><span class="by">still_grokking</span><span>|</span><a href="#36752712">root</a><span>|</span><a href="#36752821">parent</a><span>|</span><a href="#36753022">next</a><span>|</span><label class="collapse" for="c-36753620">[-]</label><label class="expand" for="c-36753620">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; WebTransport is QUIC<p>&gt; No it is an API to expose lower level parts of HTTP&#x2F;3 to developers. HTTP&#x2F;3 uses QUIC as a transport protocol, but it is very wrong to say it &quot;is&quot; QUIC.<p>Well, that&#x27;s the only thing the parent got <i>almost</i> right. (The rest was obvious nonsense, though. I agree.)<p>WebTransport is of course not QUIC. But it allows to <i>use</i> QUIC streams <i>almost directly</i>.<p>There are no &quot;lower parts&quot; of HTTP&#x2F;3 other than QUIC. HTTP&#x2F;3 is a quite thin layer directly atop of QUIC.<p>With WebTransport you send a CONNECT request with some special flags &#x2F; headers to the web server and given a correct response you can start using raw QUIC streams over your HTTP&#x2F;3 QUIC connection.<p>The overhead to get at your raw QUIC streams is quite low and a one time thing. From there you can directly use all the capabilities QUIC gives you (client or server initiated reliable unidirectional and bidirectional data streams or unreliable datagrams transporting arbitrary binary messages over a kind of &quot;virtual&quot; connection).</div><br/><div id="36755544" class="c"><input type="checkbox" id="c-36755544" checked=""/><div class="controls bullet"><span class="by">CMCDragonkai</span><span>|</span><a href="#36752712">root</a><span>|</span><a href="#36753620">parent</a><span>|</span><a href="#36753022">next</a><span>|</span><label class="collapse" for="c-36755544">[-]</label><label class="expand" for="c-36755544">[1 more]</label></div><br/><div class="children"><div class="content">I was looking into this but are you sure web transport will expose bidirectional binary quic streams and datagrams to the browser? If so please link so I can start hacking!</div><br/></div></div></div></div><div id="36753022" class="c"><input type="checkbox" id="c-36753022" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#36752712">root</a><span>|</span><a href="#36752821">parent</a><span>|</span><a href="#36753620">prev</a><span>|</span><a href="#36752845">next</a><span>|</span><label class="collapse" for="c-36753022">[-]</label><label class="expand" for="c-36753022">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know what ANGLE is, but WebGL is based on OpenGL. As this article says &quot;WebGL’s API is really just OpenGL ES 2.0&quot;<p>I believe that ANGLE is a library that is widely used to implement WebGL by translating OpenGL ES calls into Direct 3D calls: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ANGLE_(software)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ANGLE_(software)</a></div><br/><div id="36753099" class="c"><input type="checkbox" id="c-36753099" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36752712">root</a><span>|</span><a href="#36753022">parent</a><span>|</span><a href="#36752845">next</a><span>|</span><label class="collapse" for="c-36753099">[-]</label><label class="expand" for="c-36753099">[1 more]</label></div><br/><div class="children"><div class="content">The OP seems to be confusing the concept of API and library layering with the idea that something <i>is</i> something else.<p>To be clear: in software almost everything is built on top of other things using libraries. This doesn&#x27;t mean the new thing that is built <i>is</i> that thing at all, and indeed that new thing may be able to switch out the lower level library for a different implementation.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>