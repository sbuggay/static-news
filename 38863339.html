<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704358854790" as="style"/><link rel="stylesheet" href="styles.css?v=1704358854790"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lamport.azurewebsites.net/tla/science.pdf">A Science of Concurrent Programs [pdf]</a>Â <span class="domain">(<a href="https://lamport.azurewebsites.net">lamport.azurewebsites.net</a>)</span></div><div class="subtext"><span>paulolc</span> | <span>16 comments</span></div><br/><div><div id="38864518" class="c"><input type="checkbox" id="c-38864518" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38863847">next</a><span>|</span><label class="collapse" for="c-38864518">[-]</label><label class="expand" for="c-38864518">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s appropriate that this is appearing at the death of Niklaus_Wirth. He really was the first to get serious about formalizing concurrency. P and V, and all that.<p>This feels very retro. I used to work on this sort of thing, but that was back in the early 1980s. This reads like something from back then, when people were first figuring out how to think about concurrency.[1] That&#x27;s how people thought about this back then.<p>There&#x27;s been progress in the last four decades. There are completely different approaches, such as symbolic execution. The Microsoft Static Driver Verifier is an example. There&#x27;s also a theory of eventually-consistent systems now, with conflict-free replicated data types. It&#x27;s also more common today to think about concurrency in terms of messages rather than variable access, which is easier to reason about. There&#x27;s also more of a handle on the tooling problem. Not enough of a handle, though. Proof of correctness software still hasn&#x27;t really gone mainstream. (In IC design, though...)<p>There&#x27;s a tendency in this area to fall in love with the notation and formalism, rather than viewing it as a means for making better software. In practice, most of the things you need to prove in program proving are trivial, and have to be mechanized or you never get anything done. Once in a while, a theoretically difficult problem shows up. You need some way to address those abstractly and feed the results back into the semi-automated system.<p>The main concurrent problem addressed in this paper is the Paxos algorithm. That&#x27;s similar to the earlier arbiter problem.[2] The arbiter problem is also about resolving who wins access to a shared resource in a parallel system. It&#x27;s down at the hardware level, where two processors talk to one memory, and has to be resolved in nanoseconds or less. There&#x27;s no sound way to select a winner in one round. But, for each round, you can tell if the algorithm has settled and produced a winner. You have to iterate until it settles. There&#x27;s no upper bound on how many rounds it takes, but it is statistically unlikely for it to take very many. Arbiters were the first hardware device to have that property, and it was very upsetting at the time. Multiprocessor computers were built before the arbiter problem was solved, and they did indeed have hardware race conditions on access to memory. I used to debug operating systems for those things, and we did get crashes from that.<p>Good to see someone is still plugging away on the classics.<p>[1] <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;manualzilla-id-5928072&#x2F;mode&#x2F;2up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;manualzilla-id-5928072&#x2F;mode&#x2F;2up</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arbiter_%28electronics%29" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arbiter_%28electronics%29</a></div><br/><div id="38864717" class="c"><input type="checkbox" id="c-38864717" checked=""/><div class="controls bullet"><span class="by">tkhattra</span><span>|</span><a href="#38864518">parent</a><span>|</span><a href="#38863847">next</a><span>|</span><label class="collapse" for="c-38864717">[-]</label><label class="expand" for="c-38864717">[1 more]</label></div><br/><div class="children"><div class="content">&gt; He really was the first to get serious about formalizing concurrency. P and V, and all that.<p>The computer science of concurrency began with Dijkstra, not Wirth. And it was Dijkstra who introduced the P and V semaphore operations [1].<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD01xx&#x2F;EWD123.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD01xx&#x2F;E...</a></div><br/></div></div></div></div><div id="38863847" class="c"><input type="checkbox" id="c-38863847" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#38864518">prev</a><span>|</span><a href="#38864617">next</a><span>|</span><label class="collapse" for="c-38863847">[-]</label><label class="expand" for="c-38863847">[2 more]</label></div><br/><div class="children"><div class="content">Section 1.2 has an essential warning for many Hacker News readers!<p>&quot;You probably belong to one of two classes of people who I will call scientists and engineers. Scientists are computer scientists who are interested in concurrent computing. If you are a scientist, you should be well-prepared to decide if this book interests you and to read it if it does.<p>&quot;Engineers are people involved in building concurrent programs. If you are an engineer, you might have a job title such as programmer, software engineer, or hardware designer. I need to warn you that this book is about a science, not about its practical application. Practice is discussed only to explain the motivation for the science. If you are interested just in using the science, you should read about the language TLA+ and its tools, which are the practical embodiment of the science [27, 34]. But if you want to understand the underlying science, then this book may be for you.&quot;</div><br/><div id="38864024" class="c"><input type="checkbox" id="c-38864024" checked=""/><div class="controls bullet"><span class="by">maweki</span><span>|</span><a href="#38863847">parent</a><span>|</span><a href="#38864617">next</a><span>|</span><label class="collapse" for="c-38864024">[-]</label><label class="expand" for="c-38864024">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a line between the discovered stuff and the invented stuff. I always love to see it spelled out in different ways.<p>I tell my students that you can <i>understand</i> And rediscover the science part by understanding basic principles, by applying mathematical logic.<p>While the engineering part you need to <i>learn</i>, as the engineering decisions are full of conventions and constraints of the time of invention and the people inventing.<p>But understanding the science and knowing roughly the constraints gets you very far. There are usually only a few superficialities left, like concrete syntax, that are basically impossible to &quot;understand&quot; and need to be &quot;learned&quot;.</div><br/></div></div></div></div><div id="38864617" class="c"><input type="checkbox" id="c-38864617" checked=""/><div class="controls bullet"><span class="by">librasteve</span><span>|</span><a href="#38863847">prev</a><span>|</span><a href="#38863907">next</a><span>|</span><label class="collapse" for="c-38864617">[-]</label><label class="expand" for="c-38864617">[1 more]</label></div><br/><div class="children"><div class="content">i see Tony Hoare is referenced, but no mention of Bill Roscoe and his bottom<p><a href="https:&#x2F;&#x2F;www.cs.ox.ac.uk&#x2F;people&#x2F;bill.roscoe&#x2F;publications&#x2F;1.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.ox.ac.uk&#x2F;people&#x2F;bill.roscoe&#x2F;publications&#x2F;1.pd...</a></div><br/></div></div><div id="38863907" class="c"><input type="checkbox" id="c-38863907" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#38864617">prev</a><span>|</span><a href="#38864433">next</a><span>|</span><label class="collapse" for="c-38863907">[-]</label><label class="expand" for="c-38863907">[1 more]</label></div><br/><div class="children"><div class="content">Also from Leslie Lamport is this amusing course on TLA+ which is a good intro into Formal Specifications.<p><a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;tla.html" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;tla.html</a></div><br/></div></div><div id="38864433" class="c"><input type="checkbox" id="c-38864433" checked=""/><div class="controls bullet"><span class="by">mirzap</span><span>|</span><a href="#38863907">prev</a><span>|</span><a href="#38863340">next</a><span>|</span><label class="collapse" for="c-38864433">[-]</label><label class="expand" for="c-38864433">[1 more]</label></div><br/><div class="children"><div class="content">Posted yesterday:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38859393">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38859393</a></div><br/></div></div><div id="38863340" class="c"><input type="checkbox" id="c-38863340" checked=""/><div class="controls bullet"><span class="by">paulolc</span><span>|</span><a href="#38864433">prev</a><span>|</span><a href="#38864075">next</a><span>|</span><label class="collapse" for="c-38863340">[-]</label><label class="expand" for="c-38863340">[7 more]</label></div><br/><div class="children"><div class="content">This is Science. Computer Science. From one of the greatest alive.<p>&quot;This is a preliminary version of a book. If you have any comments to make or questions to ask about it, please contact
me by email. But when you do, include the version date.
I expect there are many minor errors in this version. (I
hope there are no major ones.) Anyone who is the first to
report any error will be thanked in the book. If you find an
error, please include in your email your name as you wish it
to appear as well as the version date.&quot;</div><br/><div id="38863645" class="c"><input type="checkbox" id="c-38863645" checked=""/><div class="controls bullet"><span class="by">fithisux</span><span>|</span><a href="#38863340">parent</a><span>|</span><a href="#38864075">next</a><span>|</span><label class="collapse" for="c-38863645">[-]</label><label class="expand" for="c-38863645">[6 more]</label></div><br/><div class="children"><div class="content">People often mistake software engineering, or IT with computer science.<p>Those are not science.</div><br/><div id="38864004" class="c"><input type="checkbox" id="c-38864004" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#38863340">root</a><span>|</span><a href="#38863645">parent</a><span>|</span><a href="#38864075">next</a><span>|</span><label class="collapse" for="c-38864004">[-]</label><label class="expand" for="c-38864004">[5 more]</label></div><br/><div class="children"><div class="content">Is computer science even science? It feels like we should have called ourselves computationally-applied mathematicians.</div><br/><div id="38864409" class="c"><input type="checkbox" id="c-38864409" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38863340">root</a><span>|</span><a href="#38864004">parent</a><span>|</span><a href="#38864434">next</a><span>|</span><label class="collapse" for="c-38864409">[-]</label><label class="expand" for="c-38864409">[1 more]</label></div><br/><div class="children"><div class="content">It is a side effect on how it is called in US and some other english speaking coutries I guess.<p>What people in US call computer science, in Portugal is a math degree major, mostly called something like Computing Applied Maths.<p>Computer related degrees are called Informatics Engineering, where computer science subjects are mixed with software engineering content, the degree is certficied by Engineerings Order, and is protected professional title.<p>Or you have Business Informatics, more tailored to current software being used in companies with little theory, more focused in management stuff.</div><br/></div></div><div id="38864434" class="c"><input type="checkbox" id="c-38864434" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#38863340">root</a><span>|</span><a href="#38864004">parent</a><span>|</span><a href="#38864409">prev</a><span>|</span><a href="#38864276">next</a><span>|</span><label class="collapse" for="c-38864434">[-]</label><label class="expand" for="c-38864434">[1 more]</label></div><br/><div class="children"><div class="content">I like to call it non-material science :) Sure call it math, but studying information and computation gets into what is logically or combinatorically possible, the nature of chaos and symmetry. not just a little system of manmade manipulable symbols.</div><br/></div></div><div id="38864276" class="c"><input type="checkbox" id="c-38864276" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#38863340">root</a><span>|</span><a href="#38864004">parent</a><span>|</span><a href="#38864434">prev</a><span>|</span><a href="#38864075">next</a><span>|</span><label class="collapse" for="c-38864276">[-]</label><label class="expand" for="c-38864276">[2 more]</label></div><br/><div class="children"><div class="content">Itâs as much a science as mathematical physics, I would suppose? You can make predictions (scaling of an algorithm, correctness of a concurrent algorithm) and test them empirically.<p>Some people might call pure math a âscienceâ, but this is at the very least applied math (ie more connected to physical reality than pure math).</div><br/><div id="38864317" class="c"><input type="checkbox" id="c-38864317" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#38863340">root</a><span>|</span><a href="#38864276">parent</a><span>|</span><a href="#38864075">next</a><span>|</span><label class="collapse" for="c-38864317">[-]</label><label class="expand" for="c-38864317">[1 more]</label></div><br/><div class="children"><div class="content">You could, but this book doesn&#x27;t, as far as I&#x27;ve skimmed.<p>It even makes the case as to why not:<p>&gt; This usually means that there are an enormous number of possible executions, and testing can examine only a tiny fraction of them.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38864075" class="c"><input type="checkbox" id="c-38864075" checked=""/><div class="controls bullet"><span class="by">petters</span><span>|</span><a href="#38863340">prev</a><span>|</span><label class="collapse" for="c-38864075">[-]</label><label class="expand" for="c-38864075">[1 more]</label></div><br/><div class="children"><div class="content">âThis is not the place for modesty. I was very good at concurrency.â Agreed!</div><br/></div></div></div></div></div></div></div></body></html>