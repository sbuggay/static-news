<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697792455735" as="style"/><link rel="stylesheet" href="styles.css?v=1697792455735"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://flak.tedunangst.com/post/bango">Banging errors in Go</a> <span class="domain">(<a href="https://flak.tedunangst.com">flak.tedunangst.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>226 comments</span></div><br/><div><div id="37949032" class="c"><input type="checkbox" id="c-37949032" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#37949024">next</a><span>|</span><label class="collapse" for="c-37949032">[-]</label><label class="expand" for="c-37949032">[119 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure I&#x27;m in a very tiny minority, but I kinda like having errors as values - I prefer having errors be things that are part of the normal control flow of my code, and that can be handled explicitly within an if block (which may start simple but can and does evolve to wrap details, log and skip, fallback to an alternative, etc.)<p>Yes it means errors shows up everywhere in your code - the same types of errors are something all languages have to deal with, just accept our faulty reality for what it is and have the discipline to account for it.</div><br/><div id="37949133" class="c"><input type="checkbox" id="c-37949133" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37950694">next</a><span>|</span><label class="collapse" for="c-37949133">[-]</label><label class="expand" for="c-37949133">[67 more]</label></div><br/><div class="children"><div class="content">Most Go criticism I&#x27;ve seen on error handling has been “if you are going to use errors-as-values, sum types and pattern matching were the well established approach to that when Go was created and multivalued returns when only one value is usually going to be meaningful at a time is both logically and ergonomically worse” not “don&#x27;t use errors as values”.</div><br/><div id="37952481" class="c"><input type="checkbox" id="c-37952481" checked=""/><div class="controls bullet"><span class="by">015a</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949133">parent</a><span>|</span><a href="#37950632">next</a><span>|</span><label class="collapse" for="c-37952481">[-]</label><label class="expand" for="c-37952481">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll use this opportunity to share my <i>personal</i> criticism on Go error handling; this right here.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;WbGeW8wSu0X" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;WbGeW8wSu0X</a><p>(Ignore the obvious SQL injection issues in that query, thx :)<p>It takes a lot to make me mad, but this inane behavior manages it. This behavior, <i>singularly</i>, makes it nearly impossible to achieve higher levels of ergonomic safety on the types of errors functions can return. You basically always have to just return the `error` type, and require callers to do runtime reflection.<p>And this can rear its ugly head <i>all</i> the time. You&#x27;ve got deep functions that are super specific and know exactly what kinds of errors they can return. You&#x27;ve got higher-layered functions that call lots of things that all return different error types, so those may just return `error`. Turns out; they all just have to return `error`, because if you make them more specific, at the freakin TYPE DEFINITION, a segment of the syntax that other sane languages would say is &quot;compiled away&quot; and &quot;not relevant to runtime behavior&quot;, you lose any ability to guarantee nil comparisons will work the way higher-level callers expect.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;fb0e_4loDBf" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;fb0e_4loDBf</a><p>Its a problem in any situation where a function broadens the type of a struct pointer its returning to an interface. Its just most commonly encountered with errors, because you can&#x27;t just return `DatabaseError` there, because the zero-value is non-nil and everyone checks errors with `if err != nil`.<p>The internal Go style guide of a billion dollar tech company every single person reading this has heard of reads: Never return pointers to structs designed to be used as errors. Its a significant, real problem. Its antithetical to any reasonable understanding of how this code should work. Its antithetical to even <i>unreasonable</i> understandings. Blog posts which explain it start with &quot;this makes sense when you understand how reflection works on interface-fulfilling pointer values&quot; then launch into a twenty paragraph graduate thesis as if Go wasn&#x27;t <i>explicitly</i> designed to help fresh-out-of-college engineers write productive and performant code for Google.<p>I like Go; but their recent statement that Go will never break backward compatibility genuinely scares me because I&#x27;m not sure they can fix this without breaking existing code; which means it may never get fixed. I&#x27;m doubtful the designers even consider it a bug. Just... ugh.</div><br/><div id="37953310" class="c"><input type="checkbox" id="c-37953310" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952481">parent</a><span>|</span><a href="#37953598">next</a><span>|</span><label class="collapse" for="c-37953310">[-]</label><label class="expand" for="c-37953310">[1 more]</label></div><br/><div class="children"><div class="content">Pointer to struct is not equivalent to an interface. You&#x27;re not supposed to return your custom error-like struct pointers from functions - you&#x27;re supposed to return an &quot;error&quot; interface. Just change the &quot;QueryDatabase&quot; to return &quot;(string, error)&quot; and your whole problem will disappear: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;fb0e_4loDBf" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;fb0e_4loDBf</a><p>This is a common mistake when coming from exception-based-error-handling languages where exceptions are differentiated by type. In Go, if you want a more granular distinction between different kinds of errors, you don&#x27;t use types, you use values: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;ddzhAqRgK_1" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;ddzhAqRgK_1</a><p>If you <i>insist</i> on using the typesystem for granular error checking, then you can define an &quot;Is(target error) bool&quot; method on your custom type to differentiate in the same way: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;gZmYgOq6wSo" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;gZmYgOq6wSo</a></div><br/></div></div><div id="37952814" class="c"><input type="checkbox" id="c-37952814" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952481">parent</a><span>|</span><a href="#37953598">prev</a><span>|</span><a href="#37952520">next</a><span>|</span><label class="collapse" for="c-37952814">[-]</label><label class="expand" for="c-37952814">[2 more]</label></div><br/><div class="children"><div class="content">Could someone explain what&#x27;s happening here? What on Earth is Go doing?</div><br/><div id="37953283" class="c"><input type="checkbox" id="c-37953283" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952814">parent</a><span>|</span><a href="#37952520">next</a><span>|</span><label class="collapse" for="c-37953283">[-]</label><label class="expand" for="c-37953283">[1 more]</label></div><br/><div class="children"><div class="content">Short explanation: a nil pointer to a struct that implements an interfaces is a valid non-nil value of that interface.<p>---<p>Long explanation:<p>In Go, &quot;error&quot; is an interface - i.e. a type that has an &quot;Error() string&quot; method defined on it.<p>The custom defined struct, &quot;DatabaseError&quot; is not an interface - it&#x27;s a struct, and it has an &quot;Error() string&quot; defined on it. Therefore, any value of &quot;DatabaseError&quot; (or &quot;*DatabaseError&quot;) type fulfills the &quot;error&quot; interface, and can be cast to a non-nil &quot;error&quot;. Even the nil pointer to &quot;DatabaseError&quot; - you can call methods on a nil pointer, therefore it&#x27;s a valid non-nil interface.<p>The problem in the code is the implicit cast of &quot;*DatabaseError&quot; struct into the &quot;error&quot; interface in line 21., which assumes that nil pointer is the same as nil interface. It isn&#x27;t. The solution is either to 1) return &quot;error&quot; instead of &quot;*DatabaseError&quot; in &quot;QueryDatabase&quot; (<a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;fb0e_4loDBf" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;fb0e_4loDBf</a>), or 2) to explicitly check the return value of &quot;QueryDatabase&quot; for nil pointer before cast (<a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;TgikAk1mSn0" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;TgikAk1mSn0</a>).<p>I prefer the former approach, because even if you&#x27;re free to write your own &quot;error&quot; interface implementation, you&#x27;re still supposed to use it through the &quot;error&quot; interface, not the struct pointer directly. Interface is more than just a struct pointer.<p>P.S.<p>As I explained in the other comment, the intention of the original comment is to differentiate between kinds of errors through the type system. That&#x27;s not the Go way - Go avoids type hierarchies as much as possible. The proper way to differentiate errors in Go is through values: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;ddzhAqRgK_1" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;ddzhAqRgK_1</a><p>Or, if the user insists on having a error type hierarchy, define a custom &quot;Is(target error) bool&quot; method on each custom error type: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;gZmYgOq6wSo" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;gZmYgOq6wSo</a></div><br/></div></div></div></div><div id="37952520" class="c"><input type="checkbox" id="c-37952520" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952481">parent</a><span>|</span><a href="#37952814">prev</a><span>|</span><a href="#37950632">next</a><span>|</span><label class="collapse" for="c-37952520">[-]</label><label class="expand" for="c-37952520">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Its a significant, real problem.</i><p>It&#x27;s a contrived problem, at least. In reality, your code is going to look more like:<p><pre><code>    func GetUserByID(id string) (string, error) {
        s, err := QueryDatabase(fmt.Sprintf(&quot;select * from users where id = %v&quot;, id))
        if err != nil {
            &#x2F;&#x2F; Do something with the error, returning a new error if necessary.
            return &quot;&quot;, someNewErr
        }
        return s, nil
    }
</code></pre>
The callers of GetUserByID have absolutely no concern for the implementation details of QueryDatabase. When requirements change and you replace QueryDatabase with QueryWebService, callers expect to still get the <i>same</i> errors back, not HTTP errors all of a sudden when the code was previously getting MySQL errors. That would be plain horrible API design. So, you wouldn&#x27;t actually ever encounter this particular issue in practice (assuming nobody hates you).</div><br/><div id="37952600" class="c"><input type="checkbox" id="c-37952600" checked=""/><div class="controls bullet"><span class="by">015a</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952520">parent</a><span>|</span><a href="#37952811">next</a><span>|</span><label class="collapse" for="c-37952600">[-]</label><label class="expand" for="c-37952600">[3 more]</label></div><br/><div class="children"><div class="content">Sure; the higher-order callers <i>should</i> do that. I love wrapping errors.<p>But the issue is that the <i>source</i> of the problem is in lower-level code which made the theoretically correct decision to be specific what you return and generic in what you accept. That lower-level code cannot guarantee that its higher-order callers will wrap the errors it returns. So; the lower-level code has to remain generic.<p>Obviously my example is contrived; but the problem is not. It is allowed, but essentially never safe to communicate to the compiler the error types your function returns. Its ok to <i>use</i> custom error types; you just can&#x27;t tell the compiler about them. This is a problem that is <i>so deep</i> in the language it has influenced how error types and functions are designed in the standard library. I&#x27;m aware of one production outage related to this problem (yeah yeah, blame bad reviews and bad testing, I get it, it still happened). I&#x27;ve caught it a dozen times in code reviews (especially after that happened).<p>Its a real problem. People don&#x27;t write perfect code.</div><br/><div id="37952769" class="c"><input type="checkbox" id="c-37952769" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952600">parent</a><span>|</span><a href="#37952811">next</a><span>|</span><label class="collapse" for="c-37952769">[-]</label><label class="expand" for="c-37952769">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; but essentially never safe to communicate to the compiler the error types your function returns.</i><p>It is safe as long as you don&#x27;t write too much code for no reason. The problem in the example is that DatabaseError needlessly defined an Error method. It serves no purpose other than to allow the issue to arise. Remove said method, which has no reason to exist, and the program will fail to compile.<p><i>&gt; Its a real problem. People don&#x27;t write perfect code.</i><p>Okay, sure. It is possible that a programmer may, for whatever reason, leave out entire blocks of logic that the program needs. Imagine not adding billing logic to your storefront software – I&#x27;m sure it has happened to someone before! Making interfaces more intuitive does not solve that problem, though.</div><br/><div id="37953646" class="c"><input type="checkbox" id="c-37953646" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952769">parent</a><span>|</span><a href="#37952811">next</a><span>|</span><label class="collapse" for="c-37953646">[-]</label><label class="expand" for="c-37953646">[1 more]</label></div><br/><div class="children"><div class="content">Why are you complaining that this person wrote a clear and small example that demonstrates what they are talking about? It is painfully rude; a description and a couple lines of code that runs is the gold standard for starting a programming conversation.</div><br/></div></div></div></div></div></div><div id="37952811" class="c"><input type="checkbox" id="c-37952811" checked=""/><div class="controls bullet"><span class="by">prerok</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952520">parent</a><span>|</span><a href="#37952600">prev</a><span>|</span><a href="#37950632">next</a><span>|</span><label class="collapse" for="c-37952811">[-]</label><label class="expand" for="c-37952811">[1 more]</label></div><br/><div class="children"><div class="content">Hardly a contrived problem, since I know of at least one occurrence where I had issues in production because of it. It was not error handling that was the problem, which is exposed here.<p>The problem was that I had a variable of an interface type and in the code was producing different objects implementing that interface. Now, a nil value was also allowed if none of the cases matched and then the variable was stored in a sync.Map as a value.<p>The problem was that when retriving the value the nil check never matched. Why? Well, it&#x27;s type is defined as the interface even if it doesn&#x27;t point to any implementation.<p>I get that the designers might not have considered a different option: it is allowed to invoke a method on a nil object, making what some languages would call static methods. Still, I agree with the grandparent: I think this is Go&#x27;s biggest flaw, simply because it is so surprising.</div><br/></div></div></div></div></div></div><div id="37950632" class="c"><input type="checkbox" id="c-37950632" checked=""/><div class="controls bullet"><span class="by">pizzafeelsright</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949133">parent</a><span>|</span><a href="#37952481">prev</a><span>|</span><a href="#37949992">next</a><span>|</span><label class="collapse" for="c-37950632">[-]</label><label class="expand" for="c-37950632">[27 more]</label></div><br/><div class="children"><div class="content">My frustration, possibly perhaps how I&#x27;m coding, is wrapping every instruction on an error wrapper and then I&#x27;ve got twenty if not an error do the next thing.<p>I code solo, so I&#x27;m not sure how others do it.<p>The alternative is to have twenty methods?<p>I build a data structure, modify its state in a dozen ways and then return it to the caller.</div><br/><div id="37950834" class="c"><input type="checkbox" id="c-37950834" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950632">parent</a><span>|</span><a href="#37953594">next</a><span>|</span><label class="collapse" for="c-37950834">[-]</label><label class="expand" for="c-37950834">[25 more]</label></div><br/><div class="children"><div class="content">I like Go&#x27;s error handling. Yes, I know that puts me in a special category of coder.<p>Reasons:<p>- It&#x27;s simple and easy to understand. There&#x27;s no hidden complexity, no magic, no gotchas. Nothing is going to surprise me about it.<p>- It&#x27;s a very readable cadence. Do the thing, check the error, do the thing, check the error, do the thing, check the error. Once you get used to the error checks it&#x27;s extremely readable.<p>- Despite all the extra characters the actual mental load of the error checks is tiny. Yes it&#x27;s more typing, but the hard bit about code is thinking not typing, and it doesn&#x27;t make more thinking.<p>- If I have to do something special with the error, it&#x27;s easy. There&#x27;s no incentive to handle this error just like the rest, or ignore it and let the exception handler catch it. If this error needs (for example) extra logging then I can just put it in there for this error check, no hassle.<p>- It&#x27;s pretty much standard across all Go code. If I have to deal with someone else&#x27;s code, I can expect the same cadence, the same simplicity, the same readable pattern of error checks. One of the great things about Go is that it is opinionated about stuff like this.</div><br/><div id="37951266" class="c"><input type="checkbox" id="c-37951266" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950834">parent</a><span>|</span><a href="#37953622">next</a><span>|</span><label class="collapse" for="c-37951266">[-]</label><label class="expand" for="c-37951266">[11 more]</label></div><br/><div class="children"><div class="content">The problem is that it&#x27;s so incredibly inflexible and dated.<p>Many effectful actions e.g. reading from a file system can have a range of different errors each of which you want to handle differently e.g. out of disk space versus lack of permissions.<p>It&#x27;s great that you&#x27;re treating errors as values. But you need pattern matching and other techniques as they make your code more: (a) readable, (b) safer, (c) simpler and (d) less verbose.<p>The hilarious thing is that <i>eventually</i> Go is going to get these because there is nothing but upside. And then at that point you&#x27;re going to wonder how you ever survived without it.</div><br/><div id="37951475" class="c"><input type="checkbox" id="c-37951475" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951266">parent</a><span>|</span><a href="#37951599">next</a><span>|</span><label class="collapse" for="c-37951475">[-]</label><label class="expand" for="c-37951475">[4 more]</label></div><br/><div class="children"><div class="content">&gt; But you need pattern matching and other techniques...<p>The go way to do this would be:<p><pre><code>    switch {
        case errors.Is(err, outOfDiskSpaceError):
        &#x2F;&#x2F; handle out of disk space error
        case errors.Is(err, lackOfPermissionsError):
        &#x2F;&#x2F; handle lack of permissions
        ...
        default:
        &#x2F;&#x2F; do the equivalent of the `_` case in a scala match statement or `t` in a lisp cond
    }
</code></pre>
Which is roughly as readable as scala&#x2F;rust&#x27;s match statements. Moreso if someone tried to get cute in scala and bind both the object as a whole and parts of it at the same time ( something like `case x @ Type(_, _, y, _)` ) or when people get real cute with the unapply method.<p>I mean, I like scala. It&#x27;s fun. But I would never say it&#x27;s more readable than go. I&#x27;ve been left to support things that happen when a team of average intelligence devs get a hold of it.<p>You&#x27;re also really comparing an MIT and New Jersey style solution here, and judging them both on MIT merits. And I don&#x27;t think that&#x27;s exactly a fair argument.</div><br/><div id="37952023" class="c"><input type="checkbox" id="c-37952023" checked=""/><div class="controls bullet"><span class="by">blueberry87</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951475">parent</a><span>|</span><a href="#37951599">next</a><span>|</span><label class="collapse" for="c-37952023">[-]</label><label class="expand" for="c-37952023">[3 more]</label></div><br/><div class="children"><div class="content">Trying to compare a switch statement to proper pattern matching is like comparing a rock to a rocket.</div><br/><div id="37953477" class="c"><input type="checkbox" id="c-37953477" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952023">parent</a><span>|</span><a href="#37952845">next</a><span>|</span><label class="collapse" for="c-37953477">[-]</label><label class="expand" for="c-37953477">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re thinking of C&#x2F;C++ switch statements and everyone that blindly copied them (looking at you Java, JS and PHP), you&#x27;re right, but Go&#x27;s switch is much more flexible (<a href="https:&#x2F;&#x2F;gobyexample.com&#x2F;switch" rel="nofollow noreferrer">https:&#x2F;&#x2F;gobyexample.com&#x2F;switch</a>).<p>PHP tried to correct the mistake of not giving some more thought to the switch statement at the beginning by including a new &quot;match&quot; expression in PHP 8 - fun times for everyone who used classes called &quot;Match&quot;...</div><br/></div></div><div id="37952845" class="c"><input type="checkbox" id="c-37952845" checked=""/><div class="controls bullet"><span class="by">di4na</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952023">parent</a><span>|</span><a href="#37953477">prev</a><span>|</span><a href="#37951599">next</a><span>|</span><label class="collapse" for="c-37952845">[-]</label><label class="expand" for="c-37952845">[1 more]</label></div><br/><div class="children"><div class="content">I am unashamedly stealing this one, it is both apt and making me smile. Kudos</div><br/></div></div></div></div></div></div><div id="37951599" class="c"><input type="checkbox" id="c-37951599" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951266">parent</a><span>|</span><a href="#37951475">prev</a><span>|</span><a href="#37953622">next</a><span>|</span><label class="collapse" for="c-37951599">[-]</label><label class="expand" for="c-37951599">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why pattern matching is seen as more readable, safer or simpler. Why do you think this?</div><br/><div id="37952920" class="c"><input type="checkbox" id="c-37952920" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951599">parent</a><span>|</span><a href="#37951885">next</a><span>|</span><label class="collapse" for="c-37952920">[-]</label><label class="expand" for="c-37952920">[3 more]</label></div><br/><div class="children"><div class="content">Compare:<p><pre><code>    struct BinaryTree {
        leaf_value: int,
        left_child: BinaryTree,
        right_child: BinaryTree
    }

    function sum_leaves(tree: BinaryTree) -&gt; int {
        if tree.left_child != nil {
            return sum_leaves(tree.left_child) + sum_leaves(tree.right_child);
        } else {
            return tree.leaf_value;
        }
    }
</code></pre>
vs:<p><pre><code>    enum BinaryTree {
        Leaf(int),
        Branch(BinaryTree, BinaryTree)
    }

    function sum_leaves(tree: BinaryTree) -&gt; int {
        match tree {
            Leaf(leaf) =&gt; leaf,
            Branch(left, right) =&gt; sum_leaves(left) + sum_leaves(right)
        }
    }
</code></pre>
(If you&#x27;re thinking &quot;the first example should be using inheritance + polymorphism&quot;, imagine that &quot;BinaryTree&quot; is in a different library than &quot;sum_leaves&quot;. If you&#x27;re now thinking &quot;visitor pattern&quot;, sure, go write your hundreds of lines of boilerplate code if you like.)<p>The first example is less safe because it&#x27;s filled with invariants: left_child is nil iff right_child is nil, and leaf_value should only be accessed when they&#x27;re nil. The second example has zero invariants. (You might think there would be an invariant that the children <i>aren&#x27;t</i> nil, but languages with pattern matching tend to use Optional instead of nil, so that invariant isn&#x27;t necessary.) If you make mistakes about when you access various fields in the first example, you&#x27;ll be accessing leaf_value when it&#x27;s uninitialized, or get a null dereference from one of the pointers.<p>As for readability, that&#x27;s in the eye of the beholder, but I find the second example a lot more readable for the same reason: it&#x27;s clear in both the data definition and the use site which fields exist.<p>All sorts of details vary across languages, even with a small example like this, but that&#x27;s the basic differences.</div><br/><div id="37953415" class="c"><input type="checkbox" id="c-37953415" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952920">parent</a><span>|</span><a href="#37953446">next</a><span>|</span><label class="collapse" for="c-37953415">[-]</label><label class="expand" for="c-37953415">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the clarification. I get what you&#x27;re saying, but I wouldn&#x27;t write it like this - I&#x27;d write more code with more checks ;)<p>In terms of errors, though, it&#x27;s generally &quot;the result is either a value and no error, or no value and one of these errors&quot;. I get how sum types would help with this, and I&#x27;m not arguing against that; they would be useful. But the pattern matching basically still has to deal with that outcome, and have a pattern for each error type. It doesn&#x27;t strike me as being inherently safer, more readable, etc.</div><br/></div></div><div id="37953446" class="c"><input type="checkbox" id="c-37953446" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952920">parent</a><span>|</span><a href="#37953415">prev</a><span>|</span><a href="#37951885">next</a><span>|</span><label class="collapse" for="c-37953446">[-]</label><label class="expand" for="c-37953446">[1 more]</label></div><br/><div class="children"><div class="content">In your first example you don’t need the else clause and wouldn’t you clear up a lot of the invariants by checking leaf value (with ‘not a leaf’ appropriately represented) rather than whether there is a left child. Or even representing them with a function call isLeaf.<p>I agree that sum types are lovely and that pattern matching makes them nice to work with but I don’t think you really make the case well here that it’d be superior rather than just personal preference.</div><br/></div></div></div></div><div id="37951885" class="c"><input type="checkbox" id="c-37951885" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951599">parent</a><span>|</span><a href="#37952920">prev</a><span>|</span><a href="#37953622">next</a><span>|</span><label class="collapse" for="c-37951885">[-]</label><label class="expand" for="c-37951885">[2 more]</label></div><br/><div class="children"><div class="content">Pattern matching in Erlang is a brilliant feature. You get concise branching and binding, and if a pattern match fails the native error handling (dramatically less verbose than Go) takes care of things for you (mostly).<p>Much like other FP features, shoehorning pattern matching into a language doesn&#x27;t give you nearly the same advantages as building a language around it, so I don&#x27;t know that it would make Go significantly better.</div><br/><div id="37952019" class="c"><input type="checkbox" id="c-37952019" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951885">parent</a><span>|</span><a href="#37953622">next</a><span>|</span><label class="collapse" for="c-37952019">[-]</label><label class="expand" for="c-37952019">[1 more]</label></div><br/><div class="children"><div class="content">I find it really, really hard to work out which pattern is matching when debugging Erlang. It might be more concise but it&#x27;s massively less readable (and less amenable to reasoning out what might be going wrong). Especially in older code bases that have had a few people work on them.</div><br/></div></div></div></div></div></div></div></div><div id="37953622" class="c"><input type="checkbox" id="c-37953622" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950834">parent</a><span>|</span><a href="#37951266">prev</a><span>|</span><a href="#37951121">next</a><span>|</span><label class="collapse" for="c-37953622">[-]</label><label class="expand" for="c-37953622">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s simple and easy to understand. There&#x27;s no hidden complexity, no magic, no gotchas. Nothing is going to surprise me about it<p>There absolutely are gotchas, exactly because they are not sum types. There are functions where both “slots” are used as return types, when an error occurred.<p>&gt; It&#x27;s a very readable cadence. Do the thing, check the error, do the thing<p>Arguably, you can’t reasonably handle most errors in-place, you just don’t have enough context for that. Also, you want to make your business logic right — all those  verbose, often incorrect&#x2F;naive error handles will just make it harder to read your own logic. Also, very easy to accidentally swallow an error - exceptions&#x2F;sum types are much better in this regard, you <i>can’t</i> not care about them.</div><br/></div></div><div id="37951121" class="c"><input type="checkbox" id="c-37951121" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950834">parent</a><span>|</span><a href="#37953622">prev</a><span>|</span><a href="#37951611">next</a><span>|</span><label class="collapse" for="c-37951121">[-]</label><label class="expand" for="c-37951121">[7 more]</label></div><br/><div class="children"><div class="content">&gt; - Despite all the extra characters the actual mental load of the error checks is tiny. Yes it&#x27;s more typing, but the hard bit about code is thinking not typing, and it doesn&#x27;t make more thinking.<p>The hard part is <i>understanding</i> the existing code. The more cluttered and verbose the code is, the harder that is. Go&#x27;s boilerplate if err != nil return err, nil becomes something that your eyes just skim over - which is fine right up until you have some code that&#x27;s doing something similar but not the same, and don&#x27;t even notice.</div><br/><div id="37953316" class="c"><input type="checkbox" id="c-37953316" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951121">parent</a><span>|</span><a href="#37951586">next</a><span>|</span><label class="collapse" for="c-37953316">[-]</label><label class="expand" for="c-37953316">[3 more]</label></div><br/><div class="children"><div class="content"><i>Go&#x27;s boilerplate if err != nil return err, nil becomes something that your eyes just skim over</i><p>OTOH, if you make sure you do something like<p><pre><code>    if err != nil {
        return fmt.Errorf(&quot;what I was doing when the error happened: %v&quot;, err)
    }
</code></pre>
then you get very precise targeted errors appearing in logs that are much easier to track down and fix than either just returning the error or the usual generic catch block found in other languages.<p>IME properly handled Go errors make for much more maintainable code.</div><br/><div id="37953683" class="c"><input type="checkbox" id="c-37953683" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37953316">parent</a><span>|</span><a href="#37953639">next</a><span>|</span><label class="collapse" for="c-37953683">[-]</label><label class="expand" for="c-37953683">[1 more]</label></div><br/><div class="children"><div class="content">Strong agree. Stack traces are great and all (seriously) but a chain of contextual error messages in developer friendly language is great for understanding what probably went wrong from the error alone.</div><br/></div></div><div id="37953639" class="c"><input type="checkbox" id="c-37953639" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37953316">parent</a><span>|</span><a href="#37953683">prev</a><span>|</span><a href="#37951586">next</a><span>|</span><label class="collapse" for="c-37953639">[-]</label><label class="expand" for="c-37953639">[1 more]</label></div><br/><div class="children"><div class="content">Maybe even include a stacktrace, and you got what any sane language with exceptions had for decades, hurray again for Go!</div><br/></div></div></div></div><div id="37951586" class="c"><input type="checkbox" id="c-37951586" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951121">parent</a><span>|</span><a href="#37953316">prev</a><span>|</span><a href="#37951611">next</a><span>|</span><label class="collapse" for="c-37951586">[-]</label><label class="expand" for="c-37951586">[3 more]</label></div><br/><div class="children"><div class="content">I find that the differences leap out at me. Even just a `err == nil` instead of `err!= nil` is noticeable.<p>I do have to spend a second reading the action if it&#x27;s not just `return result, fmt.Errorf(&quot;failed to do the thing: %w&quot;, err)` but that&#x27;s good, I think.<p>And all of this is way easier than trying to trace up through the stack to the nearest exception handler and work out what it will do with the error<p>edit: also, verbosity doesn&#x27;t make code harder to understand, imho. If anything the other way around. Packing 5 statements into a single line is massively harder to read than separating those same 5 statements into 20 lines with error handlers.</div><br/><div id="37952338" class="c"><input type="checkbox" id="c-37952338" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951586">parent</a><span>|</span><a href="#37951611">next</a><span>|</span><label class="collapse" for="c-37952338">[-]</label><label class="expand" for="c-37952338">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And all of this is way easier than trying to trace up through the stack to the nearest exception handler and work out what it will do with the error<p>You still have to do that part though? Like, this function returns err, so the caller returns err, so the caller of that returns err, ... - you&#x27;ve still got to walk up the stack to the point where the error is actually dealt with.<p>&gt; edit: also, verbosity doesn&#x27;t make code harder to understand, imho. If anything the other way around. Packing 5 statements into a single line is massively harder to read than separating those same 5 statements into 20 lines with error handlers.<p>Very much not my experience. There&#x27;s a huge understandability hit when a function doesn&#x27;t fit on a single screen and you have to scroll, so vertical space is really precious.</div><br/><div id="37952994" class="c"><input type="checkbox" id="c-37952994" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952338">parent</a><span>|</span><a href="#37951611">next</a><span>|</span><label class="collapse" for="c-37952994">[-]</label><label class="expand" for="c-37952994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you&#x27;ve still got to walk up the stack to the point where the error is actually dealt with.<p>This is why we wrap errors. The error message gives a pretty good indication of what the stack was doing when it went wrong.<p>I had a junior dev work with me on some JS. I was writing it in functional style because it made sense at the time. He was really struggling, so I refactored it to old-school imperative and he understood it and was able to work with it. It might have been an issue with the way he was taught JS, but I think it&#x27;s more that tightly-packed concise code is actually harder to parse. Not least because you have to understand the whole thing to work out wtf it&#x27;s doing. Whereas with one-statement-per-line you can scan down to the lines you&#x27;re interested in and focus on those.</div><br/></div></div></div></div></div></div></div></div><div id="37951611" class="c"><input type="checkbox" id="c-37951611" checked=""/><div class="controls bullet"><span class="by">dd82</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950834">parent</a><span>|</span><a href="#37951121">prev</a><span>|</span><a href="#37953594">next</a><span>|</span><label class="collapse" for="c-37951611">[-]</label><label class="expand" for="c-37951611">[5 more]</label></div><br/><div class="children"><div class="content">- Simple and lots of duplicated code.  Golang took DRY overuse and turned it on its head to be dupliate everthing everywhere
- Its duplicated everywhere which means I need to mentally figure whether I need to figure out this path or ignore.  Mental load of typing is small, load of reading is not<p>Golang has alot of good things about it.  This is not one of them and is a wart on the language that is tolerated because the genesis of the language is to be an entirely inverted approach to verbosity than Java.  Its not something to be praised.</div><br/><div id="37951893" class="c"><input type="checkbox" id="c-37951893" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951611">parent</a><span>|</span><a href="#37953594">next</a><span>|</span><label class="collapse" for="c-37951893">[-]</label><label class="expand" for="c-37951893">[4 more]</label></div><br/><div class="children"><div class="content">The mental load of reading a lot of simple code is less than reading a small amount of complex code, I find.<p>It&#x27;s easy to look at a 50-line function with one statement every 5 lines and find the bit I&#x27;m interested in, because it&#x27;s easier to screen out the bits I&#x27;m not interested in. Rather than unentangling a 5-line function that has 10 statements in it, because I have to work out what all of it does in order to understand it and I can&#x27;t focus in on the bit I&#x27;m interested in.</div><br/><div id="37953003" class="c"><input type="checkbox" id="c-37953003" checked=""/><div class="controls bullet"><span class="by">et1337</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951893">parent</a><span>|</span><a href="#37953594">next</a><span>|</span><label class="collapse" for="c-37953003">[-]</label><label class="expand" for="c-37953003">[3 more]</label></div><br/><div class="children"><div class="content">The problem with lots of simple code is now there’s 5,000 slightly different ways of doing the same thing. You end up trying to wrangle it with a mess of code generation and linters.</div><br/><div id="37953428" class="c"><input type="checkbox" id="c-37953428" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37953003">parent</a><span>|</span><a href="#37953594">next</a><span>|</span><label class="collapse" for="c-37953428">[-]</label><label class="expand" for="c-37953428">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, this is something I think feels like a bigger problem than it actually is. If I change the way I&#x27;m handling something, it is a lot of typing. But it&#x27;s just typing. No big deal.</div><br/><div id="37953643" class="c"><input type="checkbox" id="c-37953643" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37953428">parent</a><span>|</span><a href="#37953594">next</a><span>|</span><label class="collapse" for="c-37953643">[-]</label><label class="expand" for="c-37953643">[1 more]</label></div><br/><div class="children"><div class="content">The usual issue isn’t the typing, but the fact that you need to make sure you identified and updated every site correctly.<p>DRY isn’t about reducing LoC</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37953594" class="c"><input type="checkbox" id="c-37953594" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950632">parent</a><span>|</span><a href="#37950834">prev</a><span>|</span><a href="#37949992">next</a><span>|</span><label class="collapse" for="c-37953594">[-]</label><label class="expand" for="c-37953594">[1 more]</label></div><br/><div class="children"><div class="content">Use a sane language instead.</div><br/></div></div></div></div><div id="37949992" class="c"><input type="checkbox" id="c-37949992" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949133">parent</a><span>|</span><a href="#37950632">prev</a><span>|</span><a href="#37950694">next</a><span>|</span><label class="collapse" for="c-37949992">[-]</label><label class="expand" for="c-37949992">[29 more]</label></div><br/><div class="children"><div class="content">Basically - use Rust instead.</div><br/><div id="37950184" class="c"><input type="checkbox" id="c-37950184" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949992">parent</a><span>|</span><a href="#37950026">next</a><span>|</span><label class="collapse" for="c-37950184">[-]</label><label class="expand" for="c-37950184">[6 more]</label></div><br/><div class="children"><div class="content">I know this is a meme, but after writing a lot of Go, and now finally trying out Rust for a new project, I’m quickly coming to this conclusion.</div><br/><div id="37950241" class="c"><input type="checkbox" id="c-37950241" checked=""/><div class="controls bullet"><span class="by">dgunay</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950184">parent</a><span>|</span><a href="#37950026">next</a><span>|</span><label class="collapse" for="c-37950241">[-]</label><label class="expand" for="c-37950241">[5 more]</label></div><br/><div class="children"><div class="content">I love Rust but it is accidentally in the position of trying to serve two disparate camps of people. Developers who just want a modern ML-ish language with good tooling and some actual lessons learned from PL theory, and developers who need near-total control over the hardware but are tired of working with C &amp; C++ and manually solving decades-old problems with memory safety. The former are a very large audience, but have to deal with requirements imposed by the latter which are irrelevant for their use case.</div><br/><div id="37950969" class="c"><input type="checkbox" id="c-37950969" checked=""/><div class="controls bullet"><span class="by">jrop</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950241">parent</a><span>|</span><a href="#37950026">next</a><span>|</span><label class="collapse" for="c-37950969">[-]</label><label class="expand" for="c-37950969">[4 more]</label></div><br/><div class="children"><div class="content">This a million times. I love working with Rust because it&#x27;s - from my point of view - an ML language disguised in C-syntax (with a package manager and unit testing etc. etc). Most of the time I&#x27;d be served well by a GC version of Rust.</div><br/><div id="37953230" class="c"><input type="checkbox" id="c-37953230" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950969">parent</a><span>|</span><a href="#37951241">next</a><span>|</span><label class="collapse" for="c-37953230">[-]</label><label class="expand" for="c-37953230">[1 more]</label></div><br/><div class="children"><div class="content">Same. I wished for this many times. I don&#x27;t need incredibly detailed on-the-metal precision and most of the time, I do not want to think about stack, heap or lifetime parameters. I enjoy the language for its syntax.</div><br/></div></div><div id="37951241" class="c"><input type="checkbox" id="c-37951241" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950969">parent</a><span>|</span><a href="#37953230">prev</a><span>|</span><a href="#37951314">next</a><span>|</span><label class="collapse" for="c-37951241">[-]</label><label class="expand" for="c-37951241">[1 more]</label></div><br/><div class="children"><div class="content">Rust with gc by default and higher kinded traits being sane and supported would be my fave</div><br/></div></div><div id="37951314" class="c"><input type="checkbox" id="c-37951314" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950969">parent</a><span>|</span><a href="#37951241">prev</a><span>|</span><a href="#37950026">next</a><span>|</span><label class="collapse" for="c-37951314">[-]</label><label class="expand" for="c-37951314">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Most of the time I&#x27;d be served well by a GC version of Rust<p>You&#x27;ve just described Scala which inspired many of Rust&#x27;s features.</div><br/></div></div></div></div></div></div></div></div><div id="37950026" class="c"><input type="checkbox" id="c-37950026" checked=""/><div class="controls bullet"><span class="by">danesparza</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949992">parent</a><span>|</span><a href="#37950184">prev</a><span>|</span><a href="#37950503">next</a><span>|</span><label class="collapse" for="c-37950026">[-]</label><label class="expand" for="c-37950026">[19 more]</label></div><br/><div class="children"><div class="content">Why?  This doesn&#x27;t look particularly more or less friendly in Rust than in any other programming language: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-00-error-handling.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-00-error-handling.html</a></div><br/><div id="37950394" class="c"><input type="checkbox" id="c-37950394" checked=""/><div class="controls bullet"><span class="by">ColonelPhantom</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950026">parent</a><span>|</span><a href="#37950849">next</a><span>|</span><label class="collapse" for="c-37950394">[-]</label><label class="expand" for="c-37950394">[11 more]</label></div><br/><div class="children"><div class="content">Aside from the other reply which points out that common idioms have useful shorthands like ?, Rust&#x27;s type system is also error-aware. Rust errors are actual sum types (either Ok(T) or Err(E)), while Go just uses multiple return&#x2F;tuples to return (value, nil) or (nil, error). This means that in Rust, you are forced to handle errors (well, unless you don&#x27;t care about the return value, but then the compiler still gives a warning). This means it is harder to make a mistake with error checking.</div><br/><div id="37950699" class="c"><input type="checkbox" id="c-37950699" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950394">parent</a><span>|</span><a href="#37952696">next</a><span>|</span><label class="collapse" for="c-37950699">[-]</label><label class="expand" for="c-37950699">[9 more]</label></div><br/><div class="children"><div class="content">It also enforces the lack of weird anti patterns like some functions in go that will return a significant value in the first return value while also returning non nil in the error, with a snarky comment in the docs about why this actually makes sense in this case.</div><br/><div id="37950878" class="c"><input type="checkbox" id="c-37950878" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950699">parent</a><span>|</span><a href="#37952696">next</a><span>|</span><label class="collapse" for="c-37950878">[-]</label><label class="expand" for="c-37950878">[8 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t consider this an anti-pattern, but part of the flexibility gained by Go&#x27;s lightweight approach to error handling. I believe Go was even designed with this use case in mind (the standard library uses it in many places, and I don&#x27;t consider their documentation about it &quot;snarky&quot;).<p>Sometimes you want to return a partial result along with an error. Go&#x27;s idiom of returning multiple values, with the final value being an error, allows this situation to be easily supported.</div><br/><div id="37951132" class="c"><input type="checkbox" id="c-37951132" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950878">parent</a><span>|</span><a href="#37950891">next</a><span>|</span><label class="collapse" for="c-37951132">[-]</label><label class="expand" for="c-37951132">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Sometimes you want to return a partial result along with an error.<p>Sometimes you do, and there are types that represents that. Having a single type that is almost always used a certain way but occasionally used subtly differently is a trap waiting to bite you.</div><br/><div id="37952560" class="c"><input type="checkbox" id="c-37952560" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951132">parent</a><span>|</span><a href="#37950891">next</a><span>|</span><label class="collapse" for="c-37952560">[-]</label><label class="expand" for="c-37952560">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Go for almost a decade, and I don&#x27;t recall this ever biting me. It doesn&#x27;t feel like a trap.<p>Go has a convention of documenting each function with a comment (which is adhered to by the standard library, my own code, and any other code I&#x27;d consider worthy of depending on).<p>So when I think this subtlety matters, I check the documentation. Usually I don&#x27;t care either way: When I get a non-nil error, I typically don&#x27;t care about the other result (whether partial or the zero value).<p>The distinction rarely matters in practice (and when it does, the documentation is there). I think this simplicity is the right tradeoff (vs. being burdened with more types to think about).</div><br/><div id="37952839" class="c"><input type="checkbox" id="c-37952839" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952560">parent</a><span>|</span><a href="#37953048">next</a><span>|</span><label class="collapse" for="c-37952839">[-]</label><label class="expand" for="c-37952839">[2 more]</label></div><br/><div class="children"><div class="content">How is a type more of a burden than documentation? You&#x27;re saying that consistent documentation is a good thing, but types enforce more consistency and integrate better with tools.</div><br/><div id="37953356" class="c"><input type="checkbox" id="c-37953356" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952839">parent</a><span>|</span><a href="#37953048">next</a><span>|</span><label class="collapse" for="c-37953356">[-]</label><label class="expand" for="c-37953356">[1 more]</label></div><br/><div class="children"><div class="content">Documentation has immense value beyond just this specific error situation. Its a burden worth taking on regardless of how errors are handled.<p>So it&#x27;s not that a type is <i>more</i> of a burden than documentation, but rather that a type is an <i>additional</i> burden (since we&#x27;re taking on the documentation burden either way).<p>I like that Go&#x27;s error handling is simple enough that I can keep all its rules in my head. And I like that the other parts of Go are simple like that too. It allows me to easily know exactly what is going on at the language level (while my attention is focused on higher levels).</div><br/></div></div></div></div><div id="37953048" class="c"><input type="checkbox" id="c-37953048" checked=""/><div class="controls bullet"><span class="by">et1337</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952560">parent</a><span>|</span><a href="#37952839">prev</a><span>|</span><a href="#37950891">next</a><span>|</span><label class="collapse" for="c-37953048">[-]</label><label class="expand" for="c-37953048">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been bitten by it in production. Whenever I see this partial result pattern, it’s always a function that USUALLY returns nil plus an error. In one special case, it returns a partial result plus an error. This is a nil pointer panic waiting to happen.</div><br/><div id="37953482" class="c"><input type="checkbox" id="c-37953482" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37953048">parent</a><span>|</span><a href="#37950891">next</a><span>|</span><label class="collapse" for="c-37953482">[-]</label><label class="expand" for="c-37953482">[1 more]</label></div><br/><div class="children"><div class="content">The caller can check if the result != nil.<p>If I get a result that came with a non-nil error, and I still plan to do something with the result, then it seems natural to think about the possibility that the result might be nil. I would consult the function&#x27;s documentation, and maybe its source, and then maybe put in a nil check.<p>This is too rare a problem to be worth adding complexity to the language. There needs to be a big payoff for adding complexity. A language gets hard to use if it adds micro-complexities all over the place for the sake of preventing rare programming mistakes.</div><br/></div></div></div></div></div></div></div></div><div id="37950891" class="c"><input type="checkbox" id="c-37950891" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950878">parent</a><span>|</span><a href="#37951132">prev</a><span>|</span><a href="#37952696">next</a><span>|</span><label class="collapse" for="c-37950891">[-]</label><label class="expand" for="c-37950891">[1 more]</label></div><br/><div class="children"><div class="content">Except in the case I&#x27;m talking about, there was a resource to be reclaimed, the GC didn&#x27;t cover it.<p>And if you wanted to do that in rust, that&#x27;s a valid thing too, either as using a tuple instead of a sum type, or a tuple in the Err side of a result.  You can describe what you&#x27;re trying to do simply with the function signature.</div><br/></div></div></div></div></div></div><div id="37952696" class="c"><input type="checkbox" id="c-37952696" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950394">parent</a><span>|</span><a href="#37950699">prev</a><span>|</span><a href="#37950849">next</a><span>|</span><label class="collapse" for="c-37952696">[-]</label><label class="expand" for="c-37952696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust&#x27;s type system is also error-aware.<p>Rust is actually largely error-unaware. It does have some syntactic sugar (mostly `?`, and even then that’s not restricted to errors), but for the most part Result just an enum with a `must_use` annotation, everything flows down from that.</div><br/></div></div></div></div><div id="37950849" class="c"><input type="checkbox" id="c-37950849" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950026">parent</a><span>|</span><a href="#37950394">prev</a><span>|</span><a href="#37950176">next</a><span>|</span><label class="collapse" for="c-37950849">[-]</label><label class="expand" for="c-37950849">[6 more]</label></div><br/><div class="children"><div class="content">The question-mark shorthand (?) basically does what the blog post is describing, and makes a lot of this stuff straightforward.<p>There _is_ some futzing that sometimes have to happen due to various operations&#x27; Result types using incompatible Error types. That&#x27;s just a thing that has to be dealt with.</div><br/><div id="37951298" class="c"><input type="checkbox" id="c-37951298" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950849">parent</a><span>|</span><a href="#37951260">next</a><span>|</span><label class="collapse" for="c-37951298">[-]</label><label class="expand" for="c-37951298">[1 more]</label></div><br/><div class="children"><div class="content">That last point can also be considered a <i>feature</i>.<p>Being able to define your own app-specific Error type which everything gets converted to is incredibly useful and powerful. Especially for web apps where you can return the correct response codes depending on the error.</div><br/></div></div><div id="37951260" class="c"><input type="checkbox" id="c-37951260" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950849">parent</a><span>|</span><a href="#37951298">prev</a><span>|</span><a href="#37951280">next</a><span>|</span><label class="collapse" for="c-37951260">[-]</label><label class="expand" for="c-37951260">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, but that futzing typically happens separately near the &quot;outer&quot; error type&#x27;s declaration - and when it doesn&#x27;t, a concise .map_err() often does the job.<p>It&#x27;s also often taken care of by a sort thiserror macro invocation per &quot;inner&quot; type.  There are obviously more complex error setups, but this covers the vast majority IME</div><br/><div id="37953165" class="c"><input type="checkbox" id="c-37953165" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951260">parent</a><span>|</span><a href="#37951280">next</a><span>|</span><label class="collapse" for="c-37953165">[-]</label><label class="expand" for="c-37953165">[1 more]</label></div><br/><div class="children"><div class="content">I get why it&#x27;s like this but I have often found that most of the time code ends up bailing by using a conversion into `String` quite quickly, leading to everything being stringified anyways.<p>I get why this is, but it does make me miss the Python Exception model of &quot;there&#x27;s ~15 base exception types. One of them is probably good enough for you&quot;. One could point out that the arguments are usually &quot;just&quot; strings there too, but at least there&#x27;s some conventions.<p>I understand Rust&#x27;s philosophy, I just find it annoying.</div><br/></div></div></div></div><div id="37951280" class="c"><input type="checkbox" id="c-37951280" checked=""/><div class="controls bullet"><span class="by">_AzMoo</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950849">parent</a><span>|</span><a href="#37951260">prev</a><span>|</span><a href="#37950176">next</a><span>|</span><label class="collapse" for="c-37951280">[-]</label><label class="expand" for="c-37951280">[2 more]</label></div><br/><div class="children"><div class="content">I find Rust&#x27;s question mark shorthand and the resulting futzing you&#x27;re talking about adds a lot more cognitive load for me than Go&#x27;s verbose if err conventions. I think more than anything this kind of syntactical discussion is just very subjective.</div><br/><div id="37953167" class="c"><input type="checkbox" id="c-37953167" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951280">parent</a><span>|</span><a href="#37950176">next</a><span>|</span><label class="collapse" for="c-37953167">[-]</label><label class="expand" for="c-37953167">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely subjective! I think the `?` stuff in itself is pretty straightforward for a DSL-like behavior. The futzing from when you&#x27;re mixing actions from multiple codebases is unfun.</div><br/></div></div></div></div></div></div><div id="37950176" class="c"><input type="checkbox" id="c-37950176" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950026">parent</a><span>|</span><a href="#37950849">prev</a><span>|</span><a href="#37950503">next</a><span>|</span><label class="collapse" for="c-37950176">[-]</label><label class="expand" for="c-37950176">[1 more]</label></div><br/><div class="children"><div class="content">A lot of common error handling patterns are expressed more effecively in Rust.<p>For bubbling up errors you have the ? operator, then on results you have map, map_err, and, ok_and...</div><br/></div></div></div></div><div id="37950503" class="c"><input type="checkbox" id="c-37950503" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949992">parent</a><span>|</span><a href="#37950026">prev</a><span>|</span><a href="#37950643">next</a><span>|</span><label class="collapse" for="c-37950503">[-]</label><label class="expand" for="c-37950503">[2 more]</label></div><br/><div class="children"><div class="content">Rust is definitely a near-contemporary of Go that made the sum-type-and-pattern-matching choice, yes, though outside of that difference the focus of the languages is very different, so it might always be the right choice if Go was but for error handling ergonomics.</div><br/><div id="37953226" class="c"><input type="checkbox" id="c-37953226" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950503">parent</a><span>|</span><a href="#37950643">next</a><span>|</span><label class="collapse" for="c-37953226">[-]</label><label class="expand" for="c-37953226">[1 more]</label></div><br/><div class="children"><div class="content">I need to say the Go stdlib is really excellent.</div><br/></div></div></div></div><div id="37950643" class="c"><input type="checkbox" id="c-37950643" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949992">parent</a><span>|</span><a href="#37950503">prev</a><span>|</span><a href="#37950694">next</a><span>|</span><label class="collapse" for="c-37950643">[-]</label><label class="expand" for="c-37950643">[1 more]</label></div><br/><div class="children"><div class="content">Or one of the ML variants if you prefer a GCed language.  F#, OCaml, SML, were great choices when go was written.  Reason has been added since.</div><br/></div></div></div></div></div></div><div id="37950694" class="c"><input type="checkbox" id="c-37950694" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37949133">prev</a><span>|</span><a href="#37949063">next</a><span>|</span><label class="collapse" for="c-37950694">[-]</label><label class="expand" for="c-37950694">[14 more]</label></div><br/><div class="children"><div class="content">I like having errors as values, as is the case in rust, and haskell, and idiomatic scala.<p>What i don&#x27;t like is where approximately 3&#x2F;4 of the significant lines of code are endless repetitions of:<p>if err {
  return nil, err
}<p>Rust has ?, haskell has do notation, scala has for. All of them have higher order functions for operating on the result. But go is not only more verbose, it is more error prone, since it is easy to forget to check an error, or use the other returned value before checking the error.</div><br/><div id="37950835" class="c"><input type="checkbox" id="c-37950835" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950694">parent</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37950835">[-]</label><label class="expand" for="c-37950835">[12 more]</label></div><br/><div class="children"><div class="content"><i>&gt; approximately 3&#x2F;4 of the significant lines of code are endless repetitions of:
if err { return nil, err }</i><p>3&#x2F;4? How are you managing to have so many cases of blindly passing an error up the stack without introducing problematic coupling?<p>I would suggest that if you are able to realistically do this more than a couple of times total in an application, you have introduced <i>way</i> too much pointless indirection and should take a closer look at your overall design. Something is amiss.<p>And that goes for any language – not something exclusive to Go. Blindly propagating an error up the stack using exception handlers, for example, is prone to the same problematic coupling and indicates the same design problems if seen in more than rare situations.</div><br/><div id="37951337" class="c"><input type="checkbox" id="c-37951337" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950835">parent</a><span>|</span><a href="#37951743">next</a><span>|</span><label class="collapse" for="c-37951337">[-]</label><label class="expand" for="c-37951337">[1 more]</label></div><br/><div class="children"><div class="content">For a gRPC&#x2F;HTTP request that calls another microservice and writes to a database, you&#x27;ve got:<p>* Handler maps the wire format message to an internal entity. Return a bad-request type error if it fails.<p>* Handler calls controller. Perhaps some specific error conditions get dedicated status codes, the rest get 5XX.<p>* Controller calls gateway. Except in rare cases where the external call is optional, you probably just bubble this to the handler.<p>* Gateway maps internal entity to wire protocol format request. Sometimes this transformation can have errors; bubble these up.<p>* Gateway calls wire protocol client. Wire protocol client may have built-in retries, or gateway may have application-level retries. In any case, if retries are exhausted, bubble this up to the controller.<p>* Gateway maps wire protocol response to internal entity. Depending on the schema, this can often fail to be well-formed, even if the request is &quot;successful.&quot; These errors also need reported to the controller.<p>* If everything is successful up to this point, controller calls repository. Bubble errors to handler.<p>* Repository maps internal entity to storage model. Sometimes this transformation is also fallible.<p>* Repository calls storage client. These errors might be retryable but after retries, need bubbling up.<p>* Finally, storage client returns successful value to repository returns to controller returns to handler returns to wire protocol server.<p>This is just a hello-world level microservice. We have thousands of them, with easily a dozen endpoints each and probably 5+ interactions per endpoint on average. And oh yeah, every single one of these error return sites needs a unit test case.</div><br/></div></div><div id="37951743" class="c"><input type="checkbox" id="c-37951743" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950835">parent</a><span>|</span><a href="#37951337">prev</a><span>|</span><a href="#37951682">next</a><span>|</span><label class="collapse" for="c-37951743">[-]</label><label class="expand" for="c-37951743">[2 more]</label></div><br/><div class="children"><div class="content">In my experience there are usually only a few places in an application that actually care about errors. You typically have something near the top level that reports errors to the user or client, whether that is printing to stderr, showing a dialog, or returning an error response over the network. You might have something that logs errors. That might be in the same place you report to the user, or it might happen where errors originate. At some boundaries, especially between a library and the calling application it might wrap the original error in a different error. If you have retries, that is probably handled by a framework that in turn returns errors if the retries fail. And maybe in some rare cases you can gracefully degrade or try an alternative in the case of an error. Everywhere else, you probably just want to propagate it up the top level error reporting facility.<p>I don&#x27;t think you should <i>blindly</i> pass up all errors, but IME propagating upwards is usually the right thing to do in your middle layers.</div><br/></div></div><div id="37951682" class="c"><input type="checkbox" id="c-37951682" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950835">parent</a><span>|</span><a href="#37951743">prev</a><span>|</span><a href="#37951154">next</a><span>|</span><label class="collapse" for="c-37951682">[-]</label><label class="expand" for="c-37951682">[2 more]</label></div><br/><div class="children"><div class="content">Mate, the code in question also simply propagates error up the stack. I have seen this all the time in pretty much all program. There&#x27;s only a few times where exceptions are actually handled; most of the time, they are truly exceptional. What is anyone going to do when printf&#x2F;malloc&#x2F;read&#x2F;open&#x2F;close fails?<p>If I am using a library, I pretty much expect each and every one of its API to return a Result&lt;T&gt; or Option&lt;T&gt;. Those that don&#x27;t either: do something funny to hide the bad states or simply crash and die which means I have to do some double checks on my end.</div><br/><div id="37952877" class="c"><input type="checkbox" id="c-37952877" checked=""/><div class="controls bullet"><span class="by">IcePic</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951682">parent</a><span>|</span><a href="#37951154">next</a><span>|</span><label class="collapse" for="c-37952877">[-]</label><label class="expand" for="c-37952877">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What is anyone going to do when printf&#x2F;malloc&#x2F;read&#x2F;open&#x2F;close fails?<p>As a sysadmin, I would love for the code to log&#x2F;print the &quot;#€%&quot;#€%#€ filename when open() or read() fails, and not just bubble up some generic &quot;something went wrong, fix something&quot; and have me dive into strace&#x2F;truss&#x2F;ktrace just to know that &#x2F;home&#x2F;foo&#x2F;badperms.txt could not be opened.<p>For some reason, all these wrapper libraries and frameworks and stuff are super good at hiding things for which we used to get decent errors, like &quot;could not open tcp port 443&quot; or &quot;file: .&#x2F;badperms.txt open() failed&quot; but as the layers stacked on top of eachother more and more, the code calling &quot;set-up-totaly-secure-sending-of-file-to-remote-http-endpoint-and-renew-LE-cert-if-needed()&quot; has so many moving parts that the program can only say &quot;worked perfectly&quot; or &quot;dang, noone in the world knows what went wrong, try again tomorrow, worked on my laptop once before deploy&quot;.<p>So while it is not &quot;fun&quot; to handle all these particular errors one by one, when we stop fussing about details, we make someones life miserable as the filesystem goes full&#x2F;quota, or when networks&#x2F;firewalls hinder traffic if we can&#x27;t even tell the user which of those two occured because it would be &quot;tedious&quot; to pay attention to so much detail when all I wanted was my program to be short and sweet.</div><br/></div></div></div></div><div id="37951154" class="c"><input type="checkbox" id="c-37951154" checked=""/><div class="controls bullet"><span class="by">dd82</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950835">parent</a><span>|</span><a href="#37951682">prev</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37951154">[-]</label><label class="expand" for="c-37951154">[6 more]</label></div><br/><div class="children"><div class="content">its of course hyperbolic but frequent enough in any substantial codebase to be a wart on the language.</div><br/><div id="37951215" class="c"><input type="checkbox" id="c-37951215" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951154">parent</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37951215">[-]</label><label class="expand" for="c-37951215">[5 more]</label></div><br/><div class="children"><div class="content">Most codebases would not justify the use of &#x27;return nil, err&#x27; at all. The language certainly isn&#x27;t going to stop you, but you are going to make life miserable for future developers if you do so.<p>There are rare circumstances where it is the right thing, but if you are seeing more than one or two instances in a substantial codebase, something isn&#x27;t right. If it is a common occurrence, and you are not purposefully trying to demonstrate your hatred of future developers, you&#x27;ve no doubt introduced way too much unnecessary complexity – which too is going to make life miserable for future developers.</div><br/><div id="37951237" class="c"><input type="checkbox" id="c-37951237" checked=""/><div class="controls bullet"><span class="by">dd82</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951215">parent</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37951237">[-]</label><label class="expand" for="c-37951237">[4 more]</label></div><br/><div class="children"><div class="content">would love to see some examples you cite.  This pattern is prevalent in all golang I&#x27;ve seen, whether in libs or work.  And I&#x27;ve only been working in the language full time for three months.</div><br/><div id="37951285" class="c"><input type="checkbox" id="c-37951285" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951237">parent</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37951285">[-]</label><label class="expand" for="c-37951285">[3 more]</label></div><br/><div class="children"><div class="content">I would love to have the original question answered. Perhaps you (or the people who have contributed the code of which you speak) have stumbled upon some solution to the coupling problem, in which case I would then understand the choice.<p>Frankly, the entire Go community is no doubt keen to hear it. The &#x27;try&#x27; proposal fell apart because nobody could figure out a  good solution to that problem at the time, and could not find justification for a whole new feature for rare occasions. If `if err != nil { return nil, err }` were to actually become tenable in most cases then said proposal could be revived based on your information. It was otherwise well received.</div><br/><div id="37952337" class="c"><input type="checkbox" id="c-37952337" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951285">parent</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37952337">[-]</label><label class="expand" for="c-37952337">[2 more]</label></div><br/><div class="children"><div class="content">It would be wonderful to see your non-coupled design without middle layers knowing about top context to handle errors without bubbling it up. It already sounds like a failure.</div><br/><div id="37952447" class="c"><input type="checkbox" id="c-37952447" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952337">parent</a><span>|</span><a href="#37950737">next</a><span>|</span><label class="collapse" for="c-37952447">[-]</label><label class="expand" for="c-37952447">[1 more]</label></div><br/><div class="children"><div class="content">I must misunderstand, but your request does, indeed, sound like a failure – and not at all related to the discussion taking place. Perhaps you could explain how &quot;middle layers&quot; and &quot;top context&quot; fit?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37950737" class="c"><input type="checkbox" id="c-37950737" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950694">parent</a><span>|</span><a href="#37950835">prev</a><span>|</span><a href="#37949063">next</a><span>|</span><label class="collapse" for="c-37950737">[-]</label><label class="expand" for="c-37950737">[1 more]</label></div><br/><div class="children"><div class="content">Or worse. Some library developer decided that &quot;panic()&quot; was the way to go rather than:<p><pre><code>    return nil, err
</code></pre>
I&#x27;m fine with error values or Pythonesque exceptions, just not both combined.<p>So much of my code is typically:<p><pre><code>    result, err := someFunc()
    if err != nil {
       return nil, err
    }
</code></pre>
Most error conditions are basically unrecoverable anyway.</div><br/></div></div></div></div><div id="37949063" class="c"><input type="checkbox" id="c-37949063" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37950694">prev</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37949063">[-]</label><label class="expand" for="c-37949063">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be surprised if you&#x27;re in a minority -- maybe <i>here</i> that&#x27;s true but most Go developers I know and work with are pretty content with the state of affairs regarding error handling.</div><br/><div id="37950532" class="c"><input type="checkbox" id="c-37950532" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949063">parent</a><span>|</span><a href="#37950433">next</a><span>|</span><label class="collapse" for="c-37950532">[-]</label><label class="expand" for="c-37950532">[3 more]</label></div><br/><div class="children"><div class="content">Do some Go on the side, I’m not content and Go yearly survey shows many are not content either as it’s the #1 complaint.</div><br/><div id="37950633" class="c"><input type="checkbox" id="c-37950633" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950532">parent</a><span>|</span><a href="#37950433">next</a><span>|</span><label class="collapse" for="c-37950633">[-]</label><label class="expand" for="c-37950633">[2 more]</label></div><br/><div class="children"><div class="content">I do too.  Error handling is fine-ish mostly.  The issue I have is there are three forms of error handling.<p><pre><code>    Errors : Fine.
    Panics : Weird because golang already had errors. 
    Segfaults: Gah!  (though this is a cgo issue apparently)
</code></pre>
See 
   <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37908655">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37908655</a>
and
   <a href="https:&#x2F;&#x2F;rachelbythebay.com&#x2F;w&#x2F;2023&#x2F;10&#x2F;16&#x2F;env&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rachelbythebay.com&#x2F;w&#x2F;2023&#x2F;10&#x2F;16&#x2F;env&#x2F;</a></div><br/><div id="37951158" class="c"><input type="checkbox" id="c-37951158" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950633">parent</a><span>|</span><a href="#37950433">next</a><span>|</span><label class="collapse" for="c-37951158">[-]</label><label class="expand" for="c-37951158">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Panics : Weird because golang already had errors.</i><p>It is true that panic allows any value to propagate, so technically you can use it to carry errors, along with anything else you can imagine (names, email addresses, audio, whatever).<p>But the intent is for it to be used for communicating exceptions. You will notice panic&#x27;s behaviour mirrors exception handling systems found in some other popular languages. But errors, along with names and email addresses for that matter, are decidedly not exceptional.</div><br/></div></div></div></div></div></div><div id="37950433" class="c"><input type="checkbox" id="c-37950433" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949063">parent</a><span>|</span><a href="#37950532">prev</a><span>|</span><a href="#37951345">next</a><span>|</span><label class="collapse" for="c-37950433">[-]</label><label class="expand" for="c-37950433">[1 more]</label></div><br/><div class="children"><div class="content">Go developer here. I&#x27;m pretty content with the state of error handling.</div><br/></div></div><div id="37951345" class="c"><input type="checkbox" id="c-37951345" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949063">parent</a><span>|</span><a href="#37950433">prev</a><span>|</span><a href="#37950045">next</a><span>|</span><label class="collapse" for="c-37951345">[-]</label><label class="expand" for="c-37951345">[1 more]</label></div><br/><div class="children"><div class="content">I wear two hats when I develop in go. One is for robust long-lived systems and for those I don&#x27;t mind verbose error handling. The other is small quick scripts and for those I really wish I had a non-verbose option.</div><br/></div></div><div id="37950045" class="c"><input type="checkbox" id="c-37950045" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949063">parent</a><span>|</span><a href="#37951345">prev</a><span>|</span><a href="#37949637">next</a><span>|</span><label class="collapse" for="c-37950045">[-]</label><label class="expand" for="c-37950045">[1 more]</label></div><br/><div class="children"><div class="content">Same with the Go developers I know, which means it falls to me to raise the bugs against their stuff ;)</div><br/></div></div><div id="37949637" class="c"><input type="checkbox" id="c-37949637" checked=""/><div class="controls bullet"><span class="by">gaganyaan</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949063">parent</a><span>|</span><a href="#37950045">prev</a><span>|</span><a href="#37949163">next</a><span>|</span><label class="collapse" for="c-37949637">[-]</label><label class="expand" for="c-37949637">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the blub paradox in action</div><br/></div></div><div id="37949163" class="c"><input type="checkbox" id="c-37949163" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949063">parent</a><span>|</span><a href="#37949637">prev</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37949163">[-]</label><label class="expand" for="c-37949163">[8 more]</label></div><br/><div class="children"><div class="content">Most Java developers I know and work with are pretty content with the state of affairs regarding error handling. But it sucks too.</div><br/><div id="37950502" class="c"><input type="checkbox" id="c-37950502" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949163">parent</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37950502">[-]</label><label class="expand" for="c-37950502">[7 more]</label></div><br/><div class="children"><div class="content">Java is significantly better than Go.<p>You have the option to explicitly handle every error, not handle errors for certain methods, or bubble up errors to a single error handler or any combination thereof.</div><br/><div id="37950679" class="c"><input type="checkbox" id="c-37950679" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950502">parent</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37950679">[-]</label><label class="expand" for="c-37950679">[6 more]</label></div><br/><div class="children"><div class="content">Well RuntimeErrors (NullPointerExceptions&#x27;s and the like) weren&#x27;t never explicitly required to be on the method signature.<p>I was trying to remember who it was, but one author I thought had recommended subclassing every exception as a Runtime exception for this reason.</div><br/><div id="37951220" class="c"><input type="checkbox" id="c-37951220" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950679">parent</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37951220">[-]</label><label class="expand" for="c-37951220">[5 more]</label></div><br/><div class="children"><div class="content">Yes there are checked and unchecked exceptions.<p>NullPointerException don&#x27;t really make sense as checked because almost every method will have some exposure to null values. But the idea is that encapsulating methods can check for those and translate them into other exception types or just let it be handled by a global exception handler.<p>Java is not the best for error handling by any stretch. But it&#x27;s easily better than Go.</div><br/><div id="37951644" class="c"><input type="checkbox" id="c-37951644" checked=""/><div class="controls bullet"><span class="by">free652</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951220">parent</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37951644">[-]</label><label class="expand" for="c-37951644">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Java is not the best for error handling by any stretch. But it&#x27;s easily better than Go.<p>Nah. If you ever worked in a big enough company you would have:<p>try &amp; catch Throwable at the main entry.<p>Go forces to think about every error.<p>C# doesn&#x27;t even have checked errors, after using Java for 10 years - checked exceptions are dumb.<p>Go doesn&#x27;t have a stack trace in the error and thats dumb.</div><br/><div id="37951915" class="c"><input type="checkbox" id="c-37951915" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951644">parent</a><span>|</span><a href="#37952063">next</a><span>|</span><label class="collapse" for="c-37951915">[-]</label><label class="expand" for="c-37951915">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Go forces to think about every error.<p>Unless you just always return it up the chain <i>without</i> thinking about it like the bulk of the code I&#x27;ve encountered. No more thoughtful than &quot;catch and reraise&quot; or &quot;just throw.&quot;<p>And like in Java, an NPE ain&#x27;t getting caught by the error return of a function in Go either.</div><br/><div id="37953104" class="c"><input type="checkbox" id="c-37953104" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951915">parent</a><span>|</span><a href="#37952063">next</a><span>|</span><label class="collapse" for="c-37953104">[-]</label><label class="expand" for="c-37953104">[1 more]</label></div><br/><div class="children"><div class="content">Even if you ignore this, assume nobody ever created an editor macro to smash, go has several glaring holes which make it very possible (and reasonably easy) to miss errors entirely. And unlike Java, those errors are just gone, they won’t be breaking noisily eventually.</div><br/></div></div></div></div><div id="37952063" class="c"><input type="checkbox" id="c-37952063" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37951644">parent</a><span>|</span><a href="#37951915">prev</a><span>|</span><a href="#37949095">next</a><span>|</span><label class="collapse" for="c-37952063">[-]</label><label class="expand" for="c-37952063">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what you mean there.<p>With checked exceptions you need to either handle them directly or yes you can wrap them in a RuntimeException and catch it in main.<p>I&#x27;ve done a decade of old-school JVM development at enterprise companies. Never seen any codebase where no exceptions are locally handed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37949095" class="c"><input type="checkbox" id="c-37949095" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37949063">prev</a><span>|</span><a href="#37950286">next</a><span>|</span><label class="collapse" for="c-37949095">[-]</label><label class="expand" for="c-37949095">[2 more]</label></div><br/><div class="children"><div class="content">I <i>also</i> like errors as values, I just wish there was a syntactically simpler way to express &quot;let the caller of this function deal with the error&quot;.</div><br/><div id="37952959" class="c"><input type="checkbox" id="c-37952959" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949095">parent</a><span>|</span><a href="#37950286">next</a><span>|</span><label class="collapse" for="c-37952959">[-]</label><label class="expand" for="c-37952959">[1 more]</label></div><br/><div class="children"><div class="content">like Zigs `try xyz();` which does what you say</div><br/></div></div></div></div><div id="37950286" class="c"><input type="checkbox" id="c-37950286" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37949095">prev</a><span>|</span><a href="#37949069">next</a><span>|</span><label class="collapse" for="c-37950286">[-]</label><label class="expand" for="c-37950286">[2 more]</label></div><br/><div class="children"><div class="content">Due to the nature of my work I&#x27;m often in a position to write, deploy and then maintain systems that are running my code and generally have to play the part of top tier support for the entire stack.<p>The more that this has become my reality,  the more I care about actually producing worthwhile errors.  I&#x27;m not at all bothered that 70% of my code is error case management with some liberal sprinklings of context into those values.<p>At this point,  I see straight through them in my code,  to the point where I&#x27;m actually going to be confronted with an error, bug or emergent system case and I&#x27;m going to be exceptionally pleased that I put so much effort into actually managing these errors correctly and not just punting them up through a common and often cryptic common error handler case with most of the useful context about the detailed error environment now missing.</div><br/><div id="37951037" class="c"><input type="checkbox" id="c-37951037" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950286">parent</a><span>|</span><a href="#37949069">next</a><span>|</span><label class="collapse" for="c-37951037">[-]</label><label class="expand" for="c-37951037">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly how I feel about Go error handling (which I prefer to other languages).<p>Error checks become a syntactic formalism that are easy and quick to type, easy and quick for the eye to scan, but have just enough presence to make sure you think through your error situation whenever and wherever you need to.<p>Go gives me a confidence in my code&#x27;s error handling that is harder to get in other languages I&#x27;ve used, where the error situation is typically muddier.</div><br/></div></div></div></div><div id="37949069" class="c"><input type="checkbox" id="c-37949069" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37950286">prev</a><span>|</span><a href="#37949112">next</a><span>|</span><label class="collapse" for="c-37949069">[-]</label><label class="expand" for="c-37949069">[8 more]</label></div><br/><div class="children"><div class="content">Providing richer tools to manipulate results and errors doesn’t make them not-values.</div><br/><div id="37949191" class="c"><input type="checkbox" id="c-37949191" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949069">parent</a><span>|</span><a href="#37949112">next</a><span>|</span><label class="collapse" for="c-37949191">[-]</label><label class="expand" for="c-37949191">[7 more]</label></div><br/><div class="children"><div class="content">You are right. I think what I don&#x27;t like is that using this operator stops you being able to use the error as a value in the given context. I would rather always have the if block there, screaming it me, ready to be addressed. But certainly YMMV.</div><br/><div id="37952224" class="c"><input type="checkbox" id="c-37952224" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949191">parent</a><span>|</span><a href="#37949685">next</a><span>|</span><label class="collapse" for="c-37952224">[-]</label><label class="expand" for="c-37952224">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think what I don&#x27;t like is that using this operator stops you being able to use the error as a value in the given context.<p>Nobody would be making you use the operator all the time. In the rare cases when you need to do that, just don&#x27;t use it.</div><br/></div></div><div id="37949685" class="c"><input type="checkbox" id="c-37949685" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949191">parent</a><span>|</span><a href="#37952224">prev</a><span>|</span><a href="#37950160">next</a><span>|</span><label class="collapse" for="c-37949685">[-]</label><label class="expand" for="c-37949685">[4 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s an easy solution to this, would love to know if I&#x27;m off track: postfix `catch` optionally captures the last value in the return tuple.<p>Instead of<p><pre><code>  value, err := foo();
  if err != nil {
    &#x2F;&#x2F; handle err
  };
</code></pre>
you get<p><pre><code>  value := foo() catch err {
    &#x2F;&#x2F; handle err
  }</code></pre></div><br/><div id="37950231" class="c"><input type="checkbox" id="c-37950231" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949685">parent</a><span>|</span><a href="#37950160">next</a><span>|</span><label class="collapse" for="c-37950231">[-]</label><label class="expand" for="c-37950231">[3 more]</label></div><br/><div class="children"><div class="content">We have:<p><pre><code>  if value, err := foo(); err {
      &#x2F;&#x2F; do something with err.
  } else {
      &#x2F;&#x2F; do something with value.
  }</code></pre></div><br/><div id="37950362" class="c"><input type="checkbox" id="c-37950362" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950231">parent</a><span>|</span><a href="#37950160">next</a><span>|</span><label class="collapse" for="c-37950362">[-]</label><label class="expand" for="c-37950362">[2 more]</label></div><br/><div class="children"><div class="content">&quot;else&quot; for the happy path is part of the problem.</div><br/><div id="37952532" class="c"><input type="checkbox" id="c-37952532" checked=""/><div class="controls bullet"><span class="by">neilwilson</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37950362">parent</a><span>|</span><a href="#37950160">next</a><span>|</span><label class="collapse" for="c-37952532">[-]</label><label class="expand" for="c-37952532">[1 more]</label></div><br/><div class="children"><div class="content">Generally in Go the error path is part of the if, which usually returns from the function. 
Then the &#x27;happy path&#x27; is just the rest of the function.<p>If you end up with complexity at this point then it is time to refactor into several functions so the &#x27;happy path&#x27; follows the standard idiom.<p>Consider it a Go code smell.</div><br/></div></div></div></div></div></div></div></div><div id="37950160" class="c"><input type="checkbox" id="c-37950160" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949191">parent</a><span>|</span><a href="#37949685">prev</a><span>|</span><a href="#37949112">next</a><span>|</span><label class="collapse" for="c-37950160">[-]</label><label class="expand" for="c-37950160">[1 more]</label></div><br/><div class="children"><div class="content">Seems like the old and new syntax would still be there and the rewrite from one to the other is easy.<p>Actually, maybe the IDE could (optionally) display it this way, so it’s not even a rewrite. The downside would be possible confusion when using another tool (like doing a diff).</div><br/></div></div></div></div></div></div><div id="37949112" class="c"><input type="checkbox" id="c-37949112" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37949069">prev</a><span>|</span><a href="#37949232">next</a><span>|</span><label class="collapse" for="c-37949112">[-]</label><label class="expand" for="c-37949112">[1 more]</label></div><br/><div class="children"><div class="content">Boxed error typed like Result in rust, or optional in c++ are what go needs.</div><br/></div></div><div id="37949232" class="c"><input type="checkbox" id="c-37949232" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37949112">prev</a><span>|</span><a href="#37949584">next</a><span>|</span><label class="collapse" for="c-37949232">[-]</label><label class="expand" for="c-37949232">[3 more]</label></div><br/><div class="children"><div class="content">Being able to wrap the error with context is the key.  If done right, you can identify the exactly what caused the error without any additional infrastructure.  (For people that say stack traces do this, they don&#x27;t.  They don&#x27;t tell you which iteration of the for loop you&#x27;re on.  They don&#x27;t tell you what the code on the other side of the channel you read the error from was doing.)<p>My rule for errors is to add only information that the caller isn&#x27;t aware of.  So don&#x27;t do:<p><pre><code>   func GetFooByID(ctx context.Context, id int) (Foo, error) {
       row, err := LookupRow(ctx, &quot;foo&quot;, id)
       if err != nil {
           return nil, errors.Wrapf(err, &quot;GetFooByID id=%v&quot;, id)
       }
       return row, nil
    }
</code></pre>
The caller already knows the id it&#x27;s looking up, and that the name of the function is GetFooByID.  It might include those in its wrapping of that error, but GetFooByID shouldn&#x27;t.<p>Meanwhile, this is good:<p><pre><code>   func UpgradeFoos(ctx context.Context, tx *Tx) error {
       foos, err := GetAll(ctx, tx, &quot;foos&quot;)
       if err != nil {
           return errors.Wrap(err, &quot;GetAll&quot;)
       }
       for _, foo := range foos {
           if err := UpgradeFoo(ctx, tx, foo.ID); err != nil {
               return errors.Wrapf(err, &quot;UpgradeFoo(%v)&quot;, foo.ID)
           }
       }
       return nil
   }
</code></pre>
Now your logs look something like &quot;server failed to startup error=apply migration: upgrade foos: UpgradeFoo(42): i&#x2F;o timeout&quot; instead of &quot;server failed to startup error=i&#x2F;o timeout&quot;.  This saves you from &quot;hmm, maybe it&#x27;s too slow to get all the foos in a batch like that, we should change that&quot;.  But nope, it&#x27;s actually UpgradeFoo(42) that&#x27;s broken.<p>Wrapping applied well is my favorite feature of Go.  Most people don&#x27;t do it.  The standard library doesn&#x27;t follow my rules.  But if you do it this way, every error you see is so easy to debug and resolve.  Less downtime, more reliability.<p>(As an aside, that loop where you accumulate errors can easily accumulate into a multi-error as of recent versions of Go.  I always prefer to try everything possible and return all the errors, then you can fix multiple problems with your input on one go.  It&#x27;s also good for cases where you are doing a main operation and an ancillary operation, like closing something.  People often ignore errors on &quot;Close&quot; and &quot;Sync&quot;, but by joining those into a multierror, then you no longer have questions like &quot;there were no errors, but this file isn&#x27;t on disk&quot;.  <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;go.uber.org&#x2F;multierr#hdr-Deferred_Functions" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;go.uber.org&#x2F;multierr#hdr-Deferred_Functio...</a> is a really nice approach for the common case of &quot;defer fh.Close()&quot;.  I have an `errors.Close` wrapper I use: <a href="https:&#x2F;&#x2F;github.com&#x2F;pachyderm&#x2F;pachyderm&#x2F;blob&#x2F;master&#x2F;src&#x2F;internal&#x2F;errors&#x2F;multi.go#L26">https:&#x2F;&#x2F;github.com&#x2F;pachyderm&#x2F;pachyderm&#x2F;blob&#x2F;master&#x2F;src&#x2F;inter...</a>.  Can&#x27;t live without it!)</div><br/><div id="37953563" class="c"><input type="checkbox" id="c-37953563" checked=""/><div class="controls bullet"><span class="by">CWIZO</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949232">parent</a><span>|</span><a href="#37951324">next</a><span>|</span><label class="collapse" for="c-37953563">[-]</label><label class="expand" for="c-37953563">[1 more]</label></div><br/><div class="children"><div class="content">I like this. Do you have any real life examples to share or  a blog diving deeper into it?<p>We have no standards for this at our place and I think this might be a nice starting point to introduce something.</div><br/></div></div><div id="37951324" class="c"><input type="checkbox" id="c-37951324" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949232">parent</a><span>|</span><a href="#37953563">prev</a><span>|</span><a href="#37949584">next</a><span>|</span><label class="collapse" for="c-37951324">[-]</label><label class="expand" for="c-37951324">[1 more]</label></div><br/><div class="children"><div class="content">I think solving the context problem is key. I&#x27;ve seen a few proposals for go error handling that address the verbosity while also allowing you to provide proper local context in a terse and readable way. I&#x27;m hoping something like that makes its way into go eventually.</div><br/></div></div></div></div><div id="37949584" class="c"><input type="checkbox" id="c-37949584" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37949032">parent</a><span>|</span><a href="#37949232">prev</a><span>|</span><a href="#37949563">next</a><span>|</span><label class="collapse" for="c-37949584">[-]</label><label class="expand" for="c-37949584">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  foo().unwrap_or_else(|err| {
      &#x2F;&#x2F; handle err
  });
</code></pre>
or<p><pre><code>  foo() catch |err| {
      &#x2F;&#x2F; handle err
  }</code></pre></div><br/><div id="37952483" class="c"><input type="checkbox" id="c-37952483" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37949584">parent</a><span>|</span><a href="#37949563">next</a><span>|</span><label class="collapse" for="c-37952483">[-]</label><label class="expand" for="c-37952483">[3 more]</label></div><br/><div class="children"><div class="content">I like the second example, but without the |, so no new syntax is necessary.<p>I don&#x27;t like the first first one. It&#x27;s too verbose, and it looks like it&#x27;s trying to introduce a shorthand for lambdas.</div><br/><div id="37952557" class="c"><input type="checkbox" id="c-37952557" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952483">parent</a><span>|</span><a href="#37949563">next</a><span>|</span><label class="collapse" for="c-37952557">[-]</label><label class="expand" for="c-37952557">[2 more]</label></div><br/><div class="children"><div class="content">Was just showing how Rust and Zig do it. Go capture could omit the ||.</div><br/><div id="37952565" class="c"><input type="checkbox" id="c-37952565" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#37949032">root</a><span>|</span><a href="#37952557">parent</a><span>|</span><a href="#37949563">next</a><span>|</span><label class="collapse" for="c-37952565">[-]</label><label class="expand" for="c-37952565">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen proposals that were very similar. I think the problem with this approach is that it doesn&#x27;t really make error handling that much easier. Typing &quot;catch err&quot; is not that different from typing &quot;if err != nil&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37949024" class="c"><input type="checkbox" id="c-37949024" checked=""/><div class="controls bullet"><span class="by">jiripospisil</span><span>|</span><a href="#37949032">prev</a><span>|</span><a href="#37949165">next</a><span>|</span><label class="collapse" for="c-37949024">[-]</label><label class="expand" for="c-37949024">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact: There are so many proposals aimed to tackle error handling ergonomics that it has its own label in the bug tracker.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues?q=+is%3Aissue+label%3Aerror-handling">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues?q=+is%3Aissue+label%3Aer...</a></div><br/></div></div><div id="37949165" class="c"><input type="checkbox" id="c-37949165" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#37949024">prev</a><span>|</span><a href="#37952048">next</a><span>|</span><label class="collapse" for="c-37949165">[-]</label><label class="expand" for="c-37949165">[6 more]</label></div><br/><div class="children"><div class="content">The author has reinvented the ?-operator from Rust and Ruby, but for Go.<p>Here&#x27;s the same function in Rust:<p><pre><code>    fn decomp(filename: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, io::Error&gt; {
        let fd = File::open(filename)?;  &#x2F;&#x2F; File is automatically closed by its destructor.
        let zd = GzDecoder::new(fd);   &#x2F;&#x2F; flate2::read::GzDecoder::new does not return an error.
        let mut data = Vec::new();     &#x2F;&#x2F; Rust makes the caller allocate the buffer for reads.
        zd.read_to_end(&amp;mut data)?;
        Ok(data)
    }
</code></pre>
I think this is great. From a reader&#x27;s perspective, it can dramatically improve readability in a lot of functions. From a writer&#x27;s perspective, these kind of solutions make it easier to compose expressions without interleaving if-statements after every other line.<p>Yes, sometimes you want to add context to your errors instead of using this syntax. But you can always use verbose syntax when it&#x27;s needed, and terse syntax when it&#x27;s not.</div><br/><div id="37952394" class="c"><input type="checkbox" id="c-37952394" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#37949165">parent</a><span>|</span><a href="#37950485">next</a><span>|</span><label class="collapse" for="c-37952394">[-]</label><label class="expand" for="c-37952394">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust makes the caller allocate the buffer for reads.<p>I don&#x27;t think this is true in this context. The buffer initially will have a capacity of 0, and will grow to fit the available data, so that as read_to_end is inserting data, the buffer will be resized until all the data fits.<p>However, if we had preallocated the buffer, or were reusing an existing buffer, then the buffer would only be grown if the data being read was too large for the buffer. In addition, there are other functions that can will never resize the buffer, and read only until the buffer is filled.<p>Perhaps a better way of phrasing this is that Rust lets the caller control where the data will be written to.</div><br/></div></div><div id="37950485" class="c"><input type="checkbox" id="c-37950485" checked=""/><div class="controls bullet"><span class="by">zakm</span><span>|</span><a href="#37949165">parent</a><span>|</span><a href="#37952394">prev</a><span>|</span><a href="#37952048">next</a><span>|</span><label class="collapse" for="c-37950485">[-]</label><label class="expand" for="c-37950485">[4 more]</label></div><br/><div class="children"><div class="content">The only argument I can think of against this would be that it would maybe slightly discourage adding the verbose details and would generally decrease the quality of error messages slightly. That said, even so it&#x27;s probably worth the trade.</div><br/><div id="37951423" class="c"><input type="checkbox" id="c-37951423" checked=""/><div class="controls bullet"><span class="by">shepmaster</span><span>|</span><a href="#37949165">root</a><span>|</span><a href="#37950485">parent</a><span>|</span><a href="#37952135">next</a><span>|</span><label class="collapse" for="c-37951423">[-]</label><label class="expand" for="c-37951423">[1 more]</label></div><br/><div class="children"><div class="content">Rust libraries like my [SNAFU] allow you to both add additional details and use the `?` operator:<p><pre><code>    read_to_string(path).context(ConfigFileSnafu { path })?;
</code></pre>
[SNAFU]: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;snafu&#x2F;latest&#x2F;snafu&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;snafu&#x2F;latest&#x2F;snafu&#x2F;</a></div><br/></div></div><div id="37952135" class="c"><input type="checkbox" id="c-37952135" checked=""/><div class="controls bullet"><span class="by">bibabaloo</span><span>|</span><a href="#37949165">root</a><span>|</span><a href="#37950485">parent</a><span>|</span><a href="#37951423">prev</a><span>|</span><a href="#37950918">next</a><span>|</span><label class="collapse" for="c-37952135">[-]</label><label class="expand" for="c-37952135">[1 more]</label></div><br/><div class="children"><div class="content">Errors are composable so this isn&#x27;t such a problem in practice. Most of the prod code I wrote would do something like this<p><pre><code>    use thiserror::Error;

    #[derive(Error, Debug)]
    enum Error {
        #[error(&quot;Could not open given decomp file: {0}&quot;)]
        FileOpen(#[from] std:io::Error),
        #[error(&quot;Compressed read error: {0}&quot;)]
        CompressedRead(#[from] gz::Error)
    }

    fn decomp(filename: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
        let fd = File::open(filename)?;  &#x2F;&#x2F; File is automatically closed by its destructor.
        let zd = GzDecoder::new(fd);   &#x2F;&#x2F; flate2::read::GzDecoder::new does not return an error.
        let mut data = Vec::new();     &#x2F;&#x2F; Rust makes the caller allocate the buffer for reads.
        zd.read_to_end(&amp;mut data)?;
        Ok(data)
    }</code></pre></div><br/></div></div><div id="37950918" class="c"><input type="checkbox" id="c-37950918" checked=""/><div class="controls bullet"><span class="by">slantedview</span><span>|</span><a href="#37949165">root</a><span>|</span><a href="#37950485">parent</a><span>|</span><a href="#37952135">prev</a><span>|</span><a href="#37952048">next</a><span>|</span><label class="collapse" for="c-37950918">[-]</label><label class="expand" for="c-37950918">[1 more]</label></div><br/><div class="children"><div class="content">I agree, especially if you can _choose_ when you want to be a bit more verbose and add more detail, or not.</div><br/></div></div></div></div></div></div><div id="37952048" class="c"><input type="checkbox" id="c-37952048" checked=""/><div class="controls bullet"><span class="by">fsociety</span><span>|</span><a href="#37949165">prev</a><span>|</span><a href="#37950839">next</a><span>|</span><label class="collapse" for="c-37952048">[-]</label><label class="expand" for="c-37952048">[5 more]</label></div><br/><div class="children"><div class="content">People are overly dramatic when it comes to typing err != nil. I’m not going to say it’s a holy grail in error checking. But I have yet to be convinced on the benefit of exceptions vs. the hell hole of complexity they bring.<p>They stuck to their guns, took what C did, and made it 1000x better. And in the same sweep made a language that is dead simple to read and code review.</div><br/><div id="37952151" class="c"><input type="checkbox" id="c-37952151" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#37952048">parent</a><span>|</span><a href="#37952111">next</a><span>|</span><label class="collapse" for="c-37952151">[-]</label><label class="expand" for="c-37952151">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that it&#x27;s hard to type. It&#x27;s that in Go, if you make a mistake with your error checking, your program has a bug. In better languages like Rust and Haskell, if you make the same kind of mistake with error checking, your program doesn&#x27;t compile.<p>And Go isn&#x27;t even close to 1000x better than C. It makes almost all of the same mistakes that C did (especially the billion dollar mistake), despite being new enough that it should have learned from them.</div><br/><div id="37952931" class="c"><input type="checkbox" id="c-37952931" checked=""/><div class="controls bullet"><span class="by">danenania</span><span>|</span><a href="#37952048">root</a><span>|</span><a href="#37952151">parent</a><span>|</span><a href="#37952111">next</a><span>|</span><label class="collapse" for="c-37952931">[-]</label><label class="expand" for="c-37952931">[1 more]</label></div><br/><div class="children"><div class="content">I like both Haskell and Rust (in theory; haven&#x27;t written anything nontrivial in either). But they both seem to encourage you to spend a lot of time and energy on the meta aspects of programming. You can build safe, beautiful systems, but you can also happily spend all day (all week? all month?) playing various forms of code golf without actually producing anything.<p>Go, like C, is a very get-it-done language. It doesn&#x27;t let you have any fun at all with abstractions, so you end up just doing your work instead. In spite of its warts, I think Go is remarkable and unique for this quality.</div><br/></div></div></div></div><div id="37952111" class="c"><input type="checkbox" id="c-37952111" checked=""/><div class="controls bullet"><span class="by">lamontcg</span><span>|</span><a href="#37952048">parent</a><span>|</span><a href="#37952151">prev</a><span>|</span><a href="#37952266">next</a><span>|</span><label class="collapse" for="c-37952111">[-]</label><label class="expand" for="c-37952111">[1 more]</label></div><br/><div class="children"><div class="content">The alternative isn&#x27;t exceptions.  Neither this idea or rust&#x27;s &#x27;?&#x27; operator are exceptions.</div><br/></div></div><div id="37952266" class="c"><input type="checkbox" id="c-37952266" checked=""/><div class="controls bullet"><span class="by">015a</span><span>|</span><a href="#37952048">parent</a><span>|</span><a href="#37952111">prev</a><span>|</span><a href="#37950839">next</a><span>|</span><label class="collapse" for="c-37952266">[-]</label><label class="expand" for="c-37952266">[1 more]</label></div><br/><div class="children"><div class="content">I mostly agree.<p>People read code like this and think: its verbose and repetitive.<p><pre><code>    if err != nil { return nil, err }
</code></pre>
But, I almost <i>never</i> write code like that. What I&#x27;m usually writing is some formulation of:<p><pre><code>    if err != nil { return nil, fmt.Errorf(&quot;Error fetching thing: %v&quot; err) }
</code></pre>
Sometimes; you wrap to add additional context. Sometimes; you wrap to get a generic error type into a package-specific error type. Sometimes; you wrap to get, idk, some kind of project-wide HTTP-oriented error type. Error wrapping is <i>the</i> pattern in Go; which is very different from exception-oriented languages.<p>I like this article&#x27;s syntax for a straightforward &quot;throw error&quot; situation. I wouldn&#x27;t support its addition, but I wouldn&#x27;t oppose it either. However, I struggle to imagine a more concise Go-ish syntax I like which supports a &quot;wrap and throw&quot; type situation. <i>Maybe</i> something like:<p><pre><code>    v1 := Thing1()!
    v2 := Thing2() ! fmt.Errorf(&quot;Error fetching thing: %v&quot; err) 
</code></pre>
Phrased in english; the bang operator can follow any statement that resolves to a multi-value function return where the last value is an error type, and the statement is in a function body whose last return value is an error type. If this function returns a non-nil value as its last value; If nothing follows the bang, it bubbles up this non-nill error with no wrapping. If a statement follows the bang, that statement gains an implicit `err` value containing the error value the LHS statement resolved to; and it can return a new error-type which then gets bubbled up.<p>But, again; I don&#x27;t love or even really like this, its just the best I can come up with. Its not that much shorter than writing it out. Its not obvious how it should behave in the presence of an outer-scoped variable named `err`. Its not obvious how the bubble up should handle the other non-error return values (zero value I guess?)<p>One thing I rather like about Go is; if you&#x27;re catching and re-throwing wrapped errors, which is a pattern I like, its actually far <i>more</i> concise than exception oriented languages. The same thing in JS?<p><pre><code>    let v;
    try {
      v = Thing()
    } catch (err) {
      throw new Error(`I died: ${err}`);
    }
</code></pre>
So; you rarely do that. But in Go, its barely harder to wrap and re-throw than it is to just directly throw; so people do it more often.</div><br/></div></div></div></div><div id="37950839" class="c"><input type="checkbox" id="c-37950839" checked=""/><div class="controls bullet"><span class="by">wesleyd</span><span>|</span><a href="#37952048">prev</a><span>|</span><a href="#37953107">next</a><span>|</span><label class="collapse" for="c-37950839">[-]</label><label class="expand" for="c-37950839">[1 more]</label></div><br/><div class="children"><div class="content">I like to joke that the most important question in Irish architecture is: where does the water go?<p>Similarly I love how in go error plumbing is front and center, at least as important as data plumbing, usually more important.<p>For some problems, one wants to gloss over things that might go wrong. Don’t use go for those. Go is for when how something fails is more important than how it works.</div><br/></div></div><div id="37953107" class="c"><input type="checkbox" id="c-37953107" checked=""/><div class="controls bullet"><span class="by">c7DJTLrn</span><span>|</span><a href="#37950839">prev</a><span>|</span><a href="#37952962">next</a><span>|</span><label class="collapse" for="c-37953107">[-]</label><label class="expand" for="c-37953107">[1 more]</label></div><br/><div class="children"><div class="content">Please no.<p>Go is designed to be easy to read and easy to write. err != nil is <i>not</i> hard to read. If you don&#x27;t like the repetition, it simply isn&#x27;t the language for you. I&#x27;m perfectly happy with how Go does it. I do not want the language morphing into another Rust.</div><br/></div></div><div id="37952962" class="c"><input type="checkbox" id="c-37952962" checked=""/><div class="controls bullet"><span class="by">gatestone</span><span>|</span><a href="#37953107">prev</a><span>|</span><a href="#37950246">next</a><span>|</span><label class="collapse" for="c-37952962">[-]</label><label class="expand" for="c-37952962">[6 more]</label></div><br/><div class="children"><div class="content">If you browse random Go code from <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;</a> you will have a hard time finding that hypothetical case where most of your code is error handling chores. The problem is artificial.</div><br/><div id="37952976" class="c"><input type="checkbox" id="c-37952976" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37952962">parent</a><span>|</span><a href="#37950246">next</a><span>|</span><label class="collapse" for="c-37952976">[-]</label><label class="expand" for="c-37952976">[5 more]</label></div><br/><div class="children"><div class="content">Yes, I agree. If you just ignore errors, they will go away. #yolo<p>P.S. That said, any program written in Go is an absolute shitshow of crappy UX because of the (inevitably) inconsistent and often incorrect error handling.</div><br/><div id="37953093" class="c"><input type="checkbox" id="c-37953093" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#37952962">root</a><span>|</span><a href="#37952976">parent</a><span>|</span><a href="#37950246">next</a><span>|</span><label class="collapse" for="c-37953093">[-]</label><label class="expand" for="c-37953093">[4 more]</label></div><br/><div class="children"><div class="content">With a statement like that in your postscript I think it would be fair to elaborate.</div><br/><div id="37953189" class="c"><input type="checkbox" id="c-37953189" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37952962">root</a><span>|</span><a href="#37953093">parent</a><span>|</span><a href="#37950246">next</a><span>|</span><label class="collapse" for="c-37953189">[-]</label><label class="expand" for="c-37953189">[3 more]</label></div><br/><div class="children"><div class="content">Once a Go program goes off the happy path, the only way to figure out what happened is to read the source code. (No, you cannot have a stack trace. Stack traces make junior programmers feel uncomfortable, and so Google made them verboten.)<p>And even then, because Go uses insane and outdated OOP practices like casting all pointers to a generic base class, even reading the source code is a exercise in frustration and rage.</div><br/><div id="37953391" class="c"><input type="checkbox" id="c-37953391" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#37952962">root</a><span>|</span><a href="#37953189">parent</a><span>|</span><a href="#37950246">next</a><span>|</span><label class="collapse" for="c-37953391">[-]</label><label class="expand" for="c-37953391">[2 more]</label></div><br/><div class="children"><div class="content">There’s error wrapping for adding context. Where one adds a human readable context to errors. Stack traces as I know them from the JVM world, with their line numbers and method names, seem a lot more coupled to the source code, so I’d say it’s the other way around really.</div><br/><div id="37953452" class="c"><input type="checkbox" id="c-37953452" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37952962">root</a><span>|</span><a href="#37953391">parent</a><span>|</span><a href="#37950246">next</a><span>|</span><label class="collapse" for="c-37953452">[-]</label><label class="expand" for="c-37953452">[1 more]</label></div><br/><div class="children"><div class="content">I speak as a user of programs written in Go. (By junior programmers who love &quot;&quot;simple&quot;&quot; programming languages.)<p>Thank God I don&#x27;t have to code anything in Go myself.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37950246" class="c"><input type="checkbox" id="c-37950246" checked=""/><div class="controls bullet"><span class="by">solid_fuel</span><span>|</span><a href="#37952962">prev</a><span>|</span><a href="#37950864">next</a><span>|</span><label class="collapse" for="c-37950246">[-]</label><label class="expand" for="c-37950246">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked heavily with Go for several years now but recently I have been transitioning to Elixir.  In my opinion, Elixir handles this kind of error return problem better with two separate patterns:<p>1) Somewhat similar to what the author of this post achieved, there is a pattern commonly used in Elixir libraries where there are often variants of library functions which end with ! which raise an exception when a problem is encountered.<p>For example, the file module <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.13&#x2F;File.html#read&#x2F;1" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.13&#x2F;File.html#read&#x2F;1</a> provides multiple ways to read a file:<p><pre><code>  File.Read() -&gt; returns {:ok, &lt;&lt;content&gt;&gt;} or {:error, &lt;&lt;reason&gt;&gt;}
  File.Read!() -&gt; returns &lt;&lt;content&gt;&gt; or raises an exception
</code></pre>
2) Pattern matching is also a common way to deal with this.<p><pre><code>  # This will raise a pattern matching exception if something other than :ok is returned from File.Read
  {:ok, content} = File.Read(...)
</code></pre>
Pattern matching like this isn&#x27;t supported in Golang but I think it would be fantastic to be able to write<p><pre><code>  zd, nil := gzip.NewReader()
</code></pre>
and have that panic if an error was returned instead.</div><br/><div id="37953651" class="c"><input type="checkbox" id="c-37953651" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#37950246">parent</a><span>|</span><a href="#37950864">next</a><span>|</span><label class="collapse" for="c-37953651">[-]</label><label class="expand" for="c-37953651">[1 more]</label></div><br/><div class="children"><div class="content">I like a lot about elixir, including what you point out. Pattern matching is awesome. Its type hinting via spec is not enough (i hear some developments are on their way here).<p>I don&#x27;t like that I often had to jump up several callers to understand the arguments coming into my function. Go wins here. And I also require performance. While it may have been query abuse by Ecto, the Elixir code base I was in was only able to handle like 3k rps across 5 nodes. I expect nearly 2x that from a single similarly sized Go node making Go 10x more performant in naive implementations. Easier to read and more performant? I chose Go. It also plays nicer with K8s; we had trouble getting nodes linked up in elixir to allow multi node BEAM features.</div><br/></div></div></div></div><div id="37950864" class="c"><input type="checkbox" id="c-37950864" checked=""/><div class="controls bullet"><span class="by">grose</span><span>|</span><a href="#37950246">prev</a><span>|</span><a href="#37948659">next</a><span>|</span><label class="collapse" for="c-37950864">[-]</label><label class="expand" for="c-37950864">[6 more]</label></div><br/><div class="children"><div class="content">I love weird little experiments like this! I was in favor of the check-handle proposal[1] that landed at the same time as the generics proposal and a little sad that it seems to be abandoned.<p>Bikeshed: How about _two_ bangs?<p><pre><code>        data := !!io.ReadAll(zd)
</code></pre>
The double-bang pattern is unused in Go because it doesn&#x27;t coerce non-booleans to booleans, so you can appropriate it without stepping on anyone&#x27;s toes :)<p>The main disadvantage of a Rust-?-like syntax for Go is you lose the ability to add context to the error (e.g. wrapping with `fmt.Errorf(&quot;context goes here: %w&quot;, err)`). Some people prefer to shove a stack trace inside the error to work around this. I&#x27;m not sure what the perfect solution would be. The check-handle proposal adds a special handle keyword to deal with it.<p>BTW, I am aware of the &#x27;errors are values&#x27; concept -- I was the guy interpreting for Rob Pike and the nice Japanese fellow who asked him about it at a conference afterparty and inspired the blog post. I think this pattern is great but it&#x27;s quite hard to distill it into generic advice (&quot;delay reporting errors until the last possible moment&quot;?). Designing ergonomic APIs for Go can be challenging, and purely anecdotally a lot of the proprietary Go code I&#x27;ve seen at various companies does not do a great job at it.<p>My #1 wish for Go is that one day Go will figure out sum types and pattern matching. I know that the way interfaces work make this challenging, but I have hope. Using sum types to handle errors makes it much more obvious what the &#x27;right thing&#x27; to do is.<p>[1]: <a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;master&#x2F;design&#x2F;go2draft-error-handling.md" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;master&#x2F;design&#x2F;go2draf...</a></div><br/><div id="37952159" class="c"><input type="checkbox" id="c-37952159" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#37950864">parent</a><span>|</span><a href="#37952317">next</a><span>|</span><label class="collapse" for="c-37952159">[-]</label><label class="expand" for="c-37952159">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The main disadvantage of a Rust-?-like syntax for Go is you lose the ability to add context to the error<p>You don&#x27;t lose the ability to just by that syntax existing. You could still do so by writing it out the long way like you have to do anyway today in Go.</div><br/><div id="37952395" class="c"><input type="checkbox" id="c-37952395" checked=""/><div class="controls bullet"><span class="by">grose</span><span>|</span><a href="#37950864">root</a><span>|</span><a href="#37952159">parent</a><span>|</span><a href="#37952252">prev</a><span>|</span><a href="#37952317">next</a><span>|</span><label class="collapse" for="c-37952395">[-]</label><label class="expand" for="c-37952395">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. What I meant is that compared to the pre-existing error handling, there are use cases it won’t fit. I am pro-? syntax. I think it would be useful even without being able to add context, but I’m also interested to see if there are solutions that could handle this for you.</div><br/></div></div></div></div><div id="37952317" class="c"><input type="checkbox" id="c-37952317" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#37950864">parent</a><span>|</span><a href="#37952159">prev</a><span>|</span><a href="#37948659">next</a><span>|</span><label class="collapse" for="c-37952317">[-]</label><label class="expand" for="c-37952317">[2 more]</label></div><br/><div class="children"><div class="content">It could be something like<p><pre><code>    data := io.ReadAll(zd) ?: return nil, fmt.Errorf(...)
</code></pre>
like in Kotlin. I think this likes to encourage overly-long lines though, I&#x27;m personally happy with Go&#x27;s error handling today.</div><br/><div id="37952417" class="c"><input type="checkbox" id="c-37952417" checked=""/><div class="controls bullet"><span class="by">grose</span><span>|</span><a href="#37950864">root</a><span>|</span><a href="#37952317">parent</a><span>|</span><a href="#37948659">next</a><span>|</span><label class="collapse" for="c-37952417">[-]</label><label class="expand" for="c-37952417">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, I’m not seriously suggesting !! as a new language feature, just recommending it as an alternative to the article’s (!fn() and ^fn()). The reason for “abusing” these pre-existing syntaxes is so that you can take advantage of the official parser and AST package. Makes it easier to play around with. If Go were to ever actually add this feature, they definitely should use a new keyword or symbol.</div><br/></div></div></div></div></div></div><div id="37948659" class="c"><input type="checkbox" id="c-37948659" checked=""/><div class="controls bullet"><span class="by">HL33tibCe7</span><span>|</span><a href="#37950864">prev</a><span>|</span><a href="#37952716">next</a><span>|</span><label class="collapse" for="c-37948659">[-]</label><label class="expand" for="c-37948659">[3 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t allow you to wrap errors, which is essential for writing idiomatic Go</div><br/><div id="37948737" class="c"><input type="checkbox" id="c-37948737" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#37948659">parent</a><span>|</span><a href="#37952716">next</a><span>|</span><label class="collapse" for="c-37948737">[-]</label><label class="expand" for="c-37948737">[2 more]</label></div><br/><div class="children"><div class="content">Agree, wrapping errors continues to build context until you have a clear trail of blame for the issue.<p>Most languages just expect you to read the stack trace and figure it out. Proper error handling tells you explicitly how it failed at each level so you can decide what to do at each level of the codebase.<p>Having global try&#x2F;catch (or bang as the author suggests) is easier at first, but makes actually handling error paths worse.</div><br/><div id="37948851" class="c"><input type="checkbox" id="c-37948851" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#37948659">root</a><span>|</span><a href="#37948737">parent</a><span>|</span><a href="#37952716">next</a><span>|</span><label class="collapse" for="c-37948851">[-]</label><label class="expand" for="c-37948851">[1 more]</label></div><br/><div class="children"><div class="content">Here is an fictitious example of an error that was wrapped from deep in the internals of the net package all the way up to the HTTP handler serving the user. It was wrapped five times and clearly outlines what went wrong at each stage.<p>&gt; failed loading config: unable to reach host example.com: tcp: dns lookup: timeout<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;errors#Is" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;errors#Is</a> and friends can be used to figure out what type&#x2F;class of error exists in this chain so there is no loss of information either. It&#x27;s more than just string concatenation. It&#x27;s an actual tree of errors that also presents well for the logger.</div><br/></div></div></div></div></div></div><div id="37952716" class="c"><input type="checkbox" id="c-37952716" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37948659">prev</a><span>|</span><a href="#37953246">next</a><span>|</span><label class="collapse" for="c-37952716">[-]</label><label class="expand" for="c-37952716">[1 more]</label></div><br/><div class="children"><div class="content">Regular go style is to return (value, error) tuples from most functions which can have runtime errors.  This raises a bunch of questions which, thanks to some of the comments in this thread, I hadn’t really thought about until now.<p>I think it is implied that one should not return both a value <i>and</i> an error.  Is this true?  Is there much code in go that returns both and lets you decide if you want to take the value and carry on, or take the error and stop?<p>Is there much idiomatic code where a function returns a tuple of actual values?  For example a function in some shipping code that returns the largest dimension of a package to be shipped where it can only be of a maximum size or a maximum weight?  Does this kind of idiomatic code also rely on the contract that only one value will be set?<p>Does go have the typing facility to have a union type for both a value and an error, and does anyone use this in preference of returning tuples?  If types in go can be null then this still allows for ambiguity and it would surely be unpopular to produce code that breaks the value&#x2F;error tuple pattern, but I assume some left field hackers are breaking the rules somewhere.</div><br/></div></div><div id="37953246" class="c"><input type="checkbox" id="c-37953246" checked=""/><div class="controls bullet"><span class="by">cabirum</span><span>|</span><a href="#37952716">prev</a><span>|</span><a href="#37948583">next</a><span>|</span><label class="collapse" for="c-37953246">[-]</label><label class="expand" for="c-37953246">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if Go syntax could be extended to tag statements in addition to struct fields:<p><pre><code>  func decomp(filename string) ([]byte, error) {
        fd, err := os.Open(filename)   `err`
        defer fd.Close()
        zd, err := gzip.NewReader(fd)  `err`
        data, err := io.ReadAll(zd)    `errw:&quot;your device could be broken: %w&quot;`
        return data, nil
  }

</code></pre>
Where `err` tag just forwards error if nonnil, and errw is similar to Errorf.</div><br/></div></div><div id="37948583" class="c"><input type="checkbox" id="c-37948583" checked=""/><div class="controls bullet"><span class="by">ttoinou</span><span>|</span><a href="#37953246">prev</a><span>|</span><a href="#37948847">next</a><span>|</span><label class="collapse" for="c-37948583">[-]</label><label class="expand" for="c-37948583">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    We can’t fix the people who cherish their imperfections as a sign of humanity
</code></pre>
Ouch. Spoken as a wise man</div><br/><div id="37951990" class="c"><input type="checkbox" id="c-37951990" checked=""/><div class="controls bullet"><span class="by">demi56</span><span>|</span><a href="#37948583">parent</a><span>|</span><a href="#37948847">next</a><span>|</span><label class="collapse" for="c-37951990">[-]</label><label class="expand" for="c-37951990">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the person who sees such as imperfections, not every perfection is the right one. The wise take should be “is it the right one”</div><br/></div></div></div></div><div id="37948847" class="c"><input type="checkbox" id="c-37948847" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#37948583">prev</a><span>|</span><a href="#37950858">next</a><span>|</span><label class="collapse" for="c-37948847">[-]</label><label class="expand" for="c-37948847">[4 more]</label></div><br/><div class="children"><div class="content">This is something that should be in the language, not some preprocessor. Like rust&#x27;s ? operator.</div><br/><div id="37948970" class="c"><input type="checkbox" id="c-37948970" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37948847">parent</a><span>|</span><a href="#37950858">next</a><span>|</span><label class="collapse" for="c-37948970">[-]</label><label class="expand" for="c-37948970">[3 more]</label></div><br/><div class="children"><div class="content">Yes.<p>Rust struggled with that for about three rounds of verbose error handling, until finally settling on &quot;Result&lt;useful, Error&gt;&quot; and &quot;?&quot;. That seems to be about right. C++ exceptions are too much. Writing it all out as in C and Go is too little. The Rust solution is a good midpoint.</div><br/><div id="37949050" class="c"><input type="checkbox" id="c-37949050" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37948847">root</a><span>|</span><a href="#37948970">parent</a><span>|</span><a href="#37950858">next</a><span>|</span><label class="collapse" for="c-37949050">[-]</label><label class="expand" for="c-37949050">[2 more]</label></div><br/><div class="children"><div class="content">Uh? Try! was added in 0.11, and the feature found to work well enough and be sufficiently valuable that ? superseded it in 0.13.</div><br/><div id="37950121" class="c"><input type="checkbox" id="c-37950121" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#37948847">root</a><span>|</span><a href="#37949050">parent</a><span>|</span><a href="#37950858">next</a><span>|</span><label class="collapse" for="c-37950121">[-]</label><label class="expand" for="c-37950121">[1 more]</label></div><br/><div class="children"><div class="content">try! was added in 0.10 (2014), and ? was stabilized in 1.13 (2020), according to my quick check on GitHub releases. Note that the underlying traits to implement ? on custom types are still unstable.</div><br/></div></div></div></div></div></div></div></div><div id="37950858" class="c"><input type="checkbox" id="c-37950858" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37948847">prev</a><span>|</span><a href="#37948801">next</a><span>|</span><label class="collapse" for="c-37950858">[-]</label><label class="expand" for="c-37950858">[3 more]</label></div><br/><div class="children"><div class="content">&gt; New Code is a lot cleaner: matcher2 := match.If(match.Binary(match.Ident(&quot;err&quot;), token.NEQ,match.Ident(&quot;nil&quot;)),match.Block(match.Multi(match.Return(match.Multi(match.Ident(&quot;nil&quot;), match.Ident(&quot;err&quot;))))))<p>In what world is this cleaner or easier to read?</div><br/><div id="37950910" class="c"><input type="checkbox" id="c-37950910" checked=""/><div class="controls bullet"><span class="by">slantedview</span><span>|</span><a href="#37950858">parent</a><span>|</span><a href="#37948801">next</a><span>|</span><label class="collapse" for="c-37950910">[-]</label><label class="expand" for="c-37950910">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the code that a user would write to use this pattern, that&#x27;s code that a library that implements this pattern might use.</div><br/><div id="37951855" class="c"><input type="checkbox" id="c-37951855" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#37950858">root</a><span>|</span><a href="#37950910">parent</a><span>|</span><a href="#37948801">next</a><span>|</span><label class="collapse" for="c-37951855">[-]</label><label class="expand" for="c-37951855">[1 more]</label></div><br/><div class="children"><div class="content">I mean, you&#x27;re not wrong. But how does that change anything? I still have to read it, and it&#x27;s still harder to read as one long chain.</div><br/></div></div></div></div></div></div><div id="37948801" class="c"><input type="checkbox" id="c-37948801" checked=""/><div class="controls bullet"><span class="by">phlakaton</span><span>|</span><a href="#37950858">prev</a><span>|</span><a href="#37948670">next</a><span>|</span><label class="collapse" for="c-37948801">[-]</label><label class="expand" for="c-37948801">[5 more]</label></div><br/><div class="children"><div class="content">The hoops you have to jump through when you don&#x27;t have a macro system...</div><br/><div id="37949239" class="c"><input type="checkbox" id="c-37949239" checked=""/><div class="controls bullet"><span class="by">linux2647</span><span>|</span><a href="#37948801">parent</a><span>|</span><a href="#37950025">next</a><span>|</span><label class="collapse" for="c-37949239">[-]</label><label class="expand" for="c-37949239">[3 more]</label></div><br/><div class="children"><div class="content">But that’s part of the value proposition of Go: that it’s a small(-ish) language.  I like that it lacks magic found in many other languages.  Though I concede that the “simplicity” sometimes comes at the expense of developer ergonomics</div><br/><div id="37950097" class="c"><input type="checkbox" id="c-37950097" checked=""/><div class="controls bullet"><span class="by">phlakaton</span><span>|</span><a href="#37948801">root</a><span>|</span><a href="#37949239">parent</a><span>|</span><a href="#37950025">next</a><span>|</span><label class="collapse" for="c-37950097">[-]</label><label class="expand" for="c-37950097">[2 more]</label></div><br/><div class="children"><div class="content">Yet here we have an example of bad developer ergonomics that so frustrates one developer that they are willing to use whatever bonkers syntax they can get the parser to choke down, and build an AST transformer for Go, to try to get something remotely approximating sane for a single common case.<p>Which is saying nothing of Go libraries heavily relying on comment-based programming (err, sorry, we call them &quot;struct tags&quot;) to generate boilerplate. The language is successful, but &quot;expense of developer ergonomics&quot; is an understatement.</div><br/><div id="37950192" class="c"><input type="checkbox" id="c-37950192" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37948801">root</a><span>|</span><a href="#37950097">parent</a><span>|</span><a href="#37950025">next</a><span>|</span><label class="collapse" for="c-37950192">[-]</label><label class="expand" for="c-37950192">[1 more]</label></div><br/><div class="children"><div class="content">The AST fix is trivial. The key is getting consensus to do it. Without consensus you get a dozen different macros that do more-or-less the same thing.<p>It seems like a language change would be good; it’s just taking longer than it should.</div><br/></div></div></div></div></div></div><div id="37950025" class="c"><input type="checkbox" id="c-37950025" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#37948801">parent</a><span>|</span><a href="#37949239">prev</a><span>|</span><a href="#37948670">next</a><span>|</span><label class="collapse" for="c-37950025">[-]</label><label class="expand" for="c-37950025">[1 more]</label></div><br/><div class="children"><div class="content">On the upside there are fewer hoops to jump through when you are reading the code.</div><br/></div></div></div></div><div id="37948670" class="c"><input type="checkbox" id="c-37948670" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#37948801">prev</a><span>|</span><a href="#37952066">next</a><span>|</span><label class="collapse" for="c-37948670">[-]</label><label class="expand" for="c-37948670">[1 more]</label></div><br/><div class="children"><div class="content">For me personally, any kind of codegen solutions are off the table unless the library&#x2F;ecosystem demands it, like k8s :(.  You lose so much productivity when dealing with codegen: linting, LSPs, testing, hell even just understanding WTF this does.</div><br/></div></div><div id="37952066" class="c"><input type="checkbox" id="c-37952066" checked=""/><div class="controls bullet"><span class="by">demi56</span><span>|</span><a href="#37948670">prev</a><span>|</span><a href="#37948982">next</a><span>|</span><label class="collapse" for="c-37952066">[-]</label><label class="expand" for="c-37952066">[1 more]</label></div><br/><div class="children"><div class="content">Some of these proposals don’t work especially for Go, Go type system is so plain infact it’s too plain that allowing for “special compiler keywords” can do more harm than good, example is “?” What if there’re 4 return values?, in Go where Order is pretty important, to Go this alone increases compile time</div><br/></div></div><div id="37948982" class="c"><input type="checkbox" id="c-37948982" checked=""/><div class="controls bullet"><span class="by">mtlynch</span><span>|</span><a href="#37952066">prev</a><span>|</span><a href="#37948997">next</a><span>|</span><label class="collapse" for="c-37948982">[-]</label><label class="expand" for="c-37948982">[2 more]</label></div><br/><div class="children"><div class="content">I feel like I missed a few steps here.<p>Is the author just telling us about a tool they privately made but are not sharing?<p>And any code you write with this &quot;bango&quot; operator is incompatible in anyone else&#x27;s Go environment unless they have the author&#x27;s same tool configured to preprocess their code?</div><br/><div id="37949522" class="c"><input type="checkbox" id="c-37949522" checked=""/><div class="controls bullet"><span class="by">t0astbread</span><span>|</span><a href="#37948982">parent</a><span>|</span><a href="#37948997">next</a><span>|</span><label class="collapse" for="c-37949522">[-]</label><label class="expand" for="c-37949522">[1 more]</label></div><br/><div class="children"><div class="content">Given that the repo says &quot;Just some little toys.&quot; in the description[1], I don&#x27;t think this is made to be used in production.<p>Otherwise it would be an interesting idea but also more or less what Lombok is for Java.<p>[1] <a href="https:&#x2F;&#x2F;humungus.tedunangst.com&#x2F;r&#x2F;fungo" rel="nofollow noreferrer">https:&#x2F;&#x2F;humungus.tedunangst.com&#x2F;r&#x2F;fungo</a></div><br/></div></div></div></div><div id="37948997" class="c"><input type="checkbox" id="c-37948997" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37948982">prev</a><span>|</span><a href="#37950866">next</a><span>|</span><label class="collapse" for="c-37948997">[-]</label><label class="expand" for="c-37948997">[12 more]</label></div><br/><div class="children"><div class="content">Assigning errors at the function call... Worst part of go. Just add try&#x2F;catch already.</div><br/><div id="37949054" class="c"><input type="checkbox" id="c-37949054" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#37948997">parent</a><span>|</span><a href="#37949852">next</a><span>|</span><label class="collapse" for="c-37949054">[-]</label><label class="expand" for="c-37949054">[4 more]</label></div><br/><div class="children"><div class="content">it is my second or third favorite part of Go. What sucks more than just about anything is exceptions as control flow. It is a spooky GOTO at a distance.<p>To everyone who complains about the &quot;if err != nil { return err }&quot;, honestly, you are doing it wrong or you have a toy application. I have written several, large, high scale, highly available systems processing multiple billions of requests a day. When analyizing those code bases, empty error returns like that accounted for 4% or less of our code. We always were doing _something_ with the error. Metrics, logging, reties, sending off to a different workstream, etc.</div><br/><div id="37949107" class="c"><input type="checkbox" id="c-37949107" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37949054">parent</a><span>|</span><a href="#37949852">next</a><span>|</span><label class="collapse" for="c-37949107">[-]</label><label class="expand" for="c-37949107">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just the empty return.  It&#x27;s that every fallible function call starts with `err = foo()` or `value, err = foo()`. You&#x27;re forced to read `err` at the beginning of every function call even if you don&#x27;t care. How will sugar for an empty return or appending an error handling scope harm anything?</div><br/><div id="37949459" class="c"><input type="checkbox" id="c-37949459" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37949107">parent</a><span>|</span><a href="#37949852">next</a><span>|</span><label class="collapse" for="c-37949459">[-]</label><label class="expand" for="c-37949459">[2 more]</label></div><br/><div class="children"><div class="content">And I understand the advantages over exceptions, but we&#x27;ve made some nice progress since the mid 2000s. Sum types and error unions aren&#x27;t rocket science and even the assembly line programming model that Go seems to have built to enable could adopt them up in a day.<p>You could even have `catch` capture only the last value in the result tuple and it would still be big improvement.</div><br/><div id="37950137" class="c"><input type="checkbox" id="c-37950137" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37949459">parent</a><span>|</span><a href="#37949852">next</a><span>|</span><label class="collapse" for="c-37950137">[-]</label><label class="expand" for="c-37950137">[1 more]</label></div><br/><div class="children"><div class="content">sum types and pattern matching are great. For me, I&#x27;m anti-exception.<p>&quot;Point on the doll where the exceptions hurt you.&quot; I worked on a project with exceptions as control flow (cough, twisted python, cough), and the error handling was caught several classes and mixins up and over in the file directory. In some far away file, your exception triggered a callback or an errback, and if that excepted, similar magic happened. It got to the point that several engineering choices had to be made around &quot;well, this really would be nice to have an exception and some standard handling, but the framework will take it and do strange things.&quot;<p>I _love_ handling my errors where they are created.</div><br/></div></div></div></div></div></div></div></div><div id="37949852" class="c"><input type="checkbox" id="c-37949852" checked=""/><div class="controls bullet"><span class="by">coffeebeqn</span><span>|</span><a href="#37948997">parent</a><span>|</span><a href="#37949054">prev</a><span>|</span><a href="#37950383">next</a><span>|</span><label class="collapse" for="c-37949852">[-]</label><label class="expand" for="c-37949852">[2 more]</label></div><br/><div class="children"><div class="content">How is try&#x2F;catch any better? It messes with your scope and is not really any prettier</div><br/><div id="37950602" class="c"><input type="checkbox" id="c-37950602" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37949852">parent</a><span>|</span><a href="#37950383">next</a><span>|</span><label class="collapse" for="c-37950602">[-]</label><label class="expand" for="c-37950602">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean? To me it&#x27;s not even close.<p><pre><code>  value, err := foo();
  if err != nil {
    &#x2F;&#x2F; handle err
  };

  value := foo() catch err {
    &#x2F;&#x2F; handle err
  }</code></pre></div><br/></div></div></div></div><div id="37950383" class="c"><input type="checkbox" id="c-37950383" checked=""/><div class="controls bullet"><span class="by">wwarner</span><span>|</span><a href="#37948997">parent</a><span>|</span><a href="#37949852">prev</a><span>|</span><a href="#37950933">next</a><span>|</span><label class="collapse" for="c-37950383">[-]</label><label class="expand" for="c-37950383">[1 more]</label></div><br/><div class="children"><div class="content">go has panic and defer for exception-like flow control, so you’re free to use it and advocate for it, but most go programmers prefer errors as values.</div><br/></div></div><div id="37950933" class="c"><input type="checkbox" id="c-37950933" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37948997">parent</a><span>|</span><a href="#37950383">prev</a><span>|</span><a href="#37950866">next</a><span>|</span><label class="collapse" for="c-37950933">[-]</label><label class="expand" for="c-37950933">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Just add try&#x2F;catch already.</i><p>Although the keywords panic and recover were chosen instead, this functionality has existed since day one.<p>But we&#x27;re talking about errors here, not exceptions. They are <i>very</i> different things.</div><br/><div id="37953132" class="c"><input type="checkbox" id="c-37953132" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37950933">parent</a><span>|</span><a href="#37951328">next</a><span>|</span><label class="collapse" for="c-37953132">[-]</label><label class="expand" for="c-37953132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But we&#x27;re talking about errors here, not exceptions. They are very different things.<p>Well, in some languages it&#x27;s the same and I have yet to come to a practical problem with it being the same.</div><br/></div></div><div id="37951328" class="c"><input type="checkbox" id="c-37951328" checked=""/><div class="controls bullet"><span class="by">deagle50</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37950933">parent</a><span>|</span><a href="#37953132">prev</a><span>|</span><a href="#37950866">next</a><span>|</span><label class="collapse" for="c-37951328">[-]</label><label class="expand" for="c-37951328">[2 more]</label></div><br/><div class="children"><div class="content">As am I. &quot;try&quot; as sugar for a simple return, and &quot;catch&quot; to capture the error value.</div><br/><div id="37951409" class="c"><input type="checkbox" id="c-37951409" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37948997">root</a><span>|</span><a href="#37951328">parent</a><span>|</span><a href="#37950866">next</a><span>|</span><label class="collapse" for="c-37951409">[-]</label><label class="expand" for="c-37951409">[1 more]</label></div><br/><div class="children"><div class="content">How is that any different from exception handlers, which are so-named because they are for carrying exceptions, not errors?<p>Maybe you&#x27;re leaving out the stack trace that one usually expects when propagating exceptions? I&#x27;m not sure that is meaningfully different, though.</div><br/></div></div></div></div></div></div></div></div><div id="37950866" class="c"><input type="checkbox" id="c-37950866" checked=""/><div class="controls bullet"><span class="by">slantedview</span><span>|</span><a href="#37948997">prev</a><span>|</span><a href="#37952823">next</a><span>|</span><label class="collapse" for="c-37950866">[-]</label><label class="expand" for="c-37950866">[1 more]</label></div><br/><div class="children"><div class="content">I love these kind of experiments. Before Java had lambda expressions, there were a few creative libraries that introduced them. It wasn&#x27;t perfect, but it helped drive towards good use cases for that language feature before it made it into the language officially.</div><br/></div></div><div id="37952823" class="c"><input type="checkbox" id="c-37952823" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#37950866">prev</a><span>|</span><a href="#37948728">next</a><span>|</span><label class="collapse" for="c-37952823">[-]</label><label class="expand" for="c-37952823">[1 more]</label></div><br/><div class="children"><div class="content">the only people who constantly complain about errors in Go are those who have no or only small experience with long running programs, so mostly scripts(php, python,...).</div><br/></div></div><div id="37948728" class="c"><input type="checkbox" id="c-37948728" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#37952823">prev</a><span>|</span><a href="#37947852">next</a><span>|</span><label class="collapse" for="c-37948728">[-]</label><label class="expand" for="c-37948728">[2 more]</label></div><br/><div class="children"><div class="content">Also a good example of programmer masochism, there&#x27;s absolutely no good reason for<p><pre><code>    zd, err := gzip.NewReader(fd)
</code></pre>
to return an error rather than waiting for an actual read. The stdlib is usually pretty good about this but third-party libraries are rife with this kind of misdesign.</div><br/><div id="37952203" class="c"><input type="checkbox" id="c-37952203" checked=""/><div class="controls bullet"><span class="by">imran-iq</span><span>|</span><a href="#37948728">parent</a><span>|</span><a href="#37947852">next</a><span>|</span><label class="collapse" for="c-37952203">[-]</label><label class="expand" for="c-37952203">[1 more]</label></div><br/><div class="children"><div class="content">You should try reading the source code and you will get your answer. NewReader[0] calls Reset[1], which calls readHeader[2], which the name should tell you what its doing.<p>---<p>0: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.21.3&#x2F;src&#x2F;compress&#x2F;gzip&#x2F;gunzip.go#L94">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.21.3&#x2F;src&#x2F;compress&#x2F;gzip...</a><p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.21.3&#x2F;src&#x2F;compress&#x2F;gzip&#x2F;gunzip.go#L113">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.21.3&#x2F;src&#x2F;compress&#x2F;gzip...</a><p>2: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.21.3&#x2F;src&#x2F;compress&#x2F;gzip&#x2F;gunzip.go#L174">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.21.3&#x2F;src&#x2F;compress&#x2F;gzip...</a></div><br/></div></div></div></div><div id="37947852" class="c"><input type="checkbox" id="c-37947852" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37948728">prev</a><span>|</span><a href="#37949077">next</a><span>|</span><label class="collapse" for="c-37947852">[-]</label><label class="expand" for="c-37947852">[30 more]</label></div><br/><div class="children"><div class="content">Errors are values. <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values</a><p>&quot;Whatever you do, always check your errors!&quot;</div><br/><div id="37948556" class="c"><input type="checkbox" id="c-37948556" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#37947852">parent</a><span>|</span><a href="#37948546">next</a><span>|</span><label class="collapse" for="c-37948556">[-]</label><label class="expand" for="c-37948556">[9 more]</label></div><br/><div class="children"><div class="content">yes, ted&#x27;s code automates checking your errors, which is something Go itself neglected to do or even remind you the programmer to do</div><br/><div id="37948638" class="c"><input type="checkbox" id="c-37948638" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948556">parent</a><span>|</span><a href="#37948695">next</a><span>|</span><label class="collapse" for="c-37948638">[-]</label><label class="expand" for="c-37948638">[2 more]</label></div><br/><div class="children"><div class="content">It also prevents adding relevant context to the errors, meaning you get all the joy of hunting through call stacks to figure out what went wrong in a sufficiently complex program.</div><br/><div id="37949309" class="c"><input type="checkbox" id="c-37949309" checked=""/><div class="controls bullet"><span class="by">t0astbread</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948638">parent</a><span>|</span><a href="#37948695">next</a><span>|</span><label class="collapse" for="c-37949309">[-]</label><label class="expand" for="c-37949309">[1 more]</label></div><br/><div class="children"><div class="content">When I write tooling for myself in Go, I usually wrap all of my errors with stacktraces since I hate having to grep for a string that may be interpolated or duplicated throughout the codebase.<p>Addendum: It is still a good thing to be able to add context to the error message though, so I think you&#x27;ve got a point.</div><br/></div></div></div></div><div id="37948695" class="c"><input type="checkbox" id="c-37948695" checked=""/><div class="controls bullet"><span class="by">HL33tibCe7</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948556">parent</a><span>|</span><a href="#37948638">prev</a><span>|</span><a href="#37951742">next</a><span>|</span><label class="collapse" for="c-37948695">[-]</label><label class="expand" for="c-37948695">[4 more]</label></div><br/><div class="children"><div class="content">Part of me agrees with you.<p>But part of me also sees the Go&#x27;s team point on this, which is that not all functions always need their error checked - as an obvious example, fmt.Println.<p>Sure, the compiler could add explicit exceptions for those cases, but that&#x27;s a very unclean solution and it doesn&#x27;t handle third party libraries.<p>The &quot;Go way&quot; is to use the errcheck tool to do that.<p>And on balance I think that having that defined in a separate tool - which can be configured by the user to exclude modules of their choice, and comes with good defaults - is the correct choice.</div><br/><div id="37948927" class="c"><input type="checkbox" id="c-37948927" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948695">parent</a><span>|</span><a href="#37951742">next</a><span>|</span><label class="collapse" for="c-37948927">[-]</label><label class="expand" for="c-37948927">[3 more]</label></div><br/><div class="children"><div class="content">&gt;not all functions always need their error checked - as an obvious example, fmt.Println.<p>I agree, but a lot of other languages handle this much better. In Rust (predictably!) you receive a Result type, and if you don&#x27;t want to check the error you either .unwrap() it or apply the ? operator to pass it up.<p>I feel like making &quot;let&#x27;s not check this error&quot; explicit rather than implicit would be an improvement. Currently in Go it&#x27;s impossible to tell whether someone forgot to check an error, or if they omitted the check intentionally.<p>As an aside: I feel like if you are <i>ever</i> in a situation in which fmt.Println returns an error, then whatever situation you are in is already far, far beyond saving. Maybe fmt.Println should just panic on an error, that seems better than output silently being dropped!</div><br/><div id="37948991" class="c"><input type="checkbox" id="c-37948991" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948927">parent</a><span>|</span><a href="#37950997">next</a><span>|</span><label class="collapse" for="c-37948991">[-]</label><label class="expand" for="c-37948991">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As an aside: I feel like if you are ever in a situation in which fmt.Println returns an error, then whatever situation you are in is already far, far beyond saving.<p>Not necessarily, it could just be that the user has closed the stream for one reason or an other. Possibly because they’re running it as a service without having set up an stdout, if the program has useful side effects.</div><br/></div></div><div id="37950997" class="c"><input type="checkbox" id="c-37950997" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948927">parent</a><span>|</span><a href="#37948991">prev</a><span>|</span><a href="#37951742">next</a><span>|</span><label class="collapse" for="c-37950997">[-]</label><label class="expand" for="c-37950997">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; it&#x27;s impossible to tell whether someone forgot to check an error</i><p>How, exactly, does one find themselves in a situation where they forget to add entire blocks of logic to their application and not notice? We&#x27;re not exactly talking about subtle bugs here. This is completely missing functionality – something that becomes immediately obvious as soon as testing begins.<p>Which, I guess, means that the previous developer did no testing at all. In which case, where do you even begin to figure out what else they have forgotten? Such a codebase, no matter the language, may not even be salvageable at that point.</div><br/></div></div></div></div></div></div><div id="37951742" class="c"><input type="checkbox" id="c-37951742" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948556">parent</a><span>|</span><a href="#37948695">prev</a><span>|</span><a href="#37948546">next</a><span>|</span><label class="collapse" for="c-37951742">[-]</label><label class="expand" for="c-37951742">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  automates checking your errors<p>It automates <i>checking</i> but not <i>handling</i> the errors. It&#x27;s the Go equivalent of an empty catch{} block. It allows a programmer to not care about errors, which works out to the same thing as ignoring them.</div><br/><div id="37952246" class="c"><input type="checkbox" id="c-37952246" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37951742">parent</a><span>|</span><a href="#37948546">next</a><span>|</span><label class="collapse" for="c-37952246">[-]</label><label class="expand" for="c-37952246">[1 more]</label></div><br/><div class="children"><div class="content">No, Ted&#x27;s code propagates the error up to the caller, but an empty catch{} block would swallow&#x2F;ignore the error.</div><br/></div></div></div></div></div></div><div id="37948546" class="c"><input type="checkbox" id="c-37948546" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37947852">parent</a><span>|</span><a href="#37948556">prev</a><span>|</span><a href="#37948416">next</a><span>|</span><label class="collapse" for="c-37948546">[-]</label><label class="expand" for="c-37948546">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Whatever you do, always check your errors!<p>Would probably help if you did not need an external linter to remind you. Alas, here as well Go is all hat.</div><br/><div id="37948984" class="c"><input type="checkbox" id="c-37948984" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948546">parent</a><span>|</span><a href="#37952247">next</a><span>|</span><label class="collapse" for="c-37948984">[-]</label><label class="expand" for="c-37948984">[1 more]</label></div><br/><div class="children"><div class="content">&quot;All hat and no cattle&quot;, a Texas insult?</div><br/></div></div><div id="37952247" class="c"><input type="checkbox" id="c-37952247" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948546">parent</a><span>|</span><a href="#37948984">prev</a><span>|</span><a href="#37948416">next</a><span>|</span><label class="collapse" for="c-37952247">[-]</label><label class="expand" for="c-37952247">[3 more]</label></div><br/><div class="children"><div class="content">&gt; if you did not need an external linter to remind you<p>That&#x27;s true if the function doesn&#x27;t return a value (other than the error) or if it does and the caller also ignores the return value.<p>That is, given<p><pre><code>    func F() error {
        ...
    }
</code></pre>
It&#x27;s legal to call F() without checking the return.  However in the case that the function returns a value and an error, like so<p><pre><code>    func G() (int, error) {
        ...
    }
</code></pre>
then it&#x27;s fine to just call G() and ignore anything returned, but<p><pre><code>    i := G()
</code></pre>
will cause a compile error. It&#x27;s possible to assign one or both values to the Blank Identifier, the underscore _, so ignoring the error, while possible, requires the code to reflect the intent, like so<p><pre><code>    i, _ := G()
</code></pre>
but<p><pre><code>    i, err := G()
</code></pre>
will fail to compile if either i or err are not used following the call.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;Z8xNWiJHPV0" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;Z8xNWiJHPV0</a><p>Maybe the compiler should require the error return to be assigned for F(), that&#x27;s a bit of a quirk that&#x27;s under discussion.</div><br/><div id="37952592" class="c"><input type="checkbox" id="c-37952592" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37952247">parent</a><span>|</span><a href="#37948416">next</a><span>|</span><label class="collapse" for="c-37952592">[-]</label><label class="expand" for="c-37952592">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s true if the function doesn&#x27;t return a value (other than the error) or if it does and the caller also ignores the return value.<p>“Yes” would have done just fine, especially as this is not uncommon when it comes to IO. But then again who’d do IO in Go right?<p>&gt; will fail to compile if either i or err are not used following the call.<p><pre><code>    a, err := G()
    if err != nil {
     panic(err)
    }
    i, err := G()
    i, err = G()
    err = F()

    fmt.Println(&quot;Got&quot;, a, i)
</code></pre>
&gt; Maybe the compiler should require the error return to be assigned for F(), that&#x27;s a bit of a quirk that&#x27;s under discussion.<p>It’s not “a bit of a quirk”. The langage only checks for unused variables which is woefully insufficient and unfit for purpose, and has been since the langage was first released.</div><br/><div id="37952707" class="c"><input type="checkbox" id="c-37952707" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37952592">parent</a><span>|</span><a href="#37948416">next</a><span>|</span><label class="collapse" for="c-37952707">[-]</label><label class="expand" for="c-37952707">[1 more]</label></div><br/><div class="children"><div class="content">You seem nice.</div><br/></div></div></div></div></div></div></div></div><div id="37948416" class="c"><input type="checkbox" id="c-37948416" checked=""/><div class="controls bullet"><span class="by">uticus</span><span>|</span><a href="#37947852">parent</a><span>|</span><a href="#37948546">prev</a><span>|</span><a href="#37949077">next</a><span>|</span><label class="collapse" for="c-37948416">[-]</label><label class="expand" for="c-37948416">[15 more]</label></div><br/><div class="children"><div class="content">As an outsider (C#&#x2F;Java) this has always intrigued me. I can only imagine what my opinion would be after using it for a few months with a team.</div><br/><div id="37948626" class="c"><input type="checkbox" id="c-37948626" checked=""/><div class="controls bullet"><span class="by">umvi</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948416">parent</a><span>|</span><a href="#37948530">next</a><span>|</span><label class="collapse" for="c-37948626">[-]</label><label class="expand" for="c-37948626">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an intentional design decision of go. In C#&#x2F;Java, exceptions are often (ab)used to create invisible control flows through the program that are extremely difficult to follow since exceptions can float up arbitrarily large stacks before being intercepted and handled. In go since you are forced to handle every error on the current level of the stack you are on, there are no invisible control flows. Either you pass the error one level up the stack, or you don&#x27;t.</div><br/><div id="37949582" class="c"><input type="checkbox" id="c-37949582" checked=""/><div class="controls bullet"><span class="by">ubertaco</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948626">parent</a><span>|</span><a href="#37952090">next</a><span>|</span><label class="collapse" for="c-37949582">[-]</label><label class="expand" for="c-37949582">[4 more]</label></div><br/><div class="children"><div class="content">&gt;In C#&#x2F;Java, exceptions are often (ab)used to create invisible control flows through the program that are extremely difficult to follow<p>I hear this often from Go advocates, but as someone who cut my teeth in Java in 2004, I&#x27;ve only ever seen this done in one codebase: an old streaming parser that I haven&#x27;t seen since, and where the alternatives were, at the time, generally _more_ confusing than tossing an &quot;unexpected end of input&quot; exception that contained context.<p>In the 19 years since (14 of which have been my professional career, mostly with Java as part of the job _somewhere_), I&#x27;ve never seen it since.<p>In the meantime, though, I&#x27;ve run into better, more-explicit error-handling strategies (monadic errors, union types with explicit unwrapping) that manage to make the usually-bad option (&quot;I&#x27;m swallowing this error&quot;) explicit and intentional, which is not something Go manages to achieve. (Interestingly, these better approaches all pre-date Go, so it&#x27;s not like there wasn&#x27;t a better state of the art to learn from.)<p>But Go also doesn&#x27;t make error-propagation easy either.<p>Somehow, Go manages to optimize for accidentally swallowing errors, which is sort of impressively bad. It reminds me of something like INTERCAL: engineered to be as much a footgun as possible. INTERCAL is a parody, though, so it has that going for it.</div><br/><div id="37950959" class="c"><input type="checkbox" id="c-37950959" checked=""/><div class="controls bullet"><span class="by">slantedview</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37949582">parent</a><span>|</span><a href="#37952090">next</a><span>|</span><label class="collapse" for="c-37950959">[-]</label><label class="expand" for="c-37950959">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Somehow, Go manages to optimize for accidentally swallowing errors<p>How so?</div><br/><div id="37952260" class="c"><input type="checkbox" id="c-37952260" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37950959">parent</a><span>|</span><a href="#37952090">next</a><span>|</span><label class="collapse" for="c-37952260">[-]</label><label class="expand" for="c-37952260">[2 more]</label></div><br/><div class="children"><div class="content">Because if you forget to write the code to account for an error, your program still compiles (unlike languages that use sum types for errors) and then said error will be accidentally swallowed when it occurs (unlike languages that use exceptions for errors). The only other languages I can think of that are as bad as Go about this are C and assembly.</div><br/><div id="37952583" class="c"><input type="checkbox" id="c-37952583" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37952260">parent</a><span>|</span><a href="#37952090">next</a><span>|</span><label class="collapse" for="c-37952583">[-]</label><label class="expand" for="c-37952583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unlike languages that use exceptions for errors<p>I present to you Sneaky Throw, credit to the author in [1]<p><pre><code>  public class Sneak {
    public static RuntimeException sneakyThrow(Throwable t) {
      if ( t == null )
        throw new NullPointerException(&quot;t&quot;);
      Sneak.&lt;RuntimeException&gt;sneakyThrow0(t);
      return null;
    }
  
    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;T extends Throwable&gt; void sneakyThrow0(Throwable t) throws T {
      throw (T)t;
    }
  }
</code></pre>
Now you too can force your callers to accidentally swallow errors and have the code compile ;)<p>[1] <a href="https:&#x2F;&#x2F;www.mail-archive.com&#x2F;javaposse@googlegroups.com&#x2F;msg05984.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mail-archive.com&#x2F;javaposse@googlegroups.com&#x2F;msg0...</a></div><br/></div></div></div></div></div></div></div></div><div id="37952090" class="c"><input type="checkbox" id="c-37952090" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948626">parent</a><span>|</span><a href="#37949582">prev</a><span>|</span><a href="#37950948">next</a><span>|</span><label class="collapse" for="c-37952090">[-]</label><label class="expand" for="c-37952090">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In C#&#x2F;Java, exceptions are often (ab)used to create invisible control flows through the program that are extremely difficult to follow since exceptions can float up arbitrarily large stacks before being intercepted and handled.<p>I&#x27;ve actually never ever seen that done in production code in the last 20 years I&#x27;ve been programming.  I&#x27;ve only seen exceptions used for errors in which case the described behaviour is exactly what I want.<p>The fact that Go advocates have to exaggerate the issues with exceptions to make the design of errors in Go seem reasonable makes me extremely suspicious.</div><br/><div id="37953761" class="c"><input type="checkbox" id="c-37953761" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37952090">parent</a><span>|</span><a href="#37950948">next</a><span>|</span><label class="collapse" for="c-37953761">[-]</label><label class="expand" for="c-37953761">[1 more]</label></div><br/><div class="children"><div class="content">Not only Java. May I present Twisted Python, an async framework that uses exceptions as control flow. Aptly named. I have scars.</div><br/></div></div></div></div><div id="37950948" class="c"><input type="checkbox" id="c-37950948" checked=""/><div class="controls bullet"><span class="by">slantedview</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948626">parent</a><span>|</span><a href="#37952090">prev</a><span>|</span><a href="#37948530">next</a><span>|</span><label class="collapse" for="c-37950948">[-]</label><label class="expand" for="c-37950948">[2 more]</label></div><br/><div class="children"><div class="content">&gt; exceptions are often (ab)used to create invisible control flows through the program that are extremely difficult to follow<p>And yet, Golang supports Goto.</div><br/><div id="37951265" class="c"><input type="checkbox" id="c-37951265" checked=""/><div class="controls bullet"><span class="by">cwbriscoe</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37950948">parent</a><span>|</span><a href="#37948530">next</a><span>|</span><label class="collapse" for="c-37951265">[-]</label><label class="expand" for="c-37951265">[1 more]</label></div><br/><div class="children"><div class="content">How are Goto&#x27;s invisible?  They are pretty explicit.<p>Also, just because your (not talking to you, just a pet-peeve of mine) CS101 professor said that Goto&#x27;s are bad, doesn&#x27;t mean it is true in 100% of cases.</div><br/></div></div></div></div></div></div><div id="37948530" class="c"><input type="checkbox" id="c-37948530" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948416">parent</a><span>|</span><a href="#37948626">prev</a><span>|</span><a href="#37949077">next</a><span>|</span><label class="collapse" for="c-37948530">[-]</label><label class="expand" for="c-37948530">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been pondering doing a short experiment where I abandon exceptions in C# and instead always return 1 or 2 values from my methods: maybe some output and an error object. I&#x27;m not sure how well this will work in practice. One issue that occurs to me immediately is that I&#x27;d be wrapping a lot of library functions in try&#x2F;catch blocks just to push my error objects back up the call stack. I suppose the lazy option is to just ignore the libraries and only worry about my own code.</div><br/><div id="37948627" class="c"><input type="checkbox" id="c-37948627" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948530">parent</a><span>|</span><a href="#37948661">next</a><span>|</span><label class="collapse" for="c-37948627">[-]</label><label class="expand" for="c-37948627">[2 more]</label></div><br/><div class="children"><div class="content">I predict you&#x27;ll give up because:<p>1. it&#x27;s very very tedious to have two unrelated error systems in one language (yours and the one everyone else in C# uses)
1. as Go demonstrates, this type of error handling is extremely tedious even by itself</div><br/><div id="37949531" class="c"><input type="checkbox" id="c-37949531" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948627">parent</a><span>|</span><a href="#37948661">next</a><span>|</span><label class="collapse" for="c-37949531">[-]</label><label class="expand" for="c-37949531">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this type of error handling is extremely tedious even by itself<p>But is the tedium worth it?</div><br/></div></div></div></div><div id="37948661" class="c"><input type="checkbox" id="c-37948661" checked=""/><div class="controls bullet"><span class="by">jakewins</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948530">parent</a><span>|</span><a href="#37948627">prev</a><span>|</span><a href="#37950603">next</a><span>|</span><label class="collapse" for="c-37948661">[-]</label><label class="expand" for="c-37948661">[1 more]</label></div><br/><div class="children"><div class="content">I’ve done this at times in Python and C#, I really really miss Go or - better - Rust style errors there.<p>But, exactly like you say, you end up fighting libraries - particularly the standard libraries, and it ain’t a fight you will win.<p>In typescript it actually kind of works - better at least. JS APIs often are errors-as-values already because of the old continuation async APIs, and typescript of course lends itself incredibly well to rich return types.</div><br/></div></div><div id="37950603" class="c"><input type="checkbox" id="c-37950603" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#37947852">root</a><span>|</span><a href="#37948530">parent</a><span>|</span><a href="#37948661">prev</a><span>|</span><a href="#37949077">next</a><span>|</span><label class="collapse" for="c-37950603">[-]</label><label class="expand" for="c-37950603">[1 more]</label></div><br/><div class="children"><div class="content">C# doesn’t really offer language syntax to deal with self many DUs. So you will probably suffer. Perhaps it can change if the language supports DU in the future.</div><br/></div></div></div></div></div></div></div></div><div id="37949077" class="c"><input type="checkbox" id="c-37949077" checked=""/><div class="controls bullet"><span class="by">yellowviking</span><span>|</span><a href="#37947852">prev</a><span>|</span><a href="#37948836">next</a><span>|</span><label class="collapse" for="c-37949077">[-]</label><label class="expand" for="c-37949077">[1 more]</label></div><br/><div class="children"><div class="content">Rust, FTW</div><br/></div></div><div id="37948836" class="c"><input type="checkbox" id="c-37948836" checked=""/><div class="controls bullet"><span class="by">jmprspret</span><span>|</span><a href="#37949077">prev</a><span>|</span><a href="#37949137">next</a><span>|</span><label class="collapse" for="c-37948836">[-]</label><label class="expand" for="c-37948836">[4 more]</label></div><br/><div class="children"><div class="content">what&#x27;s wrong with<p><pre><code>    zd, _ := gzip.NewReader()

</code></pre>
?
This too is obvious to go readers, and the current correct way to ignore errors.</div><br/><div id="37948854" class="c"><input type="checkbox" id="c-37948854" checked=""/><div class="controls bullet"><span class="by">goalonetwo</span><span>|</span><a href="#37948836">parent</a><span>|</span><a href="#37949001">next</a><span>|</span><label class="collapse" for="c-37948854">[-]</label><label class="expand" for="c-37948854">[1 more]</label></div><br/><div class="children"><div class="content">This completely ignores the error.<p>What you want is to send the error back up, without the need to be super verbose with<p><pre><code>        if err != nil {
                return nil, err
        }</code></pre></div><br/></div></div><div id="37949001" class="c"><input type="checkbox" id="c-37949001" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#37948836">parent</a><span>|</span><a href="#37948854">prev</a><span>|</span><a href="#37948958">next</a><span>|</span><label class="collapse" for="c-37949001">[-]</label><label class="expand" for="c-37949001">[1 more]</label></div><br/><div class="children"><div class="content">He doesn&#x27;t want to ignore the error, he wants exceptions-like behavior where the exceptions just propagate up by themselves if you don&#x27;t catch them inside the function. Like Java or Python exceptions.</div><br/></div></div><div id="37948958" class="c"><input type="checkbox" id="c-37948958" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37948836">parent</a><span>|</span><a href="#37949001">prev</a><span>|</span><a href="#37949137">next</a><span>|</span><label class="collapse" for="c-37948958">[-]</label><label class="expand" for="c-37948958">[1 more]</label></div><br/><div class="children"><div class="content">The goal is not to ignore the error but to make it easier to propagate it. Similar to Haskell’s do form or rust’s ? operator.</div><br/></div></div></div></div><div id="37949137" class="c"><input type="checkbox" id="c-37949137" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#37948836">prev</a><span>|</span><label class="collapse" for="c-37949137">[-]</label><label class="expand" for="c-37949137">[4 more]</label></div><br/><div class="children"><div class="content">Yet another language-ergonomics post that confuses essential complexity (the function is doing complex business logic that happens to be necessary) with accidental complexity (in this case:  having to type more).<p>With this distinction in mind, the entire article boils down to two points:<p>1.  The author is basically complaining about having to type more (fair, but not interesting)<p>2.  The author proposes that appending a &quot;!&quot; to a statement is somehow clearer than explicitly returning an error value (absurd and eyebrow-raising)<p>The whole article then becomes &quot;I like Rust&#x27;s syntax better&quot;.</div><br/><div id="37950446" class="c"><input type="checkbox" id="c-37950446" checked=""/><div class="controls bullet"><span class="by">ColonelPhantom</span><span>|</span><a href="#37949137">parent</a><span>|</span><label class="collapse" for="c-37950446">[-]</label><label class="expand" for="c-37950446">[3 more]</label></div><br/><div class="children"><div class="content">Having a common idiom for common operations like error propagation is not &quot;absurd and eyebrow-raising&quot;.<p>What sounds absurd to me is obscuring the actually interesting control flow significantly in favor of either showing the trivial control flow or alleviating the need to learn the one (1) single operator that represents said trivial control flow.</div><br/><div id="37950635" class="c"><input type="checkbox" id="c-37950635" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#37949137">root</a><span>|</span><a href="#37950446">parent</a><span>|</span><label class="collapse" for="c-37950635">[-]</label><label class="expand" for="c-37950635">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but we <i>do</i> have a common idiom for error-propagation in Go.  It&#x27;s more explicit than the proposed alternative, in fact.</div><br/><div id="37951161" class="c"><input type="checkbox" id="c-37951161" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37949137">root</a><span>|</span><a href="#37950635">parent</a><span>|</span><label class="collapse" for="c-37951161">[-]</label><label class="expand" for="c-37951161">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have an idiom, you write it out longhand every time, which ends up obscuring the important control flow and business logic under a pile of ceremonial repetition.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>