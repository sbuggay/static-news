<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710666065876" as="style"/><link rel="stylesheet" href="styles.css?v=1710666065876"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://modal.com/blog/serverless-http">Lambda on hard mode: serverless HTTP in Rust</a> <span class="domain">(<a href="https://modal.com">modal.com</a>)</span></div><div class="subtext"><span>pierremenard</span> | <span>33 comments</span></div><br/><div><div id="39729188" class="c"><input type="checkbox" id="c-39729188" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39731639">next</a><span>|</span><label class="collapse" for="c-39729188">[-]</label><label class="expand" for="c-39729188">[13 more]</label></div><br/><div class="children"><div class="content">Lambda is fundamentally a request&#x2F;response architecture and is meant to be tied together with several other AWS services.  As such,  I don&#x27;t think Modals offering is really comparable,  nor is &quot;lambda on hard mode&quot; a particularly good description for what they&#x27;ve made.<p>Perhaps &quot;EC2 on easy mode&quot; is more like it.</div><br/><div id="39729367" class="c"><input type="checkbox" id="c-39729367" checked=""/><div class="controls bullet"><span class="by">maerF0x0</span><span>|</span><a href="#39729188">parent</a><span>|</span><a href="#39729292">next</a><span>|</span><label class="collapse" for="c-39729367">[-]</label><label class="expand" for="c-39729367">[5 more]</label></div><br/><div class="children"><div class="content">&gt; a request&#x2F;response architecture<p>fundamentally it&#x27;s a HTTPS server too, you can actually invoke them with direct HTTPS calls, no SDK required. [1]<p>[1]: <a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;lambda&#x2F;latest&#x2F;dg&#x2F;urls-invocation.html#urls-invocation-basics" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;lambda&#x2F;latest&#x2F;dg&#x2F;urls-invocation...</a></div><br/><div id="39730619" class="c"><input type="checkbox" id="c-39730619" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39729367">parent</a><span>|</span><a href="#39730688">next</a><span>|</span><label class="collapse" for="c-39730619">[-]</label><label class="expand" for="c-39730619">[3 more]</label></div><br/><div class="children"><div class="content">Function URLs aren’t part of lambda, they’re just a thin abstraction around API Gateway v2 (http APIs) that allow all calls, and have randomly generated domains, so you’re not gaining anything and losing some functionality by doing this instead of running an API GW with lambda proxy integration yourself. If setting up API GW is too difficult, you could use SAM or Serverless Framework to automatically provision it. Then you can have a real domain, SSL, failover, endpoint validation, etc.</div><br/><div id="39731043" class="c"><input type="checkbox" id="c-39731043" checked=""/><div class="controls bullet"><span class="by">arrakeenrevived</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39730619">parent</a><span>|</span><a href="#39732269">next</a><span>|</span><label class="collapse" for="c-39731043">[-]</label><label class="expand" for="c-39731043">[1 more]</label></div><br/><div class="children"><div class="content">&gt;so you’re not gaining anything and losing some functionality by doing this instead of running an API GW<p>You&#x27;re gaining the fact that Function URLs are free while APIGW can be pretty costly, as well as the fact that Function URLs are fantastically less complex than APIGW if your use cases fit it.</div><br/></div></div><div id="39732269" class="c"><input type="checkbox" id="c-39732269" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39730619">parent</a><span>|</span><a href="#39731043">prev</a><span>|</span><a href="#39730688">next</a><span>|</span><label class="collapse" for="c-39732269">[-]</label><label class="expand" for="c-39732269">[1 more]</label></div><br/><div class="children"><div class="content">Function URLs are not limited to 30 seconds. That&#x27;s massive</div><br/></div></div></div></div><div id="39730688" class="c"><input type="checkbox" id="c-39730688" checked=""/><div class="controls bullet"><span class="by">plumeria</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39729367">parent</a><span>|</span><a href="#39730619">prev</a><span>|</span><a href="#39729292">next</a><span>|</span><label class="collapse" for="c-39730688">[-]</label><label class="expand" for="c-39730688">[1 more]</label></div><br/><div class="children"><div class="content">I don’t get why they don’t support gRPC (HTTP 2)? They already support Websockets.</div><br/></div></div></div></div><div id="39729292" class="c"><input type="checkbox" id="c-39729292" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#39729188">parent</a><span>|</span><a href="#39729367">prev</a><span>|</span><a href="#39731639">next</a><span>|</span><label class="collapse" for="c-39729292">[-]</label><label class="expand" for="c-39729292">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve deployed lambdas written in rust, mostly because I needed a good C interop and didn&#x27;t want to mess around with C++ AWS (been down that road, without native json support it&#x27;s a pain).<p>The rust lambda SDK is just fine. You can write your rust endpoint on, e.g. Axum, then deploy straightaway.<p>I run a few full fledged apis with just one lambda in this way. It&#x27;s not hard mode at all.</div><br/><div id="39732610" class="c"><input type="checkbox" id="c-39732610" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39729292">parent</a><span>|</span><a href="#39729344">next</a><span>|</span><label class="collapse" for="c-39732610">[-]</label><label class="expand" for="c-39732610">[1 more]</label></div><br/><div class="children"><div class="content">&gt; been down that road, without native json support it&#x27;s a pain<p>Did rust get native JSON support in the year since I last used it?<p>If you need JSON support in C++ nlohmann json is the defacto just like serde would be for rust.<p>Now if you just aren&#x27;t adept at C++ build tooling that is fine as a reason to use Rust for this but &quot;because there is no JSON support&quot; definitely isn&#x27;t a valid reason.</div><br/></div></div><div id="39729344" class="c"><input type="checkbox" id="c-39729344" checked=""/><div class="controls bullet"><span class="by">maerF0x0</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39729292">parent</a><span>|</span><a href="#39732610">prev</a><span>|</span><a href="#39731639">next</a><span>|</span><label class="collapse" for="c-39729344">[-]</label><label class="expand" for="c-39729344">[5 more]</label></div><br/><div class="children"><div class="content">This plus because you can dockerize and run on lambda, essentially you can run most anything these days (most things i&#x27;ve encountered are reasonably easy to dockerize, i&#x27;m sure there are exceptions, but in the main easy)</div><br/><div id="39730269" class="c"><input type="checkbox" id="c-39730269" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39729344">parent</a><span>|</span><a href="#39731639">next</a><span>|</span><label class="collapse" for="c-39730269">[-]</label><label class="expand" for="c-39730269">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about latency, cold and warm, using docker. I have a dockerized number cruncher and it&#x27;s a breeze to maintain, and I&#x27;m thinking of moving everything over. What&#x27;s your experience?</div><br/><div id="39730360" class="c"><input type="checkbox" id="c-39730360" checked=""/><div class="controls bullet"><span class="by">arrakeenrevived</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39730269">parent</a><span>|</span><a href="#39730310">next</a><span>|</span><label class="collapse" for="c-39730360">[-]</label><label class="expand" for="c-39730360">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that cold starts on containerized Lambdas is actually better than non-containerized for some workloads, because using containers allows Lambda to do better caching of the code, as well as lazy-loading. YMMV of course based on exactly what image you use (eg if you&#x27;re not using a common base, like Ubuntu or Amazon Linux, you won&#x27;t get as much benefit from the caching) and how much custom code you have (like hundreds of MBs worth).<p>There&#x27;s a very interesting blog post about it here, as well an an accompanying whitepaper: <a href="https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2023&#x2F;05&#x2F;23&#x2F;snapshot-loading.html" rel="nofollow">https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2023&#x2F;05&#x2F;23&#x2F;snapshot-loading.html</a></div><br/></div></div><div id="39730310" class="c"><input type="checkbox" id="c-39730310" checked=""/><div class="controls bullet"><span class="by">vermilingua</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39730269">parent</a><span>|</span><a href="#39730360">prev</a><span>|</span><a href="#39731639">next</a><span>|</span><label class="collapse" for="c-39730310">[-]</label><label class="expand" for="c-39730310">[2 more]</label></div><br/><div class="children"><div class="content">My experience with rust coldstarts was very good, my ECS backed lambdas coldstart and return a response in &lt;40ms.</div><br/><div id="39730362" class="c"><input type="checkbox" id="c-39730362" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#39729188">root</a><span>|</span><a href="#39730310">parent</a><span>|</span><a href="#39731639">next</a><span>|</span><label class="collapse" for="c-39730362">[-]</label><label class="expand" for="c-39730362">[1 more]</label></div><br/><div class="children"><div class="content">Yeah at this point vercel and AWS and basically everyone support serverless docker. It&#x27;s probably dumb to do anything else.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39731639" class="c"><input type="checkbox" id="c-39731639" checked=""/><div class="controls bullet"><span class="by">extr</span><span>|</span><a href="#39729188">prev</a><span>|</span><a href="#39729065">next</a><span>|</span><label class="collapse" for="c-39731639">[-]</label><label class="expand" for="c-39731639">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been transitioning some compute-heavy workloads from Lambda&#x2F;AWS Batch to modal recently and have nothing but good things to say about it. One of those technologies where you are shipping the same afternoon as checking it out. &quot;Wow, that just <i>works</i>?&quot; Highly highly recommended, feels like the future IMO.</div><br/></div></div><div id="39729065" class="c"><input type="checkbox" id="c-39729065" checked=""/><div class="controls bullet"><span class="by">nathancahill</span><span>|</span><a href="#39731639">prev</a><span>|</span><a href="#39732303">next</a><span>|</span><label class="collapse" for="c-39729065">[-]</label><label class="expand" for="c-39729065">[1 more]</label></div><br/><div class="children"><div class="content">My first impression is that this is serverless done right. My second impression is I&#x27;d love to work there.</div><br/></div></div><div id="39732303" class="c"><input type="checkbox" id="c-39732303" checked=""/><div class="controls bullet"><span class="by">pcwelder</span><span>|</span><a href="#39729065">prev</a><span>|</span><a href="#39730413">next</a><span>|</span><label class="collapse" for="c-39732303">[-]</label><label class="expand" for="c-39732303">[1 more]</label></div><br/><div class="children"><div class="content">FYI the hyperlink on text &quot;traditionally understood&quot; is giving 404 (<a href="https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Pubs&#x2F;TechRpts&#x2F;2019&#x2F;EECS-2019-3.pdf" rel="nofollow">https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Pubs&#x2F;TechRpts&#x2F;2019&#x2F;EECS-2019-...</a>)</div><br/></div></div><div id="39730413" class="c"><input type="checkbox" id="c-39730413" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#39732303">prev</a><span>|</span><a href="#39729361">next</a><span>|</span><label class="collapse" for="c-39730413">[-]</label><label class="expand" for="c-39730413">[6 more]</label></div><br/><div class="children"><div class="content">I don’t get it. A lot of this post is describing how they translate HTTP requests into function calls, and deal with issues around the HTTP protocol.<p>If you’re invoking a heavy-duty, long running function then you’re likely doing something bespoke. Why use HTTP at all? Wouldn’t GRPC be a better fit, because that seems to be what is being reinvented here.<p>The selling point of HTTP is that it’s ubiquitous and simple. But you’re coupling it with an offering that is specific and complex. Is using a GRPC library such a burden that makes this effort worthwhile?</div><br/><div id="39731242" class="c"><input type="checkbox" id="c-39731242" checked=""/><div class="controls bullet"><span class="by">quadhome</span><span>|</span><a href="#39730413">parent</a><span>|</span><a href="#39730642">next</a><span>|</span><label class="collapse" for="c-39731242">[-]</label><label class="expand" for="c-39731242">[1 more]</label></div><br/><div class="children"><div class="content">gRPC is layered on top of HTTP.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;grpc&#x2F;grpc&#x2F;blob&#x2F;master&#x2F;doc&#x2F;PROTOCOL-HTTP2.md">https:&#x2F;&#x2F;github.com&#x2F;grpc&#x2F;grpc&#x2F;blob&#x2F;master&#x2F;doc&#x2F;PROTOCOL-HTTP2....</a></div><br/></div></div><div id="39730642" class="c"><input type="checkbox" id="c-39730642" checked=""/><div class="controls bullet"><span class="by">Everdred2dx</span><span>|</span><a href="#39730413">parent</a><span>|</span><a href="#39731242">prev</a><span>|</span><a href="#39730925">next</a><span>|</span><label class="collapse" for="c-39730642">[-]</label><label class="expand" for="c-39730642">[1 more]</label></div><br/><div class="children"><div class="content">Easier for the web devs to work with I guess? Multiple mentions of web browsers in the post</div><br/></div></div><div id="39730925" class="c"><input type="checkbox" id="c-39730925" checked=""/><div class="controls bullet"><span class="by">DinaCoder98</span><span>|</span><a href="#39730413">parent</a><span>|</span><a href="#39730642">prev</a><span>|</span><a href="#39729361">next</a><span>|</span><label class="collapse" for="c-39730925">[-]</label><label class="expand" for="c-39730925">[3 more]</label></div><br/><div class="children"><div class="content">gRPC is for long-lived services (and connections). Combining it with lambda doesn&#x27;t make much sense.</div><br/><div id="39730958" class="c"><input type="checkbox" id="c-39730958" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#39730413">root</a><span>|</span><a href="#39730925">parent</a><span>|</span><a href="#39729361">next</a><span>|</span><label class="collapse" for="c-39730958">[-]</label><label class="expand" for="c-39730958">[2 more]</label></div><br/><div class="children"><div class="content">If only there was some kind of long-lived proxy you could put in front of things that would handle connection pooling and would forward requests onto a short-lived backend, scaling up instances as needed to serve those requests.</div><br/><div id="39731388" class="c"><input type="checkbox" id="c-39731388" checked=""/><div class="controls bullet"><span class="by">DinaCoder98</span><span>|</span><a href="#39730413">root</a><span>|</span><a href="#39730958">parent</a><span>|</span><a href="#39729361">next</a><span>|</span><label class="collapse" for="c-39731388">[-]</label><label class="expand" for="c-39731388">[1 more]</label></div><br/><div class="children"><div class="content">Ok, this would still obviate the use of gRPC on lambda</div><br/></div></div></div></div></div></div></div></div><div id="39729361" class="c"><input type="checkbox" id="c-39729361" checked=""/><div class="controls bullet"><span class="by">voiceblue</span><span>|</span><a href="#39730413">prev</a><span>|</span><a href="#39732300">next</a><span>|</span><label class="collapse" for="c-39729361">[-]</label><label class="expand" for="c-39729361">[1 more]</label></div><br/><div class="children"><div class="content">As the other commenter points out, this offering isn&#x27;t quite comparable to Lambda directly. This ends up comparing apples to oranges here and there, but overall I was able to get a good idea of the choices made and the tradeoffs involved. Nice work! I do have a complaint about the comparison table that shows &#x27;convert HTTP to function calls&#x27; as an alternative to load balancers and reverse proxies: as we see later in the article, there is still a load balancer involved, and that table creates a false impression that there isn&#x27;t.</div><br/></div></div><div id="39732300" class="c"><input type="checkbox" id="c-39732300" checked=""/><div class="controls bullet"><span class="by">pcwelder</span><span>|</span><a href="#39729361">prev</a><span>|</span><a href="#39729363">next</a><span>|</span><label class="collapse" for="c-39732300">[-]</label><label class="expand" for="c-39732300">[1 more]</label></div><br/><div class="children"><div class="content">For workloads that take minutes to run, it&#x27;s very easy to hit max socket connection limit somaxconn. How do you handle that with just request response model?</div><br/></div></div><div id="39729363" class="c"><input type="checkbox" id="c-39729363" checked=""/><div class="controls bullet"><span class="by">maerF0x0</span><span>|</span><a href="#39732300">prev</a><span>|</span><a href="#39729196">next</a><span>|</span><label class="collapse" for="c-39729363">[-]</label><label class="expand" for="c-39729363">[2 more]</label></div><br/><div class="children"><div class="content">Their quoted limits on AWS seem quite off.<p>&gt; As of 2024, they can only use 3 CPUs (6 threads) and 10 GB of memory<p>Actually you get 1vCPU (eg a hyperthread) per 1769MB of memory[1]<p>[1] -<a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;lambda&#x2F;latest&#x2F;dg&#x2F;configuration-function-common.html#configuration-memory-console" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;lambda&#x2F;latest&#x2F;dg&#x2F;configuration-f...</a><p>&gt; Response bandwidth is 2 Mbps<p>This is shockingly low, and I wouldn&#x27;t believe it without data. 16Mbps (2MB&#x2F;s) would be more believable. In my experience you can reliably get 25MB&#x2F;s (~400Mbps) in the network layer of things in AWS.</div><br/><div id="39729442" class="c"><input type="checkbox" id="c-39729442" checked=""/><div class="controls bullet"><span class="by">arrakeenrevived</span><span>|</span><a href="#39729363">parent</a><span>|</span><a href="#39729196">next</a><span>|</span><label class="collapse" for="c-39729442">[-]</label><label class="expand" for="c-39729442">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct, it is 2 MB&#x2F;s. The actual bandwidth from the AWS Lambda docs is:<p>&gt;Uncapped for the first 6 MB of your function&#x27;s response. For responses larger than 6 MB, 2MBps for the remainder of the response<p>Some of the other numbers in the article are also incorrect. Lambda functions using containers can use a 10 GB container image (the article claims 50 MB), and container images are actually the faster&#x2F;preferred way to do it these days.</div><br/></div></div></div></div><div id="39729196" class="c"><input type="checkbox" id="c-39729196" checked=""/><div class="controls bullet"><span class="by">j4ah4n</span><span>|</span><a href="#39729363">prev</a><span>|</span><a href="#39729554">next</a><span>|</span><label class="collapse" for="c-39729196">[-]</label><label class="expand" for="c-39729196">[5 more]</label></div><br/><div class="children"><div class="content">This looks amazing, nice write up!<p>Anyone know if there&#x27;s anything like this, but using Python and self hostable?</div><br/><div id="39729302" class="c"><input type="checkbox" id="c-39729302" checked=""/><div class="controls bullet"><span class="by">WiseWeasel</span><span>|</span><a href="#39729196">parent</a><span>|</span><a href="#39729282">next</a><span>|</span><label class="collapse" for="c-39729302">[-]</label><label class="expand" for="c-39729302">[1 more]</label></div><br/><div class="children"><div class="content">You can migrate a Django project between serverless and self-hosted <a href="https:&#x2F;&#x2F;dev.to&#x2F;vaddimart&#x2F;deploy-django-app-on-aws-lambda-using-serverless-part-1-1i90" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;vaddimart&#x2F;deploy-django-app-on-aws-lambda-usi...</a></div><br/></div></div><div id="39732234" class="c"><input type="checkbox" id="c-39732234" checked=""/><div class="controls bullet"><span class="by">pcwelder</span><span>|</span><a href="#39729196">parent</a><span>|</span><a href="#39729282">prev</a><span>|</span><a href="#39731101">next</a><span>|</span><label class="collapse" for="c-39732234">[-]</label><label class="expand" for="c-39732234">[1 more]</label></div><br/><div class="children"><div class="content">Ray is the closest I think.</div><br/></div></div><div id="39731101" class="c"><input type="checkbox" id="c-39731101" checked=""/><div class="controls bullet"><span class="by">xcdzvyn</span><span>|</span><a href="#39729196">parent</a><span>|</span><a href="#39732234">prev</a><span>|</span><a href="#39729554">next</a><span>|</span><label class="collapse" for="c-39731101">[-]</label><label class="expand" for="c-39731101">[1 more]</label></div><br/><div class="children"><div class="content">A web server?</div><br/></div></div></div></div><div id="39729554" class="c"><input type="checkbox" id="c-39729554" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39729196">prev</a><span>|</span><label class="collapse" for="c-39729554">[-]</label><label class="expand" for="c-39729554">[1 more]</label></div><br/><div class="children"><div class="content">Something that turned me off of GPU lambda services is that they don&#x27;t offer a way to run everything locally. I have an instance with a GPU where I do my dev. I&#x27;m running Postgres, the front end, back end (Node), and my GPU worker thread (Python) on that box. Replicate and other offerings do not let me run the full hosted environment on my machine (you can run the service container but it behaves differently as there&#x27;s no included router&#x2F;scheduler). It feels wrong to use a magically instantiated box for my GPU worker.<p>Really all that I want is for Render.com to have GPU instances (I saw fly.io now has GPUs which is great, but I&#x27;ve both heard bad things about their stability and don&#x27;t care for their rethinking of server architecture). Please will someone give me PaaS web hosting with GPU instances?<p>I&#x27;m a simple man. If there&#x27;s a fundamental shift in hosting philosophy I will resist that change. I have loved docker and PaaS as revolutions in development and hosting experiences because the interface is at some level still just running Linux processes like I do on my computer. You can tell me that now my code is hosted in a serverless runtime. But you need to give me that runtime so that I can spin it up on my own computer, on EKS, or whatever if need be.</div><br/></div></div></div></div></div></div></div></body></html>