<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710061251457" as="style"/><link rel="stylesheet" href="styles.css?v=1710061251457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/flonatel/pipexec">Pipexec – Handling pipe of commands like a single command</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>JNRowe</span> | <span>17 comments</span></div><br/><div><div id="39656636" class="c"><input type="checkbox" id="c-39656636" checked=""/><div class="controls bullet"><span class="by">qazxcvbnm</span><span>|</span><a href="#39656905">next</a><span>|</span><label class="collapse" for="c-39656636">[-]</label><label class="expand" for="c-39656636">[2 more]</label></div><br/><div class="children"><div class="content">It seems to me that this can be achieved by the following bash-native way of creating extra file descriptor pipes:<p><pre><code>  pipe_path=&quot;$(mktemp -u)&quot;
  mkfifo &quot;$pipe_path&quot;
  exec 3&lt;&gt;&quot;$pipe_path&quot;
  rm -f &quot;$pipe_path&quot;
</code></pre>
Here, exec associates the file descriptor (3 here, replace with any desired descriptor) with the pipe created by mkfifo. The filesystem path to the pipe is removed immediately after we obtain a file descriptor to it, so that the the only remaining reference to the pipe in the system would be from this script, and thus when the script dies, the kernel will automatically free the pipe.<p>An example use case would be like so: <a href="https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;a&#x2F;216475&#x2F;585293" rel="nofollow">https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;a&#x2F;216475&#x2F;585293</a></div><br/><div id="39657564" class="c"><input type="checkbox" id="c-39657564" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#39656636">parent</a><span>|</span><a href="#39656905">next</a><span>|</span><label class="collapse" for="c-39657564">[-]</label><label class="expand" for="c-39657564">[1 more]</label></div><br/><div class="children"><div class="content">Worth noting that POSIX sh only specifies that file descriptors up to 9 be supported, and many shells stick with this minimum.</div><br/></div></div></div></div><div id="39656905" class="c"><input type="checkbox" id="c-39656905" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#39656636">prev</a><span>|</span><a href="#39656514">next</a><span>|</span><label class="collapse" for="c-39656905">[-]</label><label class="expand" for="c-39656905">[2 more]</label></div><br/><div class="children"><div class="content">Hm interesting, also see dgsh, the directed graph shell<p><a href="https:&#x2F;&#x2F;www2.dmst.aueb.gr&#x2F;dds&#x2F;sw&#x2F;dgsh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www2.dmst.aueb.gr&#x2F;dds&#x2F;sw&#x2F;dgsh&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;dspinellis&#x2F;dgsh">https:&#x2F;&#x2F;github.com&#x2F;dspinellis&#x2F;dgsh</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21700014">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21700014</a><p>dgsh uses Unix domain sockets, not pipes.  I don&#x27;t remember exactly why, but it&#x27;s in the paper, perhaps to avoid deadlocks compared to pipes.<p>I&#x27;d also be interested in some more examples with pipexec or dgsh!</div><br/><div id="39657201" class="c"><input type="checkbox" id="c-39657201" checked=""/><div class="controls bullet"><span class="by">JNRowe</span><span>|</span><a href="#39656905">parent</a><span>|</span><a href="#39656514">next</a><span>|</span><label class="collapse" for="c-39657201">[-]</label><label class="expand" for="c-39657201">[1 more]</label></div><br/><div class="children"><div class="content">Yep deadlocks, you&#x27;re correct.  From the paper:<p>&quot;Modern Unix systems offer named pipes, also known as fifos, which can be used to hand-craft arbitrary process communication topologies. However, if combined one-to-many and many-to-one piping are setup by using named pipes, another problem will occur. Due to the limited buffering offered by typical programs, deadlocks can easily occur when a process consuming data from many producers with more than one input, blocks waiting for input from one of the processes feeding it. This can cause a second feeding process to block, waiting to send its output to another one of the consumer process’s inputs, and, thereby, blocking the upstream process feeding both processes that provide data to the consumer one.&quot;<p>dspinellis has commented on another dgsh discussion¹(along with you).  Interestingly, with a light comparison to pipexec².<p>I stumbled upon pipexec trying to find a battle tested solution to extend a data munging task where I was relying on zsh&#x27;s multios³, mostly because orchestrating the interactions with a coproc&#x27;d jq for output were fighting me.  There is something both frustrating and soothing about finding a seven year old comment pointing out why my path was doomed before I&#x27;d even started; people have solved the problem already, plus people far smarter than me also found the trap.<p>¹ <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13352659">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13352659</a><p>² <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13358090">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13358090</a><p>³ <a href="https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Redirection.html#Multios" rel="nofollow">https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Redirection.html#Mult...</a></div><br/></div></div></div></div><div id="39656514" class="c"><input type="checkbox" id="c-39656514" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#39656905">prev</a><span>|</span><a href="#39657173">next</a><span>|</span><label class="collapse" for="c-39656514">[-]</label><label class="expand" for="c-39656514">[6 more]</label></div><br/><div class="children"><div class="content">This is neat, but outside of a contrived ouroboros example, what’s a real world use case for this?<p>There’s a natural flow of outputs becoming inputs and I’m struggling to identify a situation where I would feed things back into the source. Also, named pipes kind of solve that already.</div><br/><div id="39657537" class="c"><input type="checkbox" id="c-39657537" checked=""/><div class="controls bullet"><span class="by">lubutu</span><span>|</span><a href="#39656514">parent</a><span>|</span><a href="#39656667">next</a><span>|</span><label class="collapse" for="c-39657537">[-]</label><label class="expand" for="c-39657537">[1 more]</label></div><br/><div class="children"><div class="content">I suppose such feedback could be used for reaching a fixpoint. Suppose you have a build system that reads targets to be built from stdin and outputs to stdout targets that are dependent on that target and must now be rebuilt. With an ouroboros, the build system will continue to run, even if the dependency graph is dynamically cyclical, until the fixpoint is reached and the build terminates.</div><br/></div></div><div id="39656667" class="c"><input type="checkbox" id="c-39656667" checked=""/><div class="controls bullet"><span class="by">LatticeAnimal</span><span>|</span><a href="#39656514">parent</a><span>|</span><a href="#39657537">prev</a><span>|</span><a href="#39657042">next</a><span>|</span><label class="collapse" for="c-39656667">[-]</label><label class="expand" for="c-39656667">[1 more]</label></div><br/><div class="children"><div class="content">Agreed -- their only example is `pipexec -l 2 -- [ LS &#x2F;bin&#x2F;ls -l ] [ GREP &#x2F;bin&#x2F;grep LIC ] &#x27;{LS:1&gt;GREP:0}&#x27;` which appears to be `ls | grep LIC` with more steps. Seems like a (cool) solution without a real problem.<p>(I&#x27;d love to be wrong though and see a real use case for some cool feedback loop of commands)</div><br/></div></div><div id="39657042" class="c"><input type="checkbox" id="c-39657042" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#39656514">parent</a><span>|</span><a href="#39656667">prev</a><span>|</span><a href="#39657087">next</a><span>|</span><label class="collapse" for="c-39657042">[-]</label><label class="expand" for="c-39657042">[1 more]</label></div><br/><div class="children"><div class="content">It looks like it might be able to handle one of the tricks I do with dpipe running sshfs ( <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;bdmorin&#x2F;5eb17828612e7d1b66e92550f42873e8" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;bdmorin&#x2F;5eb17828612e7d1b66e92550f428...</a> is probably where I picked it up from) but I&#x27;m not sure (and dpipe already handles it fine.)</div><br/></div></div><div id="39657087" class="c"><input type="checkbox" id="c-39657087" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#39656514">parent</a><span>|</span><a href="#39657042">prev</a><span>|</span><a href="#39656982">next</a><span>|</span><label class="collapse" for="c-39657087">[-]</label><label class="expand" for="c-39657087">[1 more]</label></div><br/><div class="children"><div class="content">I recently wanted this for some scripting over SSH. I basically want to run a script on a remote machine and read it back, but implement it as a function instead of a wrapper around SSH.<p>Chatbots, where the bot only needs to be line-driven and you can connect it to any CLI chat interface. Or perhaps, run your AI agent attached to a shell, and have it treat standard IO as a shell session.</div><br/></div></div><div id="39656982" class="c"><input type="checkbox" id="c-39656982" checked=""/><div class="controls bullet"><span class="by">sebosp</span><span>|</span><a href="#39656514">parent</a><span>|</span><a href="#39657087">prev</a><span>|</span><a href="#39657173">next</a><span>|</span><label class="collapse" for="c-39656982">[-]</label><label class="expand" for="c-39656982">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of MIT&#x27;s open courseware, 601 SC, unit 1 with state machines, going all the way to build Fibonacci with them without recursion, tbh the moment the teacher translated the state machine to bounds to electrical circuit I felt it was a leap and I couldn&#x27;t quite understand their relationship, maybe I missed a requirement course. I tried to express that course in Rust as one of my first projects learning the language here <a href="https:&#x2F;&#x2F;github.com&#x2F;sebosp&#x2F;rustexercises&#x2F;blob&#x2F;develop&#x2F;ocw601sc%2FSession2%2Fstate_machine%2Fsrc%2Flib.rs">https:&#x2F;&#x2F;github.com&#x2F;sebosp&#x2F;rustexercises&#x2F;blob&#x2F;develop&#x2F;ocw601s...</a> and I think a similar iteration in the direction of this project would be to build the dependencies as drag-and-drop boxes over the browser (maybe egui) and connect the state machines by clicks, maybe download the generated code as either bash or compilable rust code, you know, for kids.</div><br/></div></div></div></div><div id="39657173" class="c"><input type="checkbox" id="c-39657173" checked=""/><div class="controls bullet"><span class="by">wwalexander</span><span>|</span><a href="#39656514">prev</a><span>|</span><a href="#39657526">next</a><span>|</span><label class="collapse" for="c-39657173">[-]</label><label class="expand" for="c-39657173">[2 more]</label></div><br/><div class="children"><div class="content">In the category of “command line representations of graphs” see also ffmpeg’s filtergraphs [1].<p>[1] <a href="https:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-filters.html#Filtering-Introduction" rel="nofollow">https:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-filters.html#Filtering-Introductio...</a></div><br/><div id="39657491" class="c"><input type="checkbox" id="c-39657491" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#39657173">parent</a><span>|</span><a href="#39657526">next</a><span>|</span><label class="collapse" for="c-39657491">[-]</label><label class="expand" for="c-39657491">[1 more]</label></div><br/><div class="children"><div class="content">First thing I thought about when seeing the Pipexec&#x27;s syntax, too.</div><br/></div></div></div></div><div id="39657526" class="c"><input type="checkbox" id="c-39657526" checked=""/><div class="controls bullet"><span class="by">soygem</span><span>|</span><a href="#39657173">prev</a><span>|</span><a href="#39656955">next</a><span>|</span><label class="collapse" for="c-39657526">[-]</label><label class="expand" for="c-39657526">[1 more]</label></div><br/><div class="children"><div class="content">42 pipex, we meet again</div><br/></div></div><div id="39656955" class="c"><input type="checkbox" id="c-39656955" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#39657526">prev</a><span>|</span><a href="#39657222">next</a><span>|</span><label class="collapse" for="c-39656955">[-]</label><label class="expand" for="c-39656955">[1 more]</label></div><br/><div class="children"><div class="content">This is great, thanks!</div><br/></div></div><div id="39657222" class="c"><input type="checkbox" id="c-39657222" checked=""/><div class="controls bullet"><span class="by">keithalewis</span><span>|</span><a href="#39656955">prev</a><span>|</span><a href="#39656637">next</a><span>|</span><label class="collapse" for="c-39657222">[-]</label><label class="expand" for="c-39657222">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nobody will tell you:<p>&gt; stdin, stdout and stderr are artificial definitions.<p>Unless you RTFM.</div><br/></div></div><div id="39656637" class="c"><input type="checkbox" id="c-39656637" checked=""/><div class="controls bullet"><span class="by">pipeline_peak</span><span>|</span><a href="#39657222">prev</a><span>|</span><label class="collapse" for="c-39656637">[-]</label><label class="expand" for="c-39656637">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t this exactly what shell scripting is for?</div><br/></div></div></div></div></div></div></div></body></html>