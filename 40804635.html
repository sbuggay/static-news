<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719478854745" as="style"/><link rel="stylesheet" href="styles.css?v=1719478854745"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://quuxplusone.github.io/blog/2024/06/25/most-stl-ctors-arent-explicit-but-yours-still-should-be/">How the STL Uses Explicit</a> <span class="domain">(<a href="https://quuxplusone.github.io">quuxplusone.github.io</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>25 comments</span></div><br/><div><div id="40807313" class="c"><input type="checkbox" id="c-40807313" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40808249">next</a><span>|</span><label class="collapse" for="c-40807313">[-]</label><label class="expand" for="c-40807313">[8 more]</label></div><br/><div class="children"><div class="content">How can the C++ statement below even compile?  Since &quot;1&quot; and &quot;2&quot; are strings (not even chars).<p><pre><code>  std::vector&lt;int&gt; v = {&quot;1&quot;, &quot;2&quot;} &#x2F;&#x2F; UB
</code></pre>
Rather than undefined behavior I&#x27;d expect a type violation error.  But my C++ has gotten a bit rusty.</div><br/><div id="40807551" class="c"><input type="checkbox" id="c-40807551" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40807313">parent</a><span>|</span><a href="#40807556">next</a><span>|</span><label class="collapse" for="c-40807551">[-]</label><label class="expand" for="c-40807551">[2 more]</label></div><br/><div class="children"><div class="content"><i>It&#x27;s simple</i>: &quot;string&quot; literals in C++ are pointers to characters. std::vector has a constructor which takes a begin and end iterator and creates a vector with contents copied from that range. Pointers are iterators in C++, and chars are implicitly convertible to ints, so overload resolution selects the aforementioned constructor. The pointer to &quot;1&quot; and the pointer to &quot;2&quot; don&#x27;t point into the same object, so trying to iterate from one to the other eventually causes a dereference past the end of &quot;1&quot; which is undefined behavior.</div><br/><div id="40807616" class="c"><input type="checkbox" id="c-40807616" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40807313">root</a><span>|</span><a href="#40807551">parent</a><span>|</span><a href="#40807556">next</a><span>|</span><label class="collapse" for="c-40807616">[-]</label><label class="expand" for="c-40807616">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about <i>simple</i>, haha, but thank you so much for explaining in depth!</div><br/></div></div></div></div><div id="40807556" class="c"><input type="checkbox" id="c-40807556" checked=""/><div class="controls bullet"><span class="by">mwkaufma</span><span>|</span><a href="#40807313">parent</a><span>|</span><a href="#40807551">prev</a><span>|</span><a href="#40807491">next</a><span>|</span><label class="collapse" for="c-40807556">[-]</label><label class="expand" for="c-40807556">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s matching std::vector&#x27;s implicit constructor which takes two iterators, which can be initialized with any pointer. Note that it won&#x27;t compile with one, three, or more string-literal char*s, but exactly two.</div><br/><div id="40807605" class="c"><input type="checkbox" id="c-40807605" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40807313">root</a><span>|</span><a href="#40807556">parent</a><span>|</span><a href="#40807491">next</a><span>|</span><label class="collapse" for="c-40807605">[-]</label><label class="expand" for="c-40807605">[3 more]</label></div><br/><div class="children"><div class="content">Why only exactly two?<p>The whole &quot;UB but it still compiles&quot; thing, is pretty gross.</div><br/><div id="40807773" class="c"><input type="checkbox" id="c-40807773" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40807313">root</a><span>|</span><a href="#40807605">parent</a><span>|</span><a href="#40807491">next</a><span>|</span><label class="collapse" for="c-40807773">[-]</label><label class="expand" for="c-40807773">[2 more]</label></div><br/><div class="children"><div class="content">Because the constructor takes two arguments, a &quot;begin&quot; iterator and an &quot;end&quot; iterator.  And pointers count as valid iterators.<p>Normally you wouldn&#x27;t use the &quot;= {}&quot; syntax to invoke a constructor this way.  Instead of `std::vector&lt;int&gt; v = {begin, end}` you would usually write `std::vector&lt;int&gt; v(begin, end)`.  But for some reason C++11 decided to make those two things mostly equivalent.</div><br/><div id="40808614" class="c"><input type="checkbox" id="c-40808614" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40807313">root</a><span>|</span><a href="#40807773">parent</a><span>|</span><a href="#40807491">next</a><span>|</span><label class="collapse" for="c-40808614">[-]</label><label class="expand" for="c-40808614">[1 more]</label></div><br/><div class="children"><div class="content">List initialization is quite nice, but the interaction with brace initialization introduced at the same time is a giant foot-gun.</div><br/></div></div></div></div></div></div></div></div><div id="40807491" class="c"><input type="checkbox" id="c-40807491" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#40807313">parent</a><span>|</span><a href="#40807556">prev</a><span>|</span><a href="#40808249">next</a><span>|</span><label class="collapse" for="c-40807491">[-]</label><label class="expand" for="c-40807491">[1 more]</label></div><br/><div class="children"><div class="content">Id argue that c++ is not type safe. 
Yes, strings could be converted to ints in theory, but these types are obviously not the same, why not make it more explicit?</div><br/></div></div></div></div><div id="40806193" class="c"><input type="checkbox" id="c-40806193" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#40808249">prev</a><span>|</span><a href="#40806425">next</a><span>|</span><label class="collapse" for="c-40806193">[-]</label><label class="expand" for="c-40806193">[8 more]</label></div><br/><div class="children"><div class="content">Was there ever a reason given as to why “explicit” was chosen over a hypothetical “implicit”?</div><br/><div id="40806782" class="c"><input type="checkbox" id="c-40806782" checked=""/><div class="controls bullet"><span class="by">cjensen</span><span>|</span><a href="#40806193">parent</a><span>|</span><a href="#40808290">next</a><span>|</span><label class="collapse" for="c-40806782">[-]</label><label class="expand" for="c-40806782">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, but a hypothetical &#x27;implicit&#x27; would mean converting all unmarked constructors into explicit constructors... which would have broken a lot of existing code.</div><br/></div></div><div id="40808290" class="c"><input type="checkbox" id="c-40808290" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40806193">parent</a><span>|</span><a href="#40806782">prev</a><span>|</span><a href="#40806363">next</a><span>|</span><label class="collapse" for="c-40808290">[-]</label><label class="expand" for="c-40808290">[1 more]</label></div><br/><div class="children"><div class="content">Many of the original C++ decisions come back to how it was supposed to be Typescript for C, which was a reason why it became widely used, and why some warts are the way they are.<p>Like having C structs magically turn into C++ ones, thus implicit rules like these.<p>Anyone that cares about C++ evolution should read &quot;Design and Evolution of C++&quot;, not only for how it came to be, also for safety approaches over plain C, that Bjarne is stil arguing for to this day on WG21 meetings.</div><br/></div></div><div id="40806363" class="c"><input type="checkbox" id="c-40806363" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#40806193">parent</a><span>|</span><a href="#40808290">prev</a><span>|</span><a href="#40806425">next</a><span>|</span><label class="collapse" for="c-40806363">[-]</label><label class="expand" for="c-40806363">[5 more]</label></div><br/><div class="children"><div class="content">In C++ because of how it developed the defaults are not optimal. For example, constructors and conversions are implicit and you have to make them explicit. Variables are default mutable and you have to make them const. Local primitive variables are default unitialized by default.</div><br/><div id="40806501" class="c"><input type="checkbox" id="c-40806501" checked=""/><div class="controls bullet"><span class="by">JTyQZSnP3cQGa8B</span><span>|</span><a href="#40806193">root</a><span>|</span><a href="#40806363">parent</a><span>|</span><a href="#40806425">next</a><span>|</span><label class="collapse" for="c-40806501">[-]</label><label class="expand" for="c-40806501">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Variables are default mutable and you have to make them const<p>Except for the captured variables in a lambda which are const unless you use the mutable keyword. Not a bad idea though.</div><br/><div id="40806618" class="c"><input type="checkbox" id="c-40806618" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40806193">root</a><span>|</span><a href="#40806501">parent</a><span>|</span><a href="#40806425">next</a><span>|</span><label class="collapse" for="c-40806618">[-]</label><label class="expand" for="c-40806618">[3 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s only true if you capture by value. If you capture by reference they remain mutable.</div><br/><div id="40807493" class="c"><input type="checkbox" id="c-40807493" checked=""/><div class="controls bullet"><span class="by">chombier</span><span>|</span><a href="#40806193">root</a><span>|</span><a href="#40806618">parent</a><span>|</span><a href="#40806425">next</a><span>|</span><label class="collapse" for="c-40807493">[-]</label><label class="expand" for="c-40807493">[2 more]</label></div><br/><div class="children"><div class="content">I think this is because `mutable` qualifies the call operator of the lambda (like a reverse const qualifier) so by-value captures are effectively const during the call unless the lambda is marked `mutable`. References <i>themselves</i> are always const, but the referenced object may be modified through the reference depending on its constness even though the lambda is not `mutable`.<p>Is there a way to force capture by const-reference by the way?</div><br/><div id="40808639" class="c"><input type="checkbox" id="c-40808639" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40806193">root</a><span>|</span><a href="#40807493">parent</a><span>|</span><a href="#40806425">next</a><span>|</span><label class="collapse" for="c-40808639">[-]</label><label class="expand" for="c-40808639">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  int main() {
     int x = 0;
     [&amp;x] { x= 1;}(); &#x2F;&#x2F; works
     [&amp;x=std::as_const(x)] { x= 1;}(); &#x2F;&#x2F; error: assignment of read-only reference &#x27;x&#x27;
   }
</code></pre>
Not very pretty, but it works.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40806425" class="c"><input type="checkbox" id="c-40806425" checked=""/><div class="controls bullet"><span class="by">geerlingguy</span><span>|</span><a href="#40806193">prev</a><span>|</span><label class="collapse" for="c-40806425">[-]</label><label class="expand" for="c-40806425">[7 more]</label></div><br/><div class="children"><div class="content">STL is overloaded - it seems like St. Louis is mentioned, but this has to do with the Standard Template Library? And there&#x27;s Studio-Transmitter Links in radio and 3D .stl files...<p>Edit: After searching the event name, it looks like it&#x27;s a C++ standards convention that&#x27;s meeting in St. Louis &#x2F; STL (MO, USA) this week, and one of the topics of discussion is the C++ STL (Standard Template Library).</div><br/><div id="40807407" class="c"><input type="checkbox" id="c-40807407" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40806425">parent</a><span>|</span><a href="#40808439">next</a><span>|</span><label class="collapse" for="c-40807407">[-]</label><label class="expand" for="c-40807407">[5 more]</label></div><br/><div class="children"><div class="content">Even if you think STL means St Louis, you can&#x27;t make that sentence confusing becasue none of those other potential uses work in this place.<p>eg &quot;The St Louis&quot; is only a possible construction if you put another noun after it like &quot;How the STL cardinals handle the pressure of big games&quot; (I don&#x27;t know, I don&#x27;t really do sports but you get the idea that&#x27;s a valid sentence).<p>You can&#x27;t have a sentence &quot;How the STL uses explicit&quot; be at all confusing with any of the examples you gave.</div><br/><div id="40807819" class="c"><input type="checkbox" id="c-40807819" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40806425">root</a><span>|</span><a href="#40807407">parent</a><span>|</span><a href="#40808439">next</a><span>|</span><label class="collapse" for="c-40807819">[-]</label><label class="expand" for="c-40807819">[4 more]</label></div><br/><div class="children"><div class="content">At least grammatically &quot;the St. Louis&quot; could make sense if you read it as referring to the namesake of the city. &quot;Who was that guy using explicit contstructors, King Louis XIV?&quot; &quot;No, it was the _Saint_ Louis!&quot;<p>I assume that no one named Louis has been canonized since C++ was invented though, and even if it was, using &quot;the&quot; might not be enough to disambiguate in some contexts.</div><br/><div id="40808591" class="c"><input type="checkbox" id="c-40808591" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40806425">root</a><span>|</span><a href="#40807819">parent</a><span>|</span><a href="#40808610">next</a><span>|</span><label class="collapse" for="c-40808591">[-]</label><label class="expand" for="c-40808591">[1 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;re obliged to omit &quot;Louis&quot; here? Certainly I would feel I can&#x27;t add this superfluous word, whereas in some cases such words are optional I don&#x27;t think one is here.<p>I can say &quot;No, it was the Saint&quot; and &quot;No, it was <i>Saint</i> Louis&quot; but I don&#x27;t think I&#x27;d utter &quot;No, it was <i>the</i> Saint Louis&quot; except as a speech error, maybe prompted by rushing like a Colemanball (commonly sports commentators mix metaphors or change their minds about intent midway through an utterance as of course they&#x27;re live and events are unfolding as they speak, e.g. &quot;That was a decisive mistake although nothing is decided yet&quot;).</div><br/></div></div><div id="40808610" class="c"><input type="checkbox" id="c-40808610" checked=""/><div class="controls bullet"><span class="by">_old_dude_</span><span>|</span><a href="#40806425">root</a><span>|</span><a href="#40807819">parent</a><span>|</span><a href="#40808591">prev</a><span>|</span><a href="#40808117">next</a><span>|</span><label class="collapse" for="c-40808610">[-]</label><label class="expand" for="c-40808610">[1 more]</label></div><br/><div class="children"><div class="content">BTW, Saint Louis is the common name of Louis IX not Louis XIV (the Sun King).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Louis_IX_of_France" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Louis_IX_of_France</a></div><br/></div></div><div id="40808117" class="c"><input type="checkbox" id="c-40808117" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40806425">root</a><span>|</span><a href="#40807819">parent</a><span>|</span><a href="#40808610">prev</a><span>|</span><a href="#40808439">next</a><span>|</span><label class="collapse" for="c-40808117">[-]</label><label class="expand" for="c-40808117">[1 more]</label></div><br/><div class="children"><div class="content">...but do we know how the Saint Louis uses explicit? Catholic would-be C++ experts are dying to know.</div><br/></div></div></div></div></div></div><div id="40808439" class="c"><input type="checkbox" id="c-40808439" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40806425">parent</a><span>|</span><a href="#40807407">prev</a><span>|</span><label class="collapse" for="c-40808439">[-]</label><label class="expand" for="c-40808439">[1 more]</label></div><br/><div class="children"><div class="content">The C++ standard library isn&#x27;t even officially called the STL - that name just carried over from the SGI STL [0] that inspired some of it.<p>[0] <a href="https:&#x2F;&#x2F;www.boost.org&#x2F;sgi&#x2F;stl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.boost.org&#x2F;sgi&#x2F;stl&#x2F;</a> (archive)</div><br/></div></div></div></div></div></div></div></div></div></body></html>