<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723453264502" as="style"/><link rel="stylesheet" href="styles.css?v=1723453264502"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jvns.ca/blog/2024/08/06/go-structs-copied-on-assignment/">Go structs are copied on assignment (and other things about Go I&#x27;d missed)</a> <span class="domain">(<a href="https://jvns.ca">jvns.ca</a>)</span></div><div class="subtext"><span>misonic</span> | <span>85 comments</span></div><br/><div><div id="41222516" class="c"><input type="checkbox" id="c-41222516" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#41220913">next</a><span>|</span><label class="collapse" for="c-41222516">[-]</label><label class="expand" for="c-41222516">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    thing := Thing{...}
    other_thing := thing
    pinter_to_same_thing := &amp;thing
</code></pre>
ALL types in go are being copied by value. There is no such thing as a &quot;reference&quot; in this language. Even a slice or map is just a small struct with some syntactic sugar provided by the language, and when you assign a slice to another variable, you are, in fact, creating a copy of that struct.</div><br/></div></div><div id="41220913" class="c"><input type="checkbox" id="c-41220913" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41222516">prev</a><span>|</span><a href="#41222472">next</a><span>|</span><label class="collapse" for="c-41220913">[-]</label><label class="expand" for="c-41220913">[7 more]</label></div><br/><div class="children"><div class="content">The semantics of when stuff is copied, moved, or passed by reference are all over the place in language design.<p>C started with the idea that functions returned one int-sized value in a register. This led to classic bugs where the function returns a pointer to a local value. Compilers now usually catch this. C eventually got structure return by copy. Then C++ added return value by move, and automatic optimization for that. It&#x27;s complicated.[1]<p>Most hard-compiled languages only let you return values of fixed length, because the caller has to allocate space. Dynamic languages where most things are boxed just return the box.
Rust makes you declare boxed types explicitly. Vec and String are already boxed, which handles the common cases.<p>More dynamic languages tend to let you return anything, although there can be questions over whether you have your own mutable copy, a copy-on-write copy, a read-only copy, or a mutable reference to the original. That&#x27;s what got the OP here, at<p><pre><code>    thing := findThing(things, &quot;record&quot;)
    thing.Name = &quot;gramaphone&quot;
</code></pre>
They thought they had a mutable reference to the original, but they had a mutable copy.<p>There&#x27;s a good argument for immutability by default, but many programmers dislike all the extra declarations required.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;17473753&#x2F;c11-return-value-optimization-or-move" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;17473753&#x2F;c11-return-valu...</a></div><br/><div id="41221719" class="c"><input type="checkbox" id="c-41221719" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#41220913">parent</a><span>|</span><a href="#41222129">next</a><span>|</span><label class="collapse" for="c-41221719">[-]</label><label class="expand" for="c-41221719">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a good argument for immutability by default, but many programmers dislike all the extra declarations required.<p>That&#x27;s one little reason why Rust is loved by many: immutability by default. Meanwhile, it&#x27;s not even possible in Go to declare immutable variables!</div><br/><div id="41222313" class="c"><input type="checkbox" id="c-41222313" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41220913">root</a><span>|</span><a href="#41221719">parent</a><span>|</span><a href="#41222379">next</a><span>|</span><label class="collapse" for="c-41222313">[-]</label><label class="expand" for="c-41222313">[1 more]</label></div><br/><div class="children"><div class="content">I hope it gets added, it adds so much safety to the language. Mind you, Go is not a very safe language in general, its type system is pretty loose compared to e.g. Java or Typescript. I don&#x27;t believe it wants to be though.</div><br/></div></div><div id="41222379" class="c"><input type="checkbox" id="c-41222379" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#41220913">root</a><span>|</span><a href="#41221719">parent</a><span>|</span><a href="#41222313">prev</a><span>|</span><a href="#41222129">next</a><span>|</span><label class="collapse" for="c-41222379">[-]</label><label class="expand" for="c-41222379">[1 more]</label></div><br/><div class="children"><div class="content">Immutable by default is only really possible now that we have gobs of memory though. I&#x27;m not even sure it&#x27;s likely to stay popular: the demands of data processing at scale mean we&#x27;re all likely to be routinely handling gigantic datasets which we don&#x27;t want to copy all over the place.<p>The real problem is just visibility: am I editing a copy of the original? Who else can edit the original? Who&#x27;s going to?<p>I&#x27;d argue those two questions are what we actually want to know the answer to, and immutability criteria are just an awkward compromise solution.</div><br/></div></div></div></div><div id="41222129" class="c"><input type="checkbox" id="c-41222129" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#41220913">parent</a><span>|</span><a href="#41221719">prev</a><span>|</span><a href="#41221285">next</a><span>|</span><label class="collapse" for="c-41222129">[-]</label><label class="expand" for="c-41222129">[1 more]</label></div><br/><div class="children"><div class="content">The one thing I’ve personally wanted in Go is something like final in Java, for structs.</div><br/></div></div><div id="41221285" class="c"><input type="checkbox" id="c-41221285" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#41220913">parent</a><span>|</span><a href="#41222129">prev</a><span>|</span><a href="#41222472">next</a><span>|</span><label class="collapse" for="c-41221285">[-]</label><label class="expand" for="c-41221285">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This led to classic bugs where the function returns a pointer to a local value. Compilers now usually catch this. C eventually got structure return by copy. Then C++ added return value by move, and automatic optimization for that.<p>Jesus Christ. Can we now get “return fruit by vegetable?”<p>Some speedups may not be worth having to memorize standards documents.</div><br/><div id="41221598" class="c"><input type="checkbox" id="c-41221598" checked=""/><div class="controls bullet"><span class="by">Aeglaecia</span><span>|</span><a href="#41220913">root</a><span>|</span><a href="#41221285">parent</a><span>|</span><a href="#41222472">next</a><span>|</span><label class="collapse" for="c-41221598">[-]</label><label class="expand" for="c-41221598">[1 more]</label></div><br/><div class="children"><div class="content">programmers who get the job done without needing to memorise standards or dig into hardware specifics are surely happy enough with general optimisations applied by the compiler like tail call optimisation or copy elision ...</div><br/></div></div></div></div></div></div><div id="41222472" class="c"><input type="checkbox" id="c-41222472" checked=""/><div class="controls bullet"><span class="by">jiripospisil</span><span>|</span><a href="#41220913">prev</a><span>|</span><a href="#41219487">next</a><span>|</span><label class="collapse" for="c-41222472">[-]</label><label class="expand" for="c-41222472">[1 more]</label></div><br/><div class="children"><div class="content">Another thing to watch out for is that &quot;defer&quot; in Go is executed at the end of the function, not at the end of the current scope. This makes it not only more difficult to reason about but also much less useful.</div><br/></div></div><div id="41219487" class="c"><input type="checkbox" id="c-41219487" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41222472">prev</a><span>|</span><a href="#41213722">next</a><span>|</span><label class="collapse" for="c-41219487">[-]</label><label class="expand" for="c-41219487">[9 more]</label></div><br/><div class="children"><div class="content">One of the many things I find inspiring about Julia is how quick she is to admit to mistakes she has made or things that she hasn&#x27;t understood.<p>If she didn&#x27;t understand it, I can 100% guarantee that there are large numbers of people out there who also didn&#x27;t understand it - many of whom were probably too embarrassed to ever admit it.<p>I think this is a useful trait for senior software engineers generally. If you&#x27;re a senior engineer you should have earned enough of a reputation that the risk involved in admitting &quot;I didn&#x27;t know that&quot; can be offset by everything you provably DO know already. As such, you can help everyone else out by admitting to those gaps in your knowledge and helping emphasize that nobody knows everything and it&#x27;s OK to take pride in filling those knowledge gaps when you come across them.</div><br/><div id="41219883" class="c"><input type="checkbox" id="c-41219883" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#41219487">parent</a><span>|</span><a href="#41220272">next</a><span>|</span><label class="collapse" for="c-41219883">[-]</label><label class="expand" for="c-41219883">[4 more]</label></div><br/><div class="children"><div class="content">Personally, I think that the idea that programmers should know everything is kinda bizarre.<p>Programming is about finding the answer. If you already knew everything, you could just sit down and type any program from your knowledge.<p>We all know that you can&#x27;t know everything otherwise, why even write documentation or use git?<p>Unfortunately, it&#x27;s difficult to move past this idea, and it&#x27;s so pervasive that stating &quot;I don&#x27;t know&quot; can negatively affect your standing for some.</div><br/><div id="41222408" class="c"><input type="checkbox" id="c-41222408" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#41219487">root</a><span>|</span><a href="#41219883">parent</a><span>|</span><a href="#41220010">next</a><span>|</span><label class="collapse" for="c-41222408">[-]</label><label class="expand" for="c-41222408">[1 more]</label></div><br/><div class="children"><div class="content">Many people have the same expectation of their doctor: he must know everything or he is completely useless and I should find a new doctor.<p>It is also insanely difficult for a doctor&#x2F;surgeon to admit a mistake without being punished severly.</div><br/></div></div><div id="41220010" class="c"><input type="checkbox" id="c-41220010" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41219487">root</a><span>|</span><a href="#41219883">parent</a><span>|</span><a href="#41222408">prev</a><span>|</span><a href="#41220272">next</a><span>|</span><label class="collapse" for="c-41220010">[-]</label><label class="expand" for="c-41220010">[2 more]</label></div><br/><div class="children"><div class="content">Right! The best thing about our chosen career is that it&#x27;s completely impossible to know everything - there&#x27;s always a new corner of software engineering to dig into, be it how the Linux kernel works, or programming with Haskell, understanding Transformer LLM architectures, or how the Svelte compiler works or whatever.</div><br/><div id="41222420" class="c"><input type="checkbox" id="c-41222420" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#41219487">root</a><span>|</span><a href="#41220010">parent</a><span>|</span><a href="#41220272">next</a><span>|</span><label class="collapse" for="c-41222420">[-]</label><label class="expand" for="c-41222420">[1 more]</label></div><br/><div class="children"><div class="content">... and be able to code in React</div><br/></div></div></div></div></div></div><div id="41220272" class="c"><input type="checkbox" id="c-41220272" checked=""/><div class="controls bullet"><span class="by">jsmeaton</span><span>|</span><a href="#41219487">parent</a><span>|</span><a href="#41219883">prev</a><span>|</span><a href="#41220697">next</a><span>|</span><label class="collapse" for="c-41220272">[-]</label><label class="expand" for="c-41220272">[1 more]</label></div><br/><div class="children"><div class="content">This is what jumped out to me reading this article too - unashamedly admitting to having gaps in knowledge that some others might take for granted.<p>Bucketing some of those gaps as “probably useful but not to me right now” is also great. It shows a purpose to focus on what matters right now, with a hint to return to when it does pop up again later.<p>Lots of folks I work with and respect sometimes get trapped in the weeds having to understand every little thing. It’s good to be curious, but sometimes filing it away for later and shipping is more important now.</div><br/></div></div><div id="41220697" class="c"><input type="checkbox" id="c-41220697" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#41219487">parent</a><span>|</span><a href="#41220272">prev</a><span>|</span><a href="#41220261">next</a><span>|</span><label class="collapse" for="c-41220697">[-]</label><label class="expand" for="c-41220697">[1 more]</label></div><br/><div class="children"><div class="content">I recently included a big goof in a blog post. I accidentally consumed all my errors and didn&#x27;t log them anywhere, so I was just flying mostly blind.<p>It was also in a language I don&#x27;t have much experience in (Elixir), doing 3D rendering in OpenGL (which I also don&#x27;t have much experience in), on a Mac (so no tools to debug OpenGL stuff). Definitely wasted more time than I&#x27;d like to admit, but I won&#x27;t be making that mistake again. :)</div><br/></div></div><div id="41220261" class="c"><input type="checkbox" id="c-41220261" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#41219487">parent</a><span>|</span><a href="#41220697">prev</a><span>|</span><a href="#41213722">next</a><span>|</span><label class="collapse" for="c-41220261">[-]</label><label class="expand" for="c-41220261">[2 more]</label></div><br/><div class="children"><div class="content">most of the time when people don&#x27;t ask questions in industry, it isn&#x27;t because they already know the answers, it&#x27;s because they don&#x27;t care what the answers are<p>blogging is culturally different because there&#x27;s way more exhibitionism involved</div><br/><div id="41222451" class="c"><input type="checkbox" id="c-41222451" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41219487">root</a><span>|</span><a href="#41220261">parent</a><span>|</span><a href="#41213722">next</a><span>|</span><label class="collapse" for="c-41222451">[-]</label><label class="expand" for="c-41222451">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t you think, as others in this thread are saying, that one reason people don&#x27;t ask questions is because they&#x27;re afraid to admit their lack of knowledge?<p>We&#x27;ve probably all been in one of those meetings where something is being proposed, and everyone is nodding vaguely along but you&#x27;re not sure the proposal is correct. Do you ask a clarifying question (and risk seeming foolish for not knowing something obvious) or just let it pass because everyone else seems happy with it?</div><br/></div></div></div></div></div></div><div id="41213722" class="c"><input type="checkbox" id="c-41213722" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41219487">prev</a><span>|</span><a href="#41222198">next</a><span>|</span><label class="collapse" for="c-41213722">[-]</label><label class="expand" for="c-41213722">[4 more]</label></div><br/><div class="children"><div class="content">Donovan and Kernighan&#x27;s &quot;The Go Programming Language&quot; is one of the best pieces of technical writing I&#x27;ve ever read. Buy it and read it cover to cover.<p>Then read the [Go Language Specification][1] cover to cover. It&#x27;s dry but refreshingly not legalese.<p>[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec</a></div><br/><div id="41220810" class="c"><input type="checkbox" id="c-41220810" checked=""/><div class="controls bullet"><span class="by">trentnix</span><span>|</span><a href="#41213722">parent</a><span>|</span><a href="#41219802">next</a><span>|</span><label class="collapse" for="c-41220810">[-]</label><label class="expand" for="c-41220810">[2 more]</label></div><br/><div class="children"><div class="content"><i>Learning Go</i> by Jon Bodner, particularly the newest edition, is also excellent.<p>An aside: are there any other Go books, particularly ones the explore more specific topics, that are recommended? I&#x27;ve read a few that I didn&#x27;t find very impressive.</div><br/><div id="41221114" class="c"><input type="checkbox" id="c-41221114" checked=""/><div class="controls bullet"><span class="by">pss314</span><span>|</span><a href="#41213722">root</a><span>|</span><a href="#41220810">parent</a><span>|</span><a href="#41219802">next</a><span>|</span><label class="collapse" for="c-41221114">[-]</label><label class="expand" for="c-41221114">[1 more]</label></div><br/><div class="children"><div class="content">I liked Cloud Native Go by Matthew A. Titmus and Concurrency in Go by Katherine Cox-Buday.</div><br/></div></div></div></div><div id="41219802" class="c"><input type="checkbox" id="c-41219802" checked=""/><div class="controls bullet"><span class="by">heyoni</span><span>|</span><a href="#41213722">parent</a><span>|</span><a href="#41220810">prev</a><span>|</span><a href="#41222198">next</a><span>|</span><label class="collapse" for="c-41219802">[-]</label><label class="expand" for="c-41219802">[1 more]</label></div><br/><div class="children"><div class="content">The language spec was so good I was able to make tangible contributions to an open source project just by using that and I don’t consider myself a go programmer at all.
 I want to buy that book but it’s technical and I feel like there might be a second edition around the corner?<p>&#x2F;edit I bought it after reading this thread: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;U99js3UYz-U" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;U99js3UYz-U</a></div><br/></div></div></div></div><div id="41222198" class="c"><input type="checkbox" id="c-41222198" checked=""/><div class="controls bullet"><span class="by">geoka9</span><span>|</span><a href="#41213722">prev</a><span>|</span><a href="#41213730">next</a><span>|</span><label class="collapse" for="c-41222198">[-]</label><label class="expand" for="c-41222198">[1 more]</label></div><br/><div class="children"><div class="content">A (shameless) plug: I&#x27;ve been building a collection of Go bits like this. Hopefully it can be useful to someone other than me, too:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;geokat&#x2F;easygo">https:&#x2F;&#x2F;github.com&#x2F;geokat&#x2F;easygo</a></div><br/></div></div><div id="41213730" class="c"><input type="checkbox" id="c-41213730" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41222198">prev</a><span>|</span><a href="#41220155">next</a><span>|</span><label class="collapse" for="c-41213730">[-]</label><label class="expand" for="c-41213730">[12 more]</label></div><br/><div class="children"><div class="content">Not understanding structs vs pointers is a pretty basic misconception in go.<p>Does this trip anyone else up?  I found it unenlightening &#x2F; unsurprising, and the linked &quot;100 mistakes&quot; piece also very basic and in some cases just plain wrong.</div><br/><div id="41219462" class="c"><input type="checkbox" id="c-41219462" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41213730">parent</a><span>|</span><a href="#41219497">next</a><span>|</span><label class="collapse" for="c-41219462">[-]</label><label class="expand" for="c-41219462">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Very basic&quot; is the entire point of this exercise. Just because things are basic doesn&#x27;t mean people won&#x27;t misunderstand them, and won&#x27;t benefit from clarification.<p>Which of those 100 mistakes were &quot;plain wrong&quot;? That would be useful feedback for the author.</div><br/></div></div><div id="41219497" class="c"><input type="checkbox" id="c-41219497" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41213730">parent</a><span>|</span><a href="#41219462">prev</a><span>|</span><a href="#41220295">next</a><span>|</span><label class="collapse" for="c-41219497">[-]</label><label class="expand" for="c-41219497">[8 more]</label></div><br/><div class="children"><div class="content">As she points out though, a lot of dynamic languages don’t behave this way. A string after all points to a heap allocation; so it’s not unreasonable to think of a string as a pointer.</div><br/><div id="41219652" class="c"><input type="checkbox" id="c-41219652" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41219497">parent</a><span>|</span><a href="#41219819">next</a><span>|</span><label class="collapse" for="c-41219652">[-]</label><label class="expand" for="c-41219652">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve several times answered questions from people coming from dynamic languages that ask lots of questions about Go pointers. And the answer is, actually, since Go lacks pointer arithmetic, Go pointers work the way you&#x27;re used to things working. It&#x27;s the Go <i>non-</i>pointers that are the new bizarre thing you&#x27;re not used to!<p>So there is definitely a common language heritage that will find the behavior of value copies in Go surprising. I came into Go with compiled language experience but I&#x27;d been exclusively in dynamic scripting languages exclusively for over a decade. I had to remind myself about this as well.</div><br/></div></div><div id="41219819" class="c"><input type="checkbox" id="c-41219819" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41219497">parent</a><span>|</span><a href="#41219652">prev</a><span>|</span><a href="#41219729">next</a><span>|</span><label class="collapse" for="c-41219819">[-]</label><label class="expand" for="c-41219819">[1 more]</label></div><br/><div class="children"><div class="content">In those languages, nearly everything <i>is</i> a pointer, they just don&#x27;t call it that, which causes unnecessary confusion when you need to understand what&#x27;s really happening. (E.g., in Java, a String is a pointer to a string, not a string; but an int is just an int, not a pointer to an int.)</div><br/></div></div><div id="41219729" class="c"><input type="checkbox" id="c-41219729" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41219497">parent</a><span>|</span><a href="#41219819">prev</a><span>|</span><a href="#41220295">next</a><span>|</span><label class="collapse" for="c-41219729">[-]</label><label class="expand" for="c-41219729">[5 more]</label></div><br/><div class="children"><div class="content">It’s how structs work in C though, and Go is spiritually very close to C, including explicit pointer types, address-taking and dereferencing.</div><br/><div id="41220910" class="c"><input type="checkbox" id="c-41220910" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41219729">parent</a><span>|</span><a href="#41220295">next</a><span>|</span><label class="collapse" for="c-41220910">[-]</label><label class="expand" for="c-41220910">[4 more]</label></div><br/><div class="children"><div class="content">Not necessarily. A string in C is usually a char<i>. If you have a struct with a char</i> and you copy it, you copy the pointer to the backing memory. This is analogous to Go which also has a String be a pointer to the heap, but the behavior is different.<p>Go’s String is a char* that behaves like a char[] when copied.</div><br/><div id="41221711" class="c"><input type="checkbox" id="c-41221711" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41220910">parent</a><span>|</span><a href="#41221637">next</a><span>|</span><label class="collapse" for="c-41221711">[-]</label><label class="expand" for="c-41221711">[1 more]</label></div><br/><div class="children"><div class="content">Is there a typo in this? C strings are not usually structs at all. Structs also do not behave differently if they contain a char.</div><br/></div></div><div id="41221637" class="c"><input type="checkbox" id="c-41221637" checked=""/><div class="controls bullet"><span class="by">mauvia</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41220910">parent</a><span>|</span><a href="#41221711">prev</a><span>|</span><a href="#41221043">next</a><span>|</span><label class="collapse" for="c-41221637">[-]</label><label class="expand" for="c-41221637">[1 more]</label></div><br/><div class="children"><div class="content">I think the two *s merged into an italic there</div><br/></div></div><div id="41221043" class="c"><input type="checkbox" id="c-41221043" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#41213730">root</a><span>|</span><a href="#41220910">parent</a><span>|</span><a href="#41221637">prev</a><span>|</span><a href="#41220295">next</a><span>|</span><label class="collapse" for="c-41221043">[-]</label><label class="expand" for="c-41221043">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go’s String is a char* that behaves like a char[] when copied.<p>Uhh, no. A go string is (effectively) a pointer to an immutable string of characters. When you do a = b, both a and b point to the same string (i.e. each is its own string struct, containing a pointer to the exact same array of character data).<p>But if you try to get a byte[] from it, THEN it makes a copy.</div><br/></div></div></div></div></div></div></div></div><div id="41220295" class="c"><input type="checkbox" id="c-41220295" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#41213730">parent</a><span>|</span><a href="#41219497">prev</a><span>|</span><a href="#41220120">next</a><span>|</span><label class="collapse" for="c-41220295">[-]</label><label class="expand" for="c-41220295">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;m fairly new to Go, but have done plenty of work in languages with &quot;no pointers&quot; (Python, Java), with pointers (Objective-C), and with &quot;reference&#x2F;value types&quot; (Swift). I thought I was pretty proficient with all of this, but Go&#x27;s implementation was really unergonomic. It feels like it&#x27;s trying to be C, but treating it more like Swift has been more effective I&#x27;ve found. How this all interacts with nils and missing fields in structs is also not very ergonomic, and it feels like the language is obviously missing an optional type, yet I&#x27;ve not seen one used commonly yet.</div><br/></div></div></div></div><div id="41220155" class="c"><input type="checkbox" id="c-41220155" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#41213730">prev</a><span>|</span><a href="#41220167">next</a><span>|</span><label class="collapse" for="c-41220155">[-]</label><label class="expand" for="c-41220155">[9 more]</label></div><br/><div class="children"><div class="content">This sometimes catches out people C#&#x2F;.Net too, it&#x27;s a big difference between Class and Struct, Class is reference type and Struct is value type. (see fiddle below), but in practice people very rarely reach for structs, so people don&#x27;t tend to build up the muscle memory of using them, even if they intuitively understand the difference between reference types and value types from general use of other types.<p>(Fiddle demonstration for non-.Net peeps: <a href="https:&#x2F;&#x2F;dotnetfiddle.net&#x2F;apDZP5" rel="nofollow">https:&#x2F;&#x2F;dotnetfiddle.net&#x2F;apDZP5</a> ).</div><br/><div id="41220210" class="c"><input type="checkbox" id="c-41220210" checked=""/><div class="controls bullet"><span class="by">rickstanley</span><span>|</span><a href="#41220155">parent</a><span>|</span><a href="#41221646">next</a><span>|</span><label class="collapse" for="c-41220210">[-]</label><label class="expand" for="c-41220210">[6 more]</label></div><br/><div class="children"><div class="content">Non-C# developer question: what use-case&#x2F;situation would a `struct` make sense to use instead of a `class`? Just out of curiosity.<p>[Edit] Well, there&#x27;s a nice, special article for this very question: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;standard&#x2F;design-guidelines&#x2F;choosing-between-class-and-struct" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;standard&#x2F;design-gui...</a></div><br/><div id="41222383" class="c"><input type="checkbox" id="c-41222383" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#41220155">root</a><span>|</span><a href="#41220210">parent</a><span>|</span><a href="#41221411">next</a><span>|</span><label class="collapse" for="c-41222383">[-]</label><label class="expand" for="c-41222383">[1 more]</label></div><br/><div class="children"><div class="content">If they are small, then there can be a significant performance advantage to using a struct.<p>Imagine you have a Dictionary&lt;TKey,TValue&gt;. (That is, a dictionary (hash lookup) from type TKey to type TValue ).<p>Imagine your choice of key is a composite of 4 bytes, and you want to preserve the meaning of each, so let&#x27;s say you define a class (shorthand to avoid all the get&#x2F;set cruft):<p><pre><code>    class MyKey {
       byte A;
       byte B;
       byte C;
       byte D;
    }
</code></pre>
When you profile your memory usage, to your horror you discover you actually have a keysize of 64 bits for the reference to the location on the heap.<p>If however you use a struct, then your key is actually the 4 bytes that defines your key.<p>In modern .Net, you&#x27;d probably be better off defaulting to use a record type for this purpose unless you have very specific reasons for wanting fine-grained control over memory layout with the StructLayout Attribute.<p>See this article for using StructLayout:<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.runtime.interopservices.structlayoutattribute?view=net-8.0" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.runtime....</a></div><br/></div></div><div id="41221411" class="c"><input type="checkbox" id="c-41221411" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41220155">root</a><span>|</span><a href="#41220210">parent</a><span>|</span><a href="#41222383">prev</a><span>|</span><a href="#41221101">next</a><span>|</span><label class="collapse" for="c-41221411">[-]</label><label class="expand" for="c-41221411">[1 more]</label></div><br/><div class="children"><div class="content">In principle, the answer <i>should</i> be (if we ignored the language community and the model of the stdlib, which we <i>shouldn&#x27;t</i> do), that structs should be used for most things, and classes only when they are needed. There&#x27;s nothing a class can do that a struct can&#x27;t, and structs are not automatically allocated in the heap, so they take some pressure off the GC. Go showed that you can have a fully managed GC language where all types are value types, and get pretty good ergonomics. Java is adding support for value types specifically for performance reasons, and so may have a similar attitude in the far future.<p>Note that Go does have one feature that makes value types more ergonomic - the ability to explicitly take a reference to one and use it as any other variable, using the syntax of C pointers (but without pointer arithmetic). In C#, if you need a reference to a structs type, your options are more limited. There is `ref` for function parameters, but if you want to store it in a field, you need to use some class type as a box, or perhaps an array of 1 element, since there are no &quot;ref fields&quot; in this sense (there are ref fields, but they are a completely different thing, related to the &quot;ref structs&quot;).<p>Now, in working with real C# code and real C# programmers, all this is false. The community has always preferred using structs almost exclusively for small immutable values, like Color. The standard library and most C# code is not designed with wide use of structs in mind, so it&#x27;s possible various methods will copy structs unnecessarily around. People aren&#x27;t used to the semantics of structs, and there is no syntactic difference between structs and classes, so mutable structs will often cause confusion where people won&#x27;t realize they&#x27;re modifying a temporary copy instead of the modifying the original.</div><br/></div></div><div id="41221101" class="c"><input type="checkbox" id="c-41221101" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41220155">root</a><span>|</span><a href="#41220210">parent</a><span>|</span><a href="#41221411">prev</a><span>|</span><a href="#41220227">next</a><span>|</span><label class="collapse" for="c-41221101">[-]</label><label class="expand" for="c-41221101">[1 more]</label></div><br/><div class="children"><div class="content">Even if you exclude performance reasons, some things just make more sense as values rather than instances.  A good example is Color.  A Color might be an object that holds 3 integers (red, green, blue) but you want to treat it like you would a scalar value.  For example, two color instances should be equal if they contain all the same values.  Class instances all have their own identity -- two classes instances are not equal even if they contain the same values.</div><br/></div></div><div id="41220227" class="c"><input type="checkbox" id="c-41220227" checked=""/><div class="controls bullet"><span class="by">makotech221</span><span>|</span><a href="#41220155">root</a><span>|</span><a href="#41220210">parent</a><span>|</span><a href="#41221101">prev</a><span>|</span><a href="#41220308">next</a><span>|</span><label class="collapse" for="c-41220227">[-]</label><label class="expand" for="c-41220227">[1 more]</label></div><br/><div class="children"><div class="content">usually performance reasons; don&#x27;t want to allocate on the heap, contributing to GC pressure, or you want pass by copy semantics</div><br/></div></div><div id="41220308" class="c"><input type="checkbox" id="c-41220308" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41220155">root</a><span>|</span><a href="#41220210">parent</a><span>|</span><a href="#41220227">prev</a><span>|</span><a href="#41221646">next</a><span>|</span><label class="collapse" for="c-41220308">[-]</label><label class="expand" for="c-41220308">[1 more]</label></div><br/><div class="children"><div class="content">Please note that the article is quite old and does not encompass the wide variety of scenarios C# is effective at.<p>Structs are used for but not limited to: all kinds of &quot;transient&quot; data containers, pass by value semantics, precise control over layout of data in memory, low-level programming and interoperating with C&#x2F;C++, zero-cost abstractions via struct generics (ala Rust or templates in C++), lightweight wrappers over existing types, etc.<p>Most C# codebases use them without even noticing in `foreach` loops - enumerators are quite often structs, and so are Span&lt;T&gt; and Memory&lt;T&gt; (which are .NET slice types for arrays, strings and pretty much every other type of contiguous memory, including unmanaged). Tuple syntax uses structs too - `(int x, int y)` is `ValueTuple&lt;int, int&gt;` behind the scenes.<p>.NET has gotten quite good at optimizing structs, so the more general response is &quot;you use them for the same things you use structs in C, C++&quot;. Or the same reason you would pick plain T struct in Rust over Box&#x2F;Arc&lt;T&gt;.<p>Intro to structs: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-reference&#x2F;builtin-types&#x2F;struct" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-ref...</a></div><br/></div></div></div></div><div id="41221646" class="c"><input type="checkbox" id="c-41221646" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41220155">parent</a><span>|</span><a href="#41220210">prev</a><span>|</span><a href="#41221653">next</a><span>|</span><label class="collapse" for="c-41221646">[-]</label><label class="expand" for="c-41221646">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t something that unsual though, from some oldies to newer ones, Delphi, Oberon variants, Modula-3, Common Lisp, Eiffel, D, Swift, and eventually Java (when <i>value class</i> and <i>value record</i> finally lands, EA available)<p>It is the focus on managed scripting languages, that trips people up, when they finally change to one of those compiled ones.</div><br/></div></div></div></div><div id="41220167" class="c"><input type="checkbox" id="c-41220167" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41220155">prev</a><span>|</span><a href="#41220653">next</a><span>|</span><label class="collapse" for="c-41220167">[-]</label><label class="expand" for="c-41220167">[1 more]</label></div><br/><div class="children"><div class="content">&gt; though apparently structs will be automatically copied on assignment if the struct implements the Copy trait<p>What&#x27;s actually going on is that the Rust compiler is always allowed to choose  whether to just copy bits during assignment, but if your type implements Copy then the value isn&#x27;t gone after it has been assigned as it would be with the ordinary destructive move assignment semantic -- so any code can continue to use the value whereas otherwise it would no longer exist having been moved.<p>Some languages make the built-in types magic and you can&#x27;t have that magic in your own types, Rust mostly resists this, a few things are magic in the stdlib and you wouldn&#x27;t be allowed to do this magic in stable Rust (it&#x27;s available to you in nightly) but mostly, as with Copy, your types are just as good as the built-in types.<p>This actually feels really natural after not long in my experience.</div><br/></div></div><div id="41220653" class="c"><input type="checkbox" id="c-41220653" checked=""/><div class="controls bullet"><span class="by">maerF0x0</span><span>|</span><a href="#41220167">prev</a><span>|</span><a href="#41214759">next</a><span>|</span><label class="collapse" for="c-41220653">[-]</label><label class="expand" for="c-41220653">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    func findThing(things []Thing, name string) *Thing {
      for i := range things {
        if things[i].Name == name {
          return &amp;things[i]
        }
      }
      return nil
    }
</code></pre>
Also you could just return i or -1, and the consuming code would be clear about what it was doing. Find the index. Update the item at the index.<p><pre><code>    if location := findThing(things, name); location != -1 {
         things[location].Name = &quot;updated&quot;
    }</code></pre></div><br/></div></div><div id="41214759" class="c"><input type="checkbox" id="c-41214759" checked=""/><div class="controls bullet"><span class="by">zuzuleinen</span><span>|</span><a href="#41220653">prev</a><span>|</span><a href="#41219510">next</a><span>|</span><label class="collapse" for="c-41214759">[-]</label><label class="expand" for="c-41214759">[23 more]</label></div><br/><div class="children"><div class="content">To generalize the title into a rule is good to remember that in Go everything is passed by value(copy).</div><br/><div id="41219674" class="c"><input type="checkbox" id="c-41219674" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41214759">parent</a><span>|</span><a href="#41220117">next</a><span>|</span><label class="collapse" for="c-41219674">[-]</label><label class="expand" for="c-41219674">[17 more]</label></div><br/><div class="children"><div class="content">That is the case for almost every modern language. C++ is one of the few languages that has &quot;references&quot; and at least last I looked that&#x27;s a language accommodation over what are pointers being passed by value in the assembly, at least until compiler optimizations take over (and that&#x27;s not limited to references either).<p>If you&#x27;re in 2024 and you&#x27;re in some programming class making a big deal about pass-by-value versus pass-by-reference, ask for your money back and find a course based in this century. Almost literally any topic is a better use of valuable class time than that. From what I&#x27;ve seen of the few unfortunate souls suffering through such a curriculum in recent times is that it literally anti-educates them.</div><br/><div id="41221906" class="c"><input type="checkbox" id="c-41221906" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41219674">parent</a><span>|</span><a href="#41220264">next</a><span>|</span><label class="collapse" for="c-41221906">[-]</label><label class="expand" for="c-41221906">[1 more]</label></div><br/><div class="children"><div class="content">For a last-century example of actual pass-by-reference, assign-by-copy, the PL&#x2F;I program<p><pre><code>  foo: proc options(main);
    dcl sysprint print;
    dcl a(3) fixed bin(31) init(1,2,3);
    put skip data (a);
    call bar(a);
    put skip data (a);
  
  bar: proc(x);
    dcl x(3) fixed bin(31);
    dcl b(3) fixed bin(31) init(3,2,1);
    x = b;
    b(1) = 42;
    x(2) = 42;
    put skip data (b);
    put skip data (x);
  end bar;
  
  end foo;
</code></pre>
outputs<p><pre><code>  A(1)=   1   A(2)=   2   A(3)=   3 ;
  B(1)=  42   B(2)=   2   B(3)=   1 ;
  X(1)=   3   X(2)=  42   X(3)=   1 ;
  A(1)=   3   A(2)=  42   A(3)=   1 ;
</code></pre>
demonstrating that X refers to A in BAR and assigning B to X copies B into X (= A).</div><br/></div></div><div id="41220264" class="c"><input type="checkbox" id="c-41220264" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41219674">parent</a><span>|</span><a href="#41221906">prev</a><span>|</span><a href="#41220319">next</a><span>|</span><label class="collapse" for="c-41220264">[-]</label><label class="expand" for="c-41220264">[4 more]</label></div><br/><div class="children"><div class="content">Is copying huge blocks of data <i>free</i> in 2024?  My benchmarks suggest otherwise, and the world still needs assembly programmers.</div><br/><div id="41221469" class="c"><input type="checkbox" id="c-41221469" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220264">parent</a><span>|</span><a href="#41222422">next</a><span>|</span><label class="collapse" for="c-41221469">[-]</label><label class="expand" for="c-41221469">[1 more]</label></div><br/><div class="children"><div class="content">The way almost all programming languages work is that they explicitly pass a copy of a pointer to a function. That is, in almost all languages used today, whether GC or not, assigning to a function parameter doesn&#x27;t modify the original variable in the calling function. Assigning to a field of that parameter will often modify the field of the caller&#x27;s local variable, though.<p>That is, in code like this:<p><pre><code>  ReferenceType a = {myField: 1}
  foo(a)
  print(a.myField)
  
  void foo(ReferenceType a) {
    a.myField = 9
    a = null
  } 
</code></pre>
Whether you translate this pseudocode to Python, Java, C# (with `class RefType`), C (`RefType = *StructType`), Go (same as C), C++ (same as C), Rust, Zig etc - the result is the same: the print will work and it will say 9.<p>The only exceptions where the print would fail with a null pointer issue that I know of are C++&#x27;s references and C#&#x27; s ref parameters. Are there any others?</div><br/></div></div><div id="41222422" class="c"><input type="checkbox" id="c-41222422" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220264">parent</a><span>|</span><a href="#41221469">prev</a><span>|</span><a href="#41220399">next</a><span>|</span><label class="collapse" for="c-41222422">[-]</label><label class="expand" for="c-41222422">[1 more]</label></div><br/><div class="children"><div class="content">It’s semantics only. The compiler is free to optimize it in any way, e.g. if a function call gets inlined, there is nothing “returning” to begin with, it’s all just local values.</div><br/></div></div><div id="41220399" class="c"><input type="checkbox" id="c-41220399" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220264">parent</a><span>|</span><a href="#41222422">prev</a><span>|</span><a href="#41220319">next</a><span>|</span><label class="collapse" for="c-41220399">[-]</label><label class="expand" for="c-41220399">[1 more]</label></div><br/><div class="children"><div class="content">See cousin posts. That&#x27;s not what the terms mean.</div><br/></div></div></div></div><div id="41220319" class="c"><input type="checkbox" id="c-41220319" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41219674">parent</a><span>|</span><a href="#41220264">prev</a><span>|</span><a href="#41220165">next</a><span>|</span><label class="collapse" for="c-41220319">[-]</label><label class="expand" for="c-41220319">[5 more]</label></div><br/><div class="children"><div class="content">Both C# and Swift makes a distinct difference by having both struct and classes.</div><br/><div id="41220394" class="c"><input type="checkbox" id="c-41220394" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220319">parent</a><span>|</span><a href="#41220165">next</a><span>|</span><label class="collapse" for="c-41220394">[-]</label><label class="expand" for="c-41220394">[4 more]</label></div><br/><div class="children"><div class="content">That is not what the pass-by-copy vs. pass-by-reference distinction is. Both are passing by value, one is just a pointer (under the hood) and the other is not. But the incoming parameter is a copy.<p>See my cousin post: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41220384">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41220384</a><p>This is a distinction so dead that people basically assume that this must be talking about whether things are passed by pointer, because in modern languages, what else would it be? But that is not what pass-by-reference versus pass-by-copy means. This is part of why it&#x27;s a good idea to let the terminology just die.</div><br/><div id="41220506" class="c"><input type="checkbox" id="c-41220506" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220394">parent</a><span>|</span><a href="#41220165">next</a><span>|</span><label class="collapse" for="c-41220506">[-]</label><label class="expand" for="c-41220506">[3 more]</label></div><br/><div class="children"><div class="content">So what should we call &quot;foo(x)&quot; and &quot;foo(ref x)&quot; in C# to distinguish them if not pass-by-value and pass-by-reference?</div><br/><div id="41220546" class="c"><input type="checkbox" id="c-41220546" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220506">parent</a><span>|</span><a href="#41220165">next</a><span>|</span><label class="collapse" for="c-41220546">[-]</label><label class="expand" for="c-41220546">[2 more]</label></div><br/><div class="children"><div class="content">C# can call it that specifically if it likes, because the general computer science term is dead, but under the hood you&#x27;re passing a reference by value. Look to the generated assembler in a non-inlined function. You&#x27;ll find a copy of a pointer. You did not in true pass-by-refernce langauges.<p>The fact that is a sensible thing to say in a modern language is another sign the terminology is dead.</div><br/><div id="41221494" class="c"><input type="checkbox" id="c-41221494" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220546">parent</a><span>|</span><a href="#41220165">next</a><span>|</span><label class="collapse" for="c-41221494">[-]</label><label class="expand" for="c-41221494">[1 more]</label></div><br/><div class="children"><div class="content">C#&#x27;s ref parameters, same as C++&#x27; s reference types, have true pass-by-reference semantics. Whether this gets compiled to pass-by-pointer or not is not observable from the language semantics.<p>That is, the following holds true:<p><pre><code>  int a = 10;
  foo(ref a) ;
  Assert(a == 100);

  void foo(ref int a) 
  {
    a = 100;
  }
</code></pre>
There&#x27;s also a good chance that in this very simple case that the compiler will inline foo, so that it will not ever pass the address of a even at the assembly level. The same would be true in C++ with `void foo (int&amp; a)`.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41220165" class="c"><input type="checkbox" id="c-41220165" checked=""/><div class="controls bullet"><span class="by">azundo</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41219674">parent</a><span>|</span><a href="#41220319">prev</a><span>|</span><a href="#41220117">next</a><span>|</span><label class="collapse" for="c-41220165">[-]</label><label class="expand" for="c-41220165">[6 more]</label></div><br/><div class="children"><div class="content">Is python no longer a modern language? Objects are certainly not copied when passed to a function.</div><br/><div id="41220384" class="c"><input type="checkbox" id="c-41220384" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220165">parent</a><span>|</span><a href="#41220117">next</a><span>|</span><label class="collapse" for="c-41220384">[-]</label><label class="expand" for="c-41220384">[5 more]</label></div><br/><div class="children"><div class="content">Python copies references by value.<p><pre><code>    $ python3
    Python 3.12.3 (main, Jul 31 2024, 17:43:48) [GCC 13.2.0] on linux
    Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
    &gt;&gt;&gt; def x():
    ...     v = 1
    ...     y(v)
    ...     print(v)
    ... 
    &gt;&gt;&gt; def y(val):
    ...     val += 1
    ... 
    &gt;&gt;&gt; x()
    1
</code></pre>
A pass-by-reference language would print 2.<p>Everything in a modern language is passed by copy. Exactly <i>what</i> is copied varies and can easily be pointers&#x2F;references. But there were languages once upon a time that didn&#x27;t work that way. It&#x27;s a dead distinction now, though, unless you go dig one of them up.<p>If you want a specific one to look at, look at Forth. Note how when you call a function (&quot;invoke a word&quot;, closest equivalent concept), the function&#x2F;word doesn&#x27;t get a copy of anything. It directly gets the actual value. There is no new copy, no new memory location, it gets the actual same memory as the caller was using, and not as a &quot;pointer&quot;... directly. Nothing works like that any more.</div><br/><div id="41221262" class="c"><input type="checkbox" id="c-41221262" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220384">parent</a><span>|</span><a href="#41220878">next</a><span>|</span><label class="collapse" for="c-41221262">[-]</label><label class="expand" for="c-41221262">[1 more]</label></div><br/><div class="children"><div class="content">C++ is a live language, C# has out parameters.... there&#x27;s stuff out there.<p>The classic example of &quot;pass by copy-reference is less expressive&quot; is you can&#x27;t have pass a reference to number and have the caller modify it. You have to explicitly box it. I understand you understand this, but it&#x27;s worth considering when thinking about whether the distinction means absolutely nothing at all.</div><br/></div></div><div id="41220878" class="c"><input type="checkbox" id="c-41220878" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220384">parent</a><span>|</span><a href="#41221262">prev</a><span>|</span><a href="#41220117">next</a><span>|</span><label class="collapse" for="c-41220878">[-]</label><label class="expand" for="c-41220878">[3 more]</label></div><br/><div class="children"><div class="content">uh I&#x27;d not say it like that<p>Python passes <i>primitive types</i> by value, out rather &quot;as if by value&quot;, because it copies them on write.<p>if you modify your experiment to pass around a dict or list and modify that in the &#x27;y&#x27;, you&#x27;ll see y is happily modified.<p>so Python passes by reference, however it either blocks updates (tuple) or copies on write (int, str, float) or updates in place (dict, list, class)</div><br/><div id="41221525" class="c"><input type="checkbox" id="c-41221525" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220878">parent</a><span>|</span><a href="#41221495">next</a><span>|</span><label class="collapse" for="c-41221525">[-]</label><label class="expand" for="c-41221525">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you modify your experiment to pass around a dict or list and modify that in the &#x27;y&#x27;, you&#x27;ll see y is happily modified.<p>No, you won&#x27;t.<p><pre><code>  x = {&#x27;a&#x27; : 1}
  foo(x)
  print(x)

  def foo(z):
    z = {&#x27;b&#x27; : 2}
</code></pre>
You&#x27;ll see that this prints `{&#x27;a&#x27; : 1}`, not `{&#x27;b&#x27; : 2}`. Python always uses pass-by-value. It passes a copy of the pointer to a dict&#x2F;list&#x2F;etc in this case. Of course, if you modify the fields of the z variable, as in `z[&#x27;b&#x27;] = 2`, you do modify the original object that is referenced by z. But this is not pass-by-reference.</div><br/></div></div><div id="41221495" class="c"><input type="checkbox" id="c-41221495" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220878">parent</a><span>|</span><a href="#41221525">prev</a><span>|</span><a href="#41220117">next</a><span>|</span><label class="collapse" for="c-41221495">[-]</label><label class="expand" for="c-41221495">[1 more]</label></div><br/><div class="children"><div class="content">jerf is correct. Please read this:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;373419&#x2F;whats-the-difference-between-passing-by-reference-vs-passing-by-value" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;373419&#x2F;whats-the-differe...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41220117" class="c"><input type="checkbox" id="c-41220117" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41214759">parent</a><span>|</span><a href="#41219674">prev</a><span>|</span><a href="#41220094">next</a><span>|</span><label class="collapse" for="c-41220117">[-]</label><label class="expand" for="c-41220117">[1 more]</label></div><br/><div class="children"><div class="content">But the author already knew that.<p>The important lesson is that <i>assignments</i> are by value(copy).</div><br/></div></div><div id="41220094" class="c"><input type="checkbox" id="c-41220094" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41214759">parent</a><span>|</span><a href="#41220117">prev</a><span>|</span><a href="#41219510">next</a><span>|</span><label class="collapse" for="c-41220094">[-]</label><label class="expand" for="c-41220094">[4 more]</label></div><br/><div class="children"><div class="content">Maps and channels and functions are passed by reference. Slices are passed and returned by value but <i>sometimes</i> share state invisibly, the worst of both worlds. It would make more sense if Go either made this stuff immutable, made defensive copies, or refused and required using explicit pointers for all these cases.</div><br/><div id="41221069" class="c"><input type="checkbox" id="c-41221069" checked=""/><div class="controls bullet"><span class="by">dondraper36</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41220094">parent</a><span>|</span><a href="#41219510">next</a><span>|</span><label class="collapse" for="c-41221069">[-]</label><label class="expand" for="c-41221069">[3 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s not the case and this terminology shouldn&#x27;t be used as it&#x27;s confusing and unhelpful.<p>There are reference types in Go even though this is also not a super popular term. They still follow the pass-by-value semantics, it&#x27;s just that a pointer is copied. A map is effectively a pointer to hmap data structure.<p>In the early days of Go, there was an explicit pointer, but then it was changed.<p>Slices are a 3-word structure internally that includes a pointer to a backing array and this is why it&#x27;s also a &quot;reference type&quot;.<p>That said, everything is still passed by value and there are no references in Go.</div><br/><div id="41221246" class="c"><input type="checkbox" id="c-41221246" checked=""/><div class="controls bullet"><span class="by">jxndndnjc</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41221069">parent</a><span>|</span><a href="#41219510">next</a><span>|</span><label class="collapse" for="c-41221246">[-]</label><label class="expand" for="c-41221246">[2 more]</label></div><br/><div class="children"><div class="content">You are splitting hair, Maps are effectively references.<p>That&#x27;s like saying C++ doesn&#x27;t have references since it&#x27;s just a pointer being copied around</div><br/><div id="41221628" class="c"><input type="checkbox" id="c-41221628" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41214759">root</a><span>|</span><a href="#41221246">parent</a><span>|</span><a href="#41219510">next</a><span>|</span><label class="collapse" for="c-41221628">[-]</label><label class="expand" for="c-41221628">[1 more]</label></div><br/><div class="children"><div class="content">No, there is a real difference, this is not splitting hairs.<p>Go is always pass-by-value, even for maps [0]:<p><pre><code>  x := map[int]int{1: 2}
  foo(x)
  fmt.Printf(&quot;%+v&quot;, x) &#x2F;&#x2F;prints map[1:2]

  func foo(a map[int]int) {
    a = map[int]int{3: 4}
  }
</code></pre>
In contrast, C++ references have different semantics [1]:<p><pre><code>  std::map&lt;int, int&gt; x {{1, 2}};
  foo(x);
  std::print(&quot;{%d:%d}&quot;, x.begin()-&gt;first, x.begin()-&gt;second);
  &#x2F;&#x2F;prints {3:4}

  void foo(std::map&lt;int, int&gt;&amp; a) {
    a = std::map&lt;int, int&gt; {{3, 4}}; 
  } 
</code></pre>
[0] <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;6a6Mz9KdFUh" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;6a6Mz9KdFUh</a><p>[1] <a href="https:&#x2F;&#x2F;onlinegdb.com&#x2F;j0U2NYbjL" rel="nofollow">https:&#x2F;&#x2F;onlinegdb.com&#x2F;j0U2NYbjL</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41219510" class="c"><input type="checkbox" id="c-41219510" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41214759">prev</a><span>|</span><a href="#41220230">next</a><span>|</span><label class="collapse" for="c-41219510">[-]</label><label class="expand" for="c-41219510">[1 more]</label></div><br/><div class="children"><div class="content">It can also be a performance issue since range has to make a copy of whatever was in the slice.  Slices of pure structs can be tantalizing for their simplicity but you should be thinking of how you want to range over them first and double check yourself everytime you write:<p><pre><code>    _, obj := range ...
</code></pre>
You&#x27;re explicitly asking for the two argument convenience which can have a price.</div><br/></div></div><div id="41220230" class="c"><input type="checkbox" id="c-41220230" checked=""/><div class="controls bullet"><span class="by">ozfive</span><span>|</span><a href="#41219510">prev</a><span>|</span><a href="#41219978">next</a><span>|</span><label class="collapse" for="c-41220230">[-]</label><label class="expand" for="c-41220230">[2 more]</label></div><br/><div class="children"><div class="content">Looks as though the range loop isn&#x27;t an issue from Go 1.22 anymore.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;loopvar-preview" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;loopvar-preview</a></div><br/><div id="41222368" class="c"><input type="checkbox" id="c-41222368" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41220230">parent</a><span>|</span><a href="#41219978">next</a><span>|</span><label class="collapse" for="c-41222368">[-]</label><label class="expand" for="c-41222368">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a different language design mistake, which several languages have had to fix including C# back in C# 5.<p>The question there is, does our for-each style loop make a <i>new</i> variable each iteration, with the appropriate value, or does it have a <i>single</i> variable and it&#x27;s just re-assigned for each iteration. People who haven&#x27;t designed a language before might think the second option sounds optimal and won&#x27;t make a practical difference, but it&#x27;s actually very annoying and that&#x27;s why Go changed to the former.<p>This time though it&#x27;s not about the variable staying the same, the problem is that we got a <i>copy</i> of the data we cared about, not a <i>mutable reference</i> to that data.</div><br/></div></div></div></div><div id="41219978" class="c"><input type="checkbox" id="c-41219978" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41220230">prev</a><span>|</span><a href="#41220156">next</a><span>|</span><label class="collapse" for="c-41219978">[-]</label><label class="expand" for="c-41219978">[1 more]</label></div><br/><div class="children"><div class="content">jvns highlights some of the easier to forgot or overlook mistakes, but their source article <a href="https:&#x2F;&#x2F;100go.co" rel="nofollow">https:&#x2F;&#x2F;100go.co</a> is a great refresher and introduction as well.</div><br/></div></div><div id="41220156" class="c"><input type="checkbox" id="c-41220156" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#41219978">prev</a><span>|</span><a href="#41219738">next</a><span>|</span><label class="collapse" for="c-41220156">[-]</label><label class="expand" for="c-41220156">[2 more]</label></div><br/><div class="children"><div class="content">The one about named returns, err always being nil, why is err even in scope, seems like it should be a compile error to me? (I rarely write Go).</div><br/><div id="41220259" class="c"><input type="checkbox" id="c-41220259" checked=""/><div class="controls bullet"><span class="by">jyap</span><span>|</span><a href="#41220156">parent</a><span>|</span><a href="#41219738">next</a><span>|</span><label class="collapse" for="c-41220259">[-]</label><label class="expand" for="c-41220259">[1 more]</label></div><br/><div class="children"><div class="content">In the function signature, the return variable err is type error. Since it is named it is also defined and initialized as nil.<p>In the code, an error is found and it does not assign a value to err and just returns it as the error value.<p>So it returns nil as the error when it wants to return an error with a proper value.<p>The code should be something like:<p><pre><code>    if ctx.Err() != nil {
      return 0, 0, ctx.Err()
    }</code></pre></div><br/></div></div></div></div><div id="41219738" class="c"><input type="checkbox" id="c-41219738" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#41220156">prev</a><span>|</span><a href="#41220222">next</a><span>|</span><label class="collapse" for="c-41219738">[-]</label><label class="expand" for="c-41219738">[1 more]</label></div><br/><div class="children"><div class="content">Nice post!<p>Also, not everyone knows that even the much-maligned old C does this.<p>It&#x27;s a huge red flag&#x2F;cringe when someone breaks out memcpy() just to copy a struct value (or return it, obviously).</div><br/></div></div><div id="41220222" class="c"><input type="checkbox" id="c-41220222" checked=""/><div class="controls bullet"><span class="by">HackerThemAll</span><span>|</span><a href="#41219738">prev</a><span>|</span><a href="#41214969">next</a><span>|</span><label class="collapse" for="c-41220222">[-]</label><label class="expand" for="c-41220222">[1 more]</label></div><br/><div class="children"><div class="content">Read The Fine Manual, and read some books, so underappreciated these days...</div><br/></div></div><div id="41214969" class="c"><input type="checkbox" id="c-41214969" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#41220222">prev</a><span>|</span><label class="collapse" for="c-41214969">[-]</label><label class="expand" for="c-41214969">[7 more]</label></div><br/><div class="children"><div class="content">Misconceptions probably come from Java or Python where a bunch of things are implicitly done for you. I much prefer Golang’s explicitness. The stuff with slices are confusing though</div><br/><div id="41219686" class="c"><input type="checkbox" id="c-41219686" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41214969">parent</a><span>|</span><a href="#41218708">next</a><span>|</span><label class="collapse" for="c-41219686">[-]</label><label class="expand" for="c-41219686">[1 more]</label></div><br/><div class="children"><div class="content">What a reach to blame Java.</div><br/></div></div><div id="41218708" class="c"><input type="checkbox" id="c-41218708" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41214969">parent</a><span>|</span><a href="#41219686">prev</a><span>|</span><a href="#41218689">next</a><span>|</span><label class="collapse" for="c-41218708">[-]</label><label class="expand" for="c-41218708">[2 more]</label></div><br/><div class="children"><div class="content">Agreed on this one, the &quot;fix&quot; involving the capacity flag, e.g. &quot;2:3:3&quot; is unintuitive compared to Python where there is no such concept.<p>Still, as far as sharp edges go these are nothing compared to Java.<p>See the discussion from:<p><i>Common I&#x2F;O Tasks in Modern Java</i><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41142737">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41142737</a><p>House of horrors, especially the URL equality triggering DNA requests.</div><br/><div id="41219716" class="c"><input type="checkbox" id="c-41219716" checked=""/><div class="controls bullet"><span class="by">throwaway8e83</span><span>|</span><a href="#41214969">root</a><span>|</span><a href="#41218708">parent</a><span>|</span><a href="#41218689">next</a><span>|</span><label class="collapse" for="c-41219716">[-]</label><label class="expand" for="c-41219716">[1 more]</label></div><br/><div class="children"><div class="content">&gt; URL equality triggering DNS requests<p>I agree it can be confusing, as the URL also can act as a client that performs actual connections. The documentation actually mentions that URI is a better choice when you want only a representation<p>In general I don&#x27;t think the other examples are that bad. The reason why there are so many different ways of performing I&#x2F;O, is because Java is evolving and adding better solutions, but can&#x27;t really remove older stuff like &quot;URL&quot; because it is widely used.<p>I see similar issues with other languages as they evolve, and I think Java has managed it well. The IDEs are also often good at making suggestions on how to replace outdated code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>