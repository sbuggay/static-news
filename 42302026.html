<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733216467547" as="style"/><link rel="stylesheet" href="styles.css?v=1733216467547"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/copper-project/copper-rs/wiki/Copper-Release-Log">Show HN: Copper – Open-source robotics in Rust with deterministic log replay</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>gbin</span> | <span>22 comments</span></div><br/><div><div id="42302986" class="c"><input type="checkbox" id="c-42302986" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#42302625">next</a><span>|</span><label class="collapse" for="c-42302986">[-]</label><label class="expand" for="c-42302986">[2 more]</label></div><br/><div class="children"><div class="content">This seems to suffer a bit from the same problem that affects a lot of &quot;new&quot; robotics frameworks: the beginnings are simple, and it&#x27;s easy at that stage to think that everything else is over-complicated.<p>The comparison with ROS 2 is a bit questionable. Comparing a single-process-only (Copper) approach using shared memory with a multi-process system (ROS 2) using default DDS settings really isn&#x27;t comparing the same thing. There are ways to make the ROS 2 system much faster if you&#x27;re willing to be limited to similar constraints (single process with components, or local-system shared-memory transport) but most people don&#x27;t because those constraints are very limiting in practical applications.</div><br/><div id="42304009" class="c"><input type="checkbox" id="c-42304009" checked=""/><div class="controls bullet"><span class="by">gbin</span><span>|</span><a href="#42302986">parent</a><span>|</span><a href="#42302625">next</a><span>|</span><label class="collapse" for="c-42304009">[-]</label><label class="expand" for="c-42304009">[1 more]</label></div><br/><div class="children"><div class="content">Note that Copper can be distributed too, we do support iceoryx2 for example if you need to split it in 2 or more processes.<p>We have ~100x less latency and ~12x faster logging also because we have adopted a data oriented architecture: the tasks outputs are written back to back in memory, all the IOs are linear (we could log to a block device straight, we don&#x27;t even need a filesystem). 
I am not sure it is possible to touch this with ROS just because of its &quot;everything is asynchronous&quot; design pattern.<p>So the question is more about those limits in practical applications: do you have use cases where you absolutely need every single component deployed as a kind of micro service in a robot?</div><br/></div></div></div></div><div id="42302625" class="c"><input type="checkbox" id="c-42302625" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#42302986">prev</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42302625">[-]</label><label class="expand" for="c-42302625">[9 more]</label></div><br/><div class="children"><div class="content">Tangent this got me thinking about: Why are the robotics and embedded communities generally separate, with little overlap in people and tech? For example, this project seems unrelated to the rust embedded tooling. And the components categories are also unfamiliar, e.g. the IMUs and ADCs in the readme, using a SBC vice a MCU etc.<p>Another angle: `ROS` and `RTOS` share letters, but not much else!<p>I gather that robotics is a fusion of embedded and mechanical engineering; I refer to the former.</div><br/><div id="42302676" class="c"><input type="checkbox" id="c-42302676" checked=""/><div class="controls bullet"><span class="by">gbin</span><span>|</span><a href="#42302625">parent</a><span>|</span><a href="#42302855">next</a><span>|</span><label class="collapse" for="c-42302676">[-]</label><label class="expand" for="c-42302676">[1 more]</label></div><br/><div class="children"><div class="content">It almost feels like we would need an &quot;in between&quot; category.<p>If I paint a broad brush:<p>- embedded is all about latency, low bandwidth<p>- computers are all about bandwidth with often terrible latencies.<p>A modern robot needs both low latency and high bandwidth.</div><br/></div></div><div id="42302855" class="c"><input type="checkbox" id="c-42302855" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42302625">parent</a><span>|</span><a href="#42302676">prev</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42302855">[-]</label><label class="expand" for="c-42302855">[7 more]</label></div><br/><div class="children"><div class="content">Typically with robots you need more power than what embedded provides. We build on top of commodity x86 systems a lot of the time. Other times we use SOCs like the Nvidia Jetson line, which also doesn&#x27;t require a lot of embedded skills; you get a full operating system and a userspace so it&#x27;s more like programming on a typical unix-based system. You find more embedded in the automation side of things. Wearables, IOT, always connected devices -- things that are too small and low powered to afford an OS.</div><br/><div id="42302890" class="c"><input type="checkbox" id="c-42302890" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42302625">root</a><span>|</span><a href="#42302855">parent</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42302890">[-]</label><label class="expand" for="c-42302890">[6 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of embedded skills in pretty much any hardware platform. Maybe this is selection bias from being an embedded-focused person in robotics, but there&#x27;s plenty of jobs out there that need a toolchain wrangler who can deal with cost optimization.</div><br/><div id="42302931" class="c"><input type="checkbox" id="c-42302931" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42302625">root</a><span>|</span><a href="#42302890">parent</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42302931">[-]</label><label class="expand" for="c-42302931">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying skills you pick up doing embedded work aren&#x27;t useful in robotics contexts. I&#x27;m saying roboticists often have the luxury of an OS, and they take advantage of it, so the worries you have doing embedded work without an OS are mitigated.<p>I would say tho there <i>are</i> different &quot;kinds&quot; of roboticists. Just as you have backend and frontend devs in the web world, you might consider people who work on hardware or software to be the robotics equivalent. Hardware people <i>are</i> going to be low level and working with embedded devices and may even program them. But higher up in the robotics stack most of that embedded know-how (toolchain wrangling as you put it) is much less important. The full stack robotics engineer has hardware and software knowledge&#x2F;experience, but you don&#x27;t usually see roles that ask for both, so people tend to specialize into one or the other.</div><br/><div id="42303133" class="c"><input type="checkbox" id="c-42303133" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42302625">root</a><span>|</span><a href="#42302931">parent</a><span>|</span><a href="#42303038">next</a><span>|</span><label class="collapse" for="c-42303133">[-]</label><label class="expand" for="c-42303133">[1 more]</label></div><br/><div class="children"><div class="content">My experience is that there&#x27;s a major difference between &quot;R&amp;D project&quot; mentality to mass production and big install bases. The embedded stuff really starts to leaking into everything during the latter once you start evaluating how much it&#x27;d cost to rewrite the high level stuff to fit cheaper hardware, or resolve the intermittent issues that big customer is complaining about.</div><br/></div></div><div id="42303038" class="c"><input type="checkbox" id="c-42303038" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42302625">root</a><span>|</span><a href="#42302931">parent</a><span>|</span><a href="#42303133">prev</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42303038">[-]</label><label class="expand" for="c-42303038">[3 more]</label></div><br/><div class="children"><div class="content">OTOH the OS can very much get in the way. If you&#x27;re using ROS for instance, it&#x27;s easy to fall into apt package dependency hell - upgrading CUDA means upgrading the OS, which means upgrading ROS, which means upgrading all deps including OpenCV, etc, etc, etc.</div><br/><div id="42304092" class="c"><input type="checkbox" id="c-42304092" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#42302625">root</a><span>|</span><a href="#42303038">parent</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42304092">[-]</label><label class="expand" for="c-42304092">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s the part I hate about ros and a whole lot of other libraries that shouldn&#x27;t have been so tightly coupled - you should be able to run most of ros in one env and then for the performance critical or hardware facing stuff, run them each in their own env and have lightweight communication between them.<p>I think if something annoys me enough I&#x27;ll end up using nanomsg or mqtt as a bridge, but it&#x27;s a pain.</div><br/><div id="42304229" class="c"><input type="checkbox" id="c-42304229" checked=""/><div class="controls bullet"><span class="by">ribadeo</span><span>|</span><a href="#42302625">root</a><span>|</span><a href="#42304092">parent</a><span>|</span><a href="#42302602">next</a><span>|</span><label class="collapse" for="c-42304229">[-]</label><label class="expand" for="c-42304229">[1 more]</label></div><br/><div class="children"><div class="content">Xenomai or rt extensions to linux, basically the rtlinux legacy,  where the os is a low priority thread while your latency critical code runs bare metal or scheduled out of band</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42302602" class="c"><input type="checkbox" id="c-42302602" checked=""/><div class="controls bullet"><span class="by">amacneil</span><span>|</span><a href="#42302625">prev</a><span>|</span><a href="#42302725">next</a><span>|</span><label class="collapse" for="c-42302602">[-]</label><label class="expand" for="c-42302602">[1 more]</label></div><br/><div class="children"><div class="content">It’s great to see more innovation in the robotics framework space, it’s sorely needed.<p>Deterministic log replay is a killer feature to have baked in from the start - many autonomous vehicle &amp; robotics companies have invested years of effort to achieve that nirvana, while the most popular robotics framework today (ROS) makes it borderline impossible.</div><br/></div></div><div id="42302725" class="c"><input type="checkbox" id="c-42302725" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#42302602">prev</a><span>|</span><a href="#42302543">next</a><span>|</span><label class="collapse" for="c-42302725">[-]</label><label class="expand" for="c-42302725">[1 more]</label></div><br/><div class="children"><div class="content">If this pics up support for like a open-library of assorted components and people shared them it has a lot of potential especially if the sim env and replays continues to be improved. I love the idea and looks gerat!</div><br/></div></div><div id="42302543" class="c"><input type="checkbox" id="c-42302543" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42302725">prev</a><span>|</span><a href="#42303145">next</a><span>|</span><label class="collapse" for="c-42302543">[-]</label><label class="expand" for="c-42302543">[3 more]</label></div><br/><div class="children"><div class="content">Nice release - deterministic replay isn&#x27;t easy - I still need to go back and pull our implementation forward to match the new features in the core framework. I&#x27;m not sure if you&#x27;ve seen Basis, but we&#x27;re somewhat &quot;competing&quot; in the same space. You&#x27;re all in on Rust, we&#x27;re C++ with bindings to other languages (eventually). I don&#x27;t see this as a bad thing - more tools in the space is a win, eventually the industry will settle on something better than ROS.</div><br/><div id="42302832" class="c"><input type="checkbox" id="c-42302832" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42302543">parent</a><span>|</span><a href="#42303145">next</a><span>|</span><label class="collapse" for="c-42302832">[-]</label><label class="expand" for="c-42302832">[2 more]</label></div><br/><div class="children"><div class="content">Having maintained something similar myself, how has your experience been with exact determinism in C++? C++ compilers tend to be a bit of a free-for-all when it comes to bit determinism, whereas the rustc folks are very good about spending the design time to preemptively avoid many of the issues you&#x27;d need workarounds for in other languages.</div><br/><div id="42302906" class="c"><input type="checkbox" id="c-42302906" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42302543">root</a><span>|</span><a href="#42302832">parent</a><span>|</span><a href="#42303145">next</a><span>|</span><label class="collapse" for="c-42302906">[-]</label><label class="expand" for="c-42302906">[1 more]</label></div><br/><div class="children"><div class="content">My goal is determinism specifically around message timings&#x2F;execution in replay. We don&#x27;t currently advertise runtime determinism, we also don&#x27;t promise fixes for determinism in your code. For message timing, the algorithm should be stable - it generates a timeline for when messages should be executed by each message handler, and will pause further executions to wait on handlers that &quot;should have&quot; finished, but haven&#x27;t due to running too slow. Ties are broken by the handler name or data source name. I wrote a bit about it here <a href="https:&#x2F;&#x2F;basisrobotics.tech&#x2F;2024&#x2F;09&#x2F;02&#x2F;determinism&#x2F;" rel="nofollow">https:&#x2F;&#x2F;basisrobotics.tech&#x2F;2024&#x2F;09&#x2F;02&#x2F;determinism&#x2F;</a> but didn&#x27;t go deep into the implementation. If your own code isn&#x27;t deterministic you will have differences, but this eliminates the biggest classes of nondeterminism when running tests (threading timings, message handling races).<p>I don&#x27;t think Copper claims to offer more than this either, but I can&#x27;t speak for them.</div><br/></div></div></div></div></div></div><div id="42303145" class="c"><input type="checkbox" id="c-42303145" checked=""/><div class="controls bullet"><span class="by">rgovostes</span><span>|</span><a href="#42302543">prev</a><span>|</span><a href="#42302574">next</a><span>|</span><label class="collapse" for="c-42303145">[-]</label><label class="expand" for="c-42303145">[2 more]</label></div><br/><div class="children"><div class="content">Do I understand that at each tick, every task outputs a single message, and can depend on the outputs of other tasks? I.e., nodes and topics are merged into tasks, executed in topological order?</div><br/><div id="42304198" class="c"><input type="checkbox" id="c-42304198" checked=""/><div class="controls bullet"><span class="by">gbin</span><span>|</span><a href="#42303145">parent</a><span>|</span><a href="#42302574">next</a><span>|</span><label class="collapse" for="c-42304198">[-]</label><label class="expand" for="c-42304198">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>Technically Copper is a compiler taking your graph with those constraints in mind and building a game loop out of it.</div><br/></div></div></div></div><div id="42302574" class="c"><input type="checkbox" id="c-42302574" checked=""/><div class="controls bullet"><span class="by">pryelluw</span><span>|</span><a href="#42303145">prev</a><span>|</span><label class="collapse" for="c-42302574">[-]</label><label class="expand" for="c-42302574">[3 more]</label></div><br/><div class="children"><div class="content">Such a great two sentence intro to the project:<p>“ Copper is a user-friendly runtime engine for creating fast and reliable robots. Copper is to robots what a game engine is to games.”<p>Other projects should take notice.</div><br/><div id="42302743" class="c"><input type="checkbox" id="c-42302743" checked=""/><div class="controls bullet"><span class="by">gbin</span><span>|</span><a href="#42302574">parent</a><span>|</span><a href="#42302581">next</a><span>|</span><label class="collapse" for="c-42302743">[-]</label><label class="expand" for="c-42302743">[1 more]</label></div><br/><div class="children"><div class="content">Oh wow thanks, I have to tell you something... It is really hard to explain what a piece of middleware is and why it is important :)</div><br/></div></div></div></div></div></div></div></div></div></body></html>