<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695114058970" as="style"/><link rel="stylesheet" href="styles.css?v=1695114058970"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tratt.net/laurie/blog/2023/how_hard_is_it_to_adapt_a_memory_allocator_to_cheri.html">How hard is it to adapt a memory allocator to CHERI?</a> <span class="domain">(<a href="https://tratt.net">tratt.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>14 comments</span></div><br/><div><div id="37555189" class="c"><input type="checkbox" id="c-37555189" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37555215">next</a><span>|</span><label class="collapse" for="c-37555189">[-]</label><label class="expand" for="c-37555189">[6 more]</label></div><br/><div class="children"><div class="content">It would be nice to have a “part 2” of this where a more complex allocator was discussed that does more interesting things like have intrusive metadata or have heap block headers. For example, you probably do not want to hand out a pointer with a capability to alter its own heap header, but on free you’ll get that pointer back and it won’t have the capability: how do you safely use that context to modify your metadata again? How do you protect freelists? There’s lots to explore.</div><br/><div id="37562511" class="c"><input type="checkbox" id="c-37562511" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#37555189">parent</a><span>|</span><a href="#37555472">next</a><span>|</span><label class="collapse" for="c-37562511">[-]</label><label class="expand" for="c-37562511">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, the allocator would possess a capability with authority over the whole heap, and it can derive a new pointer using that capability and the address of the block that&#x27;s being freed.<p>Obviously, it should make sure that the capability passed to free has full authority over the block first, or else it may end up vulnerable to confused deputy attacks.</div><br/></div></div><div id="37555472" class="c"><input type="checkbox" id="c-37555472" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#37555189">parent</a><span>|</span><a href="#37562511">prev</a><span>|</span><a href="#37555215">next</a><span>|</span><label class="collapse" for="c-37555472">[-]</label><label class="expand" for="c-37555472">[4 more]</label></div><br/><div class="children"><div class="content">Perhaps we&#x27;ll see allocators hold a heap&#x2F;bucket pointer + capability; you would use the &quot;free&quot; pointer to find the metadata, and the heap pointer to interact with it</div><br/><div id="37561977" class="c"><input type="checkbox" id="c-37561977" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#37555189">root</a><span>|</span><a href="#37555472">parent</a><span>|</span><a href="#37555215">next</a><span>|</span><label class="collapse" for="c-37561977">[-]</label><label class="expand" for="c-37561977">[3 more]</label></div><br/><div class="children"><div class="content">Some more security conscious allocators have already moved away from adjacent metadata storage to mitigate heap overflows. Instead, the metadata is stored in separate ASLR&#x27;d allocations and indexed by the pointer value. Some metadata might be implicitly encoded in the pointer value (e.g. by alignment or position above&#x2F;below some virtual memory demarcation) to optimize lookup of the metadata.</div><br/><div id="37565637" class="c"><input type="checkbox" id="c-37565637" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#37555189">root</a><span>|</span><a href="#37561977">parent</a><span>|</span><a href="#37555215">next</a><span>|</span><label class="collapse" for="c-37565637">[-]</label><label class="expand" for="c-37565637">[2 more]</label></div><br/><div class="children"><div class="content">But CHERI would stop pointer owners from exploring nearby memory space, so the metadata would only be accessible from within the allocator itself regardless. AFAICT there should be no need for ASLR with CHERI. (I mean defense in depth is ok…)</div><br/><div id="37566215" class="c"><input type="checkbox" id="c-37566215" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#37555189">root</a><span>|</span><a href="#37565637">parent</a><span>|</span><a href="#37555215">next</a><span>|</span><label class="collapse" for="c-37566215">[-]</label><label class="expand" for="c-37566215">[1 more]</label></div><br/><div class="children"><div class="content">My point was just that current security best practice already requires indexing a separate data structure for bookkeeping. With CHERI, even <i>if</i> your metadata is stored in an adjacent header, to read or write that memory you have to lookup its pool to derive a wider pointer encompassing that header. (If not, as the article describes your allocator is misusing CHERI.)<p>But certainly with CHERI you could recover some optimization opportunities. For example, the block length can be derived directly from the pointer, which could make it easier to lookup the parent pool. And CHERI pointers preserve some bits for application pointer tagging, making it easier to implement typed allocations.<p>However, you still have to be careful. CHERI provides spatial safety, not temporal safety--double frees, dangling pointers, etc--so you may not want to reuse the application-visible portion of a block for bookkeeping purposes. Similarly, ASLR still retains much of its benefit, as does Rust--static enforcement of temporal safety, not spatial safety, is the principal value-add of Rust (spatial safety in Rust primarily comes from the library, not the language per se).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37555215" class="c"><input type="checkbox" id="c-37555215" checked=""/><div class="controls bullet"><span class="by">foamdino</span><span>|</span><a href="#37555189">prev</a><span>|</span><a href="#37564779">next</a><span>|</span><label class="collapse" for="c-37555215">[-]</label><label class="expand" for="c-37555215">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re working with the Morello processor and have had to wrestle a bit with allocation from a block based allocator: <a href="https:&#x2F;&#x2F;medium.com&#x2F;thg-tech-blog&#x2F;morello-and-memory-pools-91ed20750137" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;thg-tech-blog&#x2F;morello-and-memory-pools-91...</a></div><br/></div></div><div id="37564779" class="c"><input type="checkbox" id="c-37564779" checked=""/><div class="controls bullet"><span class="by">peppermint_gum</span><span>|</span><a href="#37555215">prev</a><span>|</span><a href="#37565052">next</a><span>|</span><label class="collapse" for="c-37564779">[-]</label><label class="expand" for="c-37564779">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an interesting exchange on Lobsters between the author of this post and a person working on CHERI:<p><a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;ez2wph&#x2F;how_hard_is_it_adapt_memory_allocator" rel="nofollow noreferrer">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;ez2wph&#x2F;how_hard_is_it_adapt_memory_alloc...</a></div><br/><div id="37566682" class="c"><input type="checkbox" id="c-37566682" checked=""/><div class="controls bullet"><span class="by">valleyer</span><span>|</span><a href="#37564779">parent</a><span>|</span><a href="#37565052">next</a><span>|</span><label class="collapse" for="c-37566682">[-]</label><label class="expand" for="c-37566682">[2 more]</label></div><br/><div class="children"><div class="content">Good lord, what an absolute turn-off.  I&#x27;ll take memory unsafety over working with someone who continually instigates arguments like that.</div><br/><div id="37566824" class="c"><input type="checkbox" id="c-37566824" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37564779">root</a><span>|</span><a href="#37566682">parent</a><span>|</span><a href="#37565052">next</a><span>|</span><label class="collapse" for="c-37566824">[-]</label><label class="expand" for="c-37566824">[1 more]</label></div><br/><div class="children"><div class="content">Yeah the original discussion is reasonable (disclaimer: I brought up the exact same points independently) but it very quickly veers into irrelevant drama.</div><br/></div></div></div></div></div></div><div id="37565052" class="c"><input type="checkbox" id="c-37565052" checked=""/><div class="controls bullet"><span class="by">sheepscreek</span><span>|</span><a href="#37564779">prev</a><span>|</span><label class="collapse" for="c-37565052">[-]</label><label class="expand" for="c-37565052">[3 more]</label></div><br/><div class="children"><div class="content">Getting CHERI protection for security violations seems a bit like hitting the jackpot on a slot machine.<p>You need a CHERI OS on a CHERI CPU running software compiled with a CHERI aware compiler.<p>Doesn’t Rust also provide buffer overrun protection, without needing a special OS or CPU instruction set? Isn’t it a better ROI to rewrite the software on Rust, and not have to change anything else?<p>Can the same benefit be achieved by replacing CHERI CPU with a virtual machine runtime, or building support in LLVM IR?</div><br/><div id="37565398" class="c"><input type="checkbox" id="c-37565398" checked=""/><div class="controls bullet"><span class="by">cyber_kinetist</span><span>|</span><a href="#37565052">parent</a><span>|</span><a href="#37566003">next</a><span>|</span><label class="collapse" for="c-37565398">[-]</label><label class="expand" for="c-37565398">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Doesn’t Rust also provide buffer overrun protection, without needing a special OS or CPU instruction set?<p>No, because there’s still quite a lot of (inevitable) Unsafe Rust code floating around, and the compiler can’t protect these from memory-related errors. In fact there are some ongoing discussions and progress to support CHERI in Rust:<p>[0] <a href="https:&#x2F;&#x2F;faultlore.com&#x2F;blah&#x2F;fix-rust-pointers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;faultlore.com&#x2F;blah&#x2F;fix-rust-pointers&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;blog&#x2F;2022&#x2F;making_rust_a_better_fit_for_cheri_and_other_platforms.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;blog&#x2F;2022&#x2F;making_rust_a_better_fit_...</a><p>[2] <a href="https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2023&#x2F;schedule&#x2F;event&#x2F;rust_a_rusty_cheri_the_path_to_hardware_capabilities_in_rust&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2023&#x2F;schedule&#x2F;event&#x2F;rust_a_rusty_...</a></div><br/></div></div><div id="37566003" class="c"><input type="checkbox" id="c-37566003" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#37565052">parent</a><span>|</span><a href="#37565398">prev</a><span>|</span><label class="collapse" for="c-37566003">[-]</label><label class="expand" for="c-37566003">[1 more]</label></div><br/><div class="children"><div class="content">VMware virtualized x86 without hardware support, so it probably can be done. That doesn&#x27;t mean it would be easy or it would be as performant as with hardware support.</div><br/></div></div></div></div></div></div></div></div></div></body></html>