<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729846877298" as="style"/><link rel="stylesheet" href="styles.css?v=1729846877298"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://typeschema.org/">Show HN: TypeSchema – A JSON specification to describe data models</a> <span class="domain">(<a href="https://typeschema.org">typeschema.org</a>)</span></div><div class="subtext"><span>k42b3</span> | <span>40 comments</span></div><br/><div><div id="41943221" class="c"><input type="checkbox" id="c-41943221" checked=""/><div class="controls bullet"><span class="by">fridental</span><span>|</span><a href="#41940636">next</a><span>|</span><label class="collapse" for="c-41943221">[-]</label><label class="expand" for="c-41943221">[2 more]</label></div><br/><div class="children"><div class="content">Three big downturns for me:<p>1) They do not publish rationale of why the world needs yet another protocol &#x2F; language &#x2F; framework on the homepage. It is hidden in <a href="https:&#x2F;&#x2F;typeschema.org&#x2F;history" rel="nofollow">https:&#x2F;&#x2F;typeschema.org&#x2F;history</a><p>2) In the history page, they confuse strongly typed and statically typed languages. I have a prejudice about people doing this.<p>3) The biggest challenge about data models is not auto-generated code (that many people would avoid in principle anyway), but compressed, optimized wire serialization. So you START with selecting this for your application (eg. AVRO, CapnProto, MessagePack etc) and then use the schema definition language coming with the serialization tool you&#x27;ve chosen.</div><br/><div id="41943327" class="c"><input type="checkbox" id="c-41943327" checked=""/><div class="controls bullet"><span class="by">dominicrose</span><span>|</span><a href="#41943221">parent</a><span>|</span><a href="#41940636">next</a><span>|</span><label class="collapse" for="c-41943327">[-]</label><label class="expand" for="c-41943327">[1 more]</label></div><br/><div class="children"><div class="content">also the output in markdown and php doesn&#x27;t seem good</div><br/></div></div></div></div><div id="41940636" class="c"><input type="checkbox" id="c-41940636" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#41943221">prev</a><span>|</span><a href="#41940880">next</a><span>|</span><label class="collapse" for="c-41940636">[-]</label><label class="expand" for="c-41940636">[1 more]</label></div><br/><div class="children"><div class="content">Have you heard of wit? I suspect we&#x27;ll see use outside of WebAssembly. <a href="https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html" rel="nofollow">https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html</a><p>It has non-nullable types, via option, which makes non-nullable the default, since you have to explicitly wrap it in option. <a href="https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html#options" rel="nofollow">https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html...</a><p>A way to represent types commonly found in major languages would be nice, but it would be better to start with something like wit and build on top of it, or at least have a lot of overlap with it.</div><br/></div></div><div id="41940880" class="c"><input type="checkbox" id="c-41940880" checked=""/><div class="controls bullet"><span class="by">matthewtovbin</span><span>|</span><a href="#41940636">prev</a><span>|</span><a href="#41939623">next</a><span>|</span><label class="collapse" for="c-41940880">[-]</label><label class="expand" for="c-41940880">[3 more]</label></div><br/><div class="children"><div class="content">Why reinvent <a href="https:&#x2F;&#x2F;json-schema.org" rel="nofollow">https:&#x2F;&#x2F;json-schema.org</a> ?? Pros&#x2F;cons?</div><br/><div id="41941184" class="c"><input type="checkbox" id="c-41941184" checked=""/><div class="controls bullet"><span class="by">michaelsalim</span><span>|</span><a href="#41940880">parent</a><span>|</span><a href="#41942654">next</a><span>|</span><label class="collapse" for="c-41941184">[-]</label><label class="expand" for="c-41941184">[1 more]</label></div><br/><div class="children"><div class="content">From my understanding, JSON schema describes the schema of JSON objects with JSON. This one describes a variety of types of schemas with JSON.<p>So it could be typescript, Go, GraphQL, etc. It seems to output to JSON schema as well. I guess its main purpose is to share the schema between different languages. Which I imagine works with JSON schema too, but this takes it a step further and handle all the mapping you&#x27;d need to do otherwise.</div><br/></div></div><div id="41942654" class="c"><input type="checkbox" id="c-41942654" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41940880">parent</a><span>|</span><a href="#41941184">prev</a><span>|</span><a href="#41939623">next</a><span>|</span><label class="collapse" for="c-41942654">[-]</label><label class="expand" for="c-41942654">[1 more]</label></div><br/><div class="children"><div class="content">json schema has nuanced and expressive constraints to validate information exchanged in json serialization.<p>typeschema in contrast seems to focus on describing just the structure of data with the goal to generate stubs in a wide variety of programming languages.</div><br/></div></div></div></div><div id="41939623" class="c"><input type="checkbox" id="c-41939623" checked=""/><div class="controls bullet"><span class="by">cmgriffing</span><span>|</span><a href="#41940880">prev</a><span>|</span><a href="#41939173">next</a><span>|</span><label class="collapse" for="c-41939623">[-]</label><label class="expand" for="c-41939623">[1 more]</label></div><br/><div class="children"><div class="content">I find it interesting that the Go serialization just duplicates the props rather than using composition:
<a href="https:&#x2F;&#x2F;typeschema.org&#x2F;example&#x2F;go" rel="nofollow">https:&#x2F;&#x2F;typeschema.org&#x2F;example&#x2F;go</a><p>Seems a bit naively implemented.<p>Ideally, the duplicated props in Student would just be a single line of `Human`.</div><br/></div></div><div id="41939173" class="c"><input type="checkbox" id="c-41939173" checked=""/><div class="controls bullet"><span class="by">Onawa</span><span>|</span><a href="#41939623">prev</a><span>|</span><a href="#41939186">next</a><span>|</span><label class="collapse" for="c-41939173">[-]</label><label class="expand" for="c-41939173">[1 more]</label></div><br/><div class="children"><div class="content">Comparison between TypeSchema and LinkML for those interested as I was. <a href="https:&#x2F;&#x2F;www.perplexity.ai&#x2F;search&#x2F;please-compare-and-contrast-ty-opZqT8efRDWJMUHFLlXkyA#0" rel="nofollow">https:&#x2F;&#x2F;www.perplexity.ai&#x2F;search&#x2F;please-compare-and-contrast...</a></div><br/></div></div><div id="41939186" class="c"><input type="checkbox" id="c-41939186" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#41939173">prev</a><span>|</span><a href="#41942004">next</a><span>|</span><label class="collapse" for="c-41939186">[-]</label><label class="expand" for="c-41939186">[16 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the benefit over existing variants like Swagger&#x2F;OpenAPI&#x2F;JsonSchema ?</div><br/><div id="41939356" class="c"><input type="checkbox" id="c-41939356" checked=""/><div class="controls bullet"><span class="by">mariocesar</span><span>|</span><a href="#41939186">parent</a><span>|</span><a href="#41939469">next</a><span>|</span><label class="collapse" for="c-41939356">[-]</label><label class="expand" for="c-41939356">[1 more]</label></div><br/><div class="children"><div class="content">It feels like a convert solution, as it can transform TypeSchema into JsonSchema.</div><br/></div></div><div id="41939469" class="c"><input type="checkbox" id="c-41939469" checked=""/><div class="controls bullet"><span class="by">8338550bff96</span><span>|</span><a href="#41939186">parent</a><span>|</span><a href="#41939356">prev</a><span>|</span><a href="#41939552">next</a><span>|</span><label class="collapse" for="c-41939469">[-]</label><label class="expand" for="c-41939469">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;m not really following the line of reasoning presented on the &quot;&#x2F;history&quot; page: <a href="https:&#x2F;&#x2F;typeschema.org&#x2F;history" rel="nofollow">https:&#x2F;&#x2F;typeschema.org&#x2F;history</a><p>It seems to me like a mischaracterization of JSON Schema to say you can&#x27;t define a concrete type without actual data.<p>I am a very stupid individual so I could be misunderstanding the argument.</div><br/><div id="41940076" class="c"><input type="checkbox" id="c-41940076" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939469">parent</a><span>|</span><a href="#41939887">next</a><span>|</span><label class="collapse" for="c-41940076">[-]</label><label class="expand" for="c-41940076">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t really follow those arguments either. For example the empty object example {}. Why is this bad? Types without properties are a real thing. Also an empty schema is a real thing.<p>The thought I do get: JSON Schema primarily describes one main document (object&#x2F;thing). And additionally defines named types (#&#x2F;definitions&#x2F;Student). But it&#x27;s totally fine to just use the definitions for code generation.<p>The reference semantics of JSON Schema is quite powerful, a little bit like XML with XSD and all the different imports and addons.</div><br/><div id="41941440" class="c"><input type="checkbox" id="c-41941440" checked=""/><div class="controls bullet"><span class="by">llamaLord</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41940076">parent</a><span>|</span><a href="#41939887">next</a><span>|</span><label class="collapse" for="c-41941440">[-]</label><label class="expand" for="c-41941440">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s just me, but I&#x27;ve never been able to get a complex type schema to work properly with JSON schema.<p>The moment you have types referencing other types in a way that can become recursive in ANY way, the whole thing seems to explode.</div><br/></div></div></div></div></div></div><div id="41939552" class="c"><input type="checkbox" id="c-41939552" checked=""/><div class="controls bullet"><span class="by">mchicken</span><span>|</span><a href="#41939186">parent</a><span>|</span><a href="#41939469">prev</a><span>|</span><a href="#41939423">next</a><span>|</span><label class="collapse" for="c-41939552">[-]</label><label class="expand" for="c-41939552">[1 more]</label></div><br/><div class="children"><div class="content">It looks far more constrained, especially when it comes to the validation logic, which makes sense validation-wise but honestly quickly becomes a &quot;fate shovels shit in my face&quot; kind of situation when it comes to code generation. As much as I love this sort of constraints I also find the union-type discrimination style &quot;meh&quot;.</div><br/></div></div><div id="41939423" class="c"><input type="checkbox" id="c-41939423" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#41939186">parent</a><span>|</span><a href="#41939552">prev</a><span>|</span><a href="#41942004">next</a><span>|</span><label class="collapse" for="c-41939423">[-]</label><label class="expand" for="c-41939423">[9 more]</label></div><br/><div class="children"><div class="content">Heh feels like Json schema to me too... Same, but different.</div><br/><div id="41939493" class="c"><input type="checkbox" id="c-41939493" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939423">parent</a><span>|</span><a href="#41942004">next</a><span>|</span><label class="collapse" for="c-41939493">[-]</label><label class="expand" for="c-41939493">[8 more]</label></div><br/><div class="children"><div class="content">Feels much weaker&#x2F;naive than JSON Schema, as TypeSchema barely has any constraints.<p>The TypeSchema spec is hard to comprehend as it doesn&#x27;t delve into any details and looks like just a bunch of random examples with comments than a proper definitive document (e.g. they don&#x27;t ever seem to define what &quot;date-time&quot; string format is). I don&#x27;t see a way to say, e.g., that a string must be an UUIDv7, or that an integer must be non-negative, or support for heterogeneous collections, etc etc.<p>Maybe it has some uses for code generation across multiple languages for very simple JSON structures, but that feels like a very niche use case. And even then, if you have to hook up per-language validation logic anyway (and probably language-specific patterns too, to express concepts idiomatically), what&#x27;s the point of a code generator?</div><br/><div id="41939556" class="c"><input type="checkbox" id="c-41939556" checked=""/><div class="controls bullet"><span class="by">amanzi</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939493">parent</a><span>|</span><a href="#41942004">next</a><span>|</span><label class="collapse" for="c-41939556">[-]</label><label class="expand" for="c-41939556">[7 more]</label></div><br/><div class="children"><div class="content">&quot;What is the difference to JSON Schema?
JSON Schema is a constraint system which is designed to validate JSON data. Such a constraint system is not great for code generation, with TypeSchema our focus is to model data to be able to generate high quality code.&quot;<p>They have more details on the History page.</div><br/><div id="41939651" class="c"><input type="checkbox" id="c-41939651" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939556">parent</a><span>|</span><a href="#41939614">next</a><span>|</span><label class="collapse" for="c-41939651">[-]</label><label class="expand" for="c-41939651">[5 more]</label></div><br/><div class="children"><div class="content">Those are certainly words, but since the words they use to describe what differentiates them form JSON Schema is just asserting that their thing is for exactly what has always motivated schema languages including, but not limited to, JSON Schema, and since JSON Schema supports that purpose far better, I am left confused<p>At best, I can guess that maybe they are trying to get at the fact that JSON schema supports some structures that can be awkward or unidiomatic for data models in some languages (a lot of what you can do via allOf or oneOf fits this) and they want to narrow down to something where what can be defined in the schema language is also simple idiomatic structures nearly everywhere, but a restricted profile of JSON Schema would get you there much faster than starting from the ground up.</div><br/><div id="41939721" class="c"><input type="checkbox" id="c-41939721" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939651">parent</a><span>|</span><a href="#41940093">next</a><span>|</span><label class="collapse" for="c-41939721">[-]</label><label class="expand" for="c-41939721">[3 more]</label></div><br/><div class="children"><div class="content">&gt; narrow down to something where what can be defined in the schema language is also simple idiomatic structures nearly everywhere<p>It feels more like a lowest common denominator to me, which is frequently (in presence of anything non-trivial) the opposite of idiomatic.<p>For example, JSON does not have monetary&#x2F;decimal type, best option available is a string. It would be very opposite of idiomatic to have a C# or Python code use a string in the record&#x2F;dataclass, instead of a decimal, if the actual JSON document field has the &quot;monetary value&quot; semantic.<p>And TypeSchema seem to ignore aspects like nullability and presence requirements, making assumptions that everything can be null (which can be wrong and even harmful, as if Java haven&#x27;t taught us anything).<p>Maybe I&#x27;m thinking wrong about it and the idea is to have separate wire and public API formats, though, where the wire format is minimal JSON (TypeSchema can work, I guess, although I still have concerns about nulls - and distinguishing between nulls and absence of the field) and then that intermediate almost-over-the-wire-but-deserialized-from-JSON-blob object representation is adapted into a language-specific idiomatic structure. I always felt that such approach is way too verbose and adds a lot of boilerplate without a good reason, but I could be wrong about it.</div><br/><div id="41939815" class="c"><input type="checkbox" id="c-41939815" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939721">parent</a><span>|</span><a href="#41940093">next</a><span>|</span><label class="collapse" for="c-41939815">[-]</label><label class="expand" for="c-41939815">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, “idiomatic” may have been a poor word choice, I really meant closer to “simply representable”. oneOf, for instance, lets you very easily define flexible, concise structures in JSON Schema that OO languages without union types may not express naturally if at all, and which may not be natural to work with even if they cna be expressed in many languages.</div><br/><div id="41939995" class="c"><input type="checkbox" id="c-41939995" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939815">parent</a><span>|</span><a href="#41940093">next</a><span>|</span><label class="collapse" for="c-41939995">[-]</label><label class="expand" for="c-41939995">[1 more]</label></div><br/><div class="children"><div class="content">This makes sense, but I think it&#x27;s even a better reason to not use a code generator (which forces certain patterns on your code), but rather think about the best language-native way to express a certain concept you want to express.</div><br/></div></div></div></div></div></div><div id="41940093" class="c"><input type="checkbox" id="c-41940093" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939651">parent</a><span>|</span><a href="#41939721">prev</a><span>|</span><a href="#41939614">next</a><span>|</span><label class="collapse" for="c-41940093">[-]</label><label class="expand" for="c-41940093">[1 more]</label></div><br/><div class="children"><div class="content">Restricting JSON Schema would&#x27;ve been my approach to this &quot;problem&quot; too.</div><br/></div></div></div></div><div id="41939614" class="c"><input type="checkbox" id="c-41939614" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41939186">root</a><span>|</span><a href="#41939556">parent</a><span>|</span><a href="#41939651">prev</a><span>|</span><a href="#41942004">next</a><span>|</span><label class="collapse" for="c-41939614">[-]</label><label class="expand" for="c-41939614">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve edited my comment above and added the last paragraph with a note about it. Must be a really weird use case when you need to write a bunch of code in different languages (probably writing libraries for some API or JSON-based data interchange format?), and is also not concerned about validation and language - because if you need validation, you&#x27;re writing code by hand either way, so code generation becomes a curse rather than a blessing.<p>I would&#x27;ve understood if it would do the inverse - read source code in any of the supported languages, and check if the structures it define it conforms to the schema. That would make sense for testing that those structs aren&#x27;t too diverging between codebases (have the same-shaped fields). Even then I&#x27;m not sure I see the point because various languages tend to use different language-specific things (like an UUID type or enums&#x2F;symbols&#x2F;atoms, etc.) to make developer feel at home rather than in a barren JSONland.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41942004" class="c"><input type="checkbox" id="c-41942004" checked=""/><div class="controls bullet"><span class="by">ssousa666</span><span>|</span><a href="#41939186">prev</a><span>|</span><a href="#41940943">next</a><span>|</span><label class="collapse" for="c-41942004">[-]</label><label class="expand" for="c-41942004">[1 more]</label></div><br/><div class="children"><div class="content">Kotlin classes are (seemingly) all generated as open classes, rather than data classes. Surprising choice - is this an intentional design decision? Wondering if I am missing something</div><br/></div></div><div id="41940943" class="c"><input type="checkbox" id="c-41940943" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#41942004">prev</a><span>|</span><a href="#41939805">next</a><span>|</span><label class="collapse" for="c-41940943">[-]</label><label class="expand" for="c-41940943">[2 more]</label></div><br/><div class="children"><div class="content">Looking at the Kotlin or TypeScript examples, it would be preferable to use one of them as source and parse it to output other formats. An LLM would probably be good at doing this too. Unless it can do more than generate boilerplate code I can&#x27;t see needing this.</div><br/><div id="41942938" class="c"><input type="checkbox" id="c-41942938" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#41940943">parent</a><span>|</span><a href="#41939805">next</a><span>|</span><label class="collapse" for="c-41942938">[-]</label><label class="expand" for="c-41942938">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need an LLM for that task.</div><br/></div></div></div></div><div id="41939805" class="c"><input type="checkbox" id="c-41939805" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#41940943">prev</a><span>|</span><a href="#41941443">next</a><span>|</span><label class="collapse" for="c-41939805">[-]</label><label class="expand" for="c-41939805">[1 more]</label></div><br/><div class="children"><div class="content">The rust generator seems not to place generic parameters on the type itself?<p>use serde::{Serialize, Deserialize};
#[derive(Serialize, Deserialize)]
pub struct Map {
    #[serde(rename = &quot;totalResults&quot;)]
    total_results: Option&lt;u64&gt;,<p><pre><code>    #[serde(rename = &quot;entries&quot;)]
    entries: Option&lt;Vec&lt;T&gt;&gt;,

}</code></pre></div><br/></div></div><div id="41941443" class="c"><input type="checkbox" id="c-41941443" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#41939805">prev</a><span>|</span><a href="#41940338">next</a><span>|</span><label class="collapse" for="c-41941443">[-]</label><label class="expand" for="c-41941443">[1 more]</label></div><br/><div class="children"><div class="content">Kinda crazy question, but why not support SQL table&#x2F;column DDL (nested JSON or arrays within those for bonus points)?</div><br/></div></div><div id="41940338" class="c"><input type="checkbox" id="c-41940338" checked=""/><div class="controls bullet"><span class="by">georyb</span><span>|</span><a href="#41941443">prev</a><span>|</span><a href="#41940630">next</a><span>|</span><label class="collapse" for="c-41940338">[-]</label><label class="expand" for="c-41940338">[1 more]</label></div><br/><div class="children"><div class="content">This is great. Some positivity, since many comments are on the negative side.<p>It&#x27;s exactly what I need to connect .py with .ts</div><br/></div></div><div id="41940630" class="c"><input type="checkbox" id="c-41940630" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#41940338">prev</a><span>|</span><a href="#41940228">next</a><span>|</span><label class="collapse" for="c-41940630">[-]</label><label class="expand" for="c-41940630">[1 more]</label></div><br/><div class="children"><div class="content">Why is everything nullable?</div><br/></div></div><div id="41940228" class="c"><input type="checkbox" id="c-41940228" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#41940630">prev</a><span>|</span><a href="#41939860">next</a><span>|</span><label class="collapse" for="c-41940228">[-]</label><label class="expand" for="c-41940228">[1 more]</label></div><br/><div class="children"><div class="content">If I had the spare time I would love to contribute dart support, but alas...</div><br/></div></div><div id="41939860" class="c"><input type="checkbox" id="c-41939860" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41940228">prev</a><span>|</span><a href="#41941639">next</a><span>|</span><label class="collapse" for="c-41939860">[-]</label><label class="expand" for="c-41939860">[3 more]</label></div><br/><div class="children"><div class="content">TypeScript but no JavaScript is a tiny bit disappointing. I still like to be able to work on front-end code without needing to run separate build tooling.</div><br/><div id="41940035" class="c"><input type="checkbox" id="c-41940035" checked=""/><div class="controls bullet"><span class="by">creatonez</span><span>|</span><a href="#41939860">parent</a><span>|</span><a href="#41942331">next</a><span>|</span><label class="collapse" for="c-41940035">[-]</label><label class="expand" for="c-41940035">[1 more]</label></div><br/><div class="children"><div class="content">This tool can convert to JSON Schema, so it can be used with validator libraries. Either way, validation and static duck typing based on schema are two separate concerns, and the latter is impossible without something like a Typescript compiler (or checker if using jsdoc-style Typescript).</div><br/></div></div><div id="41942331" class="c"><input type="checkbox" id="c-41942331" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41939860">parent</a><span>|</span><a href="#41940035">prev</a><span>|</span><a href="#41941639">next</a><span>|</span><label class="collapse" for="c-41942331">[-]</label><label class="expand" for="c-41942331">[1 more]</label></div><br/><div class="children"><div class="content">It can actually generate the JavaScript type definitions for all possible inputs at once! Here, I&#x27;ll copy and paste the result for you:<p>Hope that helps.</div><br/></div></div></div></div><div id="41941639" class="c"><input type="checkbox" id="c-41941639" checked=""/><div class="controls bullet"><span class="by">miffy900</span><span>|</span><a href="#41939860">prev</a><span>|</span><a href="#41939436">next</a><span>|</span><label class="collapse" for="c-41941639">[-]</label><label class="expand" for="c-41941639">[1 more]</label></div><br/><div class="children"><div class="content">From the history page:<p>&gt; JSON Schema is a constraint system which is designed to validate JSON data. Such a constraint system is not great for code generation, with TypeSchema our focus is to model data to be able to generate high quality code.<p>Well, types themselves are another type of constraint; specifying something like the type (number) of a property (Age) is a constraint on the possible values for that property.<p>&gt; For code generators it is difficult to work with JSON Schema since it is designed to validate JSON data<p>There&#x27;s lots of features in JSON Schema, but if you&#x27;re writing a code generator, you don&#x27;t actually to have support all of them. Some languages like C# don&#x27;t have native lang support for AllOf, but do support OneOf or AnyOf.<p>&gt; JSON Schema has many keywords which contain logic like dependencies, not, if&#x2F;then&#x2F;else which are basically not needed for code generators and really complicates building them.<p>So isn&#x27;t the whole point of code generators for OpenAPI&#x2F;JSON Schema is that they generate code to map foreign data sources in a target programming language so that the programmer doesn&#x27;t have to write all this mapping code by hand? The vast majority of all programming languages support if&#x2F;then&#x2F;else and even modelling dependencies like what JSON Schema supports. So why is it a bad thing if a schema language like JSON Schema supports these constraints? Wouldn&#x27;t having support for this in the schema language and a code generator mean less handwritten code and more time saved?<p>If a schema constrained Person.Age to be an integer always greater than 0, I would actually really love for that validation code to be generated for me. Chances are, if such constraints exist in the schema, then the vendor&#x2F;original author probably has good reason to include them; having it code generated automatically means I don&#x27;t have to worry about writing it myself.<p>I mean if you want to generate the code for only defining data structures &amp; their properties, you can still do that, and just stop there. A whole new schema language in JSON seems wholly redundant. It seems like maybe the authors should&#x27;ve started with writing their own better code generator for JSON Schema rather than their whole new schema language and code generator.<p>Finally, reading the spec <a href="https:&#x2F;&#x2F;typeschema.org&#x2F;specification" rel="nofollow">https:&#x2F;&#x2F;typeschema.org&#x2F;specification</a>, I can&#x27;t see support for optional values or null&#x2F;nullable types. I&#x27;m hoping it&#x27;s just an oversight (seeing as how the spec itself is incredibly brief), but if it isn&#x27;t, then bluntly, then this isn&#x27;t ready for release.</div><br/></div></div><div id="41939436" class="c"><input type="checkbox" id="c-41939436" checked=""/><div class="controls bullet"><span class="by">banga</span><span>|</span><a href="#41941639">prev</a><span>|</span><a href="#41940599">next</a><span>|</span><label class="collapse" for="c-41939436">[-]</label><label class="expand" for="c-41939436">[2 more]</label></div><br/><div class="children"><div class="content">Obligatory <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a></div><br/><div id="41940234" class="c"><input type="checkbox" id="c-41940234" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#41939436">parent</a><span>|</span><a href="#41940599">next</a><span>|</span><label class="collapse" for="c-41940234">[-]</label><label class="expand" for="c-41940234">[1 more]</label></div><br/><div class="children"><div class="content">?</div><br/></div></div></div></div></div></div></div></div></div></body></html>