<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716195673996" as="style"/><link rel="stylesheet" href="styles.css?v=1716195673996"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kilianvalkhof.com/2024/javascript/the-problem-with-new-url-and-how-url-parse-fixes-that/">The problem with new URL(), and how URL.parse() fixes that</a> <span class="domain">(<a href="https://kilianvalkhof.com">kilianvalkhof.com</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>64 comments</span></div><br/><div><div id="40413516" class="c"><input type="checkbox" id="c-40413516" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40411256">next</a><span>|</span><label class="collapse" for="c-40413516">[-]</label><label class="expand" for="c-40413516">[1 more]</label></div><br/><div class="children"><div class="content">Why would you want to have a constructor of type T that returns you something that is not even an object of that type T? If you need the &quot;return null on error&quot; behaviour — so that you can never check that it&#x27;s null (or forget to check) and let your execution stop with &quot;TypeError: Cannot read properties of null&quot; way down the line instead of right here, where you can fix it immediately before even shipping the code — then just write a tryParse() wrapper for that!<p>Now, to be fair, having a public constructor for URL with just a string as the argument, with the parsing semantics is arguably an anti-pattern, and a static factory function would serve much better indeed. A proper public URL constructor should instead take (scheme, authority, path, query, fragment) tuple and validate its constituents. The private URL constructor could be the one without validation, and that&#x27;s what parse() and the public constructor would call internally.</div><br/></div></div><div id="40411256" class="c"><input type="checkbox" id="c-40411256" checked=""/><div class="controls bullet"><span class="by">happytoexplain</span><span>|</span><a href="#40413516">prev</a><span>|</span><a href="#40413216">next</a><span>|</span><label class="collapse" for="c-40411256">[-]</label><label class="expand" for="c-40411256">[26 more]</label></div><br/><div class="children"><div class="content">Swift, and I imagine other modern languages, do this the right way. Their idiomatic error passing is via try&#x2F;catch, which is the best error handling pattern we&#x27;ve figured out so far, but instead of bloating the API for every case where somebody might theoretically not care about the specific error and isn&#x27;t doing multiple failable operations in close proximity, it just adds some sugar to get the result described in this article:<p>`let fooOrNil = try? Foo(&quot;blah&quot;)`<p>Edit: Updated URL to Foo, since Swift happens to use optional return for its own &#x27;URL&#x27; type, as pointed out.</div><br/><div id="40411390" class="c"><input type="checkbox" id="c-40411390" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40411256">parent</a><span>|</span><a href="#40411295">next</a><span>|</span><label class="collapse" for="c-40411390">[-]</label><label class="expand" for="c-40411390">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Their idiomatic error passing is via try&#x2F;catch, which is the best error handling pattern we&#x27;ve figured out so far, ...<p>I find monadic error handling (`Result&lt;T, E&gt;` and `Option&lt;T&gt;`, or `Either&lt;T, U&gt;` and `Maybe&lt;T&gt;` if you prefer Haskell) to be much better at keeping error handling logic local to where errors originate, and making it explicit which operations are fallible and what errors they produce. Exceptions tend to be nonlocal and difficult to determine what exceptions can occur from where.<p>That sugar for getting an optional&#x2F;nullable value with `try?` definitely looks nice, I wish Python had something like that, but it seems to me that the reason it works better is that it&#x27;s closer to monadic error handling (you get an `Option&lt;T&gt;`).<p>Has your experience been different?</div><br/><div id="40411511" class="c"><input type="checkbox" id="c-40411511" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411390">parent</a><span>|</span><a href="#40411489">next</a><span>|</span><label class="collapse" for="c-40411511">[-]</label><label class="expand" for="c-40411511">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Exceptions tend to be nonlocal and difficult to determine what exceptions can occur from where.<p>This is true statically (mitigated by checked exceptions in Java, but that&#x27;s a whole can of worms on its own), but the opposite is true when you actually have an error at runtime—exceptions come bundled with stack traces which make it very easy to see the stack of function calls that get us into the failure state, where with result types you at best have a (hopefully descriptive) error message and that&#x27;s it.<p>If the code has already been well polished then that error message is probably enough, but if you&#x27;re still ironing out rough edges the error message itself may be in error and the actual problem may be somewhere else entirely. With a stack trace you can easily see the function calls that got into that unexpected state, but without them you&#x27;re on your own and have to try to recreate the error while stepping through in the debugger.</div><br/><div id="40411575" class="c"><input type="checkbox" id="c-40411575" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411511">parent</a><span>|</span><a href="#40411489">next</a><span>|</span><label class="collapse" for="c-40411575">[-]</label><label class="expand" for="c-40411575">[4 more]</label></div><br/><div class="children"><div class="content">But with a `Result` type, I&#x27;m forced to deal with each error case at compile time, so I avoid finding out about an unexpected edge case at runtime in the first place!<p>(My perspective is Rust centric, and if you eg unwrap an error because you mistakenly thought it shouldn&#x27;t be reachable, you end up with a panic which is just an exception.)</div><br/><div id="40412116" class="c"><input type="checkbox" id="c-40412116" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411575">parent</a><span>|</span><a href="#40411489">next</a><span>|</span><label class="collapse" for="c-40412116">[-]</label><label class="expand" for="c-40412116">[3 more]</label></div><br/><div class="children"><div class="content">&gt; so I avoid finding out about an unexpected edge case at runtime in the first place!<p>This has not been my experience with Rust. In my experience I&#x27;ll handle all the errors just fine—nothing is unexpectedly crashing—but then every once in a while an error object will propagate up and I&#x27;ll have no clue why that error got triggered by that input. If I&#x27;m lucky I&#x27;m working on something that makes dropping into the debugger easy, but other times this is the beginning of a very long troubleshooting session that would have been much shorter if I had a stack trace.<p>Mind you, this always does turn out to be a mistake in my code that caused an error to get returned incorrectly, but Rust doesn&#x27;t help me find and fix these problems the way that Java does.<p>(My personal opinion is that Java&#x27;s checked exceptions were on the right track and just need some UX improvements and syntactic sugar for handling them. They provide all the safety of a result type with all the debugability of an exception.)</div><br/><div id="40413489" class="c"><input type="checkbox" id="c-40413489" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40412116">parent</a><span>|</span><a href="#40412240">next</a><span>|</span><label class="collapse" for="c-40413489">[-]</label><label class="expand" for="c-40413489">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (My personal opinion is that Java&#x27;s checked exceptions were on the right track and just need some UX improvements and syntactic sugar for handling them. They provide all the safety of a result type with all the debugability of an exception.)<p>Except that it does not matter whether exception is checked when reflection is used. All you get is unchecked InvocationTargetException that wraps the actual exception.<p>To the best of my knowledge method signatures in JVM do not contain declarations of thrown exceptions, that&#x27;s Java thing. Java being Java, all the sparkly modularization and stuff means that effectively calls to entrypoint methods are hidden behind `invoke()` anyway. Or compiled against binary libraries.<p>Checked exceptions only work as supposed to only under very specific circumstances, usually don&#x27;t and that is by design - Java&#x2F;JVM features do not interact with each other nicely.</div><br/></div></div><div id="40412240" class="c"><input type="checkbox" id="c-40412240" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40412116">parent</a><span>|</span><a href="#40413489">prev</a><span>|</span><a href="#40411489">next</a><span>|</span><label class="collapse" for="c-40412240">[-]</label><label class="expand" for="c-40412240">[1 more]</label></div><br/><div class="children"><div class="content">Huh, interesting. So is this a situation where a library uses one error type for everything, so there are several function calls which could have triggered it, or where the documentation is lacking so you know where it was triggered but lack context? Or something I&#x27;m failing to imagine?<p>ETA: Rereading I see you meant that an error was returned from the wrong code path. That is interesting, and I do see why you&#x27;re lamenting the lack of a stack trace in that situation. Maybe there&#x27;s some way to write a library like `thiserror` that includes a lightweight, application level &quot;breadcrumb trail&quot; that&#x27;s cheaper than a stack trace but with some of the observability improvement, I&#x27;m not sure. Maybe I&#x27;m just reinventing logging.</div><br/></div></div></div></div></div></div></div></div><div id="40411489" class="c"><input type="checkbox" id="c-40411489" checked=""/><div class="controls bullet"><span class="by">happytoexplain</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411390">parent</a><span>|</span><a href="#40411511">prev</a><span>|</span><a href="#40411295">next</a><span>|</span><label class="collapse" for="c-40411489">[-]</label><label class="expand" for="c-40411489">[2 more]</label></div><br/><div class="children"><div class="content">&gt;making it explicit which operations are fallible and what errors they produce<p>I should specify that throwability needs to be part of the function signature to be useful in the language. As for what types of errors: At minimum they should provide something you can show a user, maybe after adding context, and the machine-readable codes should be documented, both of which are points of failure, but the ability is there.<p>Interestingly, Swift is getting typed exceptions, which seems too good to be true. I&#x27;m not sure how it works when passing exceptions up the call chain.<p>As for Optional&#x2F;Maybe, as I replied to a sibling, that&#x27;s not really comparable. It&#x27;s not for error-handling because it doesn&#x27;t provide an error. It&#x27;s useful for when something might not exist, but not so much for when some input is invalid, etc, since it&#x27;s more verbose to explicitly fork on null and return early.<p>As for Result&lt;T,E&gt;, it has a subset of the same problems: Can&#x27;t pass it up without writing a fork&#x2F;switch unless it&#x27;s just a wrapper function that returns Result&lt;T,E&gt;. And it makes things less composable or require extra forks when something is expecting T. But, like Optional, it definitely has uses: Like if you&#x27;re using a callback system for an async function, where throwing is impossible.</div><br/><div id="40411539" class="c"><input type="checkbox" id="c-40411539" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411489">parent</a><span>|</span><a href="#40411295">next</a><span>|</span><label class="collapse" for="c-40411539">[-]</label><label class="expand" for="c-40411539">[1 more]</label></div><br/><div class="children"><div class="content">I agree that exceptions are much more tolerable when they&#x27;re part of the method signature. Otherwise you have to dig through the code to figure them out, and that&#x27;s a mess.<p>You can think of `Optional&lt;T&gt;` as being `Result&lt;T, null&gt;` - it&#x27;s a fallible operation where there is either one obvious way it can fail or where we don&#x27;t care to distinguish between them. If you look a key up in a map, that&#x27;s a fallible operation, but there&#x27;s only one way for it to fail - the key wasn&#x27;t present in the dictionary. It&#x27;s definitely error handling.<p>`Result` really comes into it&#x27;s own when combined with pattern matching (`switch` with destructuring and exhaustiveness, so compilation will fail if you&#x27;ve neglected to handle a certain error case (!!!)). Rust adds syntactic sugar and other features that make this very ergonomic. Eg, there&#x27;s a `?` operator that will return early if there is an error, and traits (interfaces) that make it seamless to convert one error into another, add error messages, etc.<p>&gt; it makes things less composable<p>Not so! They&#x27;re very composable, eg:<p><pre><code>    let x = my_fallible_operation().map(|v| do_something_on_success(v)).or(other_fallible_operation_to_compose_with())
</code></pre>
If `my_fallible_operation()` success, `x` will be `Ok(do_something_on_success(v))`; otherwise, it will be the return value of `other_fallible_operation_to_compose_with()` (itself a result).</div><br/></div></div></div></div></div></div><div id="40411295" class="c"><input type="checkbox" id="c-40411295" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#40411256">parent</a><span>|</span><a href="#40411390">prev</a><span>|</span><a href="#40411360">next</a><span>|</span><label class="collapse" for="c-40411295">[-]</label><label class="expand" for="c-40411295">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s arguably a poor use of exceptions.  Swift has URL.init which returns nil if parsing fails. It doesn&#x27;t throw.</div><br/><div id="40411326" class="c"><input type="checkbox" id="c-40411326" checked=""/><div class="controls bullet"><span class="by">happytoexplain</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411295">parent</a><span>|</span><a href="#40411360">next</a><span>|</span><label class="collapse" for="c-40411326">[-]</label><label class="expand" for="c-40411326">[3 more]</label></div><br/><div class="children"><div class="content">I only meant to illustrate the feature, not argue that this specific constructor should use exceptions vs optional return.<p>Regardless: Why would it be a bad use of exceptions? It reduces the API size and unifies flows, and gives me the option of seeing the specific error. It simply happens to be that in practice I&#x27;ve never needed to know the specific error in this case.</div><br/><div id="40411451" class="c"><input type="checkbox" id="c-40411451" checked=""/><div class="controls bullet"><span class="by">taspeotis</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411326">parent</a><span>|</span><a href="#40411503">next</a><span>|</span><label class="collapse" for="c-40411451">[-]</label><label class="expand" for="c-40411451">[1 more]</label></div><br/><div class="children"><div class="content">In .NET it’s idiomatic to avoid exceptions for control flow because “it failed to parse” means creating an exception which costs you an allocation and getting the stack trace, among other things.</div><br/></div></div><div id="40411503" class="c"><input type="checkbox" id="c-40411503" checked=""/><div class="controls bullet"><span class="by">positr0n</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411326">parent</a><span>|</span><a href="#40411451">prev</a><span>|</span><a href="#40411360">next</a><span>|</span><label class="collapse" for="c-40411503">[-]</label><label class="expand" for="c-40411503">[1 more]</label></div><br/><div class="children"><div class="content">Exceptions are nice DX, but theoretically if you were parsing URLs in an inner loop and expecting lots of them to fail it would be very expensive compared to returning a tuple (or Optional, whatever).</div><br/></div></div></div></div></div></div><div id="40411360" class="c"><input type="checkbox" id="c-40411360" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#40411256">parent</a><span>|</span><a href="#40411295">prev</a><span>|</span><a href="#40411475">next</a><span>|</span><label class="collapse" for="c-40411360">[-]</label><label class="expand" for="c-40411360">[11 more]</label></div><br/><div class="children"><div class="content">I much prefer Maybe types to try&#x2F;catch.</div><br/><div id="40413392" class="c"><input type="checkbox" id="c-40413392" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411360">parent</a><span>|</span><a href="#40411392">next</a><span>|</span><label class="collapse" for="c-40413392">[-]</label><label class="expand" for="c-40413392">[1 more]</label></div><br/><div class="children"><div class="content">They are not quite orthogonal but at least independent.<p>Maybe&#x2F;Either&#x2F;Result is a way to represent partial computations at runtime.<p>try&#x2F;catch is a syntax to detect partial computations and to do something conditionally if one occurs.<p>You could have a language that used try&#x2F;catch syntax to catch Result types, indeed Rust does <i>something</i> like this with the try operator although it’s only try&#x2F;catch if you squint very hard.</div><br/></div></div><div id="40411392" class="c"><input type="checkbox" id="c-40411392" checked=""/><div class="controls bullet"><span class="by">happytoexplain</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411360">parent</a><span>|</span><a href="#40413392">prev</a><span>|</span><a href="#40411475">next</a><span>|</span><label class="collapse" for="c-40411392">[-]</label><label class="expand" for="c-40411392">[9 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not really comparable. They serve different purposes. Maybe&#x2F;Optional is for when something might not be, while try&#x2F;catch is a powerful system for passing both user-facing and machine-readable information about errors across potentially multiple layers of API. A powerful language has both.<p>Saying &quot;I prefer Maybe to try&#x2F;catch&quot; is too broad - it&#x27;s almost like saying you prefer not to handle errors.</div><br/><div id="40411507" class="c"><input type="checkbox" id="c-40411507" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411392">parent</a><span>|</span><a href="#40411513">next</a><span>|</span><label class="collapse" for="c-40411507">[-]</label><label class="expand" for="c-40411507">[1 more]</label></div><br/><div class="children"><div class="content">You have this exactly backwards as far as I am concerned. Exceptions might seem like they force you to handle errors, but in practice they force you to, at some level, not handle them. I&#x27;ve never seen a serious, production-serving tome of code that doesn&#x27;t end up generically catching all exceptions at the top and logging them blindly because all context has been lost.<p>If you were forced to handle exceptions at every call site I might find myself able to agree, but then you have something functionally equivalent to options. I&#x27;d much rather just start with that approach.</div><br/></div></div><div id="40411513" class="c"><input type="checkbox" id="c-40411513" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411392">parent</a><span>|</span><a href="#40411507">prev</a><span>|</span><a href="#40411479">next</a><span>|</span><label class="collapse" for="c-40411513">[-]</label><label class="expand" for="c-40411513">[1 more]</label></div><br/><div class="children"><div class="content">Extend the Maybe to an Either, or an Result&lt;T, E&gt;, that carries either the result or the error information and you have the same thing. Add some syntactic sugar to either get the success result or propagate the error (under the condition that the current function returns a Result and there is a way to cast the inner error type into the outer error type) and you have a nice alternative to try&#x2F;catch that can entirely replace it</div><br/></div></div><div id="40411479" class="c"><input type="checkbox" id="c-40411479" checked=""/><div class="controls bullet"><span class="by">zacmps</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411392">parent</a><span>|</span><a href="#40411513">prev</a><span>|</span><a href="#40411466">next</a><span>|</span><label class="collapse" for="c-40411479">[-]</label><label class="expand" for="c-40411479">[2 more]</label></div><br/><div class="children"><div class="content">They might have meant a type like `Result&lt;T,E&gt;`</div><br/><div id="40412146" class="c"><input type="checkbox" id="c-40412146" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411479">parent</a><span>|</span><a href="#40411466">next</a><span>|</span><label class="collapse" for="c-40412146">[-]</label><label class="expand" for="c-40412146">[1 more]</label></div><br/><div class="children"><div class="content">This is what I meant!</div><br/></div></div></div></div><div id="40411466" class="c"><input type="checkbox" id="c-40411466" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411392">parent</a><span>|</span><a href="#40411479">prev</a><span>|</span><a href="#40411666">next</a><span>|</span><label class="collapse" for="c-40411466">[-]</label><label class="expand" for="c-40411466">[2 more]</label></div><br/><div class="children"><div class="content">Well, you handle errors by needing to explicitly handle them at the point of error, as opposed to all callers needing to anticipate and understand every random system error from 10 levels deep of APIs (or just throw them all away).</div><br/><div id="40413595" class="c"><input type="checkbox" id="c-40413595" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411466">parent</a><span>|</span><a href="#40411666">next</a><span>|</span><label class="collapse" for="c-40413595">[-]</label><label class="expand" for="c-40413595">[1 more]</label></div><br/><div class="children"><div class="content">Except this isn&#x27;t my experience of errors at all.<p>My experience of errors is that most of the time you need <i>more</i> scope in order to handle them properly.<p>I.e. if writing to a file happens, what am I actually supposed to do about that? Well, that depends entirely on why I&#x27;m writing to a file. Which might not be information the calling function actually has. Usually I need to go up the call stack to find somewhere which has enough context to know what&#x27;s actually not working because a file write has failed.</div><br/></div></div></div></div><div id="40411666" class="c"><input type="checkbox" id="c-40411666" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411392">parent</a><span>|</span><a href="#40411466">prev</a><span>|</span><a href="#40413090">next</a><span>|</span><label class="collapse" for="c-40411666">[-]</label><label class="expand" for="c-40411666">[1 more]</label></div><br/><div class="children"><div class="content">Result (aka Either) and Maybe are much better than exceptions for parsing. Exceptions should only be used when something truly exceptional occurs (e.g. out of disk space, no network connection). Ill-formed input is not exceptional when you&#x27;re parsing a URL.</div><br/></div></div><div id="40413090" class="c"><input type="checkbox" id="c-40413090" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40411256">root</a><span>|</span><a href="#40411392">parent</a><span>|</span><a href="#40411666">prev</a><span>|</span><a href="#40411475">next</a><span>|</span><label class="collapse" for="c-40413090">[-]</label><label class="expand" for="c-40413090">[1 more]</label></div><br/><div class="children"><div class="content">Not only are they comparable, they&#x27;re so comparable that one ought to put them under the same interface.<p>If you write library code, fail polymorphically, then the client can choose whether they want to call it as Maybe&#x2F;Either&#x2F;Exception and we can stop these never-ending arguments.</div><br/></div></div></div></div></div></div><div id="40411475" class="c"><input type="checkbox" id="c-40411475" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40411256">parent</a><span>|</span><a href="#40411360">prev</a><span>|</span><a href="#40411368">next</a><span>|</span><label class="collapse" for="c-40411475">[-]</label><label class="expand" for="c-40411475">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; error passing is via try&#x2F;catch, which is the best error handling pattern we&#x27;ve figured out so far</i><p>The best error handling pattern <i>for scripts</i> we&#x27;ve figured out so far, but at the same time the worst error handling pattern for <i>systems</i> known to man.</div><br/></div></div><div id="40411368" class="c"><input type="checkbox" id="c-40411368" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#40411256">parent</a><span>|</span><a href="#40411475">prev</a><span>|</span><a href="#40413216">next</a><span>|</span><label class="collapse" for="c-40411368">[-]</label><label class="expand" for="c-40411368">[1 more]</label></div><br/><div class="children"><div class="content">&gt; which is the best error handling pattern we&#x27;ve figured out so far<p>What are the reasons you think it&#x27;s better than Either and map, especially for expected control flow that doesn&#x27;t signify programmer error and just responds to bad input data? I can&#x27;t see any upsides. The function doesn&#x27;t force the caller to handle the error, and the error isn&#x27;t type checked: if the function stops throwing one type of exception or starts throwing another, type system won&#x27;t force outdated call sites to be fixed.</div><br/></div></div></div></div><div id="40413216" class="c"><input type="checkbox" id="c-40413216" checked=""/><div class="controls bullet"><span class="by">ngruhn</span><span>|</span><a href="#40411256">prev</a><span>|</span><a href="#40412265">next</a><span>|</span><label class="collapse" for="c-40413216">[-]</label><label class="expand" for="c-40413216">[2 more]</label></div><br/><div class="children"><div class="content">I encountered another pitfall when using `new URL` to check if a text contains urls. It accepts strings like ”example:”, “next:&quot;, etc. as valid urls because it interprets the string before the colon as a custom protocol. This is a real edge case in the spec, because with common protocols, just &quot;http:&quot;, &quot;https:&quot; is not accepted as a valid url.</div><br/><div id="40413446" class="c"><input type="checkbox" id="c-40413446" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#40413216">parent</a><span>|</span><a href="#40412265">next</a><span>|</span><label class="collapse" for="c-40413446">[-]</label><label class="expand" for="c-40413446">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s correct, though. The URI scheme for HTTPS may always include a domain name, but my-app: is just as valid a URL as anything else. A protocol where everything is optional and the default opens a screen with all fields empty is valid, though unlikely.<p>For instance, an empty mailto: will reliably launch an email client, even if no address is specified. I think it&#x27;s the second most used protocol in web links, after HTTP(S).<p>If you want to to URL parsing by brute forcing URL constructors, you probably don&#x27;t want application URLs in the first place. You should probably start with <a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a> and <a href="http:&#x2F;&#x2F;" rel="nofollow">http:&#x2F;&#x2F;</a>, or make use of the weird double slash HTTP introduced into the URL by matching on :&#x2F;&#x2F; instead.</div><br/></div></div></div></div><div id="40412265" class="c"><input type="checkbox" id="c-40412265" checked=""/><div class="controls bullet"><span class="by">qbane</span><span>|</span><a href="#40413216">prev</a><span>|</span><a href="#40411953">next</a><span>|</span><label class="collapse" for="c-40412265">[-]</label><label class="expand" for="c-40412265">[2 more]</label></div><br/><div class="children"><div class="content">I kinda agree that `new URL()` need not bail out when the URL is invalid. Both practices exist in the spec: `new Date(&#x27;foo&#x27;)` returns invalid date, `parseInt(&#x27;foo&#x27;)` returns NaN, while `new Array(-1)` throws a `RangeError`. Probably there is a need of URL instances for invalid ones? Then we come back at an Either&lt;x, y&gt; return type.<p>However, it is the `try...catch` pattern that messes up with the `const`, not the URL constructor. It is very annoying every time when I have to wrap an existing block with a try...catch, and inevitably lose the const-ness to some variables, unless I wrap everything again into a function and `return` in the try block if things go normally.</div><br/><div id="40413469" class="c"><input type="checkbox" id="c-40413469" checked=""/><div class="controls bullet"><span class="by">jakub_g</span><span>|</span><a href="#40412265">parent</a><span>|</span><a href="#40411953">next</a><span>|</span><label class="collapse" for="c-40413469">[-]</label><label class="expand" for="c-40413469">[1 more]</label></div><br/><div class="children"><div class="content">Re: try-catch x const, this is indeed one of top annoyances in JS those days. I hope this proposal makes it to the language one day:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nzakas&#x2F;proposal-write-once-const?tab=readme-ov-file#use-case-3-try-catch-initialized-bindings">https:&#x2F;&#x2F;github.com&#x2F;nzakas&#x2F;proposal-write-once-const?tab=read...</a></div><br/></div></div></div></div><div id="40411953" class="c"><input type="checkbox" id="c-40411953" checked=""/><div class="controls bullet"><span class="by">dkarras</span><span>|</span><a href="#40412265">prev</a><span>|</span><a href="#40411697">next</a><span>|</span><label class="collapse" for="c-40411953">[-]</label><label class="expand" for="c-40411953">[6 more]</label></div><br/><div class="children"><div class="content">just make a utility function! don&#x27;t see what the fuss is about. the original API choice is arguably not great, but haphazardly adding multiple ways to do the same thing does not improve the API either.</div><br/><div id="40413477" class="c"><input type="checkbox" id="c-40413477" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#40411953">parent</a><span>|</span><a href="#40413429">next</a><span>|</span><label class="collapse" for="c-40413477">[-]</label><label class="expand" for="c-40413477">[1 more]</label></div><br/><div class="children"><div class="content">On the one hand, the Javascript spec is so littered with API helper functions to patch over old APIs that I think it&#x27;ll only continue to grow in exploitability.<p>On the other hand, you don&#x27;t want to be Java, where List.Last took until Java 21 to get implemented. It&#x27;s not hard to make a wrapper function, but it&#x27;s really annoying to clutter your code with helper functions where the native API should help you.<p>In this specific instance, I agree with the new spec: most constructors for native Javascript types don&#x27;t throw, so neither should the URL constructor. However, the try&#x2F;catch isn&#x27;t exactly the problem some people seem to think it is. It&#x27;s a minor annoyance that apparently annoyed at least three browser teams enough to come up with a new API. In other circumstances, I hope the API spec won&#x27;t be extended as easily.</div><br/></div></div><div id="40413429" class="c"><input type="checkbox" id="c-40413429" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#40411953">parent</a><span>|</span><a href="#40413477">prev</a><span>|</span><a href="#40412070">next</a><span>|</span><label class="collapse" for="c-40413429">[-]</label><label class="expand" for="c-40413429">[1 more]</label></div><br/><div class="children"><div class="content">Especially because we have npm packages for things like left-pad.<p>So this is a no-brainer.</div><br/></div></div><div id="40412070" class="c"><input type="checkbox" id="c-40412070" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#40411953">parent</a><span>|</span><a href="#40413429">prev</a><span>|</span><a href="#40412180">next</a><span>|</span><label class="collapse" for="c-40412070">[-]</label><label class="expand" for="c-40412070">[1 more]</label></div><br/><div class="children"><div class="content">Something like...<p>if (typeof URL.parse != &#x27;function&#x27;) {URL.parse = function (_s){let _ret; try { _ret = new URL(_s)} catch {}; return _ret} } ;</div><br/></div></div><div id="40412180" class="c"><input type="checkbox" id="c-40412180" checked=""/><div class="controls bullet"><span class="by">RaisingSpear</span><span>|</span><a href="#40411953">parent</a><span>|</span><a href="#40412070">prev</a><span>|</span><a href="#40411697">next</a><span>|</span><label class="collapse" for="c-40412180">[-]</label><label class="expand" for="c-40412180">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, you can write it in less than a minute:<p>const tryNew = (f, ...a) =&gt; {
  try {
   return new f(...a);
  } catch(x) {
   return undefined;
  }
 };<p>const myUrl = tryNew(URL, &#x27;<a href="http:&#x2F;&#x2F;example.com&#x2F;&#x27;);" rel="nofollow">http:&#x2F;&#x2F;example.com&#x2F;&#x27;);</a><p>I don&#x27;t get why JS devs like to whinge about the smallest things.  And we get stuff like leftPad because of huge aversion to writing utility functions.</div><br/><div id="40413399" class="c"><input type="checkbox" id="c-40413399" checked=""/><div class="controls bullet"><span class="by">hyperhopper</span><span>|</span><a href="#40411953">root</a><span>|</span><a href="#40412180">parent</a><span>|</span><a href="#40411697">next</a><span>|</span><label class="collapse" for="c-40413399">[-]</label><label class="expand" for="c-40413399">[1 more]</label></div><br/><div class="children"><div class="content">Ironic since your snippet is now a new leftpad.<p>Does every dev need to write the same line now? Or should your one-liner be a library?<p>The basics that everybody needs, should be standardized in the standard library.</div><br/></div></div></div></div></div></div><div id="40411697" class="c"><input type="checkbox" id="c-40411697" checked=""/><div class="controls bullet"><span class="by">technion</span><span>|</span><a href="#40411953">prev</a><span>|</span><a href="#40411264">next</a><span>|</span><label class="collapse" for="c-40411697">[-]</label><label class="expand" for="c-40411697">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s annoying that none of these end up parsing quite like the HTML inside a website.<p>For example, on google.com, you can find:<p>&lt;img class=&quot;lnXdpd&quot; alt=&quot;Google&quot; height=&quot;92&quot; src=&quot;&#x2F;images&#x2F;branding&#x2F;googlelogo&#x2F;2x&#x2F;googlelogo_color_272x92dp.png&quot;<p>But open the console and run this, and it will throw:<p>let x = new URL(&quot;&#x2F;images&#x2F;branding&#x2F;googlelogo&#x2F;2x&#x2F;googlelogo_color_272x92dp.png&quot;);<p>You&#x27;re supposed to address this by adding the base URL on the end, but then correctly obtaining that can be brittle. If you&#x27;re browsing a folder, the whole document.location is the baseURL, but if you are browsing a file (ie ends in .php or .html) it isn&#x27;t. If you&#x27;re taking user URLs, your browser&#x27;s URL bar will add <a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a> automatically so people don&#x27;t think about it, but they&#x27;ll leave it out of an absolute URL and now you need to detect and add it if needed.</div><br/><div id="40413575" class="c"><input type="checkbox" id="c-40413575" checked=""/><div class="controls bullet"><span class="by">philipwhiuk</span><span>|</span><a href="#40411697">parent</a><span>|</span><a href="#40412058">next</a><span>|</span><label class="collapse" for="c-40413575">[-]</label><label class="expand" for="c-40413575">[1 more]</label></div><br/><div class="children"><div class="content">`src` takes a path, not a URL.<p>I think you just misunderstand what a URL is.</div><br/></div></div><div id="40412058" class="c"><input type="checkbox" id="c-40412058" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#40411697">parent</a><span>|</span><a href="#40413575">prev</a><span>|</span><a href="#40411912">next</a><span>|</span><label class="collapse" for="c-40412058">[-]</label><label class="expand" for="c-40412058">[1 more]</label></div><br/><div class="children"><div class="content">I actually like that it does this. In your example where you’d want it to infer relative URLs, what happens when that code is executed in Node?<p>&gt; If you&#x27;re browsing a folder, the whole document.location is the baseURL, but if you are browsing a file (ie ends in .php or .html) it isn&#x27;t<p>I’m not sure I understand what you’re saying here. The second argument in the URL constructor works as a “relative to” argument. If your URL starts with &#x2F; it doesn’t matter if there’s a file or not, it’ll start from the domain root.</div><br/></div></div><div id="40411912" class="c"><input type="checkbox" id="c-40411912" checked=""/><div class="controls bullet"><span class="by">cmaggiulli</span><span>|</span><a href="#40411697">parent</a><span>|</span><a href="#40412058">prev</a><span>|</span><a href="#40411264">next</a><span>|</span><label class="collapse" for="c-40411912">[-]</label><label class="expand" for="c-40411912">[1 more]</label></div><br/><div class="children"><div class="content">Are you saying that is the to string value of a URL object instantiated with the url of a page containing just an image tag, or are you saying it’s the value when you instantiate an object with a url parameter to the png file itself?  If it’s the png file itself my 0.02 is that is a logical choice. Obviously the to string ( or whatever it is, I’m not a JS dev ) isn’t the binary data, and I believe in the binary encoded response body there is a meta data signature block that contains that info.</div><br/></div></div></div></div><div id="40411207" class="c"><input type="checkbox" id="c-40411207" checked=""/><div class="controls bullet"><span class="by">minebreaker</span><span>|</span><a href="#40411264">prev</a><span>|</span><a href="#40411478">next</a><span>|</span><label class="collapse" for="c-40411207">[-]</label><label class="expand" for="c-40411207">[5 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t we just use `Either` or ADT</div><br/><div id="40411455" class="c"><input type="checkbox" id="c-40411455" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40411207">parent</a><span>|</span><a href="#40413106">next</a><span>|</span><label class="collapse" for="c-40411455">[-]</label><label class="expand" for="c-40411455">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in `fp-ts` (and the related `io-ts`).<p><a href="https:&#x2F;&#x2F;gcanti.github.io&#x2F;fp-ts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gcanti.github.io&#x2F;fp-ts&#x2F;</a><p><a href="https:&#x2F;&#x2F;gcanti.github.io&#x2F;io-ts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gcanti.github.io&#x2F;io-ts&#x2F;</a></div><br/></div></div><div id="40413106" class="c"><input type="checkbox" id="c-40413106" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40411207">parent</a><span>|</span><a href="#40411455">prev</a><span>|</span><a href="#40411246">next</a><span>|</span><label class="collapse" for="c-40413106">[-]</label><label class="expand" for="c-40413106">[1 more]</label></div><br/><div class="children"><div class="content">We can and do.</div><br/></div></div><div id="40411246" class="c"><input type="checkbox" id="c-40411246" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#40411207">parent</a><span>|</span><a href="#40413106">prev</a><span>|</span><a href="#40411478">next</a><span>|</span><label class="collapse" for="c-40411246">[-]</label><label class="expand" for="c-40411246">[2 more]</label></div><br/><div class="children"><div class="content">With TypeScript a nullable return type effectively is an ADT.</div><br/><div id="40412038" class="c"><input type="checkbox" id="c-40412038" checked=""/><div class="controls bullet"><span class="by">seniorsassycat</span><span>|</span><a href="#40411207">root</a><span>|</span><a href="#40411246">parent</a><span>|</span><a href="#40411478">next</a><span>|</span><label class="collapse" for="c-40412038">[-]</label><label class="expand" for="c-40412038">[1 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s not Either &#x2F; Result because there no error information on  null</div><br/></div></div></div></div></div></div><div id="40411478" class="c"><input type="checkbox" id="c-40411478" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#40411207">prev</a><span>|</span><a href="#40411679">next</a><span>|</span><label class="collapse" for="c-40411478">[-]</label><label class="expand" for="c-40411478">[2 more]</label></div><br/><div class="children"><div class="content">I don’t see how it changes anything.  You’re still handling a second branch as if an error was thrown. It’s just called null.<p>Practically, though, I like it because JavaScript’s error handling sucks.  I generally avoid using try&#x2F;catch as a first class member of my software.</div><br/><div id="40413411" class="c"><input type="checkbox" id="c-40413411" checked=""/><div class="controls bullet"><span class="by">aabhay</span><span>|</span><a href="#40411478">parent</a><span>|</span><a href="#40411679">next</a><span>|</span><label class="collapse" for="c-40413411">[-]</label><label class="expand" for="c-40413411">[1 more]</label></div><br/><div class="children"><div class="content">Exactly! Handling null is still.. exception handling. You just check it with an if, not a try catch.<p>But the semantics around try&#x2F;catch are the main issue here and basically everywhere in JS. Error catching in JS is absolutely abysmal. Some examples:<p>- nested try catch<p>- not annotating that a function throws an error (or even being able to annotate in TS that it does)<p>- async code throwing an error in a callback is uncatchable. E.G. file reader onread throwing an error.<p>- not being able to narrow a catch to a specific error type.</div><br/></div></div></div></div><div id="40411679" class="c"><input type="checkbox" id="c-40411679" checked=""/><div class="controls bullet"><span class="by">ramesh31</span><span>|</span><a href="#40411478">prev</a><span>|</span><a href="#40411164">next</a><span>|</span><label class="collapse" for="c-40411679">[-]</label><label class="expand" for="c-40411679">[2 more]</label></div><br/><div class="children"><div class="content">Recently ran into this where we wanted to avoid new URL for the memory overhead, and was blown away that JavaScript&#x27;s URL does not contain a static parse method. Things like this are why people working with real languages make fun of us.</div><br/><div id="40413535" class="c"><input type="checkbox" id="c-40413535" checked=""/><div class="controls bullet"><span class="by">unchar1</span><span>|</span><a href="#40411679">parent</a><span>|</span><a href="#40411164">next</a><span>|</span><label class="collapse" for="c-40413535">[-]</label><label class="expand" for="c-40413535">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t a static parse method still allocate memory for the object that it returns?</div><br/></div></div></div></div></div></div></div></div></div></body></html>