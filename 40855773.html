<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720170065432" as="style"/><link rel="stylesheet" href="styles.css?v=1720170065432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://shkspr.mobi/blog/2024/07/how-random-are-totp-codes/">How random are TOTP codes?</a> <span class="domain">(<a href="https://shkspr.mobi">shkspr.mobi</a>)</span></div><div class="subtext"><span>ColinWright</span> | <span>47 comments</span></div><br/><div><div id="40879880" class="c"><input type="checkbox" id="c-40879880" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#40879800">next</a><span>|</span><label class="collapse" for="c-40879880">[-]</label><label class="expand" for="c-40879880">[6 more]</label></div><br/><div class="children"><div class="content">There is a small inherent bias in TOTP (and HOTP) codes. The algorithm extracts 31 consecutive bits from a SHA-1 hash ( 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HMAC-based_one-time_password#Algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HMAC-based_one-time_password#A...</a> ). Let&#x27;s assume that SHA-1 produces uniformly random bits.<p>The 31-bit number is modulo&#x27;d by 10^6 to generate a 6-digit base-10 number. But 2^31 isn&#x27;t a multiple of 10^6, so some remainders will be slightly more likely than others. Namely:<p>• 000000 to 483647: 2148&#x2F;2147483648 ≈ 1.000240e-6 chance.<p>• 483648 to 999999: 2147&#x2F;2147483648 ≈ 0.999774e-6 chance.<p>This kind of bias always happens when changing the range of random numbers and the number of possible outcomes is not a divisor of the number of incomes, and rejection sampling isn&#x27;t used.<p>This is why, for example, java.util.Random.nextInt(int n) (which generates an integer in the range [0, n)) carefully uses rejection sampling in its algorithm: <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;Random.html#nextInt-int-" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;Random.h...</a></div><br/><div id="40880492" class="c"><input type="checkbox" id="c-40880492" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40879880">parent</a><span>|</span><a href="#40880848">next</a><span>|</span><label class="collapse" for="c-40880492">[-]</label><label class="expand" for="c-40880492">[1 more]</label></div><br/><div class="children"><div class="content">The most extensive <i>comparison</i> of rejection methods I&#x27;ve seen is on the PCG blog:<p><a href="https:&#x2F;&#x2F;www.pcg-random.org&#x2F;posts&#x2F;bounded-rands.html" rel="nofollow">https:&#x2F;&#x2F;www.pcg-random.org&#x2F;posts&#x2F;bounded-rands.html</a></div><br/></div></div><div id="40880848" class="c"><input type="checkbox" id="c-40880848" checked=""/><div class="controls bullet"><span class="by">fuglede_</span><span>|</span><a href="#40879880">parent</a><span>|</span><a href="#40880492">prev</a><span>|</span><a href="#40879890">next</a><span>|</span><label class="collapse" for="c-40880848">[-]</label><label class="expand" for="c-40880848">[1 more]</label></div><br/><div class="children"><div class="content">One I remember stumbling upon some years back was the .NET Framework equivalent of that, System.Random.Next(0, int.MaxValue), which has a much greater probability of producing odd numbers than even numbers, the probability of getting odd numbers being 50.34%, because of some rather unfortunate translations between integers and floating points. <a href="https:&#x2F;&#x2F;fuglede.dk&#x2F;en&#x2F;blog&#x2F;bias-in-net-rng&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fuglede.dk&#x2F;en&#x2F;blog&#x2F;bias-in-net-rng&#x2F;</a></div><br/></div></div><div id="40879890" class="c"><input type="checkbox" id="c-40879890" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#40879880">parent</a><span>|</span><a href="#40880848">prev</a><span>|</span><a href="#40879800">next</a><span>|</span><label class="collapse" for="c-40879890">[-]</label><label class="expand" for="c-40879890">[3 more]</label></div><br/><div class="children"><div class="content">The effect of this on the min-entropy is basically nil.<p>Added: to be pedantic, the difference in min-entropy from a uniform distribution is about 0.000347 bits if my calculation is right (log2(2148*1e6&#x2F;2**31)).  Really, this is not of practical significance given how TOTP is used.</div><br/><div id="40880515" class="c"><input type="checkbox" id="c-40880515" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#40879880">root</a><span>|</span><a href="#40879890">parent</a><span>|</span><a href="#40880434">next</a><span>|</span><label class="collapse" for="c-40880515">[-]</label><label class="expand" for="c-40880515">[1 more]</label></div><br/><div class="children"><div class="content">The entropy ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Entropy_(information_theory)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Entropy_(information_theory)</a> ) of the uniform distribution is −log2(0.000001) ≈ 19.9315685693 bits.<p>The entropy of the TOTP distribution is −log2(2148&#x2F;2147483648)×483648×2148&#x2F;2147483648−log2(2147&#x2F;2147483648)×516352×2147&#x2F;2147483648 ≈ 19.9315685303 bits.<p>So yes, the difference in entropy is negligible. The TOTP distribution is worse by 39 nanobits (3.906e-8) per code.</div><br/></div></div><div id="40880434" class="c"><input type="checkbox" id="c-40880434" checked=""/><div class="controls bullet"><span class="by">p0seidon</span><span>|</span><a href="#40879880">root</a><span>|</span><a href="#40879890">parent</a><span>|</span><a href="#40880515">prev</a><span>|</span><a href="#40879800">next</a><span>|</span><label class="collapse" for="c-40880434">[-]</label><label class="expand" for="c-40880434">[1 more]</label></div><br/><div class="children"><div class="content">I love how this response corresponds to your profile description, and I mean that in a positive way, just to be clear.</div><br/></div></div></div></div></div></div><div id="40879800" class="c"><input type="checkbox" id="c-40879800" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40879880">prev</a><span>|</span><a href="#40880071">next</a><span>|</span><label class="collapse" for="c-40879800">[-]</label><label class="expand" for="c-40879800">[6 more]</label></div><br/><div class="children"><div class="content">We like to see patterns. I think the same thing with TOTP codes, I&#x27;m always noticing when they have repeated digits, or only 2 different digits, stuff like that, but that&#x27;s just the nature of the human brain looking at random numbers.</div><br/><div id="40880116" class="c"><input type="checkbox" id="c-40880116" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40879800">parent</a><span>|</span><a href="#40880278">next</a><span>|</span><label class="collapse" for="c-40880116">[-]</label><label class="expand" for="c-40880116">[1 more]</label></div><br/><div class="children"><div class="content">Me too. I was particularly pleased when I got 332211 as my TOTP once.</div><br/></div></div><div id="40880278" class="c"><input type="checkbox" id="c-40880278" checked=""/><div class="controls bullet"><span class="by">Fr0styMatt88</span><span>|</span><a href="#40879800">parent</a><span>|</span><a href="#40880116">prev</a><span>|</span><a href="#40880071">next</a><span>|</span><label class="collapse" for="c-40880278">[-]</label><label class="expand" for="c-40880278">[4 more]</label></div><br/><div class="children"><div class="content">For me it’s “I swear I feel like I’ve gotten the exact same TOTP code not that long ago!”.<p>What’s the actual likelihood of seeing the same TOTP code from different apps at different times?<p>What about those ones that get sent out in phone messages?</div><br/><div id="40880390" class="c"><input type="checkbox" id="c-40880390" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40879800">root</a><span>|</span><a href="#40880278">parent</a><span>|</span><a href="#40880071">next</a><span>|</span><label class="collapse" for="c-40880390">[-]</label><label class="expand" for="c-40880390">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What’s the actual likelihood of seeing the same TOTP code from different apps at different times?<p>There’s only a million 6 digit TOTP codes, so I reckon you get to 50% odds of collision at ~1200 values.</div><br/><div id="40880601" class="c"><input type="checkbox" id="c-40880601" checked=""/><div class="controls bullet"><span class="by">yulle</span><span>|</span><a href="#40879800">root</a><span>|</span><a href="#40880390">parent</a><span>|</span><a href="#40880071">next</a><span>|</span><label class="collapse" for="c-40880601">[-]</label><label class="expand" for="c-40880601">[2 more]</label></div><br/><div class="children"><div class="content">For those curious on how to find that ~1200 values are needed before a 50% probability of collision, this is a generalized form of the birthday problem [0].<p>With a calculator [1], we can find the exact amount. plugging in D=10^6 (# of unique codes) with P=0.5 (odds of collision) gives you 1178 values.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Birthday_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Birthday_problem</a><p>[1] <a href="https:&#x2F;&#x2F;www.bdayprob.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bdayprob.com&#x2F;</a></div><br/><div id="40880664" class="c"><input type="checkbox" id="c-40880664" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#40879800">root</a><span>|</span><a href="#40880601">parent</a><span>|</span><a href="#40880071">next</a><span>|</span><label class="collapse" for="c-40880664">[-]</label><label class="expand" for="c-40880664">[1 more]</label></div><br/><div class="children"><div class="content">The very rough rule of thumb that I think one should remember is: You get a 50% chance of collision with sqrt(total) samples.<p>Sqrt(1 000 000) = 1 000, close enough to the exact number you calculated.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40880071" class="c"><input type="checkbox" id="c-40880071" checked=""/><div class="controls bullet"><span class="by">landgenoot</span><span>|</span><a href="#40879800">prev</a><span>|</span><a href="#40880897">next</a><span>|</span><label class="collapse" for="c-40880071">[-]</label><label class="expand" for="c-40880071">[3 more]</label></div><br/><div class="children"><div class="content">I have been thinking about a useless TOTP app that works the other way around. Instead of giving you the current code, it gives you the timestamps when the code is e.g. 000000, 123456 or 777777.<p>With a window of 30 seconds and 1e6 possibilities, the expected time it takes to get to a particular number is 347 days. Should be easy to brute force.</div><br/><div id="40880688" class="c"><input type="checkbox" id="c-40880688" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40880071">parent</a><span>|</span><a href="#40880728">next</a><span>|</span><label class="collapse" for="c-40880688">[-]</label><label class="expand" for="c-40880688">[1 more]</label></div><br/><div class="children"><div class="content">In a deep voice: <i>Your wish is my command.</i><p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;skull-squadron&#x2F;8f806b28abbcaa1ba9c256391e5bd8f9" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;skull-squadron&#x2F;8f806b28abbcaa1ba9c25...</a><p>Unfortunately, it may take several years before a certain TOTP value is reached because the values are nondeterministic rather than ordered and so there will be hash collisions of other values as well.<p>Example: JBSWY3DPEHPK3PXP 999999<p><pre><code>    TOTP will match 999999 between 2024-11-29 16:37:00 -0600 and 2024-11-29 16:37:29 -0600</code></pre></div><br/></div></div><div id="40880728" class="c"><input type="checkbox" id="c-40880728" checked=""/><div class="controls bullet"><span class="by">robxorb</span><span>|</span><a href="#40880071">parent</a><span>|</span><a href="#40880688">prev</a><span>|</span><a href="#40880897">next</a><span>|</span><label class="collapse" for="c-40880728">[-]</label><label class="expand" for="c-40880728">[1 more]</label></div><br/><div class="children"><div class="content">Not so useless. A user of that could memorise the times&#x2F;dates where a particular easy-recall code comes up. With that, they have effectively &quot;transferred&quot; 2FA for those times into their brain, and not need to use any 2FA app (at only those times).</div><br/></div></div></div></div><div id="40880897" class="c"><input type="checkbox" id="c-40880897" checked=""/><div class="controls bullet"><span class="by">gizmo</span><span>|</span><a href="#40880071">prev</a><span>|</span><a href="#40880905">next</a><span>|</span><label class="collapse" for="c-40880897">[-]</label><label class="expand" for="c-40880897">[1 more]</label></div><br/><div class="children"><div class="content">A related issue is that TOPT security guidelines suggest using a 160 bit key. Some organizations use 20 chars with alphabet A-Za-z0-9. Easy mistake to make, a byte is 8 bit after all. However, 62 ^ 20 is only 120 bits (give or take). Way less than the recommended minimum. Does anybody know how insecure this is in practice?</div><br/></div></div><div id="40880905" class="c"><input type="checkbox" id="c-40880905" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40880897">prev</a><span>|</span><a href="#40880597">next</a><span>|</span><label class="collapse" for="c-40880905">[-]</label><label class="expand" for="c-40880905">[1 more]</label></div><br/><div class="children"><div class="content">I often have the feeling that my TOTP codes are somehow simple. Simple in the sense of containg repeated digits, some rhythm (e.g. 663183) or symmetry instead of being &quot;purely random&quot; (e.g. 581329).<p>I guess the reason is the human brain can really recognize many kinds of patterns. Nothing weird about the entropy.</div><br/></div></div><div id="40880597" class="c"><input type="checkbox" id="c-40880597" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#40880905">prev</a><span>|</span><a href="#40880556">next</a><span>|</span><label class="collapse" for="c-40880597">[-]</label><label class="expand" for="c-40880597">[1 more]</label></div><br/><div class="children"><div class="content">I wondered about a related problem: how many of the codes are &quot;easy&quot;? Easy as in they are composed of &quot;simple&quot; patterns, such as going to adjacent digits in a number pad. Often it seems that if you are given such a sequence, there&#x27;s a pattern you can use to recall it. Seems like it would make the randomness suspect, perhaps? But maybe all the sequences have easy rules, the rules just differ?<p>So during a short hackfest I created this to check it out: <a href="https:&#x2F;&#x2F;github.com&#x2F;eras&#x2F;reco">https:&#x2F;&#x2F;github.com&#x2F;eras&#x2F;reco</a> . Sorry, no binaries and the font size is hardcoded for presentation, and actually the whole UI stuff is just for that reason there.. By default it scans the whole 6-digit sequence space, but you can also give it a sequence and it will show the rules it finds.<p>Given the rules it uses, it turns out 50% of 6-digit sequences are &quot;easy&quot;. Because it is based on the rules I just thought would apply there are probably other &quot;easy&quot; rules that could cover a lot of the remaining 50%.. It also cheats in a way by trying to apply the codes to all* shapes and sizes of numpads (1x10, 2x5, 3x3+1): match in any numpad is accepted for a sequence to be &quot;easy&quot;.<p>It may also be some of the rules for the sequences it finds are not &quot;easy&quot; after all :).</div><br/></div></div><div id="40880556" class="c"><input type="checkbox" id="c-40880556" checked=""/><div class="controls bullet"><span class="by">dx034</span><span>|</span><a href="#40880597">prev</a><span>|</span><a href="#40880661">next</a><span>|</span><label class="collapse" for="c-40880556">[-]</label><label class="expand" for="c-40880556">[2 more]</label></div><br/><div class="children"><div class="content">My employer uses alphanumeric 2 factor codes and I&#x27;m so certain that they have a bias towards some letters (mostly y and z). I know I&#x27;m probably wrong and it&#x27;s probably because they appear so rarely in real words, but I can&#x27;t shake the feeling they aren&#x27;t random.<p>Only problem is that I don&#x27;t have the algorithm. I started writing down all codes I got but since I only get 5 a week, it&#x27;s a long process. I&#x27;ll probably switch jobs before I have valid results.<p>Not that it would change anything, but I&#x27;d be really curious how biases in those codes could appear.</div><br/><div id="40880829" class="c"><input type="checkbox" id="c-40880829" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40880556">parent</a><span>|</span><a href="#40880661">next</a><span>|</span><label class="collapse" for="c-40880829">[-]</label><label class="expand" for="c-40880829">[1 more]</label></div><br/><div class="children"><div class="content">Is there a standardized, public, and widely examined algorithm that produces letters or did they run &quot;their own crypto&quot;?</div><br/></div></div></div></div><div id="40880661" class="c"><input type="checkbox" id="c-40880661" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40880556">prev</a><span>|</span><a href="#40879896">next</a><span>|</span><label class="collapse" for="c-40880661">[-]</label><label class="expand" for="c-40880661">[1 more]</label></div><br/><div class="children"><div class="content">Having implemented TOTP codes once I know that they&#x27;re basically unbiased because of the cryptography involved. That said, I would bet money that Apple&#x27;s two-factor implementation is something custom because it just seems far too likely to generate combinations that look non-random. A bet not because I have evidence I&#x27;m right, but because I want someone to explain to me how these work, if only just &quot;oh it&#x27;s literally the same algorithm everyone else uses&quot; :)</div><br/></div></div><div id="40879896" class="c"><input type="checkbox" id="c-40879896" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#40880661">prev</a><span>|</span><a href="#40880266">next</a><span>|</span><label class="collapse" for="c-40879896">[-]</label><label class="expand" for="c-40879896">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How random are TOTP codes?<p>Nitpicking: They are not supposed to be random as that would defeat the purpose. We should be able to deterministically generate the same number on both the client and server side from the same 2 seeds (secret key and the timestamp).<p>They should be ideally uniformly distributed, though.</div><br/></div></div><div id="40880266" class="c"><input type="checkbox" id="c-40880266" checked=""/><div class="controls bullet"><span class="by">MattJ100</span><span>|</span><a href="#40879896">prev</a><span>|</span><a href="#40880134">next</a><span>|</span><label class="collapse" for="c-40880266">[-]</label><label class="expand" for="c-40880266">[2 more]</label></div><br/><div class="children"><div class="content">A related observation, where in many real-world data digit frequency <i>can</i> be predicted, is described by Benford&#x27;s Law: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Benfords_law" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Benfords_law</a><p>However this law obviously does not apply to TOTP codes (unless someone did something very wrong).</div><br/><div id="40880346" class="c"><input type="checkbox" id="c-40880346" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#40880266">parent</a><span>|</span><a href="#40880134">next</a><span>|</span><label class="collapse" for="c-40880346">[-]</label><label class="expand" for="c-40880346">[1 more]</label></div><br/><div class="children"><div class="content">IANAMathematician, but I like to visualize Benford&#x27;s law as what happens when someone is throwing allegedly-random darts at log10-lined graph paper.</div><br/></div></div></div></div><div id="40880134" class="c"><input type="checkbox" id="c-40880134" checked=""/><div class="controls bullet"><span class="by">kelseyfrog</span><span>|</span><a href="#40880266">prev</a><span>|</span><a href="#40880351">next</a><span>|</span><label class="collapse" for="c-40880134">[-]</label><label class="expand" for="c-40880134">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t they run a chi-squared test(n=10) and see that the results is not significant?</div><br/><div id="40880359" class="c"><input type="checkbox" id="c-40880359" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40880134">parent</a><span>|</span><a href="#40880351">next</a><span>|</span><label class="collapse" for="c-40880359">[-]</label><label class="expand" for="c-40880359">[1 more]</label></div><br/><div class="children"><div class="content">Using statistics? In our moment of triumph?<p>I think you underestimate these histograms.</div><br/></div></div></div></div><div id="40880351" class="c"><input type="checkbox" id="c-40880351" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40880134">prev</a><span>|</span><a href="#40879901">next</a><span>|</span><label class="collapse" for="c-40880351">[-]</label><label class="expand" for="c-40880351">[6 more]</label></div><br/><div class="children"><div class="content">TOTP is slowly on its way out compared to passkeys and FIDO2. It&#x27;s still useful as another 2FA choice.</div><br/><div id="40880439" class="c"><input type="checkbox" id="c-40880439" checked=""/><div class="controls bullet"><span class="by">aryonoco</span><span>|</span><a href="#40880351">parent</a><span>|</span><a href="#40880656">next</a><span>|</span><label class="collapse" for="c-40880439">[-]</label><label class="expand" for="c-40880439">[3 more]</label></div><br/><div class="children"><div class="content">Passkey was a great idea. A brilliant solution which could have solved authentication on the web once and for all. If only Apple, Google and Microsoft had not completely ruined it by tying it to their platforms and using it as another moat<p><a href="https:&#x2F;&#x2F;fy.blackhats.net.au&#x2F;blog&#x2F;2024-04-26-passkeys-a-shattered-dream&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fy.blackhats.net.au&#x2F;blog&#x2F;2024-04-26-passkeys-a-shatt...</a></div><br/><div id="40880550" class="c"><input type="checkbox" id="c-40880550" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#40880351">root</a><span>|</span><a href="#40880439">parent</a><span>|</span><a href="#40880656">next</a><span>|</span><label class="collapse" for="c-40880550">[-]</label><label class="expand" for="c-40880550">[2 more]</label></div><br/><div class="children"><div class="content">&quot;If you really want passkeys, put them in a password manager you control. But don&#x27;t use a platform controlled passkey store, &quot;<p>I think this is a good advice in general: if you value your freedom avoid platform controlled services even if they are slightly more convenient.<p>Btw, the platform authenticator apps are a privacy nightmare. Some are constantly reporting your activities to multiple services. You can verify this easily using an on-device proxy VPN such as NetGuard.</div><br/><div id="40880903" class="c"><input type="checkbox" id="c-40880903" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40880351">root</a><span>|</span><a href="#40880550">parent</a><span>|</span><a href="#40880656">next</a><span>|</span><label class="collapse" for="c-40880903">[-]</label><label class="expand" for="c-40880903">[1 more]</label></div><br/><div class="children"><div class="content">Yup. Don&#x27;t do Google Authenticator or similar. There are a couple of FOSS ones.</div><br/></div></div></div></div></div></div><div id="40880656" class="c"><input type="checkbox" id="c-40880656" checked=""/><div class="controls bullet"><span class="by">dx034</span><span>|</span><a href="#40880351">parent</a><span>|</span><a href="#40880439">prev</a><span>|</span><a href="#40879901">next</a><span>|</span><label class="collapse" for="c-40880656">[-]</label><label class="expand" for="c-40880656">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like passkeys. I&#x27;m not sure if I&#x27;m using it wrong, but it feels like entering a TOTP is so much faster and easier than using passkeys. It was always easy to enter a 6 digit code and have some back-up codes printed somewhere. Passkeys might be superior in some ways, but feel much harder to use. But then again, I&#x27;m also not an average user.</div><br/><div id="40880795" class="c"><input type="checkbox" id="c-40880795" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40880351">root</a><span>|</span><a href="#40880656">parent</a><span>|</span><a href="#40879901">next</a><span>|</span><label class="collapse" for="c-40880795">[-]</label><label class="expand" for="c-40880795">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like the idea of passkeys if they cannot be backed-up or are non-portable locked away in a walled garden and possibly on stored on some corporate cloud in some unknown manner. When they can be backed-up, are portable, and have an explicit security policy, then I&#x27;ll consider them.<p>For example, Bitwarden is able to act as a passkey provider on iOS and can store the passkey secret key gunk into a password record. I tried it out on a couple of minor services that have username &amp; password login alternatives.</div><br/></div></div></div></div></div></div><div id="40880261" class="c"><input type="checkbox" id="c-40880261" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#40879901">prev</a><span>|</span><a href="#40880108">next</a><span>|</span><label class="collapse" for="c-40880261">[-]</label><label class="expand" for="c-40880261">[6 more]</label></div><br/><div class="children"><div class="content">offtopic, is it secure to design a login that only requires username+TOTP?<p>This elimilates passwords altogether, but are there any pitfalls?</div><br/><div id="40880364" class="c"><input type="checkbox" id="c-40880364" checked=""/><div class="controls bullet"><span class="by">ksynwa</span><span>|</span><a href="#40880261">parent</a><span>|</span><a href="#40880285">next</a><span>|</span><label class="collapse" for="c-40880364">[-]</label><label class="expand" for="c-40880364">[2 more]</label></div><br/><div class="children"><div class="content">Not TOTP but a bunch of sites are doing this thing where they send an OTP to the registered email and have eliminated passwords altogether. I find it really annoying.</div><br/><div id="40880613" class="c"><input type="checkbox" id="c-40880613" checked=""/><div class="controls bullet"><span class="by">yurishimo</span><span>|</span><a href="#40880261">root</a><span>|</span><a href="#40880364">parent</a><span>|</span><a href="#40880285">next</a><span>|</span><label class="collapse" for="c-40880613">[-]</label><label class="expand" for="c-40880613">[1 more]</label></div><br/><div class="children"><div class="content">It is annoying but it generates far fewer support requests for people who can&#x27;t remember a password and think resetting it is too difficult.<p>With a long enough session life and a good refresh strategy, it&#x27;s less of a problem. If an app clears sessions after a week, then I would argue they are doing it wrong.</div><br/></div></div></div></div><div id="40880285" class="c"><input type="checkbox" id="c-40880285" checked=""/><div class="controls bullet"><span class="by">ManuelKiessling</span><span>|</span><a href="#40880261">parent</a><span>|</span><a href="#40880364">prev</a><span>|</span><a href="#40880569">next</a><span>|</span><label class="collapse" for="c-40880285">[-]</label><label class="expand" for="c-40880285">[2 more]</label></div><br/><div class="children"><div class="content">Totally not my field of expertise, but maybe some like “an attacker knows all usernames, and can therefore try an attack where they attempt to log into all of the accounts in parallel with the TOTP ‘000000’” yields a high enough chance of hitting one or more accounts that happen to have this TOTP at this very moment?</div><br/><div id="40880592" class="c"><input type="checkbox" id="c-40880592" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#40880261">root</a><span>|</span><a href="#40880285">parent</a><span>|</span><a href="#40880569">next</a><span>|</span><label class="collapse" for="c-40880592">[-]</label><label class="expand" for="c-40880592">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s about same chance of trying to login all usernames with password 123456 no?<p>An easy counter-measure would be blocking consecutive TOTP logins of the same or similar codes.</div><br/></div></div></div></div><div id="40880569" class="c"><input type="checkbox" id="c-40880569" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40880261">parent</a><span>|</span><a href="#40880285">prev</a><span>|</span><a href="#40880108">next</a><span>|</span><label class="collapse" for="c-40880569">[-]</label><label class="expand" for="c-40880569">[1 more]</label></div><br/><div class="children"><div class="content">&gt; offtopic, is it secure to design a login that only requires username+TOTP?<p>This elimilates passwords alltogether, but are there any pitfalls?<p>Coincidentally, I just mentioned that I did this: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40878150">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40878150</a><p>(of course, I leave it as a user preference: The user chooses whether to use standard passwords or to use one-time-passwords)</div><br/></div></div></div></div><div id="40880135" class="c"><input type="checkbox" id="c-40880135" checked=""/><div class="controls bullet"><span class="by">rustcleaner</span><span>|</span><a href="#40880108">prev</a><span>|</span><a href="#40879914">next</a><span>|</span><label class="collapse" for="c-40880135">[-]</label><label class="expand" for="c-40880135">[1 more]</label></div><br/><div class="children"><div class="content">I wish they were used more, and had adjustable settings.<p>Can we please have customizable diceware TOTP?  I&#x27;d like 8-12 words 60-90 seconds.  I also wish this could be used everywhere.</div><br/></div></div><div id="40880146" class="c"><input type="checkbox" id="c-40880146" checked=""/><div class="controls bullet"><span class="by">slau</span><span>|</span><a href="#40879916">prev</a><span>|</span><label class="collapse" for="c-40880146">[-]</label><label class="expand" for="c-40880146">[3 more]</label></div><br/><div class="children"><div class="content">Depending on the algorithm, one or two of the digits in the TOTP are counters to help the server figure out clock drift on the client device.<p>This was especially relevant when talking about hardware tokens that had relatively inaccurate clocks. In the RSA algorithm I seem to recall it was the second or third digit. Each clock tick was 2.5 seconds or something, so providing the last digit of the clock counter massively reduced the number of calculations the server had to do in case of a mismatch.</div><br/><div id="40880489" class="c"><input type="checkbox" id="c-40880489" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40880146">parent</a><span>|</span><label class="collapse" for="c-40880489">[-]</label><label class="expand" for="c-40880489">[2 more]</label></div><br/><div class="children"><div class="content">No, TOTP implementations don’t compensate for clock drift, but they do compensate for moderate inaccuracy and races at the edges of the 30 second slots by typically allowing two or three codes around the current time +&#x2F;- 1 minute or so.</div><br/><div id="40880770" class="c"><input type="checkbox" id="c-40880770" checked=""/><div class="controls bullet"><span class="by">slau</span><span>|</span><a href="#40880146">root</a><span>|</span><a href="#40880489">parent</a><span>|</span><label class="collapse" for="c-40880770">[-]</label><label class="expand" for="c-40880770">[1 more]</label></div><br/><div class="children"><div class="content">Well, considering I was part of the implementation team of one of those hardware tokens, I&#x27;m sorry I&#x27;m going to have to disagree with you :). Please note that I&#x27;m not talking about RFC6238 &#x2F; 4226. I&#x27;m talking about proprietary implementations for hardware tokens.<p>We most definitely had drift management. One of the differentiating features to our competitors is that our algorithm had both a &quot;click counter&quot; (number of times the button was pressed) and a &quot;clock counter&quot;. The least significant digit of both counters was included in the OTP that was generated. The authentication server used the last digit of both counters to figure out what values to use, and as you say, generated codes in both time directions in order to try and identify the values of the counters (well, the click counter obviously didn&#x27;t go both directions).<p>The server then stored the last matching click counter value and the drift of the clock value. It wasn&#x27;t uncommon to have tokens that drifted by multiple minutes per month.<p>This being said, you&#x27;re right: the clock only incremented every 28 or 32 seconds, not 2.5 seconds as I incorrectly remembered.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>