<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714554069589" as="style"/><link rel="stylesheet" href="styles.css?v=1714554069589"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/borgo-lang/borgo">Borgo is a statically typed language that compiles to Go</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>manx</span> | <span>255 comments</span></div><br/><div><div id="40218563" class="c"><input type="checkbox" id="c-40218563" checked=""/><div class="controls bullet"><span class="by">tbrockman</span><span>|</span><a href="#40212796">next</a><span>|</span><label class="collapse" for="c-40218563">[-]</label><label class="expand" for="c-40218563">[2 more]</label></div><br/><div class="children"><div class="content">This addresses pretty much all of my least favorite things with writing Go code at work, and I hope--at the very least--the overwhelming positivity (by HN standards -- even considering the typical  Rust bias!) of the responses inspires Go maintainers to consider&#x2F;prioritize some of these features, or renews the authors interest in working on the project (as some have commented, it seems to have gone without activity for a little bit over half a year).<p>Some of the design decisions seem to me to be a bit more driven by being Rust-like than addressing Go&#x27;s thorns though. In particular, using `impl` to define methods on types (<a href="https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#methods" rel="nofollow">https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#methods</a>), the new syntax for channels and goroutines (<a href="https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#channels" rel="nofollow">https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#channels</a>), and the `zeroValue()` built-in (<a href="https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#zero-values-and-nil" rel="nofollow">https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#zero-values-and-nil</a>) seem a bit out of place. Overall though, if I had a choice, I would still rather write Borgo by the looks of it.</div><br/><div id="40219198" class="c"><input type="checkbox" id="c-40219198" checked=""/><div class="controls bullet"><span class="by">nobleach</span><span>|</span><a href="#40218563">parent</a><span>|</span><a href="#40212796">next</a><span>|</span><label class="collapse" for="c-40219198">[-]</label><label class="expand" for="c-40219198">[1 more]</label></div><br/><div class="children"><div class="content">I have to disagree. I&#x27;m on record here lamenting Go. I&#x27;ve never really enjoyed writing it. When I&#x27;ve had to use it, I&#x27;ve used it. Lately though, I&#x27;ve found a lot more pleasure. And much of that comes from the fact that it does NOT have all these features. The code I write, is going to look like the code written by most other on my team. There&#x27;s an idiomatic way to write Go, and it doesn&#x27;t involve those concepts from other languages. (For better or for worse) So I&#x27;m super hyped that we&#x27;d have a &quot;compiles TO Go&quot; language, but I&#x27;m not as excited as using it as a catalyst to get new (and perhaps wrong for the language) features into Go.</div><br/></div></div></div></div><div id="40212796" class="c"><input type="checkbox" id="c-40212796" checked=""/><div class="controls bullet"><span class="by">lordofgibbons</span><span>|</span><a href="#40218563">prev</a><span>|</span><a href="#40218648">next</a><span>|</span><label class="collapse" for="c-40212796">[-]</label><label class="expand" for="c-40212796">[87 more]</label></div><br/><div class="children"><div class="content">Wow, this is everything I want from a new Go!<p>Having worked on multiple very large Go codebases with many engineers, the lack of actual enums and a built-in optional type instead of nil drive me crazy.<p>I think I&#x27;m in love.<p>Edit:
Looks like last commit was 7 months ago. Was this abandoned, or considered feature complete? I hope it&#x27;s not abandoned!</div><br/><div id="40216208" class="c"><input type="checkbox" id="c-40216208" checked=""/><div class="controls bullet"><span class="by">H1Supreme</span><span>|</span><a href="#40212796">parent</a><span>|</span><a href="#40217033">next</a><span>|</span><label class="collapse" for="c-40216208">[-]</label><label class="expand" for="c-40216208">[78 more]</label></div><br/><div class="children"><div class="content">An Enum type has to be on the core Go team&#x27;s radar by now. It&#x27;s got to be tied with a try&#x2F;catch block in terms of requested features at this point (now that we have generics).</div><br/><div id="40218016" class="c"><input type="checkbox" id="c-40218016" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216208">parent</a><span>|</span><a href="#40216565">next</a><span>|</span><label class="collapse" for="c-40218016">[-]</label><label class="expand" for="c-40218016">[26 more]</label></div><br/><div class="children"><div class="content">No one wants try&#x2F;catch&#x2F;exception in Go.</div><br/><div id="40218290" class="c"><input type="checkbox" id="c-40218290" checked=""/><div class="controls bullet"><span class="by">callc</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218016">parent</a><span>|</span><a href="#40218914">next</a><span>|</span><label class="collapse" for="c-40218290">[-]</label><label class="expand" for="c-40218290">[18 more]</label></div><br/><div class="children"><div class="content">Comments like this are what drives me away from Go; comments that enforce a particular belief about how or what features you should or should not use&#x2F;introduce in your PL.
Talking in absolutes is so far removed from a logical arguments and from good engineering.
I would appreciate if anyone could recommend a language like Go (static, strong typed, not ancient, good tooling) with a friendly community, that won’t ostracize the non-believers. Zig?</div><br/><div id="40218622" class="c"><input type="checkbox" id="c-40218622" checked=""/><div class="controls bullet"><span class="by">AnonymousPlanet</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218290">parent</a><span>|</span><a href="#40219877">next</a><span>|</span><label class="collapse" for="c-40218622">[-]</label><label class="expand" for="c-40218622">[4 more]</label></div><br/><div class="children"><div class="content">Go is a very opinionated language from it&#x27;s inception. We could probably argue for all eternity about code formatting, for instance. But Go went and set it in stone. Maybe it&#x27;s part of good engineering to keep things simple and not allow hundreds of ways to do something. Maybe the people who use Go are the ones who just want to write and read simple and maintainable code and don&#x27;t want it to be cluttered with whatever is currently the fashion.<p>You could look at Lisp. It&#x27;s kind of the opposite of Go in this regard. You can use whatever paradigm you like, generate new code on the fly, use types or leave them. It even allows you to easily extend the language to your taste, all the way down to how code is read.<p>But Lisp might violate <i>your</i> set of absolutes.</div><br/><div id="40220161" class="c"><input type="checkbox" id="c-40220161" checked=""/><div class="controls bullet"><span class="by">callc</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218622">parent</a><span>|</span><a href="#40220368">next</a><span>|</span><label class="collapse" for="c-40220161">[-]</label><label class="expand" for="c-40220161">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your response AnonymousPlanet. I agree there is value in the pursuit of a minimal set of features in a PL which brings many benefits. And of course the opposite - an overly feature packed and&#x2F;or extensible PL as a core feature has tradeoffs. Over this range of possibilities my preference probably falls somewhere in the middle.<p>I see an effect where the languages whose primary goal is a particular set language design choices (such as strict memory safety over all else) grow a cult following that enforces said design choices. Maybe in the pursuit of an opinionated language, even if the designers are reasonable at the language&#x27;s inception, the community throws out logic and &quot;opinionated&quot; becomes a in-group out-group tribal caveman situation.</div><br/></div></div><div id="40220368" class="c"><input type="checkbox" id="c-40220368" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218622">parent</a><span>|</span><a href="#40220161">prev</a><span>|</span><a href="#40219877">next</a><span>|</span><label class="collapse" for="c-40220368">[-]</label><label class="expand" for="c-40220368">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Go is a very opinionated language from it&#x27;s inception.<p>True.<p>&gt; We could probably argue for all eternity about code formatting, for instance. But Go went and set it in stone.<p>This is part of the story that Rob Pikes uses to justify how opinionated Go is, but it&#x27;s a bit stupid given that most language do fine and I&#x27;ve never seen any debates about the code formatting after the very beginning of a project (where it&#x27;s always settled quickly in the few case where it happens in the first place).<p>The real reason why Go is opinionated is much more mundane: Rob is an old man who think he has seen it all and that the younger folks are children, and as a result he is <i>very</i> opinionated. (remember his argument against syntax coloring because “it&#x27;s for babies” or something).<p>It&#x27;s not bad to be opinionated when designing a language, it give some kind of coherence to it (looking at you Java and C++) but it can also get into the way of users sometimes. Fortunately Go isn&#x27;t just Rob anymore and isn&#x27;t impervious to changes, and there is finally generics and a package manager in the language!</div><br/><div id="40220882" class="c"><input type="checkbox" id="c-40220882" checked=""/><div class="controls bullet"><span class="by">AnonymousPlanet</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40220368">parent</a><span>|</span><a href="#40219877">next</a><span>|</span><label class="collapse" for="c-40220882">[-]</label><label class="expand" for="c-40220882">[1 more]</label></div><br/><div class="children"><div class="content">Seriously, if you feel patronised by how someone designs a programming language, it might be best to move on. It&#x27;s obviously not for you. Especially when you feel compelled to bad faith assumptions and ageism over it.<p>For those who want to feel the wind of coding freedom blow through their hair, I can recommend to spend some time learning Lisp. It offers the most freedom you can possibly have in a programming language. It might enlighten you in many other ways. It won&#x27;t be the last language you learn, but it might be the most fruitful experience.</div><br/></div></div></div></div></div></div><div id="40219877" class="c"><input type="checkbox" id="c-40219877" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218290">parent</a><span>|</span><a href="#40218622">prev</a><span>|</span><a href="#40218683">next</a><span>|</span><label class="collapse" for="c-40219877">[-]</label><label class="expand" for="c-40219877">[1 more]</label></div><br/><div class="children"><div class="content">Aside from &quot;not ancient&quot; Java has everything you want! I&#x27;d consider the best tooling (Intellij), static, strongly typed, has enums now (sealed interfaces), composeable error handling, null safety with new module flags, etc.  Not sure about the community, but the maintainers I&#x27;ve worked with seemed nice enough.  I imagine the community has a lot less ego than rust&#x2F;go due to the general perception of the language.</div><br/></div></div><div id="40218683" class="c"><input type="checkbox" id="c-40218683" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218290">parent</a><span>|</span><a href="#40219877">prev</a><span>|</span><a href="#40219091">next</a><span>|</span><label class="collapse" for="c-40218683">[-]</label><label class="expand" for="c-40218683">[8 more]</label></div><br/><div class="children"><div class="content">You&#x27;re reading way too much into what the parent poster said. He just correctly stated the overall sentiment of the community.<p>That said, suggesting adding exceptions to Go is about as reasonable as adding a GC to Zig. How much effort would you spend arguing against someone bringing that up as a serious proposal?</div><br/><div id="40218729" class="c"><input type="checkbox" id="c-40218729" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218683">parent</a><span>|</span><a href="#40219091">next</a><span>|</span><label class="collapse" for="c-40218729">[-]</label><label class="expand" for="c-40218729">[7 more]</label></div><br/><div class="children"><div class="content"><i>&gt; That said, suggesting adding exceptions to Go is about as reasonable as adding a GC to Zig.</i><p>Suggesting the addition of exceptions to Go is as reasonable as suggesting the addition of loops to Rust. Which is to say that it already has exceptions, and always has. Much of the language&#x27;s design is heavily dependent on the presence of exceptions.<p>Idioms dictate that you probably shouldn&#x27;t use exceptions for errors (nor should you in any language, to be fair), but even that&#x27;s not strictly adhered to. encoding&#x2F;json in the standard library famously propagates errors using the exception handlers.</div><br/><div id="40218755" class="c"><input type="checkbox" id="c-40218755" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218729">parent</a><span>|</span><a href="#40219091">next</a><span>|</span><label class="collapse" for="c-40218755">[-]</label><label class="expand" for="c-40218755">[6 more]</label></div><br/><div class="children"><div class="content">Go doesn&#x27;t use exceptions as a primary way of handling errors, which is what we&#x27;re talking about here. Pedantry is not welcome.</div><br/><div id="40218766" class="c"><input type="checkbox" id="c-40218766" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218755">parent</a><span>|</span><a href="#40219091">next</a><span>|</span><label class="collapse" for="c-40218766">[-]</label><label class="expand" for="c-40218766">[5 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t not use exception handlers as a primary way of handling errors either, though. Go doesn&#x27;t specify any error handling mechanism. Using exception handlers is just as valid as any other, and even the standard library does it, as noted earlier.<p>The only error-related concept the Go language has is the error type, but it comes with no handling semantics. Which stands to reason  as there is nothing special about errors. Originally, Go didn&#x27;t even have an error type, but it was added as a workaround to deal with the language not supporting cyclic imports.<p>Your pedantry is hilarious and contradictory.</div><br/><div id="40218963" class="c"><input type="checkbox" id="c-40218963" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218766">parent</a><span>|</span><a href="#40220887">next</a><span>|</span><label class="collapse" for="c-40218963">[-]</label><label class="expand" for="c-40218963">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely technically correct, in the &quot;spherical cow in a vacuum&quot; sense. In reality though, essentially all Go code out there handles errors through the pattern of checking if the error in a `(value, error)` tuple returned from a function is `nil` or not. That is what the discussion here is about - the way errors are handled in a language in practice, not in theory. Therefore, pedantry.<p>Basically, discussions have context and I have no intention of prepending 10 disclaimers to every statement I make to preemptively guard against people interpreting my comments as absolutes in a vacuum.</div><br/><div id="40219061" class="c"><input type="checkbox" id="c-40219061" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218963">parent</a><span>|</span><a href="#40220887">next</a><span>|</span><label class="collapse" for="c-40219061">[-]</label><label class="expand" for="c-40219061">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a lot of pedantry you&#x27;ve got there for someone who claims it is not welcome. Rules for thee, not for me?<p>But, if you&#x27;d kindly come back to the topic at hand:<p><i>&gt; That is what the discussion here is about - the way errors are handled in a language in practice, not in theory.</i><p>While I&#x27;m not entirely convinced that is accurate, I will accept it. Now, how does:<p>- <i>&quot;That said, suggesting adding exceptions to Go is about as reasonable as adding a GC to Zig.&quot;</i><p>Relate to that assertion? What does &quot;suggesting adding exceptions to Go&quot; have to do with a common pattern that has emerged?</div><br/><div id="40219790" class="c"><input type="checkbox" id="c-40219790" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219061">parent</a><span>|</span><a href="#40220887">next</a><span>|</span><label class="collapse" for="c-40219790">[-]</label><label class="expand" for="c-40219790">[1 more]</label></div><br/><div class="children"><div class="content">It’s not simply a common pattern. It is a way of doing things in the community. The stdlib uses it, the libraries use it, and if you do not use it, people will not use your software.</div><br/></div></div></div></div></div></div><div id="40220887" class="c"><input type="checkbox" id="c-40220887" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218766">parent</a><span>|</span><a href="#40218963">prev</a><span>|</span><a href="#40219091">next</a><span>|</span><label class="collapse" for="c-40220887">[-]</label><label class="expand" for="c-40220887">[1 more]</label></div><br/><div class="children"><div class="content">I would be happy if they would add in compiler some thing that&#x27;ll allow to ignore error return values and in this case compiler would just throw exception^Wpanic from that point. I think it even makes sense for go purists, like you need to handle errors or get panicked. And I&#x27;d just mostly ignore errors and will have my sweet exceptions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40219091" class="c"><input type="checkbox" id="c-40219091" checked=""/><div class="controls bullet"><span class="by">smt88</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218290">parent</a><span>|</span><a href="#40218683">prev</a><span>|</span><a href="#40220673">next</a><span>|</span><label class="collapse" for="c-40219091">[-]</label><label class="expand" for="c-40219091">[2 more]</label></div><br/><div class="children"><div class="content">You have the same PL preferences as me. I haven&#x27;t tried Rust yet, but Kotlin, modern C#, and F# all fit your requirements. Kotlin is closest because it uses the enormous Java ecosystem.</div><br/><div id="40219903" class="c"><input type="checkbox" id="c-40219903" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219091">parent</a><span>|</span><a href="#40220673">next</a><span>|</span><label class="collapse" for="c-40219903">[-]</label><label class="expand" for="c-40219903">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t had time to really try to write anything in it, but <a href="https:&#x2F;&#x2F;gleam.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gleam.run&#x2F;</a> looks really good too. Like Elm for backend + frontend!</div><br/></div></div></div></div><div id="40218825" class="c"><input type="checkbox" id="c-40218825" checked=""/><div class="controls bullet"><span class="by">VS1999</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218290">parent</a><span>|</span><a href="#40220673">prev</a><span>|</span><a href="#40218914">next</a><span>|</span><label class="collapse" for="c-40218825">[-]</label><label class="expand" for="c-40218825">[1 more]</label></div><br/><div class="children"><div class="content">Why would you not enforce a particular belief about how a language should be designed? There are languages designed around being able to do anything you want at any time regardless of if it makes sense, and then you end up with everyone using their own fractured subset of language features that don&#x27;t even work well together. Not every language needs to be the same feature slop that supports everything poorly and nothing well.</div><br/></div></div></div></div><div id="40218914" class="c"><input type="checkbox" id="c-40218914" checked=""/><div class="controls bullet"><span class="by">thefounder</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218016">parent</a><span>|</span><a href="#40218290">prev</a><span>|</span><a href="#40218033">next</a><span>|</span><label class="collapse" for="c-40218914">[-]</label><label class="expand" for="c-40218914">[4 more]</label></div><br/><div class="children"><div class="content">Let’s hope Go never gets try&#x2F;catch exceptions</div><br/><div id="40219430" class="c"><input type="checkbox" id="c-40219430" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218914">parent</a><span>|</span><a href="#40220624">next</a><span>|</span><label class="collapse" for="c-40219430">[-]</label><label class="expand" for="c-40219430">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    func try(fn func()) { fn() }
    func catch(fn func(any)) {
        if v := recover(); v != nil {
            fn(v)
        }
    }
    func throw(v any) { panic(v) }

    func fail() {
        throw(&quot;Bad things have happened&quot;)
    }

    func main() {
        try(func() {
            defer catch(func(v any) {
                fmt.Println(v)
            })
            fail()
        })
    }

</code></pre>
Sorry.</div><br/><div id="40220133" class="c"><input type="checkbox" id="c-40220133" checked=""/><div class="controls bullet"><span class="by">rnmmrnm</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219430">parent</a><span>|</span><a href="#40220624">next</a><span>|</span><label class="collapse" for="c-40220133">[-]</label><label class="expand" for="c-40220133">[1 more]</label></div><br/><div class="children"><div class="content">the day the go codebase throws random panics is the day I quit the company.</div><br/></div></div></div></div><div id="40220624" class="c"><input type="checkbox" id="c-40220624" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218914">parent</a><span>|</span><a href="#40219430">prev</a><span>|</span><a href="#40218033">next</a><span>|</span><label class="collapse" for="c-40220624">[-]</label><label class="expand" for="c-40220624">[1 more]</label></div><br/><div class="children"><div class="content">ESBuild, one of my favourite Go projects, uses panics to handle try&#x2F;catch exceptions.<p>The syscall&#x2F;js package [0] throws panics if something goes wrong, rather than returning errors.<p>Go already has try&#x2F;catch exceptions. We just don&#x27;t use them most of the time because they&#x27;re a really bad way of handling errors.<p>[0] <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;syscall&#x2F;js" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;syscall&#x2F;js</a></div><br/></div></div></div></div><div id="40218033" class="c"><input type="checkbox" id="c-40218033" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218016">parent</a><span>|</span><a href="#40218914">prev</a><span>|</span><a href="#40218524">next</a><span>|</span><label class="collapse" for="c-40218033">[-]</label><label class="expand" for="c-40218033">[1 more]</label></div><br/><div class="children"><div class="content">panic&#x2F;recover&#x2F;error?</div><br/></div></div><div id="40218524" class="c"><input type="checkbox" id="c-40218524" checked=""/><div class="controls bullet"><span class="by">beeboobaa3</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218016">parent</a><span>|</span><a href="#40218033">prev</a><span>|</span><a href="#40216565">next</a><span>|</span><label class="collapse" for="c-40218524">[-]</label><label class="expand" for="c-40218524">[2 more]</label></div><br/><div class="children"><div class="content">Objectively wrong.</div><br/><div id="40220107" class="c"><input type="checkbox" id="c-40220107" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218524">parent</a><span>|</span><a href="#40216565">next</a><span>|</span><label class="collapse" for="c-40220107">[-]</label><label class="expand" for="c-40220107">[1 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t mean literally 0 people.</div><br/></div></div></div></div></div></div><div id="40216565" class="c"><input type="checkbox" id="c-40216565" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216208">parent</a><span>|</span><a href="#40218016">prev</a><span>|</span><a href="#40218482">next</a><span>|</span><label class="collapse" for="c-40216565">[-]</label><label class="expand" for="c-40216565">[15 more]</label></div><br/><div class="children"><div class="content">The issue is that it&#x27;s more or less impossible to graft onto the language now. You could add enums, but the main reason why people want them is to fix the error handling. You can&#x27;t do this without fracturing the ecosystem.</div><br/><div id="40216682" class="c"><input type="checkbox" id="c-40216682" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216565">parent</a><span>|</span><a href="#40219638">next</a><span>|</span><label class="collapse" for="c-40216682">[-]</label><label class="expand" for="c-40216682">[12 more]</label></div><br/><div class="children"><div class="content">&gt; but the main reason why people want them is to fix the error handling<p>Why do you think so? Maybe I&#x27;m an odd case, but my main use case for enums is for APIs and database designs, where I want to lock down some field to a set of acceptable values and make sure anything else is a mistake. Or for state machines. Error handling is manageable without enums (but I love Option&#x2F;Result types more than Go&#x27;s error approach, especially with the ? operator).</div><br/><div id="40219615" class="c"><input type="checkbox" id="c-40219615" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216682">parent</a><span>|</span><a href="#40218008">next</a><span>|</span><label class="collapse" for="c-40219615">[-]</label><label class="expand" for="c-40219615">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but I love Option&#x2F;Result types more than Go&#x27;s error approach<p>The thing is, these don&#x27;t add much on their own. You&#x27;d have to bring in pattern matching and&#x2F;or a bunch of other things* that would significantly complicate the language.<p>For example, with what&#x27;s currently in the language, you could definitely have an option type. You&#x27;d just be limited to roughly an api that&#x27;s `func (o Option[T]) IsEmpty() bool` and `func (o Option[T]) Get() T`. And these would just check if the underlying point is nil and dereference it. You can already do that with pointers. Errors&#x2F;Result are similar.<p>A `try` keyword that expands `x := try thingThatProducesErr()` to:<p><pre><code>    x, err := thingThatProducesErr()
    if err != nil {
        return {zero values of the rest of the function signature}, err
    }
</code></pre>
Might be more useful in go (you could have a similar one for pointers).<p>* at the very least generic methods for flat map shenanigans</div><br/><div id="40219856" class="c"><input type="checkbox" id="c-40219856" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219615">parent</a><span>|</span><a href="#40218008">next</a><span>|</span><label class="collapse" for="c-40219856">[-]</label><label class="expand" for="c-40219856">[1 more]</label></div><br/><div class="children"><div class="content">Using an Option instead of a pointer buys you the inability to forget to check for nil.<p>Just need to make sure the Option exposes the internal value only through:<p><pre><code>    func (o Option[Value]) Get() (Value, bool) {
        return o.value, o.exists
    }
</code></pre>
Accessing the value is then forced to look like this:<p><pre><code>    if value, ok := option.Get(); ok {
        &#x2F;&#x2F; value is valid
    }
    &#x2F;&#x2F; value is invalid
</code></pre>
Thus, there&#x27;s no possibility of an accidental nil pointer dereference, which I think is a big win.<p>A Result type would bring a similar benefit of fixing the few edge cases where an error may accidentally not be handled. Although I don&#x27;t think it&#x27;d be worth the cost of switching over.</div><br/></div></div></div></div><div id="40218008" class="c"><input type="checkbox" id="c-40218008" checked=""/><div class="controls bullet"><span class="by">imetatroll</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216682">parent</a><span>|</span><a href="#40219615">prev</a><span>|</span><a href="#40216924">next</a><span>|</span><label class="collapse" for="c-40218008">[-]</label><label class="expand" for="c-40218008">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-enum.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-enum.html</a><p>Then wrap appropriately.  Something like sqlc will actually generate everything you need.</div><br/></div></div><div id="40216924" class="c"><input type="checkbox" id="c-40216924" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216682">parent</a><span>|</span><a href="#40218008">prev</a><span>|</span><a href="#40219638">next</a><span>|</span><label class="collapse" for="c-40216924">[-]</label><label class="expand" for="c-40216924">[8 more]</label></div><br/><div class="children"><div class="content"><i>&gt; my main use case for enums is for APIs and database designs, where I want to lock down some field to a set of acceptable values and make sure anything else is a mistake</i><p>Then what you are really looking for is sum types (what Rust calls enums, but unusually so), not enums. Go does not have sum types, but you can use interfaces to archive a rough facsimile and most certainly to satisfy your specific expectation:<p><pre><code>    type Hot struct{}
    func (Hot) temp() {}

    type Cold struct{}
    func (Cold) temp() {}

    type Temperature interface {
        temp()
    }

    func SetThermostat(temperature Temperature) {
        switch temperature.(type) {
        case Hot:
            fmt.Println(&quot;Hot&quot;)
        case Cold:
            fmt.Println(&quot;Cold&quot;)
        }
    }</code></pre></div><br/><div id="40218785" class="c"><input type="checkbox" id="c-40218785" checked=""/><div class="controls bullet"><span class="by">throwaway143829</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216924">parent</a><span>|</span><a href="#40217377">next</a><span>|</span><label class="collapse" for="c-40218785">[-]</label><label class="expand" for="c-40218785">[4 more]</label></div><br/><div class="children"><div class="content">Enums and sum types seem to be related. In the code you wrote, you could alternatively express the Hot and Cold types as enum values. I would say that enums are a subset of sum types but I don&#x27;t know if that&#x27;s quite right. I guess maybe if you view each enum value as having its own distinct type (maybe a subtype of the enum type), then you could say the enum is the sum type of the enum value types?</div><br/><div id="40218932" class="c"><input type="checkbox" id="c-40218932" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218785">parent</a><span>|</span><a href="#40220221">next</a><span>|</span><label class="collapse" for="c-40218932">[-]</label><label class="expand" for="c-40218932">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Enums and sum types seem to be related.</i><p>They can certainly help solve some of the same problems. Does that make them related? I don&#x27;t know.<p>By definition, an enumeration is something that counts one-by-one. In other words, as is used in programming languages, a construct that numbers a set of named constants. Indeed you can solve the problem using that:<p><pre><code>    type Temperature int

    const (
        Hot Temperature = iota
        Cold
    )

    func SetThermostat(temperature Temperature) {
        switch temperature {
        case Hot:
            fmt.Println(&quot;Hot&quot;)
        case Cold:
            fmt.Println(&quot;Cold&quot;)
        }
    }
</code></pre>
But, while a handy convenience (especially if the set is large!), you don&#x27;t even need enums. You can number the constants by hand to the exact same effect:<p><pre><code>    type Temperature int

    const (
        Hot  Temperature = 0
        Cold Temperature = 1 
    )

    func SetThermostat(temperature Temperature) {
        switch temperature {
        case Hot:
            fmt.Println(&quot;Hot&quot;)
        case Cold:
            fmt.Println(&quot;Cold&quot;)
        }
    }
</code></pre>
I&#x27;m not sure that exhibits any sum type properties. I <i>guess</i> you could see the value as being a tag, but there is no union.</div><br/><div id="40220033" class="c"><input type="checkbox" id="c-40220033" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218932">parent</a><span>|</span><a href="#40220221">next</a><span>|</span><label class="collapse" for="c-40220033">[-]</label><label class="expand" for="c-40220033">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, this:<p><pre><code>    const (
        Hot  Temperature = 0
        Cold Temperature = 1 
    )
</code></pre>
Isn&#x27;t really a good workaround when lacking an <i>enumeration</i> type. The compiler can&#x27;t complain when you use a value that isn&#x27;t in the list of enumerations. The compiler can&#x27;t warn you when your switch statement doesn&#x27;t handle one of the cases.<p>Refactoring is harder - when you add a new value to the enum, you can&#x27;t easily find all those places that may require logic changes to handle the new value.<p>Enums are a big thing I miss when writing Go, compared to when writing C.</div><br/></div></div></div></div><div id="40220221" class="c"><input type="checkbox" id="c-40220221" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218785">parent</a><span>|</span><a href="#40218932">prev</a><span>|</span><a href="#40217377">next</a><span>|</span><label class="collapse" for="c-40220221">[-]</label><label class="expand" for="c-40220221">[1 more]</label></div><br/><div class="children"><div class="content">Enums are exactly sums of unit types (types with only one value).</div><br/></div></div></div></div><div id="40217377" class="c"><input type="checkbox" id="c-40217377" checked=""/><div class="controls bullet"><span class="by">blueberry87</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216924">parent</a><span>|</span><a href="#40218785">prev</a><span>|</span><a href="#40219638">next</a><span>|</span><label class="collapse" for="c-40217377">[-]</label><label class="expand" for="c-40217377">[3 more]</label></div><br/><div class="children"><div class="content">annoyingly go <i>can&#x27;t</i> have proper sum types, as the requirement for a default value for everything doesn&#x27;t make any sense for sum types</div><br/><div id="40218821" class="c"><input type="checkbox" id="c-40218821" checked=""/><div class="controls bullet"><span class="by">throwaway143829</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217377">parent</a><span>|</span><a href="#40217903">next</a><span>|</span><label class="collapse" for="c-40218821">[-]</label><label class="expand" for="c-40218821">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t the zero value be nil? I get that some types like int are not nil-able, but the language allows you to assign both nil and int to a value of type any (interface{}), so I wonder why it couldn&#x27;t work the same for sum types. i.e. they would be a subset of the `any` type.</div><br/></div></div><div id="40217903" class="c"><input type="checkbox" id="c-40217903" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217377">parent</a><span>|</span><a href="#40218821">prev</a><span>|</span><a href="#40219638">next</a><span>|</span><label class="collapse" for="c-40217903">[-]</label><label class="expand" for="c-40217903">[1 more]</label></div><br/><div class="children"><div class="content">You can just default to the first variant, no?</div><br/></div></div></div></div></div></div></div></div><div id="40219638" class="c"><input type="checkbox" id="c-40219638" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216565">parent</a><span>|</span><a href="#40216682">prev</a><span>|</span><a href="#40218345">next</a><span>|</span><label class="collapse" for="c-40219638">[-]</label><label class="expand" for="c-40219638">[1 more]</label></div><br/><div class="children"><div class="content">I would like to have proper stack traces. With that the error handling in go would be fixed.</div><br/></div></div><div id="40218345" class="c"><input type="checkbox" id="c-40218345" checked=""/><div class="controls bullet"><span class="by">LorenzoGood</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216565">parent</a><span>|</span><a href="#40219638">prev</a><span>|</span><a href="#40218482">next</a><span>|</span><label class="collapse" for="c-40218345">[-]</label><label class="expand" for="c-40218345">[1 more]</label></div><br/><div class="children"><div class="content">I just want regular enums, that would solve the problems that result from using the current status quo.</div><br/></div></div></div></div><div id="40218482" class="c"><input type="checkbox" id="c-40218482" checked=""/><div class="controls bullet"><span class="by">AnonymousPlanet</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216208">parent</a><span>|</span><a href="#40216565">prev</a><span>|</span><a href="#40216658">next</a><span>|</span><label class="collapse" for="c-40218482">[-]</label><label class="expand" for="c-40218482">[29 more]</label></div><br/><div class="children"><div class="content">I am so tired of reading Java&#x2F;C++&#x2F;Python code that just slaps try&#x2F;catch around several lines. To some it might seem annoying to actually think about errors and error handling line by line, but for whoever tries to debug or refactor it&#x27;s a godsend. Where I work, try&#x2F;catch for more than one call that can throw an exception or including arbitrary lines that don&#x27;t throw the caught exception, is a code smell.<p>So when I looked at Go for the first time, the error handling was one of the many positive features.<p>Is there any good reason for wanting try&#x2F;catch other than being lazy?</div><br/><div id="40218652" class="c"><input type="checkbox" id="c-40218652" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40219296">next</a><span>|</span><label class="collapse" for="c-40218652">[-]</label><label class="expand" for="c-40218652">[11 more]</label></div><br/><div class="children"><div class="content">&gt;the error handling was one of the many positive features.<p>sounds good on paper, but seeing &quot;if err!=nil&quot; repeated million times in golang codebases does not create positive impression at all</div><br/><div id="40218662" class="c"><input type="checkbox" id="c-40218662" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218652">parent</a><span>|</span><a href="#40220043">next</a><span>|</span><label class="collapse" for="c-40218662">[-]</label><label class="expand" for="c-40218662">[1 more]</label></div><br/><div class="children"><div class="content">golang keyboard ftw 
<a href="https:&#x2F;&#x2F;pbs.twimg.com&#x2F;media&#x2F;DCIF7-2W0AEAv9c.jpg" rel="nofollow">https:&#x2F;&#x2F;pbs.twimg.com&#x2F;media&#x2F;DCIF7-2W0AEAv9c.jpg</a></div><br/></div></div><div id="40220043" class="c"><input type="checkbox" id="c-40220043" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218652">parent</a><span>|</span><a href="#40218662">prev</a><span>|</span><a href="#40219304">next</a><span>|</span><label class="collapse" for="c-40220043">[-]</label><label class="expand" for="c-40220043">[3 more]</label></div><br/><div class="children"><div class="content">&gt; sounds good on paper, but seeing &quot;if err!=nil&quot; repeated million times in golang codebases does not create positive impression at all<p>Okay, but other than exceptions, whats the alternative?</div><br/><div id="40220084" class="c"><input type="checkbox" id="c-40220084" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40220043">parent</a><span>|</span><a href="#40219304">next</a><span>|</span><label class="collapse" for="c-40220084">[-]</label><label class="expand" for="c-40220084">[2 more]</label></div><br/><div class="children"><div class="content">The ? Operator in Rust?</div><br/><div id="40220153" class="c"><input type="checkbox" id="c-40220153" checked=""/><div class="controls bullet"><span class="by">dureuill</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40220084">parent</a><span>|</span><a href="#40219304">next</a><span>|</span><label class="collapse" for="c-40220153">[-]</label><label class="expand" for="c-40220153">[1 more]</label></div><br/><div class="children"><div class="content">More than just that, Result in general also prevents from accessing the value when there is an error and accessing an error when there is a value.</div><br/></div></div></div></div></div></div><div id="40219304" class="c"><input type="checkbox" id="c-40219304" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218652">parent</a><span>|</span><a href="#40220043">prev</a><span>|</span><a href="#40219296">next</a><span>|</span><label class="collapse" for="c-40219304">[-]</label><label class="expand" for="c-40219304">[6 more]</label></div><br/><div class="children"><div class="content">Yes but the impression is largely superficial. The error handling gets the job done well enough, if crudely.</div><br/><div id="40219808" class="c"><input type="checkbox" id="c-40219808" checked=""/><div class="controls bullet"><span class="by">FuckButtons</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219304">parent</a><span>|</span><a href="#40219296">next</a><span>|</span><label class="collapse" for="c-40219808">[-]</label><label class="expand" for="c-40219808">[5 more]</label></div><br/><div class="children"><div class="content">The ability to quickly parse, understand and reason about code is not superficial, it is essential to the job. And that is essentially what those verbose blocks of text get in the way of.</div><br/><div id="40220663" class="c"><input type="checkbox" id="c-40220663" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219808">parent</a><span>|</span><a href="#40219821">next</a><span>|</span><label class="collapse" for="c-40220663">[-]</label><label class="expand" for="c-40220663">[1 more]</label></div><br/><div class="children"><div class="content">As an experienced Go dev, this is literally not a problem.<p>Golang code has a rhythm: you do the thing, you check the error, you do the thing, you check the error. After a while it becomes automatic and easy to read, like any other syntax&#x2F;formatting. You notice if the error isn&#x27;t checked.<p>Yes, at first it&#x27;s jarring. But to be honest, the jarring thing is because Go code checks the error every time it does something, not because of the actual &quot;if err != nil&quot; syntax.</div><br/></div></div><div id="40219821" class="c"><input type="checkbox" id="c-40219821" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219808">parent</a><span>|</span><a href="#40220663">prev</a><span>|</span><a href="#40220128">next</a><span>|</span><label class="collapse" for="c-40219821">[-]</label><label class="expand" for="c-40219821">[2 more]</label></div><br/><div class="children"><div class="content">Sure, I just don&#x27;t think it&#x27;s that significant. Humans don&#x27;t read&#x2F;parse code character-by character, we do it by recognizing visual patterns. Blocks of `if err != nil { }` are easy to skip over when reading if needed.</div><br/><div id="40219930" class="c"><input type="checkbox" id="c-40219930" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219821">parent</a><span>|</span><a href="#40220128">next</a><span>|</span><label class="collapse" for="c-40219930">[-]</label><label class="expand" for="c-40219930">[1 more]</label></div><br/><div class="children"><div class="content">I agree, though I was really surprised to learn this when reading Go code. Much easier to skip over than I was expecting it to be</div><br/></div></div></div></div><div id="40220128" class="c"><input type="checkbox" id="c-40220128" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219808">parent</a><span>|</span><a href="#40219821">prev</a><span>|</span><a href="#40219296">next</a><span>|</span><label class="collapse" for="c-40220128">[-]</label><label class="expand" for="c-40220128">[1 more]</label></div><br/><div class="children"><div class="content">The idea that error handling is &quot;not part of the code&quot; is silly though. My impression of people that hate Go&#x27;s explicit error handling is that they don&#x27;t want to deal with errors properly at all. &quot;Just catch exceptions in main and print a stack trace, it&#x27;s fine.&quot;<p>Rust&#x27;s error handling is clearly better than Go&#x27;s, but Go&#x27;s is better than exceptions and the complaints about verbosity are largely complaints about having to actually consider errors.</div><br/></div></div></div></div></div></div></div></div><div id="40219296" class="c"><input type="checkbox" id="c-40219296" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40218652">prev</a><span>|</span><a href="#40220198">next</a><span>|</span><label class="collapse" for="c-40219296">[-]</label><label class="expand" for="c-40219296">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there any good reason for wanting try&#x2F;catch other than being lazy?<p>It&#x27;s the best strategy for short running programs, or scripts if you will. You just write code without thinking about error handling at all. If anything goes wrong at runtime, the program aborts with a stacktrace, which is exactly you want  and you get it for free.<p>For long-running programs you want reliability, which implies the need to think about and explicitly handle each possible error condition, making exceptions a subpar choice.</div><br/></div></div><div id="40220198" class="c"><input type="checkbox" id="c-40220198" checked=""/><div class="controls bullet"><span class="by">BillyTheKing</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40219296">prev</a><span>|</span><a href="#40218745">next</a><span>|</span><label class="collapse" for="c-40220198">[-]</label><label class="expand" for="c-40220198">[3 more]</label></div><br/><div class="children"><div class="content">I agree, I don&#x27;t really understand everyone&#x27;s issue with err != nil.. it&#x27;s explicit, and linters catch uncaught errors. Yes the ? operator in Rust is neat, but you end up with a similar issue of just matching errors throughout your code-base instead of doing err != nil..</div><br/><div id="40220286" class="c"><input type="checkbox" id="c-40220286" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40220198">parent</a><span>|</span><a href="#40218745">next</a><span>|</span><label class="collapse" for="c-40220286">[-]</label><label class="expand" for="c-40220286">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that you&#x27;re forced to have four possible states<p>1. err != nil, nondefault return value<p>2. err != nil, default return value<p>3. err == nil, nondefault return value<p>4. err == nil, default return value<p>when often what you want to express only has two: either you return an error and there&#x27;s no meaningful output, or there&#x27;s output and no error. A type system with tuples but no sum types can only express &quot;and&quot;, not &quot;or&quot;.</div><br/><div id="40220698" class="c"><input type="checkbox" id="c-40220698" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40220286">parent</a><span>|</span><a href="#40218745">next</a><span>|</span><label class="collapse" for="c-40220698">[-]</label><label class="expand" for="c-40220698">[1 more]</label></div><br/><div class="children"><div class="content">this is true, but not a problem. Go&#x27;s pattern of checking the error on every return means that if an error is returned, that is the return. Allowing routines to return a result as well as an error is occasionally useful.</div><br/></div></div></div></div></div></div><div id="40218745" class="c"><input type="checkbox" id="c-40218745" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40220198">prev</a><span>|</span><a href="#40218715">next</a><span>|</span><label class="collapse" for="c-40218745">[-]</label><label class="expand" for="c-40218745">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s the ability to unwind the stack to an exception handler without having to propagate errors manually. Go programs end up doing the exact same thing as &quot;try&#x2F;catch around multiple lines&quot; with functions that can return an error from any point, and every caller blindly propagating the error up the stack. The practice is so common that it&#x27;s like semicolons in Java or C, it just becomes noise that you gloss over.</div><br/><div id="40219387" class="c"><input type="checkbox" id="c-40219387" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218745">parent</a><span>|</span><a href="#40218715">next</a><span>|</span><label class="collapse" for="c-40219387">[-]</label><label class="expand" for="c-40219387">[1 more]</label></div><br/><div class="children"><div class="content">The difference is that all code paths are explicitly spelled out and crucially that the programmer had to consider each path at the time of writing the code. The resulting code is much more reliable than what you end up with exceptions.</div><br/></div></div></div></div><div id="40218715" class="c"><input type="checkbox" id="c-40218715" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40218745">prev</a><span>|</span><a href="#40218741">next</a><span>|</span><label class="collapse" for="c-40218715">[-]</label><label class="expand" for="c-40218715">[7 more]</label></div><br/><div class="children"><div class="content">The huge volume of boilerplate makes the code harder to read, and annoying to write. I like go, and I don’t want exceptions persay, but I would love something that cuts out all the repetitive noise.</div><br/><div id="40218746" class="c"><input type="checkbox" id="c-40218746" checked=""/><div class="controls bullet"><span class="by">jacobr1</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218715">parent</a><span>|</span><a href="#40218741">next</a><span>|</span><label class="collapse" for="c-40218746">[-]</label><label class="expand" for="c-40218746">[6 more]</label></div><br/><div class="children"><div class="content">The example in the article is a good one. Result and Optional as first class  sum types</div><br/><div id="40219190" class="c"><input type="checkbox" id="c-40219190" checked=""/><div class="controls bullet"><span class="by">RedComet</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218746">parent</a><span>|</span><a href="#40218741">next</a><span>|</span><label class="collapse" for="c-40219190">[-]</label><label class="expand" for="c-40219190">[5 more]</label></div><br/><div class="children"><div class="content">That just changes the boilerplate from if&#x27;s to match&#x27;s.</div><br/><div id="40219319" class="c"><input type="checkbox" id="c-40219319" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219190">parent</a><span>|</span><a href="#40220214">next</a><span>|</span><label class="collapse" for="c-40219319">[-]</label><label class="expand" for="c-40219319">[3 more]</label></div><br/><div class="children"><div class="content">See the example with the `?` operator: <a href="https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo?tab=readme-ov-file#error-handling-with--operator">https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo?tab=readme-ov-file#error...</a><p>The main benefits of a Result type are brevity and the inability to accidentally not handle an error.</div><br/><div id="40219887" class="c"><input type="checkbox" id="c-40219887" checked=""/><div class="controls bullet"><span class="by">RedComet</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219319">parent</a><span>|</span><a href="#40220214">next</a><span>|</span><label class="collapse" for="c-40219887">[-]</label><label class="expand" for="c-40219887">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but that isn&#x27;t necessarily a feature of option types. Is it the case that similar sugar for the tiresome Go pattern couldn&#x27;t achieve similar benefits?</div><br/><div id="40220360" class="c"><input type="checkbox" id="c-40220360" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219887">parent</a><span>|</span><a href="#40220214">next</a><span>|</span><label class="collapse" for="c-40220360">[-]</label><label class="expand" for="c-40220360">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but there have been several proposals along those lines and nobody seems capable of figuring out a sensible implementation.<p>A funny drawback of the current Go design that a Result type would solve is the need to return zero values of all the declared function return types along with the error: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;21182">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;21182</a>.</div><br/></div></div></div></div></div></div><div id="40220214" class="c"><input type="checkbox" id="c-40220214" checked=""/><div class="controls bullet"><span class="by">BillyTheKing</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219190">parent</a><span>|</span><a href="#40219319">prev</a><span>|</span><a href="#40218741">next</a><span>|</span><label class="collapse" for="c-40220214">[-]</label><label class="expand" for="c-40220214">[1 more]</label></div><br/><div class="children"><div class="content">exactly.. yes, I understand why ? is neat from a type POV since you specifically have to unwrap an optional type whereas in Go you can ignore a returned error (although linters catch that) - so at the end of the day it&#x27;s just the same boilerplate, one with ? the other with err != nil</div><br/></div></div></div></div></div></div></div></div><div id="40218741" class="c"><input type="checkbox" id="c-40218741" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40218715">prev</a><span>|</span><a href="#40220147">next</a><span>|</span><label class="collapse" for="c-40218741">[-]</label><label class="expand" for="c-40218741">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Is there any good reason for wanting try&#x2F;catch other than being lazy?<p>In a hot path it’s often beneficial to not have lots of branches for error handling. Exceptions make it cheap on success (yeah, no branches!) and pretty expensive on failure (stack unwinding). It is context specific but I think that can be seen as a good reason to have try catch.<p>Now of course in practice people throw exceptions all the time. But in a tight, well controlled environment I can see them as being useful.</div><br/><div id="40218987" class="c"><input type="checkbox" id="c-40218987" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218741">parent</a><span>|</span><a href="#40220147">next</a><span>|</span><label class="collapse" for="c-40218987">[-]</label><label class="expand" for="c-40218987">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In a hot path it’s often beneficial to not have lots of branches for error handling.<p>This is true but the branch isn&#x27;t taken unless there&#x27;s an error in Go.<p>Given that the Go compiler emits the equivalent of `if (__unlikely(err != nil)) {...}` and that any modern CPUs are decently good at branch prediction (especially in a hot path that repeats), I find it hard to believe that the cost would be greater than exceptions.</div><br/></div></div></div></div><div id="40220147" class="c"><input type="checkbox" id="c-40220147" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40218741">prev</a><span>|</span><a href="#40218971">next</a><span>|</span><label class="collapse" for="c-40220147">[-]</label><label class="expand" for="c-40220147">[1 more]</label></div><br/><div class="children"><div class="content">You can print or log the stack trace of the exception in python.</div><br/></div></div><div id="40218971" class="c"><input type="checkbox" id="c-40218971" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218482">parent</a><span>|</span><a href="#40220147">prev</a><span>|</span><a href="#40216658">next</a><span>|</span><label class="collapse" for="c-40218971">[-]</label><label class="expand" for="c-40218971">[1 more]</label></div><br/><div class="children"><div class="content">&gt; try&#x2F;catch for more than one call that can throw an exception or including arbitrary lines<p>You generally need to skip all lines that the exception invalidates. That&#x27;s why it&#x27;s a block or  conditional.</div><br/></div></div></div></div><div id="40216658" class="c"><input type="checkbox" id="c-40216658" checked=""/><div class="controls bullet"><span class="by">jurschreuder</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216208">parent</a><span>|</span><a href="#40218482">prev</a><span>|</span><a href="#40217033">next</a><span>|</span><label class="collapse" for="c-40216658">[-]</label><label class="expand" for="c-40216658">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never needed either.<p>Try&#x2F;catch is super confusing because the catch is often far away from the try. And in Python I just put try&#x2F;catch around big chunks of code just in case for production.<p>I think Go is more stable and readable because they force you not to use the lazy unreadable way of error handling.<p>Enums I honestly never used in Go also not the not-type-safe ones.<p>But I&#x27;m also someone who used interfaces in Go maybe I think 4 times only in years and years of development.<p>I just never really need all those fancy things.</div><br/><div id="40217005" class="c"><input type="checkbox" id="c-40217005" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216658">parent</a><span>|</span><a href="#40217508">next</a><span>|</span><label class="collapse" for="c-40217005">[-]</label><label class="expand" for="c-40217005">[3 more]</label></div><br/><div class="children"><div class="content">I think what this comment is missing is any sort of analysis of how your experience maps to the general go user, and an opinion on while you&#x27;ve never <i>needed</i> either whether you think it could have provided any benefit when used appropriately.<p>For example, and option type with enums combined can ensure return values are checked by providing a compile time error if a case is missing (as expressed in the first few examples of the readme).</div><br/><div id="40219767" class="c"><input type="checkbox" id="c-40219767" checked=""/><div class="controls bullet"><span class="by">jurschreuder</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217005">parent</a><span>|</span><a href="#40217508">next</a><span>|</span><label class="collapse" for="c-40219767">[-]</label><label class="expand" for="c-40219767">[2 more]</label></div><br/><div class="children"><div class="content">I know it can, the compiler can do one more &quot;automatic&quot; unit test based on the type checking system.<p>But they decided not to add enums because it conflicted and overlapped too much with interfaces.<p>I just want to add &quot;my&quot; experience that personally, yes maybe you can argue enums are nice, but I never missed them in Go.<p>I personally agree with the Go team on how they argue and for me it would be a step back if they listened to the herd that does not take all sides of the story into consideration but just keeps pushing enums.<p>Try&#x2F;catch is just a really bad thing all &quot;hacky solution&quot; alarm bells go off for me if you want to change error handling to giant try&#x2F;catch blocks.</div><br/><div id="40220325" class="c"><input type="checkbox" id="c-40220325" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40219767">parent</a><span>|</span><a href="#40217508">next</a><span>|</span><label class="collapse" for="c-40220325">[-]</label><label class="expand" for="c-40220325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But they decided not to add enums because it conflicted and overlapped too much with interfaces.<p>I&#x27;m very curious now about how it might conflict and&#x2F;or overlap with interfaces.<p>To reach the goal of an enumeration type (and all the strong type-checking that that brings with it), enums could look as simple as:<p><pre><code>    type DayNames enum {
       Sunday
       Monday
       Tuesday
       Wednesday
       Thursday
       Friday
       Saturday
    }
    ...
    func isFunDay (dow DayNames) {
       &#x2F;&#x2F; This must fail to compile, because there is an unhandled enumeration
       switch {
          case Sunday: ...
          case Monday: ...
          case Tuesday: ...
          case Thursday: ...
          case Friday: ...
          case Saturday: ...
       }
       ...
    }
    ...
    isFunDay (0)   &#x2F;&#x2F; Compile failure
    var x int
    isFunDay (x)   &#x2F;&#x2F; Compile failure
</code></pre>
And I don&#x27;t see how that conflicts or overlaps with interfaces.</div><br/></div></div></div></div></div></div><div id="40217508" class="c"><input type="checkbox" id="c-40217508" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40216658">parent</a><span>|</span><a href="#40217005">prev</a><span>|</span><a href="#40218034">next</a><span>|</span><label class="collapse" for="c-40217508">[-]</label><label class="expand" for="c-40217508">[2 more]</label></div><br/><div class="children"><div class="content">Your comment could have been a nice opinion that proves to a drive-by reader that needs can differ drastically between programmers.<p>But you ruined it with &quot;fancy things&quot; which shows offhand disregard and disrespect.<p>A question like &quot;what do you need these features for?&quot; would have been a better contribution to the forum.</div><br/><div id="40219735" class="c"><input type="checkbox" id="c-40219735" checked=""/><div class="controls bullet"><span class="by">jurschreuder</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217508">parent</a><span>|</span><a href="#40218034">next</a><span>|</span><label class="collapse" for="c-40219735">[-]</label><label class="expand" for="c-40219735">[1 more]</label></div><br/><div class="children"><div class="content">I actually really have a disrespect for them. I&#x27;m in a constant fight against developers that want to translate code in almost the same code but &quot;only using language features from the Advanced book&quot;.<p>I also wanted to add that I used inheritance only ONCE in all my years of writing Python in all other millions of lines of code inheritance was not the best solution.<p>This is my daily struggle as a CTO. People using waaayy too many &quot;fancy&quot; features of languages making it totally unreadable and unmaintainable.<p>It&#x27;s their ego they want to show off how many complex language features they know. And it&#x27;s ruining my codebases.</div><br/></div></div></div></div></div></div></div></div><div id="40217033" class="c"><input type="checkbox" id="c-40217033" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40212796">parent</a><span>|</span><a href="#40216208">prev</a><span>|</span><a href="#40218648">next</a><span>|</span><label class="collapse" for="c-40217033">[-]</label><label class="expand" for="c-40217033">[8 more]</label></div><br/><div class="children"><div class="content">While I have no particular beef with Rust deciding to call its sum types &quot;enum&quot;, to refer to this as the <i>actual</i> enum is a bit much.<p>Enumerated types are simply named integers in most languages, exactly the sort you get with const &#x2F; iota in Go: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Enumerated_type" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Enumerated_type</a><p>Rather than the tagged union which the word represents in Rust, and only Rust. Java&#x27;s enums are close, since they&#x27;re classes and one can add arbitrary behaviors and extra data associated with the enum.</div><br/><div id="40217109" class="c"><input type="checkbox" id="c-40217109" checked=""/><div class="controls bullet"><span class="by">gr4vityWall</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217033">parent</a><span>|</span><a href="#40218367">next</a><span>|</span><label class="collapse" for="c-40217109">[-]</label><label class="expand" for="c-40217109">[6 more]</label></div><br/><div class="children"><div class="content">Haxe also has Enums which are Generalized Algebraic Data Types, and they are called &quot;enums&quot; there as well: <a href="https:&#x2F;&#x2F;haxe.org&#x2F;manual&#x2F;types-enum-using.html" rel="nofollow">https:&#x2F;&#x2F;haxe.org&#x2F;manual&#x2F;types-enum-using.html</a></div><br/><div id="40217291" class="c"><input type="checkbox" id="c-40217291" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217109">parent</a><span>|</span><a href="#40218367">next</a><span>|</span><label class="collapse" for="c-40217291">[-]</label><label class="expand" for="c-40217291">[5 more]</label></div><br/><div class="children"><div class="content">Very well then: Rust is not the only one to call a variant type &#x2F; tagged union an enum.  It&#x27;s a nice language feature to have, whatever they decide to call it.<p>It remains a strange choice to refer to this as the <i>true</i> enum, <i>actual</i> enum, <i>real</i> enum, as has started occurring since Rust became prominent.  If that&#x27;s a meaningful concept, it means a set of numeric values which may be referred to by name. This is the original definition and remains the most popular.</div><br/><div id="40219026" class="c"><input type="checkbox" id="c-40219026" checked=""/><div class="controls bullet"><span class="by">danielscrubs</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217291">parent</a><span>|</span><a href="#40218060">next</a><span>|</span><label class="collapse" for="c-40219026">[-]</label><label class="expand" for="c-40219026">[1 more]</label></div><br/><div class="children"><div class="content">Checked the definition. An enum is defined as a set of named constants. Id argue that a set by definition needs to be constrained. If it lacks the constraints&#x2F;grouping id argue it no longer is a set.</div><br/></div></div><div id="40218060" class="c"><input type="checkbox" id="c-40218060" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217291">parent</a><span>|</span><a href="#40219026">prev</a><span>|</span><a href="#40220188">next</a><span>|</span><label class="collapse" for="c-40218060">[-]</label><label class="expand" for="c-40218060">[2 more]</label></div><br/><div class="children"><div class="content">Rust is targeting both users who know the original definition as well as people who don’t. Differentiating between real enums and sum types means the language gets another keyword for a concept that overlaps.<p>From a PL theory perspective, enum denotes an enumerable set of values within a type. It just happens that sums slot in well enough with that.</div><br/><div id="40218774" class="c"><input type="checkbox" id="c-40218774" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40218060">parent</a><span>|</span><a href="#40220188">next</a><span>|</span><label class="collapse" for="c-40218774">[-]</label><label class="expand" for="c-40218774">[1 more]</label></div><br/><div class="children"><div class="content">But the instances of a sum type aren&#x27;t enumerable unless all of its generic parameters are enumerable.</div><br/></div></div></div></div></div></div></div></div><div id="40218367" class="c"><input type="checkbox" id="c-40218367" checked=""/><div class="controls bullet"><span class="by">turdprincess</span><span>|</span><a href="#40212796">root</a><span>|</span><a href="#40217033">parent</a><span>|</span><a href="#40217109">prev</a><span>|</span><a href="#40218648">next</a><span>|</span><label class="collapse" for="c-40218367">[-]</label><label class="expand" for="c-40218367">[1 more]</label></div><br/><div class="children"><div class="content">Swift enums support union types as well, and are also very useful.</div><br/></div></div></div></div></div></div><div id="40218648" class="c"><input type="checkbox" id="c-40218648" checked=""/><div class="controls bullet"><span class="by">Hasnep</span><span>|</span><a href="#40212796">prev</a><span>|</span><a href="#40220880">next</a><span>|</span><label class="collapse" for="c-40218648">[-]</label><label class="expand" for="c-40218648">[1 more]</label></div><br/><div class="children"><div class="content">About a year ago, I tried writing a language that transpiled to Go with many of the same features, in my research I found other attempts at the same idea:<p>- braid: <a href="https:&#x2F;&#x2F;github.com&#x2F;joshsharp&#x2F;braid">https:&#x2F;&#x2F;github.com&#x2F;joshsharp&#x2F;braid</a><p>- have: <a href="https:&#x2F;&#x2F;github.com&#x2F;vrok&#x2F;have">https:&#x2F;&#x2F;github.com&#x2F;vrok&#x2F;have</a><p>- oden: <a href="https:&#x2F;&#x2F;oden-lang.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;oden-lang.github.io&#x2F;</a></div><br/></div></div><div id="40220880" class="c"><input type="checkbox" id="c-40220880" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#40218648">prev</a><span>|</span><a href="#40220218">next</a><span>|</span><label class="collapse" for="c-40220880">[-]</label><label class="expand" for="c-40220880">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone written a language which targets golang assembler yet?  I’m surprised I don’t see that.</div><br/></div></div><div id="40220218" class="c"><input type="checkbox" id="c-40220218" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#40220880">prev</a><span>|</span><a href="#40212961">next</a><span>|</span><label class="collapse" for="c-40220218">[-]</label><label class="expand" for="c-40220218">[1 more]</label></div><br/><div class="children"><div class="content">I am genuinely appreciative that a post like this, a GitHub link to a semi-slow moving, but clearly well considered and sincerely developed programming language, can not only remain on the front page of HN, but can generate a diverse and interesting group of discussions. It’s material like this that keeps me coming back to the site. I’m not sure if anyone needed this comment, but I’m sure my posting it isn’t going to hurt.</div><br/></div></div><div id="40212961" class="c"><input type="checkbox" id="c-40212961" checked=""/><div class="controls bullet"><span class="by">ralegh</span><span>|</span><a href="#40220218">prev</a><span>|</span><a href="#40214490">next</a><span>|</span><label class="collapse" for="c-40212961">[-]</label><label class="expand" for="c-40212961">[11 more]</label></div><br/><div class="children"><div class="content">Great! Something I&#x27;ve always wanted.<p>I&#x27;d love to be able to use a bit more type-y Go such as Borgo, and have a Pythonesque dynamic scripting language that latches onto it effortlessly.<p>Dynamic typing is great for exploratory work, whether that&#x27;s ML research or developing new features for a web app. But it would be great to be able to morph it over time into a more specified strongly typed language without having to refactor loads of stuff.<p>Like building out of clay and firing the parts you are happy with.<p>Could even have a three step - Python-esque -&gt; Go&#x2F;Java-esque -&gt; Rust&#x2F;C++esque.</div><br/><div id="40213383" class="c"><input type="checkbox" id="c-40213383" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#40212961">parent</a><span>|</span><a href="#40215572">next</a><span>|</span><label class="collapse" for="c-40213383">[-]</label><label class="expand" for="c-40213383">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Like building out of clay and firing the parts you are happy with.
&gt; Could even have a three step - Python-esque -&gt; Go&#x2F;Java-esque -&gt; Rust&#x2F;C++esque.<p>We do exactly that with Common Lisp. It compiles to different languages&#x2F;frameworks depending on what we require (usually sbcl is more than enough, but for instance for embedded or ML we need another step. All dev (with smaller data etc) is in sbcl so with all the advantages.</div><br/><div id="40213604" class="c"><input type="checkbox" id="c-40213604" checked=""/><div class="controls bullet"><span class="by">ralegh</span><span>|</span><a href="#40212961">root</a><span>|</span><a href="#40213383">parent</a><span>|</span><a href="#40215572">next</a><span>|</span><label class="collapse" for="c-40213604">[-]</label><label class="expand" for="c-40213604">[1 more]</label></div><br/><div class="children"><div class="content">Is there somewhere I could read more about this? I&#x27;ve always wanted to learn Lisp but lacked a specific need for it.</div><br/></div></div></div></div><div id="40215572" class="c"><input type="checkbox" id="c-40215572" checked=""/><div class="controls bullet"><span class="by">claudionaoto</span><span>|</span><a href="#40212961">parent</a><span>|</span><a href="#40213383">prev</a><span>|</span><a href="#40213362">next</a><span>|</span><label class="collapse" for="c-40215572">[-]</label><label class="expand" for="c-40215572">[1 more]</label></div><br/><div class="children"><div class="content">Dart? Version 1 was a lot like Javascript&#x2F;Typescript in one spec (a dynamic language with optional unsound typing). Version 2 uses sound typing, but you can still let variables unannoted (and the compiler will infer type &quot;dynamic&quot;) for scripts.</div><br/></div></div><div id="40213362" class="c"><input type="checkbox" id="c-40213362" checked=""/><div class="controls bullet"><span class="by">mattlondon</span><span>|</span><a href="#40212961">parent</a><span>|</span><a href="#40215572">prev</a><span>|</span><a href="#40219196">next</a><span>|</span><label class="collapse" for="c-40213362">[-]</label><label class="expand" for="c-40213362">[3 more]</label></div><br/><div class="children"><div class="content">Sounds like JavaScript and typescript would be a good fit for you.  Highly expressive, dynamic and strongly typed, and highly performant both on server side and within the browser.</div><br/><div id="40213529" class="c"><input type="checkbox" id="c-40213529" checked=""/><div class="controls bullet"><span class="by">ralegh</span><span>|</span><a href="#40212961">root</a><span>|</span><a href="#40213362">parent</a><span>|</span><a href="#40215083">next</a><span>|</span><label class="collapse" for="c-40213529">[-]</label><label class="expand" for="c-40213529">[1 more]</label></div><br/><div class="children"><div class="content">I do like JavaScript but it strikes a weird balance for me where it&#x27;s a bit too easy to write and a bit too verbose so I tend to end up with hard to maintain code. Feels good at the start of a project but rarely a few weeks in. Also not a fan of the node ecosystem, I try to use deno where I can (maybe that would be bun these days).</div><br/></div></div><div id="40215083" class="c"><input type="checkbox" id="c-40215083" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#40212961">root</a><span>|</span><a href="#40213362">parent</a><span>|</span><a href="#40213529">prev</a><span>|</span><a href="#40219196">next</a><span>|</span><label class="collapse" for="c-40215083">[-]</label><label class="expand" for="c-40215083">[1 more]</label></div><br/><div class="children"><div class="content">perhaps rescript [<a href="https:&#x2F;&#x2F;rescript-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rescript-lang.org&#x2F;</a>] even more than typescript</div><br/></div></div></div></div><div id="40219196" class="c"><input type="checkbox" id="c-40219196" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#40212961">parent</a><span>|</span><a href="#40213362">prev</a><span>|</span><a href="#40213392">next</a><span>|</span><label class="collapse" for="c-40219196">[-]</label><label class="expand" for="c-40219196">[1 more]</label></div><br/><div class="children"><div class="content">py2many does python-esque to both Go and Rust.<p>The larger problem is building an ecosystem and a stdlib that&#x27;s written in python, not C. Use ffi or similar instead of C-API.</div><br/></div></div><div id="40213392" class="c"><input type="checkbox" id="c-40213392" checked=""/><div class="controls bullet"><span class="by">VBprogrammer</span><span>|</span><a href="#40212961">parent</a><span>|</span><a href="#40219196">prev</a><span>|</span><a href="#40214490">next</a><span>|</span><label class="collapse" for="c-40213392">[-]</label><label class="expand" for="c-40213392">[3 more]</label></div><br/><div class="children"><div class="content">I like the idea but in all honesty I have difficulty imagining it working in practice. Once your python code is stable (i.e. You&#x27;ve worked out 99% of the bugs you might have caught earlier with strict type checking) would there be any incentive to go back and make the types more rigid or rigorous? Would there be a non-negligible chance of introducing bugs in that process?</div><br/><div id="40215123" class="c"><input type="checkbox" id="c-40215123" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#40212961">root</a><span>|</span><a href="#40213392">parent</a><span>|</span><a href="#40213479">next</a><span>|</span><label class="collapse" for="c-40215123">[-]</label><label class="expand" for="c-40215123">[1 more]</label></div><br/><div class="children"><div class="content">by the time you have your code in its final state (i.e. you&#x27;re done experimenting) and shaken out the bugs, your types <i>are</i> mostly static; they&#x27;re just implicitly so. adding annotations and a typechecker helps you maintain that state and catch the few places where type errors might still have slipped through despite all your tests (e.g. lesser-used code paths that need some rare combination of conditions to hit them all but will pass an unexpected type through the call chain when you do). it is very unlikely that you will introduce bugs at this point.</div><br/></div></div><div id="40213479" class="c"><input type="checkbox" id="c-40213479" checked=""/><div class="controls bullet"><span class="by">ralegh</span><span>|</span><a href="#40212961">root</a><span>|</span><a href="#40213392">parent</a><span>|</span><a href="#40215123">prev</a><span>|</span><a href="#40214490">next</a><span>|</span><label class="collapse" for="c-40213479">[-]</label><label class="expand" for="c-40213479">[1 more]</label></div><br/><div class="children"><div class="content">I agree it&#x27;s a bit of a pipe dream. I&#x27;m more thinking of performance here, e.g. web services using Django. You could start off in dynamic&#x2F;interpreted land and have a seamless transition to performant compiled land. Also lets you avoid premature optimisation since you can only optimise the hot paths.<p>Also types are self documenting to an extent. Could be helpful for a shared codebase. Again Python just now getting round to adding type definitions.<p>At the end of the day good tooling&#x2F;ecosystem and sheer developer hours is more important than what I&#x27;m suggesting but it would be nice anyway. I dream about cool programming languages but I stick to boring for work.</div><br/></div></div></div></div></div></div><div id="40214490" class="c"><input type="checkbox" id="c-40214490" checked=""/><div class="controls bullet"><span class="by">DerSaidin</span><span>|</span><a href="#40212961">prev</a><span>|</span><a href="#40212665">next</a><span>|</span><label class="collapse" for="c-40214490">[-]</label><label class="expand" for="c-40214490">[4 more]</label></div><br/><div class="children"><div class="content">I like the graph at the top of the readme as a summary.<p>The rest of the readme focuses on the delta between Go and Borgo. It doesn&#x27;t say much about the delta between Borgo and Rust.<p>I think the delta there is mainly no lifetimes&#x2F;ownership?</div><br/><div id="40215137" class="c"><input type="checkbox" id="c-40215137" checked=""/><div class="controls bullet"><span class="by">eximius</span><span>|</span><a href="#40214490">parent</a><span>|</span><a href="#40212665">next</a><span>|</span><label class="collapse" for="c-40215137">[-]</label><label class="expand" for="c-40215137">[3 more]</label></div><br/><div class="children"><div class="content">No traits, const generics, probably no turbofish equivalent for when inference struggles.</div><br/><div id="40215901" class="c"><input type="checkbox" id="c-40215901" checked=""/><div class="controls bullet"><span class="by">sushisource</span><span>|</span><a href="#40214490">root</a><span>|</span><a href="#40215137">parent</a><span>|</span><a href="#40212665">next</a><span>|</span><label class="collapse" for="c-40215901">[-]</label><label class="expand" for="c-40215901">[2 more]</label></div><br/><div class="children"><div class="content">Most importantly: Null pointers still exist (yes I know they technically exist in unsafe Rust, to head off any pedants)<p>Also: No `?` operator</div><br/><div id="40216205" class="c"><input type="checkbox" id="c-40216205" checked=""/><div class="controls bullet"><span class="by">jdknezek</span><span>|</span><a href="#40214490">root</a><span>|</span><a href="#40215901">parent</a><span>|</span><a href="#40212665">next</a><span>|</span><label class="collapse" for="c-40216205">[-]</label><label class="expand" for="c-40216205">[1 more]</label></div><br/><div class="children"><div class="content">There is a `?` operator: <a href="https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo?tab=readme-ov-file#error-handling-with--operator">https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo?tab=readme-ov-file#error...</a></div><br/></div></div></div></div></div></div></div></div><div id="40212665" class="c"><input type="checkbox" id="c-40212665" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#40214490">prev</a><span>|</span><a href="#40213108">next</a><span>|</span><label class="collapse" for="c-40212665">[-]</label><label class="expand" for="c-40212665">[1 more]</label></div><br/><div class="children"><div class="content">Go has an amazing runtime and tool ecosystem, but I’ve always missed a little bit more type safety (especially rust enums). Neat!</div><br/></div></div><div id="40213108" class="c"><input type="checkbox" id="c-40213108" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#40212665">prev</a><span>|</span><a href="#40214599">next</a><span>|</span><label class="collapse" for="c-40213108">[-]</label><label class="expand" for="c-40213108">[31 more]</label></div><br/><div class="children"><div class="content">This and pub&#x2F;private modifiers for structs instead of letter casing is all I&#x27;ve ever wanted.</div><br/><div id="40213585" class="c"><input type="checkbox" id="c-40213585" checked=""/><div class="controls bullet"><span class="by">odc</span><span>|</span><a href="#40213108">parent</a><span>|</span><a href="#40219047">next</a><span>|</span><label class="collapse" for="c-40213585">[-]</label><label class="expand" for="c-40213585">[29 more]</label></div><br/><div class="children"><div class="content">I love Go&#x27;s letter casing. It&#x27;s such a neat way to remove cruft.</div><br/><div id="40213876" class="c"><input type="checkbox" id="c-40213876" checked=""/><div class="controls bullet"><span class="by">phplovesong</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213585">parent</a><span>|</span><a href="#40215195">next</a><span>|</span><label class="collapse" for="c-40213876">[-]</label><label class="expand" for="c-40213876">[9 more]</label></div><br/><div class="children"><div class="content">It also adds cruft. Public struct members JSON usually needs to be converted to lowercase. Hence the stuct tags.</div><br/><div id="40214090" class="c"><input type="checkbox" id="c-40214090" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213876">parent</a><span>|</span><a href="#40214177">next</a><span>|</span><label class="collapse" for="c-40214090">[-]</label><label class="expand" for="c-40214090">[7 more]</label></div><br/><div class="children"><div class="content">JSON is just one tiny part of most programs, sitting on the edge where the program interacts with other programs; it doesn’t permeate the entire codebase.<p>Structure privacy, OTOH, does.  Count me in as someone who really enjoys the case-based approach.  It’s not the only one which could work, but it does work.</div><br/><div id="40214259" class="c"><input type="checkbox" id="c-40214259" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214090">parent</a><span>|</span><a href="#40214177">next</a><span>|</span><label class="collapse" for="c-40214259">[-]</label><label class="expand" for="c-40214259">[6 more]</label></div><br/><div class="children"><div class="content">The single most productive habit I picked up int the last few years is to always use exactly the same name for the same entity across source files, configs files, database entries, protocol fields, etc.</div><br/><div id="40216640" class="c"><input type="checkbox" id="c-40216640" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214259">parent</a><span>|</span><a href="#40214177">next</a><span>|</span><label class="collapse" for="c-40216640">[-]</label><label class="expand" for="c-40216640">[5 more]</label></div><br/><div class="children"><div class="content">That’s funny, I did it your way for years and ended up considering it a big mistake.<p>Today I use idiomatic names - MyName in Go, myName in JS&#x2F;JSON, my_name in SQL. There are many reasons but generally speaking, for me, it’s less effort and code is more readable.<p>Curious what your rationale is?</div><br/><div id="40220815" class="c"><input type="checkbox" id="c-40220815" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40216640">parent</a><span>|</span><a href="#40219001">next</a><span>|</span><label class="collapse" for="c-40220815">[-]</label><label class="expand" for="c-40220815">[1 more]</label></div><br/><div class="children"><div class="content">I have the benefit of writing mostly C++ where there is really no globally agreed idiomatic naming. At $JOB we use snake_case naming for C++ functions and objects (as opposed to types), which also matches the python naming convention we use.<p>Snake case is not idiomatic for xml, but we still happen to use it for leaf config options.<p>The main benefit is reducing ambiguity to what maps to what across files. Ease of grepability is also an advantage.</div><br/></div></div><div id="40219001" class="c"><input type="checkbox" id="c-40219001" checked=""/><div class="controls bullet"><span class="by">__float</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40216640">parent</a><span>|</span><a href="#40220815">prev</a><span>|</span><a href="#40214177">next</a><span>|</span><label class="collapse" for="c-40219001">[-]</label><label class="expand" for="c-40219001">[3 more]</label></div><br/><div class="children"><div class="content">I just ran into this earlier today - it makes navigating code with grep more difficult.<p>I had a YAML file using `some_property_name`, which was turned into `SomePropertyName`, and it&#x27;s a small annoyance. It&#x27;s not a huge deal, but it adds friction where some languages have none. (Or alternately, getting reordered in a separate system like `property_name_some`.)</div><br/><div id="40220690" class="c"><input type="checkbox" id="c-40220690" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40219001">parent</a><span>|</span><a href="#40220190">next</a><span>|</span><label class="collapse" for="c-40220690">[-]</label><label class="expand" for="c-40220690">[1 more]</label></div><br/><div class="children"><div class="content">Ease of grepping is one benefit, but for me the main benefit is the cognitive overhead when reading code.</div><br/></div></div><div id="40220190" class="c"><input type="checkbox" id="c-40220190" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40219001">parent</a><span>|</span><a href="#40220690">prev</a><span>|</span><a href="#40214177">next</a><span>|</span><label class="collapse" for="c-40220190">[-]</label><label class="expand" for="c-40220190">[1 more]</label></div><br/><div class="children"><div class="content">The issue that I ran into is dealing with lot of code across different languages, like plpgsql, go and JavaScript.<p>Especially with database code, something that&#x27;s fine in Go, like EmployeeID, ends up being employeeid in SQL. You can use underscores in Go but that can trigger other behaviours. If you mix your own JSON with JSON from other sources, you get inconsistent capitalisation. And so on.<p>And when you have hundreds or thousands of identifiers like this, it gets really hard to read.<p>You can of course capitalise in SQL - even though it&#x27;s not semantic - but that becomes inconsistent, too. And then of course the lifecycles of each of these things can be different, which adds another layer of complexity - maybe you refactor your Go code before you upgrade the database, so you end up with two identifiers anyway.<p>Ultimately I switched to using idiomatic names everywhere, and I really haven&#x27;t looked back. The boundaries between these systems tend to be pretty clear, as mentioned by someone else, so finding things shouldn&#x27;t be hard regardless of what they&#x27;re named.<p>It&#x27;s certainly takes slightly longer to deal with idiomatic names - but you read code way more than you write it, and it&#x27;s easier to read idiomatic code.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40214177" class="c"><input type="checkbox" id="c-40214177" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213876">parent</a><span>|</span><a href="#40214090">prev</a><span>|</span><a href="#40215195">next</a><span>|</span><label class="collapse" for="c-40214177">[-]</label><label class="expand" for="c-40214177">[1 more]</label></div><br/><div class="children"><div class="content">And database col name, and validation and...<p>The moment you integrate with a third party your US centre zip_code field is suddenly coming over the wire as postCode. The conversions are going to go on, at least in go I can define all of that conversion with ease in one place.</div><br/></div></div></div></div><div id="40215195" class="c"><input type="checkbox" id="c-40215195" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213585">parent</a><span>|</span><a href="#40213876">prev</a><span>|</span><a href="#40214324">next</a><span>|</span><label class="collapse" for="c-40215195">[-]</label><label class="expand" for="c-40215195">[6 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s semantic use of case is objectively bad because most of the worlds scripts do not have the concept of it. For example ideographs, as used in eastern countries, do not have capitalization. This means programmers in many parts of the world cannot express identifiers in their native tongue.</div><br/><div id="40215431" class="c"><input type="checkbox" id="c-40215431" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40215195">parent</a><span>|</span><a href="#40214324">next</a><span>|</span><label class="collapse" for="c-40215431">[-]</label><label class="expand" for="c-40215431">[5 more]</label></div><br/><div class="children"><div class="content">It looks like something was lost in the middle of your comment. You open with something about it be objectively bad, but then it jumps to something about how it is subjectively bad. What was omitted?</div><br/><div id="40216320" class="c"><input type="checkbox" id="c-40216320" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40215431">parent</a><span>|</span><a href="#40214324">next</a><span>|</span><label class="collapse" for="c-40216320">[-]</label><label class="expand" for="c-40216320">[4 more]</label></div><br/><div class="children"><div class="content">How is &quot;i cant name variables in my native language&quot; subjective?</div><br/><div id="40216740" class="c"><input type="checkbox" id="c-40216740" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40216320">parent</a><span>|</span><a href="#40218265">next</a><span>|</span><label class="collapse" for="c-40216740">[-]</label><label class="expand" for="c-40216740">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really think the sarcastic tone was called for, but the previous poster is right. &quot;I can&#x27;t name variables in my native language&quot; is objective, but whether or not that&#x27;s bad is subjective.</div><br/><div id="40219006" class="c"><input type="checkbox" id="c-40219006" checked=""/><div class="controls bullet"><span class="by">langnutty</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40216740">parent</a><span>|</span><a href="#40218265">next</a><span>|</span><label class="collapse" for="c-40219006">[-]</label><label class="expand" for="c-40219006">[1 more]</label></div><br/><div class="children"><div class="content">Very true but “bad” is <i>always</i> subjective so at least they came up with an evaluation that is binary — either you have capitalization in your language or you don’t, either the analogy fits or it doesn’t.<p>(Some linguist will point out that Bongo-Bongo has half-capitalization, or half has capitalization).</div><br/></div></div></div></div><div id="40218265" class="c"><input type="checkbox" id="c-40218265" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40216320">parent</a><span>|</span><a href="#40216740">prev</a><span>|</span><a href="#40214324">next</a><span>|</span><label class="collapse" for="c-40218265">[-]</label><label class="expand" for="c-40218265">[1 more]</label></div><br/><div class="children"><div class="content">True, as a non-native speaker: naming variables in a native language (that&#x27;s not English) is objectively bad.</div><br/></div></div></div></div></div></div></div></div><div id="40214324" class="c"><input type="checkbox" id="c-40214324" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213585">parent</a><span>|</span><a href="#40215195">prev</a><span>|</span><a href="#40213738">next</a><span>|</span><label class="collapse" for="c-40214324">[-]</label><label class="expand" for="c-40214324">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s such a neat way to remove cruft.<p>I don&#x27;t disagree,  the problem I have with it is,  I have to pay for that up front and have to factor it into my design immediately.  This also combines with the fact that the namespace is very flat with no heirarchy,  so,  choosing good public names is something I feel like I spend way too much time on.<p>Go is the only language that causes me to pull out a thesaurus when trying to name methods and struct members.  It&#x27;s kinda maddening.  Although,  after going through this exercise,  I end up with code that reads like English.  I just wish I could refactor my way into that state,  rather than having to try to nail it up front.</div><br/><div id="40219950" class="c"><input type="checkbox" id="c-40219950" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214324">parent</a><span>|</span><a href="#40218257">next</a><span>|</span><label class="collapse" for="c-40219950">[-]</label><label class="expand" for="c-40219950">[1 more]</label></div><br/><div class="children"><div class="content">ChatGPT is really good at suggesting 20 names for &lt;vague description of thing&gt;. Try it out!</div><br/></div></div><div id="40218257" class="c"><input type="checkbox" id="c-40218257" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214324">parent</a><span>|</span><a href="#40219950">prev</a><span>|</span><a href="#40215778">next</a><span>|</span><label class="collapse" for="c-40218257">[-]</label><label class="expand" for="c-40218257">[1 more]</label></div><br/><div class="children"><div class="content">Choosing names is something that often is in the bucket of oh I wish I had thought a little more before sharing these names.</div><br/></div></div><div id="40215778" class="c"><input type="checkbox" id="c-40215778" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214324">parent</a><span>|</span><a href="#40218257">prev</a><span>|</span><a href="#40213738">next</a><span>|</span><label class="collapse" for="c-40215778">[-]</label><label class="expand" for="c-40215778">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I just wish I could refactor my way into that state, rather than having to try to nail it up front.<p>Procrastination looms. :o</div><br/></div></div></div></div><div id="40213738" class="c"><input type="checkbox" id="c-40213738" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213585">parent</a><span>|</span><a href="#40214324">prev</a><span>|</span><a href="#40214129">next</a><span>|</span><label class="collapse" for="c-40213738">[-]</label><label class="expand" for="c-40213738">[3 more]</label></div><br/><div class="children"><div class="content">Dislike it very much specially with codebases which have lots of acronyms, aka aviation. Having to change an acronym from upper to lowercase just suck.</div><br/><div id="40213824" class="c"><input type="checkbox" id="c-40213824" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213738">parent</a><span>|</span><a href="#40214129">next</a><span>|</span><label class="collapse" for="c-40213824">[-]</label><label class="expand" for="c-40213824">[2 more]</label></div><br/><div class="children"><div class="content">In that case, maybe try: `_ACRNYM`</div><br/><div id="40213907" class="c"><input type="checkbox" id="c-40213907" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213824">parent</a><span>|</span><a href="#40214129">next</a><span>|</span><label class="collapse" for="c-40213907">[-]</label><label class="expand" for="c-40213907">[1 more]</label></div><br/><div class="children"><div class="content">Function names with _ ? That’s not for me :)</div><br/></div></div></div></div></div></div><div id="40214129" class="c"><input type="checkbox" id="c-40214129" checked=""/><div class="controls bullet"><span class="by">jjallen</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213585">parent</a><span>|</span><a href="#40213738">prev</a><span>|</span><a href="#40216595">next</a><span>|</span><label class="collapse" for="c-40214129">[-]</label><label class="expand" for="c-40214129">[5 more]</label></div><br/><div class="children"><div class="content">I spent quite a few hours tracking down bugs due to miscased struct fields unfortunately.  Strongly prefer explicitness over implicitness</div><br/><div id="40214345" class="c"><input type="checkbox" id="c-40214345" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214129">parent</a><span>|</span><a href="#40214174">next</a><span>|</span><label class="collapse" for="c-40214345">[-]</label><label class="expand" for="c-40214345">[2 more]</label></div><br/><div class="children"><div class="content">The casing rules are quite explicit and enforced by the compiler. A build would have immediately failed on whatever mismatch you had. A few hours and you didn&#x27;t even think to try compiling it?<p>I&#x27;m guessing you are talking about something else entirely, like, perhaps, decoding JSON into a struct using reflection and encountering a situation where the field names didn&#x27;t match? Indeed, implicitness can bite you there. That&#x27;s true in every language. But, then again, as you prefer explicitness why would you be using that approach in the first place?</div><br/><div id="40220245" class="c"><input type="checkbox" id="c-40220245" checked=""/><div class="controls bullet"><span class="by">jjallen</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214345">parent</a><span>|</span><a href="#40214174">next</a><span>|</span><label class="collapse" for="c-40220245">[-]</label><label class="expand" for="c-40220245">[1 more]</label></div><br/><div class="children"><div class="content">The rules are explicit but the actual changes in code are very small and unique to this language (or unique from the languages I had ever used). It’s one of those things that you can forget about — because it’s a small difference in code and arguably isn’t explicit.<p>I forget what it was, but basically my code wasn’t working the way I thought it should and it was solely due to a lowercased struct field. It happened twice where I spent at least a little while trying to figure it out.<p>And yeah I would guess that I tried to compile. Would be very dumb if I hadn’t although wouldn’t be the dumbest thing I’ve ever done</div><br/></div></div></div></div><div id="40214174" class="c"><input type="checkbox" id="c-40214174" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214129">parent</a><span>|</span><a href="#40214345">prev</a><span>|</span><a href="#40216595">next</a><span>|</span><label class="collapse" for="c-40214174">[-]</label><label class="expand" for="c-40214174">[2 more]</label></div><br/><div class="children"><div class="content">Which IDE do you use? Mine would flag this as an error pretty quickly.</div><br/><div id="40220466" class="c"><input type="checkbox" id="c-40220466" checked=""/><div class="controls bullet"><span class="by">jjallen</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40214174">parent</a><span>|</span><a href="#40216595">next</a><span>|</span><label class="collapse" for="c-40220466">[-]</label><label class="expand" for="c-40220466">[1 more]</label></div><br/><div class="children"><div class="content">Goland. How would an IDE know that you intended a struct field to be public or not?</div><br/></div></div></div></div></div></div><div id="40216595" class="c"><input type="checkbox" id="c-40216595" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40213108">root</a><span>|</span><a href="#40213585">parent</a><span>|</span><a href="#40214129">prev</a><span>|</span><a href="#40219047">next</a><span>|</span><label class="collapse" for="c-40216595">[-]</label><label class="expand" for="c-40216595">[1 more]</label></div><br/><div class="children"><div class="content">I like the terseness of it but having to refactor just because I change visibility is a bit stupid.<p>I never wrote ObjC but didn’t they use + and - (and nothing) as visibility modifiers?</div><br/></div></div></div></div><div id="40219047" class="c"><input type="checkbox" id="c-40219047" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#40213108">parent</a><span>|</span><a href="#40213585">prev</a><span>|</span><a href="#40214599">next</a><span>|</span><label class="collapse" for="c-40219047">[-]</label><label class="expand" for="c-40219047">[1 more]</label></div><br/><div class="children"><div class="content">Same. It&#x27;s ugly, it breaks acronyms, it doesn&#x27;t work in all (spoken) languages, it doesn&#x27;t work well with serialization, etc.<p>Frankly if they insisted on visibility being part of the name, I would have preferred they go with the age-old C++&#x2F;ancientPHP tradition of using a _ prefix for private members.</div><br/></div></div></div></div><div id="40214599" class="c"><input type="checkbox" id="c-40214599" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#40213108">prev</a><span>|</span><a href="#40213689">next</a><span>|</span><label class="collapse" for="c-40214599">[-]</label><label class="expand" for="c-40214599">[11 more]</label></div><br/><div class="children"><div class="content">I would kill for these languages features in Go</div><br/><div id="40215389" class="c"><input type="checkbox" id="c-40215389" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40214599">parent</a><span>|</span><a href="#40213689">next</a><span>|</span><label class="collapse" for="c-40215389">[-]</label><label class="expand" for="c-40215389">[10 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what C# offers (except <i>true</i>* Rust-style enums).<p>The latter will be there in one of the future versions and is in an active design phase, which luckily focuses on tagged-union implementation strategy.<p>With that said, you can already easily use one of the Option&#x2F;Result libraries or write your own structure - switching on either is trivial (though you have to sometimes choose between zero-cost-ness and convenience).<p>It already has struct generics, iterator expressions (LINQ), switch pattern matching, good C interop and easy concurrency primitives (no WaitGroup nonsense, also has Channel&lt;T&gt;). Oh, and also portable SIMD, C pointers and very strong performance in general.<p>* True as in proper tagged unions with either a tag or another type of discriminant and aliased layout, instead of tag + flattening all constituent parts into a one jumbo struct. Or making it an opaque pointer to a box (like Java does, or C# if you go inheritance&#x2F;interface route). These don&#x27;t count. I&#x27;m curious about Borgo&#x27;s lowering strategy for enums, but given Go doesn&#x27;t have those, I&#x27;m not holding my breath and expecting something like F# struct unions at best.</div><br/><div id="40215621" class="c"><input type="checkbox" id="c-40215621" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40215389">parent</a><span>|</span><a href="#40216848">next</a><span>|</span><label class="collapse" for="c-40215621">[-]</label><label class="expand" for="c-40215621">[7 more]</label></div><br/><div class="children"><div class="content">As someone who is &quot;C# curious,&quot; but haven&#x27;t been able to keep up with all the <i>horrific</i> number of rebrands of the &quot;new, open, .net, core, framework&quot;, what is the C# equivalent of $(for GOOS in linux darwin; do for GOARCH in amd64 arm64; do dotnet build -o thing_${GOOS}-${GOARCH}; done; done)?</div><br/><div id="40215823" class="c"><input type="checkbox" id="c-40215823" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40215621">parent</a><span>|</span><a href="#40215977">next</a><span>|</span><label class="collapse" for="c-40215823">[-]</label><label class="expand" for="c-40215823">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s spelled `dotnet publish -r ${GOOS}-${GOARCH}` with the new ahead-of-time (branded Native AOT) compilation features installed and enabled.<p>It isn&#x27;t without a whole list of caveats if you&#x27;re used to Go&#x27;s way of doing things though. See &lt;<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;deploying&#x2F;native-aot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;deploying&#x2F;nati...</a>&gt; for details.</div><br/><div id="40216103" class="c"><input type="checkbox" id="c-40216103" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40215823">parent</a><span>|</span><a href="#40215977">next</a><span>|</span><label class="collapse" for="c-40216103">[-]</label><label class="expand" for="c-40216103">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re very kind, thank you<p>For others wanting to play along at home:<p><pre><code>  $ docker run --name net8 --rm -it mcr.microsoft.com&#x2F;dotnet&#x2F;sdk:8.0-jammy-arm64v8 bash -c &#x27;
  cd &#x2F;root
  dotnet new -d -o console0 console
  cd console0
  dotnet publish --nologo --self-contained -v d -r osx-arm64 -o console0-darwin-arm64
  sleep 600
  &#x27;
</code></pre>
although it didn&#x27;t shake out<p><pre><code>  $ docker cp net8:&#x2F;root&#x2F;console0&#x2F;console0-darwin-arm64&#x2F;console0 .&#x2F;console0
  $ .&#x2F;console0
  Killed: 9
</code></pre>
I tried with and without --self-contained and the biggest difference was that self-contained emitted a bazillion .dll files and without just emitted the binary. I case the context isn&#x27;t obvious, $(dotnet new console) is a skeleton for the infamous WriteLine(&quot;Hello, World&quot;) without doing crazy whacko stuff</div><br/><div id="40216160" class="c"><input type="checkbox" id="c-40216160" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40216103">parent</a><span>|</span><a href="#40215977">next</a><span>|</span><label class="collapse" for="c-40216160">[-]</label><label class="expand" for="c-40216160">[3 more]</label></div><br/><div class="children"><div class="content">For simple JIT-based but fully self-contained binaries, without adding any properties to .csproj, the command is a bit mouthful and is as follows<p><pre><code>    dotnet publish -p:PublishSingleFile=true -p:PublishTrimmed=true -o {folder}
</code></pre>
(you can put -p: arguments in .csproj too as XML attrs in &lt;PropertyGroup&gt;...)<p>This will give you JIT-based &quot;trimmed&quot; binary (other languages call it tree shaking). You don&#x27;t need to specify RID explicitly unless it&#x27;s different from the one you are currently using.<p>For simple applications, publishing as AOT (without opting in the csproj for that) is<p><pre><code>    dotnet publish -p:PublishAot=true -o {folder}
</code></pre>
Add -p:OptimizationPreference=Speed and -p:IlcInstructionSet=native to taste.<p>Official docs: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;tools&#x2F;dotnet-publish#examples" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;tools&#x2F;dotnet-p...</a></div><br/><div id="40216272" class="c"><input type="checkbox" id="c-40216272" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40216160">parent</a><span>|</span><a href="#40215977">next</a><span>|</span><label class="collapse" for="c-40216272">[-]</label><label class="expand" for="c-40216272">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re also very kind, and I realized that it&#x27;s possible there were a bazillion &quot;watch out&quot;s on the docs and was just trying the &lt;PublishAot&gt;true trick when I saw your comment<p>However, it seems this brings my docker experiment to an abrupt halt, and is going to be some Holy Fucking Shit to re-implement that $(for GOOS) loop in any hypothetical CI system given the resulting explosion<p><pre><code>  &#x2F;usr&#x2F;bin&#x2F;sh: 2: &#x2F;tmp&#x2F;MSBuildTemproot&#x2F;tmp194e0a13157b47889b36abb0ce96cd2d.exec.cmd: xcodebuild: not found</code></pre></div><br/><div id="40216337" class="c"><input type="checkbox" id="c-40216337" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40216272">parent</a><span>|</span><a href="#40215977">next</a><span>|</span><label class="collapse" for="c-40216337">[-]</label><label class="expand" for="c-40216337">[1 more]</label></div><br/><div class="children"><div class="content">You need an OS for which you are building to be able to compile an AOT binary - it depends on OS-provided tooling (MSVC on Windows, Clang on macOS and Linux, and a system-provided linker from each respective system). In fact, once ILC is done compiling IL to .a or .lib, the native linker will just link together the csharp static lib, a GC, then runtime&#x2F;PAL&#x2F;misc and a couple of system dependencies into a final executable (you can also make a native library with this).<p>Cross-architecture compilation is, however, supported (but requires the same extra dependencies as e.g. Rust).<p>If you just want to publish for every target from a single docker container (you can&#x27;t easily do that with e.g. Rust as noted), then you can go with JIT+single-file using the other command.<p>Keep in mind that Go makes concessions in order for cross-compile to work, and invested extra engineering effort in that, while .NET makes emitting &quot;canonical&quot; native binaries using specific system environment a priority and also cares a lot about JIT instead (there aren&#x27;t <i>that</i> many people working on .NET compiler infrastructure, so it effectively punches above its weight bypassing Go and Java and matching C++ if optimized).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40215977" class="c"><input type="checkbox" id="c-40215977" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40215621">parent</a><span>|</span><a href="#40215823">prev</a><span>|</span><a href="#40216848">next</a><span>|</span><label class="collapse" for="c-40215977">[-]</label><label class="expand" for="c-40215977">[1 more]</label></div><br/><div class="children"><div class="content">The sibling comment pretty much sums it up. But if you want more detail, read on:<p>Generally, there are three publishing options that each make sense depending on scenario:<p>JIT + host runtime: by definition portable, includes slim launcher executable for convenience, the platform for which can be specified with e.g. -r osx-arm64[0].<p>JIT + self-contained runtime: this includes IL assemblies and runtime together, either within a single file or otherwise (so it looks like AOT, just one bin&#x2F;exe). This requires specifying RID, like in the previous option, for cross-compilation.<p>AOT: statically linked native binary, cross-<i>OS</i> compilation is not supported officially[1] because macOS is painful in general, and Windows&lt;-&gt;Linux&#x2F;FreeBSD is a configuration nightmare - IL AOT Compiler depends on Clang or MSVC and a native linker so it is subject to restrictions of those as a start. But it can be done and there are alternate, more focused toolchains, that offer it, like Bflat[1].<p>If you just want a hello world AOT application, then the shortest path to that is `dotnet new console --aot &amp;&amp; dotnet publish -o {folder}`. Otherwise, the options above are selected based on the needs either via build properties or CLI arguments. I don&#x27;t know which use case you have - let me know if you have something specific in mind (&quot;Just like in Go&quot; may or may not be optimal choice depending on scenario).<p>[0] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;rid-catalog" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;rid-catalog</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bflattened&#x2F;bflat">https:&#x2F;&#x2F;github.com&#x2F;bflattened&#x2F;bflat</a> (can also build UEFI binaries, lol)</div><br/></div></div></div></div><div id="40216848" class="c"><input type="checkbox" id="c-40216848" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40215389">parent</a><span>|</span><a href="#40215621">prev</a><span>|</span><a href="#40216585">next</a><span>|</span><label class="collapse" for="c-40216848">[-]</label><label class="expand" for="c-40216848">[1 more]</label></div><br/><div class="children"><div class="content">To clarify, my team uses Go and prefers to stick with &quot;idiomatic&quot; Go. So, while we could implement our own types, there would be pushback. As an example I liked lo [0] but my team was resistant because it&#x27;s not considered idomatic.<p>If were up to me we&#x27;d be using a language with a better type system :)<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;samber&#x2F;lo">https:&#x2F;&#x2F;github.com&#x2F;samber&#x2F;lo</a></div><br/></div></div><div id="40216585" class="c"><input type="checkbox" id="c-40216585" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#40214599">root</a><span>|</span><a href="#40215389">parent</a><span>|</span><a href="#40216848">prev</a><span>|</span><a href="#40213689">next</a><span>|</span><label class="collapse" for="c-40216585">[-]</label><label class="expand" for="c-40216585">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the best solution, but an analyzer like [0] covers most of the cases for reference types. For enums and struct DUs in general we&#x27;ll have to wait for language (or even runtime) support.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;shuebner&#x2F;ClosedTypeHierarchyDiagnosticSuppressor">https:&#x2F;&#x2F;github.com&#x2F;shuebner&#x2F;ClosedTypeHierarchyDiagnosticSup...</a></div><br/></div></div></div></div></div></div><div id="40213689" class="c"><input type="checkbox" id="c-40213689" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#40214599">prev</a><span>|</span><a href="#40212770">next</a><span>|</span><label class="collapse" for="c-40213689">[-]</label><label class="expand" for="c-40213689">[5 more]</label></div><br/><div class="children"><div class="content">This seems to achieve a similar type safety&lt;-&gt;complexity tradeoff as Gleam [1] does. However, Gleam compiles to Erlang or JavaScript, which require a runtime and are not as performant as Go.<p>I wonder if Borgo&#x27;s compiler messages are as nice as Rust&#x27;s&#x2F;Gleam&#x27;s, though.<p>[1] <a href="https:&#x2F;&#x2F;gleam.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gleam.run&#x2F;</a></div><br/><div id="40214025" class="c"><input type="checkbox" id="c-40214025" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40213689">parent</a><span>|</span><a href="#40212770">next</a><span>|</span><label class="collapse" for="c-40214025">[-]</label><label class="expand" for="c-40214025">[4 more]</label></div><br/><div class="children"><div class="content">&gt; are not as performant as Go.<p>Ymmv, you might be surprised if you actually bothered to benchmark. Depending on the workload, either JS or erlang can ultimately turn out on top.<p>They&#x27;re all optimized to a degree that each has a niche it excells at and leaves the others in the dust.<p>even with heavily scewed benchmark like techempower fortunes (<a href="https:&#x2F;&#x2F;www.techempower.com&#x2F;benchmarks&#x2F;#hw=ph&amp;test=fortune&amp;section=data-r22" rel="nofollow">https:&#x2F;&#x2F;www.techempower.com&#x2F;benchmarks&#x2F;#hw=ph&amp;test=fortune&amp;s...</a>) you end up with JS getting ahead of Go with raw requests. And not just slightly, but by 1.5 times the throughput.<p>In other benchmarks, Golang does indeed win out with similar or even bigger advantages... so the only thing you can ultimately say is ... that it depends. Its a different story if you chose other languages though. But JS, Golang and Erlang are all <i>extremely</i> optimized for their ideal usecase.</div><br/><div id="40216417" class="c"><input type="checkbox" id="c-40216417" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#40213689">root</a><span>|</span><a href="#40214025">parent</a><span>|</span><a href="#40214460">next</a><span>|</span><label class="collapse" for="c-40216417">[-]</label><label class="expand" for="c-40216417">[2 more]</label></div><br/><div class="children"><div class="content">Well hold on a second. The JS impl that you&#x27;re talking about uses a minimal custom runtime (<a href="https:&#x2F;&#x2F;github.com&#x2F;just-js&#x2F;just">https:&#x2F;&#x2F;github.com&#x2F;just-js&#x2F;just</a>) that you would never use—it barely implements JS. It&#x27;s basically only used for this benchmark. It doesn&#x27;t make sense to compare that to Go when we&#x27;re talking about Javascript vs. Go performance.<p>Scroll down to the &quot;nodejs&quot; entry for a more realistic comparison.</div><br/><div id="40219343" class="c"><input type="checkbox" id="c-40219343" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40213689">root</a><span>|</span><a href="#40216417">parent</a><span>|</span><a href="#40214460">next</a><span>|</span><label class="collapse" for="c-40219343">[-]</label><label class="expand" for="c-40219343">[1 more]</label></div><br/><div class="children"><div class="content">Feel free to switch to json serialization and the the same pattern repeat with uwebsockets.js.<p>I&#x27;m not saying that JS is &quot;just as fast as golang&quot; generally. My argument is specifically that it&#x27;s optimized to a degree that there are cases in which JS, an interpreted language, does end up on top.<p>The same applies to erlang and it&#x27;s optimization for efficient concurrency.<p>On average you&#x27;ll likely get better performance with go, but depending on the workload the results can differ</div><br/></div></div></div></div><div id="40214460" class="c"><input type="checkbox" id="c-40214460" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40213689">root</a><span>|</span><a href="#40214025">parent</a><span>|</span><a href="#40216417">prev</a><span>|</span><a href="#40212770">next</a><span>|</span><label class="collapse" for="c-40214460">[-]</label><label class="expand" for="c-40214460">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add Java to that list as well. JIT compilers have come a long way, and OpenJDK was on par with Rust for performance on the last project I tried porting.</div><br/></div></div></div></div></div></div><div id="40212770" class="c"><input type="checkbox" id="c-40212770" checked=""/><div class="controls bullet"><span class="by">eximius</span><span>|</span><a href="#40213689">prev</a><span>|</span><a href="#40220863">next</a><span>|</span><label class="collapse" for="c-40212770">[-]</label><label class="expand" for="c-40212770">[1 more]</label></div><br/><div class="children"><div class="content">Be still my heart. I would use this so fast at work where we currently use Go.<p>But introducing a new language is a scary thing.</div><br/></div></div><div id="40220863" class="c"><input type="checkbox" id="c-40220863" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40212770">prev</a><span>|</span><a href="#40219688">next</a><span>|</span><label class="collapse" for="c-40220863">[-]</label><label class="expand" for="c-40220863">[1 more]</label></div><br/><div class="children"><div class="content">No exceptions - no love.</div><br/></div></div><div id="40219688" class="c"><input type="checkbox" id="c-40219688" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#40220863">prev</a><span>|</span><a href="#40212684">next</a><span>|</span><label class="collapse" for="c-40219688">[-]</label><label class="expand" for="c-40219688">[1 more]</label></div><br/><div class="children"><div class="content">In the same vein, Go+ is also interesting,  and its being actively developed.<p><a href="https:&#x2F;&#x2F;goplus.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;goplus.org&#x2F;</a></div><br/></div></div><div id="40212684" class="c"><input type="checkbox" id="c-40212684" checked=""/><div class="controls bullet"><span class="by">Qerub</span><span>|</span><a href="#40219688">prev</a><span>|</span><a href="#40218686">next</a><span>|</span><label class="collapse" for="c-40212684">[-]</label><label class="expand" for="c-40212684">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of this previous effort to build upon Go but add a more flexible type system: <a href="https:&#x2F;&#x2F;github.com&#x2F;oden-lang&#x2F;oden">https:&#x2F;&#x2F;github.com&#x2F;oden-lang&#x2F;oden</a></div><br/></div></div><div id="40218686" class="c"><input type="checkbox" id="c-40218686" checked=""/><div class="controls bullet"><span class="by">owenpalmer</span><span>|</span><a href="#40212684">prev</a><span>|</span><a href="#40212673">next</a><span>|</span><label class="collapse" for="c-40218686">[-]</label><label class="expand" for="c-40218686">[3 more]</label></div><br/><div class="children"><div class="content">This looks like an interesting sweet spot. Rust is often praised for the borrow checker, but honestly I really only like rust for the type system and error handling. Go is praised for it&#x27;s simplicity, but hated for it&#x27;s error handling.</div><br/><div id="40219452" class="c"><input type="checkbox" id="c-40219452" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40218686">parent</a><span>|</span><a href="#40212673">next</a><span>|</span><label class="collapse" for="c-40219452">[-]</label><label class="expand" for="c-40219452">[2 more]</label></div><br/><div class="children"><div class="content">Rust without borrow checker is much less feasible than Go with Result&#x2F;Option types to address the nil overdose problem. Unfortunately Go team refuses to acknowledge the common themes coming out of years of user complaints. They don&#x27;t have to cater to every wishlist but when nil&#x2F;enum related complaints are the majority in every discussion about issues with Go, one would think to acknowledge the legitimacy of those shortcomings. Nope, not Go team and their band of simplicity zealots.</div><br/><div id="40220556" class="c"><input type="checkbox" id="c-40220556" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40218686">root</a><span>|</span><a href="#40219452">parent</a><span>|</span><a href="#40212673">next</a><span>|</span><label class="collapse" for="c-40220556">[-]</label><label class="expand" for="c-40220556">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what exactly you mean by acknowledgement, but here are some counterexamples:<p>- A proposal for sum types by a Go team member: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57644">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57644</a><p>- The community proposal with some comments from the Go team: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;19412">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;19412</a><p>Here are some excerpts from the latest Go survey [1]:<p>- &quot;The top responses in the closed-form were learning how to write Go effectively (15%) and the verbosity of error handling (13%).&quot;<p>- &quot;The most common response mentioned Go’s type system, and often asked specifically for enums, option types, or sum types in Go.&quot;<p>I think the problem is not the lack of will on the part of the Go team, but rather that these issues are not easy to fix in a way that fits the language and doesn&#x27;t cause too many issues with backwards compatibility.<p>[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;survey2024-h1-results" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;survey2024-h1-results</a></div><br/></div></div></div></div></div></div><div id="40212673" class="c"><input type="checkbox" id="c-40212673" checked=""/><div class="controls bullet"><span class="by">templaedhel</span><span>|</span><a href="#40218686">prev</a><span>|</span><a href="#40212499">next</a><span>|</span><label class="collapse" for="c-40212673">[-]</label><label class="expand" for="c-40212673">[3 more]</label></div><br/><div class="children"><div class="content">They made a coffeescript for go</div><br/><div id="40212779" class="c"><input type="checkbox" id="c-40212779" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#40212673">parent</a><span>|</span><a href="#40212499">next</a><span>|</span><label class="collapse" for="c-40212779">[-]</label><label class="expand" for="c-40212779">[2 more]</label></div><br/><div class="children"><div class="content">They made a Typescript for go. Coffeescript was dynamic.</div><br/><div id="40213144" class="c"><input type="checkbox" id="c-40213144" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40212673">root</a><span>|</span><a href="#40212779">parent</a><span>|</span><a href="#40212499">next</a><span>|</span><label class="collapse" for="c-40213144">[-]</label><label class="expand" for="c-40213144">[1 more]</label></div><br/><div class="children"><div class="content">Coffeescript added semantics and behavior.  Typescript for better or worse is <i>almost</i> only types on top of existing behavior.  (with the primary exception being the `enum` concept)</div><br/></div></div></div></div></div></div><div id="40212499" class="c"><input type="checkbox" id="c-40212499" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40212673">prev</a><span>|</span><a href="#40218983">next</a><span>|</span><label class="collapse" for="c-40212499">[-]</label><label class="expand" for="c-40212499">[48 more]</label></div><br/><div class="children"><div class="content">Is it correct to say Borgo &quot;compiles to Go&quot;, or should it say &quot;transpiles to Go&quot;<p>It appears to be a transpiler (consumes a Borgo and does the work to convert and emit a Go program as text):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo&#x2F;blob&#x2F;main&#x2F;compiler&#x2F;src&#x2F;codegen.rs">https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo&#x2F;blob&#x2F;main&#x2F;compiler&#x2F;src&#x2F;c...</a></div><br/><div id="40212642" class="c"><input type="checkbox" id="c-40212642" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40212499">parent</a><span>|</span><a href="#40212528">next</a><span>|</span><label class="collapse" for="c-40212642">[-]</label><label class="expand" for="c-40212642">[34 more]</label></div><br/><div class="children"><div class="content">The word &quot;transpiler&quot; propagates the misunderstanding that there is something special about a compiler that emits machine code, that requires some special &quot;compiler&quot; techniques for special &quot;compiler&quot; purposes that are not necessary for &quot;transpiler&quot; purposes because &quot;transpiling&quot; requires a completely different set of techniques.<p>There aren&#x27;t any such techniques. If one were to create an academic discipline to study &quot;transpilers&quot; and one to study &quot;compilers&quot;, all you&#x27;d end up with is an identical bunch of techniques and analyses with different names on them. (A thing that sometimes happens when diverse disciplines study what turns out to be the same thing; see machine learning versus statistics for a well-known example.)<p>Even &quot;compiling&quot; to machine code isn&#x27;t special anymore, because CPUs don&#x27;t actually execute assembly anymore. They themselves compile assembly into internal micro-ops, which is what they actually execute. So compilers don&#x27;t even compile &quot;machine language&quot; anymore; it&#x27;s just another target. This also dodges &quot;is it a &#x27;compiler&#x27; or a &#x27;transpiler&#x27; if it targets WASM?&quot;, which is good, because there is no value in that question on any level.</div><br/><div id="40213168" class="c"><input type="checkbox" id="c-40213168" checked=""/><div class="controls bullet"><span class="by">Matheus28</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212642">parent</a><span>|</span><a href="#40212737">next</a><span>|</span><label class="collapse" for="c-40213168">[-]</label><label class="expand" for="c-40213168">[9 more]</label></div><br/><div class="children"><div class="content">1. Transpilers output to another programming language that is typically written by hand by others (so not assembly).<p>2. Transpilers don’t typically optimize code, leaving those transformations to the compiler of the target language.<p>3. Compilers will typically have an internal representation (SSA) which they operate on to optimize. Transpilers typically operate on the AST (because they don’t need to do any but the most trivial optimizations).<p>There are exceptions to the rules but these cover the majority of the reasons on why people make the distinction.</div><br/><div id="40214671" class="c"><input type="checkbox" id="c-40214671" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213168">parent</a><span>|</span><a href="#40214221">next</a><span>|</span><label class="collapse" for="c-40214671">[-]</label><label class="expand" for="c-40214671">[1 more]</label></div><br/><div class="children"><div class="content">These differences aren&#x27;t inherent to transpilers vs compilers, they&#x27;re mostly the result of the fact that the vast majority of transpilers are less mature than the battle-tested compilers that you&#x27;re thinking of.<p>The average hobby compiler—regardless of target—doesn&#x27;t optimize code and works directly on the AST because that&#x27;s simple to get started with. Most hobby compilers <i>also</i> target some other language rather than LLVM or machine code because that&#x27;s simple to get started with, so the result is that most transpilers are hobby projects that don&#x27;t optimize. But there&#x27;s no reason why a transpiler <i>shouldn&#x27;t</i> include optimization steps that adapt the output to use code paths that are known to be fast, and a production-grade transpiler typically will include these steps.</div><br/></div></div><div id="40214221" class="c"><input type="checkbox" id="c-40214221" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213168">parent</a><span>|</span><a href="#40214671">prev</a><span>|</span><a href="#40212737">next</a><span>|</span><label class="collapse" for="c-40214221">[-]</label><label class="expand" for="c-40214221">[7 more]</label></div><br/><div class="children"><div class="content"><i>&gt; the majority of the reasons on why people make the distinction.</i><p>You have provided some defining properties that might allow for distinction, but you have not given any reasons for <i>why</i> people make a distinction.<p>But perhaps we can suss it out. Given the statement &quot;Borgo compiles to Go&quot;, what important information is lost that would be saved if &quot;Borgo transpiles to Go&quot; was used instead?</div><br/><div id="40215953" class="c"><input type="checkbox" id="c-40215953" checked=""/><div class="controls bullet"><span class="by">Matheus28</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40214221">parent</a><span>|</span><a href="#40212737">next</a><span>|</span><label class="collapse" for="c-40215953">[-]</label><label class="expand" for="c-40215953">[6 more]</label></div><br/><div class="children"><div class="content">In that statement, it doesn&#x27;t really add anything.<p>In the statement &quot;XYZ is a compiler&#x2F;transpiler&quot;, it does. It doesn&#x27;t hurt to have a word that is more specific than others. Otherwise we should just refer to compilers as an &quot;app&quot; :)</div><br/><div id="40216082" class="c"><input type="checkbox" id="c-40216082" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40215953">parent</a><span>|</span><a href="#40216753">next</a><span>|</span><label class="collapse" for="c-40216082">[-]</label><label class="expand" for="c-40216082">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone here is saying we shouldn&#x27;t have the word &quot;transpiler&quot; at all, just that &quot;transpiler&quot; is a subcategory of &quot;compiler&quot; and there&#x27;s no reason for OP to try to correct the title of this story.<p>It reminds me of how my 5-year-old son always corrects me when I tell him to get in the car—&quot;you mean the van!&quot;. I have tried to explain to him that a minivan is a kind of car, and he&#x27;s just about getting it, but it&#x27;s been a challenge for him to grasp.</div><br/><div id="40216120" class="c"><input type="checkbox" id="c-40216120" checked=""/><div class="controls bullet"><span class="by">Matheus28</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40216082">parent</a><span>|</span><a href="#40217381">next</a><span>|</span><label class="collapse" for="c-40216120">[-]</label><label class="expand" for="c-40216120">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I don&#x27;t think anyone here is saying we shouldn&#x27;t have the word &quot;transpiler&quot; at all<p>This thread chain is in response to jerf&#x27;s comment &quot;transpiler shouldn&#x27;t be a word&quot; (simplifying his comment for brevity&#x27;s sake)</div><br/><div id="40216185" class="c"><input type="checkbox" id="c-40216185" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40216120">parent</a><span>|</span><a href="#40217381">next</a><span>|</span><label class="collapse" for="c-40216185">[-]</label><label class="expand" for="c-40216185">[1 more]</label></div><br/><div class="children"><div class="content">Eh, that&#x27;s one possible reading, but their actual take is more nuanced than that:<p>&gt; The word &quot;transpiler&quot; propagates the misunderstanding that there is something special about a compiler that emits machine code, that requires some special &quot;compiler&quot; techniques for special &quot;compiler&quot; purposes that are not necessary for &quot;transpiler&quot; purposes because &quot;transpiling&quot; requires a completely different set of techniques.<p>In context of the parent comment I read this to be a reaction to someone insisting that we use &quot;transpiler&quot; instead of &quot;compiler&quot;—more an observation of what is happening here than a call to stop using the word altogether.</div><br/></div></div></div></div><div id="40217381" class="c"><input type="checkbox" id="c-40217381" checked=""/><div class="controls bullet"><span class="by">gergo_barany</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40216082">parent</a><span>|</span><a href="#40216120">prev</a><span>|</span><a href="#40216753">next</a><span>|</span><label class="collapse" for="c-40217381">[-]</label><label class="expand" for="c-40217381">[1 more]</label></div><br/><div class="children"><div class="content">We shouldn&#x27;t have the word &quot;transpiler&quot; at all.</div><br/></div></div></div></div><div id="40216753" class="c"><input type="checkbox" id="c-40216753" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40215953">parent</a><span>|</span><a href="#40216082">prev</a><span>|</span><a href="#40212737">next</a><span>|</span><label class="collapse" for="c-40216753">[-]</label><label class="expand" for="c-40216753">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; In the statement &quot;XYZ is a compiler&#x2F;transpiler&quot;, it does.</i><p>Okay. What important information is lost in &quot;XYZ is a compiler&quot; that would be gained in &quot;XYZ is a transpiler&quot;?<p><i>&gt; It doesn&#x27;t hurt to have a word that is more specific than others.</i><p>It can if the intent is not properly understood. And so far I&#x27;m not sure we do have that understanding.</div><br/></div></div></div></div></div></div></div></div><div id="40212737" class="c"><input type="checkbox" id="c-40212737" checked=""/><div class="controls bullet"><span class="by">markusde</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212642">parent</a><span>|</span><a href="#40213168">prev</a><span>|</span><a href="#40214031">next</a><span>|</span><label class="collapse" for="c-40212737">[-]</label><label class="expand" for="c-40212737">[22 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter but I fully disagree with this. A transpiler emits code the user is supposed to understand, a compiler does not. At least that&#x27;s the general way I&#x27;ve seen the term used, and it seems quite consistent.</div><br/><div id="40213161" class="c"><input type="checkbox" id="c-40213161" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40213041">next</a><span>|</span><label class="collapse" for="c-40213161">[-]</label><label class="expand" for="c-40213161">[5 more]</label></div><br/><div class="children"><div class="content">There is a phenomenon I have observed many times where you can get a bunch of people in a room and make some statement, in this case, &quot;Compilers are different than transpilers&quot;, and everyone around the table will nod sagely. Yup. We all agree with this statement.<p>But if you dig in, it will turn out that <i>every single one of them</i> has a different interpretation, quite often fatally so to whatever the task at hand is.<p>I mention this because my impression has been that the distinction between &quot;transpiler&quot; and &quot;compiler&quot; is that the latter is into some machine code and the former is not. I think if we could get people to sit down and very clearly define the difference we&#x27;d discover it is not as universal a definition as we think.<p>My personal favorite is when I say a particular term is not well defined on the internet, and I get multiple commenters to jump up and tell me off about how wrong I am and how well-defined the term is and how universal the understanding is, while <i>each of them gives a completely different definition</i>. As I write this it hasn&#x27;t happened in this thread yet, but stay tuned.<p>Anyhow, the simple solution is, there isn&#x27;t a useful distinction between them. There&#x27;s no sharp line anyhow. Plenty of &quot;transpilers&quot; produce things like Python that looks like<p><pre><code>    def f000000001_bch(a0023, a0024, bf___102893):
        __a1 = f000000248_BCh1(a0024, const_00012)
        if __c_112__0:
            f0000000923(__a1)
        else:
            f0000000082(__a1)
</code></pre>
and it&#x27;s really quite silly to look at what can be a very large process and make a distinction only in how the very last phase is run, and on a relatively superficial bit of that last phase too.</div><br/><div id="40214781" class="c"><input type="checkbox" id="c-40214781" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213161">parent</a><span>|</span><a href="#40213467">next</a><span>|</span><label class="collapse" for="c-40214781">[-]</label><label class="expand" for="c-40214781">[2 more]</label></div><br/><div class="children"><div class="content">2 hours later, I think it&#x27;s safe to say there are multiple definitions in play that are, if not outright contradictory, certainly not identical.<p>It seems the term is not terribly useful even on its own terms... it is not as well defined as everyone thinks.<p>Ultimately, &quot;compiler&quot; isn&#x27;t a bright shining line either... I can take anything and shade it down to the point where you might not be sure (&quot;is that a &#x27;compiler&#x27; or an &#x27;interpreter&#x27;?&quot;), but the &quot;transpiler&quot; term is trying to draw a line where there isn&#x27;t even a seam in the landscape.</div><br/><div id="40215950" class="c"><input type="checkbox" id="c-40215950" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40214781">parent</a><span>|</span><a href="#40213467">next</a><span>|</span><label class="collapse" for="c-40215950">[-]</label><label class="expand" for="c-40215950">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the &quot;transpiler&quot; term is trying to draw a line where there isn&#x27;t even a seam in the landscape.<p>I don&#x27;t think you have proven that it is a seamless landscape. In fact, I think that people&#x27;s definitions have been remarkably consistent in spite of their fuzziness. The heart of what I have read is that most people understand a transpiler to be an intermediate text to text translation whose output is input to another tool. The common colloquial definition of a compiler is a text to machine code (for some definition of machine code) translation whose output is an executable program on a host platform. You can make an argument that every compiler is a transpiler or every transpiler is a compiler, but I think it requires a level of willful obtuseness or excessive pedantry to deny that there is something behind the concept of a transpiler. This discussion wouldn&#x27;t even be happening if transpiler were a completely meaningless term.</div><br/></div></div></div></div><div id="40213467" class="c"><input type="checkbox" id="c-40213467" checked=""/><div class="controls bullet"><span class="by">floydnoel</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213161">parent</a><span>|</span><a href="#40214781">prev</a><span>|</span><a href="#40213041">next</a><span>|</span><label class="collapse" for="c-40213467">[-]</label><label class="expand" for="c-40213467">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve observed this sort of behavior frequently, is there a name for this phenomenon yet?<p>Something like &quot;Assuming all concepts are universal to one&#x27;s own peculiar definition&quot;<p>Maybe &quot;semantic egocentrism&quot; could fit the bill?</div><br/><div id="40215477" class="c"><input type="checkbox" id="c-40215477" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213467">parent</a><span>|</span><a href="#40213041">next</a><span>|</span><label class="collapse" for="c-40215477">[-]</label><label class="expand" for="c-40215477">[1 more]</label></div><br/><div class="children"><div class="content">And in the other corner you have Chomsky with universal grammar... and in another you have Platonic Forms...<p>I love the &quot;draw me a tree&quot; idea of a Platonic form, we all have an idealized model of what that is, that is uniquely our own. With that in mind isnt everything subject to some sort of semantics?</div><br/></div></div></div></div></div></div><div id="40213041" class="c"><input type="checkbox" id="c-40213041" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40213161">prev</a><span>|</span><a href="#40213466">next</a><span>|</span><label class="collapse" for="c-40213041">[-]</label><label class="expand" for="c-40213041">[6 more]</label></div><br/><div class="children"><div class="content">&gt; A transpiler emits code the user is supposed to understand, a compiler does not.<p>No, a transpiler emits code that another system is meant to understand (often another compiler or interpreter). Whether a human can understand it or not is immaterial to the objective of transpiling.</div><br/><div id="40213101" class="c"><input type="checkbox" id="c-40213101" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213041">parent</a><span>|</span><a href="#40213090">next</a><span>|</span><label class="collapse" for="c-40213101">[-]</label><label class="expand" for="c-40213101">[3 more]</label></div><br/><div class="children"><div class="content">Does that imply that a compiler emits code that nothing can understand? Or are you saying that &#x27;transpile&#x27; is just another word for &#x27;compile&#x27;?</div><br/><div id="40213232" class="c"><input type="checkbox" id="c-40213232" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213101">parent</a><span>|</span><a href="#40213090">next</a><span>|</span><label class="collapse" for="c-40213232">[-]</label><label class="expand" for="c-40213232">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Does that imply that a compiler emits code that nothing can understand?<p>Bizarre take. No, compilers in the classical sense target byte code and machine code which is meant to be interpreted by a byte code interpreter or a hardware machine.<p>&gt; Or are you saying that &#x27;transpile&#x27; is no more than another word for &#x27;compile&#x27;?<p>Yes. Compilers translate from one language to another. Transpilers translate from one language to another. Both have the objective of preserving the behavior of the program across translation. Neither has the objective of making something intended for humans as a general rule.<p>That transpiled code (if we draw a distinction) targets languages meant for humans to read&#x2F;write means that many transpiled programs can be read by people, but it&#x27;s not the objective.</div><br/><div id="40213499" class="c"><input type="checkbox" id="c-40213499" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213232">parent</a><span>|</span><a href="#40213090">next</a><span>|</span><label class="collapse" for="c-40213499">[-]</label><label class="expand" for="c-40213499">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Bizarre take.</i><p>Bizarre in what way? If compilers are somehow different, then they mustn&#x27;t target systems, as that&#x27;s what your previous comment says transpilers do. Which leaves even your own classical definition to be contradictory, if they are somehow different. What does that leave?<p><i>&gt; Yes.</i><p>But it seems you do not consider them different, which was the divergent path in the previous comment. But evaluating both the &quot;if&quot; and the &quot;else&quot; statement is rather illogical. The evaluation of both branches is what is truly bizarre here.</div><br/></div></div></div></div></div></div><div id="40213090" class="c"><input type="checkbox" id="c-40213090" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213041">parent</a><span>|</span><a href="#40213101">prev</a><span>|</span><a href="#40213466">next</a><span>|</span><label class="collapse" for="c-40213090">[-]</label><label class="expand" for="c-40213090">[2 more]</label></div><br/><div class="children"><div class="content">But then compilation is the same thing as transpilation as noted.</div><br/><div id="40213236" class="c"><input type="checkbox" id="c-40213236" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213090">parent</a><span>|</span><a href="#40213466">next</a><span>|</span><label class="collapse" for="c-40213236">[-]</label><label class="expand" for="c-40213236">[1 more]</label></div><br/><div class="children"><div class="content">Yes.</div><br/></div></div></div></div></div></div><div id="40213466" class="c"><input type="checkbox" id="c-40213466" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40213041">prev</a><span>|</span><a href="#40212914">next</a><span>|</span><label class="collapse" for="c-40213466">[-]</label><label class="expand" for="c-40213466">[6 more]</label></div><br/><div class="children"><div class="content">Yea, not sure i disagree with anything being said here. Though to me, transpiler just typically means it goes from one language i could write, to another i could write. I don&#x27;t necessarily expect to enjoy reading or perhaps even understanding the JavaScript output from any lang that builds to JS, for example.</div><br/><div id="40213937" class="c"><input type="checkbox" id="c-40213937" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213466">parent</a><span>|</span><a href="#40212914">next</a><span>|</span><label class="collapse" for="c-40213937">[-]</label><label class="expand" for="c-40213937">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; transpiler just typically means it goes from one language i could write, to another i could write.</i><p>What possible compiler target couldn&#x27;t you write? Compilers are not exactly magic.</div><br/><div id="40216915" class="c"><input type="checkbox" id="c-40216915" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213937">parent</a><span>|</span><a href="#40212914">next</a><span>|</span><label class="collapse" for="c-40216915">[-]</label><label class="expand" for="c-40216915">[4 more]</label></div><br/><div class="children"><div class="content">Fair, by &quot;could write&quot; i meant one intended for humans to write. Ie i would not say LLVM bytecode is intended for humans to write by hand. Can they? Sure.<p>The difference (to the parent comment) in my eyes is that the target language is the thing intended for humans, not the target output itself. As another commenter points out, transpiled code is often not intended for humans, even if the language is.</div><br/><div id="40217163" class="c"><input type="checkbox" id="c-40217163" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40216915">parent</a><span>|</span><a href="#40212914">next</a><span>|</span><label class="collapse" for="c-40217163">[-]</label><label class="expand" for="c-40217163">[3 more]</label></div><br/><div class="children"><div class="content">Machine code is intended to be written by humans. That was the <i>only</i> way to program computers at one point in time. Given a machine code target, would you say it is product of transpilation or compilation?</div><br/><div id="40218186" class="c"><input type="checkbox" id="c-40218186" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40217163">parent</a><span>|</span><a href="#40212914">next</a><span>|</span><label class="collapse" for="c-40218186">[-]</label><label class="expand" for="c-40218186">[2 more]</label></div><br/><div class="children"><div class="content">I would stand by my original statement, as i don&#x27;t consider that &quot;intended&quot; or common by modern day standards. Humans hand wrote binary for a while too hah.<p>If it&#x27;s not clear, these are just my opinions. Not an attempt at an objective fact or anything.</div><br/><div id="40219168" class="c"><input type="checkbox" id="c-40219168" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40218186">parent</a><span>|</span><a href="#40212914">next</a><span>|</span><label class="collapse" for="c-40219168">[-]</label><label class="expand" for="c-40219168">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Humans hand wrote binary for a while too hah.</i><p>Like, as in flipping toggle switches? Isn&#x27;t that just an input device? They were still producing machine code from that switching.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40212914" class="c"><input type="checkbox" id="c-40212914" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40213466">prev</a><span>|</span><a href="#40212801">next</a><span>|</span><label class="collapse" for="c-40212914">[-]</label><label class="expand" for="c-40212914">[1 more]</label></div><br/><div class="children"><div class="content">All compiler outputs are understandable. I suppose you mean with the intent of it being a one-time translation? As in, like when the Go project converted the original C codebase into Go source with the intent of having developers work in the Go output afterwards and the C code to be never touched again?<p>What is meaningful about such a distinction?</div><br/></div></div><div id="40212801" class="c"><input type="checkbox" id="c-40212801" checked=""/><div class="controls bullet"><span class="by">eklavya</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40212914">prev</a><span>|</span><a href="#40213224">next</a><span>|</span><label class="collapse" for="c-40212801">[-]</label><label class="expand" for="c-40212801">[1 more]</label></div><br/><div class="children"><div class="content">I see what you mean but how is it academically useful to identify transpilers something of their own? It&#x27;s still compiling (lowering) from one notation to another.</div><br/></div></div><div id="40213224" class="c"><input type="checkbox" id="c-40213224" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40212801">prev</a><span>|</span><a href="#40217818">next</a><span>|</span><label class="collapse" for="c-40213224">[-]</label><label class="expand" for="c-40213224">[1 more]</label></div><br/><div class="children"><div class="content">Is Babel a transpiler?</div><br/></div></div><div id="40217818" class="c"><input type="checkbox" id="c-40217818" checked=""/><div class="controls bullet"><span class="by">philwelch</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212737">parent</a><span>|</span><a href="#40213224">prev</a><span>|</span><a href="#40214031">next</a><span>|</span><label class="collapse" for="c-40217818">[-]</label><label class="expand" for="c-40217818">[1 more]</label></div><br/><div class="children"><div class="content">Actually, I can understand assembly.</div><br/></div></div></div></div><div id="40214031" class="c"><input type="checkbox" id="c-40214031" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212642">parent</a><span>|</span><a href="#40212737">prev</a><span>|</span><a href="#40212528">next</a><span>|</span><label class="collapse" for="c-40214031">[-]</label><label class="expand" for="c-40214031">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m fairly certain that source-to-source transpilers rarely use anything like BURS or any other sufficiently smart &quot;instruction selection&quot; (or insturction scheduling, for that matter) algorithms because why would they, the compilers for the targeted language already incorporate such algorithms, maybe even of the higher quality than the transpiler&#x27;s author are capable to write themselves.</div><br/><div id="40214747" class="c"><input type="checkbox" id="c-40214747" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40214031">parent</a><span>|</span><a href="#40212528">next</a><span>|</span><label class="collapse" for="c-40214747">[-]</label><label class="expand" for="c-40214747">[1 more]</label></div><br/><div class="children"><div class="content">All compilers end up with local considerations. Instruction selection or register allocation is not a consideration special to compilers that &quot;transpilers&quot; do not need to have, they are specific considerations for that particular compiler target. A compiler to Go must consider Go&#x27;s identifier rules, which does not apply to compilers targeting a CPU. A compiler to SQL must consider valid SQL syntax and have their own optimization concerns that don&#x27;t apply to Go. And so on.<p>The middles all look very similar, though, which is where the heart of &quot;compiler&quot; comes from; that process of some sort of parsing and then transforming down to some other representation. This has a distinguishing set of characteristics and problems despite what frontends and backends get slapped on them.</div><br/></div></div></div></div></div></div><div id="40212528" class="c"><input type="checkbox" id="c-40212528" checked=""/><div class="controls bullet"><span class="by">PurpleRamen</span><span>|</span><a href="#40212499">parent</a><span>|</span><a href="#40212642">prev</a><span>|</span><a href="#40212590">next</a><span>|</span><label class="collapse" for="c-40212528">[-]</label><label class="expand" for="c-40212528">[4 more]</label></div><br/><div class="children"><div class="content">Readme says transpile: &quot;Borgo is a new language that transpiles to Go.&quot;<p>And it&#x27;s written in rust. Kinda unholy.</div><br/><div id="40212538" class="c"><input type="checkbox" id="c-40212538" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212528">parent</a><span>|</span><a href="#40212669">next</a><span>|</span><label class="collapse" for="c-40212538">[-]</label><label class="expand" for="c-40212538">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the top of the project says &quot;compiles&quot;, then the readme says &quot;transpiles&quot;.  Perhaps the author was just trying to get all the SEO terms in there.<p><i>&gt; And it&#x27;s written in rust. Kinda unholy.</i><p>Agreed, it&#x27;s like, do you really hate writing Go so much that you&#x27;ll really write all that Rust to get out of it? Haha.  Reminds me of the web frameworks which generated the JS so you didn&#x27;t have to touch it, like GWT of old.<p>I&#x27;m sure it was a fun exercise to create Borgo, though.<p>My favorite transpiler is Haxe.  It targets so many other languages, the surface area is impressive.<p><a href="https:&#x2F;&#x2F;haxe.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;haxe.org&#x2F;</a></div><br/></div></div><div id="40212669" class="c"><input type="checkbox" id="c-40212669" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212528">parent</a><span>|</span><a href="#40212538">prev</a><span>|</span><a href="#40214867">next</a><span>|</span><label class="collapse" for="c-40212669">[-]</label><label class="expand" for="c-40212669">[1 more]</label></div><br/><div class="children"><div class="content">Nothing like adding dependencies to the build toolchain.</div><br/></div></div><div id="40214867" class="c"><input type="checkbox" id="c-40214867" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212528">parent</a><span>|</span><a href="#40212669">prev</a><span>|</span><a href="#40212590">next</a><span>|</span><label class="collapse" for="c-40214867">[-]</label><label class="expand" for="c-40214867">[1 more]</label></div><br/><div class="children"><div class="content">Nothing unholy there. It&#x27;s easier to transpile to a less constrained language. Transpiling to Rust would require using one of the GC crates or refcount everything. Then you&#x27;d have to also satisfy the mutability and send&#x2F;sync constraints. Go needs none of these things, so all the transpiler needs to care about is it&#x27;s own added constraints.</div><br/></div></div></div></div><div id="40212590" class="c"><input type="checkbox" id="c-40212590" checked=""/><div class="controls bullet"><span class="by">frozenport</span><span>|</span><a href="#40212499">parent</a><span>|</span><a href="#40212528">prev</a><span>|</span><a href="#40212616">next</a><span>|</span><label class="collapse" for="c-40212590">[-]</label><label class="expand" for="c-40212590">[2 more]</label></div><br/><div class="children"><div class="content">Transpiler is a kind of compiler</div><br/></div></div><div id="40212616" class="c"><input type="checkbox" id="c-40212616" checked=""/><div class="controls bullet"><span class="by">michaelsbradley</span><span>|</span><a href="#40212499">parent</a><span>|</span><a href="#40212590">prev</a><span>|</span><a href="#40212608">next</a><span>|</span><label class="collapse" for="c-40212616">[-]</label><label class="expand" for="c-40212616">[6 more]</label></div><br/><div class="children"><div class="content">“transpiler”, “compiler”, either terminology is valid:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Source-to-source_compiler" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Source-to-source_compiler</a></div><br/><div id="40212632" class="c"><input type="checkbox" id="c-40212632" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212616">parent</a><span>|</span><a href="#40212608">next</a><span>|</span><label class="collapse" for="c-40212632">[-]</label><label class="expand" for="c-40212632">[5 more]</label></div><br/><div class="children"><div class="content">Thanks, I&#x27;d always thought targeted transformations -&gt; transpiler, but it makes sense it&#x27;s really a subset of general compiler functionality, sans binary output.</div><br/><div id="40213152" class="c"><input type="checkbox" id="c-40213152" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40212632">parent</a><span>|</span><a href="#40212608">next</a><span>|</span><label class="collapse" for="c-40213152">[-]</label><label class="expand" for="c-40213152">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; but it makes sense it&#x27;s really a subset of general compiler functionality, sans binary output.</i><p>Tell us more about this compiler subset that does not produce binary output. What do they produce? Ternary? Qubits? Nothing?</div><br/><div id="40214741" class="c"><input type="checkbox" id="c-40214741" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40213152">parent</a><span>|</span><a href="#40212608">next</a><span>|</span><label class="collapse" for="c-40214741">[-]</label><label class="expand" for="c-40214741">[3 more]</label></div><br/><div class="children"><div class="content">They produce text, such as Golang source code.</div><br/><div id="40214868" class="c"><input type="checkbox" id="c-40214868" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40214741">parent</a><span>|</span><a href="#40212608">next</a><span>|</span><label class="collapse" for="c-40214868">[-]</label><label class="expand" for="c-40214868">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for your response, but the Go spec asserts that Go source is represented as UTF-8. UTF-8 is a binary encoding.<p>We&#x27;re talking about compilers that produce something other than binary output.</div><br/><div id="40214965" class="c"><input type="checkbox" id="c-40214965" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40212499">root</a><span>|</span><a href="#40214868">parent</a><span>|</span><a href="#40212608">next</a><span>|</span><label class="collapse" for="c-40214965">[-]</label><label class="expand" for="c-40214965">[1 more]</label></div><br/><div class="children"><div class="content">Ah, my mistake, I thought you were making an earnest inquiry and not a joke. Carry on.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40218983" class="c"><input type="checkbox" id="c-40218983" checked=""/><div class="controls bullet"><span class="by">peterkos</span><span>|</span><a href="#40212499">prev</a><span>|</span><a href="#40215228">next</a><span>|</span><label class="collapse" for="c-40218983">[-]</label><label class="expand" for="c-40218983">[1 more]</label></div><br/><div class="children"><div class="content">This looks a lot like Swift. To me, that&#x27;s a good thing :)</div><br/></div></div><div id="40215228" class="c"><input type="checkbox" id="c-40215228" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#40218983">prev</a><span>|</span><a href="#40213573">next</a><span>|</span><label class="collapse" for="c-40215228">[-]</label><label class="expand" for="c-40215228">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the license?</div><br/></div></div><div id="40213573" class="c"><input type="checkbox" id="c-40213573" checked=""/><div class="controls bullet"><span class="by">rdevsrex</span><span>|</span><a href="#40215228">prev</a><span>|</span><a href="#40215382">next</a><span>|</span><label class="collapse" for="c-40213573">[-]</label><label class="expand" for="c-40213573">[1 more]</label></div><br/><div class="children"><div class="content">It looks pretty interesting! Definitely something to play around with, but honestly, I&#x27;d rather just use Rust (or Gleam if GC is ok).</div><br/></div></div><div id="40215382" class="c"><input type="checkbox" id="c-40215382" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#40213573">prev</a><span>|</span><a href="#40213418">next</a><span>|</span><label class="collapse" for="c-40215382">[-]</label><label class="expand" for="c-40215382">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a little suspicious the example uses math&#x2F;rand.Seed() which has been deprecated for over a year. That&#x27;s when I noticed the repo itself hasn&#x27;t had a single commit in 7 months.<p>Why is this suddenly news, when by all appearances it&#x27;s abandonware?</div><br/><div id="40215545" class="c"><input type="checkbox" id="c-40215545" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#40215382">parent</a><span>|</span><a href="#40213418">next</a><span>|</span><label class="collapse" for="c-40215545">[-]</label><label class="expand" for="c-40215545">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why is this suddenly news, when by all appearances it&#x27;s abandonware?<p>Because the submitter suddenly found it, and it was new to many others too? It&#x27;s not a &#x27;Show HN&#x27;.</div><br/></div></div></div></div><div id="40213418" class="c"><input type="checkbox" id="c-40213418" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40215382">prev</a><span>|</span><a href="#40213054">next</a><span>|</span><label class="collapse" for="c-40213418">[-]</label><label class="expand" for="c-40213418">[5 more]</label></div><br/><div class="children"><div class="content"><i>Many people on HN</i> “Rust syntax is so ugly”<p><i>rustaceans</i> “I love the Rust syntax so much I want it in Go too”</div><br/><div id="40213723" class="c"><input type="checkbox" id="c-40213723" checked=""/><div class="controls bullet"><span class="by">Scramblejams</span><span>|</span><a href="#40213418">parent</a><span>|</span><a href="#40217965">next</a><span>|</span><label class="collapse" for="c-40213723">[-]</label><label class="expand" for="c-40213723">[3 more]</label></div><br/><div class="children"><div class="content">The author notes[0] that it keeps the Rust syntax to avoid having to write a parser.<p>I have no issue with the syntax but I think the chance of uptake would be considerably improved if the syntax were as close to Go&#x27;s as reasonably possible. That&#x27;s because I estimate Go programmers to be a better target for this than Rust programmers, but maybe I&#x27;m wrong.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36847594">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36847594</a></div><br/><div id="40214924" class="c"><input type="checkbox" id="c-40214924" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#40213418">root</a><span>|</span><a href="#40213723">parent</a><span>|</span><a href="#40217965">next</a><span>|</span><label class="collapse" for="c-40214924">[-]</label><label class="expand" for="c-40214924">[2 more]</label></div><br/><div class="children"><div class="content">Having a soft-Rust alternative is a recurring topic in the Rust community and is acknowledged as being of interest by core members:<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;j2l9v9&#x2F;revisiting_a_smaller_rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;j2l9v9&#x2F;revisiting_a_s...</a></div><br/><div id="40219805" class="c"><input type="checkbox" id="c-40219805" checked=""/><div class="controls bullet"><span class="by">Scramblejams</span><span>|</span><a href="#40213418">root</a><span>|</span><a href="#40214924">parent</a><span>|</span><a href="#40217965">next</a><span>|</span><label class="collapse" for="c-40219805">[-]</label><label class="expand" for="c-40219805">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;d be great to see something come of it. Been a while, though.</div><br/></div></div></div></div></div></div><div id="40217965" class="c"><input type="checkbox" id="c-40217965" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#40213418">parent</a><span>|</span><a href="#40213723">prev</a><span>|</span><a href="#40213054">next</a><span>|</span><label class="collapse" for="c-40217965">[-]</label><label class="expand" for="c-40217965">[1 more]</label></div><br/><div class="children"><div class="content">There’s no contradiction here.<p>Rust’s syntax looks alien to people who are not familiar with it, but the syntax itself is fine.<p>Some users also blame Rust’s syntax for being complicated when they actually struggle with Rust’s semantics, e.g. borrow checking wouldn’t be any less strict if Rust chose a less weird sigil for lifetime labels.</div><br/></div></div></div></div><div id="40213054" class="c"><input type="checkbox" id="c-40213054" checked=""/><div class="controls bullet"><span class="by">sevkih</span><span>|</span><a href="#40213418">prev</a><span>|</span><a href="#40215525">next</a><span>|</span><label class="collapse" for="c-40213054">[-]</label><label class="expand" for="c-40213054">[3 more]</label></div><br/><div class="children"><div class="content">So swift?</div><br/><div id="40218273" class="c"><input type="checkbox" id="c-40218273" checked=""/><div class="controls bullet"><span class="by">foolfoolz</span><span>|</span><a href="#40213054">parent</a><span>|</span><a href="#40215525">next</a><span>|</span><label class="collapse" for="c-40218273">[-]</label><label class="expand" for="c-40218273">[2 more]</label></div><br/><div class="children"><div class="content">it looks a lot like java 21+</div><br/><div id="40218643" class="c"><input type="checkbox" id="c-40218643" checked=""/><div class="controls bullet"><span class="by">62951413</span><span>|</span><a href="#40213054">root</a><span>|</span><a href="#40218273">parent</a><span>|</span><a href="#40215525">next</a><span>|</span><label class="collapse" for="c-40218643">[-]</label><label class="expand" for="c-40218643">[1 more]</label></div><br/><div class="children"><div class="content">Java &lt; Kotlin &lt; Scala<p>Golang &lt; Borgo &lt; Rust</div><br/></div></div></div></div></div></div><div id="40215525" class="c"><input type="checkbox" id="c-40215525" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#40213054">prev</a><span>|</span><a href="#40217542">next</a><span>|</span><label class="collapse" for="c-40215525">[-]</label><label class="expand" for="c-40215525">[3 more]</label></div><br/><div class="children"><div class="content">Why compile to Go rather than less-than-ideal (or even slightly-unsafe) Rust?<p>I find it conceptually compelling, I&#x27;m just surprised the target would then be in the GC&#x27;d, larger-binary&#x27;d direction. Like &#x27;Java expressiveness with C simplicity, transpiles to Java&#x27;.<p>Perhaps &#x27;just&#x27; because it&#x27;s a lot simpler to just expand the target language slightly and then you only have to deal with mapping the new bits into implementation, it&#x27;s less like writing a compiler for a whole new language?</div><br/><div id="40217964" class="c"><input type="checkbox" id="c-40217964" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#40215525">parent</a><span>|</span><a href="#40218028">next</a><span>|</span><label class="collapse" for="c-40217964">[-]</label><label class="expand" for="c-40217964">[1 more]</label></div><br/><div class="children"><div class="content">Good question. It&#x27;s probably to be able to continue using the Go ecosystem. You could not incrementally switch a Go codebase to a Rust-based Borgo, but you can when it&#x27;s Go-based.</div><br/></div></div><div id="40218028" class="c"><input type="checkbox" id="c-40218028" checked=""/><div class="controls bullet"><span class="by">leecommamichael</span><span>|</span><a href="#40215525">parent</a><span>|</span><a href="#40217964">prev</a><span>|</span><a href="#40217542">next</a><span>|</span><label class="collapse" for="c-40218028">[-]</label><label class="expand" for="c-40218028">[1 more]</label></div><br/><div class="children"><div class="content">I suspect emitting safe Rust would necessitate your very own implementation of a borrow-checker, or a weak flavor of it, in the language frontend. From there you place yourself in the author&#x27;s shoes and consider the tradeoffs that come with emitting unsafe Rust. My interpretation of _that_ tradeoff is emitting &quot;something like C++&quot; or &quot;something like Java,&quot; to use your analogy. There appears to be less to get wrong.</div><br/></div></div></div></div><div id="40217542" class="c"><input type="checkbox" id="c-40217542" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#40215525">prev</a><span>|</span><a href="#40213571">next</a><span>|</span><label class="collapse" for="c-40217542">[-]</label><label class="expand" for="c-40217542">[2 more]</label></div><br/><div class="children"><div class="content">Does Borgo have a Treesitter grammar? An LSP? I&#x27;d use it in a heartbeat if so.</div><br/><div id="40220883" class="c"><input type="checkbox" id="c-40220883" checked=""/><div class="controls bullet"><span class="by">himujjal</span><span>|</span><a href="#40217542">parent</a><span>|</span><a href="#40213571">next</a><span>|</span><label class="collapse" for="c-40220883">[-]</label><label class="expand" for="c-40220883">[1 more]</label></div><br/><div class="children"><div class="content">Neovim user detected!</div><br/></div></div></div></div><div id="40213571" class="c"><input type="checkbox" id="c-40213571" checked=""/><div class="controls bullet"><span class="by">rthnbgrredf</span><span>|</span><a href="#40217542">prev</a><span>|</span><a href="#40212707">next</a><span>|</span><label class="collapse" for="c-40213571">[-]</label><label class="expand" for="c-40213571">[3 more]</label></div><br/><div class="children"><div class="content">Would it be possible to make a Python (without C extensions) that compiles to Go?</div><br/><div id="40215185" class="c"><input type="checkbox" id="c-40215185" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#40213571">parent</a><span>|</span><a href="#40213711">next</a><span>|</span><label class="collapse" for="c-40215185">[-]</label><label class="expand" for="c-40215185">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure you can easily directly transpile to Golang from Python. Python is very, very dynamic and can have extremely complex types that are not representable with the Golang type system.
Not impossible but I guess you might end up with an extra runtime layer and some more dynamic operations will not be very fast. Or you restrict it to a subset of Python like this project does: <a href="https:&#x2F;&#x2F;github.com&#x2F;zanellia&#x2F;prometeo">https:&#x2F;&#x2F;github.com&#x2F;zanellia&#x2F;prometeo</a><p>You could of course write a bytecode VM in Golang but I guess that defeats the purpose.</div><br/></div></div><div id="40213711" class="c"><input type="checkbox" id="c-40213711" checked=""/><div class="controls bullet"><span class="by">funny_falcon</span><span>|</span><a href="#40213571">parent</a><span>|</span><a href="#40215185">prev</a><span>|</span><a href="#40212707">next</a><span>|</span><label class="collapse" for="c-40213711">[-]</label><label class="expand" for="c-40213711">[1 more]</label></div><br/><div class="children"><div class="content">There was one: <a href="https:&#x2F;&#x2F;github.com&#x2F;grumpyhome&#x2F;grumpy">https:&#x2F;&#x2F;github.com&#x2F;grumpyhome&#x2F;grumpy</a><p>Looks like abandoned though.</div><br/></div></div></div></div><div id="40212707" class="c"><input type="checkbox" id="c-40212707" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#40213571">prev</a><span>|</span><a href="#40212585">next</a><span>|</span><label class="collapse" for="c-40212707">[-]</label><label class="expand" for="c-40212707">[12 more]</label></div><br/><div class="children"><div class="content">The only language I can think of that has pulled off “compiles to another totaling language” and gained mainstream adoption is typescript, and I’m sure it wouldn’t have done so if it were possible to run in the browser otherwise.<p>Can anyone think of another example?</div><br/><div id="40212812" class="c"><input type="checkbox" id="c-40212812" checked=""/><div class="controls bullet"><span class="by">furyofantares</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40212771">next</a><span>|</span><label class="collapse" for="c-40212812">[-]</label><label class="expand" for="c-40212812">[1 more]</label></div><br/><div class="children"><div class="content">C++ is for sure gonna be the biggest example.  I think Objective-C too.<p>There&#x27;s other successful but not &quot;mainstream&quot; languages that might count or semi-count, like Clojure targeting the JVM (though not Java) and being able to use Java packages, or ClojureScript targeting JavaScript.</div><br/></div></div><div id="40212771" class="c"><input type="checkbox" id="c-40212771" checked=""/><div class="controls bullet"><span class="by">ARandomerDude</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40212812">prev</a><span>|</span><a href="#40214780">next</a><span>|</span><label class="collapse" for="c-40212771">[-]</label><label class="expand" for="c-40212771">[1 more]</label></div><br/><div class="children"><div class="content">CoffeeScript was pretty popular about 10 years ago and did this.</div><br/></div></div><div id="40214780" class="c"><input type="checkbox" id="c-40214780" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40212771">prev</a><span>|</span><a href="#40215215">next</a><span>|</span><label class="collapse" for="c-40214780">[-]</label><label class="expand" for="c-40214780">[1 more]</label></div><br/><div class="children"><div class="content">There’s web2c which transpiles Pascal-Web to C code. And in the 90s, Eberhard Mattes, to enable his port of TeX and friends to OS&#x2F;2 and DOS wrote a Pascal to C compiler (I remember when it was first released, there was speculation that it might have been a pirated commercial implementation because how could one guy manage this, but that was short-lived as people realized it was faster than any of the commercial versions.)</div><br/></div></div><div id="40215215" class="c"><input type="checkbox" id="c-40215215" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40214780">prev</a><span>|</span><a href="#40213627">next</a><span>|</span><label class="collapse" for="c-40215215">[-]</label><label class="expand" for="c-40215215">[1 more]</label></div><br/><div class="children"><div class="content">haxe is not quite &quot;mainstream adoption&quot; level but it has a decent amount of stuff done in it<p>clojurescript is fairly popular too.</div><br/></div></div><div id="40213627" class="c"><input type="checkbox" id="c-40213627" checked=""/><div class="controls bullet"><span class="by">hiccuphippo</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40215215">prev</a><span>|</span><a href="#40212729">next</a><span>|</span><label class="collapse" for="c-40213627">[-]</label><label class="expand" for="c-40213627">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly the same but a few languages compile to llir which then is compiled by llvm to machine code.</div><br/></div></div><div id="40212729" class="c"><input type="checkbox" id="c-40212729" checked=""/><div class="controls bullet"><span class="by">elliotlarson</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40213627">prev</a><span>|</span><a href="#40213196">next</a><span>|</span><label class="collapse" for="c-40212729">[-]</label><label class="expand" for="c-40212729">[3 more]</label></div><br/><div class="children"><div class="content">Elixir compiles to Erlang, I think.</div><br/><div id="40212775" class="c"><input type="checkbox" id="c-40212775" checked=""/><div class="controls bullet"><span class="by">toolz</span><span>|</span><a href="#40212707">root</a><span>|</span><a href="#40212729">parent</a><span>|</span><a href="#40212764">next</a><span>|</span><label class="collapse" for="c-40212775">[-]</label><label class="expand" for="c-40212775">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly correct, it does have &quot;core erlang&quot; as a compilation step, but they both have that as a compilation step ultimately compiling to beam bytecode.</div><br/></div></div><div id="40212764" class="c"><input type="checkbox" id="c-40212764" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#40212707">root</a><span>|</span><a href="#40212729">parent</a><span>|</span><a href="#40212775">prev</a><span>|</span><a href="#40213196">next</a><span>|</span><label class="collapse" for="c-40212764">[-]</label><label class="expand" for="c-40212764">[1 more]</label></div><br/><div class="children"><div class="content">Correct Elixir runs on the BEAN.</div><br/></div></div></div></div><div id="40213196" class="c"><input type="checkbox" id="c-40213196" checked=""/><div class="controls bullet"><span class="by">michaelsbradley</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40212729">prev</a><span>|</span><a href="#40212762">next</a><span>|</span><label class="collapse" for="c-40213196">[-]</label><label class="expand" for="c-40213196">[1 more]</label></div><br/><div class="children"><div class="content">Nim compiles to C by default, and it seems most Nim devs stick with that default. Nim hasn’t gained mainstream adoption, though.</div><br/></div></div><div id="40212762" class="c"><input type="checkbox" id="c-40212762" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40213196">prev</a><span>|</span><a href="#40216736">next</a><span>|</span><label class="collapse" for="c-40212762">[-]</label><label class="expand" for="c-40212762">[1 more]</label></div><br/><div class="children"><div class="content">C++ used to compile to C.</div><br/></div></div><div id="40216736" class="c"><input type="checkbox" id="c-40216736" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40212707">parent</a><span>|</span><a href="#40212762">prev</a><span>|</span><a href="#40212585">next</a><span>|</span><label class="collapse" for="c-40216736">[-]</label><label class="expand" for="c-40216736">[1 more]</label></div><br/><div class="children"><div class="content">I like your take but - not that this was important to TypeScript - JavaScript was literally the assembly language of the web (asm.js) until WASM came along. There was no other target that TypeScript could compile to. I guess that’s why TypeScript simply added types to JS, rather than being a wholly new language, which in turn made it compatible and familiar to potential adopters. It also solved a big problem caused by the growing size of client code bases.<p>All of that said - this train of thought lead me to discover AssemblyScript! <a href="https:&#x2F;&#x2F;www.assemblyscript.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.assemblyscript.org&#x2F;</a></div><br/></div></div></div></div><div id="40212585" class="c"><input type="checkbox" id="c-40212585" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#40212707">prev</a><span>|</span><a href="#40213234">next</a><span>|</span><label class="collapse" for="c-40212585">[-]</label><label class="expand" for="c-40212585">[2 more]</label></div><br/><div class="children"><div class="content">Can you use Go modules?</div><br/><div id="40218262" class="c"><input type="checkbox" id="c-40218262" checked=""/><div class="controls bullet"><span class="by">tbrockman</span><span>|</span><a href="#40212585">parent</a><span>|</span><a href="#40213234">next</a><span>|</span><label class="collapse" for="c-40218262">[-]</label><label class="expand" for="c-40218262">[1 more]</label></div><br/><div class="children"><div class="content">With a little bit of effort: <a href="https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#package-definitions" rel="nofollow">https:&#x2F;&#x2F;borgo-lang.github.io&#x2F;#package-definitions</a></div><br/></div></div></div></div><div id="40213234" class="c"><input type="checkbox" id="c-40213234" checked=""/><div class="controls bullet"><span class="by">a3w</span><span>|</span><a href="#40212585">prev</a><span>|</span><label class="collapse" for="c-40213234">[-]</label><label class="expand" for="c-40213234">[6 more]</label></div><br/><div class="children"><div class="content">Go is less complex than rust? Really? I thought that was disputed.</div><br/><div id="40213394" class="c"><input type="checkbox" id="c-40213394" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#40213234">parent</a><span>|</span><a href="#40217969">next</a><span>|</span><label class="collapse" for="c-40213394">[-]</label><label class="expand" for="c-40213394">[1 more]</label></div><br/><div class="children"><div class="content">Go is less complex than Rust, imo. As someone who has used Go and Rust for about the same time (5-6 years), it&#x27;s not <i>as less complex than it seems</i>, though. Namely i found a odd type of complexity emerge in Go where by every individual unit was simple, but the whole was so spread out and poorly abstracted that it it spread out the complexity. So if you squinted, everything was simple. If you zoomed out, it felt convoluted.<p>Rust on the other hand drastically simplifies a lot of the complexity i dealt with in Go. However depending on the type of work, it&#x27;s of course got plenty of complexity to dig into should you need it.<p>The challenge with Rust imo is to know where to use that complexity. Lots of rope to hang yourself with. On average i find myself with code that to me is simpler in Rust, because it&#x27;s easier to reason about larger blocks of logic. However i still wouldn&#x27;t ignore the extra rope of the whole language and call it &quot;simpler&quot; than Go.</div><br/></div></div><div id="40217969" class="c"><input type="checkbox" id="c-40217969" checked=""/><div class="controls bullet"><span class="by">leecommamichael</span><span>|</span><a href="#40213234">parent</a><span>|</span><a href="#40213394">prev</a><span>|</span><a href="#40214390">next</a><span>|</span><label class="collapse" for="c-40217969">[-]</label><label class="expand" for="c-40217969">[1 more]</label></div><br/><div class="children"><div class="content">Rust has macros and a novel memory model. How would you measure complexity? For me it&#x27;s that simple.</div><br/></div></div><div id="40214390" class="c"><input type="checkbox" id="c-40214390" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40213234">parent</a><span>|</span><a href="#40217969">prev</a><span>|</span><label class="collapse" for="c-40214390">[-]</label><label class="expand" for="c-40214390">[3 more]</label></div><br/><div class="children"><div class="content">You can read and grok the entire gospec in a week.</div><br/><div id="40215354" class="c"><input type="checkbox" id="c-40215354" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#40213234">root</a><span>|</span><a href="#40214390">parent</a><span>|</span><label class="collapse" for="c-40215354">[-]</label><label class="expand" for="c-40215354">[2 more]</label></div><br/><div class="children"><div class="content">The golang language spec is very sparse on implementation details in comparison to something like the java spec. I don&#x27;t think the length of the lang spec is a great metric for language simplicity.</div><br/><div id="40215775" class="c"><input type="checkbox" id="c-40215775" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40213234">root</a><span>|</span><a href="#40215354">parent</a><span>|</span><label class="collapse" for="c-40215775">[-]</label><label class="expand" for="c-40215775">[1 more]</label></div><br/><div class="children"><div class="content">The Java specification is bigger because it has to define the entire Virtual Machine where a compiler can target already defined architectures.  I&#x27;m also not seeing much in the way of &quot;implementation details&quot; in their specification.  Can you point out what you mean?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>