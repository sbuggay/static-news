<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737190875754" as="style"/><link rel="stylesheet" href="styles.css?v=1737190875754"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dashbit.co/blog/data-evolution-with-set-theoretic-types">Data evolution with set-theoretic types</a>Â <span class="domain">(<a href="https://dashbit.co">dashbit.co</a>)</span></div><div class="subtext"><span>josevalim</span> | <span>29 comments</span></div><br/><div><div id="42702970" class="c"><input type="checkbox" id="c-42702970" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#42695241">next</a><span>|</span><label class="collapse" for="c-42702970">[-]</label><label class="expand" for="c-42702970">[4 more]</label></div><br/><div class="children"><div class="content">These are great examples of difficulties people will encounter in all popular statically typed languages sooner or later.<p>I find the solution presented interesting but it is limited to the 3 operations mentioned.<p>The alternative to this runtime schema checks and treating your data as data - the data you are working with is coming from an external system and needs to be runtime-validated anyways.<p>Throw in some nil-punting and you can have a very flexible system that is guarded by runtime checks.</div><br/><div id="42716489" class="c"><input type="checkbox" id="c-42716489" checked=""/><div class="controls bullet"><span class="by">manx</span><span>|</span><a href="#42702970">parent</a><span>|</span><a href="#42710149">next</a><span>|</span><label class="collapse" for="c-42716489">[-]</label><label class="expand" for="c-42716489">[1 more]</label></div><br/><div class="children"><div class="content">I recommend reading: <a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-validate&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-va...</a></div><br/></div></div><div id="42710149" class="c"><input type="checkbox" id="c-42710149" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42702970">parent</a><span>|</span><a href="#42716489">prev</a><span>|</span><a href="#42695241">next</a><span>|</span><label class="collapse" for="c-42710149">[-]</label><label class="expand" for="c-42710149">[2 more]</label></div><br/><div class="children"><div class="content">Agreed that it is naive to assume that static types will keep some kind of consistency on the bytes that come in on the wire, but it misses the point.<p>With static types, you do <i>one</i> transformation from bytes to a proper data type at the boundary.<p>The static type information propogates bidirectionally deep into the guts of the system.<p>If you&#x27;re 10 layers in, and want to invoke getUserId() on an object, you just add it to your type.  Now your endpoint can return 400s without you needing to add extra nil-checks somewhere (or multiple places) from layers 1 to 10 (which realistically will turn into 500s).</div><br/><div id="42746630" class="c"><input type="checkbox" id="c-42746630" checked=""/><div class="controls bullet"><span class="by">Vampiero</span><span>|</span><a href="#42702970">root</a><span>|</span><a href="#42710149">parent</a><span>|</span><a href="#42695241">next</a><span>|</span><label class="collapse" for="c-42746630">[-]</label><label class="expand" for="c-42746630">[1 more]</label></div><br/><div class="children"><div class="content">Realistically you can design a runtime-checked interface that uses option types instead of nulls, thereby guaranteeing static correctness and preventing common pitfalls at the cost of making the usage pattern a bit more verbose.</div><br/></div></div></div></div></div></div><div id="42695241" class="c"><input type="checkbox" id="c-42695241" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#42702970">prev</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42695241">[-]</label><label class="expand" for="c-42695241">[15 more]</label></div><br/><div class="children"><div class="content">Author here. This is probably the article that took me the longest to write, roughly 15 months, and I may still not have explained all concepts with the clarity they deserve and I intended to. If there is any feedback or questions, I&#x27;d be glad to answer them!</div><br/><div id="42710835" class="c"><input type="checkbox" id="c-42710835" checked=""/><div class="controls bullet"><span class="by">ddellacosta</span><span>|</span><a href="#42695241">parent</a><span>|</span><a href="#42702372">next</a><span>|</span><label class="collapse" for="c-42710835">[-]</label><label class="expand" for="c-42710835">[1 more]</label></div><br/><div class="children"><div class="content">This is great stuff! As a Haskell fan who uses Elixir (and Erlang) in my day job, I&#x27;m really looking forward to seeing how we can leverage more of the new set-theoretic type features showing up in Elixir. Revisions seem like something I&#x27;ve never really seen before in any of the type systems I&#x27;ve used, so I&#x27;m excited to see how it can be leveraged in a real production system. Thanks for the post.</div><br/></div></div><div id="42702372" class="c"><input type="checkbox" id="c-42702372" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42695241">parent</a><span>|</span><a href="#42710835">prev</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42702372">[-]</label><label class="expand" for="c-42702372">[13 more]</label></div><br/><div class="children"><div class="content">Stuff like this is why I don&#x27;t like type systems. What you want to do is easy, but it becomes difficult to explain in a sane way (15 months difficult), because you need to work around the limitations of type systems. When you say &quot;set-theoretic types&quot;, I hear, &quot;get rid of types, just give me logic&quot;.</div><br/><div id="42702931" class="c"><input type="checkbox" id="c-42702931" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42702372">parent</a><span>|</span><a href="#42702473">next</a><span>|</span><label class="collapse" for="c-42702931">[-]</label><label class="expand" for="c-42702931">[5 more]</label></div><br/><div class="children"><div class="content">The work to develop the base theory, which this article presents, takes 15 months, but it doesn&#x27;t take 15 months to read it (and hopefully it won&#x27;t take as long to use it either). Whenever you use a programming language, you may work with data structures that took months to formalize and several more years to optimize, yet no one is saying &quot;throw our data structures away&quot;. Even things like pretty printing and formatting a float have collectively several years of research behind them, yet the API is often a single function call.<p>Of course, you can still not like types, and making it harder to evolve libraries over time is a good reason. But using the time it takes to formalize its underlying concepts is not a strong argument against them. The goal is that someone will spend this time, precisely so you don&#x27;t have to. :)</div><br/><div id="42703122" class="c"><input type="checkbox" id="c-42703122" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42702931">parent</a><span>|</span><a href="#42704972">next</a><span>|</span><label class="collapse" for="c-42703122">[-]</label><label class="expand" for="c-42703122">[3 more]</label></div><br/><div class="children"><div class="content">I have seen multiple users of one certain popular programming language claim that data structures besides a dynamic length array and a hash table have no useful application.</div><br/><div id="42703969" class="c"><input type="checkbox" id="c-42703969" checked=""/><div class="controls bullet"><span class="by">caspper69</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42703122">parent</a><span>|</span><a href="#42704459">next</a><span>|</span><label class="collapse" for="c-42703969">[-]</label><label class="expand" for="c-42703969">[1 more]</label></div><br/><div class="children"><div class="content">They wouldn&#x27;t also happen to throw out memory safety guarantees one level up by using a ton of array indexing, would they?</div><br/></div></div><div id="42704459" class="c"><input type="checkbox" id="c-42704459" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42703122">parent</a><span>|</span><a href="#42703969">prev</a><span>|</span><a href="#42704972">next</a><span>|</span><label class="collapse" for="c-42704459">[-]</label><label class="expand" for="c-42704459">[1 more]</label></div><br/><div class="children"><div class="content">Clojure? Sounds like something Hickey would say.</div><br/></div></div></div></div><div id="42704972" class="c"><input type="checkbox" id="c-42704972" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42702931">parent</a><span>|</span><a href="#42703122">prev</a><span>|</span><a href="#42702473">next</a><span>|</span><label class="collapse" for="c-42704972">[-]</label><label class="expand" for="c-42704972">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I like formalising things, don&#x27;t get me wrong, and I don&#x27;t mind spending time on it at all. I just don&#x27;t like doing it via types, and looking at how much time you spent on what, I rest my case.</div><br/></div></div></div></div><div id="42702473" class="c"><input type="checkbox" id="c-42702473" checked=""/><div class="controls bullet"><span class="by">ryanschaefer</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42702372">parent</a><span>|</span><a href="#42702931">prev</a><span>|</span><a href="#42710802">next</a><span>|</span><label class="collapse" for="c-42702473">[-]</label><label class="expand" for="c-42702473">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what you want to do is easy
 Easy to implement, hard to get correct. It inverts where you do work in a system.
It can be hard to implement robust types but once thatâs done itâs easy to know what you are writing is correct.</div><br/></div></div><div id="42710802" class="c"><input type="checkbox" id="c-42710802" checked=""/><div class="controls bullet"><span class="by">ddellacosta</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42702372">parent</a><span>|</span><a href="#42702473">prev</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42710802">[-]</label><label class="expand" for="c-42710802">[6 more]</label></div><br/><div class="children"><div class="content">&gt; because you need to work around the limitations of type systems.<p>What limitations of type systems are you talking about?<p>&gt; When you say &quot;set-theoretic types&quot;, I hear, &quot;get rid of types, just give me logic&quot;.<p>A type theory&#x2F;type system is a logic, so I don&#x27;t really understand this point. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_theory#Logic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_theory#Logic</a></div><br/><div id="42711569" class="c"><input type="checkbox" id="c-42711569" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42710802">parent</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42711569">[-]</label><label class="expand" for="c-42711569">[5 more]</label></div><br/><div class="children"><div class="content">Yes, a type theory is a logic, but not a particularly good one. It is limiting to have to under-approximate the mathematical universe via statically typed chunks before being able to talk about the objects in the universe, and the article just describes another instance of why that is problematic in practice.<p>The alternative I propose is simpler than you would think, and definitely simpler than type theory, but it is also very new: <a href="http:&#x2F;&#x2F;abstractionlogic.com" rel="nofollow">http:&#x2F;&#x2F;abstractionlogic.com</a> . And of course, it doesn&#x27;t come with a fixed algorithm for type checking, but going forward and in the age of AI, I think that will turn out to be an advantage.</div><br/><div id="42713231" class="c"><input type="checkbox" id="c-42713231" checked=""/><div class="controls bullet"><span class="by">ddellacosta</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42711569">parent</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42713231">[-]</label><label class="expand" for="c-42713231">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, a type theory is a logic, but not a particularly good one.<p>Given the context of the original post, type theory at least has the benefit of actually existing in industrial languages in the form of a bunch of implemented and in-use type systems.<p>&gt; It is limiting to have to under-approximate the mathematical universe via statically typed chunks before being able to talk about the objects in the universe, and the article just describes another instance of why that is problematic in practice.<p>&gt;<p>&gt; The alternative I propose is simpler than you would think, and definitely simpler than type theory, but it is also very new: <a href="http:&#x2F;&#x2F;abstractionlogic.com" rel="nofollow">http:&#x2F;&#x2F;abstractionlogic.com</a> . And of course, it doesn&#x27;t come with a fixed algorithm for type checking, but going forward and in the age of AI, I think that will turn out to be an advantage.<p>That&#x27;s helpful in understanding where you&#x27;re coming from, but now I&#x27;m even more perplexed--what you&#x27;ve linked to seems extremely theoretical. The closest to something my industrial programmer brain can grasp and read that I&#x27;d care about (in the context of the original post we&#x27;re discussing) is <a href="https:&#x2F;&#x2F;obua.com&#x2F;publications&#x2F;automating-abstraction-logic&#x2F;1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;obua.com&#x2F;publications&#x2F;automating-abstraction-logic&#x2F;1...</a>, which seems focused on theorem proving.<p>None of this is meant to suggest that I don&#x27;t see the value in what you&#x27;ve linked to--it will take me some time to absorb, but I will take a closer look--but if you want to come into a discussion about a post like this one and criticize it, and more generally type systems, I think you&#x27;d be better off showing more directly how your approach can solve the same problem (or how it doesn&#x27;t need to solve it, which it sounds like you&#x27;re implying) in a way that doesn&#x27;t take reading through a bunch of fairly abstract posts and papers or watching a five-part video series first. And if there&#x27;s no actual implementation (that I can see at least) then don&#x27;t expect me, an industrial programmer--like most folks on HN I would guess vs. e.g. lambda-the-ultimate or whatever--to consider it worthwhile past idle curiosity.<p>I see value in Valim&#x27;s post because it identifies a problem with type systems that I understand and have encountered, and provides an incremental and pragmatic solution to that. It doesn&#x27;t seem like you&#x27;re offering a coherent, practical alternative, regardless of the validity of your arguments (&quot;It is limiting to have to under-approximate the mathematical universe via statically typed chunks before being able to talk about the objects in the universe&quot; makes intuitive sense to me in this context, at least).</div><br/><div id="42713684" class="c"><input type="checkbox" id="c-42713684" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42713231">parent</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42713684">[-]</label><label class="expand" for="c-42713684">[3 more]</label></div><br/><div class="children"><div class="content">How much work you want to put into understanding abstraction logic is very much up to you.<p>There are no tools for abstraction logic right now. I hope there will be in 15 months ;-) Maybe check back then.</div><br/><div id="42723152" class="c"><input type="checkbox" id="c-42723152" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42713684">parent</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42723152">[-]</label><label class="expand" for="c-42723152">[2 more]</label></div><br/><div class="children"><div class="content">While it is a bit unfortunate that the time spent to write the article continues to be used as a criticism, and perhaps as a dig, Iâll only add that I have no formal background on type theory or logic. So much of the 15 months was also spent on learning the underlying concepts, mostly on my free time, and I am quite happy to even produce _something_ on a topic I have only recently got into. I am sure people smarter or more familiar with the theory than me would produce more in less time.</div><br/><div id="42723656" class="c"><input type="checkbox" id="c-42723656" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42695241">root</a><span>|</span><a href="#42723152">parent</a><span>|</span><a href="#42706247">next</a><span>|</span><label class="collapse" for="c-42723656">[-]</label><label class="expand" for="c-42723656">[1 more]</label></div><br/><div class="children"><div class="content">No, I was just joking in my last comment, as I know how time-consuming true progress can be. I&#x27;m also familiar with how type theory can overcomplicate simple things. When I see this happening, I can&#x27;t help but point it out, although my criticism might seem out of context. I would be very happy if I could deliver tools for abstraction logic in just 15 months.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42706247" class="c"><input type="checkbox" id="c-42706247" checked=""/><div class="controls bullet"><span class="by">Moosieus</span><span>|</span><a href="#42695241">prev</a><span>|</span><a href="#42708656">next</a><span>|</span><label class="collapse" for="c-42706247">[-]</label><label class="expand" for="c-42706247">[1 more]</label></div><br/><div class="children"><div class="content">This is some interesting shit, I love it! At least that parts I think I understand :P<p>&gt; The goal of data versioning is to provide more mechanisms for library authors to evolve their schemas without imposing breaking changes often. Application developers will have limited use of this feature, as they would rather update their existing codebases and their types right away. Although this may find use cases around durable data and distributed systems.<p>&quot;Hard cutover&quot; is definitely a lot less laborious, but often times incremental updates are necessary - large teams, existing tables and whatnot. To that end, I would foresee a lot of appeal in app dev when applied to database migrations.</div><br/></div></div><div id="42708656" class="c"><input type="checkbox" id="c-42708656" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#42706247">prev</a><span>|</span><a href="#42704500">next</a><span>|</span><label class="collapse" for="c-42708656">[-]</label><label class="expand" for="c-42708656">[5 more]</label></div><br/><div class="children"><div class="content">Some initial concerns when thinking about this:<p>- Understanding how it expands the surface area of both the API and discussion of a struct (and thus also libraries and dependencies of the librar{y,ies}). Now you don&#x27;t need to ask someone if they&#x27;re using v1.0 of some package, but also which revision of a struct they&#x27;re using, which they may not even know. This compounds when a library releases a new breaking major version, presumably - `%SomeStruct{}` for v2 may be different from `%SomeStruct{}` v1r2.<p>- Documentation seems like it would be more complex, as well. If `%SomeStruct{}` in v1.0 has some shape, and you publish `v1.1`, then realize you want to update the revision of `%SomeStruct{}` with a modified (or added) field, would there be docs for `v1.1` and `v1.1r2`? or would `v1.1` docs be retroactively modified to include `%SomeStruct{}v1.1r2`?<p>- The first example is a common situation, where an author realizes after it&#x27;s too late that the representation of some data isn&#x27;t ideal, or maybe even isn&#x27;t sufficient. Typically, this is a solved with a single change, or rarely in a couple or few changes. I&#x27;m not sure if the complexity is worth it. I understand the desire to not fragment users due to breaking changes, but I&#x27;m not sure if this is the appropriate solution.<p>- How does this interact with (de-)serialization?<p>I happen to be working with the SQLite file format currently, and I generally really enjoy data formats. It&#x27;s not exactly the same as this, since runtime data structures are ephemeral technically, but in reality they are not. The typical strategy for any blob format is to hoard a reasonable amount of extra space for when you realize you made a mistake. This is usually fine, since previous readers and writers ought to ignore any extra data in reserved space.<p>One of the things one quickly realizes when working with various blob formats is the header usually has (as a guess), 25% of it allocated to reserved space. However, looking at many data formats over the last several decades, it&#x27;s extraordinarily rare to ever see an update to them that uses it. Maybe once or twice, but it&#x27;s not common. One solution is to have more variable-length data, but this has its own problems.<p>So, in general, I&#x27;m very interested in this problem (which is a real problem!), and I&#x27;m also skeptical of this solution. I am very willing to explore these ideas though, because they&#x27;re an interesting approach that don&#x27;t have prior art to look at, as far as I know.<p>EDIT: Also, thanks for all the work to everyone on the type system! I&#x27;m a huge fan of it!</div><br/><div id="42710369" class="c"><input type="checkbox" id="c-42710369" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#42708656">parent</a><span>|</span><a href="#42708718">next</a><span>|</span><label class="collapse" for="c-42710369">[-]</label><label class="expand" for="c-42710369">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This compounds when a library releases a new breaking major version, presumably - `%SomeStruct{}` for v2 may be different from `%SomeStruct{}` v1r2.<p>You should never reuse the revisions. If you launch a major version, then it means you only support r5 onwards. Do not reset it back to r1.<p>I am also not sure if the user needs to know the version. Remember that if I am in r5, because of subtyping, the code naturally supports r1, r2, r3, and r4, and those already have to be pretty printed. All of the work here is to &quot;generate automatic proofs&quot; via type signatures, no new capability or requirement is being introduced on the type representation of things.<p>&gt; Documentation seems like it would be more complex, as well. If `%SomeStruct{}` in v1.0 has some shape, and you publish `v1.1`, then realize you want to update the revision of `%SomeStruct{}` with a modified (or added) field<p>I don&#x27;t think documentation is more complex because that&#x27;s something already factored in today. Functions add new options in new releases. Structs add new fields. And today we already annotate the version they were added. Perhaps this approach can automate some of it instead.<p>---<p>Other than that, we should be skeptical indeed. :)</div><br/><div id="42711181" class="c"><input type="checkbox" id="c-42711181" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#42708656">root</a><span>|</span><a href="#42710369">parent</a><span>|</span><a href="#42708718">next</a><span>|</span><label class="collapse" for="c-42711181">[-]</label><label class="expand" for="c-42711181">[2 more]</label></div><br/><div class="children"><div class="content">As a preamble, the discussion of versioning is difficult since it&#x27;s abstract; this is difficult to discuss in general.<p>&gt; You should never reuse the revisions. If you launch a major version, then it means you only support r5 onwards. Do not reset it back to r1.<p>Hm, so hypothetically a v1.0.0 of a library could begin its life with structs at a greater-than-1 revision number. This seems odd, since a major version bump is able to be breaking, but revisions don&#x27;t have the same semantic meaning - it just means &quot;it&#x27;s different from before&quot;.<p>This kind of breaks my mental model of major version bumps. I consider v1 of something to be distinct from v2, where it just happens to be that v2 typically is mostly compatible with v1. However, with revisions, it maintains that connection explicitly. I suppose the answer to that would be to rename the structs and have them start at revision 1, but now we&#x27;re back at square one, where I could&#x27;ve just done that without revisions to maintain backwards compatibility by introducing a new struct.<p>I&#x27;m not sure if I&#x27;m conveying what&#x27;s odd about that sufficiently. Let me know if I should think on that more and try explaining it again.<p>&gt; I don&#x27;t think documentation is more complex because that&#x27;s something already factored in today. Functions add new options in new releases. Structs add new fields. And today we already annotate the version they were added. Perhaps this approach can automate some of it instead.<p>The expectation here would be that a struct revision would be a minor version bump, correct? That seems like it kind of breaks semantic versioning, since a user of v1.0.0 wouldn&#x27;t necessarily have any behavioral changes in v1.1.0, since the structs and users of the structs would be identical, right? It kind of pushes the minor version bump onto the consumer code at their discretion, but not in a typical way. Now if I bump a dependency&#x27;s minor, I don&#x27;t necessarily want to bump my own minor - but maybe I do? Especially if I&#x27;m a middleman library, where I pass behavior from client code to one of my dependencies.<p>This is getting a bit confusing to consider the hypothetical situations. The main gut feeling I have about this is the same about versioning in general - it&#x27;s fine until it&#x27;s not, which is usually some unknown point in the future when things get complex. Kind of the gist of my hesitation is just that versioning is already a complicated problem, and introducing more variation in that seems like it really needs to be a long experiment with the expectation that it may not work. Unfortunately, the situations in which versioning rears its ugly head is typically only in long-used, complex projects. So I don&#x27;t really know how a test bed for this could exist to give realistic results.<p>As a bit of a disclaimer to everything I just said, semver is not the holy grail, in my opinion, and I think it&#x27;s perfectly reasonable to experiment with it and try alternatives. Maybe part of my issue is just that I haven&#x27;t entertained other versioning schemes that can sufficiently handle the difference between behavioral and representational changes.<p>Thanks for the discussion!</div><br/><div id="42712918" class="c"><input type="checkbox" id="c-42712918" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#42708656">root</a><span>|</span><a href="#42711181">parent</a><span>|</span><a href="#42708718">next</a><span>|</span><label class="collapse" for="c-42712918">[-]</label><label class="expand" for="c-42712918">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This kind of breaks my mental model of major version bumps.<p>If you want, you can reset the revisions in a major version, as you could rename all modules and change the behavior of all functions, but that&#x27;s hardly a good idea. Revisions are not any different. If you give a revision a new meaning in a major version, it is going to be as confusing as giving a new implementation to a function: users upgrading will have to figure out why something has subtly changed, instead of a clear error that something has gone away.<p>&gt; The expectation here would be that a struct revision would be a minor version bump, correct?<p>We could make either minor and major versions (as described by semver) work. For example, if we want to allow new revisions to be minor versions, we could make it so every time you install a dependency, we automatically lock all structs it provides. This way, if a new version is out, you have to explicitly upgrade any new revision too.<p>Of course, you could also release a new major version of the library once you introduce a new revision and _that&#x27;s fine_. The goal is not to avoid major versions of the library that defines a struct, the goal is to avoid forcing its dependents to release major versions, which has a cascading effect in the ecosystem. Putting in Elixir terms, I want to be able to release Phoenix v2 without forcing LiveView to immediately become v2. LiveView should be able to stay on v1.x and say it supports both Phoenix v1 and v2 at once. But in most typed languages, if you change a field definition, it is game over.<p>The guarantees you need to provide are not that many: as long as two revisions overlap at one point in time, you can offer a better upgrading experience to everyone, instead of assuming *all code must be updated at once*.<p>Thanks for the convo!</div><br/></div></div></div></div></div></div><div id="42708718" class="c"><input type="checkbox" id="c-42708718" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#42708656">parent</a><span>|</span><a href="#42710369">prev</a><span>|</span><a href="#42704500">next</a><span>|</span><label class="collapse" for="c-42708718">[-]</label><label class="expand" for="c-42708718">[1 more]</label></div><br/><div class="children"><div class="content">I forgot to mention, the typical situation for these things for added elements is to add `_ex` or the like, which is not a great solution. You can see this in various places in Erlang, especially around erl_interface and related aspects.<p>On the flip side, what if you realize a data structure needs to remove elements? Say revision 2 adds a field, but revision 3 removes it?</div><br/></div></div></div></div><div id="42704500" class="c"><input type="checkbox" id="c-42704500" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42708656">prev</a><span>|</span><label class="collapse" for="c-42704500">[-]</label><label class="expand" for="c-42704500">[3 more]</label></div><br/><div class="children"><div class="content">Yea, this is an issue rather near and dear to my heart (due to pain).  I very much appreciate strong and safe types, but it tends to mean enormous pain when making small obvious fixes to past mistakes, and you <i>really</i> don&#x27;t want to block those.  It just makes everything harder in the long term.<p>As an up-front caveat for below: I don&#x27;t know Elixir in detail, so I&#x27;m approaching this as a general type&#x2F;lang-design issue.  And this is a bit stream-of-consciousness-y and I&#x27;m not really seeking any goal beyond maybe discussion.<p>---<p>Structural sub-typing with inference (or similar, e.g. perhaps something fancier with dependent types) seems like kinda the only real option, as you <i>need</i> to be able to adapt to whatever bowl of Hyrum Slaw[1] has been created when you weren&#x27;t looking.  Allowing code that is <i>still provably correct</i> to continue to work without modification seems like a natural fit, and for changes I&#x27;ve made it would fairly often mean &gt;90% of users would do absolutely nothing and simply get better safety and better behavior for free.  It might even be an <i>ideal</i> end state.<p>I kinda like the <i>ergonomics</i> of `revision 2` here, it&#x27;s clear what it&#x27;s doing and can provide tooling hints in a rather important and complicated situation... but tbh I&#x27;m just not sure how much this offers vs <i>actual structural typing</i>, e.g. just having an implicit revision per field.  With explicit revisions you can bundle interrelated changes (which is quite good, and doing this with types alone ~always requires some annoying ceremony), but it seems like you&#x27;ll also be forcing code to accept all of v2..N-1 to get the change in vN because they&#x27;re <i>not</i> independent.<p>The &quot;you must accept all intermediate changes&quot; part is in some ways natural, but you&#x27;ll also be (potentially) forcing it on your users, and&#x2F;or writing a lot of transitioning code to avoid constraining them.<p>I&#x27;m guessing this is mostly due to Elixir&#x27;s type system, and explicit versions are a pragmatic tradeoff?  A linear rather than combinatoric growth of generated types?<p>&gt;<i>It is unlikely - or shall we say, not advisable to - for a given application to depend on several revisions over a long period of time. They are meant to be transitory.</i><p>An <i>application</i>, yes - applications should migrate when they are able, and because they are usage-leaf-nodes they can do that without backwards compatibility concerns.  But any library that uses other libraries generally benefits from supporting as many versions as possible, to constrain the parent-library&#x27;s users as little as possible.<p>It&#x27;s exactly the same situation as you see in normal SAT-like dependency management: applications should pin versions for stability, libraries should try to allow as broad of a range as possible to avoid conflicts.<p>&gt;<i>Would downcasting actually be useful in practice? That is yet to be seen.</i><p>I would pretty-strongly assume both &quot;yes&quot; and &quot;it&#x27;s complicated&quot;.  For end-users directly touching those fields: yes absolutely, pick your level of risk and live with it!  This kind of thing is great for isolated workarounds and &quot;trust me, it&#x27;s fine&quot; scenarios, code has varying risk&#x2F;goals and that&#x27;s good.  Those happen all the time, even if nobody really likes them afterward.<p>But if those choices apply to <i>all</i> libraries using it in a project... well then it gets complicated.  Unless you know how all of them use it, <i>and they all agree</i>, you can&#x27;t safely make that decision.  Ruby has refinements which can at least somewhat deal with this, by restricting <i>when</i> those decisions apply, and Lisps with continuations have another kind of tool, but most popular languages do not... and I have no idea how possible either would be in Elixir.<p>---<p>All that probably summarizes as: if we could boil the ocean, would this be meaningfully different than structural typing with type inference, and no versioning?  It sounds like this might be a reasonable middle-ground for Elixir, but what about in general, when trying to apply this strategy to other languages?  And viewed through that lens, are there other structural typing tools worth looking at?<p>[1] <a href="https:&#x2F;&#x2F;en.wiktionary.org&#x2F;wiki&#x2F;Hyrum%27s_law" rel="nofollow">https:&#x2F;&#x2F;en.wiktionary.org&#x2F;wiki&#x2F;Hyrum%27s_law</a></div><br/><div id="42705431" class="c"><input type="checkbox" id="c-42705431" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#42704500">parent</a><span>|</span><a href="#42746636">next</a><span>|</span><label class="collapse" for="c-42705431">[-]</label><label class="expand" for="c-42705431">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the comments. Your questions at the end resonate a lot with what I have been asking myself!<p>&gt; Structural sub-typing with inference<p>Can we have structural sub-typing with inference that is relatively fast and will generate reasonable error reports? We have been bulking up the amount of inference for dynamic code in our system and sometimes the inferred types get quite large, which can make trouble shooting daunting. In any case, better inference is a win even without taking data evolution into account.<p>&gt; but tbh I&#x27;m just not sure how much this offers vs actual structural typing<p>The bulk of the work is definitely achieved by structural typing. The revisions help generate automated type signatures that guarantee you have not widened the output for old versions. If all you have is inference, you could accidentally introduce breaking changes?<p>I guess there may be some automated way where we could check old inferred types against new ones but I am not sure how it could be done without annotating that _something_ has changed?<p>&gt; The &quot;you must accept all intermediate changes&quot; part is in some ways natural, but you&#x27;ll also be (potentially) forcing it on your users, and&#x2F;or writing a lot of transitioning code to avoid constraining them.<p>Theoretically, you do not need to support all revisions, only support more than one revision at once. A library that provides r1-r2-r3 can be supported downstream through the pairs `r1-r2` and then `r2-r3` and that should hopefully provide a smoother upgrade experience to everyone compared to `r1`, `r2`, and `r3` being part of distinct major versions.</div><br/></div></div><div id="42746636" class="c"><input type="checkbox" id="c-42746636" checked=""/><div class="controls bullet"><span class="by">Vampiero</span><span>|</span><a href="#42704500">parent</a><span>|</span><a href="#42705431">prev</a><span>|</span><label class="collapse" for="c-42746636">[-]</label><label class="expand" for="c-42746636">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It just makes everything harder in the long term.<p>Opinions. I&#x27;d gladly refactor a C# legacy monster because I can follow the compiler errors and reason about the shape of the types and how they interact in an abstract, codeless way. I can modify 200+ files and not lose track of what I&#x27;m doing. I can apply the latest language features to make the code more concise and expressive while preserving the semantics. I can use my IDE to modify every single reference to some type or object across the entire solution in a couple of keystrokes without worrying that my search and replace regex will match something it shouldn&#x27;t. I can simplify and generalize redundancies. I can transform everything in my head and make sure it&#x27;s internally consistent. I can even use reflection to do advanced metaprogramming and make sure that it, too, is consistent (with a couple of tests). If it compiles, chances are it&#x27;s going to work.<p>The more static typing, the better, because that means that most of the logic is baked in the abstractions and I don&#x27;t have to run the debugger.<p>I would never refactor a legacy Javascript application because I&#x27;m not a masochist. There are many juniors who don&#x27;t yet know what a pain it is to work on large dynamic projects so I&#x27;ll let them have all the fun while I use my time productively. I haven&#x27;t done a null check in years (in my personal projects; at my workplace they don&#x27;t even know what an option type is).<p>But I&#x27;ll take Prolog. It&#x27;s dynamic, but unification is basically type theory anyway. You can declare all your constraints and reason about them clearly. As God intended for us applied mathematicians.<p>So your claim that static typing makes things harder in the long term is alien to me. The real issue is that companies are afraid of refactoring because the client doesn&#x27;t see the immediate benefit, so they simply don&#x27;t do it, and then 10 years later they just redo the project from scratch in the latest shiny language (while reinventing the whole domain mapping layer because the old engineers were probably idiots since they wrote such unmaintanable code -- let&#x27;s ignore the fact that they, too, never had time to refactor and dogfood).</div><br/></div></div></div></div></div></div></div></div></div></body></html>