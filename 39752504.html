<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710838876782" as="style"/><link rel="stylesheet" href="styles.css?v=1710838876782"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/microsoft/garnet">Garnet – A new remote cache-store from Microsoft Research</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>saganus</span> | <span>35 comments</span></div><br/><div><div id="39752798" class="c"><input type="checkbox" id="c-39752798" checked=""/><div class="controls bullet"><span class="by">west0n</span><span>|</span><a href="#39753613">next</a><span>|</span><label class="collapse" for="c-39752798">[-]</label><label class="expand" for="c-39752798">[21 more]</label></div><br/><div class="children"><div class="content">From the benchmark performance charts(<a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;garnet&#x2F;docs&#x2F;benchmarking&#x2F;results-resp-bench" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;garnet&#x2F;docs&#x2F;benchmarking&#x2F;results...</a>), the throughput of the GET command exceeds that of Dragonfly by more than tenfold. While 50% latency is slightly higher than Dragonfly, the 99th percentile is slightly lower than Dragonfly. Both the throughput and latency of Garnet and Dragonfly are far better than Redis, indicating that Redis may require a significant performance optimization.</div><br/><div id="39753198" class="c"><input type="checkbox" id="c-39753198" checked=""/><div class="controls bullet"><span class="by">hipadev23</span><span>|</span><a href="#39752798">parent</a><span>|</span><a href="#39752832">next</a><span>|</span><label class="collapse" for="c-39753198">[-]</label><label class="expand" for="c-39753198">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Redis may require a significant performance optimization.<p>Redis is single-threaded, it’s simple and effective. I’m not sure it needs optimization, and we have 3 alternatives here.<p>Garnet however is the first alternative to actually outperform Redis at both low and high levels of concurrency, which is remarkable. I can’t wait to try it out.</div><br/><div id="39753951" class="c"><input type="checkbox" id="c-39753951" checked=""/><div class="controls bullet"><span class="by">LeonidBugaev</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753198">parent</a><span>|</span><a href="#39753820">next</a><span>|</span><label class="collapse" for="c-39753951">[-]</label><label class="expand" for="c-39753951">[1 more]</label></div><br/><div class="children"><div class="content">Plus in production, with high load, Redis cluster is way more common, which kind of solve single-threaded concern.</div><br/></div></div><div id="39753820" class="c"><input type="checkbox" id="c-39753820" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753198">parent</a><span>|</span><a href="#39753951">prev</a><span>|</span><a href="#39752832">next</a><span>|</span><label class="collapse" for="c-39753820">[-]</label><label class="expand" for="c-39753820">[1 more]</label></div><br/><div class="children"><div class="content">Redis for 99% of the intended use-cases and companies will be just fine. It has always been rock solid when we used it. It was the opposite of DNS: it was never a problem.</div><br/></div></div></div></div><div id="39752832" class="c"><input type="checkbox" id="c-39752832" checked=""/><div class="controls bullet"><span class="by">west0n</span><span>|</span><a href="#39752798">parent</a><span>|</span><a href="#39753198">prev</a><span>|</span><a href="#39752834">next</a><span>|</span><label class="collapse" for="c-39752832">[-]</label><label class="expand" for="c-39752832">[3 more]</label></div><br/><div class="children"><div class="content">What surprises me the most is that this project is developed in C#, while Dragonfly is developed in C++, and Redis is in C.</div><br/><div id="39753229" class="c"><input type="checkbox" id="c-39753229" checked=""/><div class="controls bullet"><span class="by">amir734jj</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39752832">parent</a><span>|</span><a href="#39752834">next</a><span>|</span><label class="collapse" for="c-39753229">[-]</label><label class="expand" for="c-39753229">[2 more]</label></div><br/><div class="children"><div class="content">If you look at the store code you see a lot of &quot;unsafe&quot; C# code (i.e pointer manipulation)</div><br/><div id="39753790" class="c"><input type="checkbox" id="c-39753790" checked=""/><div class="controls bullet"><span class="by">zigzag312</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753229">parent</a><span>|</span><a href="#39752834">next</a><span>|</span><label class="collapse" for="c-39753790">[-]</label><label class="expand" for="c-39753790">[1 more]</label></div><br/><div class="children"><div class="content">Shows how flexible C# is.<p>You can trade high-level expressiveness for low-level control where needed and you don&#x27;t have to deal with any FFI to do it.</div><br/></div></div></div></div></div></div><div id="39752834" class="c"><input type="checkbox" id="c-39752834" checked=""/><div class="controls bullet"><span class="by">whimsicalism</span><span>|</span><a href="#39752798">parent</a><span>|</span><a href="#39752832">prev</a><span>|</span><a href="#39753613">next</a><span>|</span><label class="collapse" for="c-39752834">[-]</label><label class="expand" for="c-39752834">[14 more]</label></div><br/><div class="children"><div class="content">surprised to see a garbage collected language project (C# for Garnet) beat redis&#x2F;dragonfly</div><br/><div id="39753132" class="c"><input type="checkbox" id="c-39753132" checked=""/><div class="controls bullet"><span class="by">blackoil</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39752834">parent</a><span>|</span><a href="#39753036">next</a><span>|</span><label class="collapse" for="c-39753132">[-]</label><label class="expand" for="c-39753132">[8 more]</label></div><br/><div class="children"><div class="content">The investment in optimization in CLR or JVM can be huge as they impact millions of applications. While each C &#x2F; C++ code will have to be hand optimized.<p>Also limits on number of people in given time who can write optimal C code vs C# will also make managed code better.</div><br/><div id="39753614" class="c"><input type="checkbox" id="c-39753614" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753132">parent</a><span>|</span><a href="#39753317">next</a><span>|</span><label class="collapse" for="c-39753614">[-]</label><label class="expand" for="c-39753614">[3 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you just replace the CLR and JVM with llvm and gcc and then replace C with assembly and arrive at the same conclusion.</div><br/><div id="39753782" class="c"><input type="checkbox" id="c-39753782" checked=""/><div class="controls bullet"><span class="by">blackoil</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753614">parent</a><span>|</span><a href="#39753703">next</a><span>|</span><label class="collapse" for="c-39753782">[-]</label><label class="expand" for="c-39753782">[1 more]</label></div><br/><div class="children"><div class="content">Now commenting beyond my expertise, I understand both ecosystems have developed orthogonally, C#&#x2F;Java assumes code to be higher level and &quot;dumb&quot; and optimization are in library&#x2F;CLR&#x2F;JVM. While C&#x2F;C++ are developed with code at lower level and developer making sure code is optimized.<p>Now, I could be talking out of ass, haven&#x27;t done enough C&#x2F;C++ coding in over a decade.</div><br/></div></div><div id="39753703" class="c"><input type="checkbox" id="c-39753703" checked=""/><div class="controls bullet"><span class="by">Dumble</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753614">parent</a><span>|</span><a href="#39753782">prev</a><span>|</span><a href="#39753317">next</a><span>|</span><label class="collapse" for="c-39753703">[-]</label><label class="expand" for="c-39753703">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the person you are replying too, but I believe that of course, the pattern holds if you keep shifting it down. I.E. using a faster CPU will speed up all programs running on it, each (already optimized) ASIC has to be optimized further individually.</div><br/></div></div></div></div><div id="39753317" class="c"><input type="checkbox" id="c-39753317" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753132">parent</a><span>|</span><a href="#39753614">prev</a><span>|</span><a href="#39753036">next</a><span>|</span><label class="collapse" for="c-39753317">[-]</label><label class="expand" for="c-39753317">[4 more]</label></div><br/><div class="children"><div class="content">Plus that it&#x27;s easier to have unmanaged code in C# than in Java.</div><br/><div id="39753477" class="c"><input type="checkbox" id="c-39753477" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753317">parent</a><span>|</span><a href="#39753036">next</a><span>|</span><label class="collapse" for="c-39753477">[-]</label><label class="expand" for="c-39753477">[3 more]</label></div><br/><div class="children"><div class="content">Is it possible to have unmanaged code in Java at all…  or you mean linking libs and exposing them through Java API in the lang?</div><br/><div id="39753637" class="c"><input type="checkbox" id="c-39753637" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753477">parent</a><span>|</span><a href="#39753036">next</a><span>|</span><label class="collapse" for="c-39753637">[-]</label><label class="expand" for="c-39753637">[2 more]</label></div><br/><div class="children"><div class="content">Ah, I meant Java code manipulating off-heap memory. For Java I don&#x27;t think there&#x27;s a way to mix managed and unmanaged code like you do in C#&#x2F;C++ CLR.</div><br/><div id="39753676" class="c"><input type="checkbox" id="c-39753676" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753637">parent</a><span>|</span><a href="#39753036">next</a><span>|</span><label class="collapse" for="c-39753676">[-]</label><label class="expand" for="c-39753676">[1 more]</label></div><br/><div class="children"><div class="content">In C# you usually don&#x27;t want to mix in C++. Manipulating off-heap memory is indeed easy - nowadays pointers to both object interiors, stack and unmanaged memory can be represented as `ref T` where T is byte, int, etc.<p>These are then subsequently wrapped by `Span&lt;T&gt;` and `ReadOnlySpan&lt;T&gt;` respectively. This way a span can be a slice of memory that can have any origin:<p><pre><code>    var fromStack1 = (stackalloc byte[32]);
    var fromStack2 = (Span&lt;byte&gt;)[0x20, 0x20, 0x20, 0x20];
    var fromHeap = new byte[32].AsSpan();
    unsafe
    {
        var ptr = NativeMemory.Alloc(32);
        var fromMalloc = new Span&lt;byte&gt;(ptr, 32);
        &#x2F;&#x2F; Don&#x27;t forget to free :)
    }</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39753036" class="c"><input type="checkbox" id="c-39753036" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39752834">parent</a><span>|</span><a href="#39753132">prev</a><span>|</span><a href="#39753340">next</a><span>|</span><label class="collapse" for="c-39753036">[-]</label><label class="expand" for="c-39753036">[4 more]</label></div><br/><div class="children"><div class="content">I think it is rare, but isn&#x27;t impossible. I remember in the 2000&#x27;s watching someone do a demo of Java&#x2F;JVM beating the pants off a C++ application. If I remember correctly, it was something about how the JIT was doing an optimization that you would have had to write assembly in order to optimize it to the same level.</div><br/><div id="39753301" class="c"><input type="checkbox" id="c-39753301" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753036">parent</a><span>|</span><a href="#39753172">next</a><span>|</span><label class="collapse" for="c-39753301">[-]</label><label class="expand" for="c-39753301">[1 more]</label></div><br/><div class="children"><div class="content">There are at least two reasons I can think of why a JIT language with GC can outperform C&#x2F;c++:<p>1. Memory management with a GC often has higher throughput. With the downside that you can have high latency when a garbage collection occurs.<p>2. The JIT compilation can potentially do a better job of optimizing, because it has information about how the code has been run so far.<p>It is possible for c or c++ (or rust) to get get the first using alternative memory management strategies, and the second by hand optimizing, and&#x2F;or using profile guided optimization.</div><br/></div></div><div id="39753172" class="c"><input type="checkbox" id="c-39753172" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753036">parent</a><span>|</span><a href="#39753301">prev</a><span>|</span><a href="#39753340">next</a><span>|</span><label class="collapse" for="c-39753172">[-]</label><label class="expand" for="c-39753172">[2 more]</label></div><br/><div class="children"><div class="content">There were coding competition benchmarks at the time putting javac against the underdeveloped gcc 2.95 of the time. The trick they did with java programs was to allocate a region of memory only once and reuse that whenever they needed more, simulating a stack. Then the programs were benchmarked as hot start and cold start. Hot start timings were used to bench against C++ programs. If the algorithm they used was better, this sometimes resulted in head to head or better performance.</div><br/><div id="39753192" class="c"><input type="checkbox" id="c-39753192" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39753172">parent</a><span>|</span><a href="#39753340">next</a><span>|</span><label class="collapse" for="c-39753192">[-]</label><label class="expand" for="c-39753192">[1 more]</label></div><br/><div class="children"><div class="content">I remember that one too, but this one was not just the hot memory trick, which seems relatively easy. It was entirely JIT based, where the JIT happened to pick a better path than gcc.</div><br/></div></div></div></div></div></div><div id="39753340" class="c"><input type="checkbox" id="c-39753340" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#39752798">root</a><span>|</span><a href="#39752834">parent</a><span>|</span><a href="#39753036">prev</a><span>|</span><a href="#39753613">next</a><span>|</span><label class="collapse" for="c-39753340">[-]</label><label class="expand" for="c-39753340">[1 more]</label></div><br/><div class="children"><div class="content">Seems it wins by using more sophisticated data structures &amp; algorithms, instead of &quot;tight code&quot;.</div><br/></div></div></div></div></div></div><div id="39753613" class="c"><input type="checkbox" id="c-39753613" checked=""/><div class="controls bullet"><span class="by">KyleSanderson</span><span>|</span><a href="#39752798">prev</a><span>|</span><a href="#39752737">next</a><span>|</span><label class="collapse" for="c-39753613">[-]</label><label class="expand" for="c-39753613">[1 more]</label></div><br/><div class="children"><div class="content">Garnet’s storage layer, called Tsavorite, was forked from OSS FASTER, and includes strong database features such as thread scalability, tiered storage support (memory, SSD, and cloud storage), fast non-blocking checkpointing, recovery, operation logging for durability, multi-key transaction support, and better memory management and reuse.<p><a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;blog&#x2F;introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;blog&#x2F;introducing-ga...</a></div><br/></div></div><div id="39752737" class="c"><input type="checkbox" id="c-39752737" checked=""/><div class="controls bullet"><span class="by">lxe</span><span>|</span><a href="#39753613">prev</a><span>|</span><a href="#39753850">next</a><span>|</span><label class="collapse" for="c-39752737">[-]</label><label class="expand" for="c-39752737">[4 more]</label></div><br/><div class="children"><div class="content">A drop-in redis replacement with rather impressive latency and throughput bench figures. Wonder what its like to operate in a non-azure stack in the real world.</div><br/><div id="39753106" class="c"><input type="checkbox" id="c-39753106" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#39752737">parent</a><span>|</span><a href="#39753850">next</a><span>|</span><label class="collapse" for="c-39753106">[-]</label><label class="expand" for="c-39753106">[3 more]</label></div><br/><div class="children"><div class="content">Are you sure it is drop-in? I don&#x27;t see any indication of xstream support.</div><br/><div id="39753392" class="c"><input type="checkbox" id="c-39753392" checked=""/><div class="controls bullet"><span class="by">StepWeiwu</span><span>|</span><a href="#39752737">root</a><span>|</span><a href="#39753106">parent</a><span>|</span><a href="#39753850">next</a><span>|</span><label class="collapse" for="c-39753392">[-]</label><label class="expand" for="c-39753392">[2 more]</label></div><br/><div class="children"><div class="content">The title does say that it can work with existing redis clients but it&#x27;s unclear if they mean full compatibility.</div><br/><div id="39753430" class="c"><input type="checkbox" id="c-39753430" checked=""/><div class="controls bullet"><span class="by">vanhanenjjv</span><span>|</span><a href="#39752737">root</a><span>|</span><a href="#39753392">parent</a><span>|</span><a href="#39753850">next</a><span>|</span><label class="collapse" for="c-39753430">[-]</label><label class="expand" for="c-39753430">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;garnet&#x2F;docs&#x2F;commands&#x2F;api-compatibility" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;garnet&#x2F;docs&#x2F;commands&#x2F;api-compati...</a></div><br/></div></div></div></div></div></div></div></div><div id="39753850" class="c"><input type="checkbox" id="c-39753850" checked=""/><div class="controls bullet"><span class="by">cpressland</span><span>|</span><a href="#39752737">prev</a><span>|</span><a href="#39753445">next</a><span>|</span><label class="collapse" for="c-39753850">[-]</label><label class="expand" for="c-39753850">[1 more]</label></div><br/><div class="children"><div class="content">This looks really good. I hope ultimately this replaces the “Azure Cache for Redis” resource. It’s slow, it’s a fork of Redis made to run on Windows, and it takes nearly an hour to create an instance of it.</div><br/></div></div><div id="39753445" class="c"><input type="checkbox" id="c-39753445" checked=""/><div class="controls bullet"><span class="by">legulere</span><span>|</span><a href="#39753850">prev</a><span>|</span><a href="#39753600">next</a><span>|</span><label class="collapse" for="c-39753445">[-]</label><label class="expand" for="c-39753445">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Garnet’s storage layer, called Tsavorite, was forked from our prior open-source project FASTER<p>Would be interesting to know why it was forked, why the changes can&#x27;t be incorporated and wether FASTER continues to be developed</div><br/><div id="39753621" class="c"><input type="checkbox" id="c-39753621" checked=""/><div class="controls bullet"><span class="by">compressedgas</span><span>|</span><a href="#39753445">parent</a><span>|</span><a href="#39753600">next</a><span>|</span><label class="collapse" for="c-39753621">[-]</label><label class="expand" for="c-39753621">[1 more]</label></div><br/><div class="children"><div class="content">I tried to compare the source trees. They are nearly identical except for replacing Faster with Tsavorite which makes a direct comparison much harder as they renamed directories and files.</div><br/></div></div></div></div><div id="39753600" class="c"><input type="checkbox" id="c-39753600" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39753445">prev</a><span>|</span><a href="#39752792">next</a><span>|</span><label class="collapse" for="c-39753600">[-]</label><label class="expand" for="c-39753600">[1 more]</label></div><br/><div class="children"><div class="content">So what&#x27;s the catch, where this doesn&#x27;t perform well? Would be neat to see benchmarks on smaller instance types too, 72vcpu is quite chunky boi</div><br/></div></div><div id="39752792" class="c"><input type="checkbox" id="c-39752792" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#39753600">prev</a><span>|</span><a href="#39753381">next</a><span>|</span><label class="collapse" for="c-39752792">[-]</label><label class="expand" for="c-39752792">[1 more]</label></div><br/><div class="children"><div class="content">Definitely impressive, Microsoft Research comes out with some impressive projects from time to time, must be fun getting paid to do R&amp;D. I wish big companies did more R&amp;D style projects that benefit the industry in general. I sure hope a good company takes over Hashicorp if they&#x27;re on the market to be bought.</div><br/></div></div><div id="39753381" class="c"><input type="checkbox" id="c-39753381" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#39752792">prev</a><span>|</span><a href="#39753082">next</a><span>|</span><label class="collapse" for="c-39753381">[-]</label><label class="expand" for="c-39753381">[1 more]</label></div><br/><div class="children"><div class="content">I just wish they had something like this <i>embedded</i> into Azure App Service, so it wouldn&#x27;t be necessarily to use a <i>remote</i> service for caching.<p>For reference, something commonly used with IIS for ASP.NET apps was to have an out-of-process &quot;session state&quot; store, so that if the web app process restarted, users wouldn&#x27;t lose their sessions and have to log in from scratch. Sure, you can put this somewhere central like SQL Server, but then <i>every</i> web page request sits there waiting for the session state to load before it does any processing at all. Session state is also typically locked in some way, which has all sorts of performance issues.<p>The typical current solution is to use Redis for both caching and session state, and this works... okay-ish. Throughput is high, sure, but Redis is a separate resource in Azure and is stupidly expensive. I really don&#x27;t want to pay Oracle DB prices for something this simple. It&#x27;s also a bit of a hassle to wire up.<p>In this article they talk about 300 microsecond response times, but that&#x27;s irrelevant in any zone-redundant design because all Azure load balancers use random zone selection. So you&#x27;ll have a web server picked in a random zone, then it&#x27;ll contact a cache server in a random zone in turn. That server in turn may not have your key and have to contact yet another random zone to get your cache data! Your traffic ping-pongs between data centres. This introduces about 1-3ms of delays, up to 10x higher than the advertised numbers for Garnet.<p>The ideal scenario would be something like what Microsoft Service Fabric does: it has a &quot;reliable collections&quot;[1] service that runs <i>locally</i> on each host node and replicates to two other nodes. A web app can always read its cached values from the <i>same physical host</i>. The latency can be single-digit microseconds in some cases, which is thousands of times faster than any naively load balanced external service, no matter how well optimised.<p>I don&#x27;t want 30% faster than Redis. I want 3,000x faster.<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;service-fabric&#x2F;service-fabric-reliable-services-reliable-collections" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;service-fabric&#x2F;servi...</a></div><br/></div></div><div id="39753082" class="c"><input type="checkbox" id="c-39753082" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#39753381">prev</a><span>|</span><label class="collapse" for="c-39753082">[-]</label><label class="expand" for="c-39753082">[2 more]</label></div><br/><div class="children"><div class="content">After the aborted&#x2F;abandoned attempt to port redis to windows (0) this feels like a second-try at the same thing, but first party.<p>Of course, as a research project it doesn&#x27;t have the same stability &#x2F; support, etc. as redis, but I could easily imagine this rolling into a real product if it&#x27;s popular.<p>...and as an MIT license, if nothing else, the code is a fun read. :)<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoftarchive&#x2F;redis?tab=readme-ov-file#redis-on-windows">https:&#x2F;&#x2F;github.com&#x2F;microsoftarchive&#x2F;redis?tab=readme-ov-file...</a></div><br/><div id="39753612" class="c"><input type="checkbox" id="c-39753612" checked=""/><div class="controls bullet"><span class="by">mordae</span><span>|</span><a href="#39753082">parent</a><span>|</span><label class="collapse" for="c-39753612">[-]</label><label class="expand" for="c-39753612">[1 more]</label></div><br/><div class="children"><div class="content">MIT license, but with CLA.<p>It&#x27;s bizzare. What more rights could they possibly want on top of MIT to warrant CLA?</div><br/></div></div></div></div></div></div></div></div></div></body></html>