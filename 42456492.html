<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734858060859" as="style"/><link rel="stylesheet" href="styles.css?v=1734858060859"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.16elt.com/2024/09/25/first-book-of-byte-sized-tech/">Ideas from &quot;A Philosophy of Software Design&quot;</a> <span class="domain">(<a href="https://www.16elt.com">www.16elt.com</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>68 comments</span></div><br/><div><div id="42484896" class="c"><input type="checkbox" id="c-42484896" checked=""/><div class="controls bullet"><span class="by">gregfjohnson</span><span>|</span><a href="#42482729">next</a><span>|</span><label class="collapse" for="c-42484896">[-]</label><label class="expand" for="c-42484896">[3 more]</label></div><br/><div class="children"><div class="content">This short book is (IMHO) one of the best on software design.  To me the main point of the book is the importance of well-designed abstractions.  The &quot;surface area&quot; of a well-designed abstraction is small, easy to understand, and helpful as you reason through your code when you use it.  The underlying implementation may be deep and non-trivial, but you find that you don&#x27;t have any need to worry about the underlying internal details.<p>In short:<p>A beautifully designed abstraction is easy to understand and use.<p>It is so trustworthy that you don&#x27;t feel any need to worry about how it is implemented.<p>Finally, and most importantly, it enables you to reason with rigor and precision about the correctness of the code you are writing that makes use of it.</div><br/><div id="42484958" class="c"><input type="checkbox" id="c-42484958" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#42484896">parent</a><span>|</span><a href="#42482729">next</a><span>|</span><label class="collapse" for="c-42484958">[-]</label><label class="expand" for="c-42484958">[2 more]</label></div><br/><div class="children"><div class="content">That book is a almost perfect summary of what is in my head after 30+ years of programming. I recommend it often to new people, as I see they make the same mistakes I did back then.<p>I recommend not loosing time with “Clean X” books, but instead read this book. Also, as noted in other comments, you can only “get it” after some real experience, so it is important to practice an develop a “common sense” of programming.</div><br/><div id="42485011" class="c"><input type="checkbox" id="c-42485011" checked=""/><div class="controls bullet"><span class="by">karmakurtisaani</span><span>|</span><a href="#42484896">root</a><span>|</span><a href="#42484958">parent</a><span>|</span><a href="#42482729">next</a><span>|</span><label class="collapse" for="c-42485011">[-]</label><label class="expand" for="c-42485011">[1 more]</label></div><br/><div class="children"><div class="content">I disagree that the &quot;Clean X&quot; books are a waste of time. They lay a nice ground understanding of what to aim for when writing code, in particular when you&#x27;re early in your career.<p>When I was starting as a professional coder years ago, I had an intuitive sense of what good code was, but I had no idea how much actual thought had been put to it by other people. Reading those books was a good step in seriously starting to think about the subject and look at code differently as a craft (&quot;it&#x27;s not just me, this code smells!&quot; or &quot;hey that&#x27;s a neat idea, better keep this in mind&quot;).<p>Definitely would recommend to someone starting out their career.<p>Edit: getting downvoted for a reasonable, justified opinion. Classy.</div><br/></div></div></div></div></div></div><div id="42482729" class="c"><input type="checkbox" id="c-42482729" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#42484896">prev</a><span>|</span><a href="#42484823">next</a><span>|</span><label class="collapse" for="c-42482729">[-]</label><label class="expand" for="c-42482729">[43 more]</label></div><br/><div class="children"><div class="content">I come from an FP background, and this book was interesting to me as the author very clearly has a very different (imperative, systems) background. In some cases we have very different opinions, in some cases I&#x27;m completely agreed (e.g. &quot;define errors out of existence&quot; is extremely common in FP, usually under the term &quot;make illegal states unrepresentable&quot;), and in other cases I feel they were half-way to FP but couldn&#x27;t quite get all the way there (e.g. the editor example is a classic interpreter, but they didn&#x27;t make the connection IIRC.) I only skimmed the book and would like to go back for a more detailed review. Curious if anyone else with an FP background had the same or different experience.</div><br/><div id="42482986" class="c"><input type="checkbox" id="c-42482986" checked=""/><div class="controls bullet"><span class="by">Darmani</span><span>|</span><a href="#42482729">parent</a><span>|</span><a href="#42484222">next</a><span>|</span><label class="collapse" for="c-42482986">[-]</label><label class="expand" for="c-42482986">[9 more]</label></div><br/><div class="children"><div class="content">&quot;Define errors out of existence&quot; might sound like &quot;make illegal states unrepresentable,&quot; it&#x27;s actually not. Instead it&#x27;s a pastiche of ideas rather foreign to most FP readers, such as broadening the space of valid inputs of a function. One of his examples is changing the substr function to accept out of bounds ranges.<p>You might be interested in my review. I&#x27;m a Haskeller at heart, although the review draws more from my formal methods background. Spoiler: his main example of a deep module is actually shallow.<p><a href="https:&#x2F;&#x2F;www.pathsensitive.com&#x2F;2018&#x2F;10&#x2F;book-review-philosophy-of-software.html" rel="nofollow">https:&#x2F;&#x2F;www.pathsensitive.com&#x2F;2018&#x2F;10&#x2F;book-review-philosophy...</a></div><br/><div id="42483305" class="c"><input type="checkbox" id="c-42483305" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482986">parent</a><span>|</span><a href="#42483076">next</a><span>|</span><label class="collapse" for="c-42483305">[-]</label><label class="expand" for="c-42483305">[4 more]</label></div><br/><div class="children"><div class="content">Does Ousterhout actually say modules must always have a longer implementation than their spec, or just that this is a generally desirable feature?<p>If he did, I agree with you, he was wrong about that. I also agree that the unix file API is probably not a good example.<p>But whether or not he did, I think the dissection of edge cases would be better off emphasizing that he&#x27;s got something importantly right that goes against the typical &quot;small modules&quot; dogma. All else being equal, deeper modules are good--making too many overly small modules creates excessive integration points and reduces the advantages of modularity.<p>P.S. While I&#x27;m here, this is not really in response to the parent post, but the example in the article really does not do justice to Ousterhout&#x27;s idea. While he does advocate sometimes just inlining code and criticizes the pervasive idea that you should shorten any method of more than n lines, the idea of deep modules involves more than just inlinining code.</div><br/><div id="42483815" class="c"><input type="checkbox" id="c-42483815" checked=""/><div class="controls bullet"><span class="by">Darmani</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483305">parent</a><span>|</span><a href="#42483558">next</a><span>|</span><label class="collapse" for="c-42483815">[-]</label><label class="expand" for="c-42483815">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say he&#x27;s in between — he strongly recommends that most modules be &quot;deep.&quot;<p>I agree that blindly making lots of tiny things is bad, but his criteria for how to chunk modules is flawed.</div><br/></div></div><div id="42483558" class="c"><input type="checkbox" id="c-42483558" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483305">parent</a><span>|</span><a href="#42483815">prev</a><span>|</span><a href="#42483076">next</a><span>|</span><label class="collapse" for="c-42483558">[-]</label><label class="expand" for="c-42483558">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Does Ousterhout actually say modules must always have a longer implementation than their spec, or just that this is a generally desirable feature?<p>I mean the spec is a lower bound on the size of the solution, right? Because if the solution were shorter than the spec, you could just use the solution as the new shorter spec.</div><br/><div id="42483797" class="c"><input type="checkbox" id="c-42483797" checked=""/><div class="controls bullet"><span class="by">Darmani</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483558">parent</a><span>|</span><a href="#42483076">next</a><span>|</span><label class="collapse" for="c-42483797">[-]</label><label class="expand" for="c-42483797">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. The implementation is very often more defined than the specific. If the implementation is the spec, then it means that even the smallest change in behavior may break callers.</div><br/></div></div></div></div></div></div><div id="42483076" class="c"><input type="checkbox" id="c-42483076" checked=""/><div class="controls bullet"><span class="by">alpinisme</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482986">parent</a><span>|</span><a href="#42483305">prev</a><span>|</span><a href="#42483154">next</a><span>|</span><label class="collapse" for="c-42483076">[-]</label><label class="expand" for="c-42483076">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t looked at the substr function but is that not similar to how you can `take 5 [1,2,3]` or `zip [1,2,3] [‘a’, ‘b’, ‘c’, ‘d’]`</div><br/></div></div><div id="42483154" class="c"><input type="checkbox" id="c-42483154" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482986">parent</a><span>|</span><a href="#42483076">prev</a><span>|</span><a href="#42483550">next</a><span>|</span><label class="collapse" for="c-42483154">[-]</label><label class="expand" for="c-42483154">[2 more]</label></div><br/><div class="children"><div class="content">Nice and seemingly balanced review.<p>Defining errors out of existence should be mandatory for all golang programs.</div><br/><div id="42484654" class="c"><input type="checkbox" id="c-42484654" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483154">parent</a><span>|</span><a href="#42483550">next</a><span>|</span><label class="collapse" for="c-42484654">[-]</label><label class="expand" for="c-42484654">[1 more]</label></div><br/><div class="children"><div class="content">err, are you serious, sir?</div><br/></div></div></div></div><div id="42483550" class="c"><input type="checkbox" id="c-42483550" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482986">parent</a><span>|</span><a href="#42483154">prev</a><span>|</span><a href="#42484222">next</a><span>|</span><label class="collapse" for="c-42483550">[-]</label><label class="expand" for="c-42483550">[1 more]</label></div><br/><div class="children"><div class="content">Your review is great! But I think the idea that it’s in opposition to PoSD is not right, I think it’s a further development and elaboration in the same direction of PoSD</div><br/></div></div></div></div><div id="42484222" class="c"><input type="checkbox" id="c-42484222" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#42482729">parent</a><span>|</span><a href="#42482986">prev</a><span>|</span><a href="#42483364">next</a><span>|</span><label class="collapse" for="c-42484222">[-]</label><label class="expand" for="c-42484222">[1 more]</label></div><br/><div class="children"><div class="content">I read most of the book a couple years ago, and I thought it was very good.  I wonder if you (or anyone else) can recommend an alternative book that does a better job of describing your perspective?</div><br/></div></div><div id="42483364" class="c"><input type="checkbox" id="c-42483364" checked=""/><div class="controls bullet"><span class="by">zusammen</span><span>|</span><a href="#42482729">parent</a><span>|</span><a href="#42484222">prev</a><span>|</span><a href="#42482843">next</a><span>|</span><label class="collapse" for="c-42483364">[-]</label><label class="expand" for="c-42483364">[1 more]</label></div><br/><div class="children"><div class="content">I read a few chapters and had the same feeling.</div><br/></div></div><div id="42482843" class="c"><input type="checkbox" id="c-42482843" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42482729">parent</a><span>|</span><a href="#42483364">prev</a><span>|</span><a href="#42484823">next</a><span>|</span><label class="collapse" for="c-42482843">[-]</label><label class="expand" for="c-42482843">[31 more]</label></div><br/><div class="children"><div class="content">I thought the book was stupid. Rehashed a bunch of obvious ideas. It’s a bit harsh, I know, but that’s my honest opinion and I respect other people who like his book.<p>I too have a fp background and I felt the author is unqualified to talk about complexity without knowing fp. Elimination of procedures and mutations is a formal and concrete reduction of complexity while the authors definition of complexity is hand wavy. Someone should know about what fp is before writing a book like this.<p>Why? Because fp is a basically like a formal structure for software design and the author tried to talk about philosophy without knowing some hard formal rules that are well known in the industry. Not saying these rules are absolute but you can’t talk about design without talking about this.<p>The book talks about modularity and things of that nature too and totally skips out on understanding the separation between statefulness and logic. The author completely misses this design concept of how how IO and mutation should be separated from declarative operations. Imperative shell&#x2F;functional core is a central design philosophy that he doesn’t touch upon. The book is woefully incomplete without talking about this. Whether the authors philosophy aligns with it is open for debate but you can’t talk about what he talks about without mentioning this in a big way.</div><br/><div id="42483059" class="c"><input type="checkbox" id="c-42483059" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482843">parent</a><span>|</span><a href="#42483897">next</a><span>|</span><label class="collapse" for="c-42483059">[-]</label><label class="expand" for="c-42483059">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Someone should know about what fp is before writing a book like this.<p>1. Are you quite sure John Ousterhout (who invented Tcl[1], comparing it to Lisp in section 7 of the original paper) doesn&#x27;t &quot;know about what fp is&quot; as you say?<p>2. Do you think that the main reason functional programming hasn&#x27;t taken off in systems programming is that practitioners are ignorant, or do you think there might be issues with fp systems that prevent its adoption?<p>[1] <a href="https:&#x2F;&#x2F;web.stanford.edu&#x2F;~ouster&#x2F;cgi-bin&#x2F;papers&#x2F;tcl-usenix.pdf" rel="nofollow">https:&#x2F;&#x2F;web.stanford.edu&#x2F;~ouster&#x2F;cgi-bin&#x2F;papers&#x2F;tcl-usenix.p...</a></div><br/><div id="42483073" class="c"><input type="checkbox" id="c-42483073" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483059">parent</a><span>|</span><a href="#42483897">next</a><span>|</span><label class="collapse" for="c-42483073">[-]</label><label class="expand" for="c-42483073">[2 more]</label></div><br/><div class="children"><div class="content">The book needs to talk about those issues and trade offs.<p>Fp with lisp is only a fraction of fp. I of course am talking more along the lines of pure fp which lisp is not.</div><br/><div id="42483207" class="c"><input type="checkbox" id="c-42483207" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483073">parent</a><span>|</span><a href="#42483897">next</a><span>|</span><label class="collapse" for="c-42483207">[-]</label><label class="expand" for="c-42483207">[1 more]</label></div><br/><div class="children"><div class="content">Sure, fp in Lisp might not always be true (scotsman) fp. ;-)<p>But omitting fp in the book is not evidence that Ousterhout is ignorant of fp, and there is certainly evidence to the contrary.<p>The likely explanation, given that he&#x27;s developed a number of systems from Sprite to Tcl&#x2F;Tk to RAMCloud to HOMA, is that he is addressing the current practice of systems programming, which remains primarily imperative.</div><br/></div></div></div></div></div></div><div id="42483897" class="c"><input type="checkbox" id="c-42483897" checked=""/><div class="controls bullet"><span class="by">rubiquity</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482843">parent</a><span>|</span><a href="#42483059">prev</a><span>|</span><a href="#42483163">next</a><span>|</span><label class="collapse" for="c-42483897">[-]</label><label class="expand" for="c-42483897">[1 more]</label></div><br/><div class="children"><div class="content">FP weenies gone wild 2024. You design web apps with monads. Ousterhout has made systems of actual consequence where mutation is a reality not a fantasy you try to pretend doesn’t exist.</div><br/></div></div><div id="42483163" class="c"><input type="checkbox" id="c-42483163" checked=""/><div class="controls bullet"><span class="by">kfreds</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482843">parent</a><span>|</span><a href="#42483897">prev</a><span>|</span><a href="#42483137">next</a><span>|</span><label class="collapse" for="c-42483163">[-]</label><label class="expand" for="c-42483163">[4 more]</label></div><br/><div class="children"><div class="content">The book plainly states that it is a philosophy for software design. Philosophy in this context is closely related to strategy, which is the art of reducing reality to heuristics, so that we might easier figure out how to reach our goals in a complex environment.<p>If the book had been titled &quot;Formal methods for software design&quot; the lack of algorithms for reducing complexity would have been surprising. As it is about philosophy it should not be surprising that it focuses on heuristics.</div><br/><div id="42483188" class="c"><input type="checkbox" id="c-42483188" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483163">parent</a><span>|</span><a href="#42483137">next</a><span>|</span><label class="collapse" for="c-42483188">[-]</label><label class="expand" for="c-42483188">[3 more]</label></div><br/><div class="children"><div class="content">Applying formal methods derived from functional programming is a design heuristic.<p>It’s a core heuristic and philosophy that is foundational in my opinion. The author failing to mention this makes the book missing a fundamental issue central to software design.</div><br/><div id="42483350" class="c"><input type="checkbox" id="c-42483350" checked=""/><div class="controls bullet"><span class="by">kfreds</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483188">parent</a><span>|</span><a href="#42483137">next</a><span>|</span><label class="collapse" for="c-42483350">[-]</label><label class="expand" for="c-42483350">[2 more]</label></div><br/><div class="children"><div class="content">Well put. This comment makes your criticism of the book much more clear to me at least.<p>I agree with you that the separation of Church and state is a foundational idea of software design and even computing generally. I find it quite beautiful how it manifests in hardware as the two categories of digital logic - combinatorial and sequential. And if we zoom in on the logical expression of memory we see it again - a latch is simply two feedback loops and some combinational logic.<p>For what it&#x27;s worth I thought the book was brilliant. Its ideas weren&#x27;t all obvious to me before I read it. It also inspired me to read Parnas, Wirth, Hoare, and study the Go runtime and compiler.<p>What should be obvious is this: the fact that the ideas were obvious to you doesn&#x27;t mean they are obvious to everyone.<p>Secondly, complexity has many meanings. Managing complexity is incredibly important in the realm of security. I&#x27;ve been dabbling in security for 25 years, but I would certainly not claim to have a deep understanding of functional programming. Nevertheless I understand complexity quite well. I think that&#x27;s what bothered me the most about your original comment - the idea that people without a background in FP are unqualified to talk about complexity.</div><br/><div id="42484977" class="c"><input type="checkbox" id="c-42484977" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483350">parent</a><span>|</span><a href="#42483137">next</a><span>|</span><label class="collapse" for="c-42484977">[-]</label><label class="expand" for="c-42484977">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would certainly not claim to have a deep understanding of functional programming.<p>From a philosophy-of-complexity perspective it&#x27;s not needed, all you need to ask is: will my code give the same output given the same input?  (And if not, there&#x27;s your complexity!)<p>Of course, this is a <i>big ask</i> of a programmer.  Leaving determinism up to the programmer in an imperative setting is like leaving memory-safety up to the programmer in a C setting.</div><br/></div></div></div></div></div></div></div></div><div id="42483137" class="c"><input type="checkbox" id="c-42483137" checked=""/><div class="controls bullet"><span class="by">vendiddy</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482843">parent</a><span>|</span><a href="#42483163">prev</a><span>|</span><a href="#42483045">next</a><span>|</span><label class="collapse" for="c-42483137">[-]</label><label class="expand" for="c-42483137">[3 more]</label></div><br/><div class="children"><div class="content">I too write FP code but I found this book very valuable in how he treats complexity and his concept of &quot;deep modules&quot;.<p>I acknowledge that he does not cover purity and mutations as a source of complexity (and they are big sources of complexity) but I don&#x27;t think that merits dismissing the entire book on those grounds.</div><br/><div id="42483174" class="c"><input type="checkbox" id="c-42483174" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483137">parent</a><span>|</span><a href="#42483045">next</a><span>|</span><label class="collapse" for="c-42483174">[-]</label><label class="expand" for="c-42483174">[2 more]</label></div><br/><div class="children"><div class="content">I’m not dismissing the entire book. It has merit in what it mentions but it’s missing core foundational concepts.<p>Because it misses these concepts the book isn’t good in my opinion.</div><br/><div id="42483947" class="c"><input type="checkbox" id="c-42483947" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483174">parent</a><span>|</span><a href="#42483045">next</a><span>|</span><label class="collapse" for="c-42483947">[-]</label><label class="expand" for="c-42483947">[1 more]</label></div><br/><div class="children"><div class="content">In what ways could these concepts be discussed in the structure of the book in terms of currently prevalent programming practices?</div><br/></div></div></div></div></div></div><div id="42483045" class="c"><input type="checkbox" id="c-42483045" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482843">parent</a><span>|</span><a href="#42483137">prev</a><span>|</span><a href="#42483044">next</a><span>|</span><label class="collapse" for="c-42483045">[-]</label><label class="expand" for="c-42483045">[11 more]</label></div><br/><div class="children"><div class="content">If this is so stupid and obvious, why does apparently 99.99% of software designed by professional engineers seem to be designed by people completely oblivious to these ideas and considerations?<p>Following these philosophical principles themselves- it seems like a simpler and more accessible treatment of these ideas would be vastly more effective then a more rigorous and complete one- because the ideas are indeed simple.</div><br/><div id="42483087" class="c"><input type="checkbox" id="c-42483087" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483045">parent</a><span>|</span><a href="#42483044">next</a><span>|</span><label class="collapse" for="c-42483087">[-]</label><label class="expand" for="c-42483087">[10 more]</label></div><br/><div class="children"><div class="content">&gt; If this is so stupid and obvious, why does apparently 99.99% of software designed by professional engineers seem to be designed by people completely oblivious to these ideas and considerations?<p>It’s similar to why a big portion of the world believes in Christianity and another portion believes in Buddhism. Basically only one or none of these religions is correct rendering at least one population of people believing in a completely made up fantasy concept.<p>Much of what is preached in software is religion and what is preached by the majority can be completely ludicrous. The majority  believing or not knowing something doesn’t mean anything.</div><br/><div id="42484345" class="c"><input type="checkbox" id="c-42484345" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483087">parent</a><span>|</span><a href="#42483228">next</a><span>|</span><label class="collapse" for="c-42484345">[-]</label><label class="expand" for="c-42484345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s similar to why a big portion of the world believes in Christianity and another portion believes in Buddhism. Basically only one or none of these religions is correct rendering at least one population of people believing in a completely made up fantasy concept.<p>You have picked religions with as little as possible in common. It would be rather different if you had picked any two monotheistic religions for example: one could be entirely right, and that would mean the other was partially or mostly right.. Despite your choice, there are many things in common: a path to redemption, monasticism, wealth being a barrier to redemption, meditation and mysticism... its quite possible those common elements might be right.<p>The same with software. Some things that are widely believed may be true and other false.</div><br/></div></div><div id="42483228" class="c"><input type="checkbox" id="c-42483228" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483087">parent</a><span>|</span><a href="#42484345">prev</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42483228">[-]</label><label class="expand" for="c-42483228">[7 more]</label></div><br/><div class="children"><div class="content">Religious “truths” are not factual truths- they are better thought of as psychological technology or techniques, and are “true” if they work for the intended purpose. Many conflicting religious “truths” are all “true.” Even calling them truths is only done to make the religions accessible to people that can’t mentally process nuance, and the techniques only work for them if labeled as truth. Intelligent religious scholars understand this well- for example Mahayana and Vajrayana Buddhism both teach nearly opposite and factually incompatible perspectives on almost everything, yet are often both used by the same religious teachers for different pupils as appropriate.<p>The same is true for software design- an approach is not literally true or false, but either works for its intended purpose or does not. Conflicting philosophies can both be “true” just with different underlying goals or values.<p>To circle back here, my point is that this information is presented in a simple way that will let people reading it design better software. Saying they have no right to present it without a much less accessible and more complex framework that would likely make it less useful to the intended audience does not make sense to me.<p>FWIW, I am also a functional  programmer, but would love to see people that are not follow some of these ideas.</div><br/><div id="42484052" class="c"><input type="checkbox" id="c-42484052" checked=""/><div class="controls bullet"><span class="by">drdeca</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483228">parent</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42484052">[-]</label><label class="expand" for="c-42484052">[6 more]</label></div><br/><div class="children"><div class="content">1 Corinthians 15:13-19 (NIV) : “ If there is no resurrection of the dead, then not even Christ has been raised. And if Christ has not been raised, our preaching is useless and so is your faith. More than that, we are then found to be false witnesses about God, for we have testified about God that he raised Christ from the dead. But he did not raise him if in fact the dead are not raised. For if the dead are not raised, then Christ has not been raised either. And if Christ has not been raised, your faith is futile; you are still in your sins. Then those also who have fallen asleep in Christ are lost. If only for this life we have hope in Christ, we are of all people most to be pitied.”<p>——<p>There is only one kind of truth. “All truths are God’s truths.”<p>If Christianity is not true, then it is false. If Christianity and Buddhism strictly contradict each-other, then at most one of them is true.<p>Christianity is not meant to be a, what, psychological trick? It makes claims, and these claims should be believed if true and disbelieved if false.</div><br/><div id="42484253" class="c"><input type="checkbox" id="c-42484253" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42484052">parent</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42484253">[-]</label><label class="expand" for="c-42484253">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s no trick, it&#x27;s a spiritual path that can&#x27;t be understood without following and practicing it- the path very much leads to something real that cannot be experienced or explained any other way. Everything Christianity teaches is true in the sense that I mean here. You are not understanding what I am saying and I do not personally know how to explain it more clearly[1], which, as I explained above, is why religions pragmatically also offer this view you hold as the official explanation to lay people, despite being obvious nonsense as an objective truth to anyone that thinks very hard about it.<p>I posit almost all intelligent monastics and religious people are smart enough to tell the difference between objective truth and religious truth- but it is taboo to explain this to lay people as they will be confused and think it means the religion is &quot;fake&quot; or a &quot;trick&quot;, however I don&#x27;t feel the need to respect said taboo. Perhaps I will learn to respect it by trying to explain it to people unsuccessfully.<p>[1] David Chapman may be able to: <a href="https:&#x2F;&#x2F;vividness.live&#x2F;visionary-and-objective-truths" rel="nofollow">https:&#x2F;&#x2F;vividness.live&#x2F;visionary-and-objective-truths</a></div><br/><div id="42484360" class="c"><input type="checkbox" id="c-42484360" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42484253">parent</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42484360">[-]</label><label class="expand" for="c-42484360">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I posit almost all intelligent monastics and religious people are smart enough to tell the difference between objective truth and religious truth- but it is taboo to explain this to lay people as they will be confused and think it means the religion is &quot;fake&quot; or a &quot;trick&quot;, however I don&#x27;t feel the need to respect said taboo.<p>That is positing a conspiracy theory level of deception.<p>At least as far as Christianity goes, the &quot;intelligent monastics and religious people&quot; write down their beliefs, and have done so for millennia, and they read each others writings. What you suggest might be possible with an oral tradition, but not with a written one. Christianity is very much concerned with objective truth, and one of the distinguishing characters of it (and some other religions too) is a belief that there is an objective truth.</div><br/><div id="42484399" class="c"><input type="checkbox" id="c-42484399" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42484360">parent</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42484399">[-]</label><label class="expand" for="c-42484399">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s no great conspiracy for a religion to have tiers of understanding and nuance reserved for people more intelligent and dedicated in practice- that is one key purpose of having a distinction between lay people and monastics. The mystique of this is openly part of the draw for people to sign up for it.<p>There&#x27;s no deception- it&#x27;s something that (as this discussion shows) is very subtle and dangerous to the religions when misunderstood- but not dangerous when understood correctly. It is written down repeatedly in religious texts, in a subtle way with plausible deniability, but clear to those that can read between the lines. Writing in that way was the essential basic art of any intellectual until very recently, it is only now (sort of) safe to plainly state nuanced philosophical and religious concepts without facing persecution. Nietzsche argued you still should not do so even if you can.<p>It&#x27;s also both quite obvious and relatively unimportant on its own to people that would be capable of understanding nuance, and could be quite harmful to the faith and the stability of the religion of those not able to understand.</div><br/><div id="42484435" class="c"><input type="checkbox" id="c-42484435" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42484399">parent</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42484435">[-]</label><label class="expand" for="c-42484435">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It is written down repeatedly in religious texts, in a subtle way with plausible deniability, but clear to those that can read between the lines.<p>Can you give me an example of what you mean? From Christianity, as its the religion I know most about.</div><br/><div id="42484537" class="c"><input type="checkbox" id="c-42484537" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42484435">parent</a><span>|</span><a href="#42483301">next</a><span>|</span><label class="collapse" for="c-42484537">[-]</label><label class="expand" for="c-42484537">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a scholar of Christian literature (or a Christian), and I don&#x27;t speak Latin, so it would hardly be appropriate for me to pull out a specific quote and insist &quot;this is what they really meant.&quot; In truth, my original source for this was my own understanding being raised in a Christian church- and voicing this perspective out loud in church as a young kid didn&#x27;t go over well, as you might imagine. To me as a young kid, it was immediately obvious that there were deeper ethical principles being explained in these stories, and one had to be an idiot to be worried about if they were objective factual details or not, when the point was clearly to understand and embody the message- to practice and live it. One was called to have faith that living these principles wholeheartedly was the right thing to do and would lead to real spiritual growth, not to have faith that some particular guy built a particular boat- such things are irrelevant.<p>However St. Augustine is someone that I am particularly certain had a clear understanding of this, and I can see it in how he frames most of his ideas.<p>Another example, would be that ancient religious texts are not careful at all to avoid making numerous objectively factual contradictions- as the anti-christian crowd loves to point out over and over while also completely missing the point. If the people writing them thought that was important, they would have avoided doing so- contrary to modern opinion, ancient theologians and philosophers like St. Augustine were not idiots.<p>William Blake is a more modern person that, while just about the furthest thing from a monastic, clearly had a deep understanding of what I am talking about. Carl Jung also extensively understood and discussed a lot of esoteric things in Christianity including this, and wrote about them in a relatively clear modern way.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42483301" class="c"><input type="checkbox" id="c-42483301" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483087">parent</a><span>|</span><a href="#42483228">prev</a><span>|</span><a href="#42483044">next</a><span>|</span><label class="collapse" for="c-42483301">[-]</label><label class="expand" for="c-42483301">[1 more]</label></div><br/><div class="children"><div class="content">Good explanation, really. Imperative systems programmers reject one or more of the fp commandments (perhaps finding them impractical), and are probably heretics in the eyes of the fp cult.</div><br/></div></div></div></div></div></div><div id="42483044" class="c"><input type="checkbox" id="c-42483044" checked=""/><div class="controls bullet"><span class="by">shinycode</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42482843">parent</a><span>|</span><a href="#42483045">prev</a><span>|</span><a href="#42484823">next</a><span>|</span><label class="collapse" for="c-42483044">[-]</label><label class="expand" for="c-42483044">[8 more]</label></div><br/><div class="children"><div class="content">Interested if you can give other books&#x2F;resources on the subject (not fp though)</div><br/><div id="42483115" class="c"><input type="checkbox" id="c-42483115" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483044">parent</a><span>|</span><a href="#42483151">next</a><span>|</span><label class="collapse" for="c-42483115">[-]</label><label class="expand" for="c-42483115">[6 more]</label></div><br/><div class="children"><div class="content">Can’t because fp is in itself basically a design philosophy that can be explained in 3 axioms.<p>Segregate mutation from logic<p>Segregate IO from logic<p>Eliminate procedures from logic.<p>The third axiom is sort of for free as it falls out automatically when someone enforces the first two. That’s basically imperative shell&#x2F;functional core design philosophy which is basically identical to the rules of pure functional programming.<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;ssense-tech&#x2F;a-look-at-the-functional-core-and-imperative-shell-pattern-be2498da153a" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;ssense-tech&#x2F;a-look-at-the-functional-core...</a><p>With fp you can think of these rules enforced as a language. Outside of fp we call it functional core &#x2F; imperative shell and these rules can be enforced in an imperative language as a core design philosophy.</div><br/><div id="42484257" class="c"><input type="checkbox" id="c-42484257" checked=""/><div class="controls bullet"><span class="by">analog31</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483115">parent</a><span>|</span><a href="#42483375">next</a><span>|</span><label class="collapse" for="c-42484257">[-]</label><label class="expand" for="c-42484257">[2 more]</label></div><br/><div class="children"><div class="content">I also found this useful. I&#x27;m not a software developer, but use programming for problem solving and prototyping. Still, things that &quot;look like software&quot; sometimes leak out of my lab. FP always set off my BS alarm, because in my simplistic view, <i>the whole world has state</i>. But even for my crude work, a sort of &quot;separation of powers&quot; helps clean up my programs a lot, and code that doesn&#x27;t <i>need</i> to have side effects can be a lot cleaner if it&#x27;s not mixed with code that does.</div><br/><div id="42484586" class="c"><input type="checkbox" id="c-42484586" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42484257">parent</a><span>|</span><a href="#42483375">next</a><span>|</span><label class="collapse" for="c-42484586">[-]</label><label class="expand" for="c-42484586">[1 more]</label></div><br/><div class="children"><div class="content">FP does not deny state, it merely segregate it between the before and the after, and everything that is in between is transient. Then you combine all the individual functions, piping them into each other and the whole reflect the same structure. Then, it becomes easier to reason about your logic as you only have two worry about 2 states: the input and the result. No need to care about individual transformations and ordering like you do in imperative.</div><br/></div></div></div></div><div id="42483375" class="c"><input type="checkbox" id="c-42483375" checked=""/><div class="controls bullet"><span class="by">kfreds</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483115">parent</a><span>|</span><a href="#42484257">prev</a><span>|</span><a href="#42484124">next</a><span>|</span><label class="collapse" for="c-42483375">[-]</label><label class="expand" for="c-42483375">[2 more]</label></div><br/><div class="children"><div class="content">Thank you. I found this comment illuminating. I too am very interested to hear any book recommendations you have on the topic.<p>What are your favorite books on software design, functional programming, and&#x2F;or computing generally? What are your favorite papers on the topic of complexity (as FP defines it)?</div><br/><div id="42484583" class="c"><input type="checkbox" id="c-42484583" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483375">parent</a><span>|</span><a href="#42484124">next</a><span>|</span><label class="collapse" for="c-42484583">[-]</label><label class="expand" for="c-42484583">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Domain Modeling Made Functional&quot; is a great read and sits next to a lot of these topics. Very easy to follow and learn from even if you don&#x27;t know (and never intend to use) the language.</div><br/></div></div></div></div><div id="42484124" class="c"><input type="checkbox" id="c-42484124" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483115">parent</a><span>|</span><a href="#42483375">prev</a><span>|</span><a href="#42483151">next</a><span>|</span><label class="collapse" for="c-42484124">[-]</label><label class="expand" for="c-42484124">[1 more]</label></div><br/><div class="children"><div class="content">I would like to echo the user kfreds sibling comment. I don&#x27;t have a FP background either and hence would very much like to hear your recommendations on books&#x2F;videos&#x2F;articles to understand FP and design the &quot;FP way&quot;.</div><br/></div></div></div></div><div id="42483151" class="c"><input type="checkbox" id="c-42483151" checked=""/><div class="controls bullet"><span class="by">vendiddy</span><span>|</span><a href="#42482729">root</a><span>|</span><a href="#42483044">parent</a><span>|</span><a href="#42483115">prev</a><span>|</span><a href="#42484823">next</a><span>|</span><label class="collapse" for="c-42483151">[-]</label><label class="expand" for="c-42483151">[1 more]</label></div><br/><div class="children"><div class="content">I disagree with the op and found the book to be very good. If you haven&#x27;t read it, I would recommend reading it and judging for yourself.</div><br/></div></div></div></div></div></div></div></div><div id="42484823" class="c"><input type="checkbox" id="c-42484823" checked=""/><div class="controls bullet"><span class="by">abcde777666</span><span>|</span><a href="#42482729">prev</a><span>|</span><a href="#42484522">next</a><span>|</span><label class="collapse" for="c-42484823">[-]</label><label class="expand" for="c-42484823">[2 more]</label></div><br/><div class="children"><div class="content">A lot of these types of books and posts only deal with the low hanging fruits of software design difficulty, such as the provided discount service example.<p>The trouble is that kind of thing&#x27;s pretty much software development common sense - only the inexperienced don&#x27;t know it.<p>The true difficulties of software development are often must gnarlier in my experience.<p>For instance, making architectural choices for large and dynamic software systems, such as say a cutting edge game engine - that can be really hard to get right, and there&#x27;s not always a lot of sage advice out there for how to navigate it - and not just for game engines but for any equally or more complex software.<p>I guess my point being - I&#x27;d love to see more effort into addressing the hard design stuff, and less repetition of what&#x27;s already been established.</div><br/><div id="42484962" class="c"><input type="checkbox" id="c-42484962" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#42484823">parent</a><span>|</span><a href="#42484522">next</a><span>|</span><label class="collapse" for="c-42484962">[-]</label><label class="expand" for="c-42484962">[1 more]</label></div><br/><div class="children"><div class="content">I’m with you with 99% of those books. But this one is little bit different, IMHO</div><br/></div></div></div></div><div id="42484522" class="c"><input type="checkbox" id="c-42484522" checked=""/><div class="controls bullet"><span class="by">suzzer99</span><span>|</span><a href="#42484823">prev</a><span>|</span><a href="#42483863">next</a><span>|</span><label class="collapse" for="c-42484522">[-]</label><label class="expand" for="c-42484522">[2 more]</label></div><br/><div class="children"><div class="content">Something bugs me about that first example. We started with two classes that had trivial constructors, and changed them into classes that require an instance of DiscountService be supplied to a constructor. That doesn&#x27;t feel like less complexity to me.<p>I&#x27;d probably just make applyDiscount a static utility method that the two classes import and invoke on their own, at least until it becomes obvious that something more involved is needed.</div><br/><div id="42484840" class="c"><input type="checkbox" id="c-42484840" checked=""/><div class="controls bullet"><span class="by">exoji2e</span><span>|</span><a href="#42484522">parent</a><span>|</span><a href="#42483863">next</a><span>|</span><label class="collapse" for="c-42484840">[-]</label><label class="expand" for="c-42484840">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and also it’s weird to get a negative shipping cost (-5) for US and code SUMMER2024. Typically you would only apply the discount code once and not both to shipping and the total order value.</div><br/></div></div></div></div><div id="42483863" class="c"><input type="checkbox" id="c-42483863" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#42484522">prev</a><span>|</span><a href="#42483549">next</a><span>|</span><label class="collapse" for="c-42483863">[-]</label><label class="expand" for="c-42483863">[1 more]</label></div><br/><div class="children"><div class="content">While I heartily agree with limiting complexity as a ground rule, the example given is not a great one.<p>First, it’s more about repetition&#x2F;poor design than complexity. Second, creating a separate service class for applying a discount is <i>adding</i> unnecessary complexity. You’ll end up with a pile of <i>DiscountService</i>, <i>TaxService</i>, <i>ShippingCostsService</i>, and so on, and they will be sewn together like patchwork. It seems to be a common pattern in Java but surely there are better ways?</div><br/></div></div><div id="42483549" class="c"><input type="checkbox" id="c-42483549" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42483863">prev</a><span>|</span><a href="#42483530">next</a><span>|</span><label class="collapse" for="c-42483549">[-]</label><label class="expand" for="c-42483549">[1 more]</label></div><br/><div class="children"><div class="content">It’s a great book. I feel like a lot of the midlevel engineers I’ve worked with over the years who read clean code and stopped there would benefit greatly from it.</div><br/></div></div><div id="42483530" class="c"><input type="checkbox" id="c-42483530" checked=""/><div class="controls bullet"><span class="by">recroad</span><span>|</span><a href="#42483549">prev</a><span>|</span><a href="#42483308">next</a><span>|</span><label class="collapse" for="c-42483530">[-]</label><label class="expand" for="c-42483530">[1 more]</label></div><br/><div class="children"><div class="content">Here’s a recent interview with the author <a href="https:&#x2F;&#x2F;youtu.be&#x2F;bopwQ_YV06g?si=S2YOVbXj3MJ2NlEG" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;bopwQ_YV06g?si=S2YOVbXj3MJ2NlEG</a></div><br/></div></div><div id="42483308" class="c"><input type="checkbox" id="c-42483308" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42483530">prev</a><span>|</span><a href="#42483267">next</a><span>|</span><label class="collapse" for="c-42483308">[-]</label><label class="expand" for="c-42483308">[4 more]</label></div><br/><div class="children"><div class="content">Sadly article&#x27;s author doesn&#x27;t touch the main idea of the book: component&#x27;s public API should be narrow as possible. John makes a great deal of that with concrete examples.</div><br/><div id="42484604" class="c"><input type="checkbox" id="c-42484604" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42483308">parent</a><span>|</span><a href="#42483267">next</a><span>|</span><label class="collapse" for="c-42484604">[-]</label><label class="expand" for="c-42484604">[3 more]</label></div><br/><div class="children"><div class="content">This. That is the biggest idea and also the most applicable and the easiest to understand when your complexity is going through the roof.<p>For example in Ruby land it is very common to make a class and then make a lot of small tiny methods which are one liners or two liners.<p>I had asked him directly about this and his answer was to avoid doing it.<p>Since then my Ruby and Common Lisp code has become much better.<p>I have since moved to rust, but the point still applies.</div><br/><div id="42484629" class="c"><input type="checkbox" id="c-42484629" checked=""/><div class="controls bullet"><span class="by">theonething</span><span>|</span><a href="#42483308">root</a><span>|</span><a href="#42484604">parent</a><span>|</span><a href="#42483267">next</a><span>|</span><label class="collapse" for="c-42484629">[-]</label><label class="expand" for="c-42484629">[2 more]</label></div><br/><div class="children"><div class="content">&gt; make a lot of small tiny methods which are one liners or two liners.<p>I&#x27;m presuming you mean <i>public</i> tiny methods?  Having private ones like that can be good if makes sense to do so (encapsulates logic, increases readability, etc)</div><br/><div id="42484836" class="c"><input type="checkbox" id="c-42484836" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42483308">root</a><span>|</span><a href="#42484629">parent</a><span>|</span><a href="#42483267">next</a><span>|</span><label class="collapse" for="c-42484836">[-]</label><label class="expand" for="c-42484836">[1 more]</label></div><br/><div class="children"><div class="content">Yes public &quot;deep&quot; methods. But even private methods I have been more conservative.<p>It is after all an API for you!<p>Basically the idea that you shouldn&#x27;t have long methods is something I don&#x27;t believe in anymore. Even Carmack made a similar point: <a href="http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carmack-on-inlined-code.html" rel="nofollow">http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carm...</a></div><br/></div></div></div></div></div></div></div></div><div id="42483267" class="c"><input type="checkbox" id="c-42483267" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42483308">prev</a><span>|</span><a href="#42484315">next</a><span>|</span><label class="collapse" for="c-42483267">[-]</label><label class="expand" for="c-42483267">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>I read this book recently, one chapter at a time, and after each, reviewed the code for my current project, applying the principles to it in a re-write --- it helped a lot.<p>Highly recommended.</div><br/></div></div><div id="42484315" class="c"><input type="checkbox" id="c-42484315" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#42483267">prev</a><span>|</span><a href="#42482746">next</a><span>|</span><label class="collapse" for="c-42484315">[-]</label><label class="expand" for="c-42484315">[1 more]</label></div><br/><div class="children"><div class="content">“The idea behind exception aggregation is to handle many exceptions with a single piece of code; rather than writing distinct handlers for many individual exceptions, handle them all in one place with a single handler.”<p>This seems similar to how events are handled in a web-browser.  Each element can handle its own event-handlers. But equally well there can be a single event-handler for each event-type in a  containing element, perhaps at the top-level only.<p>If you define event-handlers of a given type for all DOM-elements of the page in a single location it becomes much more flexible to modify how and which events are handled and for which DOM-elements.<p>So we could say that &quot;error&quot; is just one of the event-types, errors can be or could be handled by the same mechanism as events in general are. Right? Or is there clear categorical difference between error-events and other types of events?</div><br/></div></div><div id="42482746" class="c"><input type="checkbox" id="c-42482746" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#42484315">prev</a><span>|</span><a href="#42484163">next</a><span>|</span><label class="collapse" for="c-42482746">[-]</label><label class="expand" for="c-42482746">[1 more]</label></div><br/><div class="children"><div class="content">In the oop age of arch I felt like I had no mouth (and I had to scream).<p>This book, as well as the data oriented design approach, is what made things right for me.</div><br/></div></div><div id="42484163" class="c"><input type="checkbox" id="c-42484163" checked=""/><div class="controls bullet"><span class="by">indoorcomic</span><span>|</span><a href="#42482746">prev</a><span>|</span><a href="#42482747">next</a><span>|</span><label class="collapse" for="c-42484163">[-]</label><label class="expand" for="c-42484163">[2 more]</label></div><br/><div class="children"><div class="content">I disagree with the examples in the second idea. The &quot;bad&quot; example is easier to understand and maintain at a glance in my opinion. Looking at the RegisterUser method, I can immediately see the steps it takes to register a user, whereas the &quot;good&quot; example I have to think about it a bit more. Of course, this is a simple example so not much thinking needs to be done, but in a more realistic application I think this would hold much more truth. In projects I&#x27;ve worked on I&#x27;ve seen methods get incredibly bloated due to this. I certainly do agree that &quot;splitting things up for the sake of splitting them up&quot; can be bad practice, I&#x27;m just not sure this is the best example to demonstrate that.</div><br/><div id="42484272" class="c"><input type="checkbox" id="c-42484272" checked=""/><div class="controls bullet"><span class="by">estevaoam</span><span>|</span><a href="#42484163">parent</a><span>|</span><a href="#42482747">next</a><span>|</span><label class="collapse" for="c-42484272">[-]</label><label class="expand" for="c-42484272">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The main function of a component should describe what it does, similar to describing the algorithm in natural language. I have been following this pattern with success. It is much easier to understand things at a glance.</div><br/></div></div></div></div><div id="42482747" class="c"><input type="checkbox" id="c-42482747" checked=""/><div class="controls bullet"><span class="by">onemoresoop</span><span>|</span><a href="#42484163">prev</a><span>|</span><a href="#42484404">next</a><span>|</span><label class="collapse" for="c-42482747">[-]</label><label class="expand" for="c-42482747">[3 more]</label></div><br/><div class="children"><div class="content">I love this website’s format, it seems very pleasant to read.</div><br/><div id="42482835" class="c"><input type="checkbox" id="c-42482835" checked=""/><div class="controls bullet"><span class="by">asimpletune</span><span>|</span><a href="#42482747">parent</a><span>|</span><a href="#42484404">next</a><span>|</span><label class="collapse" for="c-42482835">[-]</label><label class="expand" for="c-42482835">[2 more]</label></div><br/><div class="children"><div class="content">I came here to say the same. Having the navigation on the bottom is great too, with it appearing when you scroll up. Kudos to the owner.</div><br/><div id="42483102" class="c"><input type="checkbox" id="c-42483102" checked=""/><div class="controls bullet"><span class="by">amenghra</span><span>|</span><a href="#42482747">root</a><span>|</span><a href="#42482835">parent</a><span>|</span><a href="#42484404">next</a><span>|</span><label class="collapse" for="c-42483102">[-]</label><label class="expand" for="c-42483102">[1 more]</label></div><br/><div class="children"><div class="content">It’s not great when it conflicts with the system’s default behavior :&#x2F;<p>My screen recording: <a href="https:&#x2F;&#x2F;streamable.com&#x2F;gvz68h" rel="nofollow">https:&#x2F;&#x2F;streamable.com&#x2F;gvz68h</a></div><br/></div></div></div></div></div></div><div id="42484404" class="c"><input type="checkbox" id="c-42484404" checked=""/><div class="controls bullet"><span class="by">NomDePlum</span><span>|</span><a href="#42482747">prev</a><span>|</span><a href="#42483282">next</a><span>|</span><label class="collapse" for="c-42484404">[-]</label><label class="expand" for="c-42484404">[1 more]</label></div><br/><div class="children"><div class="content">A similar article discussing the same book: <a href="https:&#x2F;&#x2F;blog.pragmaticengineer.com&#x2F;a-philosophy-of-software-design-review&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.pragmaticengineer.com&#x2F;a-philosophy-of-software-...</a></div><br/></div></div></div></div></div></div></div></body></html>