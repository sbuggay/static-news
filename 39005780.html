<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705395658247" as="style"/><link rel="stylesheet" href="styles.css?v=1705395658247"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.abubalay.com/blog/2024/01/14/rust-effect-lowering">A lowering strategy for control effects in Rust</a> <span class="domain">(<a href="https://www.abubalay.com">www.abubalay.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>34 comments</span></div><br/><div><div id="39006180" class="c"><input type="checkbox" id="c-39006180" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#39006985">next</a><span>|</span><label class="collapse" for="c-39006180">[-]</label><label class="expand" for="c-39006180">[32 more]</label></div><br/><div class="children"><div class="content">Very interesting analysis.<p>I&#x27;m fascinated with effect systems.<p>In theory they have the potential to make code both simpler and more powerful, because many complex abstractions like generators, async&#x2F;await, error propagation, injected context, etc can all be built on a simple extensible language primitive.<p>The by far nicest implementation I&#x27;ve seen is Koka lang [1]. Unfortunately it&#x27;s bound to be a small research language.<p>In practice I do wonder though if that much power won&#x27;t make code very confusing to read and write, and if the general programmer should be trusted with that much flexibility.<p>For Rust specifically, I do wonder how generic effects could slot into a language that was not designed for them upfront, without compromising the design and DX.<p>[1] <a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;index.html</a></div><br/><div id="39008799" class="c"><input type="checkbox" id="c-39008799" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39006248">next</a><span>|</span><label class="collapse" for="c-39008799">[-]</label><label class="expand" for="c-39008799">[12 more]</label></div><br/><div class="children"><div class="content">&gt; many complex abstractions like generators, async&#x2F;await, error propagation, injected context, etc can all be built on a simple extensible language primitive.<p>I have conflicting feelings about this. On the one hand, it feels like call&#x2F;cc all over again (a &quot;simple&quot; language primitive that can express devilishly complex control flow) that a lot of people would call a design mistake. The fact you <i>can</i> implement complex abstractions with a small primitive doesn&#x27;t make the complex abstractions not complex for consumers of the API.<p>On the other hand, it&#x27;s not call&#x2F;cc and lets you do complex things with a decent amount of modularity.<p>But I also don&#x27;t buy into the argument that implementing such foundational primitives like control flow in library code is <i>good</i> (I use async Rust every day, and it sucks how much has been pawned off to the ecosystem, please don&#x27;t reply to this comment telling me how wrong I am). Even if you <i>can</i> implement these things in the ecosystem doesn&#x27;t mean you <i>should</i> - it leads to bifurcations in the wild where libraries become incompatible because they aren&#x27;t working with the same tools. The very thing that makes programming a force multiplier is modularity and reuse, making those <i>harder</i> by making a language too expressive makes that language worse, imo.<p>And all that said, the biggest knock that I have against algebraic effects is I haven&#x27;t seen a compelling argument why they can&#x27;t be replaced with coroutines which are well understood and don&#x27;t require much magic to implement.</div><br/><div id="39009537" class="c"><input type="checkbox" id="c-39009537" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008799">parent</a><span>|</span><a href="#39008905">next</a><span>|</span><label class="collapse" for="c-39009537">[-]</label><label class="expand" for="c-39009537">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But I also don&#x27;t buy into the argument that implementing such foundational primitives like control flow in library code is good (I use async Rust every day, and it sucks how much has been pawned off to the ecosystem, please don&#x27;t reply to this comment telling me how wrong I am). Even if you can implement these things in the ecosystem doesn&#x27;t mean you should - it leads to bifurcations in the wild where libraries become incompatible because they aren&#x27;t working with the same tools. The very thing that makes programming a force multiplier is modularity and reuse, making those harder by making a language too expressive makes that language worse, imo.<p>That seems pretty backwards to me. Being able to implement flow control as regular functions increases modularity and reuse a lot, not least because it makes it easy to abstract across async or not. IMO the biggest reason async Rust is so painful is precisely because control flow is a bunch of special case magic builtins that you can&#x27;t share or reuse (e.g. you can&#x27;t use regular if&#x2F;while&#x2F;for with async, and you can&#x27;t write your own equivalents (like Haskell&#x27;s ifM&#x2F;whileM) because the language doesn&#x27;t provide the tools you&#x27;d need to do that).</div><br/><div id="39010013" class="c"><input type="checkbox" id="c-39010013" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39009537">parent</a><span>|</span><a href="#39008905">next</a><span>|</span><label class="collapse" for="c-39010013">[-]</label><label class="expand" for="c-39010013">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can&#x27;t use regular if&#x2F;while&#x2F;for with async<p>What do you mean by this? You can certainly mix if&#x2F;while&#x2F;for freely with .await, that&#x27;s the whole reason it exists.</div><br/></div></div></div></div><div id="39008905" class="c"><input type="checkbox" id="c-39008905" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008799">parent</a><span>|</span><a href="#39009537">prev</a><span>|</span><a href="#39009060">next</a><span>|</span><label class="collapse" for="c-39008905">[-]</label><label class="expand" for="c-39008905">[5 more]</label></div><br/><div class="children"><div class="content">I thought coroutines don’t solve the function coloring problem considering we do have coroutines but combinatorial explosion due to function coloring is an issue. In other words, I need a try_async_map function if I want to support a map operation that has failability and async (as I need a duplicate try_map vs map to support just failability).<p>Whether this should be solved by a formal generic algebraic effects system or generic keywords is an open question but unless I’m mistaken this is a real problem that can’t be solved with coroutines.<p>The article also highlights an advantage for generic algebraic effects by reducing the cost of async code by not constructing the Waker until there’s a suspension point. I don’t understand the proposals well enough to know if generic keywords would solve this too, but it’s certainly worth considering.<p>I’m less bearish on new language mechanics if they solve a class of problems very consistently and improve efficiency. Complexity of usage is a concern vs something like generic keywords, but honestly self consistent mechanics like this might be less complex to master than generic keywords in the long run. There’s precedent here for example with macros which is a pretty complex subsystem but it’s carved out by experts providing libraries for the most part and I would expect similar behavior here where library code might be more complex in implementation but there’s no code duplication and the user code gets a simpler .map function usable in any context. There will also be plenty of copy-passable examples to learn from the std library APIs.</div><br/><div id="39009305" class="c"><input type="checkbox" id="c-39009305" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008905">parent</a><span>|</span><a href="#39009078">next</a><span>|</span><label class="collapse" for="c-39009305">[-]</label><label class="expand" for="c-39009305">[2 more]</label></div><br/><div class="children"><div class="content">If you could spawn a coroutine and pass it around as a value, you could implement your effects just by calling coroutine.resume(...), coroutine.yield(...). The reason this is more powerful abstraction than async&#x2F;await is that it&#x27;s colorless - structs that could be sync or async just need a field that&#x27;s Option&lt;Coroutine&gt; and when they want to be &quot;effectful&quot; they just do something like<p><pre><code>   if let Some(async) = self.async.as_mut() {
       let next_arg = async.yield(next_result);
   }
</code></pre>
Consider deserializing JSON with serde_json over a TCP socket. There&#x27;s no need for an AsyncRead because the asynchronicity isn&#x27;t colorful - internally in the implementation of std::io::Read, it just needs to check if there is a coroutine to yield to.<p>I&#x27;m less compelled about code duplication for trivial stuff like try_async_map, whereas being able to duct tape together major libraries with a few lines of code internally is much more compelling. And solves real problems, the previous example is actually a problem faced in codebases today.<p>I can think of a few arguments against this, but I don&#x27;t see it as structurally that different from algebraic effects.</div><br/><div id="39010285" class="c"><input type="checkbox" id="c-39010285" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39009305">parent</a><span>|</span><a href="#39009078">next</a><span>|</span><label class="collapse" for="c-39010285">[-]</label><label class="expand" for="c-39010285">[1 more]</label></div><br/><div class="children"><div class="content">I agree that try_async_map is whatever, but currently if you want to call several fallible functions from different libraries and propagate the errors you get into a bit of a mess.</div><br/></div></div></div></div><div id="39009078" class="c"><input type="checkbox" id="c-39009078" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008905">parent</a><span>|</span><a href="#39009305">prev</a><span>|</span><a href="#39009071">next</a><span>|</span><label class="collapse" for="c-39009078">[-]</label><label class="expand" for="c-39009078">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The article also highlights an advantage for generic algebraic effects by reducing the cost of async code by not constructing the Waker until there’s a suspension point.<p>No, it doesn&#x27;t. It highlights that as an advantage of <i>one specific</i> implementation style, while suggesting a <i>different</i> implementation for Rust.</div><br/></div></div><div id="39009071" class="c"><input type="checkbox" id="c-39009071" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008905">parent</a><span>|</span><a href="#39009078">prev</a><span>|</span><a href="#39009060">next</a><span>|</span><label class="collapse" for="c-39009071">[-]</label><label class="expand" for="c-39009071">[1 more]</label></div><br/><div class="children"><div class="content">Lots of coroutine implementations solve this problem, see maybe Lua or greenlet or Byuu&#x27;s libco. Shipping async as-is and delaying async-in-trait until 1 month ago was a deliberate choice to make all libraries less composable.</div><br/></div></div></div></div><div id="39009060" class="c"><input type="checkbox" id="c-39009060" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008799">parent</a><span>|</span><a href="#39008905">prev</a><span>|</span><a href="#39009544">next</a><span>|</span><label class="collapse" for="c-39009060">[-]</label><label class="expand" for="c-39009060">[2 more]</label></div><br/><div class="children"><div class="content">The article is not suggesting that Rust should support arbitrary library-defined effects. It&#x27;s suggesting that Rust&#x27;s existing <i>language</i>-defined effects should be combined algebraically.<p>&gt; the biggest knock that I have against algebraic effects is I haven&#x27;t seen a compelling argument why they can&#x27;t be replaced with coroutines which are well understood and don&#x27;t require much magic to implement.<p>Rust&#x27;s effects are already implemented as coroutines! Algebraic effects are a specific pattern for how those coroutines communicate, to make them more composable.</div><br/><div id="39009165" class="c"><input type="checkbox" id="c-39009165" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39009060">parent</a><span>|</span><a href="#39009544">next</a><span>|</span><label class="collapse" for="c-39009165">[-]</label><label class="expand" for="c-39009165">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m replying to the comment on algebraic effects more than the article.</div><br/></div></div></div></div><div id="39009544" class="c"><input type="checkbox" id="c-39009544" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008799">parent</a><span>|</span><a href="#39009060">prev</a><span>|</span><a href="#39006248">next</a><span>|</span><label class="collapse" for="c-39009544">[-]</label><label class="expand" for="c-39009544">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But I also don&#x27;t buy into the argument that implementing such foundational primitives like control flow in library code is good<p>Library code doesn&#x27;t mean bespoke. Core and std are library code, and stuff can be migrated in there from the ecosystem whenever a truly best-in-class solution that won&#x27;t be replaced anytime soon becomes apparent.</div><br/><div id="39010363" class="c"><input type="checkbox" id="c-39010363" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39009544">parent</a><span>|</span><a href="#39006248">next</a><span>|</span><label class="collapse" for="c-39010363">[-]</label><label class="expand" for="c-39010363">[1 more]</label></div><br/><div class="children"><div class="content">Library code means every project has to choose which library they use. Smolstring or SmartString? Tokio or one of the others?<p>And then suddenly we have “colored” libraries. Does my http library work with the async runtime I’m using? How many arena allocator implementations does my package depend on and compile in?<p>The advantage of something being in core or std is that, because all libraries implicitly depend on it, there’s no choice to be made. String is available everywhere. Libraries pass Strings to each other all the time. Nobody is confused when String is in the public API.<p>&gt; stuff can be migrated in there from the ecosystem whenever a truly best-in-class solution that won&#x27;t be replaced anytime soon becomes apparent.<p>Rust has been remarkably conservative when it comes to adding stuff to std in the last few years. I think it would make sense at the very least to add an async executor and async syscalls to std. You shouldn’t need 3rd party libraries to async read from a file or network stream. Obviously it would be a hugely divisive choice but making no choice at all hurts users.</div><br/></div></div></div></div></div></div><div id="39006248" class="c"><input type="checkbox" id="c-39006248" checked=""/><div class="controls bullet"><span class="by">sp33der89</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39008799">prev</a><span>|</span><a href="#39007538">next</a><span>|</span><label class="collapse" for="c-39006248">[-]</label><label class="expand" for="c-39006248">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the learning curve is there, but it has its benefits for software development.<p>Personally I really am enjoying the one implemented by Unison: <a href="https:&#x2F;&#x2F;www.unison-lang.org&#x2F;docs&#x2F;fundamentals&#x2F;abilities&#x2F;using-abilities-pt1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.unison-lang.org&#x2F;docs&#x2F;fundamentals&#x2F;abilities&#x2F;usin...</a><p>But Koka&#x27;s was fun to play around with as well!</div><br/></div></div><div id="39007538" class="c"><input type="checkbox" id="c-39007538" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39006248">prev</a><span>|</span><a href="#39006963">next</a><span>|</span><label class="collapse" for="c-39007538">[-]</label><label class="expand" for="c-39007538">[1 more]</label></div><br/><div class="children"><div class="content">I read this as &quot;we have a set of effects we can layer&quot; instead of &quot;we build give the user the ability of make effects&quot;</div><br/></div></div><div id="39006963" class="c"><input type="checkbox" id="c-39006963" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39007538">prev</a><span>|</span><a href="#39006877">next</a><span>|</span><label class="collapse" for="c-39006963">[-]</label><label class="expand" for="c-39006963">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In practice I do wonder though if that much power won&#x27;t make code very confusing to read and write, and if the general programmer should be trusted with that much flexibility.<p>This is not for ordinary code, it&#x27;s for writing support libraries and DSL&#x27;s.  You need this stuff so that the &quot;general programmer&quot; can write code that&#x27;s as straightforward as possible in its proper context.</div><br/></div></div><div id="39006877" class="c"><input type="checkbox" id="c-39006877" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39006963">prev</a><span>|</span><a href="#39006667">next</a><span>|</span><label class="collapse" for="c-39006877">[-]</label><label class="expand" for="c-39006877">[11 more]</label></div><br/><div class="children"><div class="content">You see something similar with CL and Clojure (but the latter to a lesser extent): these abstractions are so powerful that those that grok them are able to construct things that others have little chance of understanding without a significant investment in time (if at all). Go does more or less the opposite: it tries to avoid any kind of cleverness.</div><br/><div id="39007246" class="c"><input type="checkbox" id="c-39007246" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39006877">parent</a><span>|</span><a href="#39007001">next</a><span>|</span><label class="collapse" for="c-39007246">[-]</label><label class="expand" for="c-39007246">[7 more]</label></div><br/><div class="children"><div class="content">Nothing I&#x27;ve seen in any other language comes close to CLs condition system. It makes exceptions look like stone age technology.<p>Technically I&#x27;m sure you could do everything conditions do even in C with like setjmp&#x2F;longjmp, but... good luck with that.</div><br/><div id="39007280" class="c"><input type="checkbox" id="c-39007280" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007246">parent</a><span>|</span><a href="#39007301">next</a><span>|</span><label class="collapse" for="c-39007280">[-]</label><label class="expand" for="c-39007280">[2 more]</label></div><br/><div class="children"><div class="content">You can implement resumable conditions using coroutine support.  They&#x27;re very comparable features.</div><br/><div id="39007387" class="c"><input type="checkbox" id="c-39007387" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007280">parent</a><span>|</span><a href="#39007301">next</a><span>|</span><label class="collapse" for="c-39007387">[-]</label><label class="expand" for="c-39007387">[1 more]</label></div><br/><div class="children"><div class="content">True. It&#x27;s so nice to just have them in the language though. Because then the whole library ecosystem is using the same abstraction, making it far more useful.</div><br/></div></div></div></div><div id="39007301" class="c"><input type="checkbox" id="c-39007301" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007246">parent</a><span>|</span><a href="#39007280">prev</a><span>|</span><a href="#39007001">next</a><span>|</span><label class="collapse" for="c-39007301">[-]</label><label class="expand" for="c-39007301">[4 more]</label></div><br/><div class="children"><div class="content">Fun fact: long ago, Rust had conditions!</div><br/><div id="39007397" class="c"><input type="checkbox" id="c-39007397" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007301">parent</a><span>|</span><a href="#39007001">next</a><span>|</span><label class="collapse" for="c-39007397">[-]</label><label class="expand" for="c-39007397">[3 more]</label></div><br/><div class="children"><div class="content">Interesting. Why were they removed?</div><br/><div id="39008207" class="c"><input type="checkbox" id="c-39008207" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007397">parent</a><span>|</span><a href="#39007001">next</a><span>|</span><label class="collapse" for="c-39008207">[-]</label><label class="expand" for="c-39008207">[2 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;9795">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;9795</a> and the linked PR that removed them.</div><br/><div id="39010646" class="c"><input type="checkbox" id="c-39010646" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39008207">parent</a><span>|</span><a href="#39007001">next</a><span>|</span><label class="collapse" for="c-39010646">[-]</label><label class="expand" for="c-39010646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; let tps = if_ok!(self.tps(as_.tps, bs.tps));<p>Ha, that&#x27;s how the question mark operator (and the previous encarnation, the `try!` macro) was born then :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39007001" class="c"><input type="checkbox" id="c-39007001" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39006877">parent</a><span>|</span><a href="#39007246">prev</a><span>|</span><a href="#39006667">next</a><span>|</span><label class="collapse" for="c-39007001">[-]</label><label class="expand" for="c-39007001">[3 more]</label></div><br/><div class="children"><div class="content">There’s no fundamental objection to requiring people to master difficult concepts in programming: see the ubiquity of the LeetCode Hard interview. Why then is this such a barrier to the adoption of functional programming and sophisticated type systems?</div><br/><div id="39010672" class="c"><input type="checkbox" id="c-39010672" checked=""/><div class="controls bullet"><span class="by">konschubert</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007001">parent</a><span>|</span><a href="#39009533">next</a><span>|</span><label class="collapse" for="c-39010672">[-]</label><label class="expand" for="c-39010672">[1 more]</label></div><br/><div class="children"><div class="content">Because the benefit of the &quot;smart&quot; approach vs the &quot;simple&quot; approach is usually smaller than its cost.<p>The cost being: Having to hire especially talented developers and developers spending more time reading and understanding code. And there is the hard-to-measure but insidious aversion of software developers to work on code that will require effort to understand.</div><br/></div></div><div id="39009533" class="c"><input type="checkbox" id="c-39009533" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39007001">parent</a><span>|</span><a href="#39010672">prev</a><span>|</span><a href="#39006667">next</a><span>|</span><label class="collapse" for="c-39009533">[-]</label><label class="expand" for="c-39009533">[1 more]</label></div><br/><div class="children"><div class="content">Because there are many alternatives that at first sight seem both easier to master and more productive. This results in perceived lower initial cost of development.</div><br/></div></div></div></div></div></div><div id="39006667" class="c"><input type="checkbox" id="c-39006667" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39006877">prev</a><span>|</span><a href="#39006646">next</a><span>|</span><label class="collapse" for="c-39006667">[-]</label><label class="expand" for="c-39006667">[1 more]</label></div><br/><div class="children"><div class="content">On the very far end of the spectrum you will have something that may look a bit like mathematical notation. Something describing a relationship extremely concisely, but the hard thing will be figuring out what exactly follows from that concise expression.<p>I can understand how people could see the appeal in this, but I think this doesn&#x27;t necessarily make it easier to write good software.</div><br/></div></div><div id="39006646" class="c"><input type="checkbox" id="c-39006646" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#39006180">parent</a><span>|</span><a href="#39006667">prev</a><span>|</span><a href="#39006985">next</a><span>|</span><label class="collapse" for="c-39006646">[-]</label><label class="expand" for="c-39006646">[4 more]</label></div><br/><div class="children"><div class="content">What about a more imperative shape? What if you could have a closure that &quot;goto&quot;s into the parent function scope?<p>Or imagine coroutines built with `swapcontext` (man 3).</div><br/><div id="39006999" class="c"><input type="checkbox" id="c-39006999" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39006646">parent</a><span>|</span><a href="#39006985">next</a><span>|</span><label class="collapse" for="c-39006999">[-]</label><label class="expand" for="c-39006999">[3 more]</label></div><br/><div class="children"><div class="content">Stackful fibers are an anti-pattern.  See Gor Nishanov&#x27;s review for the C++ ISO committee <a href="http:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p1364r0.pdf" rel="nofollow">http:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p136...</a> linked from <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20191011-00&#x2F;?p=102989" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20191011-00&#x2F;?p=10...</a> .  Notice how it sums things up:<p>&gt; <i>DO NOT USE FIBERS!</i></div><br/><div id="39007087" class="c"><input type="checkbox" id="c-39007087" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39006999">parent</a><span>|</span><a href="#39009113">next</a><span>|</span><label class="collapse" for="c-39007087">[-]</label><label class="expand" for="c-39007087">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say that not everybody agrees. Also all the issues identified by Gor are due to retrofitting continuations into an existing language as a pure library without compiler help.</div><br/></div></div><div id="39009113" class="c"><input type="checkbox" id="c-39009113" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39006180">root</a><span>|</span><a href="#39006999">parent</a><span>|</span><a href="#39007087">prev</a><span>|</span><a href="#39006985">next</a><span>|</span><label class="collapse" for="c-39009113">[-]</label><label class="expand" for="c-39009113">[1 more]</label></div><br/><div class="children"><div class="content">Can Gor Nishanov post one of his hand-made state machines that handles several nested protocols? Or does he believe that operating systems are good at scheduling work across 100,000 threads?</div><br/></div></div></div></div></div></div></div></div><div id="39006985" class="c"><input type="checkbox" id="c-39006985" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#39006180">prev</a><span>|</span><label class="collapse" for="c-39006985">[-]</label><label class="expand" for="c-39006985">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust should learn from this work and skip the layering.<p>As someone who uses Haskell professionally, 100% agree. Monad transformers are an (unfortunate) solution to the problem of stacking effects, not only due to the required lifting (to pick the appropriate handler), but due to the lack of compositionality and rough UX for the developer. Algebraic effect libraries are a lot easier to use (but I cannot speak for how easy&#x2F;hard are to implement).</div><br/></div></div></div></div></div></div></div></body></html>