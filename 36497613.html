<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687942852557" as="style"/><link rel="stylesheet" href="styles.css?v=1687942852557"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/getlago/lago/wiki/Is-ORM-still-an-%27anti-pattern%27%3F">Is ORM still an anti-pattern?</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>AnhTho_FR</span> | <span>354 comments</span></div><br/><div><div id="36500185" class="c"><input type="checkbox" id="c-36500185" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#36498275">next</a><span>|</span><label class="collapse" for="c-36500185">[-]</label><label class="expand" for="c-36500185">[163 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing ORM on Java since Hibernate was new, and it has always sucked. One of the selling points, which is now understood to be garbage, is that you can use different databases. But no-one uses different databases. Another selling point which is &quot;you don&#x27;t need to know SQL&quot;, is also garbage. <i>Every non-trivial long-lived application will require tweaks to individual queries at the string level</i>. The proper way to build a data layer is one query at a time, as a string, with string interpolation. The closer you are to raw JDBC the better.<p>Oh yeah, another bad reason for ORM: to support the &quot;Domain Model&quot;. Which is always, and I mean always, devoid of any logic. The so-called &quot;anemic domain model&quot; anti-pattern. How many man-hours have been wasted on ORM, XML, annotations, debugging generated SQL, and so on? It makes me cry.</div><br/><div id="36500429" class="c"><input type="checkbox" id="c-36500429" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503369">next</a><span>|</span><label class="collapse" for="c-36500429">[-]</label><label class="expand" for="c-36500429">[16 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t agree with this more. The way I like to put it is &quot;ORMs make the easy parts slightly easier, but they make the hard parts really hard&quot;. But I don&#x27;t care that much about improving the easy parts, because they&#x27;re already easy! Yet I can remember plenty of times when ORMs made my job a million times more difficult and all I was doing was fighting with the ORM itself (and usually at the worst time, e.g. when a query reached enough scale that it &quot;fell over&quot;).<p>Query builders aren&#x27;t exactly the same thing, but I love this article, <a href="https:&#x2F;&#x2F;gajus.medium.com&#x2F;stop-using-knex-js-and-earn-30-bf410349856c" rel="nofollow noreferrer">https:&#x2F;&#x2F;gajus.medium.com&#x2F;stop-using-knex-js-and-earn-30-bf41...</a>, and it&#x27;s made me a huge fan of Slonik and similar technologies. It does 90% of what I want a query builder or ORM to do (e.g. automatic binding of results to objects, strong type checking, etc.), but it lets me just write normal SQL. I also never understood this idea that SQL is some mystically difficult language. It has warts from being old, sure, but I&#x27;d rather learn SQL than whatever custom-flavor-of-ORM-query-language some ORM tool created.</div><br/><div id="36501509" class="c"><input type="checkbox" id="c-36501509" checked=""/><div class="controls bullet"><span class="by">B-Con</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500429">parent</a><span>|</span><a href="#36502222">next</a><span>|</span><label class="collapse" for="c-36501509">[-]</label><label class="expand" for="c-36501509">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but I&#x27;d rather learn SQL than whatever custom-flavor-of-ORM-query-language some ORM tool created<p>This point is worth emphasizing!<p>When you application carries non-trivial business logic, it <i>will</i> create non-trivial DB access patterns.<p>The developer will either use SQL or some other language that, pragmatically speaking, translates to SQL. But either way, they will learn some DB expression.<p>I&#x27;d rather use a standard. Existing familiarity, easier to find docs, support, and is probably more bug-free, etc.</div><br/><div id="36503819" class="c"><input type="checkbox" id="c-36503819" checked=""/><div class="controls bullet"><span class="by">ObscureScience</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501509">parent</a><span>|</span><a href="#36503728">next</a><span>|</span><label class="collapse" for="c-36503819">[-]</label><label class="expand" for="c-36503819">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine what would be&#x2F;is valuable is type checked embedded SQL queries.</div><br/></div></div><div id="36503728" class="c"><input type="checkbox" id="c-36503728" checked=""/><div class="controls bullet"><span class="by">Moru</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501509">parent</a><span>|</span><a href="#36503819">prev</a><span>|</span><a href="#36502222">next</a><span>|</span><label class="collapse" for="c-36503728">[-]</label><label class="expand" for="c-36503728">[1 more]</label></div><br/><div class="children"><div class="content">And since SQL has existed for so long, chances are that someone already had your problem and has posted the solution somewhere.</div><br/></div></div></div></div><div id="36502222" class="c"><input type="checkbox" id="c-36502222" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500429">parent</a><span>|</span><a href="#36501509">prev</a><span>|</span><a href="#36502115">next</a><span>|</span><label class="collapse" for="c-36502222">[-]</label><label class="expand" for="c-36502222">[5 more]</label></div><br/><div class="children"><div class="content">The problem is the ORM requires you to know its language, the underlying SQL for that database, as well as how the ORM maps to that underlying language.<p>It’s the worst of a leaky abstraction, and like 3x the conceptual overhead. But it’s better because … something something OOP.</div><br/><div id="36502499" class="c"><input type="checkbox" id="c-36502499" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502222">parent</a><span>|</span><a href="#36503125">next</a><span>|</span><label class="collapse" for="c-36502499">[-]</label><label class="expand" for="c-36502499">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s the worst of a leaky abstraction, and like 3x the conceptual overhead.<p>I really think you hit the nail on the head with this sentence. For example, another commenter said &quot;But the same SQL fanboys who believe every developer ought to memorize tri-state truth tables...&quot;<p>Yes, I think it&#x27;s fine to argue that the boolean logic with respect to NULL in SQL is a pain in the ass. But ORMs certainly don&#x27;t hide that from you! The ways DBs treat nulls is a fundamental part of nearly all RDBMSes - if you don&#x27;t understand that, you&#x27;re (eventually) going to have a bad time. All ORMs really do is make it <i>harder</i> to understand when you may need to take special null logic into account.</div><br/><div id="36502947" class="c"><input type="checkbox" id="c-36502947" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502499">parent</a><span>|</span><a href="#36503125">next</a><span>|</span><label class="collapse" for="c-36502947">[-]</label><label class="expand" for="c-36502947">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. As unfortunate as those warts are, you can&#x27;t pretend them away. Might as well be able to see them clearly.</div><br/></div></div></div></div><div id="36503125" class="c"><input type="checkbox" id="c-36503125" checked=""/><div class="controls bullet"><span class="by">monero-xmr</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502222">parent</a><span>|</span><a href="#36502499">prev</a><span>|</span><a href="#36502115">next</a><span>|</span><label class="collapse" for="c-36503125">[-]</label><label class="expand" for="c-36503125">[2 more]</label></div><br/><div class="children"><div class="content">“Something something OOP” - you reach enlightenment once you realize OOP itself is an anti-pattern.</div><br/><div id="36503825" class="c"><input type="checkbox" id="c-36503825" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503125">parent</a><span>|</span><a href="#36502115">next</a><span>|</span><label class="collapse" for="c-36503825">[-]</label><label class="expand" for="c-36503825">[1 more]</label></div><br/><div class="children"><div class="content">I agree. We&#x27;d be better off with data structures and functions that work on those data structures, and packages&#x2F;modules&#x2F;namespaces (with public&#x2F;private exposing) to do encapsulation.<p>OOP comes with the banana-gorilla-jungle problem, which I consider the fundamental issue with it.<p><a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;368797&#x2F;sample-code-to-explain-banana-monkey-jungle-problem-by-joe-armstrong" rel="nofollow noreferrer">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;3687...</a></div><br/></div></div></div></div></div></div><div id="36502115" class="c"><input type="checkbox" id="c-36502115" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500429">parent</a><span>|</span><a href="#36502222">prev</a><span>|</span><a href="#36503369">next</a><span>|</span><label class="collapse" for="c-36502115">[-]</label><label class="expand" for="c-36502115">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d rather learn SQL than whatever custom-flavor-of-ORM-query-language some ORM tool created.<p>Me too! That&#x27;s why I use an ORM that lets you write queries in SQL, like... Hibernate.<p>This narrative seems to come up frequently. People make (good) arguments against certain <i>features</i> of ORMs and then conclude it&#x27;s an argument against ORMs in general. The boundary between databases and codebases is very broad. But ultimately you work with objects in your code, and relational tables in your database, so there&#x27;s going to be some sort of Object Relational Mapper in between.</div><br/><div id="36503871" class="c"><input type="checkbox" id="c-36503871" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502115">parent</a><span>|</span><a href="#36502892">next</a><span>|</span><label class="collapse" for="c-36503871">[-]</label><label class="expand" for="c-36503871">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>ultimately you work with objects in your code, and relational tables in your database</i><p>Yes, you can map a record in a DB table to a class, and as long as you are happy with retrieving records (and related records) and mapping them to classes, an ORM will be all you need. But SQL is not just limited to the columns of a table, you can join, define new columns in your select statement, group, use aggregate functions etc. etc., and then you quickly get into territory that the ORM doesn&#x27;t understand anymore. So the point that ORMs take away a lot of the flexibility that SQL gives you still stands...</div><br/></div></div><div id="36502892" class="c"><input type="checkbox" id="c-36502892" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502115">parent</a><span>|</span><a href="#36503871">prev</a><span>|</span><a href="#36503369">next</a><span>|</span><label class="collapse" for="c-36502892">[-]</label><label class="expand" for="c-36502892">[5 more]</label></div><br/><div class="children"><div class="content">But... At that point what does hibernate even do for you? You can just use a lighter query wrapper at that point, or almost even roll your own wrapper around jdbc directly. The latter is a bit more work but it might be worth it depending on project since it gives you absolute control.<p>I&#x27;ll take a query wrapper that&#x27;s designed so I supply queries directly and it does the work from there (binding to objects) over using hibernate that way any time.</div><br/><div id="36503152" class="c"><input type="checkbox" id="c-36503152" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502892">parent</a><span>|</span><a href="#36503369">next</a><span>|</span><label class="collapse" for="c-36503152">[-]</label><label class="expand" for="c-36503152">[4 more]</label></div><br/><div class="children"><div class="content">&gt; depending on project since it gives you absolute control<p>Absolute control to hunt down your own bugs, instead of using something that is an industry standard and any competent programmer jumping to your project can be up-to-speed with it instantly..</div><br/><div id="36503229" class="c"><input type="checkbox" id="c-36503229" checked=""/><div class="controls bullet"><span class="by">isbvhodnvemrwvn</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503152">parent</a><span>|</span><a href="#36503644">next</a><span>|</span><label class="collapse" for="c-36503229">[-]</label><label class="expand" for="c-36503229">[1 more]</label></div><br/><div class="children"><div class="content">Very few developers are competent with hibernate, many fewer than with sql. Writeback cache nature of hibernate makes it very complex, order of operations on the app won&#x27;t match order of operations in the DB.</div><br/></div></div><div id="36503644" class="c"><input type="checkbox" id="c-36503644" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503152">parent</a><span>|</span><a href="#36503229">prev</a><span>|</span><a href="#36503369">next</a><span>|</span><label class="collapse" for="c-36503644">[-]</label><label class="expand" for="c-36503644">[2 more]</label></div><br/><div class="children"><div class="content">Even an &quot;industry standard&quot; framework can get in the way. Given the constraints of executing efficient queries; handling errors and timeouts on the application&#x27;s terms; and enforcing concurrency and transaction handling policies even a &quot;good&quot; ORM can be more a problem than a solution.</div><br/><div id="36503816" class="c"><input type="checkbox" id="c-36503816" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503644">parent</a><span>|</span><a href="#36503369">next</a><span>|</span><label class="collapse" for="c-36503816">[-]</label><label class="expand" for="c-36503816">[1 more]</label></div><br/><div class="children"><div class="content">All of those will be worse off by hand-made “solutions”. Especially that you are not forced to use ORM <i>for everything</i>. Use it for like 90% of your generic db usage, and use its in-built escape hatches for the rest, like native queries or go straight to the db driver if needed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36503369" class="c"><input type="checkbox" id="c-36503369" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36500429">prev</a><span>|</span><a href="#36502594">next</a><span>|</span><label class="collapse" for="c-36503369">[-]</label><label class="expand" for="c-36503369">[3 more]</label></div><br/><div class="children"><div class="content">You started with the worse ORM in existance.<p>There are ORM with good pros&#x2F;cons ratios out there. Python has espacially good ones:<p>- Django comes with a very clunky and poor performing one, but it&#x27;s very well integrated, super practical, productive and has nice ergonomics.<p>- Peewee gives you an ORM in a small package, which makes writing those little programs a joy when you don&#x27;t need anything fancy, but feel lazy.<p>- SQLAlchemy requires a lot more investment, but is very flexible, generates clean SQL and has extremely correct behavior. It also exposes a lower level query builder for when you don&#x27;t want the OOP paradigm and wish to express idiomatic SQL behavior, but abstracted away with Python.<p>This becomes a standard engineering decision, where you analyze the ROI.</div><br/><div id="36503653" class="c"><input type="checkbox" id="c-36503653" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503369">parent</a><span>|</span><a href="#36503499">next</a><span>|</span><label class="collapse" for="c-36503653">[-]</label><label class="expand" for="c-36503653">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the productivity and performance with the Django ORM is amazing. I have trouble using any other web framework now...<p>The thing people are missing is relations. The most important aspect of your application is how data is related to each other. A good ORM makes that easy.</div><br/></div></div><div id="36503499" class="c"><input type="checkbox" id="c-36503499" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503369">parent</a><span>|</span><a href="#36503653">prev</a><span>|</span><a href="#36502594">next</a><span>|</span><label class="collapse" for="c-36503499">[-]</label><label class="expand" for="c-36503499">[1 more]</label></div><br/><div class="children"><div class="content">Ruby on rails with active record is absoutly amazing. and anyone who hasn&#x27;t tried it, haven&#x27;t used a great ORM</div><br/></div></div></div></div><div id="36502594" class="c"><input type="checkbox" id="c-36502594" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503369">prev</a><span>|</span><a href="#36503105">next</a><span>|</span><label class="collapse" for="c-36502594">[-]</label><label class="expand" for="c-36502594">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Another selling point which is &quot;you don&#x27;t need to know SQL&quot;<p>It has never ever been a selling point by anyone with an ounce of brain.<p>ORMs are made for OLTP workloads, not OLAPs (one of the creators of Hibernate have also said so, but I won’t look it up now), and their primary utility is to save you from writing long and error prone insert and update queries, plus they automatically map an sql row to an object. That’s it.<p>You <i>will</i> reimplement plenty of parts of it if you go the raw way, so it is again, not a zero sum game.</div><br/><div id="36502765" class="c"><input type="checkbox" id="c-36502765" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502594">parent</a><span>|</span><a href="#36503105">next</a><span>|</span><label class="collapse" for="c-36502765">[-]</label><label class="expand" for="c-36502765">[6 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; Another selling point which is &quot;you don&#x27;t need to know SQL&quot;<p>&gt; It has never ever been a selling point by anyone with an ounce of brain.<p>Every project I&#x27;ve been involved with that got saddled with an ORM was originally justified &quot;so junior developers don&#x27;t need to know SQL&quot;.<p>Which is a great way to paint yourself into a very painful corner, but that&#x27;s what teams do.</div><br/><div id="36503923" class="c"><input type="checkbox" id="c-36503923" checked=""/><div class="controls bullet"><span class="by">scott_w</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502765">parent</a><span>|</span><a href="#36503933">next</a><span>|</span><label class="collapse" for="c-36503923">[-]</label><label class="expand" for="c-36503923">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Every project I&#x27;ve been involved with that got saddled with an ORM was originally justified &quot;so junior developers don&#x27;t need to know SQL&quot;.<p>The people who made &quot;not knowing SQL&quot; the main reason to use an ORM should not be making the decision to use an ORM. They can only use it incorrectly.<p>If there are ORMs that document &quot;not needing to know SQL&quot; as a key selling point of their ORM, they should remove those sentences because it&#x27;s not.<p>As someone with 15 years experience using ORMs, you absolutely <i>do</i> need to know how your database works to be effective at using an ORM well. Once you do, and you understand how your ORM works, I still think the benefits of a well-integrated ORM into your codebase make it worthwhile. Generally the code becomes easier to understand, modify and reuse if you&#x27;re using an industry-standard ORM. Like with most good libraries or frameworks, the number of use cases the maintainers encounter usually means you&#x27;ll find something pre-prepared when you come across a new problem.</div><br/></div></div><div id="36503933" class="c"><input type="checkbox" id="c-36503933" checked=""/><div class="controls bullet"><span class="by">gorbachev</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502765">parent</a><span>|</span><a href="#36503923">prev</a><span>|</span><a href="#36503558">next</a><span>|</span><label class="collapse" for="c-36503933">[-]</label><label class="expand" for="c-36503933">[1 more]</label></div><br/><div class="children"><div class="content">Just wait until LLMs get to that point.<p>&quot;We use CoPilotPro so that junior business analysts who can&#x27;t code can still create applications&quot;.</div><br/></div></div><div id="36503558" class="c"><input type="checkbox" id="c-36503558" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502765">parent</a><span>|</span><a href="#36503933">prev</a><span>|</span><a href="#36502939">next</a><span>|</span><label class="collapse" for="c-36503558">[-]</label><label class="expand" for="c-36503558">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like Human Resources or non-technical management taking technical decisions.</div><br/></div></div><div id="36502939" class="c"><input type="checkbox" id="c-36502939" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502765">parent</a><span>|</span><a href="#36503558">prev</a><span>|</span><a href="#36503741">next</a><span>|</span><label class="collapse" for="c-36502939">[-]</label><label class="expand" for="c-36502939">[1 more]</label></div><br/><div class="children"><div class="content">Sorry to hear that you encountered such teams. It tells a lot about their professionalism and experience. There are teams which do not use this kind of argumentation.</div><br/></div></div><div id="36503741" class="c"><input type="checkbox" id="c-36503741" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502765">parent</a><span>|</span><a href="#36502939">prev</a><span>|</span><a href="#36503105">next</a><span>|</span><label class="collapse" for="c-36503741">[-]</label><label class="expand" for="c-36503741">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, where are they even getting junior developers that don&#x27;t know some basic amount of SQL or can&#x27;t learn it in an afternoon? It&#x27;s such a non-issue. What a great way to ensure juniors never gain proper SQL experience&#x2F;expertise, and they&#x27;ll be the later senior developers too, which just propogates the problem.</div><br/></div></div></div></div></div></div><div id="36503105" class="c"><input type="checkbox" id="c-36503105" checked=""/><div class="controls bullet"><span class="by">andretti1977</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36502594">prev</a><span>|</span><a href="#36500347">next</a><span>|</span><label class="collapse" for="c-36503105">[-]</label><label class="expand" for="c-36503105">[2 more]</label></div><br/><div class="children"><div class="content">I come from Java and moved to nodejs for backend four years ago. I now use sequelize as orm. Most of your pain is due to hibernate itself. It may be the only really enterprise level orm but it is a pain in the ass.<p>Sequelize is extremely simpler and writing code with it is a joy compared to hibernate.<p>When you say nobody uses different database that’s true 99% of the time but i worked with a company which developed a tool that must be placed within customer infrastructure and this type of customers force you for the db choice since they have highly paid db support teams (financial sector) so they had to support multiple dbs.<p>A year ago i had to develop a big Java application without orm (cto’s choice): i didn’t remember how tedious, error prone and slow is development without orm!!! Never do it again!<p>I think the best approach is to use orm for common crud tasks and add specific sql queries when things get a little bit complicated.</div><br/><div id="36503334" class="c"><input type="checkbox" id="c-36503334" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503105">parent</a><span>|</span><a href="#36500347">next</a><span>|</span><label class="collapse" for="c-36503334">[-]</label><label class="expand" for="c-36503334">[1 more]</label></div><br/><div class="children"><div class="content">Yes, starting with Hibernate as a idea of what ORM provides is terrible.<p>ORM have plenty of flaws, but it&#x27;s like buying screws on wish and saying using a screwdriver is a terrible experience.</div><br/></div></div></div></div><div id="36500347" class="c"><input type="checkbox" id="c-36500347" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503105">prev</a><span>|</span><a href="#36500269">next</a><span>|</span><label class="collapse" for="c-36500347">[-]</label><label class="expand" for="c-36500347">[21 more]</label></div><br/><div class="children"><div class="content">I always hated ORM and saw it as an anti-pattern since I first used it many years ago for these exact reasons.<p>I remember back then, devs would look down on me for voicing my critiques about it.<p>There are many tools and techniques which I am forced to use today as a dev which are also anti-patterns.<p>The unfortunate reality of our industry is that most of the popular tools which software devs are using suck and are encouraging anti-patterns. The thing about the tech industry is that there are a small number of well-connected developers and ex-developers who call all the shots in this industry and they suck.</div><br/><div id="36504014" class="c"><input type="checkbox" id="c-36504014" checked=""/><div class="controls bullet"><span class="by">Idiot_in_Vain</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500347">parent</a><span>|</span><a href="#36502676">next</a><span>|</span><label class="collapse" for="c-36504014">[-]</label><label class="expand" for="c-36504014">[1 more]</label></div><br/><div class="children"><div class="content">Or maybe you haven&#x27;t taken the time to learn those tools and techniques and this is why you think they are anti-patterns. The people who set the trends in the development industry are extremely smart.<p>Take for example ORMs - people already know SQL and are often too lazy or un-motivated to learn their ORM of choice in depth. So for them the ORM is confusing and SQl just works. But an ORM eliminates a ton of code that needs to be written and maintained. Boilerplate code to read a row from DB than map it to an object or a map. Boilerplate code to do DB inserts and updates. Optionally boileplate code to track changes. Any decent ORM allows one to bypass it&#x27;s mechanisms and in the edge cases write SQL directly.<p>It&#x27;s essentially the same argument people used countless times in the past - e.g. why learn a higher level language, if they never work and I can do anything in C.</div><br/></div></div><div id="36502676" class="c"><input type="checkbox" id="c-36502676" checked=""/><div class="controls bullet"><span class="by">watwut</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500347">parent</a><span>|</span><a href="#36504014">prev</a><span>|</span><a href="#36500944">next</a><span>|</span><label class="collapse" for="c-36502676">[-]</label><label class="expand" for="c-36502676">[4 more]</label></div><br/><div class="children"><div class="content">Being old enough to experience how it worked before ORM, ORM is godsend. Maintenance just used to sux, massively, comparatively.</div><br/><div id="36503023" class="c"><input type="checkbox" id="c-36503023" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502676">parent</a><span>|</span><a href="#36500944">next</a><span>|</span><label class="collapse" for="c-36503023">[-]</label><label class="expand" for="c-36503023">[3 more]</label></div><br/><div class="children"><div class="content">Competency is a function of the human and not the tools.<p>People who create piles of garbage will do so regardless of what you give them.<p>Let&#x27;s not pretend ORM made poor behavior more manageable. It was just a different style mess to clean up.<p>You give them TDD, they&#x27;ll create bad broken tests. You give them linters, they&#x27;ll put in arcane and asinine rules. You give them git and they&#x27;ll have branching that looks like the Hapsburg family tree with commit comments like &quot;fix&quot;.<p>You aren&#x27;t going to fix behavior with tools. It takes time, discipline, probably a bunch of therapy...</div><br/><div id="36503505" class="c"><input type="checkbox" id="c-36503505" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503023">parent</a><span>|</span><a href="#36500944">next</a><span>|</span><label class="collapse" for="c-36503505">[-]</label><label class="expand" for="c-36503505">[2 more]</label></div><br/><div class="children"><div class="content">This argument has been presented forever to excuse bad tools, and it is a strawman. Of course good tools don&#x27;t fix bad behavior. The argument in favor of good tools is that competent people with good tools are insanely more productive than competent people with bad tools.</div><br/><div id="36503658" class="c"><input type="checkbox" id="c-36503658" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503505">parent</a><span>|</span><a href="#36500944">next</a><span>|</span><label class="collapse" for="c-36503658">[-]</label><label class="expand" for="c-36503658">[1 more]</label></div><br/><div class="children"><div class="content">But what does that mean? Consistent, predictable tools that can be specified generally and generally specified. For instance, gdb enacts and gnuplot</div><br/></div></div></div></div></div></div></div></div><div id="36500944" class="c"><input type="checkbox" id="c-36500944" checked=""/><div class="controls bullet"><span class="by">wernercd</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500347">parent</a><span>|</span><a href="#36502676">prev</a><span>|</span><a href="#36500269">next</a><span>|</span><label class="collapse" for="c-36500944">[-]</label><label class="expand" for="c-36500944">[15 more]</label></div><br/><div class="children"><div class="content">&gt; anti-patterns<p>if it works and it&#x27;s stupid... it&#x27;s not stupid. If companies around the world can get stuff done with &quot;anti-patterns&quot; then, by definition, they don&#x27;t &quot;suck&quot;.<p>I&#x27;m all for doing better and trying to improve my &quot;craft&quot; but I&#x27;m not going to look down on decisions that work.</div><br/><div id="36501208" class="c"><input type="checkbox" id="c-36501208" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36501117">next</a><span>|</span><label class="collapse" for="c-36501208">[-]</label><label class="expand" for="c-36501208">[3 more]</label></div><br/><div class="children"><div class="content">For a technology to not work at all it has to be really really shitty. Anti-patrern means pattern that is bad. If the tech didn&#x27;t work at all it wouldn&#x27;t be a pattern at all.<p>You could write your website in handcrafted assembly and it would work, but it would still be really stupid.</div><br/><div id="36501394" class="c"><input type="checkbox" id="c-36501394" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501208">parent</a><span>|</span><a href="#36501117">next</a><span>|</span><label class="collapse" for="c-36501394">[-]</label><label class="expand" for="c-36501394">[2 more]</label></div><br/><div class="children"><div class="content">I for one an looking forward to the advent of a frontend framework where every endpoint would be handled by a (possibly) handcrafted web assembly module.</div><br/><div id="36503613" class="c"><input type="checkbox" id="c-36503613" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501394">parent</a><span>|</span><a href="#36501117">next</a><span>|</span><label class="collapse" for="c-36503613">[-]</label><label class="expand" for="c-36503613">[1 more]</label></div><br/><div class="children"><div class="content">I mean, isn&#x27;t that just CGI?</div><br/></div></div></div></div></div></div><div id="36501117" class="c"><input type="checkbox" id="c-36501117" checked=""/><div class="controls bullet"><span class="by">throwanem</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36501208">prev</a><span>|</span><a href="#36503376">next</a><span>|</span><label class="collapse" for="c-36501117">[-]</label><label class="expand" for="c-36501117">[4 more]</label></div><br/><div class="children"><div class="content">You can drive a nail with a brick if you try hard enough. Does that make it not stupid to go looking for a brick while there&#x27;s a hammer right there in your toolbag?</div><br/><div id="36502847" class="c"><input type="checkbox" id="c-36502847" checked=""/><div class="controls bullet"><span class="by">AlchemistCamp</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501117">parent</a><span>|</span><a href="#36503376">next</a><span>|</span><label class="collapse" for="c-36502847">[-]</label><label class="expand" for="c-36502847">[3 more]</label></div><br/><div class="children"><div class="content">A screwdriver is the tool I know best and therefore it’s the most productive thing for me to use to nail things together with in my upcoming project.<p>I learned this strategy from HN&#x2F;IH commenters on many, many posts asking about which tools are ideal for various tasks.</div><br/><div id="36502965" class="c"><input type="checkbox" id="c-36502965" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502847">parent</a><span>|</span><a href="#36503376">next</a><span>|</span><label class="collapse" for="c-36502965">[-]</label><label class="expand" for="c-36502965">[2 more]</label></div><br/><div class="children"><div class="content">I would entertain myself looking how someone uses a screwdriver with a nail. Novel engineering approaches are never late to study.</div><br/><div id="36503796" class="c"><input type="checkbox" id="c-36503796" checked=""/><div class="controls bullet"><span class="by">scns</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502965">parent</a><span>|</span><a href="#36503376">next</a><span>|</span><label class="collapse" for="c-36503796">[-]</label><label class="expand" for="c-36503796">[1 more]</label></div><br/><div class="children"><div class="content">I prefer a screwdriver to my bare hands when i need to drive a nail but no hammer at hand. Speaking about real tools and not metaphorically though.</div><br/></div></div></div></div></div></div></div></div><div id="36503376" class="c"><input type="checkbox" id="c-36503376" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36501117">prev</a><span>|</span><a href="#36503620">next</a><span>|</span><label class="collapse" for="c-36503376">[-]</label><label class="expand" for="c-36503376">[1 more]</label></div><br/><div class="children"><div class="content">Nope. If it works and it&#x27;s stupid, it&#x27;s still stupid.<p>Just because companies can get stuff done in dumb ways doesn&#x27;t mean those ways aren&#x27;t dumb, it means that by brute force, sunk cost and obstinacy they can make things happen.  There are any number of technical and non-technical dumb things in any large organization. You definitely can&#x27;t assume something isn&#x27;t dumb just because a company does it.<p>Noone is looking down on ORMs because they work, people are looking down on them because they don&#x27;t work well enough to justify their downsides in most use cases.  That&#x27;s why people call it an anti-pattern.  Yes you can get it to work but in general it&#x27;s going to make things worse not better.<p>Now are some things that people call &quot;anti-patterns&quot; actually the right thing in certain circumstances? Absolutely. Just because something sucks in one situation doesn&#x27;t mean it isn&#x27;t the right choice in another.</div><br/></div></div><div id="36503620" class="c"><input type="checkbox" id="c-36503620" checked=""/><div class="controls bullet"><span class="by">MrDresden</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36503376">prev</a><span>|</span><a href="#36501645">next</a><span>|</span><label class="collapse" for="c-36503620">[-]</label><label class="expand" for="c-36503620">[1 more]</label></div><br/><div class="children"><div class="content">I guess you have never had to come in and solve a bad situation that has arisen specifically due to the bad short term decisions someone made in the past.<p>Not all tech debt is bad, as long as it is recognized when being created and gets accounted for in near future planning. That way it is a deliberate decision taken, after weighing pros and cons, knowing it will need to be dealt with at some point.<p>The worst of these is when those making the decisions don&#x27;t know as much as they think they do, forgo weighing pros and cons, and paint them selves into a corner by accident.<p>Those kinds of situations can literally kill a company (and have).</div><br/></div></div><div id="36501645" class="c"><input type="checkbox" id="c-36501645" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36503620">prev</a><span>|</span><a href="#36501842">next</a><span>|</span><label class="collapse" for="c-36501645">[-]</label><label class="expand" for="c-36501645">[1 more]</label></div><br/><div class="children"><div class="content">Getting stuff done is by far not the only concern. Maintenance cost is definitely a problem to consider.</div><br/></div></div><div id="36501842" class="c"><input type="checkbox" id="c-36501842" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36501645">prev</a><span>|</span><a href="#36501551">next</a><span>|</span><label class="collapse" for="c-36501842">[-]</label><label class="expand" for="c-36501842">[2 more]</label></div><br/><div class="children"><div class="content">Leaded gasoline worked but it was so stupid it actively made people stupid.</div><br/><div id="36502170" class="c"><input type="checkbox" id="c-36502170" checked=""/><div class="controls bullet"><span class="by">jkaplowitz</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501842">parent</a><span>|</span><a href="#36501551">next</a><span>|</span><label class="collapse" for="c-36502170">[-]</label><label class="expand" for="c-36502170">[1 more]</label></div><br/><div class="children"><div class="content">I think you’ve just identified leaded gasoline as the next greatest AI-powered cloud native blockchain technology.</div><br/></div></div></div></div><div id="36501551" class="c"><input type="checkbox" id="c-36501551" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500944">parent</a><span>|</span><a href="#36501842">prev</a><span>|</span><a href="#36500269">next</a><span>|</span><label class="collapse" for="c-36501551">[-]</label><label class="expand" for="c-36501551">[2 more]</label></div><br/><div class="children"><div class="content">More like, they want to use cheaper labor who don’t know SQL so they give them baby tools like ORM. Follow the money.</div><br/><div id="36501662" class="c"><input type="checkbox" id="c-36501662" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501551">parent</a><span>|</span><a href="#36500269">next</a><span>|</span><label class="collapse" for="c-36501662">[-]</label><label class="expand" for="c-36501662">[1 more]</label></div><br/><div class="children"><div class="content">Also there was a time it would be good to have Entity Framework or Hibernate on your CV. Another follow the money.</div><br/></div></div></div></div></div></div></div></div><div id="36500269" class="c"><input type="checkbox" id="c-36500269" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36500347">prev</a><span>|</span><a href="#36500217">next</a><span>|</span><label class="collapse" for="c-36500269">[-]</label><label class="expand" for="c-36500269">[33 more]</label></div><br/><div class="children"><div class="content">&gt; Every non-trivial long-lived application will require tweaks to individual queries at the string level. The proper way to build a data layer is one query at a time, as a string, with string interpolation. The closer you are to raw JDBC the better.<p>This is bullshit, IME. I&#x27;ve been doing this for over 10 years, and there&#x27;s not a single one of those &quot;requires a tweak at the string level&quot; queries that couldn&#x27;t be handled better by <i>actually spending 5 minutes reading the Hibernate documentation and doing what it says to do in that situation</i>. But the same SQL fanboys who believe every developer ought to memorize tri-state truth tables and COBOL-style function names can somehow never be bothered to do that.</div><br/><div id="36500971" class="c"><input type="checkbox" id="c-36500971" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500269">parent</a><span>|</span><a href="#36500953">next</a><span>|</span><label class="collapse" for="c-36500971">[-]</label><label class="expand" for="c-36500971">[28 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s not a single one of those &quot;requires a tweak at the string level&quot; queries that couldn&#x27;t be handled better by actually spending 5 minutes reading the Hibernate documentation<p>So instead of learning and using widely applicable SQL skills you learn and use Hibernate specific skills? And that’s supposed to be a positive?</div><br/><div id="36501517" class="c"><input type="checkbox" id="c-36501517" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500971">parent</a><span>|</span><a href="#36501393">next</a><span>|</span><label class="collapse" for="c-36501517">[-]</label><label class="expand" for="c-36501517">[14 more]</label></div><br/><div class="children"><div class="content">Once we&#x27;re talking about this kind of detailed tuning those &quot;widely applicable SQL skills&quot; are usually tied to a single database vendor.<p>Using any tool requires a certain investment in learning the tool. If you don&#x27;t want to learn an immensely popular and widely used library that&#x27;s in pretty high demand career-wise, well, that&#x27;s your lookout, but it&#x27;s a crazy double standard to claim that Hibernate sucks compared to handwritten SQL when you spent weeks tuning your SQL but wouldn&#x27;t spend hours tuning your Hibernate.</div><br/><div id="36501701" class="c"><input type="checkbox" id="c-36501701" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501517">parent</a><span>|</span><a href="#36501393">next</a><span>|</span><label class="collapse" for="c-36501701">[-]</label><label class="expand" for="c-36501701">[13 more]</label></div><br/><div class="children"><div class="content">&gt; If you don&#x27;t want to learn an immensely popular and widely used library that&#x27;s in pretty high demand career-wise, well, that&#x27;s your lookout<p>You’re making the argument against yourself. Even including different dialects an in depth knowledge of SQL is far more valuable than knowledge of Hibernate.<p>Over a decade ago now I used NHibernate, the .NET version of Hibernate on a project. Since that project I’ve written code in JavaScript (Node), Python, Rust, played around with a little Go and Kotlin.<p>In all those years the only database engine I’ve used seriously is Postgres. Knowledge of Postgres has been invaluable throughout my career. I can’t remember anything about NHibernate. It’s not even specific to NHibernate either, I had to use ORMs in other situations (like Sequelize on Node) and I haven’t retained any of that either.</div><br/><div id="36501836" class="c"><input type="checkbox" id="c-36501836" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501701">parent</a><span>|</span><a href="#36502673">next</a><span>|</span><label class="collapse" for="c-36501836">[-]</label><label class="expand" for="c-36501836">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Over a decade ago now I used NHibernate, the .NET version of Hibernate on a project. Since that project I’ve written code in JavaScript (Node), Python, Rust, played around with a little Go and Kotlin.<p>&gt; In all those years the only database engine I’ve used seriously is Postgres.<p>Interesting, I would think changing database happens a lot more than changing language for most developers. Over the last decade I&#x27;ve worked on systems that used MySQL, Postgres, Oracle, H2, and Sybase, but they&#x27;ve all been on the JVM and almost all used Hibernate (one used EclipseLink but a lot of the knowledge transferred over - even if something isn&#x27;t called exactly the same thing, they have the same kind of capability structured in a similar way - much smaller than the differences between databases IME. Indeed even having to use e.g. Django ORM occasionally a lot of stuff transferred over). Spending time learning to use an ORM well was absolutely a good investment, far more useful than a bunch of SQL details would&#x27;ve been.<p>Like, if a company has a Ruby&#x2F;MySQL stack, they&#x27;re going to hire someone whose experience was Ruby&#x2F;Postgres over someone whose experience was Python&#x2F;MySQL. So if you&#x27;re a Ruby dev then you open more doors for yourself by learning Ruby&#x27;s standard ORM in depth than you do by learning a specific database in depth.<p>&gt; I can’t remember anything about NHibernate. It’s not even specific to NHibernate either, I had to use ORMs in other situations (like Sequelize on Node) and I haven’t retained any of that either.<p>I suspect that reflects more on what you paid attention to and were interested in using rather than anything fundamental about how easy or hard ORMs are to learn.</div><br/><div id="36502591" class="c"><input type="checkbox" id="c-36502591" checked=""/><div class="controls bullet"><span class="by">krzyk</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501836">parent</a><span>|</span><a href="#36501895">next</a><span>|</span><label class="collapse" for="c-36502591">[-]</label><label class="expand" for="c-36502591">[5 more]</label></div><br/><div class="children"><div class="content">In my 20 year experience anegdotal evidence is that changing database happens as frequently as changing logging framework - never.<p>My employers always used Oracle (with small one time ex eption for RoR app that used mysql).</div><br/><div id="36503625" class="c"><input type="checkbox" id="c-36503625" checked=""/><div class="controls bullet"><span class="by">indigochill</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502591">parent</a><span>|</span><a href="#36502772">next</a><span>|</span><label class="collapse" for="c-36503625">[-]</label><label class="expand" for="c-36503625">[2 more]</label></div><br/><div class="children"><div class="content">Changing databases on an existing application doesn&#x27;t happen, but I&#x27;ve worked across teams within a single company for ~8 years and in that time I&#x27;ve used:<p>1. SQL Server<p>2. MySQL<p>3. Neo4j (very briefly)<p>4. PostgreSQL<p>5. DynamoDB<p>Each of those was for a different set of applications, and none of those applications changed database, but point being sometimes an engineer will be made to use a variety of databases in their career, even sometimes within the same company (although you could also chalk this up to a particularly laissez-faire style of tech direction).</div><br/><div id="36503914" class="c"><input type="checkbox" id="c-36503914" checked=""/><div class="controls bullet"><span class="by">krzyk</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503625">parent</a><span>|</span><a href="#36502772">next</a><span>|</span><label class="collapse" for="c-36503914">[-]</label><label class="expand" for="c-36503914">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>In our case company was strictly &quot;Oracle-only&quot;, but one team did a quick implementation in startup-style of Rails and used mysql. No one forced them to migrate to oracle, company just hired DBAs that now mysql.</div><br/></div></div></div></div><div id="36502772" class="c"><input type="checkbox" id="c-36502772" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502591">parent</a><span>|</span><a href="#36503625">prev</a><span>|</span><a href="#36501895">next</a><span>|</span><label class="collapse" for="c-36502772">[-]</label><label class="expand" for="c-36502772">[2 more]</label></div><br/><div class="children"><div class="content">Changing the database for an existing system happens very rarely, but changing the ORM or language is even rarer. So learning the ORM well is just as rewarding as learning the database well, IME - and more so once you take into account changing jobs, since you&#x27;re more likely to take another job using the same ORM but a different database than vice versa.</div><br/><div id="36503935" class="c"><input type="checkbox" id="c-36503935" checked=""/><div class="controls bullet"><span class="by">krzyk</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502772">parent</a><span>|</span><a href="#36501895">next</a><span>|</span><label class="collapse" for="c-36503935">[-]</label><label class="expand" for="c-36503935">[1 more]</label></div><br/><div class="children"><div class="content">It is good to know both. I wouldn&#x27;t choose which one is more important (ORM vs pure DB) as both are useful.<p>But you can use DB without ORM, you can&#x27;t use ORM without a DB.<p>Hibernate (and generally JPA) is usually more PITA than help, it makes easy things easier and hard things harder.</div><br/></div></div></div></div></div></div><div id="36501895" class="c"><input type="checkbox" id="c-36501895" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501836">parent</a><span>|</span><a href="#36502591">prev</a><span>|</span><a href="#36502673">next</a><span>|</span><label class="collapse" for="c-36501895">[-]</label><label class="expand" for="c-36501895">[4 more]</label></div><br/><div class="children"><div class="content">&gt; a lot of the knowledge transferred over - even if something isn&#x27;t called exactly the same thing, they have the same kind of capability structured in a similar way<p>At a certain point this is getting beyond parody. That statement sounds exactly like it’s discussing SQL!<p>&gt; I suspect that reflects more on what you paid attention to and were interested in using rather than anything fundamental about how easy or hard ORMs are to learn.<p>Nor am I saying anything about  anything being easy or difficult to learn. I’m talking about what’s transferable. In my experience ORMs are far less transferrable than SQL knowledge.<p>I think it’s safe to say we’re going to have to agree to disagree here.</div><br/><div id="36501940" class="c"><input type="checkbox" id="c-36501940" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501895">parent</a><span>|</span><a href="#36502673">next</a><span>|</span><label class="collapse" for="c-36501940">[-]</label><label class="expand" for="c-36501940">[3 more]</label></div><br/><div class="children"><div class="content">&gt; At a certain point this is getting beyond parody. That statement sounds exactly like it’s discussing SQL!<p>Nope. The underlying relational model is great. Knowing what tables are like, how and why indexes work (and when they don&#x27;t), transaction isolation levels, all that stuff is extremely useful transferrable knowledge (and will help you out whether you&#x27;re using an ORM or not). Knowing the three or four different bizarre pseudo-COBOL variants that different database vendors use to express something like &quot;pull rows recursively from this table&quot; or &quot;format this string using these two numbers and this date&quot; is stamp collecting at best.</div><br/><div id="36502738" class="c"><input type="checkbox" id="c-36502738" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501940">parent</a><span>|</span><a href="#36502673">next</a><span>|</span><label class="collapse" for="c-36502738">[-]</label><label class="expand" for="c-36502738">[2 more]</label></div><br/><div class="children"><div class="content">Disagree. All too often, JPA&#x2F;Hibernate dumbs the relational model down into record-at-a-time processing with navigational queries reminiscent of pre-relational network databases and counting and joins implemented by unnecessary fetching and client-side processing rather than aggregate queries and joins. Furthermore, it brings fuzzy locking semantics&#x2F;locking as a side effect of lazy&#x2F;eager fetching and artifacts such as a pattern of unnecessary &quot;id&quot; columns due to lack of support or asymmetrical and idiosyncratic handling of compound keys, also extra magic for &quot;many-to-many connectives&quot; (the wording alone is non-relational), lack of attention for decimal arithmetic&#x2F;overflow with money values, idiosyncratic date&#x2F;time conversions and mappings of enums into ordinals, etc. etc.</div><br/><div id="36502863" class="c"><input type="checkbox" id="c-36502863" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502738">parent</a><span>|</span><a href="#36502673">next</a><span>|</span><label class="collapse" for="c-36502863">[-]</label><label class="expand" for="c-36502863">[1 more]</label></div><br/><div class="children"><div class="content">Not my experience at all. The support for aggregate queries and joins is very good if you actually use it; likewise the support for decimals, date&#x2F;time and enums (though I say that from a position of thinking a lot of database date&#x2F;time handling is wrong, so take that as you will). I&#x27;m not a fan of lazy fetching but if it&#x27;s something you want then the locking semantics are a natural consequence of that. Many-to-many connectives are indeed non-relational, but again if they&#x27;re something you want (and again I mostly avoid them) then they work the way that they have to work.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36502673" class="c"><input type="checkbox" id="c-36502673" checked=""/><div class="controls bullet"><span class="by">keithnz</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501701">parent</a><span>|</span><a href="#36501836">prev</a><span>|</span><a href="#36502627">next</a><span>|</span><label class="collapse" for="c-36502673">[-]</label><label class="expand" for="c-36502673">[1 more]</label></div><br/><div class="children"><div class="content">what&#x27;s there to remember? NHibernate you basically use Linq, so if you remember Linq you remember NHbernate. The only extra bits are the setup and mappers, which are sort of trivial.   The pain points come around because NHhibernate decides to lazy load everything or ends up doing crazy joins.  But overall I found NHibernate not too bad, it certainly was fast doing a lot of basic CRUD type stuff.<p>However, these days I use Dapper.NET and SQL. Dapper gives a nice mapper for parameterized queries and maps results to types.  I think it&#x27;s a nice middle ground.</div><br/></div></div><div id="36502627" class="c"><input type="checkbox" id="c-36502627" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501701">parent</a><span>|</span><a href="#36502673">prev</a><span>|</span><a href="#36501393">next</a><span>|</span><label class="collapse" for="c-36502627">[-]</label><label class="expand" for="c-36502627">[1 more]</label></div><br/><div class="children"><div class="content">By that logic learning .NET, Python, etc was all invaluable as you are no longer using them, right?</div><br/></div></div></div></div></div></div><div id="36501393" class="c"><input type="checkbox" id="c-36501393" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500971">parent</a><span>|</span><a href="#36501517">prev</a><span>|</span><a href="#36502619">next</a><span>|</span><label class="collapse" for="c-36501393">[-]</label><label class="expand" for="c-36501393">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the same debate as whether you to hand craft xml files or have a library do it for you. You&#x27;d better know in details how the format works, but going through a library will help cover most common issues you wouldn&#x27;t want to deal with by hand.</div><br/><div id="36501543" class="c"><input type="checkbox" id="c-36501543" checked=""/><div class="controls bullet"><span class="by">nerdbert</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501393">parent</a><span>|</span><a href="#36501781">next</a><span>|</span><label class="collapse" for="c-36501543">[-]</label><label class="expand" for="c-36501543">[10 more]</label></div><br/><div class="children"><div class="content">Except that an XML file that passes the spec and contains the required data is as good as it will ever get. The world&#x27;s foremost XML-typing genius is not going to improve on that.<p>On the other hand, with hibernate, you get mediocre, inefficient SQL, and could produce much better results by focusing your energies on learning the database instead of learning hibernate.</div><br/><div id="36502106" class="c"><input type="checkbox" id="c-36502106" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501543">parent</a><span>|</span><a href="#36501681">next</a><span>|</span><label class="collapse" for="c-36502106">[-]</label><label class="expand" for="c-36502106">[1 more]</label></div><br/><div class="children"><div class="content">On hibernate: there is a common approach of having pure ORM handling of 99% of the queries and use a lower level query building tool for the 1% that needs it.<p>The query to fetch your user profile should be mediocre, properly cached, and fully defineable in the ORM. And most of your queries should be straight and obvious joins between tables with no crazy pants handling.<p>Something in your basic data structure that throws off an ORM would also probably throws off your new employees looking at the code for the first time, and could be fixed for readability and maintainance.</div><br/></div></div><div id="36501681" class="c"><input type="checkbox" id="c-36501681" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501543">parent</a><span>|</span><a href="#36502106">prev</a><span>|</span><a href="#36501847">next</a><span>|</span><label class="collapse" for="c-36501681">[-]</label><label class="expand" for="c-36501681">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The world&#x27;s foremost XML-typing genius<p>A thought exercice: XML entities can be self referencing, have you ever though of how you validate a document that has recursive entity definitions ?<p>That&#x27;s one quirk that comes first to mind, but the XML format definition is probably at leat a few hundred pages and I&#x27;m hopeful there&#x27;s enough in there to fuel anyone&#x27;s worst nightmares.<p>It&#x27;s kinda interesting in itself that XML is seen as a plain and boring data format. I don&#x27;t wish on anyone to be the receiving end of an XML typing genius&#x27; documents.</div><br/><div id="36502361" class="c"><input type="checkbox" id="c-36502361" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501681">parent</a><span>|</span><a href="#36501847">next</a><span>|</span><label class="collapse" for="c-36502361">[-]</label><label class="expand" for="c-36502361">[2 more]</label></div><br/><div class="children"><div class="content">The size of specification is easy to check. The print button say XML 1.0 spec is 37 pages long. By comparison YAML is 65 pages.<p>XML is not too simple, but it is not too complex either.</div><br/><div id="36502779" class="c"><input type="checkbox" id="c-36502779" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502361">parent</a><span>|</span><a href="#36501847">next</a><span>|</span><label class="collapse" for="c-36502779">[-]</label><label class="expand" for="c-36502779">[1 more]</label></div><br/><div class="children"><div class="content">The xml spec needs to be complemented with xsd, relax-ng or whatever schema tool is popular these days, yaml includes that.<p>Still in the same ballpark I expect.</div><br/></div></div></div></div></div></div><div id="36501847" class="c"><input type="checkbox" id="c-36501847" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501543">parent</a><span>|</span><a href="#36501681">prev</a><span>|</span><a href="#36501781">next</a><span>|</span><label class="collapse" for="c-36501847">[-]</label><label class="expand" for="c-36501847">[5 more]</label></div><br/><div class="children"><div class="content">&gt; could produce much better results by focusing your energies on learning the database instead of learning hibernate.<p>Completely false IME. If you put the same amount of effort into learning Hibernate you&#x27;ll get a much bigger return.</div><br/><div id="36502790" class="c"><input type="checkbox" id="c-36502790" checked=""/><div class="controls bullet"><span class="by">krzyk</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501847">parent</a><span>|</span><a href="#36501781">next</a><span>|</span><label class="collapse" for="c-36502790">[-]</label><label class="expand" for="c-36502790">[4 more]</label></div><br/><div class="children"><div class="content">Is there a way to avoid anemic domain model? Or have a proper invariant entity class that is created using constructor?</div><br/><div id="36502868" class="c"><input type="checkbox" id="c-36502868" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502790">parent</a><span>|</span><a href="#36501781">next</a><span>|</span><label class="collapse" for="c-36502868">[-]</label><label class="expand" for="c-36502868">[3 more]</label></div><br/><div class="children"><div class="content">No. I see that as a reflection of the reality of the database; if your database contains rows that violate your domain invariants, what would you expect to happen?</div><br/><div id="36503895" class="c"><input type="checkbox" id="c-36503895" checked=""/><div class="controls bullet"><span class="by">krzyk</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502868">parent</a><span>|</span><a href="#36503068">next</a><span>|</span><label class="collapse" for="c-36503895">[-]</label><label class="expand" for="c-36503895">[1 more]</label></div><br/><div class="children"><div class="content">I hope application to break as soon as possible so everyone will be on board to fix it.</div><br/></div></div><div id="36503068" class="c"><input type="checkbox" id="c-36503068" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502868">parent</a><span>|</span><a href="#36503895">prev</a><span>|</span><a href="#36501781">next</a><span>|</span><label class="collapse" for="c-36503068">[-]</label><label class="expand" for="c-36503068">[1 more]</label></div><br/><div class="children"><div class="content">It may not be a bad idea to fail fast by ORM calling the constructor (same way as Jackson does it when parsing JSON).
Broken invariants may propagate and cross system boundaries making things much worse (I have seen a case, when $200M transaction was rolled back in 19 systems because data was not properly validated at entry - it was a crazy day for everyone in production support).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36501781" class="c"><input type="checkbox" id="c-36501781" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501393">parent</a><span>|</span><a href="#36501543">prev</a><span>|</span><a href="#36502619">next</a><span>|</span><label class="collapse" for="c-36501781">[-]</label><label class="expand" for="c-36501781">[1 more]</label></div><br/><div class="children"><div class="content">That comparison would only really make sense if people were advocating writing SQLite storage files by hand.<p>In this situation SQL <i>is</i> the library. It’s the interface that allows you to query and write the underlying data while knowing nothing about the underlying format. An ORM is just a library sitting on top of the library you already have. There’s just as much to learn, it’s just a higher level of abstraction (until it isn’t because you need something low level).</div><br/></div></div></div></div><div id="36502619" class="c"><input type="checkbox" id="c-36502619" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500971">parent</a><span>|</span><a href="#36501393">prev</a><span>|</span><a href="#36500953">next</a><span>|</span><label class="collapse" for="c-36502619">[-]</label><label class="expand" for="c-36502619">[1 more]</label></div><br/><div class="children"><div class="content">Or you know, why not both?!</div><br/></div></div></div></div><div id="36500953" class="c"><input type="checkbox" id="c-36500953" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500269">parent</a><span>|</span><a href="#36500971">prev</a><span>|</span><a href="#36502655">next</a><span>|</span><label class="collapse" for="c-36500953">[-]</label><label class="expand" for="c-36500953">[2 more]</label></div><br/><div class="children"><div class="content">Its bullshit, IME.
All DBMS I have worked need some SQL level tuning to squeeze the last ~20% performance.</div><br/><div id="36501357" class="c"><input type="checkbox" id="c-36501357" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500953">parent</a><span>|</span><a href="#36502655">next</a><span>|</span><label class="collapse" for="c-36501357">[-]</label><label class="expand" for="c-36501357">[1 more]</label></div><br/><div class="children"><div class="content">I interpret parent&#x27;s point as doing the SQL level tuning through the ORM&#x27;s dedicated mechanisms, and not through a raw string.<p>Any decent ORM has extra procedures to tweak the resulting query and inject optimizations that it can&#x27;t arrive at automatically, kicking the ORM away every time there&#x27;s some tweak to do is counterproductive.</div><br/></div></div></div></div><div id="36502655" class="c"><input type="checkbox" id="c-36502655" checked=""/><div class="controls bullet"><span class="by">rpodraza</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500269">parent</a><span>|</span><a href="#36500953">prev</a><span>|</span><a href="#36502416">next</a><span>|</span><label class="collapse" for="c-36502655">[-]</label><label class="expand" for="c-36502655">[1 more]</label></div><br/><div class="children"><div class="content">Of course it&#x27;s bullshit. I would say 95% of the JPQL queries do the job.</div><br/></div></div></div></div><div id="36500217" class="c"><input type="checkbox" id="c-36500217" checked=""/><div class="controls bullet"><span class="by">bsuvc</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36500269">prev</a><span>|</span><a href="#36501629">next</a><span>|</span><label class="collapse" for="c-36500217">[-]</label><label class="expand" for="c-36500217">[51 more]</label></div><br/><div class="children"><div class="content">&gt; The proper way to build a data layer is one query at a time, as a string, with string interpolation.<p>Surely you mean a parameterized query string and not string interpolation, which is susceptible to sql injection.</div><br/><div id="36500245" class="c"><input type="checkbox" id="c-36500245" checked=""/><div class="controls bullet"><span class="by">kentm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36500724">next</a><span>|</span><label class="collapse" for="c-36500245">[-]</label><label class="expand" for="c-36500245">[1 more]</label></div><br/><div class="children"><div class="content">Charitably, they probably meant the process by which the parameterized query string itself is built, in the case where you need a dynamic query structure.</div><br/></div></div><div id="36500724" class="c"><input type="checkbox" id="c-36500724" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36500245">prev</a><span>|</span><a href="#36500506">next</a><span>|</span><label class="collapse" for="c-36500724">[-]</label><label class="expand" for="c-36500724">[7 more]</label></div><br/><div class="children"><div class="content">I swear to god I&#x27;m going to write a SQL library some day that doesn&#x27;t take strings as arguments. Although LINQ kinda already does what I&#x27;m thinking about, so maybe I just wait for someone to port it.</div><br/><div id="36501944" class="c"><input type="checkbox" id="c-36501944" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500724">parent</a><span>|</span><a href="#36501272">next</a><span>|</span><label class="collapse" for="c-36501944">[-]</label><label class="expand" for="c-36501944">[2 more]</label></div><br/><div class="children"><div class="content">Not sure what language you are talking about. For Java there is an awesome <a href="https:&#x2F;&#x2F;www.jooq.org&#x2F;doc&#x2F;3.19&#x2F;manual-single-page&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jooq.org&#x2F;doc&#x2F;3.19&#x2F;manual-single-page&#x2F;</a><p>Having said that: I stopped using it as writing plain SQL seems much more effective.</div><br/><div id="36503464" class="c"><input type="checkbox" id="c-36503464" checked=""/><div class="controls bullet"><span class="by">jokab</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501944">parent</a><span>|</span><a href="#36501272">next</a><span>|</span><label class="collapse" for="c-36503464">[-]</label><label class="expand" for="c-36503464">[1 more]</label></div><br/><div class="children"><div class="content">If you are fine with search and replace to refactor your code then ok.</div><br/></div></div></div></div><div id="36501272" class="c"><input type="checkbox" id="c-36501272" checked=""/><div class="controls bullet"><span class="by">intrasight</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500724">parent</a><span>|</span><a href="#36501944">prev</a><span>|</span><a href="#36502548">next</a><span>|</span><label class="collapse" for="c-36501272">[-]</label><label class="expand" for="c-36501272">[2 more]</label></div><br/><div class="children"><div class="content">The updated SqlQuery function of .NET 8 is pretty cool. It takes a string but safely interpolates the parameters.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;what-is-new&#x2F;ef-core-8.0&#x2F;whatsnew" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;what-is-new&#x2F;ef-cor...</a><p><a href="https:&#x2F;&#x2F;timdeschryver.dev&#x2F;blog&#x2F;you-can-now-return-unmapped-types-from-raw-sql-select-statements-with-entity-framework-8" rel="nofollow noreferrer">https:&#x2F;&#x2F;timdeschryver.dev&#x2F;blog&#x2F;you-can-now-return-unmapped-t...</a><p>&quot;With the new SqlQuery method, you can now write your own SQL queries and map the result to any type that you want.<p>This is useful for tasks that are not directly related to the day-to-day business of your application. For example, this can be used to import data, migrate data, or to retrieve data from a legacy system.&quot;</div><br/><div id="36502936" class="c"><input type="checkbox" id="c-36502936" checked=""/><div class="controls bullet"><span class="by">throwaway2990</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501272">parent</a><span>|</span><a href="#36502548">next</a><span>|</span><label class="collapse" for="c-36502936">[-]</label><label class="expand" for="c-36502936">[1 more]</label></div><br/><div class="children"><div class="content">Sooo it’s dapper with string interpolation override to make queries parameterized so you don’t need to manually put the parameters on as 2nd arguments?</div><br/></div></div></div></div><div id="36502548" class="c"><input type="checkbox" id="c-36502548" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500724">parent</a><span>|</span><a href="#36501272">prev</a><span>|</span><a href="#36502925">next</a><span>|</span><label class="collapse" for="c-36502548">[-]</label><label class="expand" for="c-36502548">[1 more]</label></div><br/><div class="children"><div class="content">You can do it in typescript&#x2F;es6 using tagged template literals. I have done it before and it was awesome. Seriously wish more languages supported custom variable interpolation for it.</div><br/></div></div><div id="36502925" class="c"><input type="checkbox" id="c-36502925" checked=""/><div class="controls bullet"><span class="by">missingdays</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500724">parent</a><span>|</span><a href="#36502548">prev</a><span>|</span><a href="#36500506">next</a><span>|</span><label class="collapse" for="c-36502925">[-]</label><label class="expand" for="c-36502925">[1 more]</label></div><br/><div class="children"><div class="content">Exposed exists</div><br/></div></div></div></div><div id="36500506" class="c"><input type="checkbox" id="c-36500506" checked=""/><div class="controls bullet"><span class="by">geraldwhen</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36500724">prev</a><span>|</span><a href="#36500231">next</a><span>|</span><label class="collapse" for="c-36500506">[-]</label><label class="expand" for="c-36500506">[4 more]</label></div><br/><div class="children"><div class="content">You can’t parameterize a table name and possibly also column name in Postgres.</div><br/><div id="36500714" class="c"><input type="checkbox" id="c-36500714" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500506">parent</a><span>|</span><a href="#36500231">next</a><span>|</span><label class="collapse" for="c-36500714">[-]</label><label class="expand" for="c-36500714">[3 more]</label></div><br/><div class="children"><div class="content">Those parts are perfectly fine as string constants.</div><br/><div id="36502580" class="c"><input type="checkbox" id="c-36502580" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500714">parent</a><span>|</span><a href="#36500231">next</a><span>|</span><label class="collapse" for="c-36502580">[-]</label><label class="expand" for="c-36502580">[2 more]</label></div><br/><div class="children"><div class="content">Depends on how dynamic your table names are</div><br/><div id="36502827" class="c"><input type="checkbox" id="c-36502827" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502580">parent</a><span>|</span><a href="#36500231">next</a><span>|</span><label class="collapse" for="c-36502827">[-]</label><label class="expand" for="c-36502827">[1 more]</label></div><br/><div class="children"><div class="content">APIs get weird when you gimp the common path in order to support relatively obscure use cases.<p>The common things should be easy.</div><br/></div></div></div></div></div></div></div></div><div id="36500231" class="c"><input type="checkbox" id="c-36500231" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36500506">prev</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36500231">[-]</label><label class="expand" for="c-36500231">[31 more]</label></div><br/><div class="children"><div class="content">Details. But sure. In truth the best way to do the data layer is to use stored procs with a generated binding at the application layer. This is absolutely safe from injection, and is wicked fast as well.</div><br/><div id="36500335" class="c"><input type="checkbox" id="c-36500335" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500231">parent</a><span>|</span><a href="#36500392">next</a><span>|</span><label class="collapse" for="c-36500335">[-]</label><label class="expand" for="c-36500335">[9 more]</label></div><br/><div class="children"><div class="content">Having been on the team that inherited a project full on stored procedures (more than once): no thank you, not ever again.<p>Opaque, difficult to debug, high risk to invoke, difficult to version and version-control properly. I’m sure they could be done “less worse”, but I doubt they can be done well.</div><br/><div id="36503998" class="c"><input type="checkbox" id="c-36503998" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500335">parent</a><span>|</span><a href="#36501337">next</a><span>|</span><label class="collapse" for="c-36503998">[-]</label><label class="expand" for="c-36503998">[1 more]</label></div><br/><div class="children"><div class="content">Stored procedure: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stored_procedure" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stored_procedure</a><p>Are there SQL migration tools like Alembic and South that also version and sync Stored Procedures? (Alembic on &quot;Replaceable objects&quot; and schema: <a href="https:&#x2F;&#x2F;alembic.sqlalchemy.org&#x2F;en&#x2F;latest&#x2F;cookbook.html#replaceable-objects" rel="nofollow noreferrer">https:&#x2F;&#x2F;alembic.sqlalchemy.org&#x2F;en&#x2F;latest&#x2F;cookbook.html#repla...</a> )<p>From &quot;What ORMs have taught me: just learn SQL (2014)&quot;
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15949610">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15949610</a> :<p>&gt; <i>ORMs:</i><p>&gt; <i>- Are maintainable by a team. &quot;Oh, because that seemed faster at the time.&quot;</i><p>&gt; <i>- Are unit tested: eventually we end up creating at least structs or objects anyway, and then that needs to be the same everywhere, and then the abstraction is wrong because &quot;everything should just be functional like SQL&quot; until we need to decide what you called &quot;the_initializer2&quot;.</i><p>&gt; <i>- Can make it very easy to create maintainable test fixtures which raise exceptions when the schema has changed but the test data hasn&#x27;t.</i><p>ORMs may help catch incomplete migrations; for example when every reference to a renamed column hasn&#x27;t been updated, or worse when foreign key relations changed breakingly.<p>django_rest_assured generates many tests for the models (SQL)&#x2F;views&#x2F;API views in a very DRY way from ORM schema and view&#x2F;controller&#x2F;route registrations, but is not as fast as e.g. FastAPI w&#x2F; SQLalchemy or django-ninja.</div><br/></div></div><div id="36501337" class="c"><input type="checkbox" id="c-36501337" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500335">parent</a><span>|</span><a href="#36503998">prev</a><span>|</span><a href="#36500936">next</a><span>|</span><label class="collapse" for="c-36501337">[-]</label><label class="expand" for="c-36501337">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for echoing my pain. I am paying for the bad decisions taken by a bloke who only knew SQL and used that hammer to bang on every nail he could find. Everytime someone asks why the result of the stored proc is the way it is, I need to manually run the steps one by one until I find the point where an expected row failed a condition and dropped off. And have extra fun wrapping those statements with declarations incase you are heavily using declared variables in those statements. To top it off, if you are troubleshooting in an environment where you don&#x27;t have insert&#x2F;update permissions, you day just became amazing. Fuck you  to those who use stored procs without strong justification (like high volume data processing on database side where it totally makes sense).<p>By version control, I assume you mean the inability to use different versions simultaneously without hacks, unlike a library built using Java where you get to pick and choose the version you want to use. Because of you mean version control of stored proc sources, that would be just like a normal git asset.</div><br/><div id="36503001" class="c"><input type="checkbox" id="c-36503001" checked=""/><div class="controls bullet"><span class="by">Canada</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501337">parent</a><span>|</span><a href="#36500936">next</a><span>|</span><label class="collapse" for="c-36503001">[-]</label><label class="expand" for="c-36503001">[1 more]</label></div><br/><div class="children"><div class="content">I like stored procedures, or I guess to be more specific functions in postgres, but they have to be done in a really specific way:<p>1) It&#x27;s all or nothing. If there&#x27;s functions then they better feel like a complete high level API, enforcing the consistency of data, perfectly handling locking, etc. If there&#x27;s tons of complex SQL in the app and then also a some functions then it&#x27;s better to have no functions at all.<p>2) They need to have a consistent interface, such as always returning an error flag, error message if applicable.  Functions must never surprise the caller. It either succeeds and the caller commits, or fail and the caller rolls back and knows why.<p>3) No monkey business with triggers. They can maintain updated_at columns, or maybe create some audit trails, but anything beyond that will make behavior surprising to callers and that is the worst.<p>As for version control it needs to be maintained as a separate application, which the server depends on having certain versions of. Even if you don&#x27;t use functions you have to worry about schema versions and you can&#x27;t always run two versions at the same time or roll back schema changes easily as a practical matter.</div><br/></div></div></div></div><div id="36500936" class="c"><input type="checkbox" id="c-36500936" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500335">parent</a><span>|</span><a href="#36501337">prev</a><span>|</span><a href="#36501329">next</a><span>|</span><label class="collapse" for="c-36500936">[-]</label><label class="expand" for="c-36500936">[1 more]</label></div><br/><div class="children"><div class="content">Holy crap yes. This thread has triggered a long lost memory from over a decade ago where everything, absolutely everything was done through stored procedure. Such a wild, wild waste of time.</div><br/></div></div><div id="36501329" class="c"><input type="checkbox" id="c-36501329" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500335">parent</a><span>|</span><a href="#36500936">prev</a><span>|</span><a href="#36500946">next</a><span>|</span><label class="collapse" for="c-36501329">[-]</label><label class="expand" for="c-36501329">[1 more]</label></div><br/><div class="children"><div class="content">I would add impossible to test to that list. And the postgraphile people think it&#x27;s the new hot stuff smh</div><br/></div></div><div id="36500946" class="c"><input type="checkbox" id="c-36500946" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500335">parent</a><span>|</span><a href="#36501329">prev</a><span>|</span><a href="#36500392">next</a><span>|</span><label class="collapse" for="c-36500946">[-]</label><label class="expand" for="c-36500946">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Opaque, difficult to debug, high risk to invoke, difficult to version and version-control properly.<p>Traditionally, maybe. With databases like Neon (postgresql) and Planetscale (mysql) supporting easy branching &#x2F; snapshot it&#x27;s at least made this a lot nicer.</div><br/><div id="36501077" class="c"><input type="checkbox" id="c-36501077" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500946">parent</a><span>|</span><a href="#36500392">next</a><span>|</span><label class="collapse" for="c-36501077">[-]</label><label class="expand" for="c-36501077">[2 more]</label></div><br/><div class="children"><div class="content">That might be true, but that’s like saying “now that my mechanic can repair my car for free, it’s way less worry to replace my radiator by removing it with a chainsaw”.<p>The solution to stored procs being awful isn’t making a whole branch just to see what it does, it’s fixing the problems with stored procedures at the root level.</div><br/><div id="36501320" class="c"><input type="checkbox" id="c-36501320" checked=""/><div class="controls bullet"><span class="by">grugagag</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501077">parent</a><span>|</span><a href="#36500392">next</a><span>|</span><label class="collapse" for="c-36501320">[-]</label><label class="expand" for="c-36501320">[1 more]</label></div><br/><div class="children"><div class="content">Though im on the fence with stored procs and have seen complicated messes that make it depressingly no fun to work with I also had very good experiences with systems based around stored procs, not in an abusive dogmatic way. The usual answer I’m going to invoke here is that it depends how the tool is used. Any tool, methodology, philosophy can be borked in various ways,  that experience traumatize people that they prefer to move on. Of course some tools are clearly worse or less useful than others but you can find some consensus if you know where to look.</div><br/></div></div></div></div></div></div></div></div><div id="36500392" class="c"><input type="checkbox" id="c-36500392" checked=""/><div class="controls bullet"><span class="by">mmcclure</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500231">parent</a><span>|</span><a href="#36500335">prev</a><span>|</span><a href="#36502698">next</a><span>|</span><label class="collapse" for="c-36500392">[-]</label><label class="expand" for="c-36500392">[3 more]</label></div><br/><div class="children"><div class="content">I (softly) disagree with stored procs being definitively the &quot;best way to do the data layer.&quot; Stored procs are an extremely powerful tool to have in your belt, but lord have mercy do they have their own tradeoffs.</div><br/><div id="36501122" class="c"><input type="checkbox" id="c-36501122" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500392">parent</a><span>|</span><a href="#36500685">next</a><span>|</span><label class="collapse" for="c-36501122">[-]</label><label class="expand" for="c-36501122">[1 more]</label></div><br/><div class="children"><div class="content">As usual there&#x27;s a time and place.<p>What I&#x27;ve found is that devs tend to be able to write &quot;OKish&quot; SQLs, but fall over when trying to optimize them, so the DB side can then take over and write optimized stored procs, which can have a separate cadence of code updates and version control compared to the backend team.</div><br/></div></div><div id="36500685" class="c"><input type="checkbox" id="c-36500685" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500392">parent</a><span>|</span><a href="#36501122">prev</a><span>|</span><a href="#36502698">next</a><span>|</span><label class="collapse" for="c-36500685">[-]</label><label class="expand" for="c-36500685">[1 more]</label></div><br/><div class="children"><div class="content">some of the worst issues I’ve ever dealt with had one of these as a root cause</div><br/></div></div></div></div><div id="36502698" class="c"><input type="checkbox" id="c-36502698" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500231">parent</a><span>|</span><a href="#36500392">prev</a><span>|</span><a href="#36500367">next</a><span>|</span><label class="collapse" for="c-36502698">[-]</label><label class="expand" for="c-36502698">[1 more]</label></div><br/><div class="children"><div class="content">False. I&#x27;ve developed enormous systems fully using stored procs for data layer and it&#x27;s absolutely not the &quot;best way to do the data layer&quot;. Next you&#x27;ll be saying triggers are a good idea.<p>Yes they can be fast, and they&#x27;re controlled by the DBA, that&#x27;s why you&#x27;d choose them. Injection is not an issue in modern data access layers, that&#x27;s a 1999 problem.</div><br/></div></div><div id="36500367" class="c"><input type="checkbox" id="c-36500367" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500231">parent</a><span>|</span><a href="#36502698">prev</a><span>|</span><a href="#36501281">next</a><span>|</span><label class="collapse" for="c-36500367">[-]</label><label class="expand" for="c-36500367">[5 more]</label></div><br/><div class="children"><div class="content">Stored procedures often increase CPU load of the DB instances, deploys can be more challenging, and security is only better if one takes care how the procedure is authorized or delegated.<p>They can save some network round trips, and unify interfaces if there are a lot of different stacks sharing one data store. Though it&#x27;s not universally better.</div><br/><div id="36501124" class="c"><input type="checkbox" id="c-36501124" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500367">parent</a><span>|</span><a href="#36501281">next</a><span>|</span><label class="collapse" for="c-36501124">[-]</label><label class="expand" for="c-36501124">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Stored procedures often increase CPU load of the DB instances
</code></pre>
This is of course true if you&#x27;re doing a bunch of computational work in your stored procedure (as opposed to just doing pure CRUD stuff) but I&#x27;m struggling to think of a real world situation where this might be the case.<p>Can you name some examples you&#x27;ve encountered? (I&#x27;m not doubting you, I&#x27;m just curious)</div><br/><div id="36501225" class="c"><input type="checkbox" id="c-36501225" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501124">parent</a><span>|</span><a href="#36501281">next</a><span>|</span><label class="collapse" for="c-36501225">[-]</label><label class="expand" for="c-36501225">[3 more]</label></div><br/><div class="children"><div class="content">I did some complex expiration calculations in a stored function, it cut down on round trips and kept the app simpler. Though it did cause some modestly higher CPU load.<p>I&#x27;ve also seen MVs cause CPU spikes where there is a lot of SELECT massaging going on. Even without the MVs themselves certain functions like REGEXP stuff can impact performance. Language of the PL matters too, if you&#x27;ve got choices like Python.</div><br/><div id="36501962" class="c"><input type="checkbox" id="c-36501962" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501225">parent</a><span>|</span><a href="#36501281">next</a><span>|</span><label class="collapse" for="c-36501962">[-]</label><label class="expand" for="c-36501962">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, MVs? I&#x27;m probably going to feel like an idiot but I&#x27;m not recognizing this acronym.<p>Also thanks for sharing your example, much appreciated</div><br/><div id="36502358" class="c"><input type="checkbox" id="c-36502358" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501962">parent</a><span>|</span><a href="#36501281">next</a><span>|</span><label class="collapse" for="c-36502358">[-]</label><label class="expand" for="c-36502358">[1 more]</label></div><br/><div class="children"><div class="content">Materialised Views.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36501281" class="c"><input type="checkbox" id="c-36501281" checked=""/><div class="controls bullet"><span class="by">edandersen</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500231">parent</a><span>|</span><a href="#36500367">prev</a><span>|</span><a href="#36501138">next</a><span>|</span><label class="collapse" for="c-36501281">[-]</label><label class="expand" for="c-36501281">[3 more]</label></div><br/><div class="children"><div class="content">If your default stance in 2023 is that you should start with stored procedures, you are doing something very wrong and you are a risk to the survival of your business.</div><br/><div id="36501969" class="c"><input type="checkbox" id="c-36501969" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501281">parent</a><span>|</span><a href="#36501354">next</a><span>|</span><label class="collapse" for="c-36501969">[-]</label><label class="expand" for="c-36501969">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say that any kind of absolutist &quot;default stance&quot; is suspect.</div><br/></div></div><div id="36501354" class="c"><input type="checkbox" id="c-36501354" checked=""/><div class="controls bullet"><span class="by">grugagag</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501281">parent</a><span>|</span><a href="#36501969">prev</a><span>|</span><a href="#36501138">next</a><span>|</span><label class="collapse" for="c-36501354">[-]</label><label class="expand" for="c-36501354">[1 more]</label></div><br/><div class="children"><div class="content">Really depends on what you need, depends on size, team structure, budget, and so many other things.</div><br/></div></div></div></div><div id="36501138" class="c"><input type="checkbox" id="c-36501138" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500231">parent</a><span>|</span><a href="#36501281">prev</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36501138">[-]</label><label class="expand" for="c-36501138">[9 more]</label></div><br/><div class="children"><div class="content">an application (client) should be free to query a database (server) directly<p>a stored procedure is an implicit dependency between client and server, fine as an optimization, but definitely not what you want to do by default</div><br/><div id="36501427" class="c"><input type="checkbox" id="c-36501427" checked=""/><div class="controls bullet"><span class="by">grugagag</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501138">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36501427">[-]</label><label class="expand" for="c-36501427">[8 more]</label></div><br/><div class="children"><div class="content">For CRUD stuff if you don’t care about execution plan cache and other optimizations it could save you some time sure to query directly. For chunks of code that transactions&#x2F;procesing large data directly on the server I’d reach out for stored procedures without thinking too much</div><br/><div id="36501491" class="c"><input type="checkbox" id="c-36501491" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501427">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36501491">[-]</label><label class="expand" for="c-36501491">[7 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not like stored procedures are inherently faster than normal queries, right?<p>as long as you&#x27;re not doing anything dumb like connection-per-request, query caching should work the same</div><br/><div id="36502051" class="c"><input type="checkbox" id="c-36502051" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501491">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36502051">[-]</label><label class="expand" for="c-36502051">[6 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    it&#x27;s not like stored procedures are inherently 
    faster than normal queries, right?
</code></pre>
They&#x27;re doing the same amount of &quot;work&quot; with regards to finding&#x2F;creating&#x2F;updating&#x2F;deleting rows.<p>But you (potentially) avoid shuffling all of that data back and forth between your DB server and your app.<p>This can be an orders-of-magnitude benefit if we are describing a multistep process that would involve lots of round trips, and&#x2F;or involves a lot of rows that would have to be piped over the network from the DB server to the app.<p>Suppose that when I create an order, I want to perform some other actions. I want to update inventory levels, calculate the user&#x27;s new rewards balance, blah blah blah. I could do all of that in a single stored procedure without bouncing all of that data back and forth between DB and client in a multistep process. That could matter a <i>lot</i> in terms of scalability, because now maybe I only have to hold that transaction lock for 20ms instead of 200ms while I make all of those round trips.<p>There are a lot of obvious downsides to using stored procedures, but they can be very effective as well. I would not use them as a default choice for most things but they can be a valuable optimization.</div><br/><div id="36502290" class="c"><input type="checkbox" id="c-36502290" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502051">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36502290">[-]</label><label class="expand" for="c-36502290">[5 more]</label></div><br/><div class="children"><div class="content">huh?<p>a single request returns a single result set to the client, whether it&#x27;s a stored procedure or a direct query<p>and any stored procedure can be equivalently expressed as a direct query, right?</div><br/><div id="36502377" class="c"><input type="checkbox" id="c-36502377" checked=""/><div class="controls bullet"><span class="by">grugagag</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502290">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36502377">[-]</label><label class="expand" for="c-36502377">[4 more]</label></div><br/><div class="children"><div class="content">For example you can look up millions of rows then manipulate some data, aggregate some other data and in the end return a result set without shuffling back and forth client&#x2F;server.</div><br/><div id="36502518" class="c"><input type="checkbox" id="c-36502518" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502377">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36502518">[-]</label><label class="expand" for="c-36502518">[3 more]</label></div><br/><div class="children"><div class="content">you can do that equally well in a stored procedure and a single query<p>like, you can write a query which does all of these transforms in sequence, and returns the final result set<p>the data that goes between client and server is only that final result set, it&#x27;s not like the client receives each intermediate step&#x27;s results and sends them back again?</div><br/><div id="36502966" class="c"><input type="checkbox" id="c-36502966" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502518">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36502966">[-]</label><label class="expand" for="c-36502966">[2 more]</label></div><br/><div class="children"><div class="content">If you’re going to mix multiple queries with procedural logic — eg running query A vs B depending on whatever conditions based on query C, then a stored proc saves you the round trips versus doing it in your app code. That’s all he’s saying.</div><br/><div id="36503138" class="c"><input type="checkbox" id="c-36503138" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502966">parent</a><span>|</span><a href="#36502329">next</a><span>|</span><label class="collapse" for="c-36503138">[-]</label><label class="expand" for="c-36503138">[1 more]</label></div><br/><div class="children"><div class="content">it doesn&#x27;t! whatever code you put into the stored proc you can equally well put into a query, and the round-trip costs would be equivalent<p>a stored proc is just a query saved on the db server, nothing more<p>if you destructure a stored proc to multiple individual queries, ok, sure, but who would do that?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36502329" class="c"><input type="checkbox" id="c-36502329" checked=""/><div class="controls bullet"><span class="by">IceSentry</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36500231">prev</a><span>|</span><a href="#36502809">next</a><span>|</span><label class="collapse" for="c-36502329">[-]</label><label class="expand" for="c-36502329">[1 more]</label></div><br/><div class="children"><div class="content">Some libraries can use string interpolation to create parameterized queries automatically.</div><br/></div></div><div id="36502809" class="c"><input type="checkbox" id="c-36502809" checked=""/><div class="controls bullet"><span class="by">krzyk</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36502329">prev</a><span>|</span><a href="#36501838">next</a><span>|</span><label class="collapse" for="c-36502809">[-]</label><label class="expand" for="c-36502809">[1 more]</label></div><br/><div class="children"><div class="content">Proper string interpolation is not (see JEP 430).</div><br/></div></div><div id="36501838" class="c"><input type="checkbox" id="c-36501838" checked=""/><div class="controls bullet"><span class="by">kdazzle</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36502809">prev</a><span>|</span><a href="#36500923">next</a><span>|</span><label class="collapse" for="c-36501838">[-]</label><label class="expand" for="c-36501838">[3 more]</label></div><br/><div class="children"><div class="content">Man, you know what you can really just mostly ignore when you’re using an ORM?<p>Injection<p>If i’m building an app or an API, I will ORM till I die (as long as it’s Django). If I need anything so much as a groupby, though, i will drop right into SQL or create an aggregate table that my ORM can just do a basic SELECT from</div><br/><div id="36502180" class="c"><input type="checkbox" id="c-36502180" checked=""/><div class="controls bullet"><span class="by">jkaplowitz</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501838">parent</a><span>|</span><a href="#36500923">next</a><span>|</span><label class="collapse" for="c-36502180">[-]</label><label class="expand" for="c-36502180">[2 more]</label></div><br/><div class="children"><div class="content">If you’re just worried about injection, you just need to use bound parameters instead of string interpolation. Boom, avoided at the database driver level even with plain sql. I admit though that some cases of string interpolation can be harder to catch in your code than when using ORMs.</div><br/><div id="36502595" class="c"><input type="checkbox" id="c-36502595" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502180">parent</a><span>|</span><a href="#36500923">next</a><span>|</span><label class="collapse" for="c-36502595">[-]</label><label class="expand" for="c-36502595">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, the git gut method of software engineering, an endless font of teaching opportunities from being a bottomless well of fuckups.<p>Especially unhelpful when the dynamic sql is legit.</div><br/></div></div></div></div></div></div><div id="36500923" class="c"><input type="checkbox" id="c-36500923" checked=""/><div class="controls bullet"><span class="by">wernercd</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500217">parent</a><span>|</span><a href="#36501838">prev</a><span>|</span><a href="#36501629">next</a><span>|</span><label class="collapse" for="c-36500923">[-]</label><label class="expand" for="c-36500923">[2 more]</label></div><br/><div class="children"><div class="content">My first thought is to scream in horror as Bobby Tables says hi to &quot;string interpolation&quot;. complaining about evil ORMs and then just asking to get taken to the cleaners...</div><br/><div id="36501094" class="c"><input type="checkbox" id="c-36501094" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500923">parent</a><span>|</span><a href="#36501629">next</a><span>|</span><label class="collapse" for="c-36501094">[-]</label><label class="expand" for="c-36501094">[1 more]</label></div><br/><div class="children"><div class="content">I really feel like a good chunk of the discussions around ORM&#x2F;not ORM and such are because the core method of interacting with our databases <i>sucks</i>.<p>Passing strings around is an <i>awful</i> interface, and maybe if we explored the space to fix that, a good chunk of these subsequent problems would be obviated.</div><br/></div></div></div></div></div></div><div id="36501629" class="c"><input type="checkbox" id="c-36501629" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36500217">prev</a><span>|</span><a href="#36503027">next</a><span>|</span><label class="collapse" for="c-36501629">[-]</label><label class="expand" for="c-36501629">[4 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;you don&#x27;t need to know SQL&quot;<p>Who is making those claims? Really? I&#x27;ve used Hibernate probably about as long as you have, and to me: it&#x27;s fine. Is it perfect? Of course not, but if I have to make the trade-off between Hibernate (or nowadays Spring Data) or rolling my own abstraction to interact with the database, for any kind of non-trivial application, I would not roll my own.<p>When you roll your own, you know what you&#x27;re doing: still ORM!<p>And like with many things: date and time zone math, encryption, writing databases, and ORM, if you can pull in a specialized tool, you can focus on your core business, and don&#x27;t have to become an expert in a field that&#x27;s not your core business.</div><br/><div id="36502514" class="c"><input type="checkbox" id="c-36502514" checked=""/><div class="controls bullet"><span class="by">freetime2</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501629">parent</a><span>|</span><a href="#36501725">next</a><span>|</span><label class="collapse" for="c-36502514">[-]</label><label class="expand" for="c-36502514">[1 more]</label></div><br/><div class="children"><div class="content">It’s frustrating to see “not needing to know SQL” as supposed reason for using an ORM. If you don’t have a decent foundational knowledge of SQL and relational DBs, of course you are going to have a bad time with ORMs.<p>ORMs can help you to <i>write</i> less SQL, and less boilerplate for getting data in and out of the database. But pretty soon you’re going to need to debug something, and without a solid understanding of DBs and SQL, you’re going to be hopelessly lost.</div><br/></div></div><div id="36501725" class="c"><input type="checkbox" id="c-36501725" checked=""/><div class="controls bullet"><span class="by">john-radio</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501629">parent</a><span>|</span><a href="#36502514">prev</a><span>|</span><a href="#36503027">next</a><span>|</span><label class="collapse" for="c-36501725">[-]</label><label class="expand" for="c-36501725">[2 more]</label></div><br/><div class="children"><div class="content">This year happens to be the first year when I worked with SQL enough to say that I know my ass from a hole in the ground in the language, and my job title is Senior Backend Developer and I have 11 years in tech and 5 as a developer. My journey with SQL is basically the GIF of Colin Farrell running in circles avoiding the violent American tourist in In Bruges; I have some good qualities as a developer but diligence in learning SQL is not one of them.</div><br/><div id="36502460" class="c"><input type="checkbox" id="c-36502460" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501725">parent</a><span>|</span><a href="#36503027">next</a><span>|</span><label class="collapse" for="c-36502460">[-]</label><label class="expand" for="c-36502460">[1 more]</label></div><br/><div class="children"><div class="content">I learned SQL many many years ago using Microsoft Access. It has (or at least had, I don’t know how it’s changed) a great visual query builder which would generate and run the SQL for you.<p>Seeing what SQL it generated, and the data it produced from the diagram I had created, was really helpful in learning interactively. Any tool that does this (well enough) should help a lot.</div><br/></div></div></div></div></div></div><div id="36503027" class="c"><input type="checkbox" id="c-36503027" checked=""/><div class="controls bullet"><span class="by">YmiYugy</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36501629">prev</a><span>|</span><a href="#36503880">next</a><span>|</span><label class="collapse" for="c-36503027">[-]</label><label class="expand" for="c-36503027">[1 more]</label></div><br/><div class="children"><div class="content">I don’t get how people jump from “it doesn’t work sometimes” to “never use it”.
You can write raw sql when the ORM fails. But for many queries the ORM does work, so why not use it?</div><br/></div></div><div id="36503880" class="c"><input type="checkbox" id="c-36503880" checked=""/><div class="controls bullet"><span class="by">javier2</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503027">prev</a><span>|</span><a href="#36502974">next</a><span>|</span><label class="collapse" for="c-36503880">[-]</label><label class="expand" for="c-36503880">[1 more]</label></div><br/><div class="children"><div class="content">I 100% agree. My goto is «hibernate makes simple things easier and hard things harder».
JDBC can be a little bare-bones so I prefer something like JDBI.</div><br/></div></div><div id="36502974" class="c"><input type="checkbox" id="c-36502974" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503880">prev</a><span>|</span><a href="#36501561">next</a><span>|</span><label class="collapse" for="c-36502974">[-]</label><label class="expand" for="c-36502974">[1 more]</label></div><br/><div class="children"><div class="content">I have always thought that ORM with overrides could be the answer. At the call site objects to be extracted&#x2F;inserted are defined. The implementation checks whether there is DBA written query and executes that or tries to generate something. A fancy DAO with auto-generation if you will.<p>If you want any sort of database maintainability you just cannot have queries concatenated from strings scattered around code, especially in environments with code hot loading. Otherwise, database migrations quickly start requiring shims for old interface. So ORMs&#x2F;DAOs are absolutely necessary in any larger application just to maintain (hehe) maintainability.<p>At this point why not have the abstraction layer auto generate queries? DBA time is much better spent optimizing those &quot;few&quot; queries that do matter for performance than writing thousands of straightforward CRUD queries.<p>&gt; Another selling point which is &quot;you don&#x27;t need to know SQL&quot;, is also garbage<p>On one hand, programmers do not need to know SQL beyond basic data extraction techniques. DBA is going to be better than them at the job anyway, even if for the reason that DBAs have access to (and to look at) performance metrics. On the other hand, auto-generator is going to be worse than a DBA too, therefore &quot;you don&#x27;t need to know SQL&quot; is garbage. We already have to fight SQL engine, now we have ORM layer to fight on top.</div><br/></div></div><div id="36501561" class="c"><input type="checkbox" id="c-36501561" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36502974">prev</a><span>|</span><a href="#36503364">next</a><span>|</span><label class="collapse" for="c-36501561">[-]</label><label class="expand" for="c-36501561">[6 more]</label></div><br/><div class="children"><div class="content">&gt; One of the selling points, which is now understood to be garbage, is that you can use different databases. But no-one uses different databases.<p>In Django world (python web framework) we do all the time:  in-memory sqlite for tests for speed, anything else for the actual app.</div><br/><div id="36502021" class="c"><input type="checkbox" id="c-36502021" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501561">parent</a><span>|</span><a href="#36503364">next</a><span>|</span><label class="collapse" for="c-36502021">[-]</label><label class="expand" for="c-36502021">[5 more]</label></div><br/><div class="children"><div class="content">You never use DB-specific features? We use postgres&#x27; JSONB column type which precludes using something like sqlite in tests.</div><br/><div id="36502442" class="c"><input type="checkbox" id="c-36502442" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502021">parent</a><span>|</span><a href="#36502634">next</a><span>|</span><label class="collapse" for="c-36502442">[-]</label><label class="expand" for="c-36502442">[3 more]</label></div><br/><div class="children"><div class="content">Most of our projects are mysql, and in those we don&#x27;t use any db-specific features.  Those all use in-memory sqlite for tests.  Only in one of our projects do we use jsonb with postgres, that one does use postgres for the tests as well.  Though, that project probably didn&#x27;t need it - we&#x27;re just sort of stuffing semi-regular data from another system into it.  It would have worked just as well as a text field that was parsed as-needed, since as far as I remember we don&#x27;t query it directly, only query based on other columns in that table.</div><br/><div id="36502942" class="c"><input type="checkbox" id="c-36502942" checked=""/><div class="controls bullet"><span class="by">anticodon</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502442">parent</a><span>|</span><a href="#36502634">next</a><span>|</span><label class="collapse" for="c-36502942">[-]</label><label class="expand" for="c-36502942">[2 more]</label></div><br/><div class="children"><div class="content">You can run tests in MySQL in memory almost as easily.<p><pre><code>   database-autotests:
       volumes:
          - mysql-autotests-volume:&#x2F;var&#x2F;lib&#x2F;mysql

   volumes:
       mysql-autotests-volume:
       driver_opts:
       type: tmpfs
       o: &quot;size=2G,mode=777&quot;
       device: tmpfs

</code></pre>
It&#x27;s also very fast and allows to test the code on the same database, especially if you have something MySQL-specific.</div><br/></div></div></div></div><div id="36502634" class="c"><input type="checkbox" id="c-36502634" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502021">parent</a><span>|</span><a href="#36502442">prev</a><span>|</span><a href="#36503364">next</a><span>|</span><label class="collapse" for="c-36502634">[-]</label><label class="expand" for="c-36502634">[1 more]</label></div><br/><div class="children"><div class="content">Why would it? Sqlite has had json support for years. The ORM can abstract over column types, and functions.</div><br/></div></div></div></div></div></div><div id="36503364" class="c"><input type="checkbox" id="c-36503364" checked=""/><div class="controls bullet"><span class="by">alserio</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36501561">prev</a><span>|</span><a href="#36503443">next</a><span>|</span><label class="collapse" for="c-36503364">[-]</label><label class="expand" for="c-36503364">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  But no-one uses different databases.<p>I do. And I use Hibernate to abstract over mysql and oracle, since I want to keep clients that use both.
You need a little more work than that, but it make it possible.
Hibernate is not the technology I love the most, but it does some non trivial work like managing the unit of work, graph caching and mapping that can be useful. It is also highly prone to be used wrong by devs.
You might not need hibernate, sometimes it might help. It should probably be used less than what you see in the wild, though.</div><br/></div></div><div id="36503443" class="c"><input type="checkbox" id="c-36503443" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503364">prev</a><span>|</span><a href="#36501571">next</a><span>|</span><label class="collapse" for="c-36503443">[-]</label><label class="expand" for="c-36503443">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been doing ORM on Java since Hibernate was new, and it has always sucked.<p>Have you ever looked at something like myBatis? In particular, the XML mappers: <a href="https:&#x2F;&#x2F;mybatis.org&#x2F;mybatis-3&#x2F;dynamic-sql.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;mybatis.org&#x2F;mybatis-3&#x2F;dynamic-sql.html</a><p>Looking back, I actually quite liked it - you had conditionals and ability to build queries dynamically (including snippets, doing loops etc.), while still writing mostly SQL with a bit of XML DSL around it, which didn&#x27;t suck as much as one might imagine. The only problem was that there was still writing some boilerplate, which I wasn&#x27;t the biggest fan of.<p>Hibernate always felt like walking across a bridge that might collapse at any moment (one eager fetch away from killing the performance, or having some obscure issue related to the entity mappings), however I liked tooling that let you point towards your database and get a local set of entities mapped automatically, even though codegen also used to have some issues occasionally (e.g. date types).<p>That said, there&#x27;s also projects like jOOQ which had a more code centric approach, although I recall it being slightly awkward to use in practice: <a href="https:&#x2F;&#x2F;www.jooq.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jooq.org&#x2F;</a> (and the autocomplete killed the performance in some IDEs because of all the possible method signatures)<p>More recently, when working on a Java project, I opted for JDBI3, which felt reasonably close to what you&#x27;re describing, at the expense of not being able to build dynamic queries as easily as it was with myBatis: <a href="https:&#x2F;&#x2F;jdbi.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jdbi.org&#x2F;</a><p>With the multi-line string support we have in Java now, it was rather pleasant regardless: <a href="https:&#x2F;&#x2F;blog.kronis.dev&#x2F;tutorials&#x2F;2-4-pidgeot-a-system-for-millions-of-documents-the-application" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.kronis.dev&#x2F;tutorials&#x2F;2-4-pidgeot-a-system-for-m...</a><p>I don&#x27;t think there&#x27;s a silver bullet out there, everything from lightweight ORMs, to heavy ORMs like Hibernate, or even writing pure SQL has drawbacks. You just have to make the tradeoffs that will see you being successful in your particular project.</div><br/><div id="36503575" class="c"><input type="checkbox" id="c-36503575" checked=""/><div class="controls bullet"><span class="by">namero999</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503443">parent</a><span>|</span><a href="#36501571">next</a><span>|</span><label class="collapse" for="c-36503575">[-]</label><label class="expand" for="c-36503575">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t vouch enough for MyBatis, using it since forever and it never let me down, or produced any sort of frustration.<p>It strikes the perfect balance: on code level, you still work with domain objects and the db access sublimates away into single lines of code (select, update, ...), but they are backed by handcrafted queries that can leverage the full potential of the db. What MyBatis does is mapping from an arbitrary result set to your domain object, and it&#x27;s _really smart_ about it (it knows how to convert most data types and perform arbitrary level of recursion&#x2F;nesting of objects, or return collections). For all those things that it can&#x27;t possibly do (like intermediary JSON conversions or things like that) you have an handy TypeHandler abstraction, that you can tuck away in a dedicated package for autodiscovery and doesn&#x27;t pollute your code or queries.<p>Also, you pay only 3% over raw JDBC in the average case.<p>If you love MyBatis please donate: it can&#x27;t go away.</div><br/></div></div></div></div><div id="36501571" class="c"><input type="checkbox" id="c-36501571" checked=""/><div class="controls bullet"><span class="by">desiderantes</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503443">prev</a><span>|</span><a href="#36502750">next</a><span>|</span><label class="collapse" for="c-36501571">[-]</label><label class="expand" for="c-36501571">[3 more]</label></div><br/><div class="children"><div class="content">This is why I moved to jOOQ years ago. Nice lean abstraction over SQL, to the point where it&#x27;s just a typesafe SQL builder and also does the mapping to domain objects if you want. Abstracts and polyfills SQL capabilities just enough for you to be able to port your queries between DBs if desired.</div><br/><div id="36502470" class="c"><input type="checkbox" id="c-36502470" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501571">parent</a><span>|</span><a href="#36502067">next</a><span>|</span><label class="collapse" for="c-36502470">[-]</label><label class="expand" for="c-36502470">[1 more]</label></div><br/><div class="children"><div class="content">jOOQ is far and away the best library in this class for any ecosystem.<p>It&#x27;s so good you would need to think long and hard not to choose the JVM for a SQL heavy application because it&#x27;s just that damn good and most other library requirements are relatively interchangeable.</div><br/></div></div><div id="36502067" class="c"><input type="checkbox" id="c-36502067" checked=""/><div class="controls bullet"><span class="by">illamint</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36501571">parent</a><span>|</span><a href="#36502470">prev</a><span>|</span><a href="#36502750">next</a><span>|</span><label class="collapse" for="c-36502067">[-]</label><label class="expand" for="c-36502067">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only had a brief stint in Java in my career, but I got to learn about and use jOOQ, and I think it&#x27;s such a fantastic option in this space. I&#x27;m still a diehard SQLAlchemy fan, and I&#x27;d use it in Python-land. For Go, I think sqlc is a decent option, but it&#x27;s no jOOQ. I&#x27;d love jOOQ for Go.</div><br/></div></div></div></div><div id="36502750" class="c"><input type="checkbox" id="c-36502750" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36501571">prev</a><span>|</span><a href="#36502543">next</a><span>|</span><label class="collapse" for="c-36502750">[-]</label><label class="expand" for="c-36502750">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How many man-hours have been wasted on ORM, XML, annotations, debugging generated SQL, and so on? It makes me cry.<p>Agreed. All my greatest successes with ORMs have been ripping them out of projects I&#x27;ve inherited. The results have been more maintainable code that&#x27;s faster and less resource intensive.</div><br/></div></div><div id="36502543" class="c"><input type="checkbox" id="c-36502543" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36502750">prev</a><span>|</span><a href="#36502706">next</a><span>|</span><label class="collapse" for="c-36502543">[-]</label><label class="expand" for="c-36502543">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if you&#x27;re speaking specifically about Hibernate, but if you are making the argument against ORMS generally, I feel like there are some counterarguments to the points you mention:<p>&gt;  Every non-trivial long-lived application will require tweaks to individual queries at the string level<p>I suspect that the difference in expectations here is about how many of the queries will need that, and whether the number of less sensitive queries is large enough that it&#x27;s worth having less boilerplate for them even if some other queries do need to be able to drop into something lower-level. People will quibble about where this boundary is, and maybe the real disagreement is about where to drawn the line between &quot;trivial&quot; and &quot;non-trivial&quot; applications, but I don&#x27;t think it&#x27;s quite as obvious a conclusion that ORMS aren&#x27;t useful in the general case as it sounds like you&#x27;re arguing.<p>&gt; The proper way to build a data layer is one query at a time, as a string, with string interpolation<p>This also isn&#x27;t obvious to me. I can understand the advantages it provides, but it only lets you move the problem of conversion to native types in your language to outside the query layer, not eliminate it. I think there&#x27;s a solid argument that splitting up the problem that way is better, but again, it seems more nuanced to me than there being one obvious answer.<p>&gt; The closer you are to raw JDBC the better<p>How are you sure that it&#x27;s impossible to provide any sort of useful abstraction here? There are plenty of other cases where using the lowest-level language possible isn&#x27;t the obvious correct choice all the time; it doesn&#x27;t sound like you&#x27;re writing your code in raw assembly either, so there&#x27;s obviously some utility in using higher-level abstractions.</div><br/></div></div><div id="36502706" class="c"><input type="checkbox" id="c-36502706" checked=""/><div class="controls bullet"><span class="by">theshrike79</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36502543">prev</a><span>|</span><a href="#36503679">next</a><span>|</span><label class="collapse" for="c-36502706">[-]</label><label class="expand" for="c-36502706">[5 more]</label></div><br/><div class="children"><div class="content">Every non-trivial project that uses an ORM will, at one point, fetch the whole database.<p>Either by someone accidentally creating mappings that do it without noticing or someone not understanding that there&#x27;s a whole-ass database in there and they just fetch everything local and filter with a for-loop.</div><br/><div id="36502915" class="c"><input type="checkbox" id="c-36502915" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502706">parent</a><span>|</span><a href="#36503679">next</a><span>|</span><label class="collapse" for="c-36502915">[-]</label><label class="expand" for="c-36502915">[4 more]</label></div><br/><div class="children"><div class="content">I have been coding on Java since v1 and wrote basic ORMs before Hibernate was a thing (yes, in EJB world). There were pretty big and complex projects in fintech and healthcare, but I have never encountered the situation you describe. Maybe I was lucky, but logically you cannot say “every non-trivial project”.</div><br/><div id="36503103" class="c"><input type="checkbox" id="c-36503103" checked=""/><div class="controls bullet"><span class="by">spyke112</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36502915">parent</a><span>|</span><a href="#36503679">next</a><span>|</span><label class="collapse" for="c-36503103">[-]</label><label class="expand" for="c-36503103">[3 more]</label></div><br/><div class="children"><div class="content">Some years ago Entity Framework followed navigational properties (foreign keys) by default, which quickly escalates. The scenario could be a user table referencing a organisation table, so that when quering for an org, you’d get every user.<p>Fell into this one personally, it sucked!</div><br/><div id="36503168" class="c"><input type="checkbox" id="c-36503168" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503103">parent</a><span>|</span><a href="#36503679">next</a><span>|</span><label class="collapse" for="c-36503168">[-]</label><label class="expand" for="c-36503168">[2 more]</label></div><br/><div class="children"><div class="content">This must be a mistake that you do once as a junior and then never repeat. When you declare a field with collection, would not it be natural to ask how it works?</div><br/><div id="36503694" class="c"><input type="checkbox" id="c-36503694" checked=""/><div class="controls bullet"><span class="by">spyke112</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36503168">parent</a><span>|</span><a href="#36503679">next</a><span>|</span><label class="collapse" for="c-36503694">[-]</label><label class="expand" for="c-36503694">[1 more]</label></div><br/><div class="children"><div class="content">Definitely! The problem though, is that this issue creeps up on you over time, and maybe only i  production, because the performance is directly correlated to the amount of data in the database.<p>But I guess issues like these are what transition you from junior developer into whatever comes next.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36503679" class="c"><input type="checkbox" id="c-36503679" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36502706">prev</a><span>|</span><a href="#36500528">next</a><span>|</span><label class="collapse" for="c-36503679">[-]</label><label class="expand" for="c-36503679">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One of the selling points, which is now understood to be garbage, is that you can use different databases<p>Yup, and even if the ORM supports multiple databases, once you have committed to one database, it&#x27;s almost impossible to switch to another due to different convention being used for data mapping.</div><br/></div></div><div id="36500528" class="c"><input type="checkbox" id="c-36500528" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36500185">parent</a><span>|</span><a href="#36503679">prev</a><span>|</span><a href="#36498275">next</a><span>|</span><label class="collapse" for="c-36500528">[-]</label><label class="expand" for="c-36500528">[2 more]</label></div><br/><div class="children"><div class="content">Not to mention the 8 second startup time penalty to generate 150 models worth of Hibernate code at runtime (every time, with no caching...)<p>Over the course of a month this cost <i>me</i> as much as 2 hours of time.</div><br/><div id="36500737" class="c"><input type="checkbox" id="c-36500737" checked=""/><div class="controls bullet"><span class="by">equalsione</span><span>|</span><a href="#36500185">root</a><span>|</span><a href="#36500528">parent</a><span>|</span><a href="#36498275">next</a><span>|</span><label class="collapse" for="c-36500737">[-]</label><label class="expand" for="c-36500737">[1 more]</label></div><br/><div class="children"><div class="content">You _might_ be able to use AppCDS[0] to tackle this issue<p>[0] <a href="https:&#x2F;&#x2F;wiki.openjdk.org&#x2F;display&#x2F;HotSpot&#x2F;Application+Class+Data+Sharing+-+AppCDS" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.openjdk.org&#x2F;display&#x2F;HotSpot&#x2F;Application+Class+D...</a></div><br/></div></div></div></div></div></div><div id="36498275" class="c"><input type="checkbox" id="c-36498275" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36500185">prev</a><span>|</span><a href="#36498525">next</a><span>|</span><label class="collapse" for="c-36498275">[-]</label><label class="expand" for="c-36498275">[88 more]</label></div><br/><div class="children"><div class="content">In any sufficiently complex application, something like a query builder that allows different parts of the application to work together to lazily compose queries (vs combining&#x2F;filtering&#x2F;sorting the data in memory) will be created at some point.<p>ORM is a tool that can make this easier, it&#x27;s also a tool that can make it easier to shoot yourself in the foot (ie by making it easy to create N+1 queries without knowing). Like all tools, there are tradeoffs that need to be accounted for together with the actual use case to make a decision. Operating on SQL statement strings is not something I&#x27;d recommend in any case.</div><br/><div id="36501067" class="c"><input type="checkbox" id="c-36501067" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36498488">next</a><span>|</span><label class="collapse" for="c-36501067">[-]</label><label class="expand" for="c-36501067">[6 more]</label></div><br/><div class="children"><div class="content">Different people have wildly different experiences with ORMs as they used them for wildly different levels of integration and tasks, and in wildly different languages with different features that make ORMs more or less useful, yet there&#x27;s always someone willing to go out of their way and ignore all that and make absolutest statements about how it&#x27;s good or bad.<p>We should just learn to recognize it for what it is, someone that&#x27;s being controversial for attention, and move on.  Let&#x27;s save our attention for the ORM article and discussion that starts out along the lines of &quot;ORMs can provide benefit, but it&#x27;s important to recognize where, and not let the problems of their use outweigh their benefits. Here&#x27;s what I&#x27;ve found.&quot;</div><br/><div id="36502538" class="c"><input type="checkbox" id="c-36502538" checked=""/><div class="controls bullet"><span class="by">_gabe_</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501067">parent</a><span>|</span><a href="#36501276">next</a><span>|</span><label class="collapse" for="c-36502538">[-]</label><label class="expand" for="c-36502538">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Different people have wildly different experiences with ORMs as they used them for wildly different levels of integration and tasks, and in wildly different languages with different features that make ORMs more or less useful, yet there&#x27;s always someone willing to go out of their way and ignore all that and make absolutest statements about how it&#x27;s good or bad.<p>I don&#x27;t have a horse in this race, I could care less if you do or don&#x27;t use an ORM. But, and maybe this is the cynic in me, there are practices in software development that absolutely, 100%, for certain, have no good reason and are perpetuated in part by this belief that there must have been a good reason for it to exist (Chesterton&#x27;s fence and all that).<p>Null terminated C strings are a prime example. There is absolutely no good reason, other than the fact that the authors may have wanted to save 3 bytes, that C strings should be null terminated. Fortran was created in 1954, and passed the length of the string with the string itself. How many countless bugs and CVEs have risen due to errors in handling null terminated C strings (one example[0])? And for what? To save 3 bytes or just because of the authors decision at a whim&#x27;s notice?<p>Likewise, decisions made at Javascript&#x27;s inception have burdened it for its entire life. Decisions that were made at a whim&#x27;s notice, like implicitly converting numbers to strings sometimes, and sometimes implicitly converting strings to numbers! (Tell me what `10 + &quot;10&quot;` is and what `&quot;10&quot; + 10` is without using the inspector). And the million and one ways to define something that&#x27;s undefined.<p>Anyways, when somebody tells me there&#x27;s absolutely no good reason for a development practice to exist, sometimes, that <i>is</i> the absolute truth. And I would rather have more people throwing away these crummy practices that lead to unnecessary headaches (or at least questioning them) then people continuing to laud the practice and perpetuate it ad infinitum.<p>[0]: <a href="https:&#x2F;&#x2F;defendtheweb.net&#x2F;article&#x2F;common-php-attacks-poison-null-byte" rel="nofollow noreferrer">https:&#x2F;&#x2F;defendtheweb.net&#x2F;article&#x2F;common-php-attacks-poison-n...</a></div><br/><div id="36504030" class="c"><input type="checkbox" id="c-36504030" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502538">parent</a><span>|</span><a href="#36503467">next</a><span>|</span><label class="collapse" for="c-36504030">[-]</label><label class="expand" for="c-36504030">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Null terminated C strings are a prime example<p>It’s funny - it’s almost like C never had a string type and null-termination is more a convention than a primitive data type.<p>There’s nothing that prevents us from having Pascal-like strings as much as we want, provided we know we’ll need to reimplement everything we need.</div><br/></div></div><div id="36503467" class="c"><input type="checkbox" id="c-36503467" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502538">parent</a><span>|</span><a href="#36504030">prev</a><span>|</span><a href="#36502711">next</a><span>|</span><label class="collapse" for="c-36503467">[-]</label><label class="expand" for="c-36503467">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Null terminated C strings are a prime example. There is absolutely no good reason, other than the fact that the authors may have wanted to save 3 bytes<p>Or, you know, they wanted to make the language track assembly as closely as possibly (which was possibly back at that time when processors were much simpler and instructions weren&#x27;t constantly reordered), and if you&#x27;ve ever written assembly, you know you&#x27;re not really working at a string level, you&#x27;re working at a byte and character level. Sized strings are more complex than null terminated ones in that you either need to set a max size or you need to waste multiple bytes per string (which actually mattered on many systems C was used on when it was developed) or you have to use masks on those early bytes to or determine if the next byte is part of the string or a continuation of the size.<p>And honestly, when you&#x27;re working on systems where ram (and maybe storage) is in kilobytes or less and speed is in kilohertz, the extra code to do that and the extra time to process them and the extra space to store sized strings is a lot less of an obvious choice to make.<p>Was C a good choice for the time and where it was used? Possibly. Is it a good choice these days? Probably not without a bunch of extra utils and compiler guards to beat back the worst problems. I do t blame C as much for that as I do the people that continue to use it without extra safeguards.<p>What was that you said about Chesterton&#x27;s fence?  That&#x27;s one of those terms you should be careful about throwing around when supporting an absolutist position...</div><br/></div></div><div id="36502711" class="c"><input type="checkbox" id="c-36502711" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502538">parent</a><span>|</span><a href="#36503467">prev</a><span>|</span><a href="#36501276">next</a><span>|</span><label class="collapse" for="c-36502711">[-]</label><label class="expand" for="c-36502711">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Decisions that were made at a whim&#x27;s notice, like implicitly converting numbers to strings sometimes, and sometimes implicitly converting strings to numbers!<p>I see this as a problem that&#x27;s horribly inflated by those who don&#x27;t use JS on a daily basis.<p>Practitioners of the language largely don&#x27;t care, because in actual code you rarely see cases where it would matter.<p>Now that we have template strings it&#x27;s even less relevant.</div><br/></div></div></div></div><div id="36501276" class="c"><input type="checkbox" id="c-36501276" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501067">parent</a><span>|</span><a href="#36502538">prev</a><span>|</span><a href="#36498488">next</a><span>|</span><label class="collapse" for="c-36501276">[-]</label><label class="expand" for="c-36501276">[1 more]</label></div><br/><div class="children"><div class="content">what have you found?</div><br/></div></div></div></div><div id="36498488" class="c"><input type="checkbox" id="c-36498488" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36501067">prev</a><span>|</span><a href="#36498359">next</a><span>|</span><label class="collapse" for="c-36498488">[-]</label><label class="expand" for="c-36498488">[34 more]</label></div><br/><div class="children"><div class="content">&gt; In any sufficiently complex application, something like a query builder that allows different parts of the application to work together to lazily compose queries<p>I don&#x27;t see this as a given and I don&#x27;t accept it in my own applications. If you need data, go to the data access layer. If it doesn&#x27;t provide you what you need, build a new repository &#x2F; provider &#x2F; whatever your pattern is.<p>Whether it&#x27;s an ORM or a home-built query compositor or whatever, one thing I know from experience is that once your application is &quot;sufficiently complex&quot; that you start to (incorrectly) believe you need this, your application has become too complex to use it reliably.<p>You absolutely will be mistakenly evaluating these builders in the wrong layers, iterating results without realising you&#x27;re generating N+1 queries, etc.<p>You don&#x27;t need an ORM.</div><br/><div id="36500243" class="c"><input type="checkbox" id="c-36500243" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498488">parent</a><span>|</span><a href="#36498743">next</a><span>|</span><label class="collapse" for="c-36500243">[-]</label><label class="expand" for="c-36500243">[23 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see this as a given and I don&#x27;t accept it in my own applications. If you need data, go to the data access layer. If it doesn&#x27;t provide you what you need, build a new repository &#x2F; provider &#x2F; whatever your pattern is.<p>Whichever layer you put it in, you need a way to compose two query fragments. Otherwise you have to write N*M queries manually instead of N+M query fragments.<p>Either you use an ORM to help you with this or you don&#x27;t, with all the usual tradeoffs about using a library or not. But you still have to solve the problem. (Or you do a lot of tedious copy-paste work - with all the usual tradeoffs of that)</div><br/><div id="36501187" class="c"><input type="checkbox" id="c-36501187" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500243">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36501187">[-]</label><label class="expand" for="c-36501187">[17 more]</label></div><br/><div class="children"><div class="content">usually, every interaction with your database is its own unique code path and query<p>it&#x27;s pretty rare for queries to be dynamically composed from arbitrary sub-queries<p>if this is a problem you need to solve then ORMs certainly make more sense, but even in this case I find query builders to be more effective<p>the interface between the application and the DB is actually a string! it&#x27;s not an abstract data type, it doesn&#x27;t benefit from being modeled by types</div><br/><div id="36501533" class="c"><input type="checkbox" id="c-36501533" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501187">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36501533">[-]</label><label class="expand" for="c-36501533">[9 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s pretty rare for queries to be dynamically composed from arbitrary sub-queries<p>I&#x27;m talking static, not dynamic. You still need to compose two pieces together into a single query, and you can either use an ORM to help with that or not.<p>&gt; the interface between the application and the DB is actually a string! it&#x27;s not an abstract data type, it doesn&#x27;t benefit from being modeled by types<p>No it isn&#x27;t. You can&#x27;t send an arbitrary string to the database and expect it to work.  At the very least you benefit from having an interface that&#x27;s structured enough to tell you whether your parentheses are balanced and your quotes are matched rather than having to figure that out at runtime.</div><br/><div id="36501679" class="c"><input type="checkbox" id="c-36501679" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501533">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36501679">[-]</label><label class="expand" for="c-36501679">[8 more]</label></div><br/><div class="children"><div class="content">huh?<p>when your app queries the db, the query is not composed from several pieces, it is well-defined in the relevant method<p><pre><code>    fn search(q string) -&gt; result
        return db.query(`SELECT id, text FROM table WHERE text LIKE $1;`, q)
</code></pre>
this is a single query, not multiple<p>the db accepts a string and parses it to an AST, it does not accept a typed value<p>this means the interface is the string<p>unbalanced parens and whatever other invalid syntax is obviously caught by tests</div><br/><div id="36501752" class="c"><input type="checkbox" id="c-36501752" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501679">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36501752">[-]</label><label class="expand" for="c-36501752">[7 more]</label></div><br/><div class="children"><div class="content">&gt; when your app queries the db, the query is not composed from several pieces, it is well-defined in the relevant method<p>&gt; this is a single query, not multiple<p>And when you want to query for multiple related things together, the whole point of having a relational database? For different purposes you need different views on your data, and those views are generally constructed out of a bunch of shared fragments; you can either figure out a way to share them, or copy-paste them everywhere you use them.<p>&gt; the db accepts a string and parses it to an AST, it does not accept a typed value<p>&gt; this means the interface is the string<p>The DB accepts a structured query, not a string. It might be represented as a string on the wire, but if that was what mattered then we&#x27;d use byte arrays for all our variables since everything&#x27;s a byte array at runtime.<p>&gt; unbalanced parens and whatever other invalid syntax is obviously caught by tests<p>Tests are a poor substitute for types.</div><br/><div id="36501877" class="c"><input type="checkbox" id="c-36501877" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501752">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36501877">[-]</label><label class="expand" for="c-36501877">[6 more]</label></div><br/><div class="children"><div class="content">i&#x27;m not sure what you&#x27;re thinking about when you say &quot;multiple related things&quot;<p>every &quot;view&quot; on your DB should be modeled as a separate function<p>every possible &quot;thing&quot; that&#x27;s input to a function which queries the database should be transformed into a part of the query string by that function<p>&gt; The DB accepts a structured query, not a string. It might be represented as a string on the wire, but if that was what mattered then we&#x27;d use byte arrays for all our variables since everything&#x27;s a byte array at runtime.<p>...no<p>the API literally receives a string and passes it directly to the DB&#x27;s query parser<p>if the DB accepted structured queries, then the API would rely on something like protobuf to parse raw bytes to native types -- it doesn&#x27;t<p>like `echo SELECT * FROM whatever; | psql` does not parse the `SELECT * FROM whatever;` string to a structured type, it sends the string directly to the database</div><br/><div id="36501996" class="c"><input type="checkbox" id="c-36501996" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501877">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36501996">[-]</label><label class="expand" for="c-36501996">[5 more]</label></div><br/><div class="children"><div class="content">&gt; every &quot;view&quot; on your DB should be modeled as a separate function<p>OK, and when a significant amount of what those functions do is shared, how do you share it? (E.g. imagine we&#x27;re building, IDK, some kind of CMS, and in one view we have authors (based on some criteria) and posts by those authors, and in another we have tags and posts under those tags, and in another we have date ranges and posts in that date range. How do you share the &quot;fetching posts&quot; bit of SQL between those three different (parameterized) queries?)<p>&gt; if the DB accepted structured queries, then the API would rely on something like protobuf to parse raw bytes to native types -- it doesn&#x27;t<p>&gt; like `echo SELECT * FROM whatever; | psql` does not parse the `SELECT * FROM whatever;` string to a structured type, it sends the string directly to the database<p>In both cases the parsing happens on the server, not the client. &quot;echo abcde | psql&quot; and &quot;curl -D abcde <a href="http:&#x2F;&#x2F;my-protobuf-service&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;my-protobuf-service&#x2F;</a>&quot; are both doing the same kind of thing - passing an unstructured string to a server which will fail to parse it and give some kind of error - and both equally useless.</div><br/><div id="36502198" class="c"><input type="checkbox" id="c-36502198" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501996">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36502198">[-]</label><label class="expand" for="c-36502198">[4 more]</label></div><br/><div class="children"><div class="content">&gt; How do you share the &quot;fetching posts&quot; bit of SQL between those three different (parameterized) queries?)<p>your application has a fetch posts method, that method takes input including (optional) author(s), tag(s), etc., it builds a query that includes WHERE clauses for every provided parameter<p>the code that converts an author to a WHERE clause can be a function, the point is it outputs a string, or something that is input to a builder and results in a string<p>i&#x27;m not sure what a &quot;fetching posts bit of SQL&quot; is, a query selects specific rows, qualified by where clauses that filter the result set, joins that modify it, etc.</div><br/><div id="36502346" class="c"><input type="checkbox" id="c-36502346" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502198">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36502346">[-]</label><label class="expand" for="c-36502346">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the code that converts an author to a WHERE clause can be a function, the point is it outputs a string, or something that is input to a builder and results in a string<p>So you do string-&gt;string processing, and you explicitly won&#x27;t treat the queries you&#x27;re generating as structured values? Enjoy your rampant SQL injection vulnerabilities.</div><br/><div id="36502508" class="c"><input type="checkbox" id="c-36502508" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502346">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36502508">[-]</label><label class="expand" for="c-36502508">[2 more]</label></div><br/><div class="children"><div class="content">no?<p>creating a query string that&#x27;s parameterized on input usually means you model those input parameters as `?` or `$1` or whatever, and provide them explicitly as part of the query<p>nobody is doing printfs of values</div><br/><div id="36502802" class="c"><input type="checkbox" id="c-36502802" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502508">parent</a><span>|</span><a href="#36501307">next</a><span>|</span><label class="collapse" for="c-36502802">[-]</label><label class="expand" for="c-36502802">[1 more]</label></div><br/><div class="children"><div class="content">Ok so now your WHERE clauses are no longer strings, you have to have some structured representation of them that knows which parameters go with which clauses, and something that understands the structure of your queries enough to line up the parameters when you stitch together different WHERE clauses to make your full query - exactly the kind of thing you were saying was unnecessary.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36501307" class="c"><input type="checkbox" id="c-36501307" checked=""/><div class="controls bullet"><span class="by">Daishiman</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501187">parent</a><span>|</span><a href="#36501533">prev</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36501307">[-]</label><label class="expand" for="c-36501307">[7 more]</label></div><br/><div class="children"><div class="content">You never built admin interfaces, faceted search or dynamic query filters?</div><br/><div id="36501451" class="c"><input type="checkbox" id="c-36501451" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501307">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36501451">[-]</label><label class="expand" for="c-36501451">[6 more]</label></div><br/><div class="children"><div class="content">sure, sometimes, rarely -- these are exceptions, not rules<p>in general, it should not be possible for user input to produce arbitrarily complex queries against your database<p>each input element in an HTML form should map to a well-defined parameter of a SQL query builder, like, you shouldn&#x27;t be dynamically composing sub-queries based on the value of a text field, the value should add a where or join or whatever other clause to the single well-defined query<p>sometimes this isn&#x27;t possible but these should be super rare exceptions</div><br/><div id="36502158" class="c"><input type="checkbox" id="c-36502158" checked=""/><div class="controls bullet"><span class="by">Daishiman</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501451">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36502158">[-]</label><label class="expand" for="c-36502158">[5 more]</label></div><br/><div class="children"><div class="content">I prefer using something like Rails or Django to build 10 fully working CRUD interfaces with well-defined yet dynamic filters in a day instead of spending two weeks needlessly writing the equivalent code by hand.</div><br/><div id="36502355" class="c"><input type="checkbox" id="c-36502355" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502158">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36502355">[-]</label><label class="expand" for="c-36502355">[4 more]</label></div><br/><div class="children"><div class="content">why would it take you two weeks to write 10 SQL simple queries?</div><br/><div id="36502545" class="c"><input type="checkbox" id="c-36502545" checked=""/><div class="controls bullet"><span class="by">Daishiman</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502355">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36502545">[-]</label><label class="expand" for="c-36502545">[3 more]</label></div><br/><div class="children"><div class="content">10 simple CRUDs you mean? With dynamic filters, admin UI, auth, tables, and so on? Because these frameworks allow you to do that in a single day.</div><br/><div id="36502607" class="c"><input type="checkbox" id="c-36502607" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502545">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36502607">[-]</label><label class="expand" for="c-36502607">[2 more]</label></div><br/><div class="children"><div class="content">i&#x27;m running out of ways to say that a CRUD endpoint should not have dynamism in the sense that you mean<p>&#x2F;users&#x2F;:id should map to 1 endpoint that&#x27;s parameterized on userid<p>&#x2F;search?userid=:userid&amp;tag=:tag should map to 1 endpoint that&#x27;s parameterized on userid and tag(s)<p>endpoints should be simple to write</div><br/><div id="36502784" class="c"><input type="checkbox" id="c-36502784" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502607">parent</a><span>|</span><a href="#36500925">next</a><span>|</span><label class="collapse" for="c-36502784">[-]</label><label class="expand" for="c-36502784">[1 more]</label></div><br/><div class="children"><div class="content">Yeah and programs should also be simple, but there would be no value to them that way.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36500925" class="c"><input type="checkbox" id="c-36500925" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500243">parent</a><span>|</span><a href="#36501187">prev</a><span>|</span><a href="#36502020">next</a><span>|</span><label class="collapse" for="c-36500925">[-]</label><label class="expand" for="c-36500925">[3 more]</label></div><br/><div class="children"><div class="content">Wait, why does every query fragment need to compose with every other?  What are the N and Ms here?</div><br/><div id="36502147" class="c"><input type="checkbox" id="c-36502147" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500925">parent</a><span>|</span><a href="#36502020">next</a><span>|</span><label class="collapse" for="c-36502147">[-]</label><label class="expand" for="c-36502147">[2 more]</label></div><br/><div class="children"><div class="content">Say you create a nice little utility function that makes a call to the db func1 and you write func2 that also makes a db query. If you have a func3
that needs func1 and func2 conceptually your options are:<p>* Accept that this will just be two trips to the DB.<p>* Write a new function func12 that writes a query to return all the needed data in one query and use that instead.<p>* Have your tool be able to automatically compose the queries.<p>If you do with the second option you have to do that with every combination of functions that end up being used together which is multiplicative in general.</div><br/><div id="36503170" class="c"><input type="checkbox" id="c-36503170" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502147">parent</a><span>|</span><a href="#36502020">next</a><span>|</span><label class="collapse" for="c-36503170">[-]</label><label class="expand" for="c-36503170">[1 more]</label></div><br/><div class="children"><div class="content">Well sure but that not necessary for every combination of every call.  Most likely those types of combinations are rare.</div><br/></div></div></div></div></div></div><div id="36502020" class="c"><input type="checkbox" id="c-36502020" checked=""/><div class="controls bullet"><span class="by">x-shadowban</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500243">parent</a><span>|</span><a href="#36500925">prev</a><span>|</span><a href="#36498743">next</a><span>|</span><label class="collapse" for="c-36502020">[-]</label><label class="expand" for="c-36502020">[2 more]</label></div><br/><div class="children"><div class="content">This is a problem, seems like ctes and views are a possible ormless solution here</div><br/><div id="36502360" class="c"><input type="checkbox" id="c-36502360" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502020">parent</a><span>|</span><a href="#36498743">next</a><span>|</span><label class="collapse" for="c-36502360">[-]</label><label class="expand" for="c-36502360">[1 more]</label></div><br/><div class="children"><div class="content">CTEs and views are both a bit bigger than the parts that you would normally want to share and reuse, and they&#x27;re also not very well standardised. Plus no-one really agrees on how dynamic tables should be, so you end up with the Excel maintainability problem of no real separation between code and data.</div><br/></div></div></div></div></div></div><div id="36498743" class="c"><input type="checkbox" id="c-36498743" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498488">parent</a><span>|</span><a href="#36500243">prev</a><span>|</span><a href="#36498593">next</a><span>|</span><label class="collapse" for="c-36498743">[-]</label><label class="expand" for="c-36498743">[7 more]</label></div><br/><div class="children"><div class="content">Following this advice too closely and your application logic starts leaking into your data layer.<p>One simple example is when you need to make atomic changes to two different types of entities. In the data layer, this is usually trivial — just run two queries within a transaction — but you need to expose a function that boils down to `updateBothAandB`. Rinse and repeat enough times and your data layer is a soup of business logic.</div><br/><div id="36499347" class="c"><input type="checkbox" id="c-36499347" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498743">parent</a><span>|</span><a href="#36499311">next</a><span>|</span><label class="collapse" for="c-36499347">[-]</label><label class="expand" for="c-36499347">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, in my opinion, separating your business logic from your data access layer completely is futile. You will need to either have business logic in your data access layer or fine grained query controls (when to add a filter clause, when to execute a query, what should go into a transaction, etc) in your business logic for performance reasons. This is OK, it&#x27;s incidental complexity.</div><br/></div></div><div id="36499311" class="c"><input type="checkbox" id="c-36499311" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498743">parent</a><span>|</span><a href="#36499347">prev</a><span>|</span><a href="#36498593">next</a><span>|</span><label class="collapse" for="c-36499311">[-]</label><label class="expand" for="c-36499311">[5 more]</label></div><br/><div class="children"><div class="content">There are patterns to resolve this. Depending how you structure your DAL, your data access classes can provide transaction handles. It&#x27;s a data access layer, you don&#x27;t need to abstract away the fact that you&#x27;re dealing with a database.</div><br/><div id="36501297" class="c"><input type="checkbox" id="c-36501297" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499311">parent</a><span>|</span><a href="#36500400">next</a><span>|</span><label class="collapse" for="c-36501297">[-]</label><label class="expand" for="c-36501297">[1 more]</label></div><br/><div class="children"><div class="content">I mean, yeah, but the patterns all look like the thing you said you don’t accept in your own applications: “something like a query builder that allows different parts of the application to work together to lazily compose queries”.</div><br/></div></div><div id="36500400" class="c"><input type="checkbox" id="c-36500400" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499311">parent</a><span>|</span><a href="#36501297">prev</a><span>|</span><a href="#36501010">next</a><span>|</span><label class="collapse" for="c-36500400">[-]</label><label class="expand" for="c-36500400">[1 more]</label></div><br/><div class="children"><div class="content">IME young businesses evolve so quickly too much abstraction is a higher risk that some bleeding among DAL and business rules.</div><br/></div></div><div id="36501010" class="c"><input type="checkbox" id="c-36501010" checked=""/><div class="controls bullet"><span class="by">edgyquant</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499311">parent</a><span>|</span><a href="#36500400">prev</a><span>|</span><a href="#36498593">next</a><span>|</span><label class="collapse" for="c-36501010">[-]</label><label class="expand" for="c-36501010">[2 more]</label></div><br/><div class="children"><div class="content">How is this not just a hand rolled ORM?</div><br/><div id="36501446" class="c"><input type="checkbox" id="c-36501446" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501010">parent</a><span>|</span><a href="#36498593">next</a><span>|</span><label class="collapse" for="c-36501446">[-]</label><label class="expand" for="c-36501446">[1 more]</label></div><br/><div class="children"><div class="content">An ORM is a specific kind of data layer. It is general-purpose, and as the name suggests, it is an Object-Relational Mapper whose primary purpose is to map relations to objects and vice-versa.<p>So no, bespoke data access layer code is not an ORM.</div><br/></div></div></div></div></div></div></div></div><div id="36498593" class="c"><input type="checkbox" id="c-36498593" checked=""/><div class="controls bullet"><span class="by">markkanof</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498488">parent</a><span>|</span><a href="#36498743">prev</a><span>|</span><a href="#36498359">next</a><span>|</span><label class="collapse" for="c-36498593">[-]</label><label class="expand" for="c-36498593">[3 more]</label></div><br/><div class="children"><div class="content">Why are a data access layer and an ORM mutually exclusive? An ORM is just an abstraction over your database. You might find use in it as a tool to access your database but contain the use of the ORM to within your data access layer.</div><br/><div id="36499298" class="c"><input type="checkbox" id="c-36499298" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498593">parent</a><span>|</span><a href="#36498359">next</a><span>|</span><label class="collapse" for="c-36499298">[-]</label><label class="expand" for="c-36499298">[2 more]</label></div><br/><div class="children"><div class="content">I never said they are mutually exclusive. I said you don&#x27;t need the ORM.</div><br/><div id="36500534" class="c"><input type="checkbox" id="c-36500534" checked=""/><div class="controls bullet"><span class="by">danem</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499298">parent</a><span>|</span><a href="#36498359">next</a><span>|</span><label class="collapse" for="c-36500534">[-]</label><label class="expand" for="c-36500534">[1 more]</label></div><br/><div class="children"><div class="content">Mind sharing an example of a large(ish) app that doesn&#x27;t make use of an ORM? Last time this topic came up, I went looking for one (admittedly not too hard) and I came up empty handed.</div><br/></div></div></div></div></div></div></div></div><div id="36498359" class="c"><input type="checkbox" id="c-36498359" checked=""/><div class="controls bullet"><span class="by">scarface_74</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36498488">prev</a><span>|</span><a href="#36498649">next</a><span>|</span><label class="collapse" for="c-36498359">[-]</label><label class="expand" for="c-36498359">[27 more]</label></div><br/><div class="children"><div class="content">&gt; In any sufficiently complex application, something like a query builder that allows different parts of the application to work together to lazily compose queries (vs combining&#x2F;filtering&#x2F;sorting the data in memory) will be created at some point.<p>Welcome to LINQ - introduced in 2007 (?).<p>LINQ isn’t exactly an ORM.  You create strongly typed LINQ statements that are turned into expression trees that are then turned into a query by a query provider.</div><br/><div id="36498637" class="c"><input type="checkbox" id="c-36498637" checked=""/><div class="controls bullet"><span class="by">paranoidrobot</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498359">parent</a><span>|</span><a href="#36498440">next</a><span>|</span><label class="collapse" for="c-36498637">[-]</label><label class="expand" for="c-36498637">[6 more]</label></div><br/><div class="children"><div class="content">LINQ was&#x2F;is fantastic.<p>Being able to run queries over data without having to implement the various boilerplate is excellent.<p>Unfortunately basic mistakes can result in so many of those N+1 type queries if you&#x27;re not careful. It can also result in reading entire table(s), possibly inside those nested N+1s.<p>It gets expensive when it&#x27;s a remote DB server and&#x2F;or dealing with a lot of records.<p>Profiling tools are essential.<p>It&#x27;s why I&#x27;m not a fan of LINQ (and Entity Framework) for talking to DB severs without very strict controls.<p>Many times I&#x27;ve been called in to deal with a &quot;slow&quot; server, only to find out the issue is someone chained together a bunch of calls through EF and we have hundreds of thousands of queries that can be replaced by one or two.</div><br/><div id="36499187" class="c"><input type="checkbox" id="c-36499187" checked=""/><div class="controls bullet"><span class="by">scarface_74</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498637">parent</a><span>|</span><a href="#36498440">next</a><span>|</span><label class="collapse" for="c-36499187">[-]</label><label class="expand" for="c-36499187">[5 more]</label></div><br/><div class="children"><div class="content">And that also happens with SQL - which is also an abstraction.</div><br/><div id="36500186" class="c"><input type="checkbox" id="c-36500186" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499187">parent</a><span>|</span><a href="#36498440">next</a><span>|</span><label class="collapse" for="c-36500186">[-]</label><label class="expand" for="c-36500186">[4 more]</label></div><br/><div class="children"><div class="content">SQL is only an abstraction if you consider modifying the physical file to be the purer form of RDBMS manipulation.</div><br/><div id="36500394" class="c"><input type="checkbox" id="c-36500394" checked=""/><div class="controls bullet"><span class="by">scarface_74</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500186">parent</a><span>|</span><a href="#36498440">next</a><span>|</span><label class="collapse" for="c-36500394">[-]</label><label class="expand" for="c-36500394">[3 more]</label></div><br/><div class="children"><div class="content">Would you consider SQL an abstraction over DynamoDB? ElasticSearch’s native query language? Apache Presto to query files? Mongo?<p>All of those can use SQL as a worse query language than their native counterparts.<p>You can also create very bad SQL if you don’t know the underlying engine.  For instance if you try to write SQL for a columnar database like you would for a traditional database, you are in for a world of hurt.</div><br/><div id="36500832" class="c"><input type="checkbox" id="c-36500832" checked=""/><div class="controls bullet"><span class="by">paranoidrobot</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500394">parent</a><span>|</span><a href="#36498440">next</a><span>|</span><label class="collapse" for="c-36500832">[-]</label><label class="expand" for="c-36500832">[2 more]</label></div><br/><div class="children"><div class="content">You seem to be talking about databases who&#x27;s native language is not SQL. In those cases, yes, SQL is definitely an abstraction. There&#x27;s some layer that&#x27;s transforming that into (say) Elastic query or Dynamo queries.<p>I would argue that when talking about writing SQL, most folks are talking about applications who&#x27;s query planner talks some dialect of SQL. MS SQL Server, MariaDB, MySQL, Oracle, SQLite.<p>In those cases, it&#x27;s not really an abstraction any more than writing assembly is an abstraction over (say) Intel&#x27;s CPU microcode is.<p>The query planner takes your SQL and turns it into something else, sure, but you  can&#x27;t generally do that yourself.  It&#x27;s the lowest layer of abstraction that&#x27;s reasonably available.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36498440" class="c"><input type="checkbox" id="c-36498440" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498359">parent</a><span>|</span><a href="#36498637">prev</a><span>|</span><a href="#36498647">next</a><span>|</span><label class="collapse" for="c-36498440">[-]</label><label class="expand" for="c-36498440">[7 more]</label></div><br/><div class="children"><div class="content">Iirc, Linq is exactly a query builder and not an orm.  IMO what truly makes an orm is when object fields have data binding against the database (updating a field triggers an update in the db)<p>It&#x27;s kinda gross because the developer needs to make a decision about what is authoritative source of truth, the programming model makes you feel like you can trust <i>your code</i> (probably the wrong choice), and all the footguns around distributed state kick in (possibly even worse if you have a frontend with two way data binding and data structures that last longer than an http request in your backend)</div><br/><div id="36499184" class="c"><input type="checkbox" id="c-36499184" checked=""/><div class="controls bullet"><span class="by">scarface_74</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498440">parent</a><span>|</span><a href="#36500014">next</a><span>|</span><label class="collapse" for="c-36499184">[-]</label><label class="expand" for="c-36499184">[4 more]</label></div><br/><div class="children"><div class="content">LINQ is a query builder and the .Net runtime creates expression trees.  Entity Framework translates the expression tree to SQL and maps data back to objects.</div><br/><div id="36500032" class="c"><input type="checkbox" id="c-36500032" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499184">parent</a><span>|</span><a href="#36500014">next</a><span>|</span><label class="collapse" for="c-36500032">[-]</label><label class="expand" for="c-36500032">[3 more]</label></div><br/><div class="children"><div class="content">And iirc you can use databases in .net with Linq only and pass on entity framework, if you so chose</div><br/><div id="36500836" class="c"><input type="checkbox" id="c-36500836" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500032">parent</a><span>|</span><a href="#36500402">next</a><span>|</span><label class="collapse" for="c-36500836">[-]</label><label class="expand" for="c-36500836">[1 more]</label></div><br/><div class="children"><div class="content">Linq is really just a high level abstraction for querying  any data that can be queried. EF adds some more abstractions mostly related to mapping C# objects to database tables. Then it adds database specific query providers (implementations) that combine the (abstract) linq query and the mapping to produce sql.<p>You can really use linq to query anything (APIs, for example), including databases without using EF. It&#x27;s just not very common because building a custom query provider is a lot of work.</div><br/></div></div><div id="36500402" class="c"><input type="checkbox" id="c-36500402" checked=""/><div class="controls bullet"><span class="by">scarface_74</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500032">parent</a><span>|</span><a href="#36500836">prev</a><span>|</span><a href="#36500014">next</a><span>|</span><label class="collapse" for="c-36500402">[-]</label><label class="expand" for="c-36500402">[1 more]</label></div><br/><div class="children"><div class="content">Linq2SQL was a thing.  I’m not even sure if it is still supported.</div><br/></div></div></div></div></div></div><div id="36500014" class="c"><input type="checkbox" id="c-36500014" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498440">parent</a><span>|</span><a href="#36499184">prev</a><span>|</span><a href="#36500543">next</a><span>|</span><label class="collapse" for="c-36500014">[-]</label><label class="expand" for="c-36500014">[1 more]</label></div><br/><div class="children"><div class="content">Clarifying: ORMs are gross, query builders are not.</div><br/></div></div><div id="36500543" class="c"><input type="checkbox" id="c-36500543" checked=""/><div class="controls bullet"><span class="by">geraldwhen</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498440">parent</a><span>|</span><a href="#36500014">prev</a><span>|</span><a href="#36498647">next</a><span>|</span><label class="collapse" for="c-36500543">[-]</label><label class="expand" for="c-36500543">[1 more]</label></div><br/><div class="children"><div class="content">TypeORM thinks it’s an ORM but it doesn’t do what you say. It’s pretty good at writing basic migrations from annotations, but that’s about it.</div><br/></div></div></div></div><div id="36498647" class="c"><input type="checkbox" id="c-36498647" checked=""/><div class="controls bullet"><span class="by">5e92cb50239222b</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498359">parent</a><span>|</span><a href="#36498440">prev</a><span>|</span><a href="#36498446">next</a><span>|</span><label class="collapse" for="c-36498647">[-]</label><label class="expand" for="c-36498647">[1 more]</label></div><br/><div class="children"><div class="content">LINQ is just an interface, you need some sort of an implementation below it (be it the unmaintained LINQ-to-SQL that AFAIK nobody should be using anymore, or the latest EF rewrite).<p>It&#x27;s also the first thing I recommend to anyone claiming that concatenating SQL strings together is a good use of your time in the 21st century. Makes writing things like complex HTML tables with configurable columns and tons of optional filters so much faster and more maintainable.</div><br/></div></div><div id="36498446" class="c"><input type="checkbox" id="c-36498446" checked=""/><div class="controls bullet"><span class="by">llm_nerd</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498359">parent</a><span>|</span><a href="#36498647">prev</a><span>|</span><a href="#36498649">next</a><span>|</span><label class="collapse" for="c-36498446">[-]</label><label class="expand" for="c-36498446">[12 more]</label></div><br/><div class="children"><div class="content">In my experience, across a wide variety of applications built wide a number of different teams, LINQ has almost always been an anti-pattern. Whenever you inject a leaky abstraction (as Spolsky would say), things start to go awry. The crimes of grotesque inefficiency I&#x27;ve seen because the magical LINQ is there to shield devs from proper data tiers.</div><br/><div id="36498747" class="c"><input type="checkbox" id="c-36498747" checked=""/><div class="controls bullet"><span class="by">rspeele</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498446">parent</a><span>|</span><a href="#36498667">next</a><span>|</span><label class="collapse" for="c-36498747">[-]</label><label class="expand" for="c-36498747">[7 more]</label></div><br/><div class="children"><div class="content">Absolutely, there are times where programmers try to do way too much in LINQ and don&#x27;t realize that the query being generated to back up their chain of LINQ operations is a monstrosity of thousands of lines of SQL that will grind the server to a hault. Or the abstraction leaks badly due to the programmer using something EF doesn&#x27;t know how to translate to SQL, so it ends up loading a much larger dataset and trying to complete the rest of the filtering in memory.<p>As developers get more acclimated to the .NET ecosystem they usually pick up a good spidey sense for what query &quot;shapes&quot; are appropriate to express in LINQ and which are asking for trouble.<p>However, for every one of those awful LINQ queries in a codebase, I think there are 40 to 50 run-of-the-mill queries that make it worthwhile. The biggest win that it delivers over a simpler, &quot;stringier&quot; ORM is the ability to return structured data. I have no problem writing SQL, but processing the results back out of flat rows into objects gets extremely annoying.<p>Say I want to load some Foos <i>with</i> their Bars. If I use straight SQL with a row mapper, I define a type to represent each FooBar row, load a List&lt;FooBarRow&gt; into memory from my simple left join, then I&#x27;ll have to do a GroupBy in memory on that List to get the actual structure that I want: a list of Foos where each one has its own list of Bars. Notice that I also have to handle the empty-list case specially.<p><pre><code>  var fooBarRows = await connection.QueryAsync&lt;FooBarRow&gt;(&quot;select f.FooId, f.Name as FooName, b.BarId, b.Name as BarName from Foos f left join Bars b on b.FooId = f.FooId where whatever&quot;);
  &#x2F;&#x2F; re-shape result set manually from flat query results
  var foos = fooBarRows
      .GroupBy(fbr =&gt; fbr.FooId)
      .Select(g =&gt; new Foo
         {
            FooId = g.Key,
            FooName = g.First().Name,
            Bars = g.First().BarId == null ? new List&lt;Bar&gt;() : g.Select(b =&gt; new Bar { BarId = b.BarId.Value, BarName = b.BarName }).ToList()
         });
</code></pre>
In EF it&#x27;s just:<p><pre><code>  var foos = await db.Foos.Where(whatever).Include(f =&gt; f.Bars).ToListAsync();
</code></pre>
Saving that clutter -- both the code and the otherwise useless intermediate FooBarRow type -- really adds up because the apps I write have a zillion queries very much like this.
So I&#x27;ll take the occasional shitty query that has to be tracked down and optimized in exchange.</div><br/><div id="36501051" class="c"><input type="checkbox" id="c-36501051" checked=""/><div class="controls bullet"><span class="by">Atotalnoob</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498747">parent</a><span>|</span><a href="#36500188">next</a><span>|</span><label class="collapse" for="c-36501051">[-]</label><label class="expand" for="c-36501051">[2 more]</label></div><br/><div class="children"><div class="content">You made a strong argument, up until you forced client side execution of the query by calling `ToListAsync()`<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;querying&#x2F;client-eval?source=recommendations#explicit-client-evaluation" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;querying&#x2F;client-ev...</a></div><br/><div id="36501327" class="c"><input type="checkbox" id="c-36501327" checked=""/><div class="controls bullet"><span class="by">rspeele</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501051">parent</a><span>|</span><a href="#36500188">next</a><span>|</span><label class="collapse" for="c-36501327">[-]</label><label class="expand" for="c-36501327">[1 more]</label></div><br/><div class="children"><div class="content">When they say it forces client evaluation, what they mean is that any LINQ operations you run <i>after</i> the ToListAsync() will run on the client side - since it&#x27;s just a normal list in memory at that point and no longer has any knowledge of the database. So if you want to <i>make sure</i> some code will execute client-side, you should ToList or AsEnumerable your query first, then do your additional client-side operations on that list.<p>The IQueryable operations composed <i>before</i> to the ToListAsync() will run as SQL on the server. In the case of my example it will look pretty similar in structure to the string SQL I wrote before it: a straightforward left join with a where clause. Performance will be similar too. It will <i>not</i> load the entire universe of Foos and Bars and then filter them down on the client.<p>One of the habits I have developed from working with EF for the past 10 years is to be <i>explicit</i> and as <i>local</i> as possible about forcing the query to evaluate. It lets me pretty reliably predict what the SQL is going to look like.<p>You <i>can</i> return IQueryables from methods and pass them around through many layers of your program, adding complexity to them as you go, and lazily getting the results at the last possible moment, five layers up the call stack from where the query first started.<p>It seems at first like that would be good, because that way the maximum amount of logic will run on the DB server, and letting the server do stuff is better, right? But that&#x27;s also where you open yourself up to being very surprised about what your SQL looks like by the time it executes, with multiple layers of your program each tacking complexity onto the query. It can get ugly. Also you can have problems if you&#x27;re hanging onto IQueryables that you still haven&#x27;t executed after you&#x27;ve Dispose()d your DbContext. For this reason I try not to let IQueryables travel very far through my program before forcing evaluation.</div><br/></div></div></div></div><div id="36500188" class="c"><input type="checkbox" id="c-36500188" checked=""/><div class="controls bullet"><span class="by">rjbwork</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498747">parent</a><span>|</span><a href="#36501051">prev</a><span>|</span><a href="#36498807">next</a><span>|</span><label class="collapse" for="c-36500188">[-]</label><label class="expand" for="c-36500188">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I have no problem writing SQL, but processing the results back out of flat rows into objects gets extremely annoying.<p>I&#x27;m pretty sure Dapper lets you do this fairly easily.  You&#x27;ve got a couple options - you can either provide a mapping function, or you can have your query&#x2F;sprocs return multiple result sets.  Then you can assemble the result sets into the object structure.<p>It&#x27;s not quite as magical as LINQ, but it&#x27;s also not quite as annoying and fraught with so much marshalling code as your example.</div><br/><div id="36501478" class="c"><input type="checkbox" id="c-36501478" checked=""/><div class="controls bullet"><span class="by">marklubi</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500188">parent</a><span>|</span><a href="#36498807">next</a><span>|</span><label class="collapse" for="c-36501478">[-]</label><label class="expand" for="c-36501478">[1 more]</label></div><br/><div class="children"><div class="content">Was waiting for Dapper to get brought up.  Fantastic micro ORM.</div><br/></div></div></div></div><div id="36498807" class="c"><input type="checkbox" id="c-36498807" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498747">parent</a><span>|</span><a href="#36500188">prev</a><span>|</span><a href="#36498667">next</a><span>|</span><label class="collapse" for="c-36498807">[-]</label><label class="expand" for="c-36498807">[2 more]</label></div><br/><div class="children"><div class="content">Really really well said.<p>It is weird that people jump into strange extremas when you can just combine best of both worlds.</div><br/><div id="36500498" class="c"><input type="checkbox" id="c-36500498" checked=""/><div class="controls bullet"><span class="by">fendy3002</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498807">parent</a><span>|</span><a href="#36498667">next</a><span>|</span><label class="collapse" for="c-36500498">[-]</label><label class="expand" for="c-36500498">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sad that in programming world, something is either anti-pattern and you must not use it at all, or something is so awesome that you need to use it everywhere.</div><br/></div></div></div></div></div></div><div id="36498667" class="c"><input type="checkbox" id="c-36498667" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498446">parent</a><span>|</span><a href="#36498747">prev</a><span>|</span><a href="#36498649">next</a><span>|</span><label class="collapse" for="c-36498667">[-]</label><label class="expand" for="c-36498667">[4 more]</label></div><br/><div class="children"><div class="content">&gt;LINQ has almost always been an anti-pattern<p>You mean &quot;LINQ&quot; as an input for ORM? or LINQ in general?<p>either way this is crazy claim.<p>There&#x27;s shitton of projects where queries aren&#x27;t complex and LINQ will make your life saner instead of this stringly typed hell called SQL.<p>Just check what ORM is generating for your queries and if it is a mess then write it manually and you&#x27;re good to go.<p>This way you get both benefits: sane type system and performance.</div><br/><div id="36499354" class="c"><input type="checkbox" id="c-36499354" checked=""/><div class="controls bullet"><span class="by">llm_nerd</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498667">parent</a><span>|</span><a href="#36498649">next</a><span>|</span><label class="collapse" for="c-36499354">[-]</label><label class="expand" for="c-36499354">[3 more]</label></div><br/><div class="children"><div class="content">LINQ in general is a very bad indicator if it isn&#x27;t very restricted. I don&#x27;t think it&#x27;s a crazy claim whatsoever: When LINQ appears littered through code, it usually mean there has been perilously little data access planning, so instead of planning out and centralizing concise, planned, secure, optimized data access avenues, just pretend that LINQ being available everywhere is a solution. Every LINQ-heavy solution I&#x27;ve had the misfortune of using has always, with zero exceptions, been a performance nightmare. And instead of one big function you can just optimize, it is death by a trillion cuts.<p>I get that there are big LINQ advocates. It&#x27;s convenient. I&#x27;m sure there are projects where it is use spectacularly. I&#x27;ve never seen such a project.</div><br/><div id="36500199" class="c"><input type="checkbox" id="c-36500199" checked=""/><div class="controls bullet"><span class="by">rjbwork</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36499354">parent</a><span>|</span><a href="#36498649">next</a><span>|</span><label class="collapse" for="c-36500199">[-]</label><label class="expand" for="c-36500199">[2 more]</label></div><br/><div class="children"><div class="content">LINQ is just functional list comprehensions.<p>Do you think that LINQ is only used for EF&#x2F;LINQ2SQL?</div><br/><div id="36501706" class="c"><input type="checkbox" id="c-36501706" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500199">parent</a><span>|</span><a href="#36498649">next</a><span>|</span><label class="collapse" for="c-36501706">[-]</label><label class="expand" for="c-36501706">[1 more]</label></div><br/><div class="children"><div class="content">First time I’ve heard that claim was when I had to start working with Go. I was telling someone how much I miss LINQ&#x2F;functional programming, and he said exactly the same thing “ugh, LINQ is why .NET is so slow”. I was perplexed. Do you even know what LINQ is? How does it make .NET slow? And to the best of knowledge they were comparing JIT startup time to Go’s AOT time. Smh</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36498649" class="c"><input type="checkbox" id="c-36498649" checked=""/><div class="controls bullet"><span class="by">neovive</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36498359">prev</a><span>|</span><a href="#36500279">next</a><span>|</span><label class="collapse" for="c-36498649">[-]</label><label class="expand" for="c-36498649">[2 more]</label></div><br/><div class="children"><div class="content">Good points! As someone who uses both ORM and raw SQL (I actually really like SQL as language) I sympathize with both sides of this debate. I prefer the readability of ORM in my models when developing, but closely monitor and optimize for N+1 and other inefficiencies, when needed. &quot;When needed&quot; is never cut-and-dry, but I try not to optimize too early. I actually tend to start new projects from the database and will scaffold with factories, seeders, and raw SQL queries to get a sense of the data model prior to coding.<p>ORM&#x27;s such as Eloquent in Laravel also have some nice methods to resolve N+1 and perform lazy loading, but it&#x27;s always tradeoff.</div><br/><div id="36502811" class="c"><input type="checkbox" id="c-36502811" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498649">parent</a><span>|</span><a href="#36500279">next</a><span>|</span><label class="collapse" for="c-36502811">[-]</label><label class="expand" for="c-36502811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As someone who uses both ORM and raw SQL<p>There is no other way — people who don’t know one should not touch the other. Otherwise they are either juniors, or crazies who just like to complain that “the plane is a bad vehicle because I can’t just sit inside and land it properly without years of training”.</div><br/></div></div></div></div><div id="36500279" class="c"><input type="checkbox" id="c-36500279" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36498649">prev</a><span>|</span><a href="#36498986">next</a><span>|</span><label class="collapse" for="c-36500279">[-]</label><label class="expand" for="c-36500279">[1 more]</label></div><br/><div class="children"><div class="content">We had a query builder in our app and ended up stripping it out in favour of raw SQL and string interpolation (for dyanmic queries, not for passing in data). We found the raw sql was much more readable.<p>We still used the library for inserts and updates.</div><br/></div></div><div id="36498986" class="c"><input type="checkbox" id="c-36498986" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36500279">prev</a><span>|</span><a href="#36498546">next</a><span>|</span><label class="collapse" for="c-36498986">[-]</label><label class="expand" for="c-36498986">[2 more]</label></div><br/><div class="children"><div class="content">There are libraries that flip the concept of an ORM on its head. Instead of a library that allows lazy query composition, you write your queries and the library generates the code for that query at compile time. It’s a much better model in my opinion.<p>E.g. you could write a query like this:<p><pre><code>    getUser:
    SELECT * FROM users WHERE id = ?
</code></pre>
And the library would generate a class like:<p><pre><code>    class GetUserQuery {
        static getUser(id: String): GetUserQueryResult
    }</code></pre></div><br/><div id="36501850" class="c"><input type="checkbox" id="c-36501850" checked=""/><div class="controls bullet"><span class="by">w7</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498986">parent</a><span>|</span><a href="#36498546">next</a><span>|</span><label class="collapse" for="c-36501850">[-]</label><label class="expand" for="c-36501850">[1 more]</label></div><br/><div class="children"><div class="content">Some examples for anyone else reading:<p>Go: <a href="https:&#x2F;&#x2F;github.com&#x2F;kyleconroy&#x2F;sqlc">https:&#x2F;&#x2F;github.com&#x2F;kyleconroy&#x2F;sqlc</a><p>Rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;cornucopia-rs&#x2F;cornucopia">https:&#x2F;&#x2F;github.com&#x2F;cornucopia-rs&#x2F;cornucopia</a><p>This is my preferred method of interacting with databases now, if available.<p>Very flexible.</div><br/></div></div></div></div><div id="36498546" class="c"><input type="checkbox" id="c-36498546" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36498986">prev</a><span>|</span><a href="#36502830">next</a><span>|</span><label class="collapse" for="c-36498546">[-]</label><label class="expand" for="c-36498546">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In any sufficiently complex application, something like a query builder that allows different parts of the application to work together to lazily compose queries (vs combining&#x2F;filtering&#x2F;sorting the data in memory) will be created at some point.<p>Right, but is an ORM a good way to achieve this? I would posit no. The problem, correct me if I’m wrong, is one of an in memory representation of working data and a data access layer (how to get&#x2F;update the data). An ORM provides a framework for both of these, but in my opinion it’s very inefficient to build, maintain, and optimise. You don’t need to turn to raw SQL as the alternative data access layer, but having one that is easier to customise is better in my opinion.<p>Not at all an expert, probably nonsense, please correct me.</div><br/><div id="36502029" class="c"><input type="checkbox" id="c-36502029" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36498546">parent</a><span>|</span><a href="#36502830">next</a><span>|</span><label class="collapse" for="c-36502029">[-]</label><label class="expand" for="c-36502029">[1 more]</label></div><br/><div class="children"><div class="content">It depends on what exactly the ORM offers as a feature set. ActiveRecord scopes in Ruby for example do exactly that.</div><br/></div></div></div></div><div id="36502830" class="c"><input type="checkbox" id="c-36502830" checked=""/><div class="controls bullet"><span class="by">Zetice</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36498546">prev</a><span>|</span><a href="#36501761">next</a><span>|</span><label class="collapse" for="c-36502830">[-]</label><label class="expand" for="c-36502830">[1 more]</label></div><br/><div class="children"><div class="content">The N+1 problem feels a bit like y2k in my experience; would definitely be a problem if smart folks didn’t come up with clever solutions, but since they did it’s not nearly the issue it’s made out to be for the average implementer.</div><br/></div></div><div id="36501761" class="c"><input type="checkbox" id="c-36501761" checked=""/><div class="controls bullet"><span class="by">bluesnowmonkey</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36502830">prev</a><span>|</span><a href="#36502131">next</a><span>|</span><label class="collapse" for="c-36501761">[-]</label><label class="expand" for="c-36501761">[3 more]</label></div><br/><div class="children"><div class="content">In a sufficiently complex application, the database lives in another service that exposes a fixed set of queries through an API and certainly does <i>not</i> let you compose arbitrary queries.</div><br/><div id="36502181" class="c"><input type="checkbox" id="c-36502181" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501761">parent</a><span>|</span><a href="#36502131">next</a><span>|</span><label class="collapse" for="c-36502181">[-]</label><label class="expand" for="c-36502181">[2 more]</label></div><br/><div class="children"><div class="content">How do you do anything with that? Like do you just accept that if some part of your app needs the data from query1 and query2 you make two trips to the database?</div><br/><div id="36503547" class="c"><input type="checkbox" id="c-36503547" checked=""/><div class="controls bullet"><span class="by">duckmysick</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502181">parent</a><span>|</span><a href="#36502131">next</a><span>|</span><label class="collapse" for="c-36503547">[-]</label><label class="expand" for="c-36503547">[1 more]</label></div><br/><div class="children"><div class="content">You file a ticket with the database team so they can add your fixed query to the service API. After a few rounds of exchanging messages and meetings it might be added.<p>If it&#x27;s a third-party API (say, a weather forecast or market data) the answers will range from &quot;no&quot; to &quot;yes, and it will cost you X&quot;.</div><br/></div></div></div></div></div></div><div id="36502131" class="c"><input type="checkbox" id="c-36502131" checked=""/><div class="controls bullet"><span class="by">catdog</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36501761">prev</a><span>|</span><a href="#36500102">next</a><span>|</span><label class="collapse" for="c-36502131">[-]</label><label class="expand" for="c-36502131">[2 more]</label></div><br/><div class="children"><div class="content">Why use an ORM if all you need is a query builder? They exist as of the shelve solution, some are even crazy good.</div><br/><div id="36503821" class="c"><input type="checkbox" id="c-36503821" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36502131">parent</a><span>|</span><a href="#36500102">next</a><span>|</span><label class="collapse" for="c-36503821">[-]</label><label class="expand" for="c-36503821">[1 more]</label></div><br/><div class="children"><div class="content">the line between an ORM and a query builder is a very blurry one<p>your query builder isn&#x27;t just string based to avoid a lot of potential bugs which are easy to introduce and miss in tests? It also has a simple way to (de)serialize row from&#x2F;to POD structs? Now you already have a thin ORM.</div><br/></div></div></div></div><div id="36501599" class="c"><input type="checkbox" id="c-36501599" checked=""/><div class="controls bullet"><span class="by">sacnoradhq</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36500102">prev</a><span>|</span><a href="#36500213">next</a><span>|</span><label class="collapse" for="c-36501599">[-]</label><label class="expand" for="c-36501599">[1 more]</label></div><br/><div class="children"><div class="content">Getting inner joins and denormalized data correct are a PITA that should be delegated to a semantic API that already is flexible and proven.</div><br/></div></div><div id="36500213" class="c"><input type="checkbox" id="c-36500213" checked=""/><div class="controls bullet"><span class="by">kgwxd</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36501599">prev</a><span>|</span><a href="#36501567">next</a><span>|</span><label class="collapse" for="c-36500213">[-]</label><label class="expand" for="c-36500213">[2 more]</label></div><br/><div class="children"><div class="content">IME, the accidental inefficiencies aren&#x27;t a huge problem. What I hate about some ORMs is that they want to be considered the foundation of a system or, worse, multiple systems, rather than just a tool for implementing pesky infrastructure details. LINQ-to-SQL and Entity Framework feel like they want to be at the center of everything, though they don&#x27;t have to be use that way. Something like Dapper, on the other hand, seems like it just wants to get your app the data it requires, through classes the application defines, and then get out of your way.<p>In short, I don&#x27;t think ORMs should generate class libraries to be referenced by applications, they should help you get exactly what you need, when you need it, nothing more, nothing less, and no one expect the person that maintains that code should ever need to care how the data got there. If a column gets added to a table that has nothing to do with a specific application, that application shouldn&#x27;t need to be updated.</div><br/><div id="36500257" class="c"><input type="checkbox" id="c-36500257" checked=""/><div class="controls bullet"><span class="by">swader999</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36500213">parent</a><span>|</span><a href="#36501567">next</a><span>|</span><label class="collapse" for="c-36500257">[-]</label><label class="expand" for="c-36500257">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen them help with things like dirty checking, that&#x27;s a lot of work to take on properly. But in the end I think relying on them for significant load and scale is naive.</div><br/></div></div></div></div><div id="36501567" class="c"><input type="checkbox" id="c-36501567" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36500213">prev</a><span>|</span><a href="#36500860">next</a><span>|</span><label class="collapse" for="c-36501567">[-]</label><label class="expand" for="c-36501567">[2 more]</label></div><br/><div class="children"><div class="content">That has not been my experience. Then again, I’ve written tens of thousands of sql queries over the decades, so sql is as easy as breathing for me. No need for any sort of query builder.</div><br/><div id="36503237" class="c"><input type="checkbox" id="c-36503237" checked=""/><div class="controls bullet"><span class="by">fodkodrasz</span><span>|</span><a href="#36498275">root</a><span>|</span><a href="#36501567">parent</a><span>|</span><a href="#36500860">next</a><span>|</span><label class="collapse" for="c-36503237">[-]</label><label class="expand" for="c-36503237">[1 more]</label></div><br/><div class="children"><div class="content">Query builders are generally not intended for developers to build &quot;static&quot; queries, but to build dynamic queries programmatically while being safe (eg. from SQL injection) based on dynamic data, often with user inputs, the likes from ASTs from parsed user input in query fields.</div><br/></div></div></div></div><div id="36500860" class="c"><input type="checkbox" id="c-36500860" checked=""/><div class="controls bullet"><span class="by">HumblyTossed</span><span>|</span><a href="#36498275">parent</a><span>|</span><a href="#36501567">prev</a><span>|</span><a href="#36498525">next</a><span>|</span><label class="collapse" for="c-36500860">[-]</label><label class="expand" for="c-36500860">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In any sufficiently complex application, something like a query builder that allows different parts of the application to work together to lazily compose queries (vs combining&#x2F;filtering&#x2F;sorting the data in memory) will be created at some point.<p>Then your devs have way too much time on their hands. Find them some actual problems to solve.</div><br/></div></div></div></div><div id="36498525" class="c"><input type="checkbox" id="c-36498525" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#36498275">prev</a><span>|</span><a href="#36503993">next</a><span>|</span><label class="collapse" for="c-36498525">[-]</label><label class="expand" for="c-36498525">[25 more]</label></div><br/><div class="children"><div class="content">My dislike of ORMs mainly stems from the tendency to treat modern SQL engines as glorified dumb bit buckets.<p>Where a CTE or LATERAL join or RETURNING clause would simplify processing immensely or (better yet) remove the possibility of inconsistent data making its way into the data set, ORMs are largely limited to simplistic mappings between basic tables and views to predefined object definitions. Even worse when the ORM is creating the tables.<p>SQL is at its heart a transformation language as well as a data extraction tool. ORMs largely ignore these facets to the point where most developers don&#x27;t even realize anything exists in SQL beyond the basic INSERT&#x2F;SELECT&#x2F;UPDATE&#x2F;DELETE.<p>Pivot tables. Temporal queries. CUBE&#x2F;ROLLUP. Window functions. Set-returning functions. Materialized views. Foreign tables. JSON processing. Date processing. Exclusion constraints. Types like ranges, intervals, domains. Row-level security. MERGE.<p>It&#x27;s like owning a full working tool shed but hiring someone to hand you just the one hammer, screwdriver, and hacksaw and convincing you it&#x27;s enough. Folks go their whole careers without knowing they had a full size table saw, router, sander, and array of wedges just a few meters away.</div><br/><div id="36503889" class="c"><input type="checkbox" id="c-36503889" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#36498525">parent</a><span>|</span><a href="#36499242">next</a><span>|</span><label class="collapse" for="c-36503889">[-]</label><label class="expand" for="c-36503889">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m lucky enough to work on projects usually lacking any kind of database anywhere. But when I do, I also tend to make sure to use a tiny subset of DB features. Simply because I consider &quot;code&quot; to be the part of the world I have any control over and &quot;database&quot; to be the dangerous and out-of-reach part where errors show up later (Such as in slower&#x2F;larger integration tests). Any logic that is happening in a DB happens outside of low level testing reach too and that scares me. I&#x27;ll probably never even use a select-from-select query... I&#x27;ll happily leave most of the tools in the shed.</div><br/></div></div><div id="36499242" class="c"><input type="checkbox" id="c-36499242" checked=""/><div class="controls bullet"><span class="by">freetime2</span><span>|</span><a href="#36498525">parent</a><span>|</span><a href="#36503889">prev</a><span>|</span><a href="#36502820">next</a><span>|</span><label class="collapse" for="c-36499242">[-]</label><label class="expand" for="c-36499242">[3 more]</label></div><br/><div class="children"><div class="content">Most ORM frameworks have the ability to execute raw SQL, so using an ORM does not preclude you from using these features. ORMs tend to put you in the mindset of using simple CRUD statements most of the time - but I think that’s probably for the best, and these more advanced features should be used sparingly.</div><br/><div id="36499801" class="c"><input type="checkbox" id="c-36499801" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36499242">parent</a><span>|</span><a href="#36502820">next</a><span>|</span><label class="collapse" for="c-36499801">[-]</label><label class="expand" for="c-36499801">[2 more]</label></div><br/><div class="children"><div class="content">Not only does each ORM have a different API and access pattern to do this, once you hit this point, you&#x27;re managing the object model ALONG WITH custom SQL for migrations.<p>There is also non-trivial danger in letting your ORM decide what data types your database schema should use. Got UUIDs? The ORM will store them as strings. Need start and stop timestamps? A range type with an exclusion constraint may be the right tool.<p>What you appear to consider &quot;advanced features&quot; are what some others of us consider &quot;perfectly normal.&quot; Let&#x27;s be honest: most devs consider knowing the difference between a LEFT JOIN and an INNER JOIN to be an advanced topic.<p>Devs will wax poetic about the marginal benefits of monads in limited scenarios, but throw up their hands in defeat when you mention a window function for a dashboard. They&#x27;d rather calculate it in the app layer with all the added latency that implies.</div><br/><div id="36501481" class="c"><input type="checkbox" id="c-36501481" checked=""/><div class="controls bullet"><span class="by">freetime2</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36499801">parent</a><span>|</span><a href="#36502820">next</a><span>|</span><label class="collapse" for="c-36501481">[-]</label><label class="expand" for="c-36501481">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not only does each ORM have a different API and access pattern to do this<p>I think it is to be expected that different ORM frameworks would have differing APIs and access patterns. Similar to how different RDBMS&#x27;s often have differences in the syntaxes and features that they support. It&#x27;s not a big deal to look up the correct syntax in my opinion.<p>&gt; you&#x27;re managing the object model<p>Which means in the worst case that for some portion of your app you&#x27;re basically back to where you were if you weren&#x27;t using an ORM. Although I&#x27;ve found that JPA, for example, plays pretty nicely with native SQL queries (caching gets more difficult, but I think that&#x27;s to be expected when moving logic out of the app and into the database regardless of whether you are using an ORM or not).<p>&gt; ALONG WITH custom SQL for migrations<p>Personally I&#x27;ve always used custom SQL for all migrations. While ORMs often come with a tool to automatically generate a schema, I&#x27;ve never worked on a project that actually used this tool in production.<p>&gt; There is also non-trivial danger in letting your ORM decide what data types your database schema should use. Got UUIDs? The ORM will store them as strings.<p>Some data types can be a bit tricky, but any competent ORM should at the very least have hooks to override the type on a field or implement your own custom handlers. [1]<p>&gt; What you appear to consider &quot;advanced features&quot; are what some others of us consider &quot;perfectly normal.&quot; Let&#x27;s be honest: most devs consider knowing the difference between a LEFT JOIN and an INNER JOIN to be an advanced topic.<p>I said &quot;more advanced features&quot; - as in more advanced than basic SELECT&#x2F;INSERT&#x2F;UPDATE statements. I don&#x27;t think any feature that you mentioned is particularly challenging to understand. And literally every entry-level developer I&#x27;ve ever hired has easily been able to explain the difference between LEFT and INNER joins in an interview.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;12824827" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;12824827</a></div><br/></div></div></div></div></div></div><div id="36502820" class="c"><input type="checkbox" id="c-36502820" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36498525">parent</a><span>|</span><a href="#36499242">prev</a><span>|</span><a href="#36498674">next</a><span>|</span><label class="collapse" for="c-36502820">[-]</label><label class="expand" for="c-36502820">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, no wonder many devs don&#x27;t see difference between sql and nosql.</div><br/></div></div><div id="36498674" class="c"><input type="checkbox" id="c-36498674" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36498525">parent</a><span>|</span><a href="#36502820">prev</a><span>|</span><a href="#36500331">next</a><span>|</span><label class="collapse" for="c-36498674">[-]</label><label class="expand" for="c-36498674">[4 more]</label></div><br/><div class="children"><div class="content">To be fair, a lot of those tools have that one weird caveat you need to know, and are also strongly dependent on your dialect.<p>For example there&#x27;s an aggregate function in DB&#x2F;2, LISTAGG, that joins strings... the caveat being that if they get too long, the query blows up.  It&#x27;s in OracleSQL too, which has a syntax where you can tell it to truncate the string.<p>SELECT, INSERT, UPDATE, DELETE work more or less the same whether you&#x27;re on MariaDB, Postgres, DB&#x2F;2, OracleSQL, etc.</div><br/><div id="36498893" class="c"><input type="checkbox" id="c-36498893" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36498674">parent</a><span>|</span><a href="#36500331">next</a><span>|</span><label class="collapse" for="c-36498893">[-]</label><label class="expand" for="c-36498893">[3 more]</label></div><br/><div class="children"><div class="content">As opposed to the dizzying array of ORMs that all have multiple caveats you need to know and utterly incompatible in fundamental ways between each other?<p>Folks go on about how they&#x27;re &quot;stuck&quot; with a single dialect of SQL but completely ignore how utterly impossible it is to switch ORMs without a full app rewrite. And ORMs are all language-specific, so if you have two different app clients in different languages, you can&#x27;t always share even basic API access patterns.<p>Got a Java Spring app alongside a Django app? Good luck!</div><br/><div id="36501699" class="c"><input type="checkbox" id="c-36501699" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36498893">parent</a><span>|</span><a href="#36499019">next</a><span>|</span><label class="collapse" for="c-36501699">[-]</label><label class="expand" for="c-36501699">[1 more]</label></div><br/><div class="children"><div class="content">IoC (not just interfaces, not just DI) should avoid this.<p>Inject me an object that gets people objects that meet an interface (ok might need to be async) and you can switch out how that is done later.<p>But it is more boilerplate</div><br/></div></div><div id="36499019" class="c"><input type="checkbox" id="c-36499019" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36498893">parent</a><span>|</span><a href="#36501699">prev</a><span>|</span><a href="#36500331">next</a><span>|</span><label class="collapse" for="c-36499019">[-]</label><label class="expand" for="c-36499019">[1 more]</label></div><br/><div class="children"><div class="content">Well yeah, I do think there is a fundamental difference given the DBMS is effectively hidden in this scenario, whereas the ORM is not.</div><br/></div></div></div></div></div></div><div id="36500331" class="c"><input type="checkbox" id="c-36500331" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498525">parent</a><span>|</span><a href="#36498674">prev</a><span>|</span><a href="#36500525">next</a><span>|</span><label class="collapse" for="c-36500331">[-]</label><label class="expand" for="c-36500331">[12 more]</label></div><br/><div class="children"><div class="content">SQL may be a language for all those things, but unfortunately it&#x27;s horribly bad at it. Wilfully obtuse syntax. Incredibly poor compositionality. No testability worth the name. The deployment model is a half-baked pile of perl scripts, and that&#x27;s if you&#x27;re lucky.<p>So yeah, I use SQL like <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;783&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;783&#x2F;</a> . I&#x27;m sure you have a bunch of cool data analysis tools in there, but please just shut up, give me the contents of my table, and let me process it in a real programming language where I have map&#x2F;reduce&#x2F;filter as regular composable functions that I can test and reuse, with a syntax that doesn&#x27;t make my eyes bleed.</div><br/><div id="36500729" class="c"><input type="checkbox" id="c-36500729" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500331">parent</a><span>|</span><a href="#36500782">next</a><span>|</span><label class="collapse" for="c-36500729">[-]</label><label class="expand" for="c-36500729">[6 more]</label></div><br/><div class="children"><div class="content">map&#x2F;filter&#x2F;reduce?<p>Give you the contents of your table, so you can process it in the app tier with map&#x2F;filter&#x2F;reduce?!<p>Ah, the hubris of devs who honestly believe they can whip out a solution in a day that beats a dedicated army of developers singularly focused on the task of large data management, storage, and serialization. And almost always forgetting that serialization off of disk and over a network isn&#x27;t free.<p>There&#x27;s a reason why SQL is going on 50 years when most technologies are lucky to remain dominant past 10 in this industry. And if you think it&#x27;s just because of inertia or lack of imagination, you&#x27;re deluded. SQL isn&#x27;t perfect (nothing is), but as a DSL for set theory, it does a damn good job, even 50 years later. Far better than any map&#x2F;filter&#x2F;reduce whipped up yet again by someone who doesn&#x27;t fully understand the scope of the problems being solved.<p>It&#x27;s doubly troubling when you can&#x27;t grok that SELECT = map, WHERE = filter, and GROUP BY + aggregator = reduce. I sincerely hope you aren&#x27;t avoiding JOIN by loading both tables ahead of time.</div><br/><div id="36501480" class="c"><input type="checkbox" id="c-36501480" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500729">parent</a><span>|</span><a href="#36500958">next</a><span>|</span><label class="collapse" for="c-36501480">[-]</label><label class="expand" for="c-36501480">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Ah, the hubris of devs who honestly believe they can whip out a solution in a day that beats a dedicated army of developers singularly focused on the task of large data management, storage, and serialization.<p>A &quot;dedicated army of developers&quot; who&#x27;ve been &quot;going on 50 years&quot; but whose flagship solutions are still single-point-of-failure, still noncompositional, still untestable, still have bizarre and incomprehensible performance characteristics. Yeah, no, I&#x27;m going to do stuff in regular application code, thanks.</div><br/><div id="36503349" class="c"><input type="checkbox" id="c-36503349" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36501480">parent</a><span>|</span><a href="#36502229">next</a><span>|</span><label class="collapse" for="c-36503349">[-]</label><label class="expand" for="c-36503349">[1 more]</label></div><br/><div class="children"><div class="content">I am not particularly opinionated on the matter and i think i can appreciate both sides of the argument.<p>SQL is somewhat analogous to C. It is entirely legitimate to look at its archaic usability features and wonder if we could not do better and at the same time it has hit a sweet spot of adaptation to the domain that ensured its longevity.<p>Something that might shake up things a bit is graph databases &#x2F; query languages. We can think of them as a generalization of the sql universe and an opportunity to modernize it</div><br/></div></div><div id="36502229" class="c"><input type="checkbox" id="c-36502229" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36501480">parent</a><span>|</span><a href="#36503349">prev</a><span>|</span><a href="#36500958">next</a><span>|</span><label class="collapse" for="c-36502229">[-]</label><label class="expand" for="c-36502229">[2 more]</label></div><br/><div class="children"><div class="content">You pay a huge cost in moving those bits over the network though. How do you even deal with tables that don&#x27;t fit in memory or the lack of indexes for tables where sequential scanning is too slow?</div><br/><div id="36502314" class="c"><input type="checkbox" id="c-36502314" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36502229">parent</a><span>|</span><a href="#36500958">next</a><span>|</span><label class="collapse" for="c-36502314">[-]</label><label class="expand" for="c-36502314">[1 more]</label></div><br/><div class="children"><div class="content">I mean at that point you&#x27;re getting into real big data stuff. Move the code to the data rather than moving the data to the code; have some way to stream in the data in its native format rather than having to read it in; do pre-aggregation and indexing as the data is written (but not in a way that&#x27;s blocking your OLTP). Which, yes, is stuff that SQL RDBMSes do for you up to a point, but they do it in invisible and unmanageable ways; IME you&#x27;re better off doing it explicitly and visibly.<p>In seriousness SQL databases can be good for ad-hoc exploratory queries, so having your data processing pipeline spit out a read-only SQL database dump on a regular schedule is worthwhile, but using that for anything more than prototyping is a mistake.</div><br/></div></div></div></div></div></div><div id="36500958" class="c"><input type="checkbox" id="c-36500958" checked=""/><div class="controls bullet"><span class="by">roflyear</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500729">parent</a><span>|</span><a href="#36501480">prev</a><span>|</span><a href="#36500782">next</a><span>|</span><label class="collapse" for="c-36500958">[-]</label><label class="expand" for="c-36500958">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, if your devs are loading entire tables into code and using filter on them ... I haven&#x27;t personally seen that, but oh god.<p>Not that it isn&#x27;t valid in some cases. It is. If for example, you&#x27;re using all of the table in your logic and need to filter on to do something like pull out certain items for a certain need. Sure. Then it is good, absolutely!</div><br/></div></div></div></div><div id="36500782" class="c"><input type="checkbox" id="c-36500782" checked=""/><div class="controls bullet"><span class="by">mcdonje</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500331">parent</a><span>|</span><a href="#36500729">prev</a><span>|</span><a href="#36502650">next</a><span>|</span><label class="collapse" for="c-36500782">[-]</label><label class="expand" for="c-36500782">[3 more]</label></div><br/><div class="children"><div class="content">SQL is a declarative language. If you ask it for an address, it&#x27;ll give you an address. Not sure what you&#x27;re trying to say with that xkcd.<p>SQL is a real language. It is testable and reusable. It&#x27;s a DSL, so the syntax isn&#x27;t something you have to look at most of the time unless you&#x27;re a DBA. That said, not everyone hates the syntax.<p>You&#x27;re probably losing efficiency in your quest for functional paradigm perfection.</div><br/><div id="36500967" class="c"><input type="checkbox" id="c-36500967" checked=""/><div class="controls bullet"><span class="by">roflyear</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500782">parent</a><span>|</span><a href="#36502650">next</a><span>|</span><label class="collapse" for="c-36500967">[-]</label><label class="expand" for="c-36500967">[2 more]</label></div><br/><div class="children"><div class="content">Being fair, there really aren&#x27;t tools built to test SQL queries like there are to test other code.</div><br/><div id="36501610" class="c"><input type="checkbox" id="c-36501610" checked=""/><div class="controls bullet"><span class="by">freetime2</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500967">parent</a><span>|</span><a href="#36502650">next</a><span>|</span><label class="collapse" for="c-36501610">[-]</label><label class="expand" for="c-36501610">[1 more]</label></div><br/><div class="children"><div class="content">We use integration tests to test our SQL queries. Basically fire up our persistence layer and a database instance together, call some create&#x2F;update methods, and assert that the expected results are returned. Writing tests is pretty straightforward - the tests proved incredibly valuable recently when we migrated to a different RDBMS provider.<p>But yeah I guess we don&#x27;t really have a good way to write automated tests for migrations that run outside of our application code.</div><br/></div></div></div></div></div></div><div id="36502650" class="c"><input type="checkbox" id="c-36502650" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500331">parent</a><span>|</span><a href="#36500782">prev</a><span>|</span><a href="#36500525">next</a><span>|</span><label class="collapse" for="c-36502650">[-]</label><label class="expand" for="c-36502650">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SQL may be a language for all those things, but unfortunately it&#x27;s horribly bad at it.<p>Any piece of software used incorrectly will seem &quot;horribly bad&quot;.<p>&gt; Wilfully obtuse syntax<p>This is an opinion.<p>&gt;  Incredibly poor compositionality.<p>Another opinion.<p>&gt;  No testability worth the name<p>I would argue that &quot;try it, observe side effects and rollback&quot; as a language feature is more testable than many&#x2F;most programming languages.<p>&gt; The deployment model is a half-baked pile of perl scripts, and that&#x27;s if you&#x27;re lucky.<p>&gt;&gt; Any piece of software used incorrectly will seem &quot;horribly bad&quot;.<p>I appreciate that you hate it. I don&#x27;t even think you should care or learn it if you don&#x27;t want to. But I think positioning things you don&#x27;t understand or _want to use_ as &quot;horrible&quot; or &quot;bad&quot; or whatever is acting in bad faith. You&#x27;re allowed to say that you don&#x27;t like something and don&#x27;t want to learn how to use it, without suggesting it&#x27;s the tool&#x27;s fault.<p>&gt; So yeah, I use SQL like <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;783&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;783&#x2F;</a> . I&#x27;m sure you have a bunch of cool data analysis tools in there, but please just shut up, give me the contents of my table, and let me process it in a real programming language where I have map&#x2F;reduce&#x2F;filter as regular composable functions that I can test and reuse, with a syntax that doesn&#x27;t make my eyes bleed.<p>This comment directly demonstrates &quot;I don&#x27;t understand, I don&#x27;t want to, just let me do whatever I want however I want&quot;, which is fine, but again, not the tool&#x27;s fault you don&#x27;t want to use it.<p>Quoting again because it&#x27;s also relevant to this last comment:<p>&gt;&gt; Any piece of software used incorrectly will seem &quot;horribly bad&quot;.</div><br/><div id="36502741" class="c"><input type="checkbox" id="c-36502741" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36502650">parent</a><span>|</span><a href="#36500525">next</a><span>|</span><label class="collapse" for="c-36502741">[-]</label><label class="expand" for="c-36502741">[1 more]</label></div><br/><div class="children"><div class="content">At some point there is an objective underlying reality. I&#x27;ve worked at a lot of places and never seen SQL done well; even the people who were happy with SQL had no automated testing, no compositionality to speak of, and a crappy deployment model (and would usually acknowledge all this! They just somehow didn&#x27;t mind). If one person uses a tool badly that&#x27;s maybe a problem for that person, but if everyone uses the tool badly that&#x27;s a problem with the tool.</div><br/></div></div></div></div></div></div><div id="36500525" class="c"><input type="checkbox" id="c-36500525" checked=""/><div class="controls bullet"><span class="by">throw_m239339</span><span>|</span><a href="#36498525">parent</a><span>|</span><a href="#36500331">prev</a><span>|</span><a href="#36503993">next</a><span>|</span><label class="collapse" for="c-36500525">[-]</label><label class="expand" for="c-36500525">[3 more]</label></div><br/><div class="children"><div class="content">&gt; My dislike of ORMs mainly stems from the tendency to treat modern SQL engines as glorified dumb bit buckets.<p>At scale, databases are OFTEN used as glorified dumb bit buckets for performance purposes with heavy denormalization techniques.</div><br/><div id="36500760" class="c"><input type="checkbox" id="c-36500760" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500525">parent</a><span>|</span><a href="#36503993">next</a><span>|</span><label class="collapse" for="c-36500760">[-]</label><label class="expand" for="c-36500760">[2 more]</label></div><br/><div class="children"><div class="content">If you have fewer than ten thousand simultaneous users, this is not you. After ten million, you&#x27;re not using an ORM in front of a bare relational database either.<p>Scale at high numbers adheres to no rules or off-the-shelf tools.</div><br/><div id="36502066" class="c"><input type="checkbox" id="c-36502066" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#36498525">root</a><span>|</span><a href="#36500760">parent</a><span>|</span><a href="#36503993">next</a><span>|</span><label class="collapse" for="c-36502066">[-]</label><label class="expand" for="c-36502066">[1 more]</label></div><br/><div class="children"><div class="content">I wish.  I&#x27;m constantly having to reinvent materialized views on engines that don&#x27;t have good support for the concept (ms SQL, sqlite) because my users want to sort&#x2F;filter on a calculated column, meaning that I have to revert to &quot;dumb bucket of bits&quot; for records in seven figures and user-counts in the dozens.<p>Relational algebra is good.  I like the idea of nornalized data.<p>I hope to be able to use it one day instead of SQL.</div><br/></div></div></div></div></div></div></div></div><div id="36503993" class="c"><input type="checkbox" id="c-36503993" checked=""/><div class="controls bullet"><span class="by">hn_user2</span><span>|</span><a href="#36498525">prev</a><span>|</span><a href="#36504018">next</a><span>|</span><label class="collapse" for="c-36503993">[-]</label><label class="expand" for="c-36503993">[1 more]</label></div><br/><div class="children"><div class="content">I’m an ex-ORM advocate.<p>In short, you are very very unlikely to ever change your database.<p>DBs are full of useful features that an ORM hides.<p>Instead, I now pick a DB that has the features I want and then use the hell out of the features.<p>I remember a pre-ORM time of so many manually created db side configs, stored procs, views, triggers, etc. that a DBA would have to manage. I think these unmanageable messes were one of the catalysts to getting people on board with ORMs.<p>To avoid going back that far. I make sure all config is part of code. Managed by migrations. Or otherwise checked into a repo and managed by a CI&#x2F;CD pipeline. Now I get to use a full featured DB again. Actually use all its features. And things don’t turn into unmanageable messes.</div><br/></div></div><div id="36504018" class="c"><input type="checkbox" id="c-36504018" checked=""/><div class="controls bullet"><span class="by">azlev</span><span>|</span><a href="#36503993">prev</a><span>|</span><a href="#36503649">next</a><span>|</span><label class="collapse" for="c-36504018">[-]</label><label class="expand" for="c-36504018">[1 more]</label></div><br/><div class="children"><div class="content">I remember the world before ORM (all queries inside data access objects) and it was not a great time to programming.<p>While I understand that ORMs have problems, I don&#x27;t want to craft all SQL by hand and make myself a SQL builder because I need some optional filters.</div><br/></div></div><div id="36503649" class="c"><input type="checkbox" id="c-36503649" checked=""/><div class="controls bullet"><span class="by">bbsimonbb</span><span>|</span><a href="#36504018">prev</a><span>|</span><a href="#36502678">next</a><span>|</span><label class="collapse" for="c-36503649">[-]</label><label class="expand" for="c-36503649">[2 more]</label></div><br/><div class="children"><div class="content">This thread only underscores the total mindshare dominance of ORMs. The implicit alternative to ORMs in almost every comment is raw sql in string literals in app code.<p>For 6 years now, we&#x27;ve had tools that let you use sql as a language, then generate the wrapper exposing your query to your app as a method. (queryfirst, pgtyped, pugsql, sqlc) This is (or could be) a paradigm shift. It&#x27;s clearly, demonstrably a superior way of working, but it exists on the fringes because ORMs (and this unchanging discussion) have sucked all the oxygen.</div><br/><div id="36504037" class="c"><input type="checkbox" id="c-36504037" checked=""/><div class="controls bullet"><span class="by">kubanczyk</span><span>|</span><a href="#36503649">parent</a><span>|</span><a href="#36502678">next</a><span>|</span><label class="collapse" for="c-36504037">[-]</label><label class="expand" for="c-36504037">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this. Also sqlc in Go.<p>SQL is a language, an extremely high-level one at that. Trying to stitch it together using a lower-level language is a prime example of &quot;if you have a hammer, every problem looks like a nail&quot;.<p>An illustration. Let&#x27;s say I&#x27;m coding in assembly (low-level) and I interact with a large system. The system&#x27;s docs say that the input can only be formulated in Java Script (higher-level than assembly). So there&#x27;s the choice: I can either import an arcane library that allows me to stitch something in pure assembly, without ever committing <i>.js file to repo. Or, I can express myself in </i>.js files, using the power of a high-level language.</div><br/></div></div></div></div><div id="36502678" class="c"><input type="checkbox" id="c-36502678" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#36503649">prev</a><span>|</span><a href="#36503977">next</a><span>|</span><label class="collapse" for="c-36502678">[-]</label><label class="expand" for="c-36502678">[1 more]</label></div><br/><div class="children"><div class="content">As with anything, there are situations where it works well and where it doesn&#x27;t, and the tech can be easily abused or misused. ORMs (in e.g. dotnet Entity Framework), particularly when working database-first, can be a great asset.<p>If you are working in DBs with hundreds of tables and all setup with proper foreign key relationships, an ORM can help navigate a complex schema and provide compile time sense checking when things change. Embedded SQL is a double edged swords with perceived performance benefits but with <i>very</i> difficult to maintain &quot;hard coded&quot; verbose SQL particularly for joins. I&#x27;m talking about when there are hundreds of tables, not when you have 5-10 tables.<p>I&#x27;ve no ambition to convince anyone one way or the other, but don&#x27;t believe everything your read on the internet about best practices especially since people may be talking about something quite different to what you&#x27;re looking at. Some people will be pretty shocking developers regardless of which tech is being used.</div><br/></div></div><div id="36503977" class="c"><input type="checkbox" id="c-36503977" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#36502678">prev</a><span>|</span><a href="#36503932">next</a><span>|</span><label class="collapse" for="c-36503977">[-]</label><label class="expand" for="c-36503977">[2 more]</label></div><br/><div class="children"><div class="content">The anti pattern is not the tools but how the tools are used. ORM is abused a lot by people that don&#x27;t necessarily understand databases very well. This abuse leads to overly complicated table structures based on an illusion that the ORM tries to keep up that internal domain models map 1 to 1 to the database. This is basically self inflicted pain. If you&#x27;ve never heard about the object impedance mismatch, that&#x27;s basically the problem with modern object oriented application architectures and trying to shoehorn that into a database.<p>Complex table structures have all sorts of issues related to complex database migrations and operational overhead related to that, additional complexity in the form of lots of joins, a need for indices to support those, all sorts of cascading behavior when things are updated or deleted, transactionality issues, and so on. That complexity tends to leak back into applications.<p>If you know what you are doing, you can avoid all of that of course. But there are a lot of examples of people using ORMs where things get a bit messy.<p>I&#x27;ve fixed a fair few projects where hibernate usage got out of hand a bit. These are not fun projects to join usually. Performance issues, flaky behavior, wonky test failures (and slow tests), etc.<p>Usually a good way out is to cut down on the number of tables. My mantra is that if you aren&#x27;t querying on it, maybe it can just be a json blob instead of a lot of silly tables and columns that need to be joined together. I like document stores. And you can easily adapt sql databases to build one that has nice transactional behavior.<p>A few years ago I consulted a company to help them build them a search engine. They had completely over-engineered their data model, spent months obsessing on their domain model, and there were 20 or so tables and all the usual issues related to that (hard to extend, issues with complex transactions, stupidly complicated joins, etc.). Basically, I sat their tech lead down and went over the requirements:<p>- get a thing by id<p>- do some CRUD on things<p>- put all the things in the search index (for each thing do X)<p>- use the search index to find things<p>That&#x27;s it. The whole point of the system was to act as a single source of truth for the search index.<p>So, I told them: that sounds like you need 1 table with a json blob to represent your thing. We had a few other columns for things like timestamps, userIds, etc. That vastly simplified the application architecture. We could add features without requiring a lot of database migrations. Etc. All good things.</div><br/><div id="36504012" class="c"><input type="checkbox" id="c-36504012" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#36503977">parent</a><span>|</span><a href="#36503932">next</a><span>|</span><label class="collapse" for="c-36504012">[-]</label><label class="expand" for="c-36504012">[1 more]</label></div><br/><div class="children"><div class="content">For more on this approach, see docs on single table design principles: <a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;compute&#x2F;creating-a-single-table-design-with-amazon-dynamodb&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;compute&#x2F;creating-a-single-table...</a></div><br/></div></div></div></div><div id="36503932" class="c"><input type="checkbox" id="c-36503932" checked=""/><div class="controls bullet"><span class="by">dagurp</span><span>|</span><a href="#36503977">prev</a><span>|</span><a href="#36498382">next</a><span>|</span><label class="collapse" for="c-36503932">[-]</label><label class="expand" for="c-36503932">[1 more]</label></div><br/><div class="children"><div class="content">I have inly used Django&#x27;s ORM and I don&#x27;t like writing queries in it but I think it&#x27;s fantastic because<p>* It generates the sql to create the DB very competently.<p>* It creates migration scripts<p>* Let&#x27;s me use SQLite on my dev machine but something else on my server<p>and this means that<p>* Version control is very easy<p>* Testing and bisecting older versions is not a problem<p>That makes it all worth it for me.</div><br/></div></div><div id="36498382" class="c"><input type="checkbox" id="c-36498382" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#36503932">prev</a><span>|</span><a href="#36503021">next</a><span>|</span><label class="collapse" for="c-36498382">[-]</label><label class="expand" for="c-36498382">[2 more]</label></div><br/><div class="children"><div class="content">ActiveRecord has always felt great to me: yes there are some corner cases to deal w&#x2F; but it hits the 80&#x2F;20 spot, let&#x27;s you kick out to SQL when you need to, adds a lot of excellent life-cycle related hooks that clean up domain logic, and is pretty easy to reason about<p>pragmatic ORMs that don&#x27;t try to hide everything behind a &quot;bundle&quot; or introduce their own query language are great, it&#x27;s the ones that try to totally &quot;solve&quot; the ORM problem that are hard to work with</div><br/><div id="36502664" class="c"><input type="checkbox" id="c-36502664" checked=""/><div class="controls bullet"><span class="by">tarsinge</span><span>|</span><a href="#36498382">parent</a><span>|</span><a href="#36503021">next</a><span>|</span><label class="collapse" for="c-36502664">[-]</label><label class="expand" for="c-36502664">[1 more]</label></div><br/><div class="children"><div class="content">Yes I can’t imagine going back to doing big CRUD apps without AR, readability and maintenance would take a hit. The catch is you need a prior good knowledge of SQL to use it correctly. Problems happen when people don’t learn SQL and then don’t understand the queries AR is generating and the limits.</div><br/></div></div></div></div><div id="36503021" class="c"><input type="checkbox" id="c-36503021" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#36498382">prev</a><span>|</span><a href="#36503860">next</a><span>|</span><label class="collapse" for="c-36503021">[-]</label><label class="expand" for="c-36503021">[3 more]</label></div><br/><div class="children"><div class="content">I love the Django ORM. It&#x27;s concise, generates good queries and just works.<p>However, there&#x27;s a danger - for complex applications, you want neatly separated domain objects and data layer. Django makes it really easy to make your model your domain object, and at some point that starts to hurt.<p>But a large part of any app <i>is</i> just objects backed 1-on-1 by a database table, and CRUD actions on them. It&#x27;s fine.<p>Just watch out for those parts where the separation is needed, and separate them.</div><br/><div id="36503240" class="c"><input type="checkbox" id="c-36503240" checked=""/><div class="controls bullet"><span class="by">robben1234</span><span>|</span><a href="#36503021">parent</a><span>|</span><a href="#36503860">next</a><span>|</span><label class="collapse" for="c-36503240">[-]</label><label class="expand" for="c-36503240">[2 more]</label></div><br/><div class="children"><div class="content">I feel that ORM might be an antipattern depending on a language.<p>Every Java developer I interacted in my career with wanted to avoid ORMs and instead come up with a bunch of pattern-abstracted ways to write raw SQL.<p>Every Python developer I interacted in my career with loved their ORMs. Django or SQLAlchemy.</div><br/><div id="36503266" class="c"><input type="checkbox" id="c-36503266" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#36503021">root</a><span>|</span><a href="#36503240">parent</a><span>|</span><a href="#36503860">next</a><span>|</span><label class="collapse" for="c-36503266">[-]</label><label class="expand" for="c-36503266">[1 more]</label></div><br/><div class="children"><div class="content">Probably depends on the typical type of application, team size etc then?<p>Or maybe Hibernate is just horrible :-) (I haven&#x27;t used it)</div><br/></div></div></div></div></div></div><div id="36503860" class="c"><input type="checkbox" id="c-36503860" checked=""/><div class="controls bullet"><span class="by">figassis</span><span>|</span><a href="#36503021">prev</a><span>|</span><a href="#36498338">next</a><span>|</span><label class="collapse" for="c-36503860">[-]</label><label class="expand" for="c-36503860">[1 more]</label></div><br/><div class="children"><div class="content">I don’t really understand the N+1 issue. Most ORMs I’ve used make it very easy to generate the exact query you’d generate without it, with the added benefit that you define the relationships at the model level. This helps a lot when you need to make changes like renaming a field without having to worry about propagating these changes in every query and migration in your app. When you build a statement with an ORM, you can also output it and tweak it to be what you would write as raw sql. You can look at generated migrations and tweak your models until migrations are efficient, etc. if you’re generating N+1 queries I don’t know if you would do better with raw sql. Besides, most ORMs today let you switch between 3 levels, default ORM, query builder and raw sql. You also get to choose if it converts the results into your models or if it just returns raw results. Maybe I’m missing something but so far it seems like the problem with ORMs lie on not understanding when and how to use them?.</div><br/></div></div><div id="36498338" class="c"><input type="checkbox" id="c-36498338" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36503860">prev</a><span>|</span><a href="#36503863">next</a><span>|</span><label class="collapse" for="c-36498338">[-]</label><label class="expand" for="c-36498338">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s begging the question: it never was.<p><i>Some</i> ORMs are awful to work with, but that doesn&#x27;t mean the genre is a bad idea. I&#x27;ve loved working with SQLAlchemy over the years because it doesn&#x27;t try to re-invent the whole idea of SQL. Instead, it gives you a convenient layer for building queries, passing them around, etc., while it concentrates on getting the details right so you don&#x27;t have to futz around with them.</div><br/><div id="36501454" class="c"><input type="checkbox" id="c-36501454" checked=""/><div class="controls bullet"><span class="by">tempest_</span><span>|</span><a href="#36498338">parent</a><span>|</span><a href="#36498479">next</a><span>|</span><label class="collapse" for="c-36501454">[-]</label><label class="expand" for="c-36501454">[2 more]</label></div><br/><div class="children"><div class="content">My only real ORM experience is with SQLAlchemy (and a tiny bit of trying to learn ecto) and based on this thread I have to ask are all the other ORMs just terrible?<p>I&#x27;ve been learning some rust lately and writing out boilerplate code to handle simple CRUD is painstaking and it feels like a waste of my time.<p>SQLAlechemy&#x27;s ORM can get in the way a bit for more complex queries (or ones you are trying to optimize) but you can always just drop down and write the SQL for those specifically.</div><br/><div id="36501710" class="c"><input type="checkbox" id="c-36501710" checked=""/><div class="controls bullet"><span class="by">edgyquant</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36501454">parent</a><span>|</span><a href="#36498479">next</a><span>|</span><label class="collapse" for="c-36501710">[-]</label><label class="expand" for="c-36501710">[1 more]</label></div><br/><div class="children"><div class="content">&gt;are all the other ORMs just terrible<p>From what I’ve seen yes.  My first ORM was flask-sqlalchemy.  Migrating a database was literally just updating an object and running a command.  No other ORM has been this seamless.</div><br/></div></div></div></div><div id="36498479" class="c"><input type="checkbox" id="c-36498479" checked=""/><div class="controls bullet"><span class="by">bellgrove</span><span>|</span><a href="#36498338">parent</a><span>|</span><a href="#36501454">prev</a><span>|</span><a href="#36498454">next</a><span>|</span><label class="collapse" for="c-36498479">[-]</label><label class="expand" for="c-36498479">[8 more]</label></div><br/><div class="children"><div class="content">I haven’t seen someone use the phrase begging the question properly in… forever.</div><br/><div id="36502952" class="c"><input type="checkbox" id="c-36502952" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36498479">parent</a><span>|</span><a href="#36500974">next</a><span>|</span><label class="collapse" for="c-36502952">[-]</label><label class="expand" for="c-36502952">[4 more]</label></div><br/><div class="children"><div class="content">Including here, since &#x27;it never was&#x27; is a statement, not a question. So no question has been begged.</div><br/><div id="36503077" class="c"><input type="checkbox" id="c-36503077" checked=""/><div class="controls bullet"><span class="by">DangitBobby</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36502952">parent</a><span>|</span><a href="#36500974">next</a><span>|</span><label class="collapse" for="c-36503077">[-]</label><label class="expand" for="c-36503077">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve misunderstood the comment. The question posed in the title of TFA is being begged.</div><br/><div id="36503723" class="c"><input type="checkbox" id="c-36503723" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36503077">parent</a><span>|</span><a href="#36503686">prev</a><span>|</span><a href="#36500974">next</a><span>|</span><label class="collapse" for="c-36503723">[-]</label><label class="expand" for="c-36503723">[1 more]</label></div><br/><div class="children"><div class="content">Oh I see, 2 statements:<p>That&#x27;s begging the question. It never was.</div><br/></div></div></div></div></div></div><div id="36500974" class="c"><input type="checkbox" id="c-36500974" checked=""/><div class="controls bullet"><span class="by">jkrubin</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36498479">parent</a><span>|</span><a href="#36502952">prev</a><span>|</span><a href="#36498454">next</a><span>|</span><label class="collapse" for="c-36500974">[-]</label><label class="expand" for="c-36500974">[3 more]</label></div><br/><div class="children"><div class="content">What is the proper usage?</div><br/><div id="36501038" class="c"><input type="checkbox" id="c-36501038" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36500974">parent</a><span>|</span><a href="#36501233">next</a><span>|</span><label class="collapse" for="c-36501038">[-]</label><label class="expand" for="c-36501038">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I can summarize it concisely, so I&#x27;ll defer to the wiki: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Begging_the_question" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Begging_the_question</a><p>In this case, the phrasing of the question implies something not at all evident, that ORMs are an anti-pattern.</div><br/></div></div><div id="36501233" class="c"><input type="checkbox" id="c-36501233" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#36498338">root</a><span>|</span><a href="#36500974">parent</a><span>|</span><a href="#36501038">prev</a><span>|</span><a href="#36498454">next</a><span>|</span><label class="collapse" for="c-36501233">[-]</label><label class="expand" for="c-36501233">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;w&#x2F;index.php?title=Begging_the_question&amp;oldid=1157780714" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;w&#x2F;index.php?title=Begging_the_quest...</a></div><br/></div></div></div></div></div></div><div id="36498454" class="c"><input type="checkbox" id="c-36498454" checked=""/><div class="controls bullet"><span class="by">evrimoztamur</span><span>|</span><a href="#36498338">parent</a><span>|</span><a href="#36498479">prev</a><span>|</span><a href="#36503863">next</a><span>|</span><label class="collapse" for="c-36498454">[-]</label><label class="expand" for="c-36498454">[1 more]</label></div><br/><div class="children"><div class="content">I also can vouch for SQLAlchemy, in the in the sense that it allows me to write SQL with confidence, where the code matches the query.</div><br/></div></div></div></div><div id="36503863" class="c"><input type="checkbox" id="c-36503863" checked=""/><div class="controls bullet"><span class="by">vaughan</span><span>|</span><a href="#36498338">prev</a><span>|</span><a href="#36498415">next</a><span>|</span><label class="collapse" for="c-36503863">[-]</label><label class="expand" for="c-36503863">[1 more]</label></div><br/><div class="children"><div class="content">We are definitely going to look back on this era and wonder why we stuck to archaic tech for so long.<p>It&#x27;s clear that the database needs to be more integrated in our applications.<p>SQL is not a good fit for most apps. The reporting&#x2F;analytics features are great, but that&#x27;s not what most of our apps are doing these days. This kind of stuff is moved off into other databases most of the time anyway. The core idea of the &quot;relational model&quot; is not a good fit for most apps. Interactive user interfaces are about listening to changes in single models...we don&#x27;t really care about &quot;relations&quot;. Relations are forced upon us to allow automatically optimizing query execution in the database. But this optimization doesn&#x27;t take into account what other queries we run, so we have to handle caching ourselves, and completely breaks reactivity. People fight against the query planner all the time.<p>I think the solution is to have control of the query plan.<p>Without a database, people write code that is similar to what a database is doing, often without realizing it.<p>Take: `users.map(user =&gt; ({user, posts: postsByUserId[user.id]})`. We have created an index, and we&#x27;re doing an apparent hash join.<p>Now this usually turns into a tangled mess because of all these adhoc hashmaps we create and pass around. You will see this kind of spaghetti all through modern web apps. The more of these adhoc transformations you have, the more complexity you have because we don&#x27;t have good tools to visually trace these transformations throughout your app. Your app becomes hard to change. But it also gives us a lot more flexibility when it comes to caching query results.<p>What would be nice is if our sql dbs were broken into layers, and we had access to the query planner so we can write reactive and cacheable queries. And also that our sql dbs could be run in the same memory space as our app code...which means running in a web browser.</div><br/></div></div><div id="36498415" class="c"><input type="checkbox" id="c-36498415" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36503863">prev</a><span>|</span><a href="#36502637">next</a><span>|</span><label class="collapse" for="c-36498415">[-]</label><label class="expand" for="c-36498415">[9 more]</label></div><br/><div class="children"><div class="content">IMO SQL is one case where you should &quot;just program the damn thing&quot;.<p>There&#x27;s no point at all in learning some SQL or ORM library.  Learn and write SQL directly.<p>Database access is a fundamental thing you&#x27;ll be doing for your entire career probably. Best to learn the actual technology directly.<p>This is true for certain other technologies too - CSS for example - don&#x27;t learn a CSS library - learn and use CSS. In fact that&#x27;s true really for almost all aspects of front end development - don&#x27;t use a &quot;forms library&quot;, program the damn forms APIs in the browser.<p>Also my personal experience is that SQL is much easier to learn than certain ORMs anyway.<p>Don&#x27;t waste the cost of learning the wrong thing.</div><br/><div id="36498459" class="c"><input type="checkbox" id="c-36498459" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36498415">parent</a><span>|</span><a href="#36498519">next</a><span>|</span><label class="collapse" for="c-36498459">[-]</label><label class="expand" for="c-36498459">[2 more]</label></div><br/><div class="children"><div class="content">And then you learn SQL, which you should, you&#x27;ll know when using an ORM is the right option.  You might even be able to evaluate them better.<p>I suppose the same with CSS -- knowing it means you&#x27;ll have much more flexibility and understanding when picking a CSS library for convenience.</div><br/><div id="36498722" class="c"><input type="checkbox" id="c-36498722" checked=""/><div class="controls bullet"><span class="by">systems_glitch</span><span>|</span><a href="#36498415">root</a><span>|</span><a href="#36498459">parent</a><span>|</span><a href="#36498519">next</a><span>|</span><label class="collapse" for="c-36498722">[-]</label><label class="expand" for="c-36498722">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, my introduction to databases was extracting stuff using Perl&#x27;s DBI and getting good at pushing the work out to the DB. When I was introduced to ORMs it was instantly clear that they were a game changer for MVC development.<p>I&#x27;ve transitioned a few legacy (large) Rails applications through Arel and often did not understand why we were putting the work in, other than to make it easier on new&#x2F;future developers who did not understand SQL. In pretty much all of them we ended up having to keep some non-Arel queries -- you know, the ones where `STRAIGHT_JOIN` cuts 5 minutes off a query!</div><br/></div></div></div></div><div id="36498519" class="c"><input type="checkbox" id="c-36498519" checked=""/><div class="controls bullet"><span class="by">homarp</span><span>|</span><a href="#36498415">parent</a><span>|</span><a href="#36498459">prev</a><span>|</span><a href="#36502849">next</a><span>|</span><label class="collapse" for="c-36498519">[-]</label><label class="expand" for="c-36498519">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it more a case of &quot;learn the fundamentals before learning the abstraction&quot; 
so you know what you are &quot;paying for&quot; (unless it&#x27;s &quot;zero-cost&quot; abstraction)?</div><br/><div id="36498824" class="c"><input type="checkbox" id="c-36498824" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36498415">root</a><span>|</span><a href="#36498519">parent</a><span>|</span><a href="#36500571">next</a><span>|</span><label class="collapse" for="c-36498824">[-]</label><label class="expand" for="c-36498824">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say it&#x27;s more of <i>use the fundamentals</i>. Learning them is, hopefully[0], table stakes. But even devs who know how to wield SQL, will be tempted to wrap it into some kind of ORM (either COTS or a DIY one), or a set of structures and functions, forming a flat and generic &quot;data access layer&quot; - all because that&#x27;s how they&#x27;ve been taught the code should be structured. This is the pressure they need to resist.<p>That said, I myself haven&#x27;t found the perfect balance. If you&#x27;re going to honestly embrace the database, and follow a data-first approach, chances are you&#x27;ll end up with an application that does most of its business logic on the database side.<p>On the one hand, it makes perfect sense - if your software is really about data transformation, there&#x27;s no good reason to pull data from the DB, just so you can reshape it by hand using inferior tools not fit for purpose (i.e. most code you normally write), and then put it back into DB.<p>On the other hand, it feels <i>wrong</i>. Can&#x27;t exactly say why, but somehow, having my app be a PostgreSQL database serving its own REST API, feels <i>too direct</i>, even if it literally does 100% of what I need. Closest I can come to explaining this is, RDBMS doesn&#x27;t give me enough <i>control</i> - maybe I want the REST API to work slightly differently, or have more specific security needs, etc. But then, do I <i>really</i> need those alterations? Are they worth all the complexity and overhead that comes from writing software the &quot;ordinary way&quot;, where RDBMS is only a dumb data store?<p>--<p>[0] - Who am I kidding...</div><br/></div></div><div id="36500571" class="c"><input type="checkbox" id="c-36500571" checked=""/><div class="controls bullet"><span class="by">paddw</span><span>|</span><a href="#36498415">root</a><span>|</span><a href="#36498519">parent</a><span>|</span><a href="#36498824">prev</a><span>|</span><a href="#36498903">next</a><span>|</span><label class="collapse" for="c-36500571">[-]</label><label class="expand" for="c-36500571">[1 more]</label></div><br/><div class="children"><div class="content">I think you are right, but databases are complicated enough where people can have different interpretations of what the fundamentals means.<p>For example, is being able to write the basic SQL query enough, or do you need to know what the difference between a hash join and nested loop is?<p>Without a pretty deep understanding, I think it can be hard to pick out faults with the ORM, and there is always the chance the ORM might avoid making a mistake you do yourself.</div><br/></div></div></div></div><div id="36502849" class="c"><input type="checkbox" id="c-36502849" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#36498415">parent</a><span>|</span><a href="#36498519">prev</a><span>|</span><a href="#36500511">next</a><span>|</span><label class="collapse" for="c-36502849">[-]</label><label class="expand" for="c-36502849">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Learn and write SQL directly.<p>Done that, been doing that since 1992 (using Pro*Pascal, CS130 - it&#x27;s a wonder I didn&#x27;t immediately quit and take up llama farming) but currently I am using what would be classed as an ORM (`crud` by `azer`) for its marshalling to&#x2F;from Go types because Go&#x27;s stdlib `sql` is bare bones and you essentially have to write your own object (un-)marshalling and Good Lord, it is tedious.<p>But that is all I&#x27;d use an ORM for these days.</div><br/></div></div><div id="36500511" class="c"><input type="checkbox" id="c-36500511" checked=""/><div class="controls bullet"><span class="by">aksss</span><span>|</span><a href="#36498415">parent</a><span>|</span><a href="#36502849">prev</a><span>|</span><a href="#36502637">next</a><span>|</span><label class="collapse" for="c-36500511">[-]</label><label class="expand" for="c-36500511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Learn to write SQL directly...[it&#x27;s] a fundamental thing you&#x27;ll be doing for your entire career probably<p>SQL has been called &quot;the eternal language&quot;. I can say that across many target development platforms from mainframe, to desktops, to client&#x2F;server, to web, and across all the languages used on them, SQL has been a common thread through it all (acknowledging they all have had their own idiom). Completely agree any developer is a stronger developer if they are well familiar with the data layer and what&#x27;s going on down there. Classic question is - if you&#x27;re going to spend your time learning the peculiarities of an ORM, why not just spend the time invested in learning SQL? The compound interest on your SQL experience will likely be worth more in ten to fifteen years than some platform or language specific ORM. I know there are reasons to learn and use an ORM but speaking in broad terms here. Avoidance of having to learn SQL shouldn&#x27;t be the sole reason one is biased towards an ORM.</div><br/></div></div></div></div><div id="36502637" class="c"><input type="checkbox" id="c-36502637" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#36498415">prev</a><span>|</span><a href="#36498500">next</a><span>|</span><label class="collapse" for="c-36502637">[-]</label><label class="expand" for="c-36502637">[1 more]</label></div><br/><div class="children"><div class="content">People will try to reinvent the same thing over-and-over - mostly because of missing core knowledge. So the cycle will go this way: discard ORM and use native SQL queries. Make your own management of what has changed and what not. Make your own (object) relationship&#x2F;collection management. Make your own caches of loaded objects. And - the most non-obvious but the real deal-breaker: deal with complex updates where MANY objects are involved. Then they will come and start praising ORM. Because they learned the core knowledge...</div><br/></div></div><div id="36498500" class="c"><input type="checkbox" id="c-36498500" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#36502637">prev</a><span>|</span><a href="#36502739">next</a><span>|</span><label class="collapse" for="c-36498500">[-]</label><label class="expand" for="c-36498500">[12 more]</label></div><br/><div class="children"><div class="content">A point I&#x27;m missing is: without using an ORM (or however else you&#x27;re calling your database interface) you will eventually end up writing <i>and maintaining</i> one yourself, at least for CRUD stuff, and it will be filled with weird bugs, edge cases and security holes.<p>&gt; A common complaint about ORMs is that they break two of the SOLID rules. If you aren’t familiar with SOLID, it is an acronym for the principles that are taught in college classes about software design.<p>And that right here is the problem. Academia is teaching people stuff that makes sense <i>in an academic environment</i> where time, maintainability, money and effort aren&#x27;t of a concern (as long as you have grant money, but that&#x27;s not relevant here) - and that leads to a <i>very</i> nasty collision when fresh graduates enter the workforce. They&#x27;re used to shaving yaks and reinvent wheels all day long in the quest for a &quot;perfect&quot; solution, and if the company doesn&#x27;t have (enough and qualified) senior&#x2F;lead developers to catch that, you end up with ... very interesting products, budget overruns and&#x2F;or dumpster fires. Or a combination of all of them.<p>ETA: There&#x27;s something that can go <i>even worse</i>: when stuff designed by and for academics enters public availability. The best&#x2F;worst example for that is OpenStack... enough knobs and twists to support the specialized environment of CERN and probably hundreds of universities worldwide, with components modularized to an <i>insane</i> degree, but almost impossible to get started with because it&#x27;s so byzantine.</div><br/><div id="36501675" class="c"><input type="checkbox" id="c-36501675" checked=""/><div class="controls bullet"><span class="by">invalidname</span><span>|</span><a href="#36498500">parent</a><span>|</span><a href="#36498716">next</a><span>|</span><label class="collapse" for="c-36501675">[-]</label><label class="expand" for="c-36501675">[2 more]</label></div><br/><div class="children"><div class="content">Yes!<p>This entire thread is filled with people complaining about ORM not matching vendor promises which is true.<p>* It won&#x27;t let you swap a database with no effort
* It won&#x27;t remove the need to learn and understand the SQL it generates
* It won&#x27;t make schemas seamless<p>We use it since it&#x27;s a standard abstraction that we would need to replicate otherwise. It makes caching the database access possible which is remarkably difficult to do at scale for manual SQL.<p>It comes with standardized tools and best practices that make issues like n+1 irrelevant.<p>The main problem with ORM are:<p>* Misaligned expectations
* Bad ORMs<p>All you need to do to appreciate ORM is open a project written without it and try to change ANYTHING in that project... ORMs are amazing!</div><br/></div></div><div id="36498716" class="c"><input type="checkbox" id="c-36498716" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#36498500">parent</a><span>|</span><a href="#36501675">prev</a><span>|</span><a href="#36500444">next</a><span>|</span><label class="collapse" for="c-36498716">[-]</label><label class="expand" for="c-36498716">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>you will eventually end up writing and maintaining one yourself</i><p>Only if you insist on formulating your logic based on &quot;objects&quot; instead of &quot;rows&quot;; see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36498583">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36498583</a></div><br/><div id="36498779" class="c"><input type="checkbox" id="c-36498779" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#36498500">root</a><span>|</span><a href="#36498716">parent</a><span>|</span><a href="#36500444">next</a><span>|</span><label class="collapse" for="c-36498779">[-]</label><label class="expand" for="c-36498779">[2 more]</label></div><br/><div class="children"><div class="content">Most programming languages have long since gone towards OOP so it is only natural for people to think of their database in the same way (which coincicentally is the same reason why MongoDB got so popular).<p>The key thing is: most applications won&#x27;t <i>ever</i> reach the scale where it&#x27;s a better investment to ditch the ORM and most of your data model than to increase the &quot;instance-class&quot; parameter of your RDS database. So many projects fail because they think from the beginning what life would be as a unicorn and burn all their money on an insanely complex tech stack that could have been S3 buckets for the frontend, a couple of EC2 servers for the backend and RDS for the database. The really basic stuff can get you really far without exposing you to vendor-lock in or yak shavings.<p>Shave the yaks when you actually need the fur.</div><br/><div id="36500350" class="c"><input type="checkbox" id="c-36500350" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36498500">root</a><span>|</span><a href="#36498779">parent</a><span>|</span><a href="#36500444">next</a><span>|</span><label class="collapse" for="c-36500350">[-]</label><label class="expand" for="c-36500350">[1 more]</label></div><br/><div class="children"><div class="content">&gt; most applications won&#x27;t ever reach the scale where it&#x27;s a better investment to ditch the ORM<p>Aside from working in a large application that used ORM (and had many, many problems because of it), my personal experience with using them - specifically Hibernate - to develop an application from scratch was based on a relatively simple application to parse and help reconcile bank statements. This was never going to be an application that required &quot;scale&quot;.<p>What I found was that, relative to just using SQL, the ORM version of my application was much more complex, required significantly more knowledge of the tools, and produced inferior code.<p>While I was able to get an MVP up and running slightly faster with the ORM, the productivity benefits diminished - and rapidly became negative - while the performance of the application for even a single user was very poor. Eventually, what should have taken milliseconds in SQL was literally taking seconds in the ORM. Not only did it generate stupid queries, each query had much greater latency. And what I was doing was extremely simple.<p>In addition to the poor performance and greater complexity, ORMs - like all dependencies - are not cost-free. There can be a significant learning curve just to get started with an ORM like Hibernate, and that learning curve then needs to apply to all developers who touch the code base.<p>In our larger application, we found that hibernate specifically had so many edge cases - not to mention its own SQL syntax - that the overhead of using it came to dominate the development time for new features. The need to create multiple objects (database entities AND entity objects) that could get out of sync, problems with cache consistency, latency, HQL... the list of gotchas and principle violations (DRY, KISS, SRP) was endless.<p>These days I simply refuse to use ORMs, and tend to do any complex database work in the database itself, i.e. with plpgsql. I find working directly with SQL to be insanely productive, and the resulting code to be in the order of 10x - 100x faster than what I used to be able to achieve in Java using ORMs.<p>&gt; The really basic stuff can get you really far without exposing you to vendor-lock in or yak shavings<p>In my experience, vendor lock-in and yak-shaving are <i>exactly</i> what you get with ORMs.</div><br/></div></div></div></div></div></div><div id="36500444" class="c"><input type="checkbox" id="c-36500444" checked=""/><div class="controls bullet"><span class="by">pravus</span><span>|</span><a href="#36498500">parent</a><span>|</span><a href="#36498716">prev</a><span>|</span><a href="#36498556">next</a><span>|</span><label class="collapse" for="c-36500444">[-]</label><label class="expand" for="c-36500444">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A point I&#x27;m missing is: without using an ORM (or however else you&#x27;re calling your database interface) you will eventually end up writing and maintaining one yourself, at least for CRUD stuff, and it will be filled with weird bugs, edge cases and security holes.<p>The middle ground I&#x27;ve found is to use code generation for the CRUD boilerplate with a framework that makes it easy to do free-form SQL or easy query building.  It gets rid of all the unnecessary contortions for advanced queries while still giving you a nice API for all the basic stuff because you get helpers instead of abstract objects.  An example would be sqlboiler for Go.</div><br/></div></div><div id="36498556" class="c"><input type="checkbox" id="c-36498556" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36498500">parent</a><span>|</span><a href="#36500444">prev</a><span>|</span><a href="#36498631">next</a><span>|</span><label class="collapse" for="c-36498556">[-]</label><label class="expand" for="c-36498556">[4 more]</label></div><br/><div class="children"><div class="content">This. Use a good one unless you want to own half of a poor one.</div><br/><div id="36500230" class="c"><input type="checkbox" id="c-36500230" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#36498500">root</a><span>|</span><a href="#36498556">parent</a><span>|</span><a href="#36498631">next</a><span>|</span><label class="collapse" for="c-36500230">[-]</label><label class="expand" for="c-36500230">[3 more]</label></div><br/><div class="children"><div class="content">This is just a claim that everyone who advocates for ORMs makes, but it’s not reality.</div><br/><div id="36502193" class="c"><input type="checkbox" id="c-36502193" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36498500">root</a><span>|</span><a href="#36500230">parent</a><span>|</span><a href="#36498631">next</a><span>|</span><label class="collapse" for="c-36502193">[-]</label><label class="expand" for="c-36502193">[2 more]</label></div><br/><div class="children"><div class="content">The third time I have to figure out whether to write obj.setCreatedAt(rs.getTimestamp(&quot;created_at&quot;, calendar)) or obj.setCreatedAt(rs.getLong(&quot;created_at&quot;)) I&#x27;m going to write code to look at the schema and the setter and figure it out automatically. And that’s where new ORMs come from.</div><br/><div id="36503366" class="c"><input type="checkbox" id="c-36503366" checked=""/><div class="controls bullet"><span class="by">isbvhodnvemrwvn</span><span>|</span><a href="#36498500">root</a><span>|</span><a href="#36502193">parent</a><span>|</span><a href="#36498631">next</a><span>|</span><label class="collapse" for="c-36503366">[-]</label><label class="expand" for="c-36503366">[1 more]</label></div><br/><div class="children"><div class="content">Query builders solve those problems without the complexity of ORMs.</div><br/></div></div></div></div></div></div></div></div><div id="36498631" class="c"><input type="checkbox" id="c-36498631" checked=""/><div class="controls bullet"><span class="by">treeman79</span><span>|</span><a href="#36498500">parent</a><span>|</span><a href="#36498556">prev</a><span>|</span><a href="#36502739">next</a><span>|</span><label class="collapse" for="c-36498631">[-]</label><label class="expand" for="c-36498631">[1 more]</label></div><br/><div class="children"><div class="content">Since a few departments and multiple companies struggle &#x2F; fail because a super brilliant guy(s) was chasing perfection.  No useful work could get done. Or it took 20-100x longer than a quick and dirty approach.<p>Perhaps the worst was when a team of highly skilled HTML designers were forced to learning functional programming.  
Sure the back end wizard to configure some setting was a marvel of modern engineering and elegant design.   It just took 10 people a year to build.<p>VC money makes people weird.</div><br/></div></div></div></div><div id="36502739" class="c"><input type="checkbox" id="c-36502739" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#36498500">prev</a><span>|</span><a href="#36501156">next</a><span>|</span><label class="collapse" for="c-36502739">[-]</label><label class="expand" for="c-36502739">[4 more]</label></div><br/><div class="children"><div class="content">The article leaves out a few weaknesses of ORMs<p>1. inability to represent arbitrary query results. Results get mapped back into &#x27;domain-objects&#x27;. Now you&#x27;ve removed yourself from the extreme expressiveness of the SELECT statement as well as GROUP BY, pivot tables etc. etc.
The best you can hope for is domain objects that are only partially initialized with values.<p>2. lazy loading of attributes - certainly configurable, but if you rely on SELECT statements being generated while you are navigating a &#x27;persistent&#x27; object, you will run into unexpected performance issues. 
To solve those, you then start to eagerly load domain data for certain access patterns. More annotations, more configurations and more ... stuff - where a nice SELECT query would have sufficed to get the data you need.<p>3. Troubleshooting is a pain. Especially if you rely on dynamically building queries. Have fun getting the actual SQL that was run and then translate back and forth between SQL and the query builder syntax to optimize it - if you can even optimize it.<p>4. Doesn&#x27;t treat data as data. First of all data coming from SQL queries is stale the moment it arrives in your objects. Trying to pretend otherwise and having an object graph that pretends to be the living counterpart of the state in your DB is foolishness.<p>5. No&#x2F;limited control over writes&#x2F;updates.
The moment you rely on your ORM to create UPDATEs and INSERTS to reflect the state of your object graph back into the DB, good luck with your chosen locking strategy and good luck optimizing those. Pessimistic locking is the best worst you can hope for.<p>Stay away from ORMs (as in Hibernate and its ilk) and treat data as data. Use structs&#x2F;records.</div><br/><div id="36502776" class="c"><input type="checkbox" id="c-36502776" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#36502739">parent</a><span>|</span><a href="#36501156">next</a><span>|</span><label class="collapse" for="c-36502776">[-]</label><label class="expand" for="c-36502776">[3 more]</label></div><br/><div class="children"><div class="content">5x simply not true</div><br/><div id="36503092" class="c"><input type="checkbox" id="c-36503092" checked=""/><div class="controls bullet"><span class="by">DandyDev</span><span>|</span><a href="#36502739">root</a><span>|</span><a href="#36502776">parent</a><span>|</span><a href="#36501156">next</a><span>|</span><label class="collapse" for="c-36503092">[-]</label><label class="expand" for="c-36503092">[2 more]</label></div><br/><div class="children"><div class="content">That is a cheap comment. Could you elaborate why you disagree with the comment you respond to?</div><br/><div id="36503357" class="c"><input type="checkbox" id="c-36503357" checked=""/><div class="controls bullet"><span class="by">isbvhodnvemrwvn</span><span>|</span><a href="#36502739">root</a><span>|</span><a href="#36503092">parent</a><span>|</span><a href="#36501156">next</a><span>|</span><label class="collapse" for="c-36503357">[-]</label><label class="expand" for="c-36503357">[1 more]</label></div><br/><div class="children"><div class="content">Not the original responder - hibernate has had projections to solve #1 for ages, the rest are on point IMO.</div><br/></div></div></div></div></div></div></div></div><div id="36501156" class="c"><input type="checkbox" id="c-36501156" checked=""/><div class="controls bullet"><span class="by">post-it</span><span>|</span><a href="#36502739">prev</a><span>|</span><a href="#36498334">next</a><span>|</span><label class="collapse" for="c-36501156">[-]</label><label class="expand" for="c-36501156">[4 more]</label></div><br/><div class="children"><div class="content">I love ORMs. I recently wrote a little script to scrape a website and put some data in a database. I used Sequelize and it&#x27;s excellent. I don&#x27;t want to write an<p>INSERT INTO blah (A, B, C, D, E, F, G, ...) VALUES (a, b, c, d, f, e, g, ...)<p>statement where, whoops, I transposed two values! Will SQL throw a cryptic error because the types don&#x27;t match, or will it silently accept my awful query because the types do match? Perhaps I&#x27;ll find out after a frustrating night of querying data that doesn&#x27;t seem to make sense.<p>&quot;But post-it, why don&#x27;t you write a loop that builds a query string?&quot;<p>I could! But if I&#x27;m already abstracting away the misery that is SQL, I may as well use a library.<p>&quot;But post-it, with an ORM I can&#x27;t do &lt;X thing to speed up my query&gt;!&quot;<p>I&#x27;m never going to need that. 99% of people using SQL are never going to need it. They&#x27;re going to INSERT &lt; 100 million things and then they&#x27;re going to do a bunch of SELECTS and some JOINs and they won&#x27;t care if the query takes 150 ms or 50 ms. And if they do, they&#x27;ll optimize and write that one thing in raw SQL.</div><br/><div id="36502374" class="c"><input type="checkbox" id="c-36502374" checked=""/><div class="controls bullet"><span class="by">superasn</span><span>|</span><a href="#36501156">parent</a><span>|</span><a href="#36498334">next</a><span>|</span><label class="collapse" for="c-36502374">[-]</label><label class="expand" for="c-36502374">[3 more]</label></div><br/><div class="children"><div class="content">You can always insert into blah set A=a, B=b, .. in SQL too</div><br/><div id="36502579" class="c"><input type="checkbox" id="c-36502579" checked=""/><div class="controls bullet"><span class="by">psnehanshu</span><span>|</span><a href="#36501156">root</a><span>|</span><a href="#36502374">parent</a><span>|</span><a href="#36498334">next</a><span>|</span><label class="collapse" for="c-36502579">[-]</label><label class="expand" for="c-36502579">[2 more]</label></div><br/><div class="children"><div class="content">What? Never knew this.</div><br/><div id="36502867" class="c"><input type="checkbox" id="c-36502867" checked=""/><div class="controls bullet"><span class="by">331c8c71</span><span>|</span><a href="#36501156">root</a><span>|</span><a href="#36502579">parent</a><span>|</span><a href="#36498334">next</a><span>|</span><label class="collapse" for="c-36502867">[-]</label><label class="expand" for="c-36502867">[1 more]</label></div><br/><div class="children"><div class="content">Me neither... Must be an sql dialect.</div><br/></div></div></div></div></div></div></div></div><div id="36498334" class="c"><input type="checkbox" id="c-36498334" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#36501156">prev</a><span>|</span><a href="#36498371">next</a><span>|</span><label class="collapse" for="c-36498334">[-]</label><label class="expand" for="c-36498334">[6 more]</label></div><br/><div class="children"><div class="content">I’m a big fan of the “middle ground” micro-ORMs like Dapper or Diesel.<p>Write your queries in SQL, but you get to have your strong typing and automatic result set to objects mappings. Productivity combined with the full-featured “real” query language.<p>Also, I’ve become a fan of using the object mappers only for read-only queries. Updates occur via the command pattern — stored procedures. These can be mapped through to look like native methods.</div><br/><div id="36498567" class="c"><input type="checkbox" id="c-36498567" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#36498334">parent</a><span>|</span><a href="#36500583">next</a><span>|</span><label class="collapse" for="c-36498567">[-]</label><label class="expand" for="c-36498567">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely. Dapper is easily the most pleasurable data access solution I have worked with. Developers need to stop pretending SQL doesn&#x27;t exist and just embrace it.</div><br/></div></div><div id="36500583" class="c"><input type="checkbox" id="c-36500583" checked=""/><div class="controls bullet"><span class="by">zmj</span><span>|</span><a href="#36498334">parent</a><span>|</span><a href="#36498567">prev</a><span>|</span><a href="#36498391">next</a><span>|</span><label class="collapse" for="c-36500583">[-]</label><label class="expand" for="c-36500583">[1 more]</label></div><br/><div class="children"><div class="content">I think this is the sweet spot. Last time I worked with SQLite on .NET I wrote a wrapper library along those lines: <a href="https:&#x2F;&#x2F;github.com&#x2F;zmj&#x2F;sqlite-fast">https:&#x2F;&#x2F;github.com&#x2F;zmj&#x2F;sqlite-fast</a></div><br/></div></div><div id="36498391" class="c"><input type="checkbox" id="c-36498391" checked=""/><div class="controls bullet"><span class="by">gmac</span><span>|</span><a href="#36498334">parent</a><span>|</span><a href="#36500583">prev</a><span>|</span><a href="#36500663">next</a><span>|</span><label class="collapse" for="c-36498391">[-]</label><label class="expand" for="c-36498391">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the middle ground is great. In TypeScript there’s Kysely or Zapatos (mine), for example.</div><br/></div></div><div id="36500663" class="c"><input type="checkbox" id="c-36500663" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#36498334">parent</a><span>|</span><a href="#36498391">prev</a><span>|</span><a href="#36498371">next</a><span>|</span><label class="collapse" for="c-36500663">[-]</label><label class="expand" for="c-36500663">[2 more]</label></div><br/><div class="children"><div class="content">Personally I like not having to either write my own model functions which just map back to sql, or having to write a boilerplate php to do parameterized queries correctly. Eloquent abstracts enough of that crap out of my way i can focus on the logic.<p>Sincerely someone rewriting an &#x27;old&#x27; php app that is just arrays and queries to something using models and eloquent, what a game changer</div><br/><div id="36503782" class="c"><input type="checkbox" id="c-36503782" checked=""/><div class="controls bullet"><span class="by">BafS</span><span>|</span><a href="#36498334">root</a><span>|</span><a href="#36500663">parent</a><span>|</span><a href="#36498371">next</a><span>|</span><label class="collapse" for="c-36503782">[-]</label><label class="expand" for="c-36503782">[1 more]</label></div><br/><div class="children"><div class="content">Eloquent is one of the worst ORM I worked with. It works until it doesn&#x27;t, there is too much magic and it mixes SQL&#x2F;Entity in the same class. Since then I use doctrine and&#x2F;or repository pattern which makes the code more extensible and testable, it&#x27;s also trivial to do your own raw SQL request and map it to your entity if you don&#x27;t want to rely on an ORM.</div><br/></div></div></div></div></div></div><div id="36498371" class="c"><input type="checkbox" id="c-36498371" checked=""/><div class="controls bullet"><span class="by">square_usual</span><span>|</span><a href="#36498334">prev</a><span>|</span><a href="#36503817">next</a><span>|</span><label class="collapse" for="c-36498371">[-]</label><label class="expand" for="c-36498371">[2 more]</label></div><br/><div class="children"><div class="content">ORMs are all problematic, but some are less problematic than others. Some years ago I started writing more Elixir with Phoenix and Ecto, and I quickly realized just how much better Ecto is when compared to ActiveRecord. I wrote about it back then [1] but the gist of is it: SQL &gt; Query Builders with some ORM elements &gt; ORM qua ORM, and the less you blur the boundary between your application and the database the better.<p>1: <a href="https:&#x2F;&#x2F;blog.shrikanthup.com&#x2F;2021-12-04-ecto-data&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.shrikanthup.com&#x2F;2021-12-04-ecto-data&#x2F;</a></div><br/><div id="36500471" class="c"><input type="checkbox" id="c-36500471" checked=""/><div class="controls bullet"><span class="by">mmcclure</span><span>|</span><a href="#36498371">parent</a><span>|</span><a href="#36503817">next</a><span>|</span><label class="collapse" for="c-36500471">[-]</label><label class="expand" for="c-36500471">[1 more]</label></div><br/><div class="children"><div class="content">You say this in your post (and allude to it here), so not trying to be pedantic, but explicitly surfacing it here for other folks that don&#x27;t click through: Ecto isn&#x27;t an ORM.<p>I <i>love</i> Ecto. In my opinion, Phoenix has a lot of strengths, but Ecto is the superpower in that ecosystem.<p>That being said, at least _some_ of the brand of &quot;problems&quot; mentioned in the post can exist into the Ecto world. I&#x27;ve seen plenty of folks new to Ecto fall into N+1 queries using `preload` naively, so I&#x27;d argue it doesn&#x27;t completely erase that blurred boundary. I also personally much prefer the level that Ecto sits at and think the tradeoffs are totally worth it.</div><br/></div></div></div></div><div id="36503817" class="c"><input type="checkbox" id="c-36503817" checked=""/><div class="controls bullet"><span class="by">redditor98654</span><span>|</span><a href="#36498371">prev</a><span>|</span><a href="#36503878">next</a><span>|</span><label class="collapse" for="c-36503817">[-]</label><label class="expand" for="c-36503817">[1 more]</label></div><br/><div class="children"><div class="content">I love the DynamoDB mapper model of the ORM. It only handles object serialization and deserialization but everything else you write code as if you are working with the native DynamoDB API. I want an RDBMS ORM that does only that - translate a ResultSet to a Java POJO and convert a Java POJO to an SQL insert&#x2F;update statement. I would gladly handle everything myself.</div><br/></div></div><div id="36503878" class="c"><input type="checkbox" id="c-36503878" checked=""/><div class="controls bullet"><span class="by">gv83</span><span>|</span><a href="#36503817">prev</a><span>|</span><a href="#36503989">next</a><span>|</span><label class="collapse" for="c-36503878">[-]</label><label class="expand" for="c-36503878">[1 more]</label></div><br/><div class="children"><div class="content">all the absolutism I read in the comments speaks miles about the problem not being in ORMs (which are a tool that is very useful given the right scenario) but existing between chair and keyboard.<p>I&#x27;d rather have an ORM than having to deal with some of the garbage code I&#x27;ve seen over the years (specially around many-to-many tables or relations in general) to handle the deserialization from db &quot;manually, hand crafted, artisanal, more maintainable&quot;, specially for very basic CRUD or almost CRUD scenario where a decent ORM pulls most of the project with little hassle.<p>Hand crafted queries have their places just like ORMs.</div><br/></div></div><div id="36503989" class="c"><input type="checkbox" id="c-36503989" checked=""/><div class="controls bullet"><span class="by">valevino</span><span>|</span><a href="#36503878">prev</a><span>|</span><a href="#36501264">next</a><span>|</span><label class="collapse" for="c-36503989">[-]</label><label class="expand" for="c-36503989">[1 more]</label></div><br/><div class="children"><div class="content">This word brings me nightmares: EAGER</div><br/></div></div><div id="36501264" class="c"><input type="checkbox" id="c-36501264" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#36503989">prev</a><span>|</span><a href="#36498851">next</a><span>|</span><label class="collapse" for="c-36501264">[-]</label><label class="expand" for="c-36501264">[1 more]</label></div><br/><div class="children"><div class="content">My experience is that ORMs are like training wheels for fledgling teams&#x2F;developers. They&#x27;re a fantastic way to make sure everyone is following the same pattern&#x2F;rules and that changes will more-or-less work over time without too much headache. If you have a team with developers who are actually skilled in SQL and use things like Dapper when writing code, you will actively detest the notion that the raw SQL should be abstracted away.<p>I also believe that you are more likely to completely go off rails if constrained at domain modeling time into an ORM-compatible schema. The real world usually has some cranky things like circular dependencies and self-joins. Modeling these effectively with an ORM can be a nightmare (in my experience). If you have access to SQL, determining how to manage a circular dependency is much more obvious &amp; direct. The effect is that you are free to model you domain in such a manner that it more closely resembles actual reality. In turn, this makes it easier to talk about and write the SQL.<p>There is 100% a virtuous cycle here. The more you force yourself to endure the SQL, the better every aspect around it will become. You will feel the fire of a bad schema the moment you see if it you have been spending thousands of hours troubleshooting queries over bad schemas. Knowing when an arrangement of tables is &quot;smelly&quot; before they see any data can save you <i>so much</i> frustration. I think a lot of people who hide from SQL aren&#x27;t hiding from SQL. They&#x27;re hiding from someone else&#x27;s horrible interpretation of a problem domain.</div><br/></div></div><div id="36498851" class="c"><input type="checkbox" id="c-36498851" checked=""/><div class="controls bullet"><span class="by">ajhurliman</span><span>|</span><a href="#36501264">prev</a><span>|</span><a href="#36502554">next</a><span>|</span><label class="collapse" for="c-36498851">[-]</label><label class="expand" for="c-36498851">[3 more]</label></div><br/><div class="children"><div class="content">I may be in the minority here (based off of other comments), but using raw SQL commands has been more performant, easier to write, easier to understand, easier to learn, and easier to build complex queries&#x2F; commands than an ORM has ever provided.<p>Updating some records in a CTE and using the results in a subsequent SELECT? It may take a minute or so on stack overflow, but significantly less than it would with SQLAlchemy.<p>Want to make a composite primary key? I have no idea how you would do it with most ORMs, but it’s relatively straightforward with SQL.<p>A lot of times the stuff you want to do won’t even be available in your ORM, but the person lobbying for using it always pleads “it’s okay, it still allows you to make raw queries! We have an escape hatch!” Then when you start writing raw queries, your PRs get rejected: “Please stick to the ORM”.<p>I don’t understand people’s love of ORMs instead of simply learning SQL, it seems to bring on myriad headaches for nearly zero benefit.</div><br/><div id="36502542" class="c"><input type="checkbox" id="c-36502542" checked=""/><div class="controls bullet"><span class="by">meitham</span><span>|</span><a href="#36498851">parent</a><span>|</span><a href="#36500515">next</a><span>|</span><label class="collapse" for="c-36502542">[-]</label><label class="expand" for="c-36502542">[1 more]</label></div><br/><div class="children"><div class="content">I don’t use ORM, but depending on the complexity of the SQL statement I might build it using SQL alchemy core.  I hate to deal with all these rules about the right way of escaping SQL Colum names with “, ‘ and [.  I find it sqlalchemy core to be the right balance where I am still in charge of the transaction management around the statement but rely on a library to build the textual SQL statement, without it I would probably have to reinvent some parts of sqlalchemy.</div><br/></div></div><div id="36500515" class="c"><input type="checkbox" id="c-36500515" checked=""/><div class="controls bullet"><span class="by">c_crank</span><span>|</span><a href="#36498851">parent</a><span>|</span><a href="#36502542">prev</a><span>|</span><a href="#36502554">next</a><span>|</span><label class="collapse" for="c-36500515">[-]</label><label class="expand" for="c-36500515">[1 more]</label></div><br/><div class="children"><div class="content">Seconding this. Nothing less fun than trying to untangle insidious Hibernate bugs.</div><br/></div></div></div></div><div id="36502554" class="c"><input type="checkbox" id="c-36502554" checked=""/><div class="controls bullet"><span class="by">ookblah</span><span>|</span><a href="#36498851">prev</a><span>|</span><a href="#36503810">next</a><span>|</span><label class="collapse" for="c-36502554">[-]</label><label class="expand" for="c-36502554">[1 more]</label></div><br/><div class="children"><div class="content">i feel like i&#x27;m old enough to see every new generation of people come in talking about how ORM is the devil lol.  balance in everything, i maintain that ORM for 90% of the people out there is the right solution (basic or complex CRUD apps).<p>is it the most efficient?  a big no, but at most people&#x27;s scale it&#x27;s fine and nothing that a caching layer can&#x27;t solve if you really need it.  you can always drive down to the raw SQL as well.<p>i can&#x27;t tell you how many times in my career i thought i was a purist for writing raw queries or using even a query builder and ended up creating some frankenstein &quot;ORM&quot; in the end.  if you&#x27;re app has any sort of complexity involving relationships you are in for a bad time trying to cobble this shit together yourself.</div><br/></div></div><div id="36503810" class="c"><input type="checkbox" id="c-36503810" checked=""/><div class="controls bullet"><span class="by">bartq</span><span>|</span><a href="#36502554">prev</a><span>|</span><a href="#36503801">next</a><span>|</span><label class="collapse" for="c-36503810">[-]</label><label class="expand" for="c-36503810">[1 more]</label></div><br/><div class="children"><div class="content">The obvious solution is to use nor ORMs or raw SQL generated with various helpers in your language, but to open up DB engine to execute low level bytecode. Think: DB=GPU, SQL=GLSL, what&#x27;s actually executed -&gt; compiled code.</div><br/></div></div><div id="36503801" class="c"><input type="checkbox" id="c-36503801" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36503810">prev</a><span>|</span><a href="#36502795">next</a><span>|</span><label class="collapse" for="c-36503801">[-]</label><label class="expand" for="c-36503801">[1 more]</label></div><br/><div class="children"><div class="content">Where they ever an anti-patter?<p>I would say no.<p>But most implementations have issues of varying degrees of servility. And the important part is understanding this issues and deciding weather or not this issues are worth it compared to the benefit a _specific_ ORM might provide.</div><br/></div></div><div id="36502795" class="c"><input type="checkbox" id="c-36502795" checked=""/><div class="controls bullet"><span class="by">cjdell</span><span>|</span><a href="#36503801">prev</a><span>|</span><label class="collapse" for="c-36502795">[-]</label><label class="expand" for="c-36502795">[2 more]</label></div><br/><div class="children"><div class="content">It took me a long time to realise this but I discovered the only thing I really needed from an ORM was a type safe query builder. Essentially a drop in replacement for trivial SQL queries, which is most of them.<p>This article sums up the difference between old and new quite nicely. Prisma is fantastic for rapid development and type safety but doesn&#x27;t require you to completely change the way you write code as it is still basically just a query generator, unlike traditional ORMs which use hidden magic to try to do everything for you with surprising consequences.<p><a href="https:&#x2F;&#x2F;www.prisma.io&#x2F;docs&#x2F;concepts&#x2F;more&#x2F;comparisons&#x2F;prisma-and-typeorm" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.prisma.io&#x2F;docs&#x2F;concepts&#x2F;more&#x2F;comparisons&#x2F;prisma-...</a></div><br/><div id="36503671" class="c"><input type="checkbox" id="c-36503671" checked=""/><div class="controls bullet"><span class="by">erikpukinskis</span><span>|</span><a href="#36502795">parent</a><span>|</span><label class="collapse" for="c-36503671">[-]</label><label class="expand" for="c-36503671">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think you can call Prisma a “query builder”…<p>It introduces its own global DSL for describing relationships between tables, and then you query that. So if you need a relationship for any query, it’s now present in the model for every query. That doesn’t feel like a query builder to me.<p>A query builder should still look like the SQL if you blur your eyes. Prisma does not.</div><br/></div></div></div></div></div></div></div></div></div></body></html>