<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dthompson.us/posts/optimizing-guile-scheme.html">Optimizing Guile Scheme</a>Â <span class="domain">(<a href="https://dthompson.us">dthompson.us</a>)</span></div><div class="subtext"><span>avvvv</span> | <span>57 comments</span></div><br/><div><div id="41648574" class="c"><input type="checkbox" id="c-41648574" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41648357">next</a><span>|</span><label class="collapse" for="c-41648574">[-]</label><label class="expand" for="c-41648574">[13 more]</label></div><br/><div class="children"><div class="content">I have such mixed feelings about dynamically typed languages. I&#x27;ve designed a whole pile of hobby programming languages, and dynamically typed languages are at least an order of magnitude simpler to design and for users to learn and start using.<p>At the same time, they inevitably seem to lead to user stories like this where a user really does know exactly what types they&#x27;re working with and wants the language to know that too (for performance or correctness), and they end up jumping through all sorts of insane hoops to get the optimizer to do exactly what they want.</div><br/><div id="41651507" class="c"><input type="checkbox" id="c-41651507" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#41648574">parent</a><span>|</span><a href="#41648665">next</a><span>|</span><label class="collapse" for="c-41651507">[-]</label><label class="expand" for="c-41651507">[6 more]</label></div><br/><div class="children"><div class="content">I think Common Lisp got it exactly right. Strongly typed dynamic language where you can optionally specify types for the extra performance&#x2F;correctness if need be (especially with SBCL).<p>Honestly, I think weak typing is more of an issue than dynamic typing and people  cry for static types when they suffer mostly from the former.<p>Dynamic typing is great because it allows you to have extremely complex types for basically free. It allows for insane expressiveness. It also makes prototyping much easier and does not force you into over-specifying in you types early on. In dynamic language most of your types are the most general type that would work by default while static types forces you to use very specific types (especially when lacking structural typing.)<p>If you want to allow just half the expressiveness of dynamic languages in your static language you will quickly find huge complexity with dependent types, long compile time, cryptic error messages and whatnot.<p>Generally, I think gradual typing is rising in popularity for good reason. It allows for quick prototyping but also to drill down on your types when you want to. Best of both worlds.</div><br/><div id="41653719" class="c"><input type="checkbox" id="c-41653719" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41651507">parent</a><span>|</span><a href="#41653847">next</a><span>|</span><label class="collapse" for="c-41653719">[-]</label><label class="expand" for="c-41653719">[1 more]</label></div><br/><div class="children"><div class="content">I find much the same to be true. I&#x27;m a big fan of Racket&#x27;s define&#x2F;contract and clojure&#x27;s Malli&#x2F;guardrails. You get one of the biggest benefits of static types (code that self-documents the expected shape of data) while enjoying all the benefits of a dynamic language (like creating types at runtime, and repl-driven development).</div><br/></div></div><div id="41653847" class="c"><input type="checkbox" id="c-41653847" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41651507">parent</a><span>|</span><a href="#41653719">prev</a><span>|</span><a href="#41648665">next</a><span>|</span><label class="collapse" for="c-41653847">[-]</label><label class="expand" for="c-41653847">[4 more]</label></div><br/><div class="children"><div class="content">I wish Common Lisp had integrated type declarations with TYPEP and CHECK-TYPE, instead of punting with &quot;consequences are undefined if the value of the declared variable is not of the declared type,&quot; i.e., sucks to be you.</div><br/><div id="41654145" class="c"><input type="checkbox" id="c-41654145" checked=""/><div class="controls bullet"><span class="by">nouripenny</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41653847">parent</a><span>|</span><a href="#41648665">next</a><span>|</span><label class="collapse" for="c-41654145">[-]</label><label class="expand" for="c-41654145">[3 more]</label></div><br/><div class="children"><div class="content">No doubt you know this, but Common Lisp&#x27;s standardization gave leeway to implementations. So you could choose which implementation suits you better. Common Lisp is an umbrella for different Lisps to have some commonality. It was a process of negotiation, during a time when there were many design forks in the road, and diverse use-cases<p>For example, type declarations can enable performance optimizations, compiletime type checking, runtime type checking, IDE autocompletion, etc. Or they can be ignored, if compiler simplicity is more valued. All these things have engineering tradeoffs. For example, runtime checks may have runtime costs at odds with performance optimization<p>There might be higher-value improvements to Common Lisp, if higher quality code is desired</div><br/><div id="41655638" class="c"><input type="checkbox" id="c-41655638" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41654145">parent</a><span>|</span><a href="#41648665">next</a><span>|</span><label class="collapse" for="c-41655638">[-]</label><label class="expand" for="c-41655638">[2 more]</label></div><br/><div class="children"><div class="content">As someone who doesn&#x27;t know much about types, do SBCL type declarations provide as good type-based development experience as OCaml and Rust?<p>And perhaps I wouldn&#x27;t get your answer, I mean is there something fundamentally inadequate in the way SBCL declares types? I think there is a phrase for it in CS theory.</div><br/><div id="41655876" class="c"><input type="checkbox" id="c-41655876" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41655638">parent</a><span>|</span><a href="#41648665">next</a><span>|</span><label class="collapse" for="c-41655876">[-]</label><label class="expand" for="c-41655876">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As someone who doesn&#x27;t know much about types, do SBCL type declarations provide as good type-based development experience as OCaml and Rust?<p>First of all, op was talking about strongly typed languages. Asking are they good as statically typed ones like Rust and OCaml is raising the goal posts quite a bit.<p>Second of all, SBCL can indeed have a subsection of its code expressed in OCaml-like static types, see<p><a href="https:&#x2F;&#x2F;github.com&#x2F;coalton-lang&#x2F;coalton">https:&#x2F;&#x2F;github.com&#x2F;coalton-lang&#x2F;coalton</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41648665" class="c"><input type="checkbox" id="c-41648665" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#41648574">parent</a><span>|</span><a href="#41651507">prev</a><span>|</span><a href="#41649885">next</a><span>|</span><label class="collapse" for="c-41648665">[-]</label><label class="expand" for="c-41648665">[2 more]</label></div><br/><div class="children"><div class="content">I like dynamic languages too. But I don&#x27;t like the idea of &quot;optimization&quot;, and I would be super interested in a dynamic language that didn&#x27;t attempt to divorce performance from correctness. The worst part about jumping through insane hoops to enchant the optimizer is that it can all go wrong with the tiniest change--a flag here, a different usage pattern there, a new version, etc., and suddenly your program doesn&#x27;t do what you need it to, as though an operation taking 1000x longer is just a matter of degree.</div><br/><div id="41649356" class="c"><input type="checkbox" id="c-41649356" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41648665">parent</a><span>|</span><a href="#41649885">next</a><span>|</span><label class="collapse" for="c-41649356">[-]</label><label class="expand" for="c-41649356">[1 more]</label></div><br/><div class="children"><div class="content">I agree completely.<p>At the same time, no one wants their code to run 100x slower than it would in any typical statically typed language. Unoptimized dynamic languages are <i>sloooooow</i>.</div><br/></div></div></div></div><div id="41649885" class="c"><input type="checkbox" id="c-41649885" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41648574">parent</a><span>|</span><a href="#41648665">prev</a><span>|</span><a href="#41653497">next</a><span>|</span><label class="collapse" for="c-41649885">[-]</label><label class="expand" for="c-41649885">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy with dynamic languages for almost everything I do and generally do not want to sacrifice flexibility, which is the price to pay for a static type system. However, certain parts of a program become more crystalline over time, whether for performance or correctness reasons, and being able to express those parts using a static type system makes a lot of sense. PreScheme [0] is an example of a statically typed Scheme that composes with the host Scheme. I&#x27;d like to see more work in this direction as Scheme already works well as a multi-paradigm language.<p>[0] <a href="https:&#x2F;&#x2F;prescheme.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prescheme.org&#x2F;</a></div><br/></div></div><div id="41653497" class="c"><input type="checkbox" id="c-41653497" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41648574">parent</a><span>|</span><a href="#41649885">prev</a><span>|</span><a href="#41649466">next</a><span>|</span><label class="collapse" for="c-41653497">[-]</label><label class="expand" for="c-41653497">[2 more]</label></div><br/><div class="children"><div class="content">As a long-time Python and JavaScript user, I&#x27;ve come to the conclusion that dynamic typing is just not a good idea for anything beyond exploratory or very small projects.<p>The problem is that you invariably have to think about types. If you mistakenly pass a string to a function expecting an integer, you better hope that that is properly handled, otherwise you risk having type errors at runtime, or worseâno errors, and silent data corruption. That function also needs to be very explicit about this, but often the only way to do that is via documentation, which is often not good enough, or flat out wrong. All of this amounts to a lot of risk and operational burden.<p>Python&#x27;s answer has historically been duck typing, which doesn&#x27;t guarantee correctness so it&#x27;s not a solution, and is more recently addressing it with gradual typing, which has its own issues and limitations. Primarily that if specifying types is optional, most programmers will not bother, or will just default to `any` to silence the type checker. While for JS we had to invent entirely new languages that compile to it, and we&#x27;ve reached the point where nobody sane would be caught working with plain JS in 2024.<p>Static typing, in turn, gives you a compile time safety net. It avoids a whole host of runtime issues, reduces the amount of exhaustive and mechanical tests you need to write, while also serving as explicit documentation. Code is easier to reason about and maintain, especially on large projects. You do lose some of the expressiveness and succinctness of dynamic typing, but what you gain with static typing is far more helpful than these minor benefits.</div><br/><div id="41654338" class="c"><input type="checkbox" id="c-41654338" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#41648574">root</a><span>|</span><a href="#41653497">parent</a><span>|</span><a href="#41649466">next</a><span>|</span><label class="collapse" for="c-41654338">[-]</label><label class="expand" for="c-41654338">[1 more]</label></div><br/><div class="children"><div class="content">Dynamic typing with deeply nested data forces you to put type bandaids all over the code. For example you end up defining Pydantic schemas and then validating the same thing more than once since you can&#x27;t guarantee that the type of a thing was not changed somewhere in the middle.<p>Dynamic typing forces you to test behavior which could be tested much more thoroughly by a type checker, at compile time, with zero development time.<p>Dynamic typing does offer much faster time to early prototyping but then drags you down with each bug.<p>Static typing does force some early commitments to the structure of the data but it also allows faster iteration and refactoring.<p>Static typing with good type inference seems the best to me.</div><br/></div></div></div></div><div id="41649466" class="c"><input type="checkbox" id="c-41649466" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#41648574">parent</a><span>|</span><a href="#41653497">prev</a><span>|</span><a href="#41648357">next</a><span>|</span><label class="collapse" for="c-41649466">[-]</label><label class="expand" for="c-41649466">[1 more]</label></div><br/><div class="children"><div class="content">stanza (<a href="https:&#x2F;&#x2F;lbstanza.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lbstanza.org&#x2F;</a>) is a very interesting experiment in designing for gradual types rather than retrofitting them onto a dynamic language</div><br/></div></div></div></div><div id="41648357" class="c"><input type="checkbox" id="c-41648357" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41648574">prev</a><span>|</span><a href="#41647855">next</a><span>|</span><label class="collapse" for="c-41648357">[-]</label><label class="expand" for="c-41648357">[2 more]</label></div><br/><div class="children"><div class="content">Solid blog overall and I think it is pitched at the right level of granularity for the topic. However, if I were offering criticism, the place I think more detail would be super interesting is the &#x27;Please Inline&#x27; section. In particular, I would really be interested in a slightly more detailed description of the optimizer&#x27;s algorithm for inlining. I think the &quot;define_inlinable&quot; macro is a great example of macro usage, but it is clearly a way to circumvent the inliner&#x27;s apparent short comings. I would like to be able to understand what heuristic the optimizer is using to see if there is a sensible default function construction style&#x2F;idiom that is more appealing to the optimizer for inlining. However, I am reminded of the inlining discussion in Chandler Carruth&#x27;s talk (Understanding Compiler Optimization) from a few years ago where he discusses how obscure and seemingly arbitrary, in general, inlining heuristics and their optimization passes are in practice. [1]<p>1 - <a href="https:&#x2F;&#x2F;youtu.be&#x2F;FnGCDLhaxKU?si=J3MhvJ-BmX5SG2N6&amp;t=1550" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;FnGCDLhaxKU?si=J3MhvJ-BmX5SG2N6&amp;t=1550</a></div><br/><div id="41649327" class="c"><input type="checkbox" id="c-41649327" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41648357">parent</a><span>|</span><a href="#41647855">next</a><span>|</span><label class="collapse" for="c-41649327">[-]</label><label class="expand" for="c-41649327">[1 more]</label></div><br/><div class="children"><div class="content">A walkthrough of Guile&#x27;s optimization passes and the inlining heuristics would be great. I&#x27;ve been meaning to do a &quot;part two&quot; here but you know how these things go.</div><br/></div></div></div></div><div id="41647855" class="c"><input type="checkbox" id="c-41647855" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41648357">prev</a><span>|</span><a href="#41649193">next</a><span>|</span><label class="collapse" for="c-41647855">[-]</label><label class="expand" for="c-41647855">[1 more]</label></div><br/><div class="children"><div class="content">Great overview on how to approach improving code performance, without going down the usual route of rewriting into something else.</div><br/></div></div><div id="41649193" class="c"><input type="checkbox" id="c-41649193" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41647855">prev</a><span>|</span><a href="#41648456">next</a><span>|</span><label class="collapse" for="c-41649193">[-]</label><label class="expand" for="c-41649193">[2 more]</label></div><br/><div class="children"><div class="content">If you want to read just an enormous amount of well-written bloggage about optimizing Guile Scheme, this is the spot: <a href="https:&#x2F;&#x2F;wingolog.org" rel="nofollow">https:&#x2F;&#x2F;wingolog.org</a><p>Andy Wingo is the maintainer and I get a kick out of everything he posts.</div><br/><div id="41649910" class="c"><input type="checkbox" id="c-41649910" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41649193">parent</a><span>|</span><a href="#41648456">next</a><span>|</span><label class="collapse" for="c-41649910">[-]</label><label class="expand" for="c-41649910">[1 more]</label></div><br/><div class="children"><div class="content">Andy&#x27;s blog is on another level. He&#x27;s also leading the Hoot project to compile Guile to WebAssembly and I work with him on that and try to absorb whatever compiler knowledge I can while doing so.</div><br/></div></div></div></div><div id="41648456" class="c"><input type="checkbox" id="c-41648456" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#41649193">prev</a><span>|</span><a href="#41651141">next</a><span>|</span><label class="collapse" for="c-41648456">[-]</label><label class="expand" for="c-41648456">[26 more]</label></div><br/><div class="children"><div class="content">These sorts of optimizations can and should be handled by a (sufficiently smart (tm)) compiler.<p>Common Lisp&#x2F;SBCL is usually sufficiently smart. I know not everyone likes Common Lisp, but at least I would have tested it with something more performant that Guile, like Chicken Scheme (my favorite!), Chez Scheme, etc.<p>I like Guile and its purpose as a universal scripting language. However, its performance issues are well known. Even compared to other scripting-first languages (Lua, Perl, Python etc).</div><br/><div id="41648613" class="c"><input type="checkbox" id="c-41648613" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41648456">parent</a><span>|</span><a href="#41649409">next</a><span>|</span><label class="collapse" for="c-41648613">[-]</label><label class="expand" for="c-41648613">[1 more]</label></div><br/><div class="children"><div class="content">I think that is why this blog is particularly interesting to me. As one of the other comments to this posting said, it is nice to see an analysis&#x2F;detailed description of working to optimize code where the first step is not to rewrite in a language with a presumed better performance baseline. Also, I think there is also some props to be given for continuing to work within Guile&#x27;s somewhat spartan tooling to do the optimization work, instead of switching to a language that may have more&#x2F;better tooling for the task.<p>Not to take away from the general comparisons between various Lisp flavors and between various scripting languages (an activity I engage in quite often), but your lead off line is more prescriptive than I find advisable. I don&#x27;t think a blanket statement that optimizations of runtime behavior of code &quot;should&quot; only be done via a compiler. Some devs enjoy the work, others have varied reasons for doing performance sensitive work in a given language&#x2F;environment. But at the end of day, doing optimization is a valid usage of developer effort and time if that developer judges it so.</div><br/></div></div><div id="41649409" class="c"><input type="checkbox" id="c-41649409" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41648456">parent</a><span>|</span><a href="#41648613">prev</a><span>|</span><a href="#41651564">next</a><span>|</span><label class="collapse" for="c-41649409">[-]</label><label class="expand" for="c-41649409">[3 more]</label></div><br/><div class="children"><div class="content">Guile has come a long way in the past decade or so! I think your info is quite out of date. Guile&#x27;s compiler performs a number of state of the art optimizations. It compiles to bytecode so native code compilers like Chez win the race, naturally. The JIT is pretty good, though! Native compilation is on the roadmap for Guile, but maybe somewhat surprisingly we&#x27;re getting AOT compilation to WebAssembly first. <a href="https:&#x2F;&#x2F;spritely.institute&#x2F;hoot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;spritely.institute&#x2F;hoot&#x2F;</a></div><br/><div id="41649637" class="c"><input type="checkbox" id="c-41649637" checked=""/><div class="controls bullet"><span class="by">armitron</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41649409">parent</a><span>|</span><a href="#41651564">next</a><span>|</span><label class="collapse" for="c-41649637">[-]</label><label class="expand" for="c-41649637">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still much much slower than SBCL which is not surprising given the time &amp; effort that went into the latter. User-guided optimizations (type declarations, stack allocation, intrinsics, machine code generation) in SBCL are also more flexible and better integrated.</div><br/><div id="41649779" class="c"><input type="checkbox" id="c-41649779" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41649637">parent</a><span>|</span><a href="#41651564">next</a><span>|</span><label class="collapse" for="c-41649779">[-]</label><label class="expand" for="c-41649779">[1 more]</label></div><br/><div class="children"><div class="content">Yup, SBCL is quite amazing!</div><br/></div></div></div></div></div></div><div id="41651564" class="c"><input type="checkbox" id="c-41651564" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41648456">parent</a><span>|</span><a href="#41649409">prev</a><span>|</span><a href="#41654722">next</a><span>|</span><label class="collapse" for="c-41651564">[-]</label><label class="expand" for="c-41651564">[3 more]</label></div><br/><div class="children"><div class="content">Part of the problem is that raw Scheme is spectacularly underspecified.<p>It also doesn&#x27;t help that Schemes like Guile are also interactive. The domain of an interactive language and a &quot;compiled&quot; language are quite different.<p>Given the entirety of the program made available to the compiler all at once, there are high level derivations that can happen notably through flow analysis to let the compiler make better decisions. But do that in an interactive environment when the rug can be pulled out of any of the assumption the compiler made, and things get messy quite quickly.<p>One interesting tidbit for Java is that the developers of the compiler advocate &quot;idiomatic&quot; Java. Simply, write Java like Java, and don&#x27;t try to trick the compiler. Let the compiler developers trick the compiler.<p>That&#x27;s evident here in this article when they wrote the function that tests the types of the parameters. Raw Scheme, naturally, doesn&#x27;t allow you to specify parameter types, not the way you can in Common Lisp, for example. And, either Guile does not have an specific extension to support this, or simply the compiler looks for this type checking pattern at the top of a function to make optimization determinations. On the one hand, it could be more succinct with a specialized facility, but on the other, this is &quot;just Scheme&quot;.<p>So, in effect by checking for the type of the variable, they&#x27;re implicitly declaring the type of the variable for the &quot;sufficiently smart&quot; compiler to make better decisions.<p>The counter example is the &quot;define-inline&quot; construct, and thus not standard Scheme (though readily replaced by a &quot;no-op&quot; macro if one was interested in porting the code).</div><br/><div id="41654948" class="c"><input type="checkbox" id="c-41654948" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651564">parent</a><span>|</span><a href="#41653336">next</a><span>|</span><label class="collapse" for="c-41654948">[-]</label><label class="expand" for="c-41654948">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But do that in an interactive environment when the rug can be pulled out of any of the assumption the compiler made, and things get messy quite quickly.<p><a href="https:&#x2F;&#x2F;bibliography.selflanguage.org&#x2F;_static&#x2F;dynamic-deoptimization.pdf" rel="nofollow">https:&#x2F;&#x2F;bibliography.selflanguage.org&#x2F;_static&#x2F;dynamic-deopti...</a></div><br/></div></div><div id="41653336" class="c"><input type="checkbox" id="c-41653336" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651564">parent</a><span>|</span><a href="#41654948">prev</a><span>|</span><a href="#41654722">next</a><span>|</span><label class="collapse" for="c-41653336">[-]</label><label class="expand" for="c-41653336">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Given the entirety of the program made available to the compiler all at once, there are high level derivations that can happen notably through flow analysis to let the compiler make better decisions. But do that in an interactive environment when the rug can be pulled out of any of the assumption the compiler made, and things get messy quite quickly.<p>Haskell&#x27;s GHC does quite well with its &#x27;ghci&#x27; interactive environment.  GHC is a compiler first and foremost, and as far as I can tell, ghci works by compiling each line you give it one by one?  (But even in ghci, you have to abide by the type system of Haskell, so that might help.)<p>The Common Lisps were always pretty good at combining compiled and interpreted parts, even in the same program.  And I think OCaml also does a good job of combining the two approaches?</div><br/></div></div></div></div><div id="41654722" class="c"><input type="checkbox" id="c-41654722" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#41648456">parent</a><span>|</span><a href="#41651564">prev</a><span>|</span><a href="#41649413">next</a><span>|</span><label class="collapse" for="c-41654722">[-]</label><label class="expand" for="c-41654722">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, guile these days is often faster than chicken, even compiled (the csi interpreter is dog slow and not suitable for anything but interactive exploration). Chicken is just not a fast implementation.<p>Plus guile comes with a more comprehensive standard library; on the other hand, chicken&#x27;s package manager and available packages do make up for that.</div><br/></div></div><div id="41649413" class="c"><input type="checkbox" id="c-41649413" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41648456">parent</a><span>|</span><a href="#41654722">prev</a><span>|</span><a href="#41648841">next</a><span>|</span><label class="collapse" for="c-41649413">[-]</label><label class="expand" for="c-41649413">[3 more]</label></div><br/><div class="children"><div class="content">I switched from Guile to SBCL because I really like having things such as (declare (inline my-function)) and (declare (type Double-Float x y z)). Now if only it had case-lambda, named let, and a better deftype which can specify members of classes and&#x2F;or structs.</div><br/><div id="41655471" class="c"><input type="checkbox" id="c-41655471" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41649413">parent</a><span>|</span><a href="#41653526">next</a><span>|</span><label class="collapse" for="c-41655471">[-]</label><label class="expand" for="c-41655471">[1 more]</label></div><br/><div class="children"><div class="content">&gt;named let<p>Serapeum has you covered: <a href="https:&#x2F;&#x2F;github.com&#x2F;ruricolist&#x2F;serapeum&#x2F;blob&#x2F;master&#x2F;REFERENCE.md#nlet-name-rest-bindings-body-body">https:&#x2F;&#x2F;github.com&#x2F;ruricolist&#x2F;serapeum&#x2F;blob&#x2F;master&#x2F;REFERENCE...</a></div><br/></div></div><div id="41653526" class="c"><input type="checkbox" id="c-41653526" checked=""/><div class="controls bullet"><span class="by">dannyobrien</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41649413">parent</a><span>|</span><a href="#41655471">prev</a><span>|</span><a href="#41648841">next</a><span>|</span><label class="collapse" for="c-41653526">[-]</label><label class="expand" for="c-41653526">[1 more]</label></div><br/><div class="children"><div class="content">The language-hack of the &quot;the&quot; operator in Common Lisp, whereby  `(the fixnum (+ 5 7))` signals that the result of (+ 5 7) should be an integer is so ... <i>lispy</i>.</div><br/></div></div></div></div><div id="41648841" class="c"><input type="checkbox" id="c-41648841" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41648456">parent</a><span>|</span><a href="#41649413">prev</a><span>|</span><a href="#41651141">next</a><span>|</span><label class="collapse" for="c-41648841">[-]</label><label class="expand" for="c-41648841">[14 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Racket the &#x27;default&#x27; Scheme?  (Even though it&#x27;s no longer called Scheme.)</div><br/><div id="41649160" class="c"><input type="checkbox" id="c-41649160" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41648841">parent</a><span>|</span><a href="#41651022">next</a><span>|</span><label class="collapse" for="c-41649160">[-]</label><label class="expand" for="c-41649160">[4 more]</label></div><br/><div class="children"><div class="content">Extremely easy interop with native code is the main selling point of guile IMO. You just link in guile as a library and can have C code call scheme code and vice versa. Makes it great for any native program that needs an embedded scripting language (much like Lua). Does Racket support that use-case?</div><br/><div id="41653288" class="c"><input type="checkbox" id="c-41653288" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41649160">parent</a><span>|</span><a href="#41651022">next</a><span>|</span><label class="collapse" for="c-41653288">[-]</label><label class="expand" for="c-41653288">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t done FFI with Racket, but <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;foreign&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;foreign&#x2F;index.html</a> looks reasonably approachable?</div><br/><div id="41653317" class="c"><input type="checkbox" id="c-41653317" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41653288">parent</a><span>|</span><a href="#41651022">next</a><span>|</span><label class="collapse" for="c-41653317">[-]</label><label class="expand" for="c-41653317">[2 more]</label></div><br/><div class="children"><div class="content">That seems to let you call C functions from Racket, but I don&#x27;t see how it lets you embed Racket in a C program and call Racket functions from C. So it&#x27;s at best half a solution, unless I&#x27;m missing something.</div><br/><div id="41654043" class="c"><input type="checkbox" id="c-41654043" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41653317">parent</a><span>|</span><a href="#41651022">next</a><span>|</span><label class="collapse" for="c-41654043">[-]</label><label class="expand" for="c-41654043">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;inside&#x2F;cs-procs.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;inside&#x2F;cs-procs.html</a></div><br/></div></div></div></div></div></div></div></div><div id="41651022" class="c"><input type="checkbox" id="c-41651022" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41648841">parent</a><span>|</span><a href="#41649160">prev</a><span>|</span><a href="#41649438">next</a><span>|</span><label class="collapse" for="c-41651022">[-]</label><label class="expand" for="c-41651022">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s a real &#x27;default&#x27; Scheme, like Chez is probably the implementation which generates the fastest code, but if I&#x27;m not mistaken it only implements the R6RS spec, Guile is quite performant and supports both R6RS and R7RS Small, Chicken has a bunch of libraries (the &#x27;eggs&#x27;), but I think it&#x27;s R5RS (I may be wrong), and of course GNU&#x2F;MIT Scheme is what you want to follow along with MIT publications working in Scheme (like Structure and Interpretation of Computer Programs, Structure and Interpretation of Classical Mechanics, and The Art of the Propagator). There&#x27;s also Gauche, which I believe is the most conformant implementation to the various Colour Dockets for R7RS Large (Gerbil may also be fully conformant).</div><br/><div id="41654813" class="c"><input type="checkbox" id="c-41654813" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651022">parent</a><span>|</span><a href="#41651763">next</a><span>|</span><label class="collapse" for="c-41654813">[-]</label><label class="expand" for="c-41654813">[1 more]</label></div><br/><div class="children"><div class="content">For SICP, the best option is probably Racket with the sicp language package.<p>I can&#x27;t recommend MIT Scheme for anything these days; it&#x27;s just missing too many things that I feel are required for real work in Scheme, and has too many idiosyncrasies and quirks. Even using it to run a standalone program written in Scheme is a pain.</div><br/></div></div><div id="41651763" class="c"><input type="checkbox" id="c-41651763" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651022">parent</a><span>|</span><a href="#41654813">prev</a><span>|</span><a href="#41651709">next</a><span>|</span><label class="collapse" for="c-41651763">[-]</label><label class="expand" for="c-41651763">[1 more]</label></div><br/><div class="children"><div class="content">You can download a package to use R7RS Small in Racket. <a href="https:&#x2F;&#x2F;github.com&#x2F;lexi-lambda&#x2F;racket-r7rs">https:&#x2F;&#x2F;github.com&#x2F;lexi-lambda&#x2F;racket-r7rs</a></div><br/></div></div><div id="41651709" class="c"><input type="checkbox" id="c-41651709" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651022">parent</a><span>|</span><a href="#41651763">prev</a><span>|</span><a href="#41653323">next</a><span>|</span><label class="collapse" for="c-41651709">[-]</label><label class="expand" for="c-41651709">[2 more]</label></div><br/><div class="children"><div class="content">Racket is now built around Chez.</div><br/><div id="41655801" class="c"><input type="checkbox" id="c-41655801" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651709">parent</a><span>|</span><a href="#41653323">next</a><span>|</span><label class="collapse" for="c-41655801">[-]</label><label class="expand" for="c-41655801">[1 more]</label></div><br/><div class="children"><div class="content">Which was a great idea, bootstraped languages always takes the usual &quot;but you depend on XYZ&quot; that haters always bring into the discussion.<p>Additionally they allow to prove a point.<p>For example, is writing compilers systems programming or not?</div><br/></div></div></div></div><div id="41653323" class="c"><input type="checkbox" id="c-41653323" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41651022">parent</a><span>|</span><a href="#41651709">prev</a><span>|</span><a href="#41649438">next</a><span>|</span><label class="collapse" for="c-41653323">[-]</label><label class="expand" for="c-41653323">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the context!  It&#x27;s been a while since I did serious work in the Lisps.  (I&#x27;ve moved on to the ML family.)<p>&gt; [...] GNU&#x2F;MIT Scheme is what you want to follow along with MIT publications working in Scheme (like Structure and Interpretation of Computer Programs, Structure and Interpretation of Classical Mechanics, and The Art of the Propagator).<p>Definitely, though I suspect if you need a language that&#x27;s exactly what&#x27;s written in the text, you are probably missing the point?  At least for SICP, I haven&#x27;t looked into the others as closely.  (Part of) the point being learning wider concepts.<p>I almost feel like you get more out of the book, if you do the exercises in a mix of JavaScript and Python.  Not because those are better languages, just the opposite: because it forces you to understand the concepts well enough to translate them.</div><br/><div id="41655642" class="c"><input type="checkbox" id="c-41655642" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41653323">parent</a><span>|</span><a href="#41649438">next</a><span>|</span><label class="collapse" for="c-41655642">[-]</label><label class="expand" for="c-41655642">[1 more]</label></div><br/><div class="children"><div class="content">In SICM they frequently make use of a kind of implicit applicative lifting (I can&#x27;t remember what they call it) where you apply a vector-of-functions as if it were a function itself. In psuedo-Haskell:<p><pre><code>    lift :: Vec (a-&gt;b) -&gt; (a-&gt;Vec b)
    lift [] a = []
    lift f:fs = (f a):(lift fs $ a)
</code></pre>
so that you can write natural-looking multidimensional physics expressions like<p><pre><code>    ((fx fy fz) r)
</code></pre>
without having to invoke macros or restructure the expression to please the compiler. I dearly wish you could do this in another scheme but so far I haven&#x27;t found one. Iirc it&#x27;s required for using the magnificent `scmutils` package too.<p>For example, `guile-scmutils`[0] says:<p>&gt; Functionality not available in the port:<p>&gt; Scheme extension to allow applying vectors&#x2F;structures as procedures. For example rather than<p><pre><code>    1 ]=&gt; (pe ((up (literal-function &#x27;x) (literal-function &#x27;y)) &#x27;t))
    (up (x t) (y t))
</code></pre>
&gt; you must use<p><pre><code>    guile&gt; (pe ((lambda (t) (up ((literal-function &#x27;x) t) ((literal-function &#x27;y) t))) &#x27;t))
    (up (x t) (y t))
</code></pre>
[0] <a href="https:&#x2F;&#x2F;www.cs.rochester.edu&#x2F;~gildea&#x2F;guile-scmutils&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cs.rochester.edu&#x2F;~gildea&#x2F;guile-scmutils&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41649438" class="c"><input type="checkbox" id="c-41649438" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41648841">parent</a><span>|</span><a href="#41651022">prev</a><span>|</span><a href="#41649140">next</a><span>|</span><label class="collapse" for="c-41649438">[-]</label><label class="expand" for="c-41649438">[1 more]</label></div><br/><div class="children"><div class="content">At this point it&#x27;s a separate language from Scheme. I think Chez Scheme tends to be the &quot;default&quot; recommendation.</div><br/></div></div><div id="41649140" class="c"><input type="checkbox" id="c-41649140" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41648456">root</a><span>|</span><a href="#41648841">parent</a><span>|</span><a href="#41649438">prev</a><span>|</span><a href="#41651141">next</a><span>|</span><label class="collapse" for="c-41649140">[-]</label><label class="expand" for="c-41649140">[1 more]</label></div><br/><div class="children"><div class="content">No</div><br/></div></div></div></div></div></div><div id="41651141" class="c"><input type="checkbox" id="c-41651141" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41648456">prev</a><span>|</span><a href="#41647801">next</a><span>|</span><label class="collapse" for="c-41651141">[-]</label><label class="expand" for="c-41651141">[1 more]</label></div><br/><div class="children"><div class="content">I prefer Common Lisp with SBCL and Lem, but this is good too.<p>On SICP, Guile badly needs a module for the picture language from the book (and srfi-203 + srfi-216).</div><br/></div></div><div id="41647801" class="c"><input type="checkbox" id="c-41647801" checked=""/><div class="controls bullet"><span class="by">orliesaurus</span><span>|</span><a href="#41651141">prev</a><span>|</span><a href="#41649532">next</a><span>|</span><label class="collapse" for="c-41647801">[-]</label><label class="expand" for="c-41647801">[10 more]</label></div><br/><div class="children"><div class="content">As soon as I saw the title, I thought of the streetfighter character, but this was actually an interesting read on a programming language, I had never heard of before</div><br/><div id="41648020" class="c"><input type="checkbox" id="c-41648020" checked=""/><div class="controls bullet"><span class="by">abound</span><span>|</span><a href="#41647801">parent</a><span>|</span><a href="#41648298">next</a><span>|</span><label class="collapse" for="c-41648020">[-]</label><label class="expand" for="c-41648020">[2 more]</label></div><br/><div class="children"><div class="content">A prominent use of Guile is as the configuration language for Guix, GNU&#x27;s version of Nix</div><br/><div id="41649672" class="c"><input type="checkbox" id="c-41649672" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#41647801">root</a><span>|</span><a href="#41648020">parent</a><span>|</span><a href="#41648298">next</a><span>|</span><label class="collapse" for="c-41649672">[-]</label><label class="expand" for="c-41649672">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the official GNU extension language, so it&#x27;s fairly widely used in the GNU world I think.<p>It&#x27;s also the language of the init system&#x2F;service manager on GuixSD (the full OS distribution based on Guix), GNU Shepherd (a.k.a. dmd), and IIRC their initrd runs a Guile program instead of a shell script.</div><br/></div></div></div></div><div id="41648298" class="c"><input type="checkbox" id="c-41648298" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41647801">parent</a><span>|</span><a href="#41648020">prev</a><span>|</span><a href="#41648107">next</a><span>|</span><label class="collapse" for="c-41648298">[-]</label><label class="expand" for="c-41648298">[6 more]</label></div><br/><div class="children"><div class="content">The slogan I&#x27;ve proposed for the language is &quot;Guile goes with everything.&quot; Because Guile was designed from the outset to run embedded or standalone, and to transpile other extension languages to Scheme or a Scheme-compatible representation, I think that fitting. See: <a href="https:&#x2F;&#x2F;knowyourmeme.com&#x2F;memes&#x2F;guiles-theme-goes-with-everything" rel="nofollow">https:&#x2F;&#x2F;knowyourmeme.com&#x2F;memes&#x2F;guiles-theme-goes-with-everyt...</a></div><br/><div id="41649444" class="c"><input type="checkbox" id="c-41649444" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41647801">root</a><span>|</span><a href="#41648298">parent</a><span>|</span><a href="#41652229">next</a><span>|</span><label class="collapse" for="c-41649444">[-]</label><label class="expand" for="c-41649444">[3 more]</label></div><br/><div class="children"><div class="content">I think the Guile community of yore would have no idea what Street Fighter was but now we should embrace it as long as Capcom doesn&#x27;t get mad.</div><br/><div id="41655906" class="c"><input type="checkbox" id="c-41655906" checked=""/><div class="controls bullet"><span class="by">masfoobar</span><span>|</span><a href="#41647801">root</a><span>|</span><a href="#41649444">parent</a><span>|</span><a href="#41652009">next</a><span>|</span><label class="collapse" for="c-41655906">[-]</label><label class="expand" for="c-41655906">[1 more]</label></div><br/><div class="children"><div class="content">Originally, it was called GEL (GNU Extension Language) but was later renamed to GUILE.<p><a href="https:&#x2F;&#x2F;wingolog.org&#x2F;archives&#x2F;2009&#x2F;01&#x2F;07&#x2F;a-brief-history-of-guile" rel="nofollow">https:&#x2F;&#x2F;wingolog.org&#x2F;archives&#x2F;2009&#x2F;01&#x2F;07&#x2F;a-brief-history-of-...</a><p>There was a forum where Tom Lord, the creator of GEL talked about the early history from his perspective. Unfortunately I cannot remember where it is. Sadly, Tom Lord passed away in 2022.</div><br/></div></div><div id="41652009" class="c"><input type="checkbox" id="c-41652009" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41647801">root</a><span>|</span><a href="#41649444">parent</a><span>|</span><a href="#41655906">prev</a><span>|</span><a href="#41652229">next</a><span>|</span><label class="collapse" for="c-41652009">[-]</label><label class="expand" for="c-41652009">[1 more]</label></div><br/><div class="children"><div class="content">The other Scheme environment I use regularly is Gambit. So, reppin both Marvel and Capcom.</div><br/></div></div></div></div><div id="41652229" class="c"><input type="checkbox" id="c-41652229" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#41647801">root</a><span>|</span><a href="#41648298">parent</a><span>|</span><a href="#41649444">prev</a><span>|</span><a href="#41648107">next</a><span>|</span><label class="collapse" for="c-41652229">[-]</label><label class="expand" for="c-41652229">[2 more]</label></div><br/><div class="children"><div class="content">Should it be &quot;Guile Scheme goes with everything&quot; for the rhyme?</div><br/><div id="41652976" class="c"><input type="checkbox" id="c-41652976" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41647801">root</a><span>|</span><a href="#41652229">parent</a><span>|</span><a href="#41648107">next</a><span>|</span><label class="collapse" for="c-41652976">[-]</label><label class="expand" for="c-41652976">[1 more]</label></div><br/><div class="children"><div class="content">Even better.</div><br/></div></div></div></div></div></div></div></div><div id="41649532" class="c"><input type="checkbox" id="c-41649532" checked=""/><div class="controls bullet"><span class="by">exitb</span><span>|</span><a href="#41647801">prev</a><span>|</span><label class="collapse" for="c-41649532">[-]</label><label class="expand" for="c-41649532">[1 more]</label></div><br/><div class="children"><div class="content">You probably shouldnât do those things. The point of a high level language is to not have to think about such details. If you canât get the performance you need, you should use a different tool, instead of trying to circumvent implicit limitations.</div><br/></div></div></div></div></div></div></div></body></html>