<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699434060476" as="style"/><link rel="stylesheet" href="styles.css?v=1699434060476"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://sebmestre.blogspot.com/2023/11/en-writing-compiler-is-surprisingly.html">Writing a Compiler is Surprisingly Easy (part 1)</a> <span class="domain">(<a href="http://sebmestre.blogspot.com">sebmestre.blogspot.com</a>)</span></div><div class="subtext"><span>mmphosis</span> | <span>89 comments</span></div><br/><div><div id="38184993" class="c"><input type="checkbox" id="c-38184993" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38186062">next</a><span>|</span><label class="collapse" for="c-38184993">[-]</label><label class="expand" for="c-38184993">[10 more]</label></div><br/><div class="children"><div class="content">Writing a compiler is not too difficult.  Most of the techniques and procedures are well researched and documented.  The best thing is that you can pick the parts that are useful and stop instead of implementing the full blown end to end pipeline.<p>Recently in an app, instead of supporting the bare minimum I wanted to support a bit more sophisticated search expression, like embedded commands and compounded conditional expression.  I just hand-rolled the lexical tokenizer and the parser, and stopped without going the full mile.  The tokenizer used simple regex to break up the terms and tagged them with token types.  Came up with a grammar for the mini language.  The parser used the standard recursive descent parsing technique on the grammar production.  It&#x27;s simple to handle errors and do auto-completion of the missing syntax because the parser knew what to expect at the point of error and could fill in the default nodes in the tree as needed.  The generated AST was enough to implement the search tree and the embedded commands.  The whole thing was only couple files and done in couple days, but it&#x27;s very useful for the app.</div><br/><div id="38186166" class="c"><input type="checkbox" id="c-38186166" checked=""/><div class="controls bullet"><span class="by">13of40</span><span>|</span><a href="#38184993">parent</a><span>|</span><a href="#38187065">next</a><span>|</span><label class="collapse" for="c-38186166">[-]</label><label class="expand" for="c-38186166">[7 more]</label></div><br/><div class="children"><div class="content">I wrote a parser&#x2F;interpreter for VBA a few years back, and even though the core concepts were straightforward, conforming to a language that had been in development for decades turned out to be brain-wreckingly tedious.  One of the biggest parts of it was a block of thousands(?) of conditional statements to figure out the result type of every combination of type+operator+type.  At the end of the ordeal, though, I threw the engine into a test app that looked like GWBASIC, and got a little nostalgia kick from being able to run BASIC like it was 1983.</div><br/><div id="38186865" class="c"><input type="checkbox" id="c-38186865" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38186166">parent</a><span>|</span><a href="#38186940">next</a><span>|</span><label class="collapse" for="c-38186865">[-]</label><label class="expand" for="c-38186865">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s amazing to implement a full interpreter for VBA.<p>I would imagine a lot of the type resolution are redundant.  E.g. +, -, *, and &#x2F; would have the same type resolution for numbers.  Those can reuse the same type resolver.  May be + also work on string.  Then call the string type resolver on it in addition to see if it can be resolved.<p>Anyway, kudos for the amazing work.</div><br/></div></div><div id="38186940" class="c"><input type="checkbox" id="c-38186940" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38186166">parent</a><span>|</span><a href="#38186865">prev</a><span>|</span><a href="#38186608">next</a><span>|</span><label class="collapse" for="c-38186940">[-]</label><label class="expand" for="c-38186940">[1 more]</label></div><br/><div class="children"><div class="content"><i>One of the biggest parts of it was a block of thousands(?) of conditional statements to figure out the result type of every combination of type+operator+type</i><p>This is not something uncommon for a dynamically typed language; I think the simplest approach is a multidimensional array lookup.</div><br/></div></div><div id="38186608" class="c"><input type="checkbox" id="c-38186608" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38186166">parent</a><span>|</span><a href="#38186940">prev</a><span>|</span><a href="#38186424">next</a><span>|</span><label class="collapse" for="c-38186608">[-]</label><label class="expand" for="c-38186608">[1 more]</label></div><br/><div class="children"><div class="content">Did you need thousands of conditionals? Couldn&#x27;t you map types and operators into an efficient representation for a single lookup?!</div><br/></div></div><div id="38186424" class="c"><input type="checkbox" id="c-38186424" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38186166">parent</a><span>|</span><a href="#38186608">prev</a><span>|</span><a href="#38187065">next</a><span>|</span><label class="collapse" for="c-38186424">[-]</label><label class="expand" for="c-38186424">[3 more]</label></div><br/><div class="children"><div class="content">That and there were never official grammars published for any version of any basic from Microsoft afaik</div><br/><div id="38187009" class="c"><input type="checkbox" id="c-38187009" checked=""/><div class="controls bullet"><span class="by">makeset</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38186424">parent</a><span>|</span><a href="#38187065">next</a><span>|</span><label class="collapse" for="c-38187009">[-]</label><label class="expand" for="c-38187009">[2 more]</label></div><br/><div class="children"><div class="content">I doubt they ever existed.<p>I had to write a VBScript parser some 25 years ago (to syntax-check ASP files before they would crash live) and to get it to parse valid syntax correctly, I ended up with a messy patchwork of logic which was also letting through some really pathological edge cases. While trying to fix it, to my utter delight, I found that Microsoft’s parsers also allowed the exact same cases which looked nothing like valid code otherwise. I don’t recall specific examples anymore, but they were far from obvious without looking at the parser code, and I made and won bets with other programmers on whether those snippets would throw syntax errors or not.</div><br/><div id="38187225" class="c"><input type="checkbox" id="c-38187225" checked=""/><div class="controls bullet"><span class="by">jakobson14</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38187009">parent</a><span>|</span><a href="#38187065">next</a><span>|</span><label class="collapse" for="c-38187225">[-]</label><label class="expand" for="c-38187225">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I doubt they ever existed.<p>Probably right, since Microsoft&#x27;s BASIC interpreter is probably derived from the one that Bill Gates wrote as a teenage slacker. He wrote it, tried to sell it at the homebrew computer club, and then threw a hissy fit when people kept copying his paper tapes for their friends. Thus, Microsoft was born. (He got lucky later when Microsoft were chosen by IBM to develop a DOS, then bought a working DOS from somebody else. The rest as they say is history)</div><br/></div></div></div></div></div></div></div></div><div id="38187065" class="c"><input type="checkbox" id="c-38187065" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38184993">parent</a><span>|</span><a href="#38186166">prev</a><span>|</span><a href="#38186062">next</a><span>|</span><label class="collapse" for="c-38187065">[-]</label><label class="expand" for="c-38187065">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Writing a compiler is not too difficult.<p>Wait till you&#x27;re faced with the endless .h files with their inevitable use of nutburger undocumented C extensions.</div><br/><div id="38187463" class="c"><input type="checkbox" id="c-38187463" checked=""/><div class="controls bullet"><span class="by">habibur</span><span>|</span><a href="#38184993">root</a><span>|</span><a href="#38187065">parent</a><span>|</span><a href="#38186062">next</a><span>|</span><label class="collapse" for="c-38187463">[-]</label><label class="expand" for="c-38187463">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t write a compiler for C.
Write compilers that convert your sources to C.<p>You create the header files.</div><br/></div></div></div></div></div></div><div id="38186062" class="c"><input type="checkbox" id="c-38186062" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38184993">prev</a><span>|</span><a href="#38187932">next</a><span>|</span><label class="collapse" for="c-38186062">[-]</label><label class="expand" for="c-38186062">[2 more]</label></div><br/><div class="children"><div class="content"><i>We will store that intermediate value in the stack, and read it back after the right term is done computing. If we take care that the code we generate for the right term doesn&#x27;t write into the same stack slot, then we can be sure that the value will be preserved.</i><p>There are push and pop instructions which are perfectly suited to this nested value use. In the past, lamenting how many compilers don&#x27;t seem to realise that (and the fact that push&#x2F;pop are specially optimised on x86 via hardware known as the stack engine), I wrote a piece of a code generator with similar capabilities to the one in this article as a proof-of-concept, and with the addition of some trivial (rotating FIFO-like) register allocation, was able to generate surprisingly compact and fast code that looks like it could&#x27;ve been written by a human Asm programmer.<p>I believe Crenshaw&#x27;s famous compiler tutorial also makes the same simplification, and it&#x27;s also a powerful generalisation since it means that arbitrarily deep nested expressions can be compiled, as long as there is sufficient stack space.</div><br/><div id="38186812" class="c"><input type="checkbox" id="c-38186812" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38186062">parent</a><span>|</span><a href="#38187932">next</a><span>|</span><label class="collapse" for="c-38186812">[-]</label><label class="expand" for="c-38186812">[1 more]</label></div><br/><div class="children"><div class="content">crenshaw mostly just emits pushes and pops; he recommends a simpler version of that rotating fifo technique (just spilling deeply nested values onto the stack so you get a performance cliff, instead of pushing old values out of the fifo) but doesn&#x27;t actually show it<p>in ur-scheme i just pushed and popped, getting performance much less terrible than i expected, but still probably a third of the performance the rotating fifo register allocator would give</div><br/></div></div></div></div><div id="38187932" class="c"><input type="checkbox" id="c-38187932" checked=""/><div class="controls bullet"><span class="by">rossant</span><span>|</span><a href="#38186062">prev</a><span>|</span><a href="#38184480">next</a><span>|</span><label class="collapse" for="c-38187932">[-]</label><label class="expand" for="c-38187932">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Writing a Compiler is Surprisingly Easy (part 1&#x2F;72)&quot;<p>Joke aside, great work up! Thank you.</div><br/></div></div><div id="38184480" class="c"><input type="checkbox" id="c-38184480" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#38187932">prev</a><span>|</span><a href="#38185708">next</a><span>|</span><label class="collapse" for="c-38184480">[-]</label><label class="expand" for="c-38184480">[8 more]</label></div><br/><div class="children"><div class="content">Writing a toy compiler for one sane input language and one target platform is indeed surprisingly easy, and very educational.  I had to do this back in the 90&#x27;s for C when the O&#x2F;S SW group I worked for needed to start work on a UNIX port to a new proprietary architecture (simulator) and the company&#x27;s compiler group wasn&#x27;t getting anything started any time soon.  It took maybe 3-4 KLOC to get a boring old recursive descent parser and simple code generator working well enough to compile a minimal kernel configuration and pass a compiler self-replication test.  The most interesting bit was actually the preprocessor.</div><br/><div id="38185525" class="c"><input type="checkbox" id="c-38185525" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#38184480">parent</a><span>|</span><a href="#38185708">next</a><span>|</span><label class="collapse" for="c-38185525">[-]</label><label class="expand" for="c-38185525">[7 more]</label></div><br/><div class="children"><div class="content">Writing a compiler was part of the undergraduate compsci curriculum back where I did it.  I still have vague memories of ancient tools like Flex and Bison (and I’m puzzled that the author seems to be hand-rolling code rather than use existing tooling).</div><br/><div id="38185683" class="c"><input type="checkbox" id="c-38185683" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#38184480">root</a><span>|</span><a href="#38185525">parent</a><span>|</span><a href="#38185733">next</a><span>|</span><label class="collapse" for="c-38185683">[-]</label><label class="expand" for="c-38185683">[5 more]</label></div><br/><div class="children"><div class="content">AFAIK nowadays it is more common to write a recursive descent parser to build whatever structure you want to work with (if not use the parsing directly) than rely on Flex&#x2F;Bison.<p>Personally i&#x27;ve written so many parsers over the years that the code for writing one &quot;flows&quot; naturally and i feel like Flex&#x2F;Bison would introduce complexity and dependencies for no gain.</div><br/><div id="38187678" class="c"><input type="checkbox" id="c-38187678" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38184480">root</a><span>|</span><a href="#38185683">parent</a><span>|</span><a href="#38187076">next</a><span>|</span><label class="collapse" for="c-38187678">[-]</label><label class="expand" for="c-38187678">[1 more]</label></div><br/><div class="children"><div class="content">I keep writing parser generators because I hate writing parsers manually, but keep returning to writing parsers manually because making a parser generator survive the first few meetings with reality without the pretty grammar turning into a hairy beast (when e.g. adding error recovery or trying to wrangle it into producing the trees you&#x27;d prefer rather than what fits the structure of the grammar) remains elusive.<p>Ironically I think the sheer number of parser generators reflects our collective failure to make a good one more so than their amazing utility (sure, some projects so actually use some).<p>I&#x27;m knee deep in her another parser generator these days, and I&#x27;m mildly hopeful (then that&#x27;s always the case at the outset) of taking an augmented BNF variant and producing something DFA like that retains links from each state to higher level rules to retain enough information to backtrack to a reasonable place to both report errors from and&#x2F;or resume parsing after an error.<p>I doubt the overall approach is novel in any way, and I suspect I&#x27;ll be back to hand rolling parsers soon enough, but who knows, I might end up with some worthwhile reusable components from it...</div><br/></div></div><div id="38187076" class="c"><input type="checkbox" id="c-38187076" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#38184480">root</a><span>|</span><a href="#38185683">parent</a><span>|</span><a href="#38187678">prev</a><span>|</span><a href="#38186772">next</a><span>|</span><label class="collapse" for="c-38187076">[-]</label><label class="expand" for="c-38187076">[1 more]</label></div><br/><div class="children"><div class="content">There is also the ANTLR parser generator which generates a top-down parser. It&#x27;s nice to write in a grammar. Still, almost all production lexers and parsers are hand written.<p><a href="https:&#x2F;&#x2F;www.antlr.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.antlr.org</a></div><br/></div></div><div id="38186772" class="c"><input type="checkbox" id="c-38186772" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38184480">root</a><span>|</span><a href="#38185683">parent</a><span>|</span><a href="#38187076">prev</a><span>|</span><a href="#38185733">next</a><span>|</span><label class="collapse" for="c-38186772">[-]</label><label class="expand" for="c-38186772">[2 more]</label></div><br/><div class="children"><div class="content">it introduces knowing where the ambiguities are in your grammar and eliminates large classes of parsing bugs<p>it&#x27;s also dramatically easier for other people to understand</div><br/><div id="38187106" class="c"><input type="checkbox" id="c-38187106" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38184480">root</a><span>|</span><a href="#38186772">parent</a><span>|</span><a href="#38185733">next</a><span>|</span><label class="collapse" for="c-38187106">[-]</label><label class="expand" for="c-38187106">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately `%expect` is so easy to reach even in yacc.</div><br/></div></div></div></div></div></div><div id="38185733" class="c"><input type="checkbox" id="c-38185733" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38184480">root</a><span>|</span><a href="#38185525">parent</a><span>|</span><a href="#38185683">prev</a><span>|</span><a href="#38185708">next</a><span>|</span><label class="collapse" for="c-38185733">[-]</label><label class="expand" for="c-38185733">[1 more]</label></div><br/><div class="children"><div class="content">Undergrad was when I learned about the subject.  It was done with tools like Lex and Yacc, along with the Dragon book.  These tools are fine but only work in C.  Yacc&#x2F;Bison generate LALR bottom up parsers, which can be difficult to debug and use.  Also it&#x27;s difficult to implement error recovery.  If you want to do it in another language or want to have more control, hand rolling the lexer and parser is not too bad.</div><br/></div></div></div></div></div></div><div id="38185708" class="c"><input type="checkbox" id="c-38185708" checked=""/><div class="controls bullet"><span class="by">RagnarD</span><span>|</span><a href="#38184480">prev</a><span>|</span><a href="#38187716">next</a><span>|</span><label class="collapse" for="c-38185708">[-]</label><label class="expand" for="c-38185708">[7 more]</label></div><br/><div class="children"><div class="content">Playing chess is easy.
Playing <i>good</i> chess - not so much.
Playing <i>world class</i> chess - good luck.</div><br/><div id="38186558" class="c"><input type="checkbox" id="c-38186558" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#38185708">parent</a><span>|</span><a href="#38186945">next</a><span>|</span><label class="collapse" for="c-38186558">[-]</label><label class="expand" for="c-38186558">[2 more]</label></div><br/><div class="children"><div class="content">But a lot of programmers think compilers are magic. Maybe because they read about stuff like parser generators, register allocators, optimizations, etc., that are not strictly necessary. It&#x27;s empowering to remind people that a seemingly hard task is within their reach.</div><br/><div id="38187477" class="c"><input type="checkbox" id="c-38187477" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#38185708">root</a><span>|</span><a href="#38186558">parent</a><span>|</span><a href="#38186945">next</a><span>|</span><label class="collapse" for="c-38187477">[-]</label><label class="expand" for="c-38187477">[1 more]</label></div><br/><div class="children"><div class="content">People always think that what they dont understand is magic, and when they do understand it they think its simple.<p>For example: React, Operating Systems, AI, CSS and assembly.</div><br/></div></div></div></div><div id="38186945" class="c"><input type="checkbox" id="c-38186945" checked=""/><div class="controls bullet"><span class="by">RagnarD</span><span>|</span><a href="#38185708">parent</a><span>|</span><a href="#38186558">prev</a><span>|</span><a href="#38186520">next</a><span>|</span><label class="collapse" for="c-38186945">[-]</label><label class="expand" for="c-38186945">[3 more]</label></div><br/><div class="children"><div class="content">To elaborate, I&#x27;ve written a number of compilers in years past. I highly recommend it as an exercise in learning about parsing, code emission, etc. Anything that gets a developer closer to understanding that process, rather than a mystery black box, is a very good thing. So I&#x27;m not trying to be a downer, just noting that it can rapidly become an extremely complex task to make an excellent compiler which includes end user expected code optimizations, informative error messages, syntax error recovery, etc.</div><br/><div id="38187809" class="c"><input type="checkbox" id="c-38187809" checked=""/><div class="controls bullet"><span class="by">khazhoux</span><span>|</span><a href="#38185708">root</a><span>|</span><a href="#38186945">parent</a><span>|</span><a href="#38187092">prev</a><span>|</span><a href="#38186520">next</a><span>|</span><label class="collapse" for="c-38187809">[-]</label><label class="expand" for="c-38187809">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure anyone would think otherwise, though.</div><br/></div></div></div></div><div id="38186520" class="c"><input type="checkbox" id="c-38186520" checked=""/><div class="controls bullet"><span class="by">atan2</span><span>|</span><a href="#38185708">parent</a><span>|</span><a href="#38186945">prev</a><span>|</span><a href="#38187716">next</a><span>|</span><label class="collapse" for="c-38186520">[-]</label><label class="expand" for="c-38186520">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes people just want to learn how to play chess, and that&#x27;s ok.</div><br/></div></div></div></div><div id="38187716" class="c"><input type="checkbox" id="c-38187716" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38185708">prev</a><span>|</span><a href="#38185022">next</a><span>|</span><label class="collapse" for="c-38187716">[-]</label><label class="expand" for="c-38187716">[4 more]</label></div><br/><div class="children"><div class="content">Wirth&#x27;s classic recursive descent Pascal compiler in his 1976 book <i>Algorithms + Data Structures = Programs</i> is a basic compiler for a somewhat useful language.
That&#x27;s kind of dated. What&#x27;s a modern equivalent?</div><br/><div id="38187722" class="c"><input type="checkbox" id="c-38187722" checked=""/><div class="controls bullet"><span class="by">bartekpacia</span><span>|</span><a href="#38187716">parent</a><span>|</span><a href="#38185022">next</a><span>|</span><label class="collapse" for="c-38187722">[-]</label><label class="expand" for="c-38187722">[3 more]</label></div><br/><div class="children"><div class="content">Crafting Interpreters?</div><br/><div id="38187981" class="c"><input type="checkbox" id="c-38187981" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#38187716">root</a><span>|</span><a href="#38187722">parent</a><span>|</span><a href="#38185022">next</a><span>|</span><label class="collapse" for="c-38187981">[-]</label><label class="expand" for="c-38187981">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that crafting interpreters is becoming dated as well. There are modern alternatives that could make the process a lot more streamline. Would love a rewrite!</div><br/><div id="38188072" class="c"><input type="checkbox" id="c-38188072" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#38187716">root</a><span>|</span><a href="#38187981">parent</a><span>|</span><a href="#38185022">next</a><span>|</span><label class="collapse" for="c-38188072">[-]</label><label class="expand" for="c-38188072">[1 more]</label></div><br/><div class="children"><div class="content">Could you expand on what alternatives you prefer? I&#x27;m not sure what is dated about Crafting Interpreters (but I&#x27;m also not following the latest developments in the compiler space).<p>Thorston Ball&#x27;s Compiler and Interpreter book series is the only other book on the subject I find widely recommend and modern.</div><br/></div></div></div></div></div></div></div></div><div id="38185022" class="c"><input type="checkbox" id="c-38185022" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#38187716">prev</a><span>|</span><a href="#38187822">next</a><span>|</span><label class="collapse" for="c-38185022">[-]</label><label class="expand" for="c-38185022">[3 more]</label></div><br/><div class="children"><div class="content">Yet it is more and more time consuming the closer you want to get to the real world compilers</div><br/><div id="38185249" class="c"><input type="checkbox" id="c-38185249" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#38185022">parent</a><span>|</span><a href="#38185958">next</a><span>|</span><label class="collapse" for="c-38185249">[-]</label><label class="expand" for="c-38185249">[1 more]</label></div><br/><div class="children"><div class="content">It gets harder when you try to deviate from the norm of “40 years of research and experience, and this has survived 40 years for a reason”</div><br/></div></div><div id="38185958" class="c"><input type="checkbox" id="c-38185958" checked=""/><div class="controls bullet"><span class="by">bachmeier</span><span>|</span><a href="#38185022">parent</a><span>|</span><a href="#38185249">prev</a><span>|</span><a href="#38187822">next</a><span>|</span><label class="collapse" for="c-38185958">[-]</label><label class="expand" for="c-38185958">[1 more]</label></div><br/><div class="children"><div class="content">The nice thing about real world compilers is that they already exist. You can write your own compiler for situations where you need to do other things. If you need performance, compile to a language with a high-performance compiler.</div><br/></div></div></div></div><div id="38187822" class="c"><input type="checkbox" id="c-38187822" checked=""/><div class="controls bullet"><span class="by">7373737373</span><span>|</span><a href="#38185022">prev</a><span>|</span><a href="#38186736">next</a><span>|</span><label class="collapse" for="c-38187822">[-]</label><label class="expand" for="c-38187822">[1 more]</label></div><br/><div class="children"><div class="content">One thing I haven&#x27;t seen yet is how a compiler would keep track of types and emit the corresponding assembly</div><br/></div></div><div id="38186736" class="c"><input type="checkbox" id="c-38186736" checked=""/><div class="controls bullet"><span class="by">sebastianmestre</span><span>|</span><a href="#38187822">prev</a><span>|</span><a href="#38186375">next</a><span>|</span><label class="collapse" for="c-38186736">[-]</label><label class="expand" for="c-38186736">[2 more]</label></div><br/><div class="children"><div class="content">Wow! My blog made the HN front page!<p>I&#x27;ve been lurking for a while but only now made an account :^)</div><br/><div id="38186757" class="c"><input type="checkbox" id="c-38186757" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38186736">parent</a><span>|</span><a href="#38186375">next</a><span>|</span><label class="collapse" for="c-38186757">[-]</label><label class="expand" for="c-38186757">[1 more]</label></div><br/><div class="children"><div class="content">thanks for writing it! i look forward to seeing future installments</div><br/></div></div></div></div><div id="38186375" class="c"><input type="checkbox" id="c-38186375" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38186736">prev</a><span>|</span><a href="#38184366">next</a><span>|</span><label class="collapse" for="c-38186375">[-]</label><label class="expand" for="c-38186375">[10 more]</label></div><br/><div class="children"><div class="content">I wish there were a standard cross platform assembler library in C for x86, ARM, and WASM. Because frankly writing an asm text generator and shelling out to GCC or NASM is really annoying, and it feels like something so foundational should just exist.<p>I get there&#x27;s yasm, and libnasm, and asmjit, and libgccjit, and llvm, etc but they&#x27;re all varying degrees of &quot;bad&quot; for the purposes of a simple code generator for someone that doesn&#x27;t want to dig through ARM and Intel&#x27;s developer docs.</div><br/><div id="38186466" class="c"><input type="checkbox" id="c-38186466" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#38186375">parent</a><span>|</span><a href="#38186953">next</a><span>|</span><label class="collapse" for="c-38186466">[-]</label><label class="expand" for="c-38186466">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I wish there were a standard cross platform assembler library in C for x86, ARM, and WASM. Because frankly writing an asm text generator and shelling out to GCC or NASM is really annoying, and it feels like something so foundational should just exist.<p>It does, it&#x27;s called C :-)<p>&gt; I get there&#x27;s yasm, and libnasm, and asmjit, and libgccjit, and llvm, etc but they&#x27;re all varying degrees of &quot;bad&quot; for the purposes of a simple code generator for someone that doesn&#x27;t want to dig through ARM and Intel&#x27;s developer docs.<p>This is only for language developers who aren&#x27;t writing in C, right? Because if you&#x27;re writing in C, what would you use this assembler for?<p>Anything a cross-platform assembler emits is going to be portable, so it&#x27;s only going to be as performant as C is, so why not just emit C?<p>Having a C library that emits C might be a nice thing to have - then all the other languages can emit &quot;code&quot; that is cross-platform.</div><br/><div id="38186919" class="c"><input type="checkbox" id="c-38186919" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38186375">root</a><span>|</span><a href="#38186466">parent</a><span>|</span><a href="#38186953">next</a><span>|</span><label class="collapse" for="c-38186919">[-]</label><label class="expand" for="c-38186919">[5 more]</label></div><br/><div class="children"><div class="content">C is not assembler nor is it close to assembler nor is it desirable to have a C compiler in your toolchain to compile something that needs assembler<p>For example, C has a calling convention. It has a notion of a stack and heap. Certain things like arbitrary control flow, threading, and process spawning cannot be expressed in C. It has a memory model that you must adhere to.<p>If you actually want to implement a programming language, C is not sufficient as a transpilation target except for mostly trivial designs.</div><br/><div id="38187150" class="c"><input type="checkbox" id="c-38187150" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#38186375">root</a><span>|</span><a href="#38186919">parent</a><span>|</span><a href="#38187011">next</a><span>|</span><label class="collapse" for="c-38187150">[-]</label><label class="expand" for="c-38187150">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For example, C has a calling convention. It has a notion of a stack and heap. Certain things like arbitrary control flow, threading, and process spawning cannot be expressed in C. It has a memory model that you must adhere to.<p>Yes, all trivially bypassed or worked-around if you&#x27;re emitting C. Considering the initial constraint was &quot;cross-platform&quot;:<p>1. Calling convention - what would be the point of a calling convention different to the rest of the system? You wouldn&#x27;t be able to do system calls, for one. And if you need a different calling convention within the language itself C will let you push elements onto a stack and jump to a different piece of code[1], optionally saving and restoring registers.<p>2. The notion of a stack and heap - what&#x27;s the alternative you have in mind when using assembler? Assemblers also have a notion of a stack and non-stack addresses, after all.<p>3. Arbitrary control flow - you can emit goto&#x27;s to your hearts content (see [1] below).<p>4. Threading - this is platform-specific by nature, but if you&#x27;re emitting C you can emit calls to the platform&#x27;s thread primitives (CreateThreadEx, pthread_create, etc) the same way you&#x27;d have to do if you were using an assembler. Nothing stops you from proving a wrapper for threads that your emitted C code calls (so that it works on multiple platforms).<p>5. Process-spawning - once again, this is platform-specific, so even in assembler you&#x27;re going to have to make a call to the platform&#x27;s CreateProcess&#x2F;posix_spawn&#x2F;exec functions. If you&#x27;re going to call a platform function from assembly, you may as well call it from C.<p>6. Memory model - I&#x27;ll give you this point, even though the memory model is not that much different from assembler. If you&#x27;re emitting C, you&#x27;re still free to allocate&#x2F;define a large array and use that memory in whatever way you wish.<p>&gt; If you actually want to implement a programming language, C is not sufficient as a transpilation target except for mostly trivial designs.<p>Actually, many languages with non-trivial and advanced features, such as Common Lisp, already have implementations that transpile to C. They implement the entire Common Lisp standard, and don&#x27;t seem to be missing any features even though they are emitting C and not assembler.<p>Anonymous functions? Done with emitted C.<p>Closures, continuations? Done with emitted C.<p>Garbage collection? Same.<p>What feature do you have in mind that cannot be implemented by emitting C[2], but can be implemented by emitting assembler[3]?<p>[1] Some constraints on the jumping exist, but emitting GCC-specific C let&#x27;s you do calculated expressions for the jump target - you don&#x27;t need to `goto` a constant address.<p>[2] I initially thought that something like Goroutines or async functions might be a candidate, but off the top of my head, I can think of at least one way to implement async functions and&#x2F;or go routines by emitting C. There&#x27;s probably more.<p>[3] I&#x27;m not being contentious, I&#x27;d really rather like to know - my own toy language (everyone has one) currently in the phase of &quot;I&#x27;m thinking really hard about what it should look like&quot; is going to be emitting C. I couldn&#x27;t find any feature for the language  that can&#x27;t be done by emitting C, so I really want to know what you have in mind.</div><br/><div id="38187761" class="c"><input type="checkbox" id="c-38187761" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38186375">root</a><span>|</span><a href="#38187150">parent</a><span>|</span><a href="#38187011">next</a><span>|</span><label class="collapse" for="c-38187761">[-]</label><label class="expand" for="c-38187761">[2 more]</label></div><br/><div class="children"><div class="content">Plenty of languages have language-internal calling conventions nothing like C, and usually for good reasons.<p>Some try to stay close to make passing the boundary easy, some are so different they need an expensive conversion step anyway and then there&#x27;s little point.<p>Sure, you can always map your requirement onto the standard calling convention <i>somehow</i>, but if you can&#x27;t directly call out or in anyway it&#x27;s a constraint it&#x27;s totally reasonable to not want to be forced into.<p>EDIT: Note that there&#x27;s nothing wrong with emitting C if you don&#x27;t have any compelling reasons not to. When we don&#x27;t it&#x27;s often for reasons such as wanting a simpler toolchain, wanting the environment to be self-hosted etc. that are tradeoffs that sometimes are frankly ideological (take that as you want - I don&#x27;t mean anything inherently negative with that other than when the authors ideology differs from mine ;) I like that there&#x27;s choice and that some deviates from the norms ), sometimes based on requirements that doesn&#x27;t really have to do with the language itself. I do agree with you that you <i>can</i> fit all languages onto C, and most languages <i>neatly</i> onto C.<p>One example where it has traditionally been painful without compiler extensions, though, is tail call elimination. You can still do it. Other fun times involve closures, but you can do that too (been there, done that, wrote a blog post years ago) even though it quickly gets ugly.<p>Often you end up wanting to demand a specific set of extensions.<p>Overall nothing <i>stops</i> you, but at some point it also doesn&#x27;t necessarily buy you all that much - you still need to do most of the hard bits.</div><br/><div id="38187831" class="c"><input type="checkbox" id="c-38187831" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#38186375">root</a><span>|</span><a href="#38187761">parent</a><span>|</span><a href="#38187011">next</a><span>|</span><label class="collapse" for="c-38187831">[-]</label><label class="expand" for="c-38187831">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sure, you can always map your requirement onto the standard calling convention somehow, but if you can&#x27;t directly call out or in anyway it&#x27;s a constraint it&#x27;s totally reasonable to not want to be forced into.<p>I get that, but what I don&#x27;t get is what about C makes it harder to define your own calling convention than defining it in an assembler language.<p>In the context of this thread, OP wants a portable assembler. Implementing a custom calling convention by emitting <i>any</i> assembly language is bound to be more work than implementing a custom calling convention by emitting C.<p>Maybe the situation regarding floating point registers when passing floating point values? That&#x27;s about the only thing I can think of that makes it harder to emit C code that implements a custom calling convention than doing it in assembler, but even for that I can think of workarounds, just so that other high-level constructs can be used.</div><br/></div></div></div></div></div></div><div id="38187011" class="c"><input type="checkbox" id="c-38187011" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38186375">root</a><span>|</span><a href="#38186919">parent</a><span>|</span><a href="#38187150">prev</a><span>|</span><a href="#38186953">next</a><span>|</span><label class="collapse" for="c-38187011">[-]</label><label class="expand" for="c-38187011">[1 more]</label></div><br/><div class="children"><div class="content">works pretty well most of the time; chicken scheme even compiles call&#x2F;cc to c</div><br/></div></div></div></div></div></div><div id="38186953" class="c"><input type="checkbox" id="c-38186953" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38186375">parent</a><span>|</span><a href="#38186466">prev</a><span>|</span><a href="#38187254">next</a><span>|</span><label class="collapse" for="c-38186953">[-]</label><label class="expand" for="c-38186953">[2 more]</label></div><br/><div class="children"><div class="content">You can generate the opcodes directly if you want to avoid having a separate assembler.<p>AFAIK MSVC does that unless you tell it to generate Asm output, whereas GCC always goes through the separate assembler route.</div><br/></div></div><div id="38187254" class="c"><input type="checkbox" id="c-38187254" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38186375">parent</a><span>|</span><a href="#38186953">prev</a><span>|</span><a href="#38184366">next</a><span>|</span><label class="collapse" for="c-38187254">[-]</label><label class="expand" for="c-38187254">[1 more]</label></div><br/><div class="children"><div class="content">One way would be to target and generate LLVM IR.<p>You get multiple platforms for free if I&#x27;m not wrong.</div><br/></div></div></div></div><div id="38184366" class="c"><input type="checkbox" id="c-38184366" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38186375">prev</a><span>|</span><a href="#38185646">next</a><span>|</span><label class="collapse" for="c-38184366">[-]</label><label class="expand" for="c-38184366">[5 more]</label></div><br/><div class="children"><div class="content">a problem that a lot of these series run into is that the author runs out of steam before they finish writing them.  crenshaw&#x27;s otherwise excellent series suffers from this, for example<p>so far the author of this one has only written the first chapter<p>i&#x27;ve written a few didactic compilers that are complete enough to compile themselves, though not complete enough to compile anything else; these may be of more interest to someone who&#x27;s looking for how to make writing a compiler surprisingly easy, though they do lack the extensive explanatory text in the linked blog post<p>- <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;urscheme" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;urscheme</a> (from a subset of scheme to at&amp;t-syntax i386 assembly, 1553 lines of code)<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kragen&#x2F;stoneknifeforth">https:&#x2F;&#x2F;github.com&#x2F;kragen&#x2F;stoneknifeforth</a> (from a forth-like language to an i386 linux elf executable, 132 lines of code)<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kragen&#x2F;peg-bootstrap&#x2F;blob&#x2F;master&#x2F;peg.md">https:&#x2F;&#x2F;github.com&#x2F;kragen&#x2F;peg-bootstrap&#x2F;blob&#x2F;master&#x2F;peg.md</a> (from a peg grammar with semantic actions to javascript, 66 lines of code)<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kragen&#x2F;peg-bootstrap&#x2F;blob&#x2F;master&#x2F;handaxeweb.md">https:&#x2F;&#x2F;github.com&#x2F;kragen&#x2F;peg-bootstrap&#x2F;blob&#x2F;master&#x2F;handaxew...</a> (tangles a literate program in virtually any plain-text format, such as markdown, html, restructuredtext, or tex, into virtually any plain-text programming language, 208 lines of code; used to tangle both itself and the peg compiler compiler above)<p>- <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;meta5ix.m5" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;meta5ix.m5</a> (from meta5ix, a language for writing parsers derived from val schorre&#x27;s meta-ii, to meta5ix assembly, 18 lines of code; it is a top-down parsing language with limited backtracking, like pegs, but less expressive and implementable without heap allocation or the ability to backtrack past the beginning of a line; see <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;meta5ixrun.py" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;meta5ixrun.py</a> for an m5asm interpreter)<p>- <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;meta5ix2c2.m5" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;meta5ix2c2.m5</a> (from a slightly different variation of meta5ix to c, 133 lines of code)<p>most of these do take the same ast-free approach as the linked blog post and crenshaw, just emitting code as they finish parsing a production (or, in the case of stoneknifeforth, a token), but ur-scheme in particular does not; it uses scheme s-expressions as its syntax tree, because some kind of syntax tree is necessary to be able to allocate some local variables on the stack while also supporting closures.  peg-bootstrap can certainly handle code that builds an ast with its semantic actions, but its implementation of itself just glues together snippets of javascript text<p>also worth mentioning in this connection:<p>- darius bacon&#x27;s work, especially parson (for example, <a href="https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;parson&#x2F;blob&#x2F;master&#x2F;eg_calc_compile.py">https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;parson&#x2F;blob&#x2F;master&#x2F;eg_calc_compile...</a>)<p>- the oberon compiler in wirth and gutknecht&#x27;s oberon book<p>- the later chapters of sicp</div><br/><div id="38185155" class="c"><input type="checkbox" id="c-38185155" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38184366">parent</a><span>|</span><a href="#38185652">next</a><span>|</span><label class="collapse" for="c-38185155">[-]</label><label class="expand" for="c-38185155">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the author runs out of steam before they finish<p>One approach is to finish the whole compiler first and then to split it up for presentation, but I imagine most writers don&#x27;t want to do that.</div><br/></div></div><div id="38186780" class="c"><input type="checkbox" id="c-38186780" checked=""/><div class="controls bullet"><span class="by">whitten</span><span>|</span><a href="#38184366">parent</a><span>|</span><a href="#38185652">prev</a><span>|</span><a href="#38185646">next</a><span>|</span><label class="collapse" for="c-38186780">[-]</label><label class="expand" for="c-38186780">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for your hard work.</div><br/><div id="38186822" class="c"><input type="checkbox" id="c-38186822" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38184366">root</a><span>|</span><a href="#38186780">parent</a><span>|</span><a href="#38185646">next</a><span>|</span><label class="collapse" for="c-38186822">[-]</label><label class="expand" for="c-38186822">[1 more]</label></div><br/><div class="children"><div class="content">i hope you enjoy it</div><br/></div></div></div></div></div></div><div id="38184160" class="c"><input type="checkbox" id="c-38184160" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38185646">prev</a><span>|</span><a href="#38185330">next</a><span>|</span><label class="collapse" for="c-38184160">[-]</label><label class="expand" for="c-38184160">[1 more]</label></div><br/><div class="children"><div class="content">I like this approach, but why not take it one step further toward Turbo Pascal and generate the opcodes? ;-)</div><br/></div></div><div id="38187283" class="c"><input type="checkbox" id="c-38187283" checked=""/><div class="controls bullet"><span class="by">jojobas</span><span>|</span><a href="#38185330">prev</a><span>|</span><a href="#38184719">next</a><span>|</span><label class="collapse" for="c-38187283">[-]</label><label class="expand" for="c-38187283">[1 more]</label></div><br/><div class="children"><div class="content">The 2014 (doesn&#x27;t time fly) edition of the ICFP Programming Contest had participants make a Pacman brain, deliverable in SECD machine assembly, and ghost brains, deliverable in a simple microcontroller assembly.<p>Most teams, ours included, wrote 2 (probably rather crappy) compilers in 3 days.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ICFP_Programming_Contest" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ICFP_Programming_Contest</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SECD_machine" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SECD_machine</a></div><br/></div></div><div id="38184719" class="c"><input type="checkbox" id="c-38184719" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#38187283">prev</a><span>|</span><a href="#38183671">next</a><span>|</span><label class="collapse" for="c-38184719">[-]</label><label class="expand" for="c-38184719">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s... not a compiler. It&#x27;s a small part of a compiler backend (code generator).</div><br/></div></div><div id="38183671" class="c"><input type="checkbox" id="c-38183671" checked=""/><div class="controls bullet"><span class="by">t14n</span><span>|</span><a href="#38184719">prev</a><span>|</span><a href="#38184177">next</a><span>|</span><label class="collapse" for="c-38183671">[-]</label><label class="expand" for="c-38183671">[2 more]</label></div><br/><div class="children"><div class="content">I like the sentiment of the title, even if it gets people riled up. I&#x27;m fondly reminded of the introduction from Bob Nystrom&#x27;s _Crafting Interpreter_ [1]<p>&gt; This last reason is hard for me to admit, because it’s so close to my heart. Ever since I learned to program as a kid, I felt there was something magical about languages. When I first tapped out BASIC programs one key at a time I couldn’t conceive how BASIC itself was made.<p>&gt; Later, the mixture of awe and terror on my college friends’ faces when talking about their compilers class was enough to convince me language hackers were a different breed of human—some sort of wizards granted privileged access to arcane arts.<p>&gt; It’s a charming image, but it has a darker side. I didn’t feel like a wizard, so I was left thinking I lacked some inborn quality necessary to join the cabal. Though I’ve been fascinated by languages ever since I doodled made-up keywords in my school notebook, it took me decades to muster the courage to try to really learn them. That “magical” quality, that sense of exclusivity, excluded me.<p>&gt; And its practitioners don’t hesitate to play up this image. Two of the seminal texts on programming languages feature a dragon and a wizard on their covers.<p>&gt; When I did finally start cobbling together my own little interpreters, I quickly learned that, of course, there is no magic at all. It’s just code, and the people who hack on languages are just people.<p>&gt; There are a few techniques you don’t often encounter outside of languages, and some parts are a little difficult. But not more difficult than other obstacles you’ve overcome. My hope is that if you’ve felt intimidated by languages and this book helps you overcome that fear, maybe I’ll leave you just a tiny bit braver than you were before.<p>1: <a href="https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;</a></div><br/></div></div><div id="38184177" class="c"><input type="checkbox" id="c-38184177" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#38183671">prev</a><span>|</span><a href="#38183067">next</a><span>|</span><label class="collapse" for="c-38184177">[-]</label><label class="expand" for="c-38184177">[8 more]</label></div><br/><div class="children"><div class="content">Who needs a lexer, a parser, and an AST when you can just explicitly feed the tokens into a switch statement that completely falls through if it runs into something it doesn&#x27;t recognize? This is super easy!<p>Sorry, I am by no means a compiler expert, but spent enough years in study of them and taken enough stabs at writing my own that this take is hopelessly naive, and I really hope the author realizes it.</div><br/><div id="38184219" class="c"><input type="checkbox" id="c-38184219" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#38184177">parent</a><span>|</span><a href="#38184304">next</a><span>|</span><label class="collapse" for="c-38184219">[-]</label><label class="expand" for="c-38184219">[5 more]</label></div><br/><div class="children"><div class="content">I have written multiple compilers, from C-like interpreters to protobuffer like compilers over the years, all in production, some still.<p>Not doing a finite state machine for any stream interpretation is a huge mistake, just as much as it is outside of the compiler tokenisation, such as protocol decoders and even just parsing config files.<p>edit: There is a well known book with a dragon on it, but I first learnt from The Unix Programming Environment, by Brian W. Kernighan and Rob Pike. In just a few pages they clearly explain how to write an basic calculator like this, that generates intermediate code to run on a stack based interpreter. I started with this and expanded it to emit assembly for an arcane DG machine. I know that code generated ran for at least 20 years. Kinda surreal as nothing lasts that long usually.</div><br/><div id="38184341" class="c"><input type="checkbox" id="c-38184341" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38184177">root</a><span>|</span><a href="#38184219">parent</a><span>|</span><a href="#38185681">next</a><span>|</span><label class="collapse" for="c-38184341">[-]</label><label class="expand" for="c-38184341">[3 more]</label></div><br/><div class="children"><div class="content">Could you elaborate on what you mean by that? To me this looks like a code generation library, an approach I like because of its concreteness and adaptability (for example, if we changed it to emit opcodes then it could be used for dynamic code generation, which has many fun and interesting applications.)<p>Also this post is aimed at the author&#x27;s imagined teenage self. Does that change anything?</div><br/><div id="38184502" class="c"><input type="checkbox" id="c-38184502" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#38184177">root</a><span>|</span><a href="#38184341">parent</a><span>|</span><a href="#38185681">next</a><span>|</span><label class="collapse" for="c-38184502">[-]</label><label class="expand" for="c-38184502">[2 more]</label></div><br/><div class="children"><div class="content">When writing a compiler you want to first look at what you expect and when you get that, what to expect next. If that does not come, where do you go?<p>We call this a graph, but there is no need to confuse things with advanced terms.</div><br/><div id="38185083" class="c"><input type="checkbox" id="c-38185083" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38184177">root</a><span>|</span><a href="#38184502">parent</a><span>|</span><a href="#38185681">next</a><span>|</span><label class="collapse" for="c-38185083">[-]</label><label class="expand" for="c-38185083">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see any parsing in TFA - I think they are taking a bottom-up approach by starting with a code generation library before even thinking about parsing.<p>I like this approach because it produces something that generates usable code without worrying about things like parsing or high level language syntax, and you&#x27;ve basically written a DSL&#x2F;intermediate format which can be compiled by an existing C compiler.</div><br/></div></div></div></div></div></div><div id="38185681" class="c"><input type="checkbox" id="c-38185681" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#38184177">root</a><span>|</span><a href="#38184219">parent</a><span>|</span><a href="#38184341">prev</a><span>|</span><a href="#38184304">next</a><span>|</span><label class="collapse" for="c-38185681">[-]</label><label class="expand" for="c-38185681">[1 more]</label></div><br/><div class="children"><div class="content">thanks for the edit, i will endeavor to have a look at that source</div><br/></div></div></div></div><div id="38184304" class="c"><input type="checkbox" id="c-38184304" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#38184177">parent</a><span>|</span><a href="#38184219">prev</a><span>|</span><a href="#38184711">next</a><span>|</span><label class="collapse" for="c-38184304">[-]</label><label class="expand" for="c-38184304">[1 more]</label></div><br/><div class="children"><div class="content">Very true. Writing a compiler that works on correct code is often trivial. It’s not much harder than a minimal lisp or forth.<p>However, figuring out errors, adding type checking, etc now that’s hard.</div><br/></div></div></div></div><div id="38183067" class="c"><input type="checkbox" id="c-38183067" checked=""/><div class="controls bullet"><span class="by">mati365</span><span>|</span><a href="#38184177">prev</a><span>|</span><label class="collapse" for="c-38183067">[-]</label><label class="expand" for="c-38183067">[20 more]</label></div><br/><div class="children"><div class="content">* compiler without optimization phase</div><br/><div id="38184157" class="c"><input type="checkbox" id="c-38184157" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#38183067">parent</a><span>|</span><a href="#38183216">next</a><span>|</span><label class="collapse" for="c-38184157">[-]</label><label class="expand" for="c-38184157">[2 more]</label></div><br/><div class="children"><div class="content">Aka: a compiler.<p>A compiler is just `source -&gt; generate -&gt; target`. All the other fancy things are optional. IMPORTANT things, but don&#x27;t detract from calling it a &quot;compiler&quot;.<p>---<p>This is similar to anything else: A single `.html` served on `:80` is a website. A 2d, grayscale `pacman` is a videogame. `print(&quot;hello world&quot;)` is a program, etc.</div><br/><div id="38184398" class="c"><input type="checkbox" id="c-38184398" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38184157">parent</a><span>|</span><a href="#38183216">next</a><span>|</span><label class="collapse" for="c-38184398">[-]</label><label class="expand" for="c-38184398">[1 more]</label></div><br/><div class="children"><div class="content">Aka a function <i>tongue-in-cheek</i> :p</div><br/></div></div></div></div><div id="38183216" class="c"><input type="checkbox" id="c-38183216" checked=""/><div class="controls bullet"><span class="by">phtrivier</span><span>|</span><a href="#38183067">parent</a><span>|</span><a href="#38184157">prev</a><span>|</span><a href="#38183933">next</a><span>|</span><label class="collapse" for="c-38183216">[-]</label><label class="expand" for="c-38183216">[5 more]</label></div><br/><div class="children"><div class="content">If I read the article correctly, it&#x27;s actually &quot;a compiler for a language that only supports basic arithmetic, without a lexer, a parser, symbols, nor an optimization phase&quot;.<p>Which _is_ surprisingly easy to write. But it might be a stretch to call it &quot;a compiler&quot; :D</div><br/><div id="38183878" class="c"><input type="checkbox" id="c-38183878" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183216">parent</a><span>|</span><a href="#38184220">next</a><span>|</span><label class="collapse" for="c-38183878">[-]</label><label class="expand" for="c-38183878">[1 more]</label></div><br/><div class="children"><div class="content">Yes draw two circles and then the rest of the owl kind of thing.</div><br/></div></div><div id="38184220" class="c"><input type="checkbox" id="c-38184220" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183216">parent</a><span>|</span><a href="#38183878">prev</a><span>|</span><a href="#38183495">next</a><span>|</span><label class="collapse" for="c-38184220">[-]</label><label class="expand" for="c-38184220">[1 more]</label></div><br/><div class="children"><div class="content">Eh, a college friend put together a C compiler in 100 lines of yacc (not particularly golfed, either, C just isn&#x27;t that sophisticated.)  Great for playing with &quot;what if C + this one feature&quot; kind of things in a concrete way.  So from my perspective, not a stretch at all...</div><br/></div></div><div id="38183495" class="c"><input type="checkbox" id="c-38183495" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183216">parent</a><span>|</span><a href="#38184220">prev</a><span>|</span><a href="#38183933">next</a><span>|</span><label class="collapse" for="c-38183495">[-]</label><label class="expand" for="c-38183495">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve written stuff like this many times -- mostly producing AST then bytecode, etc. I never really wanted to call it a &#x27;compiler&#x27; per se though that&#x27;s what it is. Because I generally stand in awe of serious optimizing compiler engineers, they have deep domain expertise that is admirable.</div><br/><div id="38183538" class="c"><input type="checkbox" id="c-38183538" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183495">parent</a><span>|</span><a href="#38183933">next</a><span>|</span><label class="collapse" for="c-38183538">[-]</label><label class="expand" for="c-38183538">[1 more]</label></div><br/><div class="children"><div class="content">True, but no need to self-gatekeep the terminology here just to appease a rando commenter. :)</div><br/></div></div></div></div></div></div><div id="38183933" class="c"><input type="checkbox" id="c-38183933" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#38183067">parent</a><span>|</span><a href="#38183216">prev</a><span>|</span><a href="#38183225">next</a><span>|</span><label class="collapse" for="c-38183933">[-]</label><label class="expand" for="c-38183933">[1 more]</label></div><br/><div class="children"><div class="content">As opposed to a tree-walking interpreter, which is usually presented as the only viable way to write your first programming language implementation.</div><br/></div></div><div id="38183225" class="c"><input type="checkbox" id="c-38183225" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#38183067">parent</a><span>|</span><a href="#38183933">prev</a><span>|</span><a href="#38183280">next</a><span>|</span><label class="collapse" for="c-38183225">[-]</label><label class="expand" for="c-38183225">[4 more]</label></div><br/><div class="children"><div class="content">* compiler without good error messages</div><br/><div id="38183993" class="c"><input type="checkbox" id="c-38183993" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183225">parent</a><span>|</span><a href="#38183280">next</a><span>|</span><label class="collapse" for="c-38183993">[-]</label><label class="expand" for="c-38183993">[3 more]</label></div><br/><div class="children"><div class="content">Clang may have better static checking, but Apple&#x27;s MPW C compiler still had better error messages.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37283375">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37283375</a></div><br/><div id="38184360" class="c"><input type="checkbox" id="c-38184360" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183993">parent</a><span>|</span><a href="#38184346">next</a><span>|</span><label class="collapse" for="c-38184360">[-]</label><label class="expand" for="c-38184360">[1 more]</label></div><br/><div class="children"><div class="content">Cute and whimsical, but I was thinking along the lines of context for answering &quot;why?&quot;<p>&quot;..because it was defined at [....] and used [....] and [...] as a int32 type (thus coerced to int64), but passed in [...] as a&quot;</div><br/></div></div></div></div></div></div><div id="38183280" class="c"><input type="checkbox" id="c-38183280" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#38183067">parent</a><span>|</span><a href="#38183225">prev</a><span>|</span><a href="#38183178">next</a><span>|</span><label class="collapse" for="c-38183280">[-]</label><label class="expand" for="c-38183280">[4 more]</label></div><br/><div class="children"><div class="content">if you use the nanopass approach you can add optimisation phases relatively easily</div><br/><div id="38183668" class="c"><input type="checkbox" id="c-38183668" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183280">parent</a><span>|</span><a href="#38183178">next</a><span>|</span><label class="collapse" for="c-38183668">[-]</label><label class="expand" for="c-38183668">[3 more]</label></div><br/><div class="children"><div class="content">but since he hardcodes the register allocation, i wonder how he can control anything here</div><br/><div id="38183819" class="c"><input type="checkbox" id="c-38183819" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183668">parent</a><span>|</span><a href="#38183178">next</a><span>|</span><label class="collapse" for="c-38183819">[-]</label><label class="expand" for="c-38183819">[2 more]</label></div><br/><div class="children"><div class="content">you can refactor over time to add a register allocator. the key point is it&#x27;s usually easier to do these things within the context of an end-to-end working compiler than with a big design up front.</div><br/><div id="38184295" class="c"><input type="checkbox" id="c-38184295" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183819">parent</a><span>|</span><a href="#38183178">next</a><span>|</span><label class="collapse" for="c-38184295">[-]</label><label class="expand" for="c-38184295">[1 more]</label></div><br/><div class="children"><div class="content">yeah, fair enough</div><br/></div></div></div></div></div></div></div></div><div id="38183178" class="c"><input type="checkbox" id="c-38183178" checked=""/><div class="controls bullet"><span class="by">TheChaplain</span><span>|</span><a href="#38183067">parent</a><span>|</span><a href="#38183280">prev</a><span>|</span><a href="#38184716">next</a><span>|</span><label class="collapse" for="c-38183178">[-]</label><label class="expand" for="c-38183178">[2 more]</label></div><br/><div class="children"><div class="content">Probably adheres to the principle; &quot;Make it work, then make it fast&quot;</div><br/><div id="38183745" class="c"><input type="checkbox" id="c-38183745" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38183067">root</a><span>|</span><a href="#38183178">parent</a><span>|</span><a href="#38184716">next</a><span>|</span><label class="collapse" for="c-38183745">[-]</label><label class="expand" for="c-38183745">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually three steps:
make it,
make it work,
make it work faster.<p>this may actually be somewhere between step one and two.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>