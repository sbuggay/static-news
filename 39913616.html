<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712221254621" as="style"/><link rel="stylesheet" href="styles.css?v=1712221254621"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://devblogs.microsoft.com/oldnewthing/20240401-00/?p=109599">Subroutine calls in the ancient world, before computers had stacks or heaps</a>Â <span class="domain">(<a href="https://devblogs.microsoft.com">devblogs.microsoft.com</a>)</span></div><div class="subtext"><span>signa11</span> | <span>146 comments</span></div><br/><div><div id="39928012" class="c"><input type="checkbox" id="c-39928012" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#39918536">next</a><span>|</span><label class="collapse" for="c-39928012">[-]</label><label class="expand" for="c-39928012">[1 more]</label></div><br/><div class="children"><div class="content">&quot;First, the compiler defined a secret global variable for each inbound function parameter, plus another secret global variable for each function to hold the return address&quot;<p>I believe &#x27;hidden&#x27; is the word he&#x27;s looking for.<p>And one doesn&#x27;t have to go all that far into history to find architectures w&#x2F;o hardware support for a return stack, see e.g. Parallax Propeller.<p>And the problem with static variables (hidden or not) is not only that they prevent recursion, but also reentrancy.<p>I think that article could have benefited from a peer review from one of his colleagues at Microsoft.</div><br/></div></div><div id="39918536" class="c"><input type="checkbox" id="c-39918536" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#39928012">prev</a><span>|</span><a href="#39918533">next</a><span>|</span><label class="collapse" for="c-39918536">[-]</label><label class="expand" for="c-39918536">[19 more]</label></div><br/><div class="children"><div class="content">I really liked the Art of Computer Programming with regards to this subject.<p>While seemingly obsolete, there are a ton of pre-heap &#x2F; pre-stack algorithms for dynamically changing arrays or other data structures.<p>The book also builds up to garbage collection and how to implements Lisp-lists. The kind of encyclopedic knowledge you&#x27;d expect from Knuth.<p>-------<p>One of my favorites is how to have two Arrays dynamically take up one space.<p>Have one array grow normally from location#0, and the second array grow backwards from location#End.<p>Now both arrays take up the statically allocated space efficiently sharing.<p>This can be extended to an arbitrary number of arrays, but at that point you might as well use Malloc and Realloc. Or at least, the techniques therein are really close to a malloc-like routine IMO.</div><br/><div id="39922706" class="c"><input type="checkbox" id="c-39922706" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#39918536">parent</a><span>|</span><a href="#39919554">next</a><span>|</span><label class="collapse" for="c-39922706">[-]</label><label class="expand" for="c-39922706">[5 more]</label></div><br/><div class="children"><div class="content">Some word processors on 8-bit computers worked like this.  Your document took all of the available RAM.  Text before the cursor was at the start of RAM and text after the cursor was at the end of RAM.  Insertions and pastes didn&#x27;t need to shuffle data around but navigation did.  It worked well.</div><br/><div id="39922791" class="c"><input type="checkbox" id="c-39922791" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39922706">parent</a><span>|</span><a href="#39919554">next</a><span>|</span><label class="collapse" for="c-39922791">[-]</label><label class="expand" for="c-39922791">[4 more]</label></div><br/><div class="children"><div class="content">emacs still does this IIUC. The beating heart of the emacs edit model is a &quot;gap buffer&quot; at the cursor.<p>There&#x27;s a neat compare-and-contrast someone did awhile back on the gap buffer approach vs. the other approach often taken for code IDEs (&quot;ropes&quot;). The tl;dr is that gap buffers are actually really performant for a lot of cases except for having to edit at a lot of randomly-chosen cursor points far apart from each other (but how often is that your use case?).<p><a href="https:&#x2F;&#x2F;coredumped.dev&#x2F;2023&#x2F;08&#x2F;09&#x2F;text-showdown-gap-buffers-vs-ropes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;coredumped.dev&#x2F;2023&#x2F;08&#x2F;09&#x2F;text-showdown-gap-buffers-...</a></div><br/><div id="39925630" class="c"><input type="checkbox" id="c-39925630" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39922791">parent</a><span>|</span><a href="#39923982">next</a><span>|</span><label class="collapse" for="c-39925630">[-]</label><label class="expand" for="c-39925630">[2 more]</label></div><br/><div class="children"><div class="content">&gt; except for having to edit at a lot of randomly-chosen cursor points far apart from each other (but how often is that your use case?)<p>I use Sublime, and pretty often I do a &quot;Find All&quot; for some term; then Multiselect (Cmd+L); then select from cursor (Shift+RightArrow); and then type something. Which <i>is</i> essentially &quot;editing at a lot of randomly [or at least arbitrarily]-chosen cursor points.&quot;<p>That, and IIRC Sublime actually does its &quot;Find and Replace All&quot; operation, as essentially this same multicursor-select-and-type operation internally. (If you have a large-enough buffer open, you can see it gradually doing it!)</div><br/><div id="39926701" class="c"><input type="checkbox" id="c-39926701" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39925630">parent</a><span>|</span><a href="#39923982">next</a><span>|</span><label class="collapse" for="c-39926701">[-]</label><label class="expand" for="c-39926701">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never been able to make that work, but I respect that you have. Generally, that kind of select almost always grabs a bunch of substrings that aren&#x27;t appropriate and I end up mangling my file.</div><br/></div></div></div></div><div id="39923982" class="c"><input type="checkbox" id="c-39923982" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39922791">parent</a><span>|</span><a href="#39925630">prev</a><span>|</span><a href="#39919554">next</a><span>|</span><label class="collapse" for="c-39923982">[-]</label><label class="expand" for="c-39923982">[1 more]</label></div><br/><div class="children"><div class="content">seems like Vim does too</div><br/></div></div></div></div></div></div><div id="39919554" class="c"><input type="checkbox" id="c-39919554" checked=""/><div class="controls bullet"><span class="by">bewaretheirs</span><span>|</span><a href="#39918536">parent</a><span>|</span><a href="#39922706">prev</a><span>|</span><a href="#39922452">next</a><span>|</span><label class="collapse" for="c-39919554">[-]</label><label class="expand" for="c-39919554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Have one array grow normally from location#0, and the second array grow backwards from location#End.<p>The stack in most ISAs and ABIs grows down from a high address, allowing this trick to be used to divide memory flexibly between heap and stack in single-threaded small-memory systems.</div><br/></div></div><div id="39922452" class="c"><input type="checkbox" id="c-39922452" checked=""/><div class="controls bullet"><span class="by">yongjik</span><span>|</span><a href="#39918536">parent</a><span>|</span><a href="#39919554">prev</a><span>|</span><a href="#39927610">next</a><span>|</span><label class="collapse" for="c-39922452">[-]</label><label class="expand" for="c-39922452">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Have one array grow normally from location#0, and the second array grow backwards from location#End.<p>Fun fact: Itanium had <i>two</i> stacks, one for manual push&#x2F;pop and another for cycling through the register file.  One stack grew upward, another grew downward.  A fascinating architecture, though it never delivered the promised performance.</div><br/></div></div><div id="39927610" class="c"><input type="checkbox" id="c-39927610" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#39918536">parent</a><span>|</span><a href="#39922452">prev</a><span>|</span><a href="#39918898">next</a><span>|</span><label class="collapse" for="c-39927610">[-]</label><label class="expand" for="c-39927610">[1 more]</label></div><br/><div class="children"><div class="content">&gt;but at that point you might as well use Malloc and Realloc.<p>IIRC, the first edition of the classic K&amp;R C book, The C Programming Language, had an example of creating a memory allocator and using it.</div><br/></div></div><div id="39918898" class="c"><input type="checkbox" id="c-39918898" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39918536">parent</a><span>|</span><a href="#39927610">prev</a><span>|</span><a href="#39919477">next</a><span>|</span><label class="collapse" for="c-39918898">[-]</label><label class="expand" for="c-39918898">[9 more]</label></div><br/><div class="children"><div class="content">SQLite&#x27;s on-disk format uses a similar array technique for storing the contents of table btree leaf node pages. Within a fixed-size page, there&#x27;s an array of offsets growing forwards, and an array of (variable length) row values growing backwards from the end - the latter of which may end up with holes when rows are deleted (iiuc).<p>It wouldn&#x27;t surprise me if it was a direct inspiration, since their docs cite TAOCP for the btree structure itself.</div><br/><div id="39919204" class="c"><input type="checkbox" id="c-39919204" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39918898">parent</a><span>|</span><a href="#39923527">next</a><span>|</span><label class="collapse" for="c-39919204">[-]</label><label class="expand" for="c-39919204">[5 more]</label></div><br/><div class="children"><div class="content">We know from the Corecursive podcast on the hidden story of SQLite that Dr. Hipp did indeed reference and pull at least one alg straight from Knuth&#x27;s books, which he had behind his desk. What a different world that must have been!</div><br/><div id="39924066" class="c"><input type="checkbox" id="c-39924066" checked=""/><div class="controls bullet"><span class="by">andrewshadura</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39919204">parent</a><span>|</span><a href="#39923527">next</a><span>|</span><label class="collapse" for="c-39924066">[-]</label><label class="expand" for="c-39924066">[4 more]</label></div><br/><div class="children"><div class="content">FYI, he&#x27;s D. R. Hipp, not Dr. Hipp.</div><br/><div id="39924198" class="c"><input type="checkbox" id="c-39924198" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39924066">parent</a><span>|</span><a href="#39924213">next</a><span>|</span><label class="collapse" for="c-39924198">[-]</label><label class="expand" for="c-39924198">[2 more]</label></div><br/><div class="children"><div class="content">More like Dr. D. R. Hipp, actually.</div><br/><div id="39925909" class="c"><input type="checkbox" id="c-39925909" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39924198">parent</a><span>|</span><a href="#39924213">next</a><span>|</span><label class="collapse" for="c-39925909">[-]</label><label class="expand" for="c-39925909">[1 more]</label></div><br/><div class="children"><div class="content">Hilarious and true</div><br/></div></div></div></div></div></div></div></div><div id="39923527" class="c"><input type="checkbox" id="c-39923527" checked=""/><div class="controls bullet"><span class="by">suncherta</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39918898">parent</a><span>|</span><a href="#39919204">prev</a><span>|</span><a href="#39919361">next</a><span>|</span><label class="collapse" for="c-39923527">[-]</label><label class="expand" for="c-39923527">[1 more]</label></div><br/><div class="children"><div class="content">As others have already mentioned this is used in a lot (most?) of databases.
It is called &quot;slotted-page&quot;. Searching for it gives good discussions&#x2F;explanations of it.</div><br/></div></div><div id="39919361" class="c"><input type="checkbox" id="c-39919361" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39918898">parent</a><span>|</span><a href="#39923527">prev</a><span>|</span><a href="#39922125">next</a><span>|</span><label class="collapse" for="c-39919361">[-]</label><label class="expand" for="c-39919361">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like it was copied from PostreSQL which SQLite cites as a strong source of inspiration.</div><br/></div></div><div id="39922125" class="c"><input type="checkbox" id="c-39922125" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#39918536">root</a><span>|</span><a href="#39918898">parent</a><span>|</span><a href="#39919361">prev</a><span>|</span><a href="#39919477">next</a><span>|</span><label class="collapse" for="c-39922125">[-]</label><label class="expand" for="c-39922125">[1 more]</label></div><br/><div class="children"><div class="content">Oracle does this as well and I suspect many other row-major RDBMS storage engines do too.</div><br/></div></div></div></div><div id="39919477" class="c"><input type="checkbox" id="c-39919477" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#39918536">parent</a><span>|</span><a href="#39918898">prev</a><span>|</span><a href="#39918533">next</a><span>|</span><label class="collapse" for="c-39919477">[-]</label><label class="expand" for="c-39919477">[1 more]</label></div><br/><div class="children"><div class="content">This succinctly describes how old MacOS allocated per-application resources. Each app had a minimum and preferred RAM requirement tagged to it. When launched, it would take up the whole preferred slot, unless that amount wasn&#x27;t available in which case it&#x27;d take up less than preferred (and fail to launch if it couldn&#x27;t get minimum).<p>The system allocated the heap (and libraries, I think) at the bottom and the stack at the top of that physical-RAM slice, and off you went.<p>I believe around system 8 they added a virtualization layer that started to obviate the need for that approach (and of course by the time of MacOSX they were using paged memory like everyone else was and so such fancy tap-dancing was no longer needed). But it&#x27;s fun to think about the era where this &quot;one weird trick&quot; from Art of Computer Programming <i>was</i> how we allocated RAM for multiple concurrent applications.</div><br/></div></div></div></div><div id="39918533" class="c"><input type="checkbox" id="c-39918533" checked=""/><div class="controls bullet"><span class="by">joeatwork</span><span>|</span><a href="#39918536">prev</a><span>|</span><a href="#39918886">next</a><span>|</span><label class="collapse" for="c-39918533">[-]</label><label class="expand" for="c-39918533">[3 more]</label></div><br/><div class="children"><div class="content">Getting recursive functions into ALGOL turns out to have been a controversial move that made for a fun story: <a href="https:&#x2F;&#x2F;vanemden.wordpress.com&#x2F;2014&#x2F;06&#x2F;18&#x2F;how-recursion-got-into-programming-a-comedy-of-errors-3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vanemden.wordpress.com&#x2F;2014&#x2F;06&#x2F;18&#x2F;how-recursion-got-...</a></div><br/><div id="39923583" class="c"><input type="checkbox" id="c-39923583" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39918533">parent</a><span>|</span><a href="#39918905">next</a><span>|</span><label class="collapse" for="c-39923583">[-]</label><label class="expand" for="c-39923583">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>How recursion got into programming: intrigue, betrayal, and advanced semantics</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33123916">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33123916</a> - Oct 2022 (8 comments)<p><i>How Recursion Got into Programming (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23061881">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23061881</a> - May 2020 (47 comments)<p><i>How recursion got into Algol 60: a comedy of errors</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10131664">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10131664</a> - Aug 2015 (124 comments)<p><i>How recursion got into programming: a comedy of errors</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8073361">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8073361</a> - July 2014 (108 comments)</div><br/></div></div><div id="39918905" class="c"><input type="checkbox" id="c-39918905" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#39918533">parent</a><span>|</span><a href="#39923583">prev</a><span>|</span><a href="#39918886">next</a><span>|</span><label class="collapse" for="c-39918905">[-]</label><label class="expand" for="c-39918905">[1 more]</label></div><br/><div class="children"><div class="content">Definitely &quot;a tale of intrigue, betrayal, and advanced programming-language semantics&quot;</div><br/></div></div></div></div><div id="39918886" class="c"><input type="checkbox" id="c-39918886" checked=""/><div class="controls bullet"><span class="by">howerj</span><span>|</span><a href="#39918533">prev</a><span>|</span><a href="#39927703">next</a><span>|</span><label class="collapse" for="c-39918886">[-]</label><label class="expand" for="c-39918886">[9 more]</label></div><br/><div class="children"><div class="content">I wrote a Forth interpreter for a SUBLEQ machine (<a href="https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;subleq">https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;subleq</a>), and for a bit-serial machine (<a href="https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;bit-serial">https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;bit-serial</a>), both of which do not have a function call stack which is a requirement of Forth. SUBLEQ also does not allow indirect loading and stores as well and requires self-modifying code to do anything non-trivial. The approach I took for both machines was to build a virtual machine that could do those things, along with cooperative multithreading. The heap, if required, is written in Forth, along with a floating point word-set (various MCUs not having instructions for floating point numbers is still fairly common, and can be implemented as calls to software functions that implement them instead).<p>I would imagine that other compilers took a similar approach which wasn&#x27;t mentioned.<p>EDIT: There were some BASIC interpreters which did this as well, implementing a VM and then targetting that instead. P-Code is a similar thing.</div><br/><div id="39922923" class="c"><input type="checkbox" id="c-39922923" checked=""/><div class="controls bullet"><span class="by">parlortricks</span><span>|</span><a href="#39918886">parent</a><span>|</span><a href="#39926994">next</a><span>|</span><label class="collapse" for="c-39922923">[-]</label><label class="expand" for="c-39922923">[3 more]</label></div><br/><div class="children"><div class="content">I came across your works learning and consuming all things Forth and Subleq. It was great to read over how you approach things. I wanted to purchase your book but Amazon says no...will there be another run?</div><br/><div id="39923454" class="c"><input type="checkbox" id="c-39923454" checked=""/><div class="controls bullet"><span class="by">howerj</span><span>|</span><a href="#39918886">root</a><span>|</span><a href="#39922923">parent</a><span>|</span><a href="#39926994">next</a><span>|</span><label class="collapse" for="c-39923454">[-]</label><label class="expand" for="c-39923454">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! You should still be able buy it, you might have to either click on &quot;Paperback&quot; or &quot;Hardcover&quot;, if you want to get the kindle edition you have to go to the Amazon webpage that serves you country (e.g. if you are in the UK and you are on amazon.com you get &quot;This title is not currently available for purchase&quot;, but if you go to amazon.co.uk, you get buy it). That&#x27;s an odd user interface issue...</div><br/><div id="39924371" class="c"><input type="checkbox" id="c-39924371" checked=""/><div class="controls bullet"><span class="by">parlortricks</span><span>|</span><a href="#39918886">root</a><span>|</span><a href="#39923454">parent</a><span>|</span><a href="#39926994">next</a><span>|</span><label class="collapse" for="c-39924371">[-]</label><label class="expand" for="c-39924371">[1 more]</label></div><br/><div class="children"><div class="content">Ahhhh Amazon weirdness...all good, i managed to sort it out, paperback on its way!</div><br/></div></div></div></div></div></div><div id="39926994" class="c"><input type="checkbox" id="c-39926994" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39918886">parent</a><span>|</span><a href="#39922923">prev</a><span>|</span><a href="#39920178">next</a><span>|</span><label class="collapse" for="c-39926994">[-]</label><label class="expand" for="c-39926994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; EDIT: There were some BASIC interpreters which did this as well, implementing a VM and then targetting that instead.<p>The TI-99&#x2F;4A had 256 <i>bytes</i> (128 words) of main, CPU-accessible RAM. Most of the base system&#x27;s memory was video RAM, accessible by a relatively cumbersome process of poking and peeking registers on the system&#x27;s video chip. The video chip maintained an autoincrementing current memory pointer, so successive reads (or writes) would bump the pointer by one allowing straightforward transfers of data, but the very fact that most of the system&#x27;s memory was only accessible in this way made significant programs difficult to write. So, TI&#x27;s solution was to create an abstract machine called GPL in which memory accesses to this video RAM were more natural. It was interpreted on the TMS9900 and therefore slower than native code, though -- especially given that the CPU can only access the video chip&#x27;s RAM while the chip itself is not doing scanout to the display, so during horizontal and vertical retrace.<p>And since all the BASIC code and variables lived in this video memory, guess what the TI-99&#x2F;4A&#x27;s BASIC interpreter was written in! Yeah, it wasn&#x27;t very fast, like at all.<p>The neat part, apropos of the article&#x27;s topic, is that there were no actual general-purpose registers on the TMS9900: workspace registers WR0 through WR15 were instead located somewhere in memory, pointed to by the WP (workspace pointer) register. The CPU only had three physical registers: PC (program counter), WP, and a status register. What this amounted to was you could do a very primitive form of register windowing: by using the BLWP (Branch and Load WP) instruction, you can branch to a subroutine in which a new set of &quot;registers&quot; will be active elsewhere in memory -- and the return address will be saved in the new workspace.<p>If I&#x27;m going on about the TI-99&#x2F;4A a lot recently, it&#x27;s because I&#x27;m writing an assembler for it as a personal project.</div><br/></div></div><div id="39920178" class="c"><input type="checkbox" id="c-39920178" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#39918886">parent</a><span>|</span><a href="#39926994">prev</a><span>|</span><a href="#39927703">next</a><span>|</span><label class="collapse" for="c-39920178">[-]</label><label class="expand" for="c-39920178">[4 more]</label></div><br/><div class="children"><div class="content">I was about to talk about subleq, but it&#x27;s damn difficult even to write a &quot;Hello world&quot;.</div><br/><div id="39921021" class="c"><input type="checkbox" id="c-39921021" checked=""/><div class="controls bullet"><span class="by">howerj</span><span>|</span><a href="#39918886">root</a><span>|</span><a href="#39920178">parent</a><span>|</span><a href="#39927703">next</a><span>|</span><label class="collapse" for="c-39921021">[-]</label><label class="expand" for="c-39921021">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, it really is a pain to do anything in it. I got around that by writing in another language instead as soon as possible. You can paper over many issues with a VM, although it will slow things down on such limited computers.</div><br/><div id="39921805" class="c"><input type="checkbox" id="c-39921805" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#39918886">root</a><span>|</span><a href="#39921021">parent</a><span>|</span><a href="#39927703">next</a><span>|</span><label class="collapse" for="c-39921805">[-]</label><label class="expand" for="c-39921805">[2 more]</label></div><br/><div class="children"><div class="content">How does muxleq work? It looks like a &#x27;concurrent&#x27; subleq...</div><br/><div id="39922112" class="c"><input type="checkbox" id="c-39922112" checked=""/><div class="controls bullet"><span class="by">howerj</span><span>|</span><a href="#39918886">root</a><span>|</span><a href="#39921805">parent</a><span>|</span><a href="#39927703">next</a><span>|</span><label class="collapse" for="c-39922112">[-]</label><label class="expand" for="c-39922112">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure what you mean by concurrent in this case, muxleq is just subleq with one extra instruction. The extra instruction is based off of multiplexing (see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiplexer" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiplexer</a>). Subleq as you know is incredibly inefficient, muxleq is an experiment to add a single instruction to Subleq in order to greatly improve its efficiency.<p>The `mux` instruction added computes:<p><pre><code>   m[operand2] = (m[operand1] &amp; ~selector) | (m[operand2] &amp; selector)
</code></pre>
As multiplexing is a universal gate (so long as you have access to true and false as constants) you can use this to calculate AND&#x2F;OR&#x2F;XOR, which are very expensive to do in a pure Subleq machine. It also means you can do a MOV in a single instruction instead of four (set the `selector` to zero in this case). This in turns speeds up indirect loads and stores.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39927703" class="c"><input type="checkbox" id="c-39927703" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#39918886">prev</a><span>|</span><a href="#39922375">next</a><span>|</span><label class="collapse" for="c-39927703">[-]</label><label class="expand" for="c-39927703">[1 more]</label></div><br/><div class="children"><div class="content">If my memory is correct &quot;no stack&quot; was the way I was writing BASIC programs on my ZX81.<p><pre><code>   1 GOTO 30
  10 LET C = A + B
  20 RETURN
  30 LET A = 1
  40 LET B = 2
  50 GOSUB 10
  60 LET A = C
  70 LET B = 3
  80 GOSUB 10
  90 PRINT C

  RUN
  6
</code></pre>
I was doing the job of the compiler in the article. Line numbers are memory addresses and the hidden variables are not hidden to me, because I&#x27;m the compiler. The only thing the interpreter made for me is storing the return address of GOSUB.<p>Disclaimer 1: the code could be syntactically wrong and hallucinated (40 years are a long time) but it gives the general idea.<p>Disclaimer 2: The Z80 processor inside the machine had stack management, the BASIC interpreter was really very basic but it could be excused: it had 1 kB RAM and a 8 kB ROM with the OS, the interpreter and everything.</div><br/></div></div><div id="39922375" class="c"><input type="checkbox" id="c-39922375" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#39927703">prev</a><span>|</span><a href="#39923594">next</a><span>|</span><label class="collapse" for="c-39922375">[-]</label><label class="expand" for="c-39922375">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As I recall, some processors stored the return address at the word before the first instruction of the subroutine.<p>Yep, that&#x27;s what the PDP-8 did.  The evolution of the PDP-8 is arguably a journey in hardware support for recursion.<p>Initially the JMS instruction stuck the return address in the first word of the function (as an aside, a lot of time caller would put it&#x27;s arguments after the JMS instruction, and the callee would read arguments offset of the return instruction, incrementing it with each read argument until the return address pointed to code again).<p>Then it became relatively common to use one of the autoincrement locations (the PDP-8 had 8 memory locations that would increment any time you used them as a pointer) to create a simple stack, and function prologues&#x2F;epilogues manually managed this stack to allow full recursion.<p>Then later on hardware stacks were added in the microprocessor implementations like the Harris 6120 to make this more performant.</div><br/><div id="39925741" class="c"><input type="checkbox" id="c-39925741" checked=""/><div class="controls bullet"><span class="by">drfuchs</span><span>|</span><a href="#39922375">parent</a><span>|</span><a href="#39925128">next</a><span>|</span><label class="collapse" for="c-39925741">[-]</label><label class="expand" for="c-39925741">[1 more]</label></div><br/><div class="children"><div class="content">Way back in 1956, Librascope&#x27;s LGP-30 had an &quot;R&quot; instruction (&quot;store Return address&quot;) that stored (already-incremented)PC+1 into the address portion of the instruction at the destination, which was by convention an unconditional branch just in front of the beginning of a subroutine. You&#x27;d follow the &quot;R&quot; instruction with a &quot;U&quot; (unconditional branch) to that subroutine.  The subroutine would return by branching to the address just in front of it, which conveniently was an unconditional branch back to just after the call location.  So, recursion was out of the question unless you used some more advanced calling convention.  (And all opcodes in assembly language were a single letter.)</div><br/></div></div><div id="39925128" class="c"><input type="checkbox" id="c-39925128" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#39922375">parent</a><span>|</span><a href="#39925741">prev</a><span>|</span><a href="#39923594">next</a><span>|</span><label class="collapse" for="c-39925128">[-]</label><label class="expand" for="c-39925128">[1 more]</label></div><br/><div class="children"><div class="content">As did the IBM 1800 and IBM 1130 and many machines of that era.  Machines such as the Xerox Sigma series had enough registers to avoid this practice.</div><br/></div></div></div></div><div id="39923594" class="c"><input type="checkbox" id="c-39923594" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#39922375">prev</a><span>|</span><a href="#39925652">next</a><span>|</span><label class="collapse" for="c-39923594">[-]</label><label class="expand" for="c-39923594">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing functional programming so long that I genuinely have a hard time thinking about how I would write things without recursion.<p>Like, I technically know how to convert a recursive algorithm to an iterative one, I&#x27;ve done it before on more resource-constrained stuff, but I don&#x27;t <i>like</i> it.  I think the recursive stuff is generally prettier and for 99% of things it&#x27;s fast enough (and 100% if your compiler supports tail recursion, though you&#x27;d still be stuck maintaining a stack for most of the more interesting stuff).<p>Occasionally I&#x27;ll do things to force myself to learn how things were done before I was born.  I&#x27;ve been on&#x2F;off hacking on a Commodore 64 game, but man I feel pretty grateful to be as spoiled as I am with fast, cheap, easy-to-use hardware.</div><br/><div id="39925140" class="c"><input type="checkbox" id="c-39925140" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#39923594">parent</a><span>|</span><a href="#39925652">next</a><span>|</span><label class="collapse" for="c-39925140">[-]</label><label class="expand" for="c-39925140">[1 more]</label></div><br/><div class="children"><div class="content">Yes, instruction sets these days are significantly more useful.<p>To do recursion in those old machines, one would need to build your own stack mechanism, but there would still be issues to take care of, as there was no native way to use anything but global storage.<p>Having lived through those times, I don&#x27;t wish them on anyone.</div><br/></div></div></div></div><div id="39925652" class="c"><input type="checkbox" id="c-39925652" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#39923594">prev</a><span>|</span><a href="#39916445">next</a><span>|</span><label class="collapse" for="c-39925652">[-]</label><label class="expand" for="c-39925652">[1 more]</label></div><br/><div class="children"><div class="content">Funny enough, I was forced to program in exactly this way, when I was first learning to program. But not in the 1970s... in the year 2001!<p>Why? Because my first exposure to programming was the semi-graphical scripting &quot;language&quot; exposed by the game-development  tool &quot;RPG Maker 2000.&quot;<p>For those who haven&#x27;t seen RM2K scripting before: picture a cross between Scratch and Emacs Paredit mode. (E.g. <a href="https:&#x2F;&#x2F;forums.rpgmakerweb.com&#x2F;data&#x2F;attachments&#x2F;21&#x2F;21958-f8978e9d268a8359ef8547ff5736de90.jpg" rel="nofollow">https:&#x2F;&#x2F;forums.rpgmakerweb.com&#x2F;data&#x2F;attachments&#x2F;21&#x2F;21958-f89...</a>) It&#x27;s presented as textual, but you can&#x27;t edit it like text â only as blocks with associated properties dialogs.<p>And, of course, that scripting language in RPG Maker doesn&#x27;t have anything so fancy as a <i>stack</i>.<p>Want some reusable subroutines? Well, you better believe you&#x27;re allocating secret global variables for their parameters â no re-entrancy for you!<p>---<p>Mind you, thinking back on it, it&#x27;s probably <i>possible</i> to implement both registers and a runtime stack in RPG Maker 2000, given sufficient stubbornness.<p>Both features <i>seem</i> easy enough at first: you can do pseudo-&quot;registers&quot; like the zero page on a 6502; and you can do a stack through indirect variable access (<a href="https:&#x2F;&#x2F;rpgmaker.net&#x2F;tutorials&#x2F;523&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rpgmaker.net&#x2F;tutorials&#x2F;523&#x2F;</a>).<p>The problem with both of these, though, is that RM2K actually has <i>concurrency</i> in the form of &quot;parallel process&quot; scripts â so any use of either of these abstractions by these parallel processes, will have different &quot;threads&quot; stomping all over one-another&#x27;s state.<p>So you&#x27;d actually need <i>multiple</i> &quot;zero pages&quot; and &quot;stacks&quot; â one for each &quot;virtual core&quot; â and then you&#x27;d need to somehow assign&#x2F;bind&#x2F;schedule the &quot;virtual cores&quot; to parallel scripts (i.e. somehow get each script its own privately-known &quot;stack pointer.&quot;) Which, to be stable in the face of race conditions, would normally require something like mutexes...<p>Knowing the bloody-mindedness of RPG Maker gamedevs, I&#x27;m sure someone <i>did</i> come up with a way to trick some runtime feature into acting like a mutex. But I&#x27;m genuinely scared to know what it was they did.</div><br/></div></div><div id="39916445" class="c"><input type="checkbox" id="c-39916445" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39925652">prev</a><span>|</span><a href="#39918824">next</a><span>|</span><label class="collapse" for="c-39916445">[-]</label><label class="expand" for="c-39916445">[13 more]</label></div><br/><div class="children"><div class="content">Note that before we had arbitrarily extensible heaps, programmers always did at least a little engineering, in that they had to consider the probable distribution of inputs and size* all their intermediate storage appropriately.<p>* giving rise to &quot;BUGS <i>AND LIMITATIONS</i>&quot;</div><br/><div id="39918480" class="c"><input type="checkbox" id="c-39918480" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#39916445">parent</a><span>|</span><a href="#39919131">next</a><span>|</span><label class="collapse" for="c-39918480">[-]</label><label class="expand" for="c-39918480">[2 more]</label></div><br/><div class="children"><div class="content">Those before times are still today, depending on what you&#x27;re doing. For hard real-time, dynamic memory is (almost) never used, mostly because the time needed to alloc&#x2F;free memory isn&#x27;t deterministic. So everything is statically allocated at compile time and yeah, you&#x27;ve got to know how much memory your inputs are going to consume.<p>But knowing the bounds of memory consumption used to be normal for application programmers, too. I mean, you don&#x27;t want to run out of memory. Ever. What do people do now, just YOLO memory usage?</div><br/><div id="39919523" class="c"><input type="checkbox" id="c-39919523" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39918480">parent</a><span>|</span><a href="#39919131">next</a><span>|</span><label class="collapse" for="c-39919523">[-]</label><label class="expand" for="c-39919523">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What do people do now, just YOLO memory usage?<p>Yes, literally. Careful allocation has given way to &quot;Use what&#x27;s there and fail hard if it ain&#x27;t enough&quot; in the era where machines are cheap and the dominant paradigm is how parallel you can make your algorithm so you can solve your problem with scale.<p>In the modern era, for most online service software (which is, I&#x27;d argue, most software people interface with these days), you write it as fast as you can, prototype it small, <i>start</i> to care about RAM allocation (but build it to just die screaming if it runs out of RAM so you know you need to make a change), and keep scaling up.<p>You don&#x27;t care a lot about RAM allocation until you&#x27;re scaled to a lot of nodes because only at that scale is whether the app takes up a kilobyte less going to start to matter on machines that are swinging gigabytes of storage around.<p>There are plenty of application spaces where this isn&#x27;t the status quo (embedded architectures, console gaming), but that tends to be considered specialist engineering in this day and age.</div><br/></div></div></div></div><div id="39919131" class="c"><input type="checkbox" id="c-39919131" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#39916445">parent</a><span>|</span><a href="#39918480">prev</a><span>|</span><a href="#39920331">next</a><span>|</span><label class="collapse" for="c-39919131">[-]</label><label class="expand" for="c-39919131">[7 more]</label></div><br/><div class="children"><div class="content">Historically, that was also a big goal of GNU. It aimed to get rid of artificial limitations in core utilities. That was a big improvement over (made up example) sed having a finite and short maximum command length.</div><br/><div id="39919863" class="c"><input type="checkbox" id="c-39919863" checked=""/><div class="controls bullet"><span class="by">deckard1</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39919131">parent</a><span>|</span><a href="#39920331">next</a><span>|</span><label class="collapse" for="c-39919863">[-]</label><label class="expand" for="c-39919863">[6 more]</label></div><br/><div class="children"><div class="content">I can understand why people wanted that, and the benefit of doing that.<p>With that said, I also see benefit in having limitations. There is a certain comfort in knowing what a tool can do and <i>cannot</i> do. A hammer cannot become a screwdriver. And that&#x27;s fine because you can then <i>decide</i> to use a screwdriver. You&#x27;re capable of selection.<p>Take PostgreSQL. How many devs today know when it&#x27;s the right solution? When should they use Redis instead? Or a queue solution? Cloud services add even more confusion. What are the limitations and weaknesses of AWS RDS? Or any AWS service? Ask your typical dev this today and they will give you a blank stare. It&#x27;s really hard to even know what the right tool is today, when everything is abstracted away and put into fee tiers, ingress&#x2F;egress charges, etc. etc.<p>tl;dr: limitations and knowledge of those limitations are an important part of being able to select the right tool for the job</div><br/><div id="39920407" class="c"><input type="checkbox" id="c-39920407" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39919863">parent</a><span>|</span><a href="#39923271">next</a><span>|</span><label class="collapse" for="c-39920407">[-]</label><label class="expand" for="c-39920407">[2 more]</label></div><br/><div class="children"><div class="content">I see zero benefit in having artificial functionality limitations. In my hypothetical example, imagine that `sed &#x27;s&#x2F;foo&#x2F;bar&#x2F;&#x27;` works but `sed &#x27;s&#x2F;foo&#x2F;bark&#x2F;&#x27;` does not because it&#x27;s 1 character too long. There&#x27;s not a plausible scenario where that helps me. You wouldn&#x27;t want to expand sed to add a fullscreen text editor because that&#x27;s outside its scope. Within its scope, limitations only prevent you from using it where you need it. It would be more like a hammer that cannot be made to hammer 3 inch nails because it has a hard limit of 2.5 inches.<p>Those are the kinds of limits GNU wanted to remove. Why use a fixed-length buffer when you can alloc() at runtime? It doesn&#x27;t mean that `ls` should send email.</div><br/><div id="39924192" class="c"><input type="checkbox" id="c-39924192" checked=""/><div class="controls bullet"><span class="by">kryptiskt</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39920407">parent</a><span>|</span><a href="#39923271">next</a><span>|</span><label class="collapse" for="c-39924192">[-]</label><label class="expand" for="c-39924192">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a major benefit: you can test that a program with an artificial limit works up to the limit, and fails in a well-defined manner above the limit. A program without any hardcoded limit will also fail at some point, but you don&#x27;t know where and how.</div><br/></div></div></div></div><div id="39923271" class="c"><input type="checkbox" id="c-39923271" checked=""/><div class="controls bullet"><span class="by">mywittyname</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39919863">parent</a><span>|</span><a href="#39920407">prev</a><span>|</span><a href="#39919977">next</a><span>|</span><label class="collapse" for="c-39923271">[-]</label><label class="expand" for="c-39923271">[2 more]</label></div><br/><div class="children"><div class="content">Imagine using a program that can only allocate 4GB of ram because it has 32-bit address space.  There&#x27;s no benefit to that limitation, it&#x27;s an arbitrary limit imposed by the trades-offs made in the 80s.  It just means that someone will need to build another layer to their program to chunk their input data then recombine the output.  It&#x27;s a needless waste of resources.<p>The benefit of not having a limitation is that the real limits scale with compute power.  If you need more than 4GB of memory to process something, add more memory to the computer.</div><br/><div id="39923995" class="c"><input type="checkbox" id="c-39923995" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39923271">parent</a><span>|</span><a href="#39919977">next</a><span>|</span><label class="collapse" for="c-39923995">[-]</label><label class="expand" for="c-39923995">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine using a program that can only allocate 4GB of ram because it has 32-bit address space. There&#x27;s no benefit to that limitation<p>You&#x27;re looking at isolated parts of a system. In a system, an artificial &quot;limit&quot; in one component becomes a known <i>constraint</i> that other components can leverage as part of their own engineering.<p>In the example of memory addresses, it might be &quot;artificial&quot; to say that a normal application can only use 32-bit or 48-bit addresses when the hardware running the application operates in 64-bits, but this <i>explicit constraint</i> might enable (say) a runtime or operating system to do clever things with those extra bits -- security, validation, auditing, optimization, etc.<p>And in many cases, the benefits of being able to engineer a system of <i>constrained</i> components are far more common and far more constructive than the odd occasion that a use case is entirely inhibited by a constraint.<p>That&#x27;s not to say that we should blindly accept and perpetuate every constraint ever introduced, or introduce new ones without thoughtful consideration, but it&#x27;s wrong to believe they have &quot;no benefit&quot; just because they seem &quot;artificial&quot; or &quot;arbitrary&quot;.</div><br/></div></div></div></div><div id="39919977" class="c"><input type="checkbox" id="c-39919977" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39919863">parent</a><span>|</span><a href="#39923271">prev</a><span>|</span><a href="#39920331">next</a><span>|</span><label class="collapse" for="c-39919977">[-]</label><label class="expand" for="c-39919977">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A hammer cannot become a screwdriver.<p>Don&#x27;t tell me you&#x27;ve never hammered a screw into a wooden plank? Vice versa, a screwdriver also can be used as a hammer although a quite pathetic one.</div><br/></div></div></div></div></div></div><div id="39920331" class="c"><input type="checkbox" id="c-39920331" checked=""/><div class="controls bullet"><span class="by">lenerdenator</span><span>|</span><a href="#39916445">parent</a><span>|</span><a href="#39919131">prev</a><span>|</span><a href="#39918824">next</a><span>|</span><label class="collapse" for="c-39920331">[-]</label><label class="expand" for="c-39920331">[3 more]</label></div><br/><div class="children"><div class="content">Really, the mistake was letting humans provide input to computer programs.</div><br/><div id="39921650" class="c"><input type="checkbox" id="c-39921650" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39920331">parent</a><span>|</span><a href="#39918824">next</a><span>|</span><label class="collapse" for="c-39921650">[-]</label><label class="expand" for="c-39921650">[2 more]</label></div><br/><div class="children"><div class="content">In particular input to assemblers, compilers, and interpreters.</div><br/><div id="39921968" class="c"><input type="checkbox" id="c-39921968" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39916445">root</a><span>|</span><a href="#39921650">parent</a><span>|</span><a href="#39918824">next</a><span>|</span><label class="collapse" for="c-39921968">[-]</label><label class="expand" for="c-39921968">[1 more]</label></div><br/><div class="children"><div class="content">I once wrote a 16-bit assembler as a recursive function, which emitted code and fixed data on the way down and patched in relative offsets on the way back up.<p>In principle, one might worry about blowing the stack, but as the sole purpose of this function was to assemble at most a half-k boot sector, in practice they fit.</div><br/></div></div></div></div></div></div></div></div><div id="39918824" class="c"><input type="checkbox" id="c-39918824" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39916445">prev</a><span>|</span><a href="#39919126">next</a><span>|</span><label class="collapse" for="c-39918824">[-]</label><label class="expand" for="c-39918824">[5 more]</label></div><br/><div class="children"><div class="content">In the @let feature in Enhanced GNU Awk, for those @let blocks that are outside of a function, like in BEGIN or END blocks, I have the compiler allocate secret global variables. They are reused as much as possible between blocks.<p><pre><code>  $ .&#x2F;gawk --dump-variables &#x27;BEGIN { @let (a, b, c = 1) { } }&#x27;
  $ cat awkvars.out
  $let0001: untyped variable
  $let0002: untyped variable
  $let0003: 1
  ARGC: 1
  ARGIND: 0
  ARGV: array, 1 elements
  BINMODE: 0
  [ .. snip many ]
</code></pre>
<a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;egawk&#x2F;about&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;egawk&#x2F;about&#x2F;</a></div><br/><div id="39924582" class="c"><input type="checkbox" id="c-39924582" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#39918824">parent</a><span>|</span><a href="#39919126">next</a><span>|</span><label class="collapse" for="c-39924582">[-]</label><label class="expand" for="c-39924582">[4 more]</label></div><br/><div class="children"><div class="content">That website doesn&#x27;t work from my ISP. Can&#x27;t even ping it or nc -z 104.37.63.7 443.<p>Edit update: Your security infrastructure is broken because I don&#x27;t know what that is and don&#x27;t use Twitter. If you check the AS, it&#x27;s Google Fiber. And I&#x27;d appreciate it if you wouldn&#x27;t dox me.</div><br/><div id="39927995" class="c"><input type="checkbox" id="c-39927995" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39918824">root</a><span>|</span><a href="#39924582">parent</a><span>|</span><a href="#39925265">next</a><span>|</span><label class="collapse" for="c-39927995">[-]</label><label class="expand" for="c-39927995">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div><div id="39925265" class="c"><input type="checkbox" id="c-39925265" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39918824">root</a><span>|</span><a href="#39924582">parent</a><span>|</span><a href="#39927995">prev</a><span>|</span><a href="#39926037">next</a><span>|</span><label class="collapse" for="c-39925265">[-]</label><label class="expand" for="c-39925265">[1 more]</label></div><br/><div class="children"><div class="content">Not sure why. Out of the 26 IP addresses that accessed the egawk repository in the last day or so, only one was banned. The client identified as Twitterbot, coming from 136.49.X.X.</div><br/></div></div><div id="39926037" class="c"><input type="checkbox" id="c-39926037" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#39918824">root</a><span>|</span><a href="#39924582">parent</a><span>|</span><a href="#39925265">prev</a><span>|</span><a href="#39919126">next</a><span>|</span><label class="collapse" for="c-39926037">[-]</label><label class="expand" for="c-39926037">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t your dox: if you can&#x27;t even ping it, you wouldn&#x27;t have been able to request a specific repository, and won&#x27;t appear in that access log.</div><br/></div></div></div></div></div></div><div id="39919126" class="c"><input type="checkbox" id="c-39919126" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39918824">prev</a><span>|</span><a href="#39920027">next</a><span>|</span><label class="collapse" for="c-39919126">[-]</label><label class="expand" for="c-39919126">[46 more]</label></div><br/><div class="children"><div class="content"><i>&quot;There was just one catch: You can&#x27;t do recursion.&quot;</i><p>You could do tail recursion, because only the return address of the first call would be needed to be stored. `branch_with_link` would be used for the initial call, but the recursive calls would have to be regular branches.</div><br/><div id="39925176" class="c"><input type="checkbox" id="c-39925176" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#39919126">parent</a><span>|</span><a href="#39919268">next</a><span>|</span><label class="collapse" for="c-39925176">[-]</label><label class="expand" for="c-39925176">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but you do need to handle local storage.</div><br/></div></div><div id="39919268" class="c"><input type="checkbox" id="c-39919268" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">parent</a><span>|</span><a href="#39925176">prev</a><span>|</span><a href="#39920027">next</a><span>|</span><label class="collapse" for="c-39919268">[-]</label><label class="expand" for="c-39919268">[44 more]</label></div><br/><div class="children"><div class="content">Most recursion is about as bad as goto coding methodologies.<p>Personally, I think it should be avoided in modern compiled languages too.<p>Haskell is fun to play around on, but it is horrific to consider using in a stable production environment. =)</div><br/><div id="39919650" class="c"><input type="checkbox" id="c-39919650" checked=""/><div class="controls bullet"><span class="by">EdwardCoffin</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919268">parent</a><span>|</span><a href="#39922743">next</a><span>|</span><label class="collapse" for="c-39919650">[-]</label><label class="expand" for="c-39919650">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend you read Guy Steele&#x27;s blog post Why Object-Oriented Languages Need Tail Calls [1] and perhaps the essay by William Cook [2] and the discussion over on Lambda the Ultimate [3]<p>[1] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20091206042608&#x2F;http:&#x2F;&#x2F;projectfortress.sun.com&#x2F;Projects&#x2F;Community&#x2F;blog&#x2F;ObjectOrientedTailRecursion" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20091206042608&#x2F;http:&#x2F;&#x2F;projectfor...</a><p>[2] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~wcook&#x2F;Drafts&#x2F;2009&#x2F;essay.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~wcook&#x2F;Drafts&#x2F;2009&#x2F;essay.pdf</a><p>[3] <a href="http:&#x2F;&#x2F;lambda-the-ultimate.org&#x2F;node&#x2F;3702" rel="nofollow">http:&#x2F;&#x2F;lambda-the-ultimate.org&#x2F;node&#x2F;3702</a></div><br/><div id="39920505" class="c"><input type="checkbox" id="c-39920505" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919650">parent</a><span>|</span><a href="#39922743">next</a><span>|</span><label class="collapse" for="c-39920505">[-]</label><label class="expand" for="c-39920505">[1 more]</label></div><br/><div class="children"><div class="content">Sure, or just add a polymorphic functor to walk a tree autonomously.<p>There are shorter ways to admit you already sold your soul. lol =)</div><br/></div></div></div></div><div id="39922743" class="c"><input type="checkbox" id="c-39922743" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919268">parent</a><span>|</span><a href="#39919650">prev</a><span>|</span><a href="#39920580">next</a><span>|</span><label class="collapse" for="c-39922743">[-]</label><label class="expand" for="c-39922743">[1 more]</label></div><br/><div class="children"><div class="content">This limitation doesnât just proscribe traditional recursive algorithms: Any reentrancy is impossible.<p>Your threads, co-routines, interrupt handlers, error handlers, all have to be careful not to stomp on someone elseâs use of the same function, even if theyâre not directly using a function recursively.</div><br/></div></div><div id="39920580" class="c"><input type="checkbox" id="c-39920580" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919268">parent</a><span>|</span><a href="#39922743">prev</a><span>|</span><a href="#39919305">next</a><span>|</span><label class="collapse" for="c-39920580">[-]</label><label class="expand" for="c-39920580">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting because I love using Haskell in a stable production environment.  In fact I&#x27;d hate to use anything else!<p>On the other hand, I almost never use naked recursion in Haskell.  It typically do recursion indirectly through more familiar combinators such as for loops.</div><br/><div id="39920694" class="c"><input type="checkbox" id="c-39920694" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39920580">parent</a><span>|</span><a href="#39919305">next</a><span>|</span><label class="collapse" for="c-39920694">[-]</label><label class="expand" for="c-39920694">[1 more]</label></div><br/><div class="children"><div class="content">I like Haskell in many ways as it shifts ones perspectives, but it is just way too easy to leave unpredictable behaviors unconstrained. =)</div><br/></div></div></div></div><div id="39919305" class="c"><input type="checkbox" id="c-39919305" checked=""/><div class="controls bullet"><span class="by">autoexecbat</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919268">parent</a><span>|</span><a href="#39920580">prev</a><span>|</span><a href="#39921036">next</a><span>|</span><label class="collapse" for="c-39919305">[-]</label><label class="expand" for="c-39919305">[32 more]</label></div><br/><div class="children"><div class="content">Outside of a university course, if I see recursion in a non-FP language I consider it a code-smell</div><br/><div id="39919684" class="c"><input type="checkbox" id="c-39919684" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919305">parent</a><span>|</span><a href="#39920159">next</a><span>|</span><label class="collapse" for="c-39919684">[-]</label><label class="expand" for="c-39919684">[26 more]</label></div><br/><div class="children"><div class="content">This opinion is totally wild to me.<p>Do you never work with tree data structures?<p>I can&#x27;t think of a non-trivial program I&#x27;ve written in the past two decades that didn&#x27;t have some recursive tree traversal in it.</div><br/><div id="39927773" class="c"><input type="checkbox" id="c-39927773" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919684">parent</a><span>|</span><a href="#39922172">next</a><span>|</span><label class="collapse" for="c-39927773">[-]</label><label class="expand" for="c-39927773">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you never work with tree data structures?<p>Yes, you can use std::vector or array or similar as a stack, without using recursion (which has some easily reachable depth limit that is much smaller than what your full RAM memory allows, especially in e.g. JS)<p>Of course ideally programming languages would figure out a way to not have this reachable limit and allow as much recursion as your RAM allows... We&#x27;re still in the ancient world when it comes to this, it seems</div><br/></div></div><div id="39922172" class="c"><input type="checkbox" id="c-39922172" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919684">parent</a><span>|</span><a href="#39927773">prev</a><span>|</span><a href="#39921604">next</a><span>|</span><label class="collapse" for="c-39922172">[-]</label><label class="expand" for="c-39922172">[1 more]</label></div><br/><div class="children"><div class="content">I think there are a lot of web devs here who never do anything more complicated than process data in a loop, and complexity analysis can be accomplished by counting indentation levels.  When this viewpoint is applied with a wide brush to all programmers or the whole practice of programming, it results in some pretty spicy takes.<p>On the other hand, recursion extremely expensive in some languages and Python has a notorious limit that forces library writers to roll their own stack.  So despite the above, I&#x27;m actually in the anti-recursion camp.</div><br/></div></div><div id="39921604" class="c"><input type="checkbox" id="c-39921604" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919684">parent</a><span>|</span><a href="#39922172">prev</a><span>|</span><a href="#39919945">next</a><span>|</span><label class="collapse" for="c-39921604">[-]</label><label class="expand" for="c-39921604">[19 more]</label></div><br/><div class="children"><div class="content">Recursion in production code is bad news, because you can&#x27;t control the depth of your call tree.<p>At some point you will crash because the runtime won&#x27;t be able to allocate any more stack. And you can&#x27;t preflight it because if you could preflight it you wouldn&#x27;t be doing recursion.<p>Recursion is a nice toy, but in real life it&#x27;s a ticking time bomb.</div><br/><div id="39922738" class="c"><input type="checkbox" id="c-39922738" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39921604">parent</a><span>|</span><a href="#39924084">next</a><span>|</span><label class="collapse" for="c-39922738">[-]</label><label class="expand" for="c-39922738">[9 more]</label></div><br/><div class="children"><div class="content">This is just bananas. I work in programming languages.<p>I currently have open in my editor a code formatter that I maintain that uses at least half a dozen recursive algorithms to traverse syntax trees and other data structures. This program is used by almost every user of our language, invoked on every save, and probably executed billions of times a day.<p>Recursion is <i>fine</i>.</div><br/><div id="39923331" class="c"><input type="checkbox" id="c-39923331" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39922738">parent</a><span>|</span><a href="#39924084">next</a><span>|</span><label class="collapse" for="c-39923331">[-]</label><label class="expand" for="c-39923331">[8 more]</label></div><br/><div class="children"><div class="content">&quot;Recursion is fine [for your use-case].&quot;<p>In general it is naive, often dangerous, and an inefficient space&#x2F;time trade-off.<p>I have been writing software for several decades... does that make one less insightful or more biased?<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;pmu5sRIizdw?feature=shared&amp;t=31" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;pmu5sRIizdw?feature=shared&amp;t=31</a><p>=)</div><br/><div id="39923949" class="c"><input type="checkbox" id="c-39923949" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39923331">parent</a><span>|</span><a href="#39924286">next</a><span>|</span><label class="collapse" for="c-39923949">[-]</label><label class="expand" for="c-39923949">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to make a generalization, I think recursion is fine, efficient, and rarely dangerous.<p>There may be use cases where it&#x27;s insecure or has performance concerns, but those are the exception. Most of the time, it&#x27;s fine.<p>We don&#x27;t generally tell programmers that loops are naive, often dangerous, and risk locking up the program. They certainly can, but most just... don&#x27;t.<p>Just like loops, recursion can make code much simpler to write, read, and maintain. Every modern language under the sun supports it for very good reasons. Use it.</div><br/><div id="39924216" class="c"><input type="checkbox" id="c-39924216" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39923949">parent</a><span>|</span><a href="#39924286">next</a><span>|</span><label class="collapse" for="c-39924216">[-]</label><label class="expand" for="c-39924216">[1 more]</label></div><br/><div class="children"><div class="content">For many reasons, people often add nesting limits in recursive structures to at least constrain how bad they behave when something eventually does go wrong.<p>Parsers are far from immune to these issues.<p>I think we will have to &quot;agree to disagree&quot; here... =)</div><br/></div></div></div></div><div id="39924286" class="c"><input type="checkbox" id="c-39924286" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39923331">parent</a><span>|</span><a href="#39923949">prev</a><span>|</span><a href="#39924084">next</a><span>|</span><label class="collapse" for="c-39924286">[-]</label><label class="expand" for="c-39924286">[5 more]</label></div><br/><div class="children"><div class="content">For a fun time, make a nested json blob about 1000 layers deep[1] and in python:<p><pre><code>  with open(&#x27;lulz.json&#x27;) as ayy_lmao:
      oops = json.load(ayy_lmao)
</code></pre>
If you parse arbitrary json bytes from the Internet (for example, if you have some public Python API with no auth) then you have given the world a fun little stacktrace generator, and a way to lessen your server room&#x27;s heating bill.<p>EDIT: btw you can do the same thing in rust&#x27;s serde_json if the type you&#x27;re deserializing into somehow supports the nesting, but you&#x27;d have to work for it.<p>EDIT2: the only (decent) way I can think to mitigate this in the python app&#x27;s case is to enforce a sufficiently restrictive Content-Length at the edge, which obviously isn&#x27;t possible of you expect blobs O(100Kb) uncompressed. Or you could pre-parse to detect nesting.<p>[1] EDIT3: on my machine in ipython right now it&#x27;s 1485:<p><pre><code>  import json

  def nest(d):
      return &#x27;{&quot;k&quot;:&#x27; + str(d) + &#x27;}&#x27;

  def make_mess(n):
      v = 1
      for _ in range(n):
          v = nest(v)
      return v

  json.loads(make_mess(1485))  # boom</code></pre></div><br/><div id="39924637" class="c"><input type="checkbox" id="c-39924637" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924286">parent</a><span>|</span><a href="#39924444">next</a><span>|</span><label class="collapse" for="c-39924637">[-]</label><label class="expand" for="c-39924637">[3 more]</label></div><br/><div class="children"><div class="content">Parsing untrusted input on a machine where failure could affect someone other than the person who provided the input is definitely a known case to be mindful of.<p>You&#x27;ll want to cap the maximum allowed nesting depth. Even if not using recursion, you probably don&#x27;t want untrusted input to be able to make your stack data structure allocate arbitrary amounts of memory.<p>If you do put a nesting limit in, you can do that equally well using an actual stack or recursion. (For example, I believe v8 still uses recursive descent for parsing JSON and JavaScript. It detects and handles stack overflows to ensure that untrusted input can&#x27;t blow the stack and crash. I&#x27;m not sure if it&#x27;s using  a hardcoded nesting limit or actually trapping the stack&#x2F;heap collision somehow.)</div><br/><div id="39924898" class="c"><input type="checkbox" id="c-39924898" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924637">parent</a><span>|</span><a href="#39924874">next</a><span>|</span><label class="collapse" for="c-39924898">[-]</label><label class="expand" for="c-39924898">[1 more]</label></div><br/><div class="children"><div class="content">Yes, unfortunately in the python case the standard library&#x27;s json parser has no way to configure a reasonable limit. It&#x27;ll just consume stack frames until it hits the interpeter&#x27;s recursion limit. And, as has been mentioned elsewhere, python stack frames are expensive for a variety of reasons.<p>I&#x27;ve run into similar issues with recursive code in java. The story gets better in C or rust, but there wre still sharp edges. I guess there are sharp edges everywhere though...</div><br/></div></div><div id="39924874" class="c"><input type="checkbox" id="c-39924874" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924637">parent</a><span>|</span><a href="#39924898">prev</a><span>|</span><a href="#39924444">next</a><span>|</span><label class="collapse" for="c-39924874">[-]</label><label class="expand" for="c-39924874">[1 more]</label></div><br/><div class="children"><div class="content">You mean like the reply depth limit in forums like YC.<p>Shouldn&#x27;t you stick to a depth-first branch reply limit until moving to the next fork.<p>I want to respect your beliefs. =)</div><br/></div></div></div></div><div id="39924444" class="c"><input type="checkbox" id="c-39924444" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924286">parent</a><span>|</span><a href="#39924637">prev</a><span>|</span><a href="#39924084">next</a><span>|</span><label class="collapse" for="c-39924444">[-]</label><label class="expand" for="c-39924444">[1 more]</label></div><br/><div class="children"><div class="content">In general, most json&#x2F;bson parsers like libbson have a rather shallow depth restriction (xerces also constrains this if I recall.)<p>And yeah, recursion is avoided in some shops for good reasons.</div><br/></div></div></div></div></div></div></div></div><div id="39924084" class="c"><input type="checkbox" id="c-39924084" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39921604">parent</a><span>|</span><a href="#39922738">prev</a><span>|</span><a href="#39922264">next</a><span>|</span><label class="collapse" for="c-39924084">[-]</label><label class="expand" for="c-39924084">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Recursion in production code is bad news, because you can&#x27;t control the depth of your call tree.<p>Of course you can, <i>if you wanted to</i>, just like you can control the iteration count of a loop. It&#x27;s not even hard. This is simply a non-issue.<p>Some algorithms are much more naturally expressed recursively and writing the imperative equivalent with manual stack handling is just annoying. Stack growth is just something you don&#x27;t have to worry about for almost all scenarios you&#x27;re likely to encounter.</div><br/><div id="39924744" class="c"><input type="checkbox" id="c-39924744" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924084">parent</a><span>|</span><a href="#39925551">next</a><span>|</span><label class="collapse" for="c-39924744">[-]</label><label class="expand" for="c-39924744">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is simply a non-issue.<p>Well, it&#x27;s about the tradeoffs right? If I have a recursive algorithm that&#x27;s growing the stack (assuming no TCO, because few languages people actually use in production support it) I&#x27;m trading execution time, space, and reliability for economy of expression. In reverse order:<p>- reliability: if, as you suggest, I implement some hard depth limit (which is necessary because all the processes which are running concurrently need to not exceed my max stack depth), and assuming generally that things grow over time (more users, more concurrent processes, more recursive calls needed to get the job done) we face two issues. (1) theres a complicated relationship between the maximum number of concurrent processes and the maximum allowable recursion depth. Getting it wrong could crash the entire program! If this is a web server that&#x27;s means we just killed a whole bunch of connections all at once. (2) eventually, over time, we&#x27;ll need to raise the recursion limit, which entails rebalancing the concurrency limit. Hard walls like this are bad news in systems. If instead this was implemented iteratively the system would degrade softly as the iteration count grows--each process would take longer to complete, but they&#x27;d still all complete. Assuming I&#x27;m monitoring process execution time I can predict and respond to this proactively instead of being faced with an emergency where the system is just completely broken.<p>- space: this is obvious I guess, more stack frames == more memory. The problem is worse in some languages than others.<p>- time: this may be less obvious, and there may be optimizations which render it false, but generally in my experience iterative code gets pipelined better and runs quicker.<p>&gt; Stack growth is just something you don&#x27;t have to worry about for almost all scenarios you&#x27;re likely to encounter.<p>I guess that depends on the situation. I&#x27;ve encountered hard walls and performance issues from recursion enough times in my career thus far that I make the extra effort to avoid it. I could totally see the value, though, in areas where you know ahead of time how the recursion depth will scale over time. More often than not, though, that&#x27;s unknowable at implementation time so better err on the side of caution.<p>EDIT: upon re-reading this I think it might have been clearer if I insted wrote &quot;task&quot; every time I wrote &quot;process&quot;--I&#x27;m not talking specifically about any OS feature.</div><br/><div id="39925848" class="c"><input type="checkbox" id="c-39925848" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924744">parent</a><span>|</span><a href="#39925267">next</a><span>|</span><label class="collapse" for="c-39925848">[-]</label><label class="expand" for="c-39925848">[2 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re overthinking it. Here are probably the people who need to worry about recursion depth: embedded developers working with limited memory, and developers working on data systems that process huge data sets (and even this is debatable as stack growth is log n with these tree data structures).<p>My process for deciding when to use iteration or recursion is simple: if each step needs to keep context then use recursion, otherwise use iteration (unless recursion with TCO is the native idiom of course).<p>I&#x27;ve never had an issue that wasn&#x27;t an obvious bug that iteration would have somehow solved. If any bug that terminated a thread was fatal to the whole process then I suggest the thread termination handler should handle this more gracefully.<p>Increased space usage is a non-issue IMO. Translating a stack frame to a data structure you manage as an explicit stack requires the same space within a small constant factor.<p>And an oft-ignored factor is the cleanup advantages of allocating on the stack, which offsets any space and time disadvantages you might see with recursion.</div><br/><div id="39926726" class="c"><input type="checkbox" id="c-39926726" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39925848">parent</a><span>|</span><a href="#39925267">next</a><span>|</span><label class="collapse" for="c-39926726">[-]</label><label class="expand" for="c-39926726">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think you&#x27;re overthinking it<p>Quite likely :)<p>&gt; And an oft-ignored factor is the cleanup advantages of allocating on the stack, which offsets any space and time disadvantages you might see with recursion.<p>This is a very good point.<p>Alright, you&#x27;ve convinced me to start playing with recursion again. Just not in java or python.</div><br/></div></div></div></div><div id="39925267" class="c"><input type="checkbox" id="c-39925267" checked=""/><div class="controls bullet"><span class="by">furyofantares</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924744">parent</a><span>|</span><a href="#39925848">prev</a><span>|</span><a href="#39925551">next</a><span>|</span><label class="collapse" for="c-39925267">[-]</label><label class="expand" for="c-39925267">[2 more]</label></div><br/><div class="children"><div class="content">They were referring to algorithms that need to use that much space either way and where the alternative is maintaining your own stack.</div><br/><div id="39925448" class="c"><input type="checkbox" id="c-39925448" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39925267">parent</a><span>|</span><a href="#39925551">next</a><span>|</span><label class="collapse" for="c-39925448">[-]</label><label class="expand" for="c-39925448">[1 more]</label></div><br/><div class="children"><div class="content">Even in that case there&#x27;s a tradeoff, if that stack needs to be large you can maintain it on the heap. Now you can do that to some extent with either a recursive implementation or not of course, but it&#x27;s still a matter of deciding which is the better approach. It&#x27;s not simply the case that &quot;you can always just use recursion and it&#x27;ll be totally fine mostly&quot;.</div><br/></div></div></div></div></div></div><div id="39925551" class="c"><input type="checkbox" id="c-39925551" checked=""/><div class="controls bullet"><span class="by">EnigmaFlare</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924084">parent</a><span>|</span><a href="#39924744">prev</a><span>|</span><a href="#39924610">next</a><span>|</span><label class="collapse" for="c-39925551">[-]</label><label class="expand" for="c-39925551">[1 more]</label></div><br/><div class="children"><div class="content">That sounds awfully complicated modifying a recursive algorithm to control the recursion depth. By that, I mean, if sometimes the data happens to be a very deep unbalanced tree that would cause a stack overflow with a naive recursive algorithm, you detect that situation and make it work. Isn&#x27;t that much harder than just using your own stack (from a library&#x2F;framework)?</div><br/></div></div><div id="39924610" class="c"><input type="checkbox" id="c-39924610" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39924084">parent</a><span>|</span><a href="#39925551">prev</a><span>|</span><a href="#39922264">next</a><span>|</span><label class="collapse" for="c-39924610">[-]</label><label class="expand" for="c-39924610">[1 more]</label></div><br/><div class="children"><div class="content">From my perspective, the main issue it causes (besides flood risks) is an overlapping state dependency that can process-bind large areas of fragmented memory.<p>So, if you try to unroll naive recursive code, than one wins n-many issues instead of 1 predictably separable one. Sure one could pass in a mutex etc., but it is back to using a global again and a single-core bounded context.<p>Best of luck, =)</div><br/></div></div></div></div><div id="39922264" class="c"><input type="checkbox" id="c-39922264" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39921604">parent</a><span>|</span><a href="#39924084">prev</a><span>|</span><a href="#39919945">next</a><span>|</span><label class="collapse" for="c-39922264">[-]</label><label class="expand" for="c-39922264">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using some sort of balanced tree (red-black, AVL or a b-tree of some sort), the depth of the tree is guaranteed to be log(n) where n is the number of items. If you recursively descend down the tree, the number of stack frames involved will never exceed the height of the tree.<p>If you have a binary tree with 1 billion elements, the depth will be 20. In a b-tree with a reasonable node width (eg 16), assuming 50% occupancy the depth will be about 8.<p>This is, in practice, totally fine. You won&#x27;t exhaust your stack traversing a balanced tree.</div><br/></div></div></div></div><div id="39919945" class="c"><input type="checkbox" id="c-39919945" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919684">parent</a><span>|</span><a href="#39921604">prev</a><span>|</span><a href="#39922725">next</a><span>|</span><label class="collapse" for="c-39919945">[-]</label><label class="expand" for="c-39919945">[3 more]</label></div><br/><div class="children"><div class="content">Tree traversal uses stacks &#x2F; queues unless you&#x27;re dealing with a small tree such that you&#x27;re sure recursion won&#x27;t blow your stack, or your algorithm can work with tail calls and your language guarantees TCO.</div><br/><div id="39922315" class="c"><input type="checkbox" id="c-39922315" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919945">parent</a><span>|</span><a href="#39922725">next</a><span>|</span><label class="collapse" for="c-39922315">[-]</label><label class="expand" for="c-39922315">[2 more]</label></div><br/><div class="children"><div class="content">Any balanced tree will be shallow enough that this isn&#x27;t a problem in practice. You&#x27;ll run out of RAM &#x2F; hard disk space to store your tree before you run out of stack space.</div><br/><div id="39922615" class="c"><input type="checkbox" id="c-39922615" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39922315">parent</a><span>|</span><a href="#39922725">next</a><span>|</span><label class="collapse" for="c-39922615">[-]</label><label class="expand" for="c-39922615">[1 more]</label></div><br/><div class="children"><div class="content">There are lots of trees that can&#x27;t be balanced, like tries.</div><br/></div></div></div></div></div></div><div id="39922725" class="c"><input type="checkbox" id="c-39922725" checked=""/><div class="controls bullet"><span class="by">hehhehaha</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919684">parent</a><span>|</span><a href="#39919945">prev</a><span>|</span><a href="#39920159">next</a><span>|</span><label class="collapse" for="c-39922725">[-]</label><label class="expand" for="c-39922725">[1 more]</label></div><br/><div class="children"><div class="content">Tree traversal almost never makes use of tail call recursion. Also, most of the times, you can just use a stack object instead of the program stack which saves you from insane stacktraces, arbitrary stack limits, and a bunch of wasted memory in call frames</div><br/></div></div></div></div><div id="39920159" class="c"><input type="checkbox" id="c-39920159" checked=""/><div class="controls bullet"><span class="by">nerpderp82</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919305">parent</a><span>|</span><a href="#39919684">prev</a><span>|</span><a href="#39919701">next</a><span>|</span><label class="collapse" for="c-39920159">[-]</label><label class="expand" for="c-39920159">[2 more]</label></div><br/><div class="children"><div class="content">Recursion is like an inductive proof, you can show it is correct and it normally fits on half of a small screen.</div><br/><div id="39920546" class="c"><input type="checkbox" id="c-39920546" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39920159">parent</a><span>|</span><a href="#39919701">next</a><span>|</span><label class="collapse" for="c-39920546">[-]</label><label class="expand" for="c-39920546">[1 more]</label></div><br/><div class="children"><div class="content">There is an argument that all recursive proofs can be made iterative due to isomorphism.<p>You are not lazy enough to be a good programmer yet. ;-)</div><br/></div></div></div></div><div id="39919701" class="c"><input type="checkbox" id="c-39919701" checked=""/><div class="controls bullet"><span class="by">II2II</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919305">parent</a><span>|</span><a href="#39920159">prev</a><span>|</span><a href="#39919642">next</a><span>|</span><label class="collapse" for="c-39919701">[-]</label><label class="expand" for="c-39919701">[2 more]</label></div><br/><div class="children"><div class="content">While I am not a fan of recursion, the call stack that enables it sounds infinitely better than statically allocating space for parameters and return values. Besides, it makes some algorithms clearer. That is certainly useful in learning environments, including early academic research.</div><br/><div id="39920637" class="c"><input type="checkbox" id="c-39920637" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919701">parent</a><span>|</span><a href="#39919642">next</a><span>|</span><label class="collapse" for="c-39920637">[-]</label><label class="expand" for="c-39920637">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the CPU, in some architectures the stack pointers had low finite capacity before overflowing.</div><br/></div></div></div></div><div id="39919642" class="c"><input type="checkbox" id="c-39919642" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919305">parent</a><span>|</span><a href="#39919701">prev</a><span>|</span><a href="#39921036">next</a><span>|</span><label class="collapse" for="c-39919642">[-]</label><label class="expand" for="c-39919642">[1 more]</label></div><br/><div class="children"><div class="content">The only time I ever do it is for tree walking, and then it&#x27;s always a private internal function, so like:<p><pre><code>    def process_that_tree(my_tree):
      def _handle(node):
        # do the things
        for child in node.children:
          _handle(child)
      _handle(my_tree.root)
</code></pre>
The processing can even be brought outside sometimes, or the walker can just become a generator, yielding nodes out to a regular loop doing the actual work. Either way, the recursive part is kept very minimal and easy to reason about.<p>Obviously for the filesystem these kinds of abstractions exist already in shutil&#x2F;pathlib&#x2F;glob, but it still can have a place for dealing with other kinds of hierarchies, like a package dependency tree or the like.</div><br/></div></div></div></div><div id="39921036" class="c"><input type="checkbox" id="c-39921036" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39919268">parent</a><span>|</span><a href="#39919305">prev</a><span>|</span><a href="#39920027">next</a><span>|</span><label class="collapse" for="c-39921036">[-]</label><label class="expand" for="c-39921036">[6 more]</label></div><br/><div class="children"><div class="content">I agree. People love making things clever instead of making things done.<p>Recursion for iteration is just more complicated iteration. I&#x27;ve never seen a good argument for it in modern programming, it just ends up being the classic backwards rationalization of something people want to believe.<p>Recursion for traversing a tree is just using the call stack as a stack data structure.<p>Any balanced tree is never going to exceed 64 levels deep (really 48 on a 48 bit memory addressing cpu) and that could easily be put in a static array that gets used as a stack without recursing. This is easier to limit and debug.</div><br/><div id="39922676" class="c"><input type="checkbox" id="c-39922676" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39921036">parent</a><span>|</span><a href="#39921652">next</a><span>|</span><label class="collapse" for="c-39922676">[-]</label><label class="expand" for="c-39922676">[2 more]</label></div><br/><div class="children"><div class="content">To my poor eyes it&#x27;s creating self sustaining computing blocks.<p>You could recurse using an explicit stack or use tiny function that will thread themselves as see fit.<p>In a way it&#x27;s more encapsulating than languages preaching encapsulation.</div><br/><div id="39923830" class="c"><input type="checkbox" id="c-39923830" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39922676">parent</a><span>|</span><a href="#39921652">next</a><span>|</span><label class="collapse" for="c-39923830">[-]</label><label class="expand" for="c-39923830">[1 more]</label></div><br/><div class="children"><div class="content">Are you saying recursion creates <i>&quot;self sustaining computing blocks&quot; ?  What does that mean and how does it do it?<p></i>that will thread themselves as see fit.*<p>What does this mean?<p><i>In a way it&#x27;s more encapsulating than languages preaching encapsulation.</i><p>Recursion does this? Are you talking about not depending on a stack structure in this specific instance or something else?</div><br/></div></div></div></div><div id="39921652" class="c"><input type="checkbox" id="c-39921652" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39921036">parent</a><span>|</span><a href="#39922676">prev</a><span>|</span><a href="#39920027">next</a><span>|</span><label class="collapse" for="c-39921652">[-]</label><label class="expand" for="c-39921652">[3 more]</label></div><br/><div class="children"><div class="content">The same argument suggests that a recursive stack traversal will never consume more than 64 stack frames, so consuming stack frames is no reason not to use a recursive function.<p>It&#x27;s just as easy to limit recursion depth, if you need to, just pass along a counter and check it.  I haven&#x27;t found that hand-rolling a second stack, instead of using the program stack, is easier to debug, the opposite if anything, but your mileage may vary on that one.</div><br/><div id="39923352" class="c"><input type="checkbox" id="c-39923352" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39921652">parent</a><span>|</span><a href="#39920027">next</a><span>|</span><label class="collapse" for="c-39923352">[-]</label><label class="expand" for="c-39923352">[2 more]</label></div><br/><div class="children"><div class="content"><i>so consuming stack frames is no reason not to use a recursive function.</i><p>Saving stack memory isn&#x27;t the point (even though a static array definitely does, because instead of multiple pointers and variables on the stack it only would have to store the node index of a tree).<p>The point is that you can see the whole stack and all the data that you&#x27;re using at one time in a debugger instead of trying switch through call stacks to find data.</div><br/><div id="39927597" class="c"><input type="checkbox" id="c-39927597" checked=""/><div class="controls bullet"><span class="by">sham1</span><span>|</span><a href="#39919126">root</a><span>|</span><a href="#39923352">parent</a><span>|</span><a href="#39920027">next</a><span>|</span><label class="collapse" for="c-39927597">[-]</label><label class="expand" for="c-39927597">[1 more]</label></div><br/><div class="children"><div class="content">Well, it&#x27;s still recursion whether you&#x27;re using the call stack or are using an explicit stack structure. You&#x27;re still breaking the problem down into smaller subproblems inductively. I feel that people focus on the wrong things when talking about recursion, focusing on the aspect of having a function calling itself instead of the idea of having the problem solved by way of breaking it down into smaller problems.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39920027" class="c"><input type="checkbox" id="c-39920027" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#39919126">prev</a><span>|</span><a href="#39921674">next</a><span>|</span><label class="collapse" for="c-39920027">[-]</label><label class="expand" for="c-39920027">[4 more]</label></div><br/><div class="children"><div class="content">For the kind of programs I write for AVR-8 it seems insane to use the calling conventions of C, so if I write assembly I can sometimes keep the inner loop variables in registers (big register file) and otherwise use the methods he describes.  I like âcoloringâ functions in an app like that, if I know a red and a green function will never be active at once I can reuse locals&#x2F;parameters for them.</div><br/><div id="39920272" class="c"><input type="checkbox" id="c-39920272" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#39920027">parent</a><span>|</span><a href="#39921674">next</a><span>|</span><label class="collapse" for="c-39920272">[-]</label><label class="expand" for="c-39920272">[3 more]</label></div><br/><div class="children"><div class="content">Yes, C&#x27;s stack usage can be unintuitive when working in a constrained environment, especially when accustomed to the affordances of desktop operating system. I once joined a project where several developers had spent a couple weeks trying to track really hard to pin down bugs in several subsystems they were developing in a microcontroller codebase. They would move things around and the bugs would move. After tracing things a bit and setting a trap, I found the places in the codebase where the call stack got too deep and was scribbling over other data structures.</div><br/><div id="39921362" class="c"><input type="checkbox" id="c-39921362" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#39920027">root</a><span>|</span><a href="#39920272">parent</a><span>|</span><a href="#39920793">next</a><span>|</span><label class="collapse" for="c-39921362">[-]</label><label class="expand" for="c-39921362">[1 more]</label></div><br/><div class="children"><div class="content">Recursion is a bad thing in embedded systems and generally overrated in CS pedagogy.<p>It can be useful in analyzing algorithms but often in cases like search it is a &quot;second best&quot; answer compared to say,  using nondeterminism.</div><br/></div></div><div id="39920793" class="c"><input type="checkbox" id="c-39920793" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39920027">root</a><span>|</span><a href="#39920272">parent</a><span>|</span><a href="#39921362">prev</a><span>|</span><a href="#39921674">next</a><span>|</span><label class="collapse" for="c-39920793">[-]</label><label class="expand" for="c-39920793">[1 more]</label></div><br/><div class="children"><div class="content">Putting a `out-of-stack? branch` check in every function prolog made an embedded chip programmed in C much nicer to work with. Cost a few instructions which was contentious but definitely a development aid.</div><br/></div></div></div></div></div></div><div id="39921674" class="c"><input type="checkbox" id="c-39921674" checked=""/><div class="controls bullet"><span class="by">HeyLaughingBoy</span><span>|</span><a href="#39920027">prev</a><span>|</span><a href="#39926579">next</a><span>|</span><label class="collapse" for="c-39921674">[-]</label><label class="expand" for="c-39921674">[11 more]</label></div><br/><div class="children"><div class="content">A long time ago (1991 maybe?) one of my first freelance projects during my first job out of college was to design an RS232 serial multiplexer -- take an incoming serial datastream, parse it, and redirect it to one of n outputs based on its header.<p>I remember doing something similar to what he describes. My hardware design was basically a Z80, a 2716 EPROM (I may have also had a Parallax EPROM emulator to speed debugging) and a couple of Z80-SIO serial devices. Notice that there is no SRAM chip :-)<p>The Z80 has enough registers that I could hold all the data I needed internally so I decided against the extra cost of RAM. This was the early 90&#x27;s, remember. The one thing I was missing was a stack to make function calls. This was done (memory is fuzzy here) by preloading the return address onto a register pair and then calling the function. When the function was done, it would do an indirect jump to the location held in that register pair, which would return to the next instruction after the call.<p>I don&#x27;t remember how I passed and returned values, but I probably dedicated a register to that. I have a couple of old hard drives around here somewhere. I should see if I saved the code anywhere; I was quite proud of it.</div><br/><div id="39923121" class="c"><input type="checkbox" id="c-39923121" checked=""/><div class="controls bullet"><span class="by">billforsternz</span><span>|</span><a href="#39921674">parent</a><span>|</span><a href="#39924075">next</a><span>|</span><label class="collapse" for="c-39923121">[-]</label><label class="expand" for="c-39923121">[2 more]</label></div><br/><div class="children"><div class="content">That is very cool and I say that as someone whose first project in my first job (1982) was to write the code for a serial multiplexer with a Z80, a 2716 EPROM, Zilog SIOs (or maybe DUARTs actually).... and 2K of static RAM. I basically learned my craft on the job and there&#x27;s no way I could have done it without the RAM. A few years later I would have relished the challenge. Although you are really limiting the complexity of the protocol you can deal with ... (perhaps not such a terrible thing:).</div><br/><div id="39925578" class="c"><input type="checkbox" id="c-39925578" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#39921674">root</a><span>|</span><a href="#39923121">parent</a><span>|</span><a href="#39924075">next</a><span>|</span><label class="collapse" for="c-39925578">[-]</label><label class="expand" for="c-39925578">[1 more]</label></div><br/><div class="children"><div class="content">Writing code for the old Mac serial chip was an adventure.<p>I wrote a MIDI driver once, and that required dividing a 1MHz external clock, to get the 62.5KHz (I think) serial clock (you couldnât divide the internal clock).<p>Their chip had 8 control lines, with each line controlling some aspect of the chip operation. They set it up as the lower 8 bits of the 16-bit address bus, with the upper 8 bits fixed (so you were working with 256 addresses, to control the chip).<p>So just referencing an address would change the state of the chip.<p>A lot of hardware limitations influenced software structure, and Iâll bet that a lot of software proclivities have their genesis in weird hardware compromises (like bytes).</div><br/></div></div></div></div><div id="39924075" class="c"><input type="checkbox" id="c-39924075" checked=""/><div class="controls bullet"><span class="by">RiverCrochet</span><span>|</span><a href="#39921674">parent</a><span>|</span><a href="#39923121">prev</a><span>|</span><a href="#39922328">next</a><span>|</span><label class="collapse" for="c-39924075">[-]</label><label class="expand" for="c-39924075">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This was done (memory is fuzzy here) by preloading the return address onto a register pair and then calling the function. When the function was done, it would do an indirect jump to the location held in that register pair, which would return to the next instruction after the call.<p>This is pretty much what the MIPS `jal` and ARM `BL` do.  TMS9900 also did something similar (edit: it had a `BL` instruction too.)<p>I was fascinated by the fact the Signetics 2650 that had an 8-byte internal stack.</div><br/></div></div><div id="39922328" class="c"><input type="checkbox" id="c-39922328" checked=""/><div class="controls bullet"><span class="by">Sponge5</span><span>|</span><a href="#39921674">parent</a><span>|</span><a href="#39924075">prev</a><span>|</span><a href="#39923172">next</a><span>|</span><label class="collapse" for="c-39922328">[-]</label><label class="expand" for="c-39922328">[1 more]</label></div><br/><div class="children"><div class="content">You should be proud of it, I can&#x27;t even begin to think about programming with these constraints, and I work in embedded.</div><br/></div></div><div id="39923172" class="c"><input type="checkbox" id="c-39923172" checked=""/><div class="controls bullet"><span class="by">smcin</span><span>|</span><a href="#39921674">parent</a><span>|</span><a href="#39922328">prev</a><span>|</span><a href="#39923523">next</a><span>|</span><label class="collapse" for="c-39923172">[-]</label><label class="expand" for="c-39923172">[5 more]</label></div><br/><div class="children"><div class="content">&#x27;2716 EPROM&#x27; was a 16K (2kb x 8) EPROM.<p>Which customer&#x2F;sector was your project intended for?</div><br/><div id="39926326" class="c"><input type="checkbox" id="c-39926326" checked=""/><div class="controls bullet"><span class="by">HeyLaughingBoy</span><span>|</span><a href="#39921674">root</a><span>|</span><a href="#39923172">parent</a><span>|</span><a href="#39923302">next</a><span>|</span><label class="collapse" for="c-39926326">[-]</label><label class="expand" for="c-39926326">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t remember. I do remember that I didn&#x27;t get paid.<p>I was so excited to have a freelance job (don&#x27;t remember how I got the customer either) that I jumped right into it and worked heads down for a couple weeks. Then when I went to tell the customer that I was done and ready to ship, I couldn&#x27;t reach him. Finally heard back from him about 6-12 months later and he was surprised that I had been working on it without hearing back from him and that he no longer needed the product.<p>And that, kids, is how I learned to get at least partial payment upfront.</div><br/></div></div><div id="39923302" class="c"><input type="checkbox" id="c-39923302" checked=""/><div class="controls bullet"><span class="by">mytailorisrich</span><span>|</span><a href="#39921674">root</a><span>|</span><a href="#39923172">parent</a><span>|</span><a href="#39926326">prev</a><span>|</span><a href="#39923523">next</a><span>|</span><label class="collapse" for="c-39923302">[-]</label><label class="expand" for="c-39923302">[3 more]</label></div><br/><div class="children"><div class="content">Yes, the xx(x) number in the 27xx(x) EPROM series indicates the kilo (1024) bits. So indeed this is 2 KiB.
This sounds OK for the application described, especially as it was no doubt written in assembly and obviously bare metal. When it does not fit but not far off it&#x27;s when the fun of code optimisation kicks in ;)<p>Edit: Very interesting how easily available they still seem to be according to Google.</div><br/><div id="39926511" class="c"><input type="checkbox" id="c-39926511" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#39921674">root</a><span>|</span><a href="#39923302">parent</a><span>|</span><a href="#39924475">next</a><span>|</span><label class="collapse" for="c-39926511">[-]</label><label class="expand" for="c-39926511">[1 more]</label></div><br/><div class="children"><div class="content">My first personal computer was a Z80 with a 2716.  Into that 2K I fit basic monitor commands (dump&#x2F;store memory), a terminal emulator with VT52 escape sequences, and a floppy boot loader.  Got very good at squeezing out every last byte.</div><br/></div></div><div id="39924475" class="c"><input type="checkbox" id="c-39924475" checked=""/><div class="controls bullet"><span class="by">smcin</span><span>|</span><a href="#39921674">root</a><span>|</span><a href="#39923302">parent</a><span>|</span><a href="#39926511">prev</a><span>|</span><a href="#39923523">next</a><span>|</span><label class="collapse" for="c-39924475">[-]</label><label class="expand" for="c-39924475">[1 more]</label></div><br/><div class="children"><div class="content">Ok I was trying to help you communicate &quot;8-bit CPU which had 14 registers, no RAM, tiny EPROM, no persistent storage&#x2F;disk&#x2F;SSD&quot;. And you were doing function calls.</div><br/></div></div></div></div></div></div></div></div><div id="39926579" class="c"><input type="checkbox" id="c-39926579" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#39921674">prev</a><span>|</span><a href="#39919956">next</a><span>|</span><label class="collapse" for="c-39926579">[-]</label><label class="expand" for="c-39926579">[1 more]</label></div><br/><div class="children"><div class="content">My first exposure to assembly language was one of those computers that used self-modifying code for subroutine calls, the Control Data Cyber 6400.  It had a special instruction (I think it was called RJ) that replaced the first word of the subroutine with a jump instruction back to the caller.  Every function had to start with a special no-op so that it could be replaced, and you returned from a function by jumping back to the beginning.</div><br/></div></div><div id="39919956" class="c"><input type="checkbox" id="c-39919956" checked=""/><div class="controls bullet"><span class="by">elvis70</span><span>|</span><a href="#39926579">prev</a><span>|</span><a href="#39921611">next</a><span>|</span><label class="collapse" for="c-39919956">[-]</label><label class="expand" for="c-39919956">[1 more]</label></div><br/><div class="children"><div class="content">And to think that&#x27;s where we come from. The Intel 8008, the ancestor of the x86 processor family, just has a 7-level call hardware stack only used by the unconditional and conditional call and return instructions. So, there is no push and pop instructions. As the only way to access a byte in memory was to store the address in the HL register pair (no absolute addressing mode) before the load or store instruction and as there was no way to disable hardware interrupts, it was almost impossible to write useful interrupt routines without some external hardware trick.</div><br/></div></div><div id="39921611" class="c"><input type="checkbox" id="c-39921611" checked=""/><div class="controls bullet"><span class="by">le-mark</span><span>|</span><a href="#39919956">prev</a><span>|</span><a href="#39920530">next</a><span>|</span><label class="collapse" for="c-39921611">[-]</label><label class="expand" for="c-39921611">[3 more]</label></div><br/><div class="children"><div class="content">Cobol upto and including the 85 Standard was stackless and heapless which is quite a cognitive divide. For those going to and coming from that language.<p>I didnât read Raymond say anything about security in the present article, but the advantages a clear. No stack or buffer overflow vulnerability for example.</div><br/><div id="39926998" class="c"><input type="checkbox" id="c-39926998" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#39921611">parent</a><span>|</span><a href="#39922514">next</a><span>|</span><label class="collapse" for="c-39926998">[-]</label><label class="expand" for="c-39926998">[1 more]</label></div><br/><div class="children"><div class="content">I remember having to preallocate an array and do manual stack management there.  the old hands told me to &#x27;simply&#x27; use a  disk if I needed the stack (or heap) to be larger.  with the mainframe VM these could then be virtual in the 1980s&#x2F;1990s, &#x27;for performance&#x27;<p>stackless Cobol really did fun things to brains on long term exposure.</div><br/></div></div><div id="39922514" class="c"><input type="checkbox" id="c-39922514" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#39921611">parent</a><span>|</span><a href="#39926998">prev</a><span>|</span><a href="#39920530">next</a><span>|</span><label class="collapse" for="c-39922514">[-]</label><label class="expand" for="c-39922514">[1 more]</label></div><br/><div class="children"><div class="content">Just fixed size static buffers guaranteed to overflow.</div><br/></div></div></div></div><div id="39920530" class="c"><input type="checkbox" id="c-39920530" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#39921611">prev</a><span>|</span><a href="#39924215">next</a><span>|</span><label class="collapse" for="c-39920530">[-]</label><label class="expand" for="c-39920530">[3 more]</label></div><br/><div class="children"><div class="content">Whenever Raymond Chen retires, I am going to be really sad.</div><br/><div id="39920577" class="c"><input type="checkbox" id="c-39920577" checked=""/><div class="controls bullet"><span class="by">abhinavk</span><span>|</span><a href="#39920530">parent</a><span>|</span><a href="#39924215">next</a><span>|</span><label class="collapse" for="c-39920577">[-]</label><label class="expand" for="c-39920577">[2 more]</label></div><br/><div class="children"><div class="content">Why? I feel he will able to write more.</div><br/><div id="39920711" class="c"><input type="checkbox" id="c-39920711" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#39920530">root</a><span>|</span><a href="#39920577">parent</a><span>|</span><a href="#39924215">next</a><span>|</span><label class="collapse" for="c-39920711">[-]</label><label class="expand" for="c-39920711">[1 more]</label></div><br/><div class="children"><div class="content">I mean when he stops writing. Fair enough if he does it for fun afterwards.</div><br/></div></div></div></div></div></div><div id="39924215" class="c"><input type="checkbox" id="c-39924215" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39920530">prev</a><span>|</span><a href="#39920341">next</a><span>|</span><label class="collapse" for="c-39924215">[-]</label><label class="expand" for="c-39924215">[2 more]</label></div><br/><div class="children"><div class="content">This post happens to describe the world of the famous âGoto considered harmfulâ paper.<p>Most people just know the title and simply fetishistically refuse to use a goto (most of the time they are terrible, but not always).  But really the paper argues for giving subroutines a single entry point.<p>Sometimes I write assembly code that falls through into another subroutine, but I donât want all my assembly to be spaghetti like that.</div><br/><div id="39925114" class="c"><input type="checkbox" id="c-39925114" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#39924215">parent</a><span>|</span><a href="#39920341">next</a><span>|</span><label class="collapse" for="c-39925114">[-]</label><label class="expand" for="c-39925114">[1 more]</label></div><br/><div class="children"><div class="content">While those are of the same era, the goto issue was its own whole issue, generally referring to goto statements in a give block of code, and not talking about subroutines.<p>While this, as you note, often led to mass refusal to use a goto, the effect of the paper led to much discussion and presaged the practice of much better control flow constructs in languages.</div><br/></div></div></div></div><div id="39920341" class="c"><input type="checkbox" id="c-39920341" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#39924215">prev</a><span>|</span><a href="#39926512">next</a><span>|</span><label class="collapse" for="c-39920341">[-]</label><label class="expand" for="c-39920341">[2 more]</label></div><br/><div class="children"><div class="content">My first assembly was 6502 which kept a call stack in page 3 (128 levels deep being the maximum call depth as a consequence). When I learned 370 assembly, I remember being shocked to discover that an application was responsible for maintaining its own call stack.</div><br/><div id="39922811" class="c"><input type="checkbox" id="c-39922811" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#39920341">parent</a><span>|</span><a href="#39926512">next</a><span>|</span><label class="collapse" for="c-39922811">[-]</label><label class="expand" for="c-39922811">[1 more]</label></div><br/><div class="children"><div class="content">(Dâoh, not page 3, page <i>one</i>. Page 3 on the Apple ][ was reserved for &amp; handlers and, IIRC page 2 was the input buffer.</div><br/></div></div></div></div><div id="39926512" class="c"><input type="checkbox" id="c-39926512" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39920341">prev</a><span>|</span><a href="#39920666">next</a><span>|</span><label class="collapse" for="c-39926512">[-]</label><label class="expand" for="c-39926512">[1 more]</label></div><br/><div class="children"><div class="content">I was looking through the ROM listing on a really old diskette controller for an S-100 computer, and I saw all those jumps... and didn&#x27;t understand what was going on. Then a friend told me there wasn&#x27;t any guarantee of RAM in any given address, so they used the BX register (if I recall correctly) for the return address.</div><br/></div></div><div id="39920666" class="c"><input type="checkbox" id="c-39920666" checked=""/><div class="controls bullet"><span class="by">JoeAltmaier</span><span>|</span><a href="#39926512">prev</a><span>|</span><a href="#39920394">next</a><span>|</span><label class="collapse" for="c-39920666">[-]</label><label class="expand" for="c-39920666">[2 more]</label></div><br/><div class="children"><div class="content">The old IMB 360 use a &#x27;display&#x27; where you just chose a register by convention, pointed it at some memory then did your own linked list on call and return.<p>In fact call was really jump-and-link(?) where you got the return address in a register. Anticipating that if your subroutine took more than a little code you&#x27;d just store it temporarily in your allocated &#x27;display&#x27;.<p>No push&#x2F;pop at all! Unless you wanted to write it that way. You were just on your own.</div><br/><div id="39925208" class="c"><input type="checkbox" id="c-39925208" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#39920666">parent</a><span>|</span><a href="#39920394">next</a><span>|</span><label class="collapse" for="c-39925208">[-]</label><label class="expand" for="c-39925208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In fact call was really jump-and-link(?)<p>Yes, technically &quot;BALR&quot; for Branch and Link Register. (I knew a guy who had been a 360 assembly language programmer who called his consulting firm BALR consulting, referring to that instruction.)<p>Interestingly, Gene Amdahl was asked why the 360 architecture didn&#x27;t have a stack. &quot;Too expensive&quot; he said. I found this amusing at the time you could buy an 8085 for $5 retail quantity one. Perhaps he meant culturally expensive?</div><br/></div></div></div></div><div id="39920394" class="c"><input type="checkbox" id="c-39920394" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#39920666">prev</a><span>|</span><a href="#39924091">next</a><span>|</span><label class="collapse" for="c-39920394">[-]</label><label class="expand" for="c-39920394">[1 more]</label></div><br/><div class="children"><div class="content">When I was first starting out a very long time ago, I wrote a lot of Fortran (mainly for digital signal processing applications), and a couple of times I had to work around the lack of recursion by building my own stacks for intermediate results, with arrays and a position to keep track of where I was. It was ugly.</div><br/></div></div><div id="39924091" class="c"><input type="checkbox" id="c-39924091" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#39920394">prev</a><span>|</span><a href="#39925778">next</a><span>|</span><label class="collapse" for="c-39924091">[-]</label><label class="expand" for="c-39924091">[3 more]</label></div><br/><div class="children"><div class="content">If it blows your mind to consider the time before call stacks were somewhat the norm in computers, you should look into the time from before register renaming.<p>I don&#x27;t think many people realize just how much of a modern processor is made around supporting preemptive multitasking.  Folks know that we have a class of security bugs from it, but a lot of what happens in a CPU is around juggling multiple workloads.</div><br/><div id="39925326" class="c"><input type="checkbox" id="c-39925326" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#39924091">parent</a><span>|</span><a href="#39925778">next</a><span>|</span><label class="collapse" for="c-39925326">[-]</label><label class="expand" for="c-39925326">[2 more]</label></div><br/><div class="children"><div class="content">In ten years or so all the people who worked on machines without preemptive multitasking will be retired.</div><br/><div id="39927034" class="c"><input type="checkbox" id="c-39927034" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#39924091">root</a><span>|</span><a href="#39925326">parent</a><span>|</span><a href="#39925778">next</a><span>|</span><label class="collapse" for="c-39927034">[-]</label><label class="expand" for="c-39927034">[1 more]</label></div><br/><div class="children"><div class="content">wait what? you&#x27;re right! 386 came 1985, 45 years later is 2030<p>now I feel old</div><br/></div></div></div></div></div></div><div id="39925778" class="c"><input type="checkbox" id="c-39925778" checked=""/><div class="controls bullet"><span class="by">justinlloyd</span><span>|</span><a href="#39924091">prev</a><span>|</span><a href="#39921720">next</a><span>|</span><label class="collapse" for="c-39925778">[-]</label><label class="expand" for="c-39925778">[1 more]</label></div><br/><div class="children"><div class="content">A couple of personal experiences from the ancient world:<p>I wrote code for a microprocessor that did not have a stack as an actual concept. There are still embedded processors out there today like this. To work around this you stored a value at a zero page location, and when you wanted to jump to a subroutine, you would first load up this value from zero-page, advance it, put the program counter into the memory address now pointing to a new memory location, then execute a simple go to, and at the end of your function, to return, you would load up that value in zero page, then load up your return address, decrement your pointer, store it back to zero page, then go to back to the calling function. Every value you wanted to pass to the subroutine would be either in one of your three registers, or you would pass those values by storing them in memory pointed to by your zero page value. The 6502 offers nice instructions to do these very operations, by turning the assembly&#x2F;machine code into microcode that does the exact same thing, but more succinctly.<p>Another trick I used was bank weaving. You only had a limited amount of addressable memory, but you could bank switch ROMs, so you&#x27;d write your code to have it reside at a fixed memory location, and another chunk of code at another fixed memory location in a different ROM bank, then your first code would execute down to a point where it would switch banks based on a condition, and when the other ROM bank switched in, your alternative code path would be waiting for you, you&#x27;d execute that, then switch the ROM bank again back to the first one, and the PC (program counter) will have advanced several hundred bytes possibly, so you&#x27;d return to a point in your code, back in the first ROM bank, that was a completely different point in memory, but still the same calling function.<p>A few years later I used a similar technique on a large text adventure game, a compiler and a word processor, where the core of the program was always resident, but chunks of code could be loaded in at fixed memory locations from disk. So if you ran a spell check, the spell check functions would load in at a known memory location, various bits were set in RAM to indicate which functions were resident, and the application could perform the spell check, or run the logic for a part of the text adventure game. And functions would automatically unload to make room for new functions based on the last time they were invoked.<p>I wrote code for a Timex processor that had a &quot;execute the instruction at the following address&quot; opcode, so effectively your instruction here, would execute that instruction over there, but only for one instruction. It made writing the equivalent of switch&#x2F;case in assembly interesting, and also good for self-modifying code.<p>Zero-page on some old CPUs was a faster RAM, a few dozen bytes, or even 256 bytes, so if you had a tight loop, you&#x27;d copy the code into zero page, perhaps having to move other stuff out of the way first, and execute it there.<p>I wrote a word processor that stored only a tiny fraction of its data in under 3KB of RAM, the rest was stored on big floppy disks. As you scrolled through the text, it would page through the pages (memory pages, not pages of text) on the floppy disc, but the memory pages were not stored continuously, either in RAM or on disk. The RAM acted more like a cache, and a couple of memory pages were reserved for edit operations and even copy &amp; paste. To copy and paste entire pages was fast, you only had to adjust a few pointers in RAM and on disk, plus a few hundred bytes for head and tail page operations so moving large blocks of text around was very fast, and inserting large blocks of text, or even just typing, was very fast, because the buffers were quite small. It was the only word processor I know of that came with a disk defrag operation built in, but the company called it &quot;housekeeping&quot; in the manual with no explanation to the end user of what it was doing. I learned a lot about &quot;don&#x27;t mark that as deleted until you are damn sure the operation is completed and you&#x27;ve verified it worked.&quot;<p>I did a 6507 and Z80 emulator on the MIPS R3000 that ran the code in a very pedestrian way, but as the 6507 or Z80 ran through the code, each memory address was added to a list, and the 6507&#x2F;Z80 opcode found there was translated into an intermediate assembly language, and then I post-processed that intermediate assembly into R3000, which gave me a huge performance boost; post-process dynamic recompilation effectively. I had to do other sneaky things with it too because the original hardware raced the electron beam whereas the target platform just had a big VRAM buffer. Used the same trick to port 6507 code to an early ARM processor for an old handheld too.<p>There&#x27;s a lot of other tricks we used to in the before-times, such as LFSR and LCG to permute game objects in seemingly random patterns, cheating on distance checks by counting the clock cycles between two objects drawn on screen, low-rez bitmaps of the screen to speed up collision detection, compiled graphics&#x2F;sprites, even sprite blitting routines that were hard-coded to specific pixel offsets.</div><br/></div></div><div id="39921720" class="c"><input type="checkbox" id="c-39921720" checked=""/><div class="controls bullet"><span class="by">greesil</span><span>|</span><a href="#39925778">prev</a><span>|</span><a href="#39922901">next</a><span>|</span><label class="collapse" for="c-39921720">[-]</label><label class="expand" for="c-39921720">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not ancient if you still do embedded development</div><br/><div id="39922944" class="c"><input type="checkbox" id="c-39922944" checked=""/><div class="controls bullet"><span class="by">dnedic</span><span>|</span><a href="#39921720">parent</a><span>|</span><a href="#39922901">next</a><span>|</span><label class="collapse" for="c-39922944">[-]</label><label class="expand" for="c-39922944">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on what you classify under embedded. Everything more expensive than a Padauk or newer than PIC will have hardware support for the stack, and also most likely have the heap provided by newlib.</div><br/></div></div></div></div><div id="39922901" class="c"><input type="checkbox" id="c-39922901" checked=""/><div class="controls bullet"><span class="by">mirkodrummer</span><span>|</span><a href="#39921720">prev</a><span>|</span><a href="#39921074">next</a><span>|</span><label class="collapse" for="c-39922901">[-]</label><label class="expand" for="c-39922901">[1 more]</label></div><br/><div class="children"><div class="content">Very unfortunate that the mobile layout of the devblog has so many fixed elements on the side, they are distracting  and canât navigate the page without feeling some discomfort</div><br/></div></div><div id="39921074" class="c"><input type="checkbox" id="c-39921074" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#39922901">prev</a><span>|</span><a href="#39920440">next</a><span>|</span><label class="collapse" for="c-39921074">[-]</label><label class="expand" for="c-39921074">[1 more]</label></div><br/><div class="children"><div class="content">Raymond Chen has to be one of the few OG legends where the title of the post alone is just like: âToday is Old New Thing day, and thatâs just going to be the coolest thing I learn today.â I started salivating before my eyes scanned so far as the domain name.<p>And as usual, worth reading at least one or two more times.<p>Fucking. Legend.</div><br/></div></div><div id="39920440" class="c"><input type="checkbox" id="c-39920440" checked=""/><div class="controls bullet"><span class="by">caycep</span><span>|</span><a href="#39921074">prev</a><span>|</span><a href="#39922440">next</a><span>|</span><label class="collapse" for="c-39920440">[-]</label><label class="expand" for="c-39920440">[1 more]</label></div><br/><div class="children"><div class="content">the headline reminded me of &quot;ancient computers&quot; in sci fi games, which was essentially a tower of Hanoi problem inmplemented in-game</div><br/></div></div><div id="39922440" class="c"><input type="checkbox" id="c-39922440" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#39920440">prev</a><span>|</span><a href="#39919387">next</a><span>|</span><label class="collapse" for="c-39922440">[-]</label><label class="expand" for="c-39922440">[1 more]</label></div><br/><div class="children"><div class="content">One of the things that people miss is that a &quot;stack&quot; was not <i>just</i> for recursion.<p>A &quot;stack&quot; was also a small memory, single thread optimization because it allows you to <i>multiplex</i> memory for function calls.  If two functions do not call each other, they can share the memory used for their activation records.<p>Keeping track of this memory multiplexing in the compilers of the day would have been very hard and highly memory intensive--a stack solves that problem.<p>Without a stack, your memory usage (static) goes as O(n) with the number of functions.  With a stack, your memory usage (dynamic) goes as O(n) with the depth of function calls.  The memory usage of these two scenarios is <i>wildly</i> different.</div><br/></div></div><div id="39919387" class="c"><input type="checkbox" id="c-39919387" checked=""/><div class="controls bullet"><span class="by">ginko</span><span>|</span><a href="#39922440">prev</a><span>|</span><label class="collapse" for="c-39919387">[-]</label><label class="expand" for="c-39919387">[1 more]</label></div><br/><div class="children"><div class="content">If you write a GPU shader in most graphics APIs today you will also not have a stack or heap.</div><br/></div></div></div></div></div></div></div></body></html>