<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728896464040" as="style"/><link rel="stylesheet" href="styles.css?v=1728896464040"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://simonwillison.net/2024/Oct/13/zero-latency-sqlite-storage-in-every-durable-object/">Zero-latency SQLite storage in every Durable Object</a> <span class="domain">(<a href="https://simonwillison.net">simonwillison.net</a>)</span></div><div class="subtext"><span>ajhit406</span> | <span>79 comments</span></div><br/><div><div id="41835605" class="c"><input type="checkbox" id="c-41835605" checked=""/><div class="controls bullet"><span class="by">blixt</span><span>|</span><a href="#41834673">next</a><span>|</span><label class="collapse" for="c-41835605">[-]</label><label class="expand" for="c-41835605">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m constantly impressed by the design of DOs. I think it&#x27;s easy to have a knee-jerk reaction that something is wrong with doing it this way, but in reality I think this is exactly how a lot of real products are implicitly structured: a lot of complex work done at very low scale per atomic thing (by which I mean, anything that needs to be transactionally consistent).<p>In retrospect what we ended up building at Framer for projects with multiplayer support where edits are replicated at 60 FPS while being correctly ordered for all clients is a more applied version of what DOs are doing now. We also ended up with something like a WAL of JSON object edits so in case a project instance crashed its backup could pick up as if nothing had happened, even if committing the JSON patches into the (huge) project data object didn&#x27;t have time to occur (on an every-N-updates&#x2F;M-seconds basis just like described here).</div><br/></div></div><div id="41834673" class="c"><input type="checkbox" id="c-41834673" checked=""/><div class="controls bullet"><span class="by">tmikaeld</span><span>|</span><a href="#41835605">prev</a><span>|</span><a href="#41833065">next</a><span>|</span><label class="collapse" for="c-41834673">[-]</label><label class="expand" for="c-41834673">[7 more]</label></div><br/><div class="children"><div class="content">&gt; ..each DO constantly streams a sequence of WAL entries to object storage - batched every 16MB or every ten seconds.<p>Which also means it may take 10 seconds before you can (reliably) read the write globally.<p>I keep failing to see how this can replace regionally placed database clusters which can serve a continent in milliseconds.<p>Edit: I know it uses streams, but those are only to 5 followers and CF have hundreds of datacenters. There is no physical way to guarantee reads in seconds unless all instances of the SQLite are always connected and even then, packet latency will cause issues.</div><br/><div id="41835155" class="c"><input type="checkbox" id="c-41835155" checked=""/><div class="controls bullet"><span class="by">firtoz</span><span>|</span><a href="#41834673">parent</a><span>|</span><a href="#41834790">next</a><span>|</span><label class="collapse" for="c-41835155">[-]</label><label class="expand" for="c-41835155">[4 more]</label></div><br/><div class="children"><div class="content">AFAIK the writes and reads are done only from the same process, so the long term storage will apply only if the current process is hibernated. When you write something and then read it, it&#x27;s immediate, because the writes and reads are also updating the current process&#x27;s state in memory.<p>For another process (e.g. another DO or another worker) to access the data, they need to go through the DO which &quot;contains&quot; the data, so they&#x27;d be making a RPC or a HTTP request to the DO, and they&#x27;d get the latest information.<p>+ the hibernation happens after x seconds of inactivity, so it feels like the only time a data write to be unavailable as expected would be when the DO or worker crashes right after a write.</div><br/><div id="41835281" class="c"><input type="checkbox" id="c-41835281" checked=""/><div class="controls bullet"><span class="by">tmikaeld</span><span>|</span><a href="#41834673">root</a><span>|</span><a href="#41835155">parent</a><span>|</span><a href="#41834790">next</a><span>|</span><label class="collapse" for="c-41835281">[-]</label><label class="expand" for="c-41835281">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right that reads and writes are immediate in the same client connection, this is how it works with CF KV as well - but not across the entire network.<p>On KV they expect up to 30 second latency before a write can be written everywhere, I expect similar here.</div><br/><div id="41835295" class="c"><input type="checkbox" id="c-41835295" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41834673">root</a><span>|</span><a href="#41835281">parent</a><span>|</span><a href="#41834790">next</a><span>|</span><label class="collapse" for="c-41835295">[-]</label><label class="expand" for="c-41835295">[2 more]</label></div><br/><div class="children"><div class="content">Cloudflare ensures all operations on a DO happen on _the_ single instance of that DO, worldwide.<p>There’s no such thing as the read after wrote problem because only one host will ever do reads and writes (until that host dies).</div><br/><div id="41835632" class="c"><input type="checkbox" id="c-41835632" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#41834673">root</a><span>|</span><a href="#41835295">parent</a><span>|</span><a href="#41834790">next</a><span>|</span><label class="collapse" for="c-41835632">[-]</label><label class="expand" for="c-41835632">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. The entire purpose of DO’s is essentially to provide the consistency guarantees that KV cannot.</div><br/></div></div></div></div></div></div></div></div><div id="41834790" class="c"><input type="checkbox" id="c-41834790" checked=""/><div class="controls bullet"><span class="by">neamar</span><span>|</span><a href="#41834673">parent</a><span>|</span><a href="#41835155">prev</a><span>|</span><a href="#41834832">next</a><span>|</span><label class="collapse" for="c-41834790">[-]</label><label class="expand" for="c-41834790">[1 more]</label></div><br/><div class="children"><div class="content">The writes are streamed in near real time to five followers, acknowledging it near instantly. The cloudflare blog article mention this more in depth. So writes remain fast, while still having durability.</div><br/></div></div><div id="41834832" class="c"><input type="checkbox" id="c-41834832" checked=""/><div class="controls bullet"><span class="by">memothon</span><span>|</span><a href="#41834673">parent</a><span>|</span><a href="#41834790">prev</a><span>|</span><a href="#41833065">next</a><span>|</span><label class="collapse" for="c-41834832">[-]</label><label class="expand" for="c-41834832">[1 more]</label></div><br/><div class="children"><div class="content">Those WAL entries streamed to object storage I think are just for backups.<p>Each DO is globally unique (there&#x27;s one DO with a given id running anywhere) and runs sqlite on its own local storage in that datacenter.</div><br/></div></div></div></div><div id="41833065" class="c"><input type="checkbox" id="c-41833065" checked=""/><div class="controls bullet"><span class="by">emadda</span><span>|</span><a href="#41834673">prev</a><span>|</span><a href="#41835163">next</a><span>|</span><label class="collapse" for="c-41833065">[-]</label><label class="expand" for="c-41833065">[6 more]</label></div><br/><div class="children"><div class="content">Some other interesting points:<p>- The write api is sync, but it has a hidden async await: when you do your next output with a response, if the write fails the runtime will replace the response with a http failure. This allows the runtime to auto-batch writes and optimistically assume they will succeed, without the user explicitly handling the errors or awaits.<p>- There are no read transactions, which would be useful to get a pointer to a snapshot at a point in time.<p>- Each runtime instance is limited to 128mb RAM.<p>- Websockets can hibernate and you do not have to pay for the  time they are sleeping. This allows your clients to remain connected even when the DO is sleeping.<p>- They have a kind of auto RPC ability where you can talk to other DOs or workers as if they are normal JS calls, but they can actually be calling another data center. The runtime handles the serialisation and parsing.</div><br/><div id="41835462" class="c"><input type="checkbox" id="c-41835462" checked=""/><div class="controls bullet"><span class="by">ngrilly</span><span>|</span><a href="#41833065">parent</a><span>|</span><a href="#41833314">next</a><span>|</span><label class="collapse" for="c-41835462">[-]</label><label class="expand" for="c-41835462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The write api is sync, but it has a hidden async await: when you do your next output with a response, if the write fails the runtime will replace the response with a http failure. This allows the runtime to auto-batch writes and optimistically assume they will succeed, without the user explicitly handling the errors or awaits.<p>It reminds me of PostgreSQL&#x27;s commit_delay, even thought it&#x27;s not exactly the same principle: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;runtime-config-wal.html#GUC-COMMIT-DELAY" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;runtime-config-wal.h...</a><p>Litestream, mentioned in the post, is also suggesting a similar technique.</div><br/></div></div><div id="41833314" class="c"><input type="checkbox" id="c-41833314" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41833065">parent</a><span>|</span><a href="#41835462">prev</a><span>|</span><a href="#41834959">next</a><span>|</span><label class="collapse" for="c-41833314">[-]</label><label class="expand" for="c-41833314">[2 more]</label></div><br/><div class="children"><div class="content">The RPC stuff is pretty interesting. More here: <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;javascript-native-rpc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;javascript-native-rpc&#x2F;</a></div><br/><div id="41834632" class="c"><input type="checkbox" id="c-41834632" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41833065">root</a><span>|</span><a href="#41833314">parent</a><span>|</span><a href="#41834959">next</a><span>|</span><label class="collapse" for="c-41834632">[-]</label><label class="expand" for="c-41834632">[1 more]</label></div><br/><div class="children"><div class="content">Without a schema, I’m wondering about validation. I guess your server should use Zod or an equivalent library?</div><br/></div></div></div></div><div id="41834959" class="c"><input type="checkbox" id="c-41834959" checked=""/><div class="controls bullet"><span class="by">matharmin</span><span>|</span><a href="#41833065">parent</a><span>|</span><a href="#41833314">prev</a><span>|</span><a href="#41834000">next</a><span>|</span><label class="collapse" for="c-41834959">[-]</label><label class="expand" for="c-41834959">[1 more]</label></div><br/><div class="children"><div class="content">Just wondering, do you have a specific use case for read transactions implemented on the database level here?<p>In SQLite in general read transactions are useful since you can access the same database from multiple processes at a time. Here, only a single process can access the database. So you can get the same effect as read transactions either by doing all reads in one synchronous function, or implement your own process-level locking.</div><br/></div></div></div></div><div id="41835163" class="c"><input type="checkbox" id="c-41835163" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#41833065">prev</a><span>|</span><a href="#41835303">next</a><span>|</span><label class="collapse" for="c-41835163">[-]</label><label class="expand" for="c-41835163">[1 more]</label></div><br/><div class="children"><div class="content">I really love the Durable Object design, particularly because it&#x27;s easy to understand how it works on the inside. Unlike lots of other solutions designed for realtime data stuff, Durable Objects have a simplicity to them, much like Redis and Italian food. You can see all the ingredients. Given enough time and resources (and datacenters :) ), a competent programmer could read the DO docs and reimplement something similar. This makes it easy to judge the tradeoffs involved.<p>I do worry that DOs are great for building fast, low-overhead, realtime experiences (eg five people editing a document in realtime), but make it very hard to make analyses and overviews (which groups of people have been which editing documents the last week?). Putting the data inside SQLite might make that even harder - you&#x27;d have to somehow query lots and lots of little SQLite instances and then merge the results together. I wonder if there&#x27;s anything for this with DOs, because this is what keeps bringing me back to Postgres time and time again: it works for core app features <i>and</i> for overviews, BI, etc.</div><br/></div></div><div id="41835303" class="c"><input type="checkbox" id="c-41835303" checked=""/><div class="controls bullet"><span class="by">jwblackwell</span><span>|</span><a href="#41835163">prev</a><span>|</span><a href="#41834823">next</a><span>|</span><label class="collapse" for="c-41835303">[-]</label><label class="expand" for="c-41835303">[2 more]</label></div><br/><div class="children"><div class="content">Does anyone else struggle to wrap their head around a lot of this new cloud stuff?<p>I have 15+ years experience of building for the web, using Laravel &#x2F; Postgres &#x2F; Redis stack and I read posts like this and just think, &quot;not for me&quot;.</div><br/><div id="41835404" class="c"><input type="checkbox" id="c-41835404" checked=""/><div class="controls bullet"><span class="by">djtango</span><span>|</span><a href="#41835303">parent</a><span>|</span><a href="#41834823">next</a><span>|</span><label class="collapse" for="c-41835404">[-]</label><label class="expand" for="c-41835404">[1 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; For useful background on the first version of Durable Objects take a look at Cloudflare&#x27;s durable multiplayer moat by Paul Butler, who digs into its popularity for building WebSocket-based realtime collaborative applications.<p>First apps that come to mind that have RT collaboration:<p>- Google Docs&#x2F;Sheets etc<p>- Notion<p>- Miro<p>- Figma<p>These are all global scale collaborative apps, I&#x27;m not sure a Laravel stack will support those use cases... Google had to in house everything and probably spearheaded the usage of CRDTs ( this is a guess!) but as the patterns emerge and the building blocks get SAASified, mass-RT collaboration no longer becomes a giant engineering problem and more and more interesting products get unlocked</div><br/></div></div></div></div><div id="41834823" class="c"><input type="checkbox" id="c-41834823" checked=""/><div class="controls bullet"><span class="by">segalord</span><span>|</span><a href="#41835303">prev</a><span>|</span><a href="#41835125">next</a><span>|</span><label class="collapse" for="c-41834823">[-]</label><label class="expand" for="c-41834823">[2 more]</label></div><br/><div class="children"><div class="content">Noticing CF pushing for devs to use DO for eveything over workers these days. Even websocket connections on workers get timed out after ~30s and the recommended way is to use DO for them</div><br/><div id="41834966" class="c"><input type="checkbox" id="c-41834966" checked=""/><div class="controls bullet"><span class="by">rozenmd</span><span>|</span><a href="#41834823">parent</a><span>|</span><a href="#41835125">next</a><span>|</span><label class="collapse" for="c-41834966">[-]</label><label class="expand" for="c-41834966">[1 more]</label></div><br/><div class="children"><div class="content">Durable Objects have always been the recommended way to do websocket connections on Cloudflare Workers? (as far as I remember, anyway)<p>The original chat demo dates back to 2020, using DOs + websockets: <a href="https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;workers-chat-demo">https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;workers-chat-demo</a></div><br/></div></div></div></div><div id="41835125" class="c"><input type="checkbox" id="c-41835125" checked=""/><div class="controls bullet"><span class="by">myflash13</span><span>|</span><a href="#41834823">prev</a><span>|</span><a href="#41835500">next</a><span>|</span><label class="collapse" for="c-41835125">[-]</label><label class="expand" for="c-41835125">[2 more]</label></div><br/><div class="children"><div class="content">What I don’t understand is why, in the example of flight seat mapping provided, you create a DO per flight. So does a DO correspond to a “model” in MVC architecture? What if I used DOs in a per-tenant way, so one DO per user. And then how do I query or “join” across all DOs to find all full flights? I guess you would have to design your DOs such that joins are not required?</div><br/><div id="41835304" class="c"><input type="checkbox" id="c-41835304" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41835125">parent</a><span>|</span><a href="#41835500">next</a><span>|</span><label class="collapse" for="c-41835304">[-]</label><label class="expand" for="c-41835304">[1 more]</label></div><br/><div class="children"><div class="content">They support “function” calling between DOs, so you are able to compose a response from more than one DO.</div><br/></div></div></div></div><div id="41835500" class="c"><input type="checkbox" id="c-41835500" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#41835125">prev</a><span>|</span><a href="#41832812">next</a><span>|</span><label class="collapse" for="c-41835500">[-]</label><label class="expand" for="c-41835500">[1 more]</label></div><br/><div class="children"><div class="content">The first thing I wondered was how this plays with data residency and privacy&#x2F;regulatory requirements.</div><br/></div></div><div id="41832812" class="c"><input type="checkbox" id="c-41832812" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41835500">prev</a><span>|</span><a href="#41832728">next</a><span>|</span><label class="collapse" for="c-41832812">[-]</label><label class="expand" for="c-41832812">[8 more]</label></div><br/><div class="children"><div class="content">One thing I don&#x27;t understand about Durable Objects yet is where they are physically located.<p>Are they located in the region that hosted the API call that caused them to be created in the first place?<p>If so, is there a mechanism by which a DO can be automatically migrated to another location if it turns out that e.g. they were created in North America but actually all of the subsequent read&#x2F;write traffic to them comes from Australia?</div><br/><div id="41832906" class="c"><input type="checkbox" id="c-41832906" checked=""/><div class="controls bullet"><span class="by">mhart</span><span>|</span><a href="#41832812">parent</a><span>|</span><a href="#41833115">next</a><span>|</span><label class="collapse" for="c-41832906">[-]</label><label class="expand" for="c-41832906">[2 more]</label></div><br/><div class="children"><div class="content">By default in the region you created them in, but you can alternatively specify a locationHint. Use &quot;oc&quot; for Australia. <a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;durable-objects&#x2F;reference&#x2F;data-location&#x2F;#supported-locations-1" rel="nofollow">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;durable-objects&#x2F;reference&#x2F;...</a><p>Note the &quot;Dynamic relocation of existing Durable Objects is planned for the future&quot;</div><br/><div id="41833048" class="c"><input type="checkbox" id="c-41833048" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41832812">root</a><span>|</span><a href="#41832906">parent</a><span>|</span><a href="#41833115">next</a><span>|</span><label class="collapse" for="c-41833048">[-]</label><label class="expand" for="c-41833048">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, added that to my post.</div><br/></div></div></div></div><div id="41833115" class="c"><input type="checkbox" id="c-41833115" checked=""/><div class="controls bullet"><span class="by">dantiberian</span><span>|</span><a href="#41832812">parent</a><span>|</span><a href="#41832906">prev</a><span>|</span><a href="#41832862">next</a><span>|</span><label class="collapse" for="c-41833115">[-]</label><label class="expand" for="c-41833115">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;where.durableobjects.live" rel="nofollow">https:&#x2F;&#x2F;where.durableobjects.live</a> is a good website that shows you where they live. Only about 10-11% of Cloudflare PoPs host durable objects. Requests to another PoP to create a DO will get forward to one of the nearby PoPs which do host them.</div><br/></div></div><div id="41832862" class="c"><input type="checkbox" id="c-41832862" checked=""/><div class="controls bullet"><span class="by">masterj</span><span>|</span><a href="#41832812">parent</a><span>|</span><a href="#41833115">prev</a><span>|</span><a href="#41832834">next</a><span>|</span><label class="collapse" for="c-41832862">[-]</label><label class="expand" for="c-41832862">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Durable Objects do not currently change locations after they are created<p>&gt; Dynamic relocation of existing Durable Objects is planned for the future.<p><a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;durable-objects&#x2F;reference&#x2F;data-location&#x2F;#:~:text=Durable%20Objects%20do%20not%20currently,will%20be%20in%20close%20proximity" rel="nofollow">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;durable-objects&#x2F;reference&#x2F;...</a>.<p>IIRC Orleans (<a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;02&#x2F;Orleans-MSR-TR-2014-41.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a>) allows actors to be moved between machines, which should map well to DOs being moved between locations.</div><br/><div id="41834934" class="c"><input type="checkbox" id="c-41834934" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#41832812">root</a><span>|</span><a href="#41832862">parent</a><span>|</span><a href="#41832834">next</a><span>|</span><label class="collapse" for="c-41834934">[-]</label><label class="expand" for="c-41834934">[1 more]</label></div><br/><div class="children"><div class="content">As actors in Orleans are virtual and persistent it can also be the case it is running nowhere.<p>If it&#x27;s stateless it could be running in multiple locations.<p>I worry &quot;Dynamic relocation of DOs&quot; might be going a bit too granular, this should be something the runtime takes care of.</div><br/></div></div></div></div><div id="41832834" class="c"><input type="checkbox" id="c-41832834" checked=""/><div class="controls bullet"><span class="by">ko_pivot</span><span>|</span><a href="#41832812">parent</a><span>|</span><a href="#41832862">prev</a><span>|</span><a href="#41832933">next</a><span>|</span><label class="collapse" for="c-41832834">[-]</label><label class="expand" for="c-41832834">[1 more]</label></div><br/><div class="children"><div class="content">Durable Objects have long term storage. They get hydrated from that storage, so in that sense, they can move to any Cloudflare DS. However, there is no API call to move a Durable Object. It has to have no connections and then gets recreated in the DS nearest to the next&#x2F;first connection. Memory gets dropped when that happens, storage survives. (This is slightly out of date as they have some nuanced hibernation stuff that is recent).</div><br/></div></div><div id="41832933" class="c"><input type="checkbox" id="c-41832933" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832812">parent</a><span>|</span><a href="#41832834">prev</a><span>|</span><a href="#41832728">next</a><span>|</span><label class="collapse" for="c-41832933">[-]</label><label class="expand" for="c-41832933">[1 more]</label></div><br/><div class="children"><div class="content">Not an answer to your question, but shoutout to <a href="https:&#x2F;&#x2F;where.durableobjects.live&#x2F;" rel="nofollow">https:&#x2F;&#x2F;where.durableobjects.live&#x2F;</a></div><br/></div></div></div></div><div id="41832728" class="c"><input type="checkbox" id="c-41832728" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#41832812">prev</a><span>|</span><a href="#41834017">next</a><span>|</span><label class="collapse" for="c-41832728">[-]</label><label class="expand" for="c-41832728">[39 more]</label></div><br/><div class="children"><div class="content">This is a really interesting design, but these kinds of smart systems always inhabit an uncanny valley for me. You need them in exactly two cases:<p>1. You have a really high-load system that you need to figure out some clever ways to scale.<p>2. You&#x27;re working on a toy project for fun.<p>If #2, fine, use whatever you want, it&#x27;s great.<p>If this is production, or for Work(TM), you need something proven. If you don&#x27;t know you <i>need</i> this, you don&#x27;t need it, go with a boring Postgres database and a VM or something.<p>If you do know you <i>need</i> this, then you&#x27;re kind of in a bind: It&#x27;s not really very mature yet, as it&#x27;s pretty new, and you&#x27;re probably going to hit a bunch of weird edge cases, which you probably don&#x27;t really want to have to debug or live with.<p>So, who are these systems for, in the end? They&#x27;re so niche that they can&#x27;t easily mature and be used by lots of serious players, and they&#x27;re too complex with too many tradeoffs to be used by 99.9% of companies.<p>The only people I know for sure are the target market for this sort of thing is the developers who see something shiny, build a company (or, worse, build someone else&#x27;s company) on it, and then regret it pretty soon and move to something else (hopefully much more boring).<p>Does anyone have more insight on this? I&#x27;d love to know.</div><br/><div id="41833218" class="c"><input type="checkbox" id="c-41833218" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41832980">next</a><span>|</span><label class="collapse" for="c-41833218">[-]</label><label class="expand" for="c-41833218">[7 more]</label></div><br/><div class="children"><div class="content">Databases is an extremely slow-maturing area, similar to programming languages, but are all deviations from Postgres shiny and hipster?<p>The idea of colocating data and behavior is really a quantifiable <i>reduction</i> in complexity. It removes latency and bandwidth concerns, which means both operational concerns and development concerns (famously the impact of the N+1 problem is greatly reduced). You can absolutely argue that networked Postgres is better for other reasons (and you may be right) but SQLite is about as boring and predictable as you can get, with known strong advantages. This is the reason it’s getting popular on the server.<p>That said, I don’t like the idea of creating many small databases very much - as they suggest with Durable Objects. That gives noSQL nightmares - breaking all kinds of important invariants of relational dbs. I think it’s much preferable to use SQLite as a monolithic database like it’s done in their D1 product.</div><br/><div id="41833285" class="c"><input type="checkbox" id="c-41833285" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833218">parent</a><span>|</span><a href="#41834497">next</a><span>|</span><label class="collapse" for="c-41833285">[-]</label><label class="expand" for="c-41833285">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That gives noSQL nightmares - breaking all kinds of important invariants of relational dbs<p>IMO Durable Objects map well to use cases where there actually are documents. Think of Figma. There is a ton of data that lives inside the literal Figma document. It would be awful to have a relational table for like &quot;shapes&quot; with one row per rectangle across Figma&#x27;s entire customer base. That&#x27;s just not an appropriate use of a relational database.<p>So let&#x27;s say I built Figma on MongoDB, where each Figma document is a Mongo document. That corresponds fairly straightforwardly to each Figma document being a Durable Object instance, using either the built-in noSQL storage that Durable Objects already have, or a small Sqlite relational database which <i>does</i> have a &quot;shapes&quot; table, but only containing the shapes in this one document.</div><br/><div id="41833997" class="c"><input type="checkbox" id="c-41833997" checked=""/><div class="controls bullet"><span class="by">jchanimal</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833285">parent</a><span>|</span><a href="#41834497">next</a><span>|</span><label class="collapse" for="c-41833997">[-]</label><label class="expand" for="c-41833997">[1 more]</label></div><br/><div class="children"><div class="content">We are wrestling with questions like this on the new document database we’re building. A database should correspond to some administrative domain object.<p>Today in Fireproof a database is a unit of sharing, but we are working toward a broader model where a database corresponds to an individual application’s state. So one database is all the shared documents not just a single unit of sharing.<p>These small changes early on can have big impact later. If you’re interested in these sort of design questions, the Fireproof Discord is where we are hashing out the v0.20 api.<p>(I was an early contributor to Apache CouchDB. Damien Katz, creator of CouchDB, is helping with engineering and raised these questions recently, along with other team members.)</div><br/></div></div></div></div><div id="41834497" class="c"><input type="checkbox" id="c-41834497" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833218">parent</a><span>|</span><a href="#41833285">prev</a><span>|</span><a href="#41833308">next</a><span>|</span><label class="collapse" for="c-41834497">[-]</label><label class="expand" for="c-41834497">[1 more]</label></div><br/><div class="children"><div class="content">N+1 problem is also reduced if you keep your one and only server next to your one and only database.<p>This was actually the solution we came up with at a very big global company. Well, not 1 server, but 1 data center. If your write leaders are all in one place it apparently doesn&#x27;t matter that everything else is global, for certain write requests at least.</div><br/></div></div><div id="41834216" class="c"><input type="checkbox" id="c-41834216" checked=""/><div class="controls bullet"><span class="by">masterj</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833218">parent</a><span>|</span><a href="#41833308">prev</a><span>|</span><a href="#41832980">next</a><span>|</span><label class="collapse" for="c-41834216">[-]</label><label class="expand" for="c-41834216">[2 more]</label></div><br/><div class="children"><div class="content">If you adopt a wide-column db like Cassandra or DynamoDB, don’t you have to pick a shard for your table? The idea behind Durable Objects seems similar</div><br/><div id="41834628" class="c"><input type="checkbox" id="c-41834628" checked=""/><div class="controls bullet"><span class="by">simpsond</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41834216">parent</a><span>|</span><a href="#41832980">next</a><span>|</span><label class="collapse" for="c-41834628">[-]</label><label class="expand" for="c-41834628">[1 more]</label></div><br/><div class="children"><div class="content">You have a row key, which gets consistently hashed to a shard &#x2F; node on the ring.</div><br/></div></div></div></div></div></div><div id="41832980" class="c"><input type="checkbox" id="c-41832980" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41833218">prev</a><span>|</span><a href="#41835368">next</a><span>|</span><label class="collapse" for="c-41832980">[-]</label><label class="expand" for="c-41832980">[10 more]</label></div><br/><div class="children"><div class="content">As far as I can tell, multiplayer is the killer app for Durable Objects. If you want to build another Figma, Google Docs, etc, the programming model of Durable Objects is super handy.<p>This article goes into it more: <a href="https:&#x2F;&#x2F;digest.browsertech.com&#x2F;archive&#x2F;browsertech-digest-cloudflares-durable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;digest.browsertech.com&#x2F;archive&#x2F;browsertech-digest-cl...</a><p>I think this old article is quite relevant too: <a href="http:&#x2F;&#x2F;ithare.com&#x2F;scaling-stateful-objects&#x2F;" rel="nofollow">http:&#x2F;&#x2F;ithare.com&#x2F;scaling-stateful-objects&#x2F;</a><p>Anyone who read the Figma multiplayer article and thought &quot;that&#x27;s kind of what I need&quot; would be well served by Durable Objects, I think. <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;rust-in-production-at-figma&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;rust-in-production-at-figma&#x2F;</a><p>There are other approaches - I&#x27;ve worked in the past with CRDTs over WebRTC which felt absolutely space-age. But that&#x27;s a much more complicated foundation compared to a websocket and a single class instance &quot;somewhere&quot; in the cloud.</div><br/><div id="41833041" class="c"><input type="checkbox" id="c-41833041" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41832980">parent</a><span>|</span><a href="#41835368">next</a><span>|</span><label class="collapse" for="c-41833041">[-]</label><label class="expand" for="c-41833041">[9 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very interesting use case. Given that your &quot;players&quot; aren&#x27;t guaranteed to be local to the DO, doesn&#x27;t using DOs only make sense in high-traffic situations again? Otherwise you might as well just serve the players from a conventional server, no?<p>CRDTs really do sound amazing, though.</div><br/><div id="41834616" class="c"><input type="checkbox" id="c-41834616" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833041">parent</a><span>|</span><a href="#41833274">next</a><span>|</span><label class="collapse" for="c-41834616">[-]</label><label class="expand" for="c-41834616">[1 more]</label></div><br/><div class="children"><div class="content">Some games have regions and you only see players in the same region. For example, a “Europe” region. If you’re in the US and you connect to the Europe region, you know that you should expect some lag.<p>And it seems like that would work just as well with durable objects.</div><br/></div></div><div id="41833274" class="c"><input type="checkbox" id="c-41833274" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833041">parent</a><span>|</span><a href="#41834616">prev</a><span>|</span><a href="#41833255">next</a><span>|</span><label class="collapse" for="c-41833274">[-]</label><label class="expand" for="c-41833274">[5 more]</label></div><br/><div class="children"><div class="content">Best case, the players are co-located in a city or country, and they&#x27;ll benefit from data center locality.<p>Worst case, they&#x27;re not co-located, and one participant has good latency, and the other doesn&#x27;t. This is equivalent to the &quot;deploy the backend in a single server&#x2F;datacenter&quot; approach.<p>Aside from the data locality, I still find the programming model (a globally-unique and addressable single-threaded class instance) to be quite nice, and would want to emulate it even without the Cloudflare edge magic.</div><br/><div id="41833340" class="c"><input type="checkbox" id="c-41833340" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833274">parent</a><span>|</span><a href="#41834709">next</a><span>|</span><label class="collapse" for="c-41833340">[-]</label><label class="expand" for="c-41833340">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Aside from the data locality, I still find the programming model (a globally-unique and addressable single-threaded class instance) to be quite nice, and would want to emulate it even without the Cloudflare edge magic.<p>You might be interested in Plane (<a href="https:&#x2F;&#x2F;plane.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;plane.dev&#x2F;</a> &#x2F; <a href="https:&#x2F;&#x2F;github.com&#x2F;jamsocket&#x2F;plane">https:&#x2F;&#x2F;github.com&#x2F;jamsocket&#x2F;plane</a>), which we sometimes describe as a sort of Durable Object-like abstraction that can run anywhere containers can.<p>(I&#x27;m also one of the articles you linked, thanks for the shoutout!)</div><br/><div id="41833503" class="c"><input type="checkbox" id="c-41833503" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833340">parent</a><span>|</span><a href="#41834709">next</a><span>|</span><label class="collapse" for="c-41833503">[-]</label><label class="expand" for="c-41833503">[1 more]</label></div><br/><div class="children"><div class="content">I am interested, and I really enjoy your work on Browsertech! I haven&#x27;t needed Plane above&#x2F;over what Cloudflare is providing, but I&#x27;ve got it in the back of my mind as an option.<p>I&#x27;ve long hoped other providers might jump on the Durable Objects bandwagon and provide competing functionality so we&#x27;re not locked in. Plane&#x2F;Jamsocket looks like one way to go about mitigating that risk to a certain extent.</div><br/></div></div></div></div><div id="41834709" class="c"><input type="checkbox" id="c-41834709" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833274">parent</a><span>|</span><a href="#41833340">prev</a><span>|</span><a href="#41833255">next</a><span>|</span><label class="collapse" for="c-41834709">[-]</label><label class="expand" for="c-41834709">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the actor model essentially.<p>You can have a DO proxy each user connection, then they forward messages to the multipler document. The user proxy deals with ordering and buffering their connection message state in the presence of disconnects, and the document DO handles the shared state.</div><br/><div id="41834801" class="c"><input type="checkbox" id="c-41834801" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41834709">parent</a><span>|</span><a href="#41833255">next</a><span>|</span><label class="collapse" for="c-41834801">[-]</label><label class="expand" for="c-41834801">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actors <i>plus</i> a global routing system that means all messages addressed to a unique identifier will arrive in the actor instance. I haven&#x27;t seen any other actor frameworks that provide that.</div><br/></div></div></div></div></div></div><div id="41833255" class="c"><input type="checkbox" id="c-41833255" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833041">parent</a><span>|</span><a href="#41833274">prev</a><span>|</span><a href="#41835368">next</a><span>|</span><label class="collapse" for="c-41833255">[-]</label><label class="expand" for="c-41833255">[2 more]</label></div><br/><div class="children"><div class="content">In practice you’re most likely to be collaborating with other folks on your school project group, work team, close family, etc. Sure there are exceptions, but <i>generally speaking</i> picking a service location near your first group member ensures low latency for them (and they’re probably most engaged), and is likely to have lowish latency for everyone else.<p>On the flip side, picking US-East-1 gives okayish latency to folks near that, and nobody else.</div><br/><div id="41833295" class="c"><input type="checkbox" id="c-41833295" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833255">parent</a><span>|</span><a href="#41835368">next</a><span>|</span><label class="collapse" for="c-41833295">[-]</label><label class="expand" for="c-41833295">[1 more]</label></div><br/><div class="children"><div class="content">And the corollary to that is that often your collaborations have a naturally low scale. While your entire app&#x2F;customerbase as a whole needs to handle thousands of requests per second or more, one document&#x2F;shard may only need to handle a handful of people.</div><br/></div></div></div></div></div></div></div></div><div id="41835368" class="c"><input type="checkbox" id="c-41835368" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41832980">prev</a><span>|</span><a href="#41832813">next</a><span>|</span><label class="collapse" for="c-41835368">[-]</label><label class="expand" for="c-41835368">[1 more]</label></div><br/><div class="children"><div class="content">First, this is very insightful--I think most people should go through this exact analysis before architecting a system.<p>As others have said, the use is multiplayer, and that&#x27;s because you need everyone to see your changes ASAP for the app to feel good. But more broadly, the storage industry has been trying to build something that&#x27;s consistent, low latency, and multiuser for a long time. That&#x27;s super hard, just from a physics point of view there&#x27;s generally a tradeoff between consistency and latency. So I think people are trying different models to get there, and a lot of that experimentation (not all, cf Yugabyte or Cockroach) is happening with SQLite.</div><br/></div></div><div id="41832813" class="c"><input type="checkbox" id="c-41832813" checked=""/><div class="controls bullet"><span class="by">jmtulloss</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41835368">prev</a><span>|</span><a href="#41833093">next</a><span>|</span><label class="collapse" for="c-41832813">[-]</label><label class="expand" for="c-41832813">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re in #1, you talk to CloudFlare. They need some great customer stories and they have some great engineers that are most likely willing to work with you on how this will work&#x2F;help you with bugs in exchange for some success stories. If it gets proven out this turns into a service relationship, but early on it&#x27;s a partnership.</div><br/></div></div><div id="41833093" class="c"><input type="checkbox" id="c-41833093" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41832813">prev</a><span>|</span><a href="#41833057">next</a><span>|</span><label class="collapse" for="c-41833093">[-]</label><label class="expand" for="c-41833093">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d view the split here along the axes of debuggability&#x2F;introspection.<p>There are many services that just don&#x27;t require performance tuning or deep introspection, things like internal tools. This is where I think serverless frameworks do well, because they avoid a lot of time spent on deployment. It&#x27;s nice if these are fast, but that&#x27;s rarely a key requirement. Usually the key requirement is that they are fast to build and low maintenance. It&#x27;s possible that Cloudflare have got a good story for developer experience here that gets things working quickly, but that&#x27;s not their pitch, and there are a lot of services competing to make this sort of development fast.<p>However where I don&#x27;t think these services work well is when you have high debuggability and introspection requirements. What metrics do I get out of this? What happens if some Durable Objects are just slow, do we have the information to understand why? Can we rectify it if they are? What&#x27;s the logging story, and how much does it cost?<p>I think these sorts of services may be a good idea for a startup on day 1 to build some clever distributed system in order to put off thinking about scaling, but I can&#x27;t help but think that scale-up sized companies would be wanting to move off this onto something they can get into the details more with, and that transition would be a hard one.</div><br/></div></div><div id="41833057" class="c"><input type="checkbox" id="c-41833057" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41833093">prev</a><span>|</span><a href="#41832877">next</a><span>|</span><label class="collapse" for="c-41833057">[-]</label><label class="expand" for="c-41833057">[11 more]</label></div><br/><div class="children"><div class="content">I almost have the opposite view:<p>When starting out you can get away with using a simple Postgres database. Postgres is fine for low-traffic projects with minimal latency constraints, and you probably want to spend your innovation tokens elsewhere.<p>But in very high-traffic Production cases with tight latency requirements, you will start to see all kinds of weird and wacky traffic patterns, that barebones Postgres won&#x27;t be able to handle. It&#x27;s usually in these cases where you&#x27;d need to start exploring alternatives to Postgres. It&#x27;s also in these cases where you can afford to hire people to manage your special database needs.</div><br/><div id="41833100" class="c"><input type="checkbox" id="c-41833100" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833057">parent</a><span>|</span><a href="#41832877">next</a><span>|</span><label class="collapse" for="c-41833100">[-]</label><label class="expand" for="c-41833100">[10 more]</label></div><br/><div class="children"><div class="content">Have you worked on any examples of projects that started on PostgreSQL and ended up needing to migrate to something specialized?</div><br/><div id="41833373" class="c"><input type="checkbox" id="c-41833373" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833100">parent</a><span>|</span><a href="#41832877">next</a><span>|</span><label class="collapse" for="c-41833373">[-]</label><label class="expand" for="c-41833373">[9 more]</label></div><br/><div class="children"><div class="content">I did, twice.<p>The second time, we had a reporting system that eventually stored billions of rows per day in a Postgres database. Processing times got so bad that we decided to migrate to Clickhouse, resulting in a substantial boost to query times. I maintain that we haven&#x27;t exhausted all available optimisations for Postgres, but I cannot deny that the migration made sense in the long run - OLTP vs OLAP and all that.<p>(The first time is a funny story that I&#x27;m not quite ready to share.)</div><br/><div id="41833415" class="c"><input type="checkbox" id="c-41833415" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833373">parent</a><span>|</span><a href="#41833821">next</a><span>|</span><label class="collapse" for="c-41833415">[-]</label><label class="expand" for="c-41833415">[5 more]</label></div><br/><div class="children"><div class="content">That makes a lot of sense to me. One of my strongest hints that a non-relational data store might be a good idea is &quot;grows by billions of rows a day&quot;.</div><br/><div id="41833708" class="c"><input type="checkbox" id="c-41833708" checked=""/><div class="controls bullet"><span class="by">adhamsalama</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833415">parent</a><span>|</span><a href="#41833821">next</a><span>|</span><label class="collapse" for="c-41833708">[-]</label><label class="expand" for="c-41833708">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Clickhouse relational?</div><br/><div id="41833752" class="c"><input type="checkbox" id="c-41833752" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833708">parent</a><span>|</span><a href="#41833758">next</a><span>|</span><label class="collapse" for="c-41833752">[-]</label><label class="expand" for="c-41833752">[1 more]</label></div><br/><div class="children"><div class="content">It does allow you to query with SQL, but it&#x27;s meant for OLAP workloads, not OLTP. Its internal architecture and storage is different to what you&#x27;d usually think of as a relational database, like Postgres. See <a href="https:&#x2F;&#x2F;clickhouse.com&#x2F;docs&#x2F;en&#x2F;concepts&#x2F;why-clickhouse-is-so-fast#what-makes-clickhouse-so-fast" rel="nofollow">https:&#x2F;&#x2F;clickhouse.com&#x2F;docs&#x2F;en&#x2F;concepts&#x2F;why-clickhouse-is-so...</a><p>The term &quot;relational&quot; is overloaded. Sometimes it means &quot;you can use SQL&quot; and sometimes it means &quot;OLTP with data stored in an AoS btree&quot;.<p>(And sometimes, a pet peeve of mine, it means &quot;data with relationships&quot; which is based on misunderstanding the term &quot;relation&quot;. If someone asks you if &quot;your data is relational&quot; they are suffering from this confusion.)</div><br/></div></div><div id="41833758" class="c"><input type="checkbox" id="c-41833758" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833708">parent</a><span>|</span><a href="#41833752">prev</a><span>|</span><a href="#41833828">next</a><span>|</span><label class="collapse" for="c-41833758">[-]</label><label class="expand" for="c-41833758">[1 more]</label></div><br/><div class="children"><div class="content">Clickhouse is a SQL database, so I guess it is?<p>(Strictly speaking since a &quot;relation&quot; in the original Codd-paper sense is a table, anything with tables is relational. I don&#x27;t know if that&#x27;s what people mean by &quot;relational&quot;, plus I don&#x27;t know what counts as &quot;non-relational&quot; in that sense)</div><br/></div></div><div id="41833828" class="c"><input type="checkbox" id="c-41833828" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833708">parent</a><span>|</span><a href="#41833758">prev</a><span>|</span><a href="#41833821">next</a><span>|</span><label class="collapse" for="c-41833828">[-]</label><label class="expand" for="c-41833828">[1 more]</label></div><br/><div class="children"><div class="content">Kind of? By &quot;relational&quot; there I meant &quot;traditional relational databases like MySQL and PostgreSQL that are optimized for transactions and aren&#x27;t designed for large scale analytics&quot;.</div><br/></div></div></div></div></div></div><div id="41833821" class="c"><input type="checkbox" id="c-41833821" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833373">parent</a><span>|</span><a href="#41833415">prev</a><span>|</span><a href="#41833713">next</a><span>|</span><label class="collapse" for="c-41833821">[-]</label><label class="expand" for="c-41833821">[1 more]</label></div><br/><div class="children"><div class="content">Right, OLTP vs OLAP are very different workloads (using the car analogy, that would be like using a ferrari to tow a trailer, and an F250 to... oh wait, an F250 can do anything!).<p>But seriously though, even if you use postgres, as a former DBA (DB2 and Oracle) I would have tuned the OLTP database very differently to the OLAP database, and I don&#x27;t mean just indexes, but even during ETL from OLTP-&gt;OLAP you might decide to de-normalize columns on the OLAP side simply to speed up queries (OLAP databases are the sort of database you were warned about, where indexes can be 10x the data size)</div><br/></div></div><div id="41833713" class="c"><input type="checkbox" id="c-41833713" checked=""/><div class="controls bullet"><span class="by">adhamsalama</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833373">parent</a><span>|</span><a href="#41833821">prev</a><span>|</span><a href="#41832877">next</a><span>|</span><label class="collapse" for="c-41833713">[-]</label><label class="expand" for="c-41833713">[2 more]</label></div><br/><div class="children"><div class="content">Well, this isn&#x27;t specific to Postgres, is it?<p>If you were storing billions of rows per day  in MySQL, SQL Server, or Oracle, it still wouldn&#x27;t be able to handle it, would it?</div><br/><div id="41833748" class="c"><input type="checkbox" id="c-41833748" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833713">parent</a><span>|</span><a href="#41832877">next</a><span>|</span><label class="collapse" for="c-41833748">[-]</label><label class="expand" for="c-41833748">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s right. The key difference is using row-based vs column-based databases (i.e. OLTP vs OLAP). Any good database person should be cringing at the thought of using Postgres (or MySQL, Oracle, Sql Server, etc) for pulling reporting data.<p>That said, no regrets using Postgres there. If we started with Clickhouse the project could have not launched as quickly as it did, and that would have given us more problems.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41832877" class="c"><input type="checkbox" id="c-41832877" checked=""/><div class="controls bullet"><span class="by">gregwebs</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41833057">prev</a><span>|</span><a href="#41832987">next</a><span>|</span><label class="collapse" for="c-41832877">[-]</label><label class="expand" for="c-41832877">[6 more]</label></div><br/><div class="children"><div class="content">There are a lot of cases of low traffic applications that aren’t toys but instead are internal tools- this could be a great option for those.<p>For higher traffic they are asking you to figure out how to shard your data and it’s compute. That’s really hard to do without hitting edge cases.</div><br/><div id="41832894" class="c"><input type="checkbox" id="c-41832894" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41832877">parent</a><span>|</span><a href="#41832987">next</a><span>|</span><label class="collapse" for="c-41832894">[-]</label><label class="expand" for="c-41832894">[5 more]</label></div><br/><div class="children"><div class="content">Why would you use this for an internal, low-traffic tool over Postgres?</div><br/><div id="41833011" class="c"><input type="checkbox" id="c-41833011" checked=""/><div class="controls bullet"><span class="by">alright2565</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41832894">parent</a><span>|</span><a href="#41832962">next</a><span>|</span><label class="collapse" for="c-41833011">[-]</label><label class="expand" for="c-41833011">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so low traffic that you don&#x27;t want to pay the minimum $35&#x2F;mo for a PostgreSQL instance on AWS maybe. Or you&#x27;re required by policy to have a single-tenant architecture, but a full always-on database server would be overkill.</div><br/></div></div><div id="41832962" class="c"><input type="checkbox" id="c-41832962" checked=""/><div class="controls bullet"><span class="by">fracus</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41832894">parent</a><span>|</span><a href="#41833011">prev</a><span>|</span><a href="#41832987">next</a><span>|</span><label class="collapse" for="c-41832962">[-]</label><label class="expand" for="c-41832962">[3 more]</label></div><br/><div class="children"><div class="content">Could this be used to get a time edge in trading?  I&#x27;m not an expert, just thinking out loud.  I remember hearing about firms laying wire in a certain way because getting a microsecond jump on changing rates could be everything for them.</div><br/><div id="41833310" class="c"><input type="checkbox" id="c-41833310" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41832962">parent</a><span>|</span><a href="#41832987">next</a><span>|</span><label class="collapse" for="c-41833310">[-]</label><label class="expand" for="c-41833310">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also no expert, but from reading around the subject a little (Flash Boys by Michael Lewis was pretty cool, also Jane Street&#x27;s podcast has some fantastic information)... no. I doubt you&#x27;d be on a public cloud if low-latency trading is what you&#x27;re doing.</div><br/><div id="41834751" class="c"><input type="checkbox" id="c-41834751" checked=""/><div class="controls bullet"><span class="by">aldonius</span><span>|</span><a href="#41832728">root</a><span>|</span><a href="#41833310">parent</a><span>|</span><a href="#41832987">next</a><span>|</span><label class="collapse" for="c-41834751">[-]</label><label class="expand" for="c-41834751">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t the HFT boxes usually stock exchange colocations? Each trader gets a rack (or multiple racks depending on size) in the exchange&#x27;s datacenter, every rack has the same cable length to the switch, etc.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41832987" class="c"><input type="checkbox" id="c-41832987" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#41832728">parent</a><span>|</span><a href="#41832877">prev</a><span>|</span><a href="#41834017">next</a><span>|</span><label class="collapse" for="c-41832987">[-]</label><label class="expand" for="c-41832987">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If this is production, or for Work(TM), you need something proven.<p>I feel like part of Cloudflare&#x27;s business model is to try to convince businesses at scale to solve problems in a non-traditional way using technology they are cooking up, no matter the cost.</div><br/></div></div></div></div><div id="41833493" class="c"><input type="checkbox" id="c-41833493" checked=""/><div class="controls bullet"><span class="by">braden-lk</span><span>|</span><a href="#41834017">prev</a><span>|</span><a href="#41832723">next</a><span>|</span><label class="collapse" for="c-41833493">[-]</label><label class="expand" for="c-41833493">[4 more]</label></div><br/><div class="children"><div class="content">Durable objects seem so cool but the pricing always scares me. (Specifically, having to worry about getting hibernation right.) They’d be a great fit for our yjs document based strategy, but while everything in prod still works on plain ol redis and Postgres, it’s hard to justify an exploration.</div><br/><div id="41833761" class="c"><input type="checkbox" id="c-41833761" checked=""/><div class="controls bullet"><span class="by">attilakun</span><span>|</span><a href="#41833493">parent</a><span>|</span><a href="#41833710">next</a><span>|</span><label class="collapse" for="c-41833761">[-]</label><label class="expand" for="c-41833761">[2 more]</label></div><br/><div class="children"><div class="content">Does CloudFlare have proper spending caps? If they have, I&#x27;d be open to try DOs but if they don&#x27;t, it&#x27;s a non-starter for an indie dev as I can&#x27;t risk bankruptcy due to a bad for loop.</div><br/><div id="41834546" class="c"><input type="checkbox" id="c-41834546" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41833493">root</a><span>|</span><a href="#41833761">parent</a><span>|</span><a href="#41833710">next</a><span>|</span><label class="collapse" for="c-41834546">[-]</label><label class="expand" for="c-41834546">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just the listed prices either. There was a story here not long ago where they essentially requested someone to migrate to an enterprise plan or get out. With AWS it&#x27;s pretty common to get a refund for accidental abuse. From my contact so far and from stories here, I wouldn&#x27;t expect anything close to that treatment from CF.</div><br/></div></div></div></div><div id="41833710" class="c"><input type="checkbox" id="c-41833710" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#41833493">parent</a><span>|</span><a href="#41833761">prev</a><span>|</span><a href="#41832723">next</a><span>|</span><label class="collapse" for="c-41833710">[-]</label><label class="expand" for="c-41833710">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Specifically, having to worry about getting hibernation right.</i><p>As long as the client doesn&#x27;t exchange websocket messages with DO, it&#x27;ll hibernate. From what I can tell, ping&#x2F;pong frames don&#x27;t count towards uptime, if you&#x27;re worried about that.</div><br/></div></div></div></div><div id="41832723" class="c"><input type="checkbox" id="c-41832723" checked=""/><div class="controls bullet"><span class="by">kondro</span><span>|</span><a href="#41833493">prev</a><span>|</span><a href="#41833868">next</a><span>|</span><label class="collapse" for="c-41832723">[-]</label><label class="expand" for="c-41832723">[3 more]</label></div><br/><div class="children"><div class="content">Does this mean SQLite for DO can lose up to 10 seconds of data in the event of a failing DO?</div><br/><div id="41832730" class="c"><input type="checkbox" id="c-41832730" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#41832723">parent</a><span>|</span><a href="#41833868">next</a><span>|</span><label class="collapse" for="c-41832730">[-]</label><label class="expand" for="c-41832730">[2 more]</label></div><br/><div class="children"><div class="content">&gt; To ensure durability beyond that ten second window, writes are also forwarded to five replicas in separate nearby data centers as soon as they commit, and the write is only acknowledged once three of them have confirmed it.<p>I think Simon meant &quot;within&quot;, rather than &quot;beyond&quot;, here.</div><br/><div id="41832794" class="c"><input type="checkbox" id="c-41832794" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41832723">root</a><span>|</span><a href="#41832730">parent</a><span>|</span><a href="#41833868">next</a><span>|</span><label class="collapse" for="c-41832794">[-]</label><label class="expand" for="c-41832794">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I&#x27;ve updated that word.</div><br/></div></div></div></div></div></div><div id="41833868" class="c"><input type="checkbox" id="c-41833868" checked=""/><div class="controls bullet"><span class="by">pajeets</span><span>|</span><a href="#41832723">prev</a><span>|</span><label class="collapse" for="c-41833868">[-]</label><label class="expand" for="c-41833868">[1 more]</label></div><br/><div class="children"><div class="content">wonder how this works with Pocketbase</div><br/></div></div></div></div></div></div></div></body></html>