<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711443656754" as="style"/><link rel="stylesheet" href="styles.css?v=1711443656754"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blogs.gnome.org/rbultje/2017/07/14/writing-x86-simd-using-x86inc-asm/">Writing x86 SIMD using x86inc.asm (2017)</a>Â <span class="domain">(<a href="https://blogs.gnome.org">blogs.gnome.org</a>)</span></div><div class="subtext"><span>transpute</span> | <span>6 comments</span></div><br/><div><div id="39825506" class="c"><input type="checkbox" id="c-39825506" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39825279">next</a><span>|</span><label class="collapse" for="c-39825506">[-]</label><label class="expand" for="c-39825506">[1 more]</label></div><br/><div class="children"><div class="content">This turns out to be a lot of assembly macros to help write one x86 assembly. <a href="https:&#x2F;&#x2F;github.com&#x2F;FFmpeg&#x2F;FFmpeg&#x2F;blob&#x2F;master&#x2F;libavutil&#x2F;x86&#x2F;x86inc.asm">https:&#x2F;&#x2F;github.com&#x2F;FFmpeg&#x2F;FFmpeg&#x2F;blob&#x2F;master&#x2F;libavutil&#x2F;x86&#x2F;x...</a><p>The sibling comment recommending compiler intrinsics is probably the best way to go for writing SIMD code. A mixture of `&lt;i32 x 16&gt;` style types and intrinsics to specify instructions is a solid 90% solution compared to assembly.<p>If you want that last 10%, I think macros are putting the emphasis in the wrong place. They&#x27;re a somewhat easy way to build up a language abstraction which will work if held carefully, but I&#x27;m confident the dev experience using this abstraction when you write invalid code will be deeply confusing.<p>I would suggest to write a parser instead of the macros. That&#x27;ll tell you clearly when the syntax is invalid (though possibly not with much precision) and it&#x27;ll give you a place to put semantic analysis for where valid syntax encodes nonsense. Do the equivalent of the macro expansions on the parsed tree instead of on the text. Emit asm as the &quot;back end&quot;.</div><br/></div></div><div id="39825279" class="c"><input type="checkbox" id="c-39825279" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#39825506">prev</a><span>|</span><a href="#39825538">next</a><span>|</span><label class="collapse" for="c-39825279">[-]</label><label class="expand" for="c-39825279">[3 more]</label></div><br/><div class="children"><div class="content">There is a fourth way of writing SIMD code that is not among the three mentioned in the article: using language built-in features for SIMD.<p>For C and C++ this is GCC vector extensions (also available in Clang), for Rust (nightly) it&#x27;s std::simd.<p>Compared to other methods, this gives portability to different CPU architectures, ability to use basic arithmetic operators (+, -, *, &#x2F;), vector widths wider than the CPU supports and compiler optimizations that would be inhibited by inline assembly.<p>It may not cover every instruction available in the CPU, but there is a zero cost fallback to intrinsics when you need a particular CPU instruction (e.g. __mm_rcp_ps).<p>I&#x27;ve written a significant amount of SIMD code in C, C++ and Rust using builtins and it&#x27;s quite a pleasant experience compared to other methods.</div><br/><div id="39825446" class="c"><input type="checkbox" id="c-39825446" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#39825279">parent</a><span>|</span><a href="#39825538">next</a><span>|</span><label class="collapse" for="c-39825446">[-]</label><label class="expand" for="c-39825446">[2 more]</label></div><br/><div class="children"><div class="content">Very good point, thanks!<p>The ever-popular Mr Lemire often uses this technique, I think it&#x27;s way easier to follow than straight up assembly. See for instance [1], his post about prefix-recognition in strings (not randomly chosen, it was simply the first post with code that I found when I searched for &quot;simd&quot;).<p>[1]: <a href="https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;07&#x2F;14&#x2F;recognizing-string-prefixes-with-simd-instructions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;07&#x2F;14&#x2F;recognizing-string-prefixe...</a></div><br/><div id="39825508" class="c"><input type="checkbox" id="c-39825508" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#39825279">root</a><span>|</span><a href="#39825446">parent</a><span>|</span><a href="#39825538">next</a><span>|</span><label class="collapse" for="c-39825508">[-]</label><label class="expand" for="c-39825508">[1 more]</label></div><br/><div class="children"><div class="content">The article you link to uses Intel intrinsics, not built-in vector extensions.<p>Intrinsics are probably the most popular method of doing SIMD but they are not portable to other CPUs and are quite difficult to discover due to shorthand naming conventions and lack of general level documentation.<p>Each of the Intel intrinsic functions are well documented but figuring out which ones you need out of the 600 or so available functions is not easy. Situation is worse for ARM.</div><br/></div></div></div></div></div></div><div id="39825538" class="c"><input type="checkbox" id="c-39825538" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#39825279">prev</a><span>|</span><label class="collapse" for="c-39825538">[-]</label><label class="expand" for="c-39825538">[1 more]</label></div><br/><div class="children"><div class="content">Nowadays this is a fringe way to write SIMD code, if you use something like simd-everywhere you will be able to write SIMD code for ARM, x86, RISC-V... who share quite a bit of common ground.
It&#x27;s easy to think we can schedule instructions and spill registers better than compilers but only is some extreme cases.
Assembly is also longer to write than intrinsics and harder to read, and doesn&#x27;t get better over time as the compiler improves.</div><br/></div></div></div></div></div></div></div></body></html>