<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709197271225" as="style"/><link rel="stylesheet" href="styles.css?v=1709197271225"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Vyxal/Vyxal">Vyxal: A code-golfing language experience</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>tosh</span> | <span>31 comments</span></div><br/><div><div id="39540956" class="c"><input type="checkbox" id="c-39540956" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540810">next</a><span>|</span><label class="collapse" for="c-39540956">[-]</label><label class="expand" for="c-39540956">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Vyxal is an stack-based esoteric array language that is dedicated to dominating competition in code golf challenges. This means that it strips away all need for boilerplate, long function names and impractical source layouts.<p>&gt; Functions are a core part of Vyxal. They are first class objects, meaning that you can have functions on the stack, functions can take functions as arguments, and functions can return functions.<p>This is actually all you need for writing very compact code.
If you were to strip away all other features of Vyxal, namely variables, stacks, numbers, strings, lists, and all control flow, and have only functions from functions to functions, plus some way to use these for input and output, then you have Binary Lambda Calculus [1].<p>The Vyxal code for the infinite list of Fibonacci numbers is   13 bytes long.
In comparison, the BLC code is only 78 bits, or just under 10 bytes: 010101000110100000000001011011001010111110111101110000111110011110100000100010.<p>Or graphically [2]:<p><pre><code>    ┬─┬ ────┬─┬──────── ─ ┬
    └─┤ ────┼─┼─┬─┬──── ┬ │
      │ ──┬─┼─┼─┼─┼─┬── │ │
      │ ┬─┼─┼─┼─┼─┼─┼── │ │
      │ └─┤ └─┤ │ ┼─┼─┬ │ │
      │   │   └─┤ │ ├─┘ │ │
      │   │     │ ├─┘   │ │
      │   │     ├─┘     │ │
      │   ├─────┘       │ │
      └───┤             │ │
          └─────────────┤ │
                        └─┘
</code></pre>
[1] <a href="https:&#x2F;&#x2F;www.ioccc.org&#x2F;2012&#x2F;tromp&#x2F;hint.html" rel="nofollow">https:&#x2F;&#x2F;www.ioccc.org&#x2F;2012&#x2F;tromp&#x2F;hint.html</a><p>[2] <a href="https:&#x2F;&#x2F;tromp.github.io&#x2F;cl&#x2F;diagrams.html" rel="nofollow">https:&#x2F;&#x2F;tromp.github.io&#x2F;cl&#x2F;diagrams.html</a></div><br/><div id="39541361" class="c"><input type="checkbox" id="c-39541361" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#39540956">parent</a><span>|</span><a href="#39541266">next</a><span>|</span><label class="collapse" for="c-39541361">[-]</label><label class="expand" for="c-39541361">[3 more]</label></div><br/><div class="children"><div class="content">&gt; strips away all need for boilerplate<p>Looks like this includes special optimizations for common problems including hello world (kh) and fizzbuzz (kF), but not 99 bottles of beer.<p><a href="https:&#x2F;&#x2F;vyxapedia.hyper-neutrino.xyz&#x2F;elements" rel="nofollow">https:&#x2F;&#x2F;vyxapedia.hyper-neutrino.xyz&#x2F;elements</a></div><br/><div id="39546624" class="c"><input type="checkbox" id="c-39546624" checked=""/><div class="controls bullet"><span class="by">aqfamnzc</span><span>|</span><a href="#39540956">root</a><span>|</span><a href="#39541361">parent</a><span>|</span><a href="#39541266">next</a><span>|</span><label class="collapse" for="c-39546624">[-]</label><label class="expand" for="c-39546624">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, that doesn&#x27;t seem fair. At that point, why not encode a huge library of programming challenges into the language spec to beat all the challenges with just a couple of chars? Oh well, I suppose it&#x27;s not really a competition in the usual sense so it doesn&#x27;t really matter. And code golf language comparisons are kind of apples-to-oranges huh.</div><br/><div id="39547631" class="c"><input type="checkbox" id="c-39547631" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#39540956">root</a><span>|</span><a href="#39546624">parent</a><span>|</span><a href="#39541266">next</a><span>|</span><label class="collapse" for="c-39547631">[-]</label><label class="expand" for="c-39547631">[1 more]</label></div><br/><div class="children"><div class="content">What about getting a large set of programming challenges as input and finding an esoteric standard library using some optimization algorithm, when combined, can solve any challenge in minimal program size<p>Such standard library could contain weird operations that, while not specifically solving a single program, would each be pretty hard to grasp in order to use to do something useful</div><br/></div></div></div></div></div></div><div id="39541266" class="c"><input type="checkbox" id="c-39541266" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39540956">parent</a><span>|</span><a href="#39541361">prev</a><span>|</span><a href="#39540810">next</a><span>|</span><label class="collapse" for="c-39541266">[-]</label><label class="expand" for="c-39541266">[5 more]</label></div><br/><div class="children"><div class="content">Does that output a string of bits, or decimal numbers?</div><br/><div id="39541367" class="c"><input type="checkbox" id="c-39541367" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540956">root</a><span>|</span><a href="#39541266">parent</a><span>|</span><a href="#39540810">next</a><span>|</span><label class="collapse" for="c-39541367">[-]</label><label class="expand" for="c-39541367">[4 more]</label></div><br/><div class="children"><div class="content">It computes a list (as nested pairs in the standard lambda calculus representation) of Church numerals (the standard representation of natural numbers). See also the discussion of the 167-bit primes program output in the first link, which gives an impression of the overhead needed for output in decimals.</div><br/><div id="39541637" class="c"><input type="checkbox" id="c-39541637" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39540956">root</a><span>|</span><a href="#39541367">parent</a><span>|</span><a href="#39543488">prev</a><span>|</span><a href="#39540810">next</a><span>|</span><label class="collapse" for="c-39541637">[-]</label><label class="expand" for="c-39541637">[2 more]</label></div><br/><div class="children"><div class="content">So how long is the code to convert those representations into ASCII or Unicode decimal strings?</div><br/><div id="39542068" class="c"><input type="checkbox" id="c-39542068" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540956">root</a><span>|</span><a href="#39541637">parent</a><span>|</span><a href="#39540810">next</a><span>|</span><label class="collapse" for="c-39542068">[-]</label><label class="expand" for="c-39542068">[1 more]</label></div><br/><div class="children"><div class="content">The size of <a href="https:&#x2F;&#x2F;www.ioccc.org&#x2F;2012&#x2F;tromp&#x2F;oddindices.Blc" rel="nofollow">https:&#x2F;&#x2F;www.ioccc.org&#x2F;2012&#x2F;tromp&#x2F;oddindices.Blc</a> is 84 bytes.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39540810" class="c"><input type="checkbox" id="c-39540810" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#39540956">prev</a><span>|</span><a href="#39540991">next</a><span>|</span><label class="collapse" for="c-39540810">[-]</label><label class="expand" for="c-39540810">[6 more]</label></div><br/><div class="children"><div class="content">Huh, 
once you add a compiler step to turn normal code into &quot;golfed&quot; code, it feels like a different thing, with the goal being to write a compact bytecode format.<p>This one seems mostly like a workaround for having to type weird Unicode characters, so it still seem &quot;fair&quot; to me whatever that means.<p>But I wonder how much a normal java program can be auto golfed by playing with the bytecode output.</div><br/><div id="39543658" class="c"><input type="checkbox" id="c-39543658" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#39540810">parent</a><span>|</span><a href="#39541575">next</a><span>|</span><label class="collapse" for="c-39543658">[-]</label><label class="expand" for="c-39543658">[1 more]</label></div><br/><div class="children"><div class="content">In <i>my</i> golf language, called stax, each program expressible in plain ASCII has a corresponding representation in a single byte character set. [0]  The only reason a program wouldn&#x27;t start in plain ASCII is the contents of string literals.<p>The alternate representation generally saves ~15%, as measured in bytes.  However, I totally understand the argument about human-unreadable &quot;golfed&quot; code, which is why you can always use the plain ASCII representation if you want.<p>For instance, you can print fibonacci numbers in an infinite loop using this program. [1]<p><pre><code>    10Wb+Q
</code></pre>
It pushes one and zero to the stack.  Then `W` repeats the rest of the program forever.  `b+` copies the top 2 elements from the stack and adds them.  `Q` peeks from the stack and prints to output.  This program packs down to `╪Ç►╢0` for a savings of 1 byte (using the languages own impractical character encoding).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;tomtheisen&#x2F;stax&#x2F;blob&#x2F;master&#x2F;docs&#x2F;packed.md#packed-stax">https:&#x2F;&#x2F;github.com&#x2F;tomtheisen&#x2F;stax&#x2F;blob&#x2F;master&#x2F;docs&#x2F;packed.m...</a><p>[1] <a href="https:&#x2F;&#x2F;staxlang.xyz&#x2F;#c=10Wb%2BQ&amp;i=" rel="nofollow">https:&#x2F;&#x2F;staxlang.xyz&#x2F;#c=10Wb%2BQ&amp;i=</a></div><br/></div></div><div id="39541575" class="c"><input type="checkbox" id="c-39541575" checked=""/><div class="controls bullet"><span class="by">posix86</span><span>|</span><a href="#39540810">parent</a><span>|</span><a href="#39543658">prev</a><span>|</span><a href="#39543104">next</a><span>|</span><label class="collapse" for="c-39541575">[-]</label><label class="expand" for="c-39541575">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the whole purpose of golfing to write compact in higher level languages? If writing the lower level is too hard, it&#x27;s no different to jars, pyc, or x86 files.</div><br/><div id="39541665" class="c"><input type="checkbox" id="c-39541665" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#39540810">root</a><span>|</span><a href="#39541575">parent</a><span>|</span><a href="#39543104">next</a><span>|</span><label class="collapse" for="c-39541665">[-]</label><label class="expand" for="c-39541665">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, totally. I guess really the way to think about it is that any code golfing problem is a separate competition between each language. What&#x27;s the shortest you can get in JS, in Java, in Pyth etc.<p>Languages made just for golfing, and how many of them there are, seem a little silly, but theyre cute to look at and fun to make i&#x27;m sure. Its art :p Not complaining.</div><br/><div id="39542282" class="c"><input type="checkbox" id="c-39542282" checked=""/><div class="controls bullet"><span class="by">MrZander</span><span>|</span><a href="#39540810">root</a><span>|</span><a href="#39541665">parent</a><span>|</span><a href="#39543104">next</a><span>|</span><label class="collapse" for="c-39542282">[-]</label><label class="expand" for="c-39542282">[1 more]</label></div><br/><div class="children"><div class="content">I agree.  I used to frequent codegolf.stackexchange.com but nowadays it&#x27;s just a bunch of 2 character solutions in 50 different home-grown golfing languages.<p>Golfing languages can be fun, but they do feel like something totally different than trying to make a 200 line C program run in 200 bytes.</div><br/></div></div></div></div></div></div><div id="39543104" class="c"><input type="checkbox" id="c-39543104" checked=""/><div class="controls bullet"><span class="by">myhf</span><span>|</span><a href="#39540810">parent</a><span>|</span><a href="#39541575">prev</a><span>|</span><a href="#39540991">next</a><span>|</span><label class="collapse" for="c-39543104">[-]</label><label class="expand" for="c-39543104">[1 more]</label></div><br/><div class="children"><div class="content">There are still different approaches within the same language, and having a broad consensus about which constants and abbreviations are part of the standard library puts more competitive focus on the algorithm instead of the encoding.</div><br/></div></div></div></div><div id="39540991" class="c"><input type="checkbox" id="c-39540991" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39540810">prev</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39540991">[-]</label><label class="expand" for="c-39540991">[10 more]</label></div><br/><div class="children"><div class="content">I think the size of the interpreter for Vyxal should be included in the scoring, if we&#x27;re going to be really consistent about this.<p>On the other hand, if you&#x27;re going to allow plaintext to be compressed into bytecode, why not include a Huffman encoder as part of the flow?  The FizzBuzz example has a string splitter in it (apparently, I haven&#x27;t read ALL the docs), just to get around quoting some strings, but quotes might be less than a byte if you do them enough, etc.<p>Lastly, who can make the smallest Vyxal executable? <i>Let&#x27;s use Jart&#x27;s excellent Acutally Portable Executable[1] format as a kicking off point.</i> That seems like the best way to make it work for almost anyone. If not, then maybe DOS&#x2F;Windows&#x2F;Arm&#x2F;VAX&#x2F;PDP-11&#x2F;Z80 categories might be needed?<p>A Vyxal compliance suite of tests is required to enable all of the above. Who can make it the smallest?  ;-)<p>[1] <a href="https:&#x2F;&#x2F;justine.lol&#x2F;ape.html" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;ape.html</a></div><br/><div id="39544911" class="c"><input type="checkbox" id="c-39544911" checked=""/><div class="controls bullet"><span class="by">creatonez</span><span>|</span><a href="#39540991">parent</a><span>|</span><a href="#39541174">next</a><span>|</span><label class="collapse" for="c-39544911">[-]</label><label class="expand" for="c-39544911">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I think the size of the interpreter for Vyxal should be included in the scoring, if we&#x27;re going to be really consistent about this.<p>Code Golf categories are arbitrary anyways, and can be as strict or as permissible as the golf course designer likes. If you need the most raw representation of code size, how about a code golf category where you have to design the smallest physical computer that can perform a certain task?<p>&gt; Who can make it the smallest?<p>I noticed that in Vyxel 2 the language allows you to grab arbitrary Python modules and make calls, but this doesn&#x27;t seem to be available anymore in Vyxel 3. So I&#x27;m thinking you can make a smaller Vyxel 3 implementation than 2. Either way, both reference implementations are fairly large runtimes.</div><br/></div></div><div id="39541174" class="c"><input type="checkbox" id="c-39541174" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540991">parent</a><span>|</span><a href="#39544911">prev</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39541174">[-]</label><label class="expand" for="c-39541174">[8 more]</label></div><br/><div class="children"><div class="content">&gt; the size of the interpreter for vyval should be included in the scoring<p>But an interpreter in what language?</div><br/><div id="39541228" class="c"><input type="checkbox" id="c-39541228" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39541174">parent</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39541228">[-]</label><label class="expand" for="c-39541228">[7 more]</label></div><br/><div class="children"><div class="content">the demoscene version is assembly on a specific machine, which seems very fair to me.<p>Compared to code golfing, where finding a language with the closest built ins for the task is a good bit of the strategy</div><br/><div id="39541324" class="c"><input type="checkbox" id="c-39541324" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39541228">parent</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39541324">[-]</label><label class="expand" for="c-39541324">[6 more]</label></div><br/><div class="children"><div class="content">&gt; assembly on a specific machine, which seems very fair to me.<p>It seems a little biased toward imperative languages. The earliest models of computation, namely combinatory logic with S &amp; K, and the lambda calculus, date back to 1920s, and being exceedingly simple, can easily be implemented in any modern functional language. But not so easily in an imperative one, which have no support for closures.<p>On the other hand, implementing an imperative language in a functional one is relatively straightforward.</div><br/><div id="39541434" class="c"><input type="checkbox" id="c-39541434" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39541324">parent</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39541434">[-]</label><label class="expand" for="c-39541434">[5 more]</label></div><br/><div class="children"><div class="content">Any defined runtime seems fair, though a real computer will always seem more canonical.<p>The two parts that seem unfair to me:<p>1. There&#x27;s hidden bits of information based on choosing one language over another that can&#x27;t be counted. Imagine a family of 26 languages that are the same except the first letter is different etc.<p>2. Some of the golfing is in how good the language you picked is in their bytecode and not how clever your solution is<p>Standardizing on one format would fix those, but you would lose the cuteness compared to demoscene of turning on your phyaical computer and trying it out, and you would lose compared to current code golf the fun of finding and playing with new cool languages<p>Or I guess just treat each language as a separate category and not compare between them</div><br/><div id="39542180" class="c"><input type="checkbox" id="c-39542180" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39541434">parent</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39542180">[-]</label><label class="expand" for="c-39542180">[4 more]</label></div><br/><div class="children"><div class="content">My motivation in defining BLC was to have the simplest measure of the complexity of things. That includes binary strings, natural numbers, tuples, lists, sets, and functions of those, as well as languages (according to their interpreter) and formal systems (according to their theorem enumerator) [1].<p>[1] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;tromp&#x2F;86b3184f852f65bfb814e3ab0987d861" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;tromp&#x2F;86b3184f852f65bfb814e3ab0987d8...</a></div><br/><div id="39546393" class="c"><input type="checkbox" id="c-39546393" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39542180">parent</a><span>|</span><a href="#39542452">next</a><span>|</span><label class="collapse" for="c-39546393">[-]</label><label class="expand" for="c-39546393">[2 more]</label></div><br/><div class="children"><div class="content">How does it compare to BrainPhoque, the language used in <i>Learning Universal Predictors</i> (Hutter 2024) to approximate normalized Solomonoff induction?</div><br/><div id="39547198" class="c"><input type="checkbox" id="c-39547198" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39546393">parent</a><span>|</span><a href="#39542452">next</a><span>|</span><label class="collapse" for="c-39547198">[-]</label><label class="expand" for="c-39547198">[1 more]</label></div><br/><div class="children"><div class="content">BP is like a slightly messier BrainFuck. Its alphabet size of 17 is rather odd. Its spec (Section E.2 of [1]) says<p>&gt; programs containing unbalanced parentheses are made valid, in particular by skipping any additional ].<p>But that still leaves programs invalid programs like &quot;[[[[&quot;.<p>From a theoretical viewpoint, its biggest flaw is the lack of an input tape, which makes it a non-optimal description method in the sense of [2]. In particular, while BLC programs are at most a constant larger than BP ones, the reverse is not true.<p>The version of BF that I interpret in [3] is still optimally universal, because its program delimiting fist unbalanced ] is followed by its binary input.<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2401.14953v1" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2401.14953v1</a><p>[2] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;tromp&#x2F;86b3184f852f65bfb814e3ab0987d861#universality" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;tromp&#x2F;86b3184f852f65bfb814e3ab0987d8...</a><p>[3] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;tromp&#x2F;86b3184f852f65bfb814e3ab0987d861#brainfuck" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;tromp&#x2F;86b3184f852f65bfb814e3ab0987d8...</a></div><br/></div></div></div></div><div id="39542452" class="c"><input type="checkbox" id="c-39542452" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#39540991">root</a><span>|</span><a href="#39542180">parent</a><span>|</span><a href="#39546393">prev</a><span>|</span><a href="#39544417">next</a><span>|</span><label class="collapse" for="c-39542452">[-]</label><label class="expand" for="c-39542452">[1 more]</label></div><br/><div class="children"><div class="content">Oh, is BLC yours? I saw the link posted earlier in the thread, its beautiful.<p>Still trying to understand it but yeah, there&#x27;s definitely a mathematical purity to it that some random ASM language doesn&#x27;t have.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39544417" class="c"><input type="checkbox" id="c-39544417" checked=""/><div class="controls bullet"><span class="by">tkwa</span><span>|</span><a href="#39540991">prev</a><span>|</span><a href="#39544010">next</a><span>|</span><label class="collapse" for="c-39544417">[-]</label><label class="expand" for="c-39544417">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Vyxal aims to bridge the gap between simplicity and &quot;golfability&quot;.<p>With code golfing languages, there are inherent tradeoffs between code size and usability&#x2F;fun. IMO the most important features for minimizing length (assuming the only rule is the interpreter must be published before the challenge) are:<p>* (in Vyxal) Efficient syntax. Not sure what state of the art is anymore but stack-based seems reasonable.<p>* (in Vyxal) String compression<p>* (not in Vyxal) Efficient encoding; Huffman coding at a minimum but ideally arithmetic coding using sophisticated machine learning to predict the next command. It&#x27;s super inefficient to have each command be 1 or 2 bytes regardless of frequency.<p>* (not in Vyxal) Huge numbers of builtins; Vyxal has &quot;only&quot; ~560. Ideally every past code golf question and every OEIS sequence are their own builtin.<p>Vyxal might hit a sweet spot, but I&#x27;m skeptical that it actually score as well as other languages with more of these features.</div><br/></div></div><div id="39544010" class="c"><input type="checkbox" id="c-39544010" checked=""/><div class="controls bullet"><span class="by">creatonez</span><span>|</span><a href="#39544417">prev</a><span>|</span><a href="#39544323">next</a><span>|</span><label class="collapse" for="c-39544010">[-]</label><label class="expand" for="c-39544010">[1 more]</label></div><br/><div class="children"><div class="content">Since version 3 was rewritten from Python to Scala, does that mean it drops support for Python FFI? Does it replace it with Java FFI?<p>Python FFI in Vyxal was neat because you could trivially import python libraries like sockets, or start doing FFI to C libraries with calls to Python&#x27;s ctypes. It was a mess but it&#x27;s satisfying just how many different cross-cutting concerns you could glue together with very little code, when most other esolangs don&#x27;t provide much of a standard library.</div><br/></div></div><div id="39544323" class="c"><input type="checkbox" id="c-39544323" checked=""/><div class="controls bullet"><span class="by">Nuzzerino</span><span>|</span><a href="#39544010">prev</a><span>|</span><a href="#39540987">next</a><span>|</span><label class="collapse" for="c-39544323">[-]</label><label class="expand" for="c-39544323">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of this, which I used back in the day when I was competitive on that site 
<a href="https:&#x2F;&#x2F;www.hacker.org&#x2F;hvm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hacker.org&#x2F;hvm&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>