<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704704462120" as="style"/><link rel="stylesheet" href="styles.css?v=1704704462120"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/moturus/motor-os">MotorOS: a Rust-first operating system for x64 VMs</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>sbt567</span> | <span>56 comments</span></div><br/><div><div id="38908037" class="c"><input type="checkbox" id="c-38908037" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#38908564">next</a><span>|</span><label class="collapse" for="c-38908037">[-]</label><label class="expand" for="c-38908037">[2 more]</label></div><br/><div class="children"><div class="content">The author wrote this on reddit:<p>&gt; What does &quot;Rust-first&quot; mean here? It means not only that both the (micro) kernel and the drivers are implemented in Rust, but also that Rust is the first (and only, at the moment) language that userspace programs can be written in.<p>&gt; Although technically one can reverse-engineer the Rust-based ABI and the provided Rust toolchain to write apps for Motor OS in e.g. C, that is some work. But standard Rust programs (using standard Rust library, without FFI) will just compile and run - see e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;moturus&#x2F;motor-os&#x2F;tree&#x2F;main&#x2F;src&#x2F;bin&#x2F;httpd">https:&#x2F;&#x2F;github.com&#x2F;moturus&#x2F;motor-os&#x2F;tree&#x2F;main&#x2F;src&#x2F;bin&#x2F;httpd</a>.<p>&gt; This Rust-first approach is rather unique, as e.g. Redox uses relibc and C-based kernel ABI as the glue...<p><a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;190znk5&#x2F;mot%C5%ABrus_os_motor_os_a_rustfirst_operating_system&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;190znk5&#x2F;mot%C5%ABrus_...</a></div><br/><div id="38908696" class="c"><input type="checkbox" id="c-38908696" checked=""/><div class="controls bullet"><span class="by">glonq</span><span>|</span><a href="#38908037">parent</a><span>|</span><a href="#38908564">next</a><span>|</span><label class="collapse" for="c-38908696">[-]</label><label class="expand" for="c-38908696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is the first (and only, at the moment) language that userspace programs can be written in.<p>Shouldn&#x27;t be much effort to make it compatible with Crablang, no?<p>&#x2F;s</div><br/></div></div></div></div><div id="38908564" class="c"><input type="checkbox" id="c-38908564" checked=""/><div class="controls bullet"><span class="by">bluejekyll</span><span>|</span><a href="#38908037">prev</a><span>|</span><a href="#38908866">next</a><span>|</span><label class="collapse" for="c-38908564">[-]</label><label class="expand" for="c-38908564">[2 more]</label></div><br/><div class="children"><div class="content">One thing I keep hoping to see in all of these kernels in Rust is an async first kernel. Is there something that makes this particularly difficult or do folks not see the value in it? I know from following along with Phil Oppermann’s OS in Rust series that is definitely possible, but these last few OS’ in Rust seem to not be attempting this, <a href="https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;" rel="nofollow">https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;</a></div><br/><div id="38908813" class="c"><input type="checkbox" id="c-38908813" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#38908564">parent</a><span>|</span><a href="#38908866">next</a><span>|</span><label class="collapse" for="c-38908813">[-]</label><label class="expand" for="c-38908813">[1 more]</label></div><br/><div class="children"><div class="content">There are so many posts about how async Rust isn&#x27;t the right abstraction it would surprise me if someone doubled-down on it right now.</div><br/></div></div></div></div><div id="38908866" class="c"><input type="checkbox" id="c-38908866" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#38908564">prev</a><span>|</span><a href="#38907937">next</a><span>|</span><label class="collapse" for="c-38908866">[-]</label><label class="expand" for="c-38908866">[5 more]</label></div><br/><div class="children"><div class="content">Out of curiousity, why would a small kernel take a whole 200ms to start on a modern computer? Wouldn&#x27;t it need to initialize some metadata for the memory pages, mount the filesystem, and try to launch an init process? I suppose there might be an ethernet driver and possibly something to pipe logs to (&quot;stdout&quot; for the VM) to initialize. Shouldn&#x27;t that all take a few microseconds?<p>Or is all the slowness in the host preparing the resources? (as in QEMU and KVM?)</div><br/><div id="38909016" class="c"><input type="checkbox" id="c-38909016" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#38908866">parent</a><span>|</span><a href="#38909001">next</a><span>|</span><label class="collapse" for="c-38909016">[-]</label><label class="expand" for="c-38909016">[1 more]</label></div><br/><div class="children"><div class="content">4 months ago we had FreeBSD booting in 25ms. That gives some insight where the bottlenecks might be: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37319180">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37319180</a></div><br/></div></div><div id="38909001" class="c"><input type="checkbox" id="c-38909001" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#38908866">parent</a><span>|</span><a href="#38909016">prev</a><span>|</span><a href="#38908968">next</a><span>|</span><label class="collapse" for="c-38909001">[-]</label><label class="expand" for="c-38909001">[2 more]</label></div><br/><div class="children"><div class="content">In general, lots of hardware requires long waits to initialize. As in, program a value then you must wait 50 ms before querying the registers or the hardware will give you non-deterministic garbage with no error indication.<p>So, it depends on the hardware, though you are unlikely to need more than 1 second on anything other than truly degenerate hardware assuming you are initializing devices in parallel.</div><br/><div id="38909121" class="c"><input type="checkbox" id="c-38909121" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#38908866">root</a><span>|</span><a href="#38909001">parent</a><span>|</span><a href="#38908968">next</a><span>|</span><label class="collapse" for="c-38909121">[-]</label><label class="expand" for="c-38909121">[1 more]</label></div><br/><div class="children"><div class="content">But it’s only for VMs. So what hardware are you initializing?</div><br/></div></div></div></div></div></div><div id="38907937" class="c"><input type="checkbox" id="c-38907937" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#38908866">prev</a><span>|</span><a href="#38908702">next</a><span>|</span><label class="collapse" for="c-38907937">[-]</label><label class="expand" for="c-38907937">[4 more]</label></div><br/><div class="children"><div class="content">It sounds like a cool project and I hope it continues development, but there is such a huge graveyard of such projects that have never gone anywhere that I struggle to get excited about them anymore. Replacing Linux is really hard, even for specific uses like cloud.</div><br/><div id="38908740" class="c"><input type="checkbox" id="c-38908740" checked=""/><div class="controls bullet"><span class="by">seanw444</span><span>|</span><a href="#38907937">parent</a><span>|</span><a href="#38908702">next</a><span>|</span><label class="collapse" for="c-38908740">[-]</label><label class="expand" for="c-38908740">[3 more]</label></div><br/><div class="children"><div class="content">Replacing Linux is hard even for the BSDs, and those are very well established and considered basically next-in-line for similar tasks.</div><br/><div id="38909203" class="c"><input type="checkbox" id="c-38909203" checked=""/><div class="controls bullet"><span class="by">haarts</span><span>|</span><a href="#38907937">root</a><span>|</span><a href="#38908740">parent</a><span>|</span><a href="#38908702">next</a><span>|</span><label class="collapse" for="c-38909203">[-]</label><label class="expand" for="c-38909203">[2 more]</label></div><br/><div class="children"><div class="content">You think BSDs are next-in-line? Why is that? 
I have the distinct impression BSDs will remain niche. Something radical (like MotorOS?) seems more likely.</div><br/><div id="38909247" class="c"><input type="checkbox" id="c-38909247" checked=""/><div class="controls bullet"><span class="by">dylukes</span><span>|</span><a href="#38907937">root</a><span>|</span><a href="#38909203">parent</a><span>|</span><a href="#38908702">next</a><span>|</span><label class="collapse" for="c-38909247">[-]</label><label class="expand" for="c-38909247">[1 more]</label></div><br/><div class="children"><div class="content">What do you think is running on your favorite game consoles (that aren&#x27;t Xbox)? I&#x27;ll give you a hint, it isn&#x27;t Linux.<p>Nintendo is using a custom OS but with a huge chunk of user space borrowed from FreeBSD. Sony on the other hand just went and forked FreeBSD outright.<p>You might also want to look into what OS are being used for server environments. A lot more BSD there than you might have initially guessed.</div><br/></div></div></div></div></div></div></div></div><div id="38908702" class="c"><input type="checkbox" id="c-38908702" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#38907937">prev</a><span>|</span><a href="#38908092">next</a><span>|</span><label class="collapse" for="c-38908702">[-]</label><label class="expand" for="c-38908702">[6 more]</label></div><br/><div class="children"><div class="content">Sounds interesting, but it also reminds me of what Linus once said when asked about fearing competition.
From my memory his answer was something like: I really like writing device drivers. Few people like that and until someone young and hungry comes along who likes that I&#x27;m not afraid of competition.</div><br/><div id="38908842" class="c"><input type="checkbox" id="c-38908842" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#38908702">parent</a><span>|</span><a href="#38908092">next</a><span>|</span><label class="collapse" for="c-38908842">[-]</label><label class="expand" for="c-38908842">[5 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need very many device drivers to run in a VM.<p>The real question is, how useful is a non-C-compatible, non-Linux-compatible, VM-only OS. Maybe a little bit, for microservices?</div><br/><div id="38909531" class="c"><input type="checkbox" id="c-38909531" checked=""/><div class="controls bullet"><span class="by">slau</span><span>|</span><a href="#38908702">root</a><span>|</span><a href="#38908842">parent</a><span>|</span><a href="#38909075">next</a><span>|</span><label class="collapse" for="c-38909531">[-]</label><label class="expand" for="c-38909531">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s relatively trivial to have a `FROM scratch` dockerised microservice in Rust. I&#x27;m not convinced having an entire OS brings that much to the table.</div><br/></div></div><div id="38909075" class="c"><input type="checkbox" id="c-38909075" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#38908702">root</a><span>|</span><a href="#38908842">parent</a><span>|</span><a href="#38909531">prev</a><span>|</span><a href="#38909004">next</a><span>|</span><label class="collapse" for="c-38909075">[-]</label><label class="expand" for="c-38909075">[2 more]</label></div><br/><div class="children"><div class="content">According to <i>The American Heritage Dictionary</i> an operating system is:<p><i>&quot;Software designed to control the hardware of a specific data-processing system in order to allow users and application programs to make use of it.&quot;</i><p>The question is how much <i>Operating System</i> is a software that delegates all <i>&quot;control the hardware&quot;</i> parts to the layer below.<p>I know there are wider definitions of OS, but my point is this is not going to replace Linux.<p>Without question projects like MotorOS are sill useful. Besides practical applications it&#x27;s a nice idea. Just recently I wrote in another thread that I would love to have a glimpse into an alternative universe, where Pascal had won over C and everything was Pascal-based. The idea to have everything Rust-based is even more exciting.</div><br/></div></div><div id="38909004" class="c"><input type="checkbox" id="c-38909004" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38908702">root</a><span>|</span><a href="#38908842">parent</a><span>|</span><a href="#38909075">prev</a><span>|</span><a href="#38908092">next</a><span>|</span><label class="collapse" for="c-38909004">[-]</label><label class="expand" for="c-38909004">[1 more]</label></div><br/><div class="children"><div class="content">Is this really non-C-compatible? Seems like it just needs a libc layer written in rust. Most C programs don&#x27;t make syscalls directly anyways (on some OSes they aren&#x27;t even able to). The rest of the question is definitely fair though.</div><br/></div></div></div></div></div></div><div id="38908092" class="c"><input type="checkbox" id="c-38908092" checked=""/><div class="controls bullet"><span class="by">paulirotta</span><span>|</span><a href="#38908702">prev</a><span>|</span><a href="#38907876">next</a><span>|</span><label class="collapse" for="c-38908092">[-]</label><label class="expand" for="c-38908092">[1 more]</label></div><br/><div class="children"><div class="content">I was skeptical at first- the healthy approach to any new tech. But thinking again, the efficiency and security gains from stripping away layers of cruft after rather compelling</div><br/></div></div><div id="38907876" class="c"><input type="checkbox" id="c-38907876" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38908092">prev</a><span>|</span><a href="#38908923">next</a><span>|</span><label class="collapse" for="c-38907876">[-]</label><label class="expand" for="c-38907876">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Maestro: A Linux-compatible kernel in Rust&quot; (2023) 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38852360#38857185">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38852360#38857185</a> ; redox-os, cosmic-de , Motūrus OS; MotorOS</div><br/></div></div><div id="38908923" class="c"><input type="checkbox" id="c-38908923" checked=""/><div class="controls bullet"><span class="by">ianbicking</span><span>|</span><a href="#38907876">prev</a><span>|</span><a href="#38908622">next</a><span>|</span><label class="collapse" for="c-38908923">[-]</label><label class="expand" for="c-38908923">[2 more]</label></div><br/><div class="children"><div class="content">It could be cool if there was a WASM container built in Rust that could run in this OS. I don&#x27;t really have a sense of how complicated a WASM container is, though it seems non-trivial to even decide <i>what</i> such a thing is, so it would be nice not to treat the WASM container itself as the OS (i.e., more room to safely experiment). WASM also seems like it dodges the ABI issue by being more explicitly about composition instead of shared binary data structures.</div><br/><div id="38908993" class="c"><input type="checkbox" id="c-38908993" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38908923">parent</a><span>|</span><a href="#38908622">next</a><span>|</span><label class="collapse" for="c-38908993">[-]</label><label class="expand" for="c-38908993">[1 more]</label></div><br/><div class="children"><div class="content">When you say wasm container, you mean something like wasmtime that provides a non-browser wasm runtime?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime">https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime</a></div><br/></div></div></div></div><div id="38908622" class="c"><input type="checkbox" id="c-38908622" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#38908923">prev</a><span>|</span><a href="#38908817">next</a><span>|</span><label class="collapse" for="c-38908622">[-]</label><label class="expand" for="c-38908622">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Nix OS all exist because of Linux&#x27;s complexity<p>That said, I would be thrilled to build this and other alt OSes and their userlands with Nix &#x2F; Nixpkgs :).</div><br/><div id="38908978" class="c"><input type="checkbox" id="c-38908978" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#38908622">parent</a><span>|</span><a href="#38908817">next</a><span>|</span><label class="collapse" for="c-38908978">[-]</label><label class="expand" for="c-38908978">[2 more]</label></div><br/><div class="children"><div class="content">&gt; because of Linux&#x27;s complexity<p>Linux is not complex but there are some design issues with C ABI and glibc stability and symlinks.</div><br/><div id="38909623" class="c"><input type="checkbox" id="c-38909623" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#38908622">root</a><span>|</span><a href="#38908978">parent</a><span>|</span><a href="#38908817">next</a><span>|</span><label class="collapse" for="c-38909623">[-]</label><label class="expand" for="c-38909623">[1 more]</label></div><br/><div class="children"><div class="content">Indeed I would say Linux is as simple as possible given various goals ... however, &#x27;simple as possible&#x27; can still be complex!</div><br/></div></div></div></div></div></div><div id="38908817" class="c"><input type="checkbox" id="c-38908817" checked=""/><div class="controls bullet"><span class="by">micahcc</span><span>|</span><a href="#38908622">prev</a><span>|</span><a href="#38909148">next</a><span>|</span><label class="collapse" for="c-38908817">[-]</label><label class="expand" for="c-38908817">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a simple multi-processor round robin (SMP)<p>&gt; the kernel is very small and does not block, so does not need to be preemptible<p>I don&#x27;t believe you and I don&#x27;t even need to look at the code to know this is false.</div><br/><div id="38908832" class="c"><input type="checkbox" id="c-38908832" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#38908817">parent</a><span>|</span><a href="#38909148">next</a><span>|</span><label class="collapse" for="c-38908832">[-]</label><label class="expand" for="c-38908832">[1 more]</label></div><br/><div class="children"><div class="content">Care to elaborate?</div><br/></div></div></div></div><div id="38909148" class="c"><input type="checkbox" id="c-38909148" checked=""/><div class="controls bullet"><span class="by">pipeline_peak</span><span>|</span><a href="#38908817">prev</a><span>|</span><a href="#38908486">next</a><span>|</span><label class="collapse" for="c-38909148">[-]</label><label class="expand" for="c-38909148">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think swapping out the first order language does anything other than boxes out potential support.</div><br/></div></div></div></div></div></div></div></body></html>