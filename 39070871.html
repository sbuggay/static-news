<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705827653097" as="style"/><link rel="stylesheet" href="styles.css?v=1705827653097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.timschumi.net/2024/01/20/ah532-bios-investigation.html">Investigating a vanishing BIOS on the Fujitsu Lifebook AH532</a> <span class="domain">(<a href="https://blog.timschumi.net">blog.timschumi.net</a>)</span></div><div class="subtext"><span>timschumi</span> | <span>46 comments</span></div><br/><div><div id="39075601" class="c"><input type="checkbox" id="c-39075601" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39072453">next</a><span>|</span><label class="collapse" for="c-39075601">[-]</label><label class="expand" for="c-39075601">[2 more]</label></div><br/><div class="children"><div class="content"><i>“BIOS Setup” is an actual boot menu entry.</i><p>Someone clearly thought that was a good idea, and I wouldn&#x27;t be surprised if they thought the same of the bloated monstrosity that is UEFI. &quot;Let&#x27;s make the setup an EFI application&quot; sounds like a reasonable argument, but they don&#x27;t realise that it&#x27;s a <i>very important</i> application, one which should be accessible under all circumstances short of having the BIOS erased.[1]<p>We&#x27;re approaching 10 years since this happened: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5139055">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5139055</a><p>And almost 8 years since this: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11008449">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11008449</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10999335">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10999335</a><p>[1] Most if not all BIOSes on EEPROM (late 90s onwards) before UEFI had &quot;boot block recovery&quot; which would automatically detect if they were corrupt and attempt to recover by flashing from a specially formatted floppy disk.</div><br/><div id="39076326" class="c"><input type="checkbox" id="c-39076326" checked=""/><div class="controls bullet"><span class="by">jtriangle</span><span>|</span><a href="#39075601">parent</a><span>|</span><a href="#39072453">next</a><span>|</span><label class="collapse" for="c-39076326">[-]</label><label class="expand" for="c-39076326">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve come across similar issues with OEM installs before, where it simply will not boot if anything but the OEM&#x27;s factory image is installed by the OEM&#x27;s install disks.<p>Profoundly annoying, but, thankfully not commonplace and those couple times it&#x27;s happened to me I&#x27;ve been in the return window, so, back they went. I figure that&#x27;s as big of an FU as I can muster, the OEM dealing with a higher than normal return rate.<p>Last time it was a HP laptop running a god aweful bloatware infested version of windows 8.1, never again.</div><br/></div></div></div></div><div id="39072453" class="c"><input type="checkbox" id="c-39072453" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#39075601">prev</a><span>|</span><a href="#39071905">next</a><span>|</span><label class="collapse" for="c-39072453">[-]</label><label class="expand" for="c-39072453">[4 more]</label></div><br/><div class="children"><div class="content">Around 20 years ago I had Fujitsu Siemens V3505 that beyond giving me a lot of grief when it came to get it to work ACPI, hardware buttons or getting FN-less function keys it had weird characteristic of requiring motherboard replacement every single time I installed Linux on it.<p>As it was advertised as OpenSUSE compatible (and even came with stickers and such) first one or two times they made a fuss about it, but after that they replaced pretty much on the demand.<p>I wonder if that was also related to the issue article was mentioning. But such design lasting for multiple years?</div><br/><div id="39073215" class="c"><input type="checkbox" id="c-39073215" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39072453">parent</a><span>|</span><a href="#39071905">next</a><span>|</span><label class="collapse" for="c-39073215">[-]</label><label class="expand" for="c-39073215">[3 more]</label></div><br/><div class="children"><div class="content">Confused, this only occurred during <i>installation</i>? Not booting after the OS was installed?</div><br/><div id="39073575" class="c"><input type="checkbox" id="c-39073575" checked=""/><div class="controls bullet"><span class="by">tenebrisalietum</span><span>|</span><a href="#39072453">root</a><span>|</span><a href="#39073215">parent</a><span>|</span><a href="#39071905">next</a><span>|</span><label class="collapse" for="c-39073575">[-]</label><label class="expand" for="c-39073575">[2 more]</label></div><br/><div class="children"><div class="content">Related to killing EFI variables in a way the UEFI didn&#x27;t expect I bet - would happen when boot loader is installed and boot entries set possibly.</div><br/><div id="39074109" class="c"><input type="checkbox" id="c-39074109" checked=""/><div class="controls bullet"><span class="by">xattt</span><span>|</span><a href="#39072453">root</a><span>|</span><a href="#39073575">parent</a><span>|</span><a href="#39071905">next</a><span>|</span><label class="collapse" for="c-39074109">[-]</label><label class="expand" for="c-39074109">[1 more]</label></div><br/><div class="children"><div class="content">That’s an interesting failure mode. Is there any reason why the manufacturer didn’t consider that boot entries can be created and destroyed by the customer?</div><br/></div></div></div></div></div></div></div></div><div id="39071905" class="c"><input type="checkbox" id="c-39071905" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39072453">prev</a><span>|</span><a href="#39071981">next</a><span>|</span><label class="collapse" for="c-39071905">[-]</label><label class="expand" for="c-39071905">[15 more]</label></div><br/><div class="children"><div class="content">Is there any indication why Linux can&#x27;t read these efivars? That seems like a short fix away from the research already done, and would take care of everything.  (Once you have the C skills already demonstrated in the post, kernel code is not especially difficult to debug.)</div><br/><div id="39072050" class="c"><input type="checkbox" id="c-39072050" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071905">parent</a><span>|</span><a href="#39071981">next</a><span>|</span><label class="collapse" for="c-39072050">[-]</label><label class="expand" for="c-39072050">[14 more]</label></div><br/><div class="children"><div class="content">As far as I have tracked it down (quite literally up to the point where it switches into the EFI context to run the respective service handler), the UEFI denies a call to `GetNextVariableName` with `EFI_INVALID_PARAMETER` (that part is actually indicated in `dmesg`) even though the request appears to be specification-compliant (and the existing implementation evidently hasn&#x27;t been an issue on any other notable hardware).<p>The main issue with fixing it properly is that I&#x27;d most likely have to reverse engineer the Windows kernel or the UEFI firmware itself (note to self: I haven&#x27;t yet checked whether any of the *BSDs can read EFI variables in general and on this hardware in particular) to figure out where the request is going wrong&#x2F;what Windows is doing different.<p>It&#x27;s not impossible, given that one can unpack the UEFI PI firmware image into all the separate modules, but going through them to figure out where variable management is implemented will still take me a few weeks at least (not due to any particular challenge, it&#x27;s just consuming a lot of time that I don&#x27;t have right now).</div><br/><div id="39073378" class="c"><input type="checkbox" id="c-39073378" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072050">parent</a><span>|</span><a href="#39072935">next</a><span>|</span><label class="collapse" for="c-39073378">[-]</label><label class="expand" for="c-39073378">[2 more]</label></div><br/><div class="children"><div class="content">&gt; note to self: I haven&#x27;t yet checked whether any of the *BSDs can read EFI variables in general and on this hardware in particular<p>Good news: FreeBSD is able to read the whole variable list.<p>Bad news: I just wiped my test drive with all the in-progress kernel patches by accident.</div><br/><div id="39074594" class="c"><input type="checkbox" id="c-39074594" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39073378">parent</a><span>|</span><a href="#39072935">next</a><span>|</span><label class="collapse" for="c-39074594">[-]</label><label class="expand" for="c-39074594">[1 more]</label></div><br/><div class="children"><div class="content">Glad to hear FreeBSD worked.  Sorry you wiped your drive though!!</div><br/></div></div></div></div><div id="39072935" class="c"><input type="checkbox" id="c-39072935" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072050">parent</a><span>|</span><a href="#39073378">prev</a><span>|</span><a href="#39072856">next</a><span>|</span><label class="collapse" for="c-39072935">[-]</label><label class="expand" for="c-39072935">[2 more]</label></div><br/><div class="children"><div class="content">One thing I&#x27;ve gotten used to over the years is Linux complaining that some part of the machine&#x27;s EFI is buggy no matter what machine it is installed on.  Apparently it&#x27;s just too complicated for hardware manufacturers to get right.  I also feel like there is far too much duplicated effort in the industry with everybody making their own version that is slightly buggy in a unique way.</div><br/><div id="39075797" class="c"><input type="checkbox" id="c-39075797" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072935">parent</a><span>|</span><a href="#39072856">next</a><span>|</span><label class="collapse" for="c-39075797">[-]</label><label class="expand" for="c-39075797">[1 more]</label></div><br/><div class="children"><div class="content">It is just moving the complexity around.<p>In the old BIOS + ACPI days, the OS carries hardware specific hacks. These hack were buggy and hard to keep to day.<p>We (the community as a whole) decided it is better leave the hardware specific hacks to the hardware, UEFI was supposed to provide enough abstraction for all we need.<p>The result is, of course, the hacks with all its bugs are moved to the firmware.</div><br/></div></div></div></div><div id="39072856" class="c"><input type="checkbox" id="c-39072856" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072050">parent</a><span>|</span><a href="#39072935">prev</a><span>|</span><a href="#39072082">next</a><span>|</span><label class="collapse" for="c-39072856">[-]</label><label class="expand" for="c-39072856">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD can read and manipulate EFI variables in general.  It would be interesting to see what happens when you try efivar or efibootmgr in FreeBSD.<p>Grab the memstick image from here: <a href="https:&#x2F;&#x2F;download.freebsd.org&#x2F;releases&#x2F;ISO-IMAGES&#x2F;14.0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;download.freebsd.org&#x2F;releases&#x2F;ISO-IMAGES&#x2F;14.0&#x2F;</a><p>Uncompress it, and dd it to your USB drive.  (dd if=FreeBSD-14.0-RELEASE-amd64-memstick.img of=&#x2F;dev&#x2F;sdb bs=1m conv=sync,  assuming sdb is your usb stick..)</div><br/></div></div><div id="39072082" class="c"><input type="checkbox" id="c-39072082" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072050">parent</a><span>|</span><a href="#39072856">prev</a><span>|</span><a href="#39072124">next</a><span>|</span><label class="collapse" for="c-39072082">[-]</label><label class="expand" for="c-39072082">[6 more]</label></div><br/><div class="children"><div class="content">Makes sense! I wonder if there is a way to dynamically watch the Windows call, to compare it with the Linux one, to avoid the tedious reverse engineering. Or if the syntax of Windows GetNextVariableName() use is generally understood&#x2F;documented?<p>This could happen either through somehow getting logging from the Windows end, or somehow changing the UEFI to be one you control and logging there, or finding a different BIOS&#x2F;OS that can read the vars and getting it to log its work.</div><br/><div id="39072401" class="c"><input type="checkbox" id="c-39072401" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072082">parent</a><span>|</span><a href="#39073043">next</a><span>|</span><label class="collapse" for="c-39072401">[-]</label><label class="expand" for="c-39072401">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Makes sense! I wonder if there is a way to dynamically watch the Windows call, to compare it with the Linux one, to avoid the tedious reverse engineering. Or if the syntax of Windows GetNextVariableName() use is generally understood&#x2F;documented?<p>The userspace interface is somewhat documented by third-parties (because it is technically internal). However, the important parts happen kernel side, and I&#x27;d rather avoid diving too deep into Windows because some very interesting job postings (understandably) have &quot;No exposure to Microsoft code or reverse-engineering of Microsoft software&quot; in them.<p>I already tried getting to the service handler implementation via Linux, but memory protections made it weird enough that I was even questioning whether it was returning correct raw data when trying to read it from memory (or I have been looking at the wrong set of headers).</div><br/></div></div><div id="39073043" class="c"><input type="checkbox" id="c-39073043" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072082">parent</a><span>|</span><a href="#39072401">prev</a><span>|</span><a href="#39072982">next</a><span>|</span><label class="collapse" for="c-39073043">[-]</label><label class="expand" for="c-39073043">[3 more]</label></div><br/><div class="children"><div class="content">Last I checked (which was about a decade ago) Windows doesn&#x27;t call GetNextVariableName() - it just accesses variables on demand. We should probably handle that in a cleaner way.</div><br/><div id="39073315" class="c"><input type="checkbox" id="c-39073315" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39073043">parent</a><span>|</span><a href="#39072982">next</a><span>|</span><label class="collapse" for="c-39073315">[-]</label><label class="expand" for="c-39073315">[2 more]</label></div><br/><div class="children"><div class="content">It seems like that is no longer the case. I was able to successfully retrieve a non-standard variable using the `UEFIv2` PowerShell module [1] (which is just a thin wrapper around the undocumented `NtEnumerateSystemEnvironmentValuesEx` function) without actually naming the variable in question.<p>To the untrained layman like me, this sounds like Windows actually is querying via `GetNextVariableName`, because UEFI doesn&#x27;t seem to offer any other interfaces that aren&#x27;t &quot;get&#x2F;set variable by name&quot;.<p>[1] <a href="https:&#x2F;&#x2F;www.powershellgallery.com&#x2F;packages&#x2F;UEFIv2" rel="nofollow">https:&#x2F;&#x2F;www.powershellgallery.com&#x2F;packages&#x2F;UEFIv2</a></div><br/><div id="39074145" class="c"><input type="checkbox" id="c-39074145" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39073315">parent</a><span>|</span><a href="#39072982">next</a><span>|</span><label class="collapse" for="c-39074145">[-]</label><label class="expand" for="c-39074145">[1 more]</label></div><br/><div class="children"><div class="content">Ok, yes, sounds like it is in that case. Which means figuring out how Linux is doing this differently to Windows, sigh. The easiest validation is to boot Windows under qemu with a debug-enabled EDK2 build to trace the calls.</div><br/></div></div></div></div></div></div><div id="39072982" class="c"><input type="checkbox" id="c-39072982" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072082">parent</a><span>|</span><a href="#39073043">prev</a><span>|</span><a href="#39072124">next</a><span>|</span><label class="collapse" for="c-39072982">[-]</label><label class="expand" for="c-39072982">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or somehow changing the UEFI to be one you control<p>wouldn&#x27;t that be trivial simply using a VM?<p>I don&#x27;t know a thing about BIOS internals, so this might be completely irrelevant</div><br/></div></div></div></div><div id="39072124" class="c"><input type="checkbox" id="c-39072124" checked=""/><div class="controls bullet"><span class="by">csdvrx</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072050">parent</a><span>|</span><a href="#39072082">prev</a><span>|</span><a href="#39071981">next</a><span>|</span><label class="collapse" for="c-39072124">[-]</label><label class="expand" for="c-39072124">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The main issue with fixing it properly is that I&#x27;d most likely have to reverse engineer the Windows kernel or the UEFI firmware itself<p>Before doing such complicated things, have you tried with RU.EFI?</div><br/><div id="39072292" class="c"><input type="checkbox" id="c-39072292" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071905">root</a><span>|</span><a href="#39072124">parent</a><span>|</span><a href="#39071981">next</a><span>|</span><label class="collapse" for="c-39072292">[-]</label><label class="expand" for="c-39072292">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t, and (as I already said) I also haven&#x27;t tried any of the BSDs yet. I put both on the list of things to try.</div><br/></div></div></div></div></div></div></div></div><div id="39071981" class="c"><input type="checkbox" id="c-39071981" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39071905">prev</a><span>|</span><a href="#39073749">next</a><span>|</span><label class="collapse" for="c-39071981">[-]</label><label class="expand" for="c-39071981">[9 more]</label></div><br/><div class="children"><div class="content">&gt; I made an image of the Winbond 25Q32BVSIG SPI flash chip.<p>I&#x27;d love a footnote explaining how you did this.</div><br/><div id="39072192" class="c"><input type="checkbox" id="c-39072192" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071981">parent</a><span>|</span><a href="#39072111">next</a><span>|</span><label class="collapse" for="c-39072192">[-]</label><label class="expand" for="c-39072192">[3 more]</label></div><br/><div class="children"><div class="content">I guessed which chip it was (with a little bit of help from leaked schematics for similar laptop models), bought the first programmer that I saw online that appeared to be compatible (anything with a CH341A in it, apparently) and ran `flashrom --programmer ch341a_spi -r bios.bin`.<p>Had there been any more than one possible type of chip and more than three of these similar looking chips on the [accessible part of the] motherboard, I&#x27;d probably still be sitting here trying to figure out what to do.<p>In any case, I&#x27;ll try and add it to the blog post once I figure out how to do footnotes. :^)</div><br/><div id="39076669" class="c"><input type="checkbox" id="c-39076669" checked=""/><div class="controls bullet"><span class="by">The_SamminAter</span><span>|</span><a href="#39071981">root</a><span>|</span><a href="#39072192">parent</a><span>|</span><a href="#39072111">next</a><span>|</span><label class="collapse" for="c-39076669">[-]</label><label class="expand" for="c-39076669">[2 more]</label></div><br/><div class="children"><div class="content">I have tried to use a generic usb CH341A previously, and ended up seemingly frying the chip. By chance, would you happen to know the pin out on the ch341a, or something else that may be useful? I’ve stayed away from using it since, out of fear of frying a more expensive&#x2F;important device.</div><br/><div id="39076729" class="c"><input type="checkbox" id="c-39076729" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#39071981">root</a><span>|</span><a href="#39076669">parent</a><span>|</span><a href="#39072111">next</a><span>|</span><label class="collapse" for="c-39076729">[-]</label><label class="expand" for="c-39076729">[1 more]</label></div><br/><div class="children"><div class="content">Different flash chips operate at different voltages.  1.8v, 3.3v are common.<p>Your programmer needs to operate at the same voltage as your target.<p>I assume if this programmer is designed as a dev tool, it probably has a jumper somewhere to set what voltage to operate at.</div><br/></div></div></div></div></div></div><div id="39072111" class="c"><input type="checkbox" id="c-39072111" checked=""/><div class="controls bullet"><span class="by">csdvrx</span><span>|</span><a href="#39071981">parent</a><span>|</span><a href="#39072192">prev</a><span>|</span><a href="#39073749">next</a><span>|</span><label class="collapse" for="c-39072111">[-]</label><label class="expand" for="c-39072111">[5 more]</label></div><br/><div class="children"><div class="content">If I may guess, with a dongle supported by flashrom, soldering wires to the flash chip, and a lot of patience - because doing the same thing from say linux can run into permission problems: the firmware really doesn&#x27;t want you to read the flash chip.</div><br/><div id="39072241" class="c"><input type="checkbox" id="c-39072241" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071981">root</a><span>|</span><a href="#39072111">parent</a><span>|</span><a href="#39073749">next</a><span>|</span><label class="collapse" for="c-39072241">[-]</label><label class="expand" for="c-39072241">[4 more]</label></div><br/><div class="children"><div class="content">Luckily, it was the type of flash chip that I could use an external programmer and a test clip for. I haven&#x27;t actually ever tried reading&#x2F;writing through the internal programmer.</div><br/><div id="39075441" class="c"><input type="checkbox" id="c-39075441" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#39071981">root</a><span>|</span><a href="#39072241">parent</a><span>|</span><a href="#39073145">next</a><span>|</span><label class="collapse" for="c-39075441">[-]</label><label class="expand" for="c-39075441">[2 more]</label></div><br/><div class="children"><div class="content">I was able to fix a laptop I bricked that way, note to self: never disable usb on a device with only usb input. the device had no bios clear pins. So I got a chip flasher and a soic clip and reflashed the firmware the hard way. luckily it worked &quot;on board&quot;<p>A process note. I did not really know what I was doing. and nothing was flashing correctly. Most of my problems ended up being with the cheap soic clip I had bought. After buying a nicer one it flashed first try. If anyone wants a recommendation, the nicer clip was from pomona electronics.<p><a href="https:&#x2F;&#x2F;www.pomonaelectronics.com&#x2F;products&#x2F;test-clips&#x2F;soic-clip-8-pin" rel="nofollow">https:&#x2F;&#x2F;www.pomonaelectronics.com&#x2F;products&#x2F;test-clips&#x2F;soic-c...</a></div><br/><div id="39075535" class="c"><input type="checkbox" id="c-39075535" checked=""/><div class="controls bullet"><span class="by">baby_souffle</span><span>|</span><a href="#39071981">root</a><span>|</span><a href="#39075441">parent</a><span>|</span><a href="#39073145">next</a><span>|</span><label class="collapse" for="c-39075535">[-]</label><label class="expand" for="c-39075535">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Most of my problems ended up being with the cheap soic clip I had bought. After buying a nicer one it flashed first try. If anyone wants a recommendation, the nicer clip was from pomona electronics.<p>I can +1 for that clip. Had similar issues pulling data off a flash chip. If `flashrom` could see it at all, each read would come back with a different `sha1` hash.<p>Spent _way_ too long fighting that before I had the &quot;wonder if this cheap clip is the issue...&quot; thought. The pomona clip is so much better made and holds on to the chip well.</div><br/></div></div></div></div><div id="39073145" class="c"><input type="checkbox" id="c-39073145" checked=""/><div class="controls bullet"><span class="by">Scoundreller</span><span>|</span><a href="#39071981">root</a><span>|</span><a href="#39072241">parent</a><span>|</span><a href="#39075441">prev</a><span>|</span><a href="#39073749">next</a><span>|</span><label class="collapse" for="c-39073145">[-]</label><label class="expand" for="c-39073145">[1 more]</label></div><br/><div class="children"><div class="content">Test clip? Fancy!<p>Had to reflash an SOIC i2c chip before and just soldered wires on. Some pins are easier where you have a via to solder to instead of the pin. Had to <i>carefully</i> lift the VCC pin to avoid turning on the whole board. Not all is lost if you break a pin: can <i>carefully</i> file down a bit of the plastic chip encapsulation to expose some pin to rebridge it once complete.<p>It&#x27;s really nice to see how much cheaper ZIF sockets, test clips and programmers have gotten over the last few decades.</div><br/></div></div></div></div></div></div></div></div><div id="39073749" class="c"><input type="checkbox" id="c-39073749" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#39071981">prev</a><span>|</span><a href="#39071177">next</a><span>|</span><label class="collapse" for="c-39073749">[-]</label><label class="expand" for="c-39073749">[1 more]</label></div><br/><div class="children"><div class="content">I mean they can&#x27;t even add up numbers correctly or do ACID transactions to prevent double accounting.<p>The BIOS never stood a chance. Maybe it was self deleting to hide evidence.<p>Thanks, I&#x27;m here all night.</div><br/></div></div><div id="39071177" class="c"><input type="checkbox" id="c-39071177" checked=""/><div class="controls bullet"><span class="by">asmor</span><span>|</span><a href="#39073749">prev</a><span>|</span><a href="#39071245">next</a><span>|</span><label class="collapse" for="c-39071177">[-]</label><label class="expand" for="c-39071177">[1 more]</label></div><br/><div class="children"><div class="content">Early UEFI firmware having quirks like this is pretty common, and it&#x27;s also not uncommon for the BIOS Menu and other things you&#x27;d hope to be persistent (Diagnostics, Secure Erase Tool on Lenovo laptops) to just be boot entries with some hardcoded (but not absolute) protections.<p>I remember the opposite problem being the case on the T420 BIOS. If you didn&#x27;t set a newly added entry as NextBoot, it&#x27;d just disappear after reboot.</div><br/></div></div><div id="39071245" class="c"><input type="checkbox" id="c-39071245" checked=""/><div class="controls bullet"><span class="by">csdvrx</span><span>|</span><a href="#39071177">prev</a><span>|</span><a href="#39076236">next</a><span>|</span><label class="collapse" for="c-39071245">[-]</label><label class="expand" for="c-39071245">[10 more]</label></div><br/><div class="children"><div class="content">The UEFI entries are just regular EFI variables, except they use a special GUID: 8BE4DF61-93CA-11D2-AA0D-00E098032B8C cf <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;67395528&#x2F;" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;67395528&#x2F;</a> and the actual description in 
 <a href="https:&#x2F;&#x2F;github.com&#x2F;erikberglund&#x2F;AppleNVRAM&#x2F;blob&#x2F;master&#x2F;EFI&#x2F;8BE4DF61-93CA-11D2-AA0D-00E098032B8C.md">https:&#x2F;&#x2F;github.com&#x2F;erikberglund&#x2F;AppleNVRAM&#x2F;blob&#x2F;master&#x2F;EFI&#x2F;8...</a> with examples on how to access them from an UEFI shell on <a href="https:&#x2F;&#x2F;oofhours.com&#x2F;2019&#x2F;09&#x2F;02&#x2F;geeking-out-with-uefi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;oofhours.com&#x2F;2019&#x2F;09&#x2F;02&#x2F;geeking-out-with-uefi&#x2F;</a><p>These variables are what `efibootmgr` lists and can change on Linux, what `bcdedit &#x2F;enum firmware` lists on Windows, and what GetSetVariable can manipulate on Windows cf <a href="https:&#x2F;&#x2F;github.com&#x2F;ProSlatisa&#x2F;GetSetVariable&#x2F;tree&#x2F;master&#x2F;VariableCfg">https:&#x2F;&#x2F;github.com&#x2F;ProSlatisa&#x2F;GetSetVariable&#x2F;tree&#x2F;master&#x2F;Var...</a><p>Ultimately, each are OS-specific solutions, while it would be interesting to make a crossover between efibootmgr and GetSetVariable (and that C program) to create a tool working on both Linux and Windows with cosmopolitan to restore&#x2F;hack 8BE4DF61-93CA-11D2-AA0D-00E098032B8C variables, because a quick search on that magic shows some people have uploaded their efivar to github for other models so it must be a common issue!</div><br/><div id="39071560" class="c"><input type="checkbox" id="c-39071560" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071245">parent</a><span>|</span><a href="#39076236">next</a><span>|</span><label class="collapse" for="c-39071560">[-]</label><label class="expand" for="c-39071560">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Ultimately, each are OS-specific solutions, while it would be interesting to make a crossover between efibootmgr and GetSetVariable (and that C program) to create a tool working on both Linux and Windows<p>I seems that nobody except for Linux (for some not yet determined reason) is having issues with retrieving EFI variables on this hardware, and one could potentially classify this as a bug in `efibootmgr` as well (due to how it handles creating the new entry in unknown conditions).<p>In either case, Linux is the only thing affected by this, so in real-world setups Linux is going to be the only boot option that is available while the boot menu is in a broken state.</div><br/><div id="39071633" class="c"><input type="checkbox" id="c-39071633" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071560">parent</a><span>|</span><a href="#39076236">next</a><span>|</span><label class="collapse" for="c-39071633">[-]</label><label class="expand" for="c-39071633">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a pretty decent chance nobody else is actually <i>trying</i>. The only other OS getting installed is Windows, and that&#x27;s probably coming straight from a disk image or a recovery partition.<p>Especially in laptops, a lot of hardware &#x2F; firmware issues are simply &quot;solved&quot; by baking a fix into the pre-installed Windows version. It&#x27;s a solution for 99% of users, so why bother spending time looking into the root cause?</div><br/><div id="39071763" class="c"><input type="checkbox" id="c-39071763" checked=""/><div class="controls bullet"><span class="by">timschumi</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071633">parent</a><span>|</span><a href="#39071669">next</a><span>|</span><label class="collapse" for="c-39071763">[-]</label><label class="expand" for="c-39071763">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The only other OS getting installed is Windows, and that&#x27;s probably coming straight from a disk image or a recovery partition.<p>&gt; Especially in laptops, a lot of hardware &#x2F; firmware issues are simply &quot;solved&quot; by baking a fix into the pre-installed Windows version. It&#x27;s a solution for 99% of users, so why bother spending time looking into the root cause?<p>The Windows versions I installed for testing were non-OEM versions. They still behaved as expected.<p>Notably, Windows didn&#x27;t just know about all the standard UEFI variables, but also about a non-standard one that I added for testing. This means that there definitely is a way to ask for the list of variables so that the UEFI accepts it (sadly, reverse engineering that is a pain), and that the Linux kernel is most likely the place where an actual fix has to happen.<p>Of course, yes, at the end of the day, the root cause is a specification non-conformity in the UEFI itself.</div><br/><div id="39072086" class="c"><input type="checkbox" id="c-39072086" checked=""/><div class="controls bullet"><span class="by">csdvrx</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071763">parent</a><span>|</span><a href="#39071669">next</a><span>|</span><label class="collapse" for="c-39072086">[-]</label><label class="expand" for="c-39072086">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (sadly, reverse engineering that is a pain), and that the Linux kernel is most likely the place where an actual fix has to happen.<p>You did most of the work already, and it&#x27;s super interesting (or at least, it&#x27;s the kind of things I find super interesting lol) so you may want to finish fixing the issue?<p>It&#x27;s funny how outside RU.EFI, there&#x27;re no nice tools for such a basic features as tweaking UEFI variables, so if you are into this kind of things, you may also be interested by writing a better efibootmgr: many people (including myself, and now you) are dissatisfied by the issues it can create: <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;archlinux&#x2F;comments&#x2F;18j6o7x&#x2F;rfc_what_are_your_gripes_with_efibootmgr_and&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;archlinux&#x2F;comments&#x2F;18j6o7x&#x2F;rfc_what...</a></div><br/></div></div></div></div><div id="39071669" class="c"><input type="checkbox" id="c-39071669" checked=""/><div class="controls bullet"><span class="by">peppermint_gum</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071633">parent</a><span>|</span><a href="#39071763">prev</a><span>|</span><a href="#39072076">next</a><span>|</span><label class="collapse" for="c-39071669">[-]</label><label class="expand" for="c-39071669">[3 more]</label></div><br/><div class="children"><div class="content">&gt;There&#x27;s a pretty decent chance nobody else is actually trying. The only other OS getting installed is Windows, and that&#x27;s probably coming straight from a disk image or a recovery partition.<p>From TFA: &quot;Note: At this point, I checked that Windows and various other UEFI tools are able to read the variables just fine, so Linux’ output is confirmed to be incorrect.&quot;</div><br/><div id="39076233" class="c"><input type="checkbox" id="c-39076233" checked=""/><div class="controls bullet"><span class="by">791076443</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071669">parent</a><span>|</span><a href="#39071978">next</a><span>|</span><label class="collapse" for="c-39076233">[-]</label><label class="expand" for="c-39076233">[1 more]</label></div><br/><div class="children"><div class="content">Hhhhh
8uhga</div><br/></div></div><div id="39071978" class="c"><input type="checkbox" id="c-39071978" checked=""/><div class="controls bullet"><span class="by">csdvrx</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071669">parent</a><span>|</span><a href="#39076233">prev</a><span>|</span><a href="#39072076">next</a><span>|</span><label class="collapse" for="c-39071978">[-]</label><label class="expand" for="c-39071978">[1 more]</label></div><br/><div class="children"><div class="content">&gt; From TFA: &quot;Note: At this point, I checked that Windows and various other UEFI tools are able to read the variables just fine, so Linux’ output is confirmed to be incorrect.&quot;<p>UEFI is a bit complicated and it&#x27;s well known the EDD3 specifications can cause issues to efibootmgr, for example on Dell <a href="https:&#x2F;&#x2F;github.com&#x2F;rhboot&#x2F;efibootmgr&#x2F;issues&#x2F;86">https:&#x2F;&#x2F;github.com&#x2F;rhboot&#x2F;efibootmgr&#x2F;issues&#x2F;86</a><p>I just think it&#x27;d be nicer to have a multiplatform way to tweak UEFI boot variable, so you can  fiddle with your UEFI variables from either Linux or Windows without having to actually go into the UEFI shell or use a PE32 like RU.EFI : <a href="https:&#x2F;&#x2F;ruexe.blogspot.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ruexe.blogspot.com&#x2F;</a></div><br/></div></div></div></div><div id="39072076" class="c"><input type="checkbox" id="c-39072076" checked=""/><div class="controls bullet"><span class="by">dishsoap</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39071633">parent</a><span>|</span><a href="#39071669">prev</a><span>|</span><a href="#39076236">next</a><span>|</span><label class="collapse" for="c-39072076">[-]</label><label class="expand" for="c-39072076">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Especially in laptops, a lot of hardware &#x2F; firmware issues are simply &quot;solved&quot; by baking a fix into the pre-installed Windows version. It&#x27;s a solution for 99% of users, so why bother spending time looking into the root cause?<p>I&#x27;ve never really seen a single example of this. Could you provide some?</div><br/><div id="39073709" class="c"><input type="checkbox" id="c-39073709" checked=""/><div class="controls bullet"><span class="by">shrx</span><span>|</span><a href="#39071245">root</a><span>|</span><a href="#39072076">parent</a><span>|</span><a href="#39076236">next</a><span>|</span><label class="collapse" for="c-39073709">[-]</label><label class="expand" for="c-39073709">[1 more]</label></div><br/><div class="children"><div class="content">My ASUS UX305UA&#x27;s touchpad stopped working when I removed the windows partition.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39076236" class="c"><input type="checkbox" id="c-39076236" checked=""/><div class="controls bullet"><span class="by">791076443</span><span>|</span><a href="#39071245">prev</a><span>|</span><a href="#39074597">next</a><span>|</span><label class="collapse" for="c-39076236">[-]</label><label class="expand" for="c-39076236">[1 more]</label></div><br/><div class="children"><div class="content">Uafrat</div><br/></div></div><div id="39074597" class="c"><input type="checkbox" id="c-39074597" checked=""/><div class="controls bullet"><span class="by">fouc</span><span>|</span><a href="#39076236">prev</a><span>|</span><label class="collapse" for="c-39074597">[-]</label><label class="expand" for="c-39074597">[2 more]</label></div><br/><div class="children"><div class="content">minor grammatical fix on first line &quot;I got given&quot; -&gt; &quot;I was given&quot;</div><br/><div id="39074647" class="c"><input type="checkbox" id="c-39074647" checked=""/><div class="controls bullet"><span class="by">rahimnathwani</span><span>|</span><a href="#39074597">parent</a><span>|</span><label class="collapse" for="c-39074647">[-]</label><label class="expand" for="c-39074647">[1 more]</label></div><br/><div class="children"><div class="content">I think many native English speakers would consider &#x27;I got given&#x27; grammatically correct.<p>Consider &#x27;I got caught&#x27; and &#x27;I got hit&#x27;.</div><br/></div></div></div></div></div></div></div></div></div></body></html>