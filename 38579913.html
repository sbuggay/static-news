<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702371683181" as="style"/><link rel="stylesheet" href="styles.css?v=1702371683181"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://marc.info/?l=openbsd-tech&amp;m=170205367232026&amp;w=2">OpenBSD – pinning all system calls</a> <span class="domain">(<a href="https://marc.info">marc.info</a>)</span></div><div class="subtext"><span>g0xA52A2A</span> | <span>53 comments</span></div><br/><div><div id="38607289" class="c"><input type="checkbox" id="c-38607289" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38607328">next</a><span>|</span><label class="collapse" for="c-38607289">[-]</label><label class="expand" for="c-38607289">[17 more]</label></div><br/><div class="children"><div class="content">Classic thread on this stuff from Halvar Flake:<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;halvarflake&#x2F;status&#x2F;1156815950873804800" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;halvarflake&#x2F;status&#x2F;1156815950873804800</a><p>With that in mind, it&#x27;d be handy to know which exploit techniques these steps break, and whether those steps are in the current &quot;meta&quot; game for exploit developers.<p>(The specific mitigation here: the kernel formerly locked system call invocation down to the libc.so area of program text in memory; libc.so is big, so now OpenBSD locks specific system calls down to their specified libc stubs; further, in static binaries, the same mechanism locks programs down to only those system calls used in the binary, which effectively disables all the system calls not explicitly invoked by the program text of a static binary).</div><br/><div id="38607506" class="c"><input type="checkbox" id="c-38607506" checked=""/><div class="controls bullet"><span class="by">vngzs</span><span>|</span><a href="#38607289">parent</a><span>|</span><a href="#38609740">next</a><span>|</span><label class="collapse" for="c-38607506">[-]</label><label class="expand" for="c-38607506">[7 more]</label></div><br/><div class="children"><div class="content">Indeed, in CCC&#x27;s &quot;systematic evaluation of OpenBSD&#x27;s mitigations&quot;[0] the presenter explicitly calls out OpenBSD&#x27;s tendency to present mitigations without specific examples of CVEs it defeats or exploit techniques the mitigations are known to defend against:<p>&gt; Proper mitigations I think stem from proper design and threat modeling. Strong, reality-based statements like &quot;this kills these vulnerabilities,&quot; or &quot;this kills this CVE; it delays production of an exploit by one week.&quot; And also thorough testing by seasoned exploit writers. Anything else is relying on pure luck, superstition, and wishful thinking.<p>Some of OpenBSD&#x27;s mitigations are excellent and robust in defensiveness; others are amorphous and not particularly useful.<p>[0]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;3E9ga-CylWQ?feature=shared&amp;t=2770" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;3E9ga-CylWQ?feature=shared&amp;t=2770</a></div><br/><div id="38609878" class="c"><input type="checkbox" id="c-38609878" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38607506">parent</a><span>|</span><a href="#38608761">next</a><span>|</span><label class="collapse" for="c-38609878">[-]</label><label class="expand" for="c-38609878">[3 more]</label></div><br/><div class="children"><div class="content">OpenBSD disabled hyperthreading before speculative execution attacks were in the wild. In the words of Greg K-H “OpenBSD was right”.<p>There probably is some amount of security theatre in OpenBSD but they have also mitigated attacks which weren’t even known to exist.</div><br/><div id="38610130" class="c"><input type="checkbox" id="c-38610130" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609878">parent</a><span>|</span><a href="#38608761">next</a><span>|</span><label class="collapse" for="c-38610130">[-]</label><label class="expand" for="c-38610130">[2 more]</label></div><br/><div class="children"><div class="content">&gt;they have also mitigated attacks which weren’t even known to exist<p>Indeed, I&#x27;m reminded of some other comments that tptacek made in a recent thread, about how encrypting vulnerability disclosures &quot;just isn&#x27;t done&quot;:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38563897">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38563897</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38569179">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38569179</a><p>I&#x27;ll bet the NSA is very happy about this situation and is doing everything they can to keep the gravy train rolling.<p>I thought the entire <i>point</i> of being a good security person was that you&#x27;re able to anticipate and defend against attacks <i>before</i> they become known...  Isn&#x27;t that what &quot;security mindset&quot; is supposed to entail?</div><br/><div id="38610670" class="c"><input type="checkbox" id="c-38610670" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38610130">parent</a><span>|</span><a href="#38608761">next</a><span>|</span><label class="collapse" for="c-38610670">[-]</label><label class="expand" for="c-38610670">[1 more]</label></div><br/><div class="children"><div class="content">He’s not wrong, though. Security researchers don’t use PGP when reporting vulnerabilities typically.</div><br/></div></div></div></div></div></div><div id="38608761" class="c"><input type="checkbox" id="c-38608761" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38607506">parent</a><span>|</span><a href="#38609878">prev</a><span>|</span><a href="#38609740">next</a><span>|</span><label class="collapse" for="c-38608761">[-]</label><label class="expand" for="c-38608761">[3 more]</label></div><br/><div class="children"><div class="content">There have been cases where OpenBSD&#x27;s hypothetical mitigations have worked out well for the project. I recall a relatively recent DNS cache poisoning attack that OpenBSD was novel in pre-emptively mitigating because something (I think it was the port?) was &quot;needlessly&quot; random.<p>If a mitigation has negligible performance impact, and doesn&#x27;t introduce a new attack vector, I can&#x27;t imagine why it would be seen as a bad thing.</div><br/><div id="38609034" class="c"><input type="checkbox" id="c-38609034" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38608761">parent</a><span>|</span><a href="#38609167">next</a><span>|</span><label class="collapse" for="c-38609034">[-]</label><label class="expand" for="c-38609034">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a mitigation has negligible performance impact, and doesn&#x27;t introduce a new attack vector, I can&#x27;t imagine why it would be seen as a bad thing.<p>Because it creates confusion about your threat model, which can ultimately weaken your security.</div><br/></div></div><div id="38609167" class="c"><input type="checkbox" id="c-38609167" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38608761">parent</a><span>|</span><a href="#38609034">prev</a><span>|</span><a href="#38609740">next</a><span>|</span><label class="collapse" for="c-38609167">[-]</label><label class="expand" for="c-38609167">[1 more]</label></div><br/><div class="children"><div class="content">Every mitigation is code and complexity. There is always a cost.</div><br/></div></div></div></div></div></div><div id="38609740" class="c"><input type="checkbox" id="c-38609740" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38607289">parent</a><span>|</span><a href="#38607506">prev</a><span>|</span><a href="#38607451">next</a><span>|</span><label class="collapse" for="c-38609740">[-]</label><label class="expand" for="c-38609740">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Classic thread on this stuff from Halvar Flake:<p>That&#x27;s from four years ago and does not address these technical issues. Are you going to pull it out every time OpenBSD is mentioned? I think people understand that you don&#x27;t like their approach, etc., and the flaws you see, and that OpenBSD isn&#x27;t designed for your interests.</div><br/></div></div><div id="38607451" class="c"><input type="checkbox" id="c-38607451" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#38607289">parent</a><span>|</span><a href="#38609740">prev</a><span>|</span><a href="#38609371">next</a><span>|</span><label class="collapse" for="c-38607451">[-]</label><label class="expand" for="c-38607451">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;nitter.net&#x2F;halvarflake&#x2F;status&#x2F;1156815950873804800" rel="nofollow noreferrer">https:&#x2F;&#x2F;nitter.net&#x2F;halvarflake&#x2F;status&#x2F;1156815950873804800</a><p>for those who don&#x27;t have an X a&#x2F;c</div><br/></div></div><div id="38609371" class="c"><input type="checkbox" id="c-38609371" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#38607289">parent</a><span>|</span><a href="#38607451">prev</a><span>|</span><a href="#38607328">next</a><span>|</span><label class="collapse" for="c-38609371">[-]</label><label class="expand" for="c-38609371">[7 more]</label></div><br/><div class="children"><div class="content">Is there a current meta for OpenBSD exploit developers?<p>What&#x27;s the right way to go about hardening the system if there&#x27;s no meta to observe?<p>My very naive take would be something like: A successful exploit depends on jumping through a number of different hoops.  Each of those hoops has an estimated success probability associated with it.  We can multiply all the individual probabilities together to get an estimated probability of successful exploit -- assuming that hoop probabilities are independent, which seems reasonable?  The most efficient way to harden against exploits is to try and shrink whichever hoop possesses the greatest partial derivative of overall exploit success probability with respect to developer time.</div><br/><div id="38610684" class="c"><input type="checkbox" id="c-38610684" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609371">parent</a><span>|</span><a href="#38609660">next</a><span>|</span><label class="collapse" for="c-38610684">[-]</label><label class="expand" for="c-38610684">[1 more]</label></div><br/><div class="children"><div class="content">The meta doesn’t exist because nobody targets OpenBSD because it’s not used. People’s analysis of it is mostly just their educated guess as to how work for other platforms would carry over.</div><br/></div></div><div id="38609660" class="c"><input type="checkbox" id="c-38609660" checked=""/><div class="controls bullet"><span class="by">dtx1</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609371">parent</a><span>|</span><a href="#38610684">prev</a><span>|</span><a href="#38607328">next</a><span>|</span><label class="collapse" for="c-38609660">[-]</label><label class="expand" for="c-38609660">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The most efficient way to harden against exploits is to try and shrink whichever hoop possesses the greatest partial derivative of overall exploit success probability with respect to developer time.<p>Depending on your definition of efficient, adding more hoops should work exponentially better.</div><br/><div id="38609853" class="c"><input type="checkbox" id="c-38609853" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609660">parent</a><span>|</span><a href="#38607328">next</a><span>|</span><label class="collapse" for="c-38609853">[-]</label><label class="expand" for="c-38609853">[4 more]</label></div><br/><div class="children"><div class="content">My definition of efficient is essentially whatever decreases the number of workable exploits most rapidly per hour of developer time.<p>&gt;Depending on your definition of efficient, adding more hoops should work exponentially better.<p>Explain?</div><br/><div id="38609907" class="c"><input type="checkbox" id="c-38609907" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609853">parent</a><span>|</span><a href="#38607328">next</a><span>|</span><label class="collapse" for="c-38609907">[-]</label><label class="expand" for="c-38609907">[3 more]</label></div><br/><div class="children"><div class="content">Suppose your hoop probabilities are 25% and that you have two hoops so that the probability of jumping through both is<p><pre><code>  25% * 25% = 6.25%.
</code></pre>
You can reduce the size of one of the hoops in half, changing the probability to<p><pre><code>  25% * 25%&#x2F;2 = 3.125%
</code></pre>
You can also add a third hoop, in which case the probability is<p><pre><code>  25% * 25% * 25% = 1.5625%
</code></pre>
1.5625% &lt; 3.125%, so adding a third hoop is better than shrinking one of the two existing hoops. Of course, this argument makes important assumptions about the hoop probabilities.</div><br/><div id="38610578" class="c"><input type="checkbox" id="c-38610578" checked=""/><div class="controls bullet"><span class="by">krab</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609907">parent</a><span>|</span><a href="#38610094">next</a><span>|</span><label class="collapse" for="c-38610578">[-]</label><label class="expand" for="c-38610578">[1 more]</label></div><br/><div class="children"><div class="content">The probabilities aren&#x27;t independent. The person jumping through the first hoop is probably more able than average. Therefore, any additional hoop - if it doesn&#x27;t require a completely orthogonal skill - is less selective.</div><br/></div></div><div id="38610094" class="c"><input type="checkbox" id="c-38610094" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#38607289">root</a><span>|</span><a href="#38609907">parent</a><span>|</span><a href="#38610578">prev</a><span>|</span><a href="#38607328">next</a><span>|</span><label class="collapse" for="c-38610094">[-]</label><label class="expand" for="c-38610094">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense.  Other key questions would be: complexity cost of added hoop (including, possibly, increased attack surface -- the sequence of hoops is just an abstraction that reality may not obey) and also creation difficulty (it could be that improving an existing hoop is significantly quicker than creating a new one).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38607328" class="c"><input type="checkbox" id="c-38607328" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38607289">prev</a><span>|</span><a href="#38608305">next</a><span>|</span><label class="collapse" for="c-38607328">[-]</label><label class="expand" for="c-38607328">[12 more]</label></div><br/><div class="children"><div class="content">Without a pre-formed opinion: does anybody have an intuition for the security benefits this provides? My first thought is that it’s primarily mitigating cases of attacker-introduced shellcode, which should already be pretty well covered by techniques like W^X. Code reuse techniques (ROP, JOP, etc.) aren’t impacted, right?<p>I would also think this would cause problems for JITed code, although maybe syscalls in JITed code aren’t common enough for this to be an issue (or the JIT gets around it by calling a syscall thunk, similar to how Go handled OpenBSD’s earlier syscall changes).</div><br/><div id="38607538" class="c"><input type="checkbox" id="c-38607538" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#38607328">parent</a><span>|</span><a href="#38610064">next</a><span>|</span><label class="collapse" for="c-38607538">[-]</label><label class="expand" for="c-38607538">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Code reuse techniques (ROP, JOP, etc.) aren’t impacted, right?<p>Unless I&#x27;m mistaken, this should restrict what you can do with ROP gadgets that contain syscalls. You will only be able to use the gadget with its intended arguments, since other syscall types will be disallowed.<p>&gt; I would also think this would cause problems for JITed code<p>They can probably just jump into precompiled code that performs the needed syscall. Also, making syscalls directly from something like JITed JavaScript is generally avoided anyways. AFAIK browsers don&#x27;t even let the processes that run JavaScript touch much of the system at all, instead they have to use an IPC mechanism to ask a slightly more privileged process to perform specific tasks.</div><br/><div id="38607616" class="c"><input type="checkbox" id="c-38607616" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38607538">parent</a><span>|</span><a href="#38610064">next</a><span>|</span><label class="collapse" for="c-38607616">[-]</label><label class="expand" for="c-38607616">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  You will only be able to use the gadget with its intended arguments, since other syscall types will be disallowed.<p>That makes sense, although &quot;intended&quot; arguments here means still being able to invoke `execve(2)`, etc., right? The gadget will still be able to mangle whatever it likes into the arguments for that syscall; it just won&#x27;t be able to mangle a `wait(2)` into an `execve(2)`, I think.<p>Your points about JITs make sense, thanks.</div><br/><div id="38607700" class="c"><input type="checkbox" id="c-38607700" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38607616">parent</a><span>|</span><a href="#38610064">next</a><span>|</span><label class="collapse" for="c-38607700">[-]</label><label class="expand" for="c-38607700">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s how I understand it; you can&#x27;t mangle one syscall into another, but you can still mangle the syscall&#x27;s other argument values.</div><br/></div></div></div></div></div></div><div id="38610064" class="c"><input type="checkbox" id="c-38610064" checked=""/><div class="controls bullet"><span class="by">NobodyNada</span><span>|</span><a href="#38607328">parent</a><span>|</span><a href="#38607538">prev</a><span>|</span><a href="#38608278">next</a><span>|</span><label class="collapse" for="c-38610064">[-]</label><label class="expand" for="c-38610064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Code reuse techniques (ROP, JOP, etc.) aren’t impacted, right?<p>One thing to note is that system calls can no longer be made from the program&#x27;s .text section; only from within libc. This is highly important because of ASLR: in order to ROP into a syscall, an attacker must now know where libc is located in the virtual address space. Before this mitigation, an attacker that only knew the address of the program binary could search for a sequence of bytes within the .text section that happened to decode to a syscall instruction, and use that for ROP (code reuse techniques can often access a lot of unexpected instructions by jumping into the middle of a multibyte instruction, due to x86&#x27;s complex and variable-length instruction encoding).</div><br/></div></div><div id="38608278" class="c"><input type="checkbox" id="c-38608278" checked=""/><div class="controls bullet"><span class="by">enjoytheview</span><span>|</span><a href="#38607328">parent</a><span>|</span><a href="#38610064">prev</a><span>|</span><a href="#38608305">next</a><span>|</span><label class="collapse" for="c-38608278">[-]</label><label class="expand" for="c-38608278">[7 more]</label></div><br/><div class="children"><div class="content">The other comment on this thread mentions that it also does something else:<p>&gt;disables all the system calls not explicitly invoked by the program text of a static binary<p>This means that if the original library didn&#x27;t have an execve call in it, you would&#x27;nt be able to use it even if with ROP. In short, this seems useful to block attackers from using syscalls that were not originally used by the program and nothing else. It can be useful.</div><br/><div id="38608331" class="c"><input type="checkbox" id="c-38608331" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38608278">parent</a><span>|</span><a href="#38608305">next</a><span>|</span><label class="collapse" for="c-38608331">[-]</label><label class="expand" for="c-38608331">[6 more]</label></div><br/><div class="children"><div class="content">Sure, assuming your programs don&#x27;t execute other programs. I don&#x27;t know much about OpenBSD specifically, but spawning all over the place is the &quot;norm&quot; in terms of &quot;Unix philosophy&quot; program design.<p>(I agree with the point in the adjacent thread: it&#x27;s hard to know what to make of security mitigations that aren&#x27;t accompanied by a threat model and attacker profile!)</div><br/><div id="38609164" class="c"><input type="checkbox" id="c-38609164" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38608331">parent</a><span>|</span><a href="#38608539">next</a><span>|</span><label class="collapse" for="c-38609164">[-]</label><label class="expand" for="c-38609164">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; assuming your programs don&#x27;t execute other programs.</i><p>What about language runtimes? They don&#x27;t execute other programs in the sense of ELF executables (although the programs they interpret might), but they have to support every syscall that&#x27;s included in the language. So, for example, the Python interpreter would have to include the appropriate code for every syscall that Python byte code could call (in addition to whatever internal syscalls are used by the interpreter itself). That would be a pretty complete set of syscalls.</div><br/><div id="38609418" class="c"><input type="checkbox" id="c-38609418" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38609164">parent</a><span>|</span><a href="#38610066">next</a><span>|</span><label class="collapse" for="c-38609418">[-]</label><label class="expand" for="c-38609418">[1 more]</label></div><br/><div class="children"><div class="content">Yep, language runtimes are an (inevitably?) large attack surface. My understanding is that OpenBSD userspace processes can voluntarily limit their own syscall behavior with pledge[1], so a Python program (or the interpreter itself) could limit the scope of a particular process. But I have no idea how common that is.<p>[1]: <a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;pledge" rel="nofollow noreferrer">https:&#x2F;&#x2F;man.openbsd.org&#x2F;pledge</a></div><br/></div></div><div id="38610066" class="c"><input type="checkbox" id="c-38610066" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38609164">parent</a><span>|</span><a href="#38609418">prev</a><span>|</span><a href="#38608539">next</a><span>|</span><label class="collapse" for="c-38610066">[-]</label><label class="expand" for="c-38610066">[1 more]</label></div><br/><div class="children"><div class="content">A langage runtime would dispatch to the libc, which is always whitelisted.<p>This is only an issue for the weirdo langage runtimes who’d also refuse to use libc.</div><br/></div></div></div></div><div id="38608539" class="c"><input type="checkbox" id="c-38608539" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38608331">parent</a><span>|</span><a href="#38609164">prev</a><span>|</span><a href="#38608385">next</a><span>|</span><label class="collapse" for="c-38608539">[-]</label><label class="expand" for="c-38608539">[1 more]</label></div><br/><div class="children"><div class="content">It is now less normal for programs to run programs on openbsd.</div><br/></div></div><div id="38608385" class="c"><input type="checkbox" id="c-38608385" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#38607328">root</a><span>|</span><a href="#38608331">parent</a><span>|</span><a href="#38608539">prev</a><span>|</span><a href="#38608305">next</a><span>|</span><label class="collapse" for="c-38608385">[-]</label><label class="expand" for="c-38608385">[1 more]</label></div><br/><div class="children"><div class="content">*Agent Smith voice*<p>But what use is a fork() if you&#x27;re unable to exec()?</div><br/></div></div></div></div></div></div></div></div><div id="38608305" class="c"><input type="checkbox" id="c-38608305" checked=""/><div class="controls bullet"><span class="by">MyMonkeyBalls</span><span>|</span><a href="#38607328">prev</a><span>|</span><label class="collapse" for="c-38608305">[-]</label><label class="expand" for="c-38608305">[23 more]</label></div><br/><div class="children"><div class="content">This implementation has a trivial buffer overflow, ROFLMAO</div><br/><div id="38608315" class="c"><input type="checkbox" id="c-38608315" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#38608305">parent</a><span>|</span><a href="#38609710">next</a><span>|</span><label class="collapse" for="c-38608315">[-]</label><label class="expand" for="c-38608315">[13 more]</label></div><br/><div class="children"><div class="content">Would you mind sharing how and where in the code, specifically.<p>Geniunely curious.</div><br/><div id="38608738" class="c"><input type="checkbox" id="c-38608738" checked=""/><div class="controls bullet"><span class="by">ninjin</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608315">parent</a><span>|</span><a href="#38608796">next</a><span>|</span><label class="collapse" for="c-38608738">[-]</label><label class="expand" for="c-38608738">[6 more]</label></div><br/><div class="children"><div class="content">This just went out to tech@:<p><a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-tech&amp;m=170234892604404&amp;w=2" rel="nofollow noreferrer">https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-tech&amp;m=170234892604404&amp;w=2</a></div><br/><div id="38608996" class="c"><input type="checkbox" id="c-38608996" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608738">parent</a><span>|</span><a href="#38608796">next</a><span>|</span><label class="collapse" for="c-38608996">[-]</label><label class="expand" for="c-38608996">[5 more]</label></div><br/><div class="children"><div class="content">One of the more under-appreciated features of Rust is that it traps on integer overflow &#x2F; underflow by default.<p>It’s too bad OpenBSD doesn’t have a good Rust story for the core system.  (I understand their reasoning, but it’s still too bad.)<p>I wonder how hard it would be to backport the integer behavior to C.  (C++ would be easy: Use templates.)  Perhaps they could add a compiler directive that causes vanilla integer overflow&#x2F;wraparound to trap, then add annotations or a special library call that supports modulo arithmetic as expected.</div><br/><div id="38609098" class="c"><input type="checkbox" id="c-38609098" checked=""/><div class="controls bullet"><span class="by">ninjin</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608996">parent</a><span>|</span><a href="#38609097">next</a><span>|</span><label class="collapse" for="c-38609098">[-]</label><label class="expand" for="c-38609098">[3 more]</label></div><br/><div class="children"><div class="content">Look, I get as much as the next guy that Rust brings a lot of niceties. But what we are talking about here is a project that clocks in at just over 19,000,000 lines of C (`wc -l $(find src -name &#x27;*.c&#x27; -or -name &#x27;*.h&#x27;)`), code heritage going back more than 40 years, an explicit commitment to a very rich set of platforms [1], and a <i>very</i> limited amount of manpower compared to projects such as Linux with their insane level of corporate backing. &quot;Just rewrite it in and&#x2F;or integrate Rust&quot; is neither easy nor safe in that it overturns everything that is already there and tested.<p>[1]: <a href="https:&#x2F;&#x2F;www.openbsd.org&#x2F;plat.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.openbsd.org&#x2F;plat.html</a><p>As for improving upon C. I can not speak for OpenBSD as a project, but I am sure that there would be ample excitement to produce a minimal, solid C compiler with experimental security features to then serve as the default compiler for the project (heck, OpenBSD already ships with a number of less common security-related compiler flags from what I recall). Sadly, I doubt there is either funding or the hands to make that a reality.</div><br/><div id="38609903" class="c"><input type="checkbox" id="c-38609903" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609098">parent</a><span>|</span><a href="#38609097">next</a><span>|</span><label class="collapse" for="c-38609903">[-]</label><label class="expand" for="c-38609903">[2 more]</label></div><br/><div class="children"><div class="content">This is all true, but this just means that any security focused OS for the next 40 years should consider Rust</div><br/><div id="38610640" class="c"><input type="checkbox" id="c-38610640" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609903">parent</a><span>|</span><a href="#38609097">next</a><span>|</span><label class="collapse" for="c-38610640">[-]</label><label class="expand" for="c-38610640">[1 more]</label></div><br/><div class="children"><div class="content">Rust brings niceties, but this implies no requirement for considering Rust.</div><br/></div></div></div></div></div></div><div id="38609097" class="c"><input type="checkbox" id="c-38609097" checked=""/><div class="controls bullet"><span class="by">abound</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608996">parent</a><span>|</span><a href="#38609098">prev</a><span>|</span><a href="#38608796">next</a><span>|</span><label class="collapse" for="c-38609097">[-]</label><label class="expand" for="c-38609097">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  One of the more under-appreciated features of Rust is that it traps on integer overflow &#x2F; underflow by default.<p>I think this is only true on debug builds, with --release (which most Rust binaries an end-user uses should be compiled with) it just wraps [1] [2]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;26197104b7bb9a5a35db243d639aee6e46d35d75&#x2F;text&#x2F;0560-integer-overflow.md">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;26197104b7bb9a5a35db2...</a>
[2] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;60238510" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;60238510</a></div><br/></div></div></div></div></div></div><div id="38608796" class="c"><input type="checkbox" id="c-38608796" checked=""/><div class="controls bullet"><span class="by">qzzi</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608315">parent</a><span>|</span><a href="#38608738">prev</a><span>|</span><a href="#38609710">next</a><span>|</span><label class="collapse" for="c-38608796">[-]</label><label class="expand" for="c-38608796">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how they define `MAX`, but I&#x27;m guessing it&#x27;s a typical &quot;a&gt;b?a:b&quot;. In function `elf_read_pintable` the `npins` is defined as signed int and `sysno` as unsigned int.<p>So this comparison will be unsigned and will allow to set `npins` to any value, even negative:<p><pre><code>  npins = MAX(npins, syscalls[i].sysno)
</code></pre>
Then `SYS_kbind` seems to be a signed int. So this comparison will be signed and &quot;fix&quot; the negative `npins` to `SYS_kbind`:<p><pre><code>  npins = MAX(npins, SYS_kbind)
</code></pre>
And finally the `sysno` index might be out of bounds here:<p><pre><code>  pins[syscalls[i].sysno] = syscalls[i].offset
</code></pre>
But maybe I&#x27;m completely wrong, I&#x27;m not interested in researching it too much.</div><br/><div id="38609435" class="c"><input type="checkbox" id="c-38609435" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608796">parent</a><span>|</span><a href="#38609698">next</a><span>|</span><label class="collapse" for="c-38609435">[-]</label><label class="expand" for="c-38609435">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I don&#x27;t know how they define `MAX`, but I&#x27;m guessing it&#x27;s a typical &quot;a&gt;b?a:b&quot;</i><p>Indeed: <a href="https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;sys&#x2F;sys&#x2F;param.h#L193">https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;sys&#x2F;sys&#x2F;param.h#L...</a><p><i>&gt; Then `SYS_kbind` seems to be a signed int.</i><p>It&#x27;s an untyped #define: <a href="https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;sys&#x2F;sys&#x2F;syscall.h#L269">https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;sys&#x2F;sys&#x2F;syscall.h...</a><p>I believe your whole analysis is correct, that running an elf file with an openbsd.syscalls entry with .sysno &gt; INT_MAX will allow an out-of-bounds write.</div><br/><div id="38609584" class="c"><input type="checkbox" id="c-38609584" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609435">parent</a><span>|</span><a href="#38609698">next</a><span>|</span><label class="collapse" for="c-38609584">[-]</label><label class="expand" for="c-38609584">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s an untyped #define<p>Pure decimal integer literals (like 86) are typed as &quot;int&quot; in C, rather than being typeless and triggering type inference. This is a pain when you accidentally write something like this:<p><pre><code>  uint64_t n = 1 &lt;&lt; 32;
</code></pre>
On modern desktop platforms, an int is 32 bits, so 1 &lt;&lt; 32 is 0, not 2^32, even though a 64-bit integer is wide enough to support that.<p>Regardless, it&#x27;s not relevant here, because if an integer and an unsigned integer of the same size are compared the integer is implicitly cast to unsigned integer, and 86 is fine for both signed and unsigned integers (so &quot;MAX(npins, SYS_kbind)&quot; is safe).</div><br/></div></div></div></div><div id="38609698" class="c"><input type="checkbox" id="c-38609698" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608796">parent</a><span>|</span><a href="#38609435">prev</a><span>|</span><a href="#38609195">next</a><span>|</span><label class="collapse" for="c-38609698">[-]</label><label class="expand" for="c-38609698">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Then `SYS_kbind` seems to be a signed int. So this comparison will be signed and &quot;fix&quot; the negative `npins` to `SYS_kbind`:<p><pre><code>  npins = MAX(npins, SYS_kbind)
</code></pre>
No, the comparison is unsigned here. They&#x27;re integers of the same &quot;conversion rank&quot;, so the unsigned type wins and the signed integer is interpreted as unsigned.<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;conversion" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;conversion</a><p>I can never remember the integer conversion rules and end up looking up this link whenever necessary.</div><br/><div id="38610529" class="c"><input type="checkbox" id="c-38610529" checked=""/><div class="controls bullet"><span class="by">qzzi</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609698">parent</a><span>|</span><a href="#38609195">next</a><span>|</span><label class="collapse" for="c-38610529">[-]</label><label class="expand" for="c-38610529">[1 more]</label></div><br/><div class="children"><div class="content">No.</div><br/></div></div></div></div><div id="38609195" class="c"><input type="checkbox" id="c-38609195" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38608796">parent</a><span>|</span><a href="#38609698">prev</a><span>|</span><a href="#38609710">next</a><span>|</span><label class="collapse" for="c-38609195">[-]</label><label class="expand" for="c-38609195">[1 more]</label></div><br/><div class="children"><div class="content">That seems about right.</div><br/></div></div></div></div></div></div><div id="38609710" class="c"><input type="checkbox" id="c-38609710" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38608305">parent</a><span>|</span><a href="#38608315">prev</a><span>|</span><a href="#38609061">next</a><span>|</span><label class="collapse" for="c-38609710">[-]</label><label class="expand" for="c-38609710">[1 more]</label></div><br/><div class="children"><div class="content">Have you managed to trigger this? You never ended up explaining how the heap overflow occurs, and I cannot determine whether the other person who was guessing how it might happen is right, because I am not very familiar with OpenBSD&#x27;s code.</div><br/></div></div><div id="38609061" class="c"><input type="checkbox" id="c-38609061" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38608305">parent</a><span>|</span><a href="#38609710">prev</a><span>|</span><label class="collapse" for="c-38609061">[-]</label><label class="expand" for="c-38609061">[8 more]</label></div><br/><div class="children"><div class="content">Imagine trying to write secure code in C by hand.</div><br/><div id="38609777" class="c"><input type="checkbox" id="c-38609777" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609061">parent</a><span>|</span><a href="#38609084">next</a><span>|</span><label class="collapse" for="c-38609777">[-]</label><label class="expand" for="c-38609777">[1 more]</label></div><br/><div class="children"><div class="content">Kids today ... Anyway, how has it worked out for OpenBSD?</div><br/></div></div><div id="38609084" class="c"><input type="checkbox" id="c-38609084" checked=""/><div class="controls bullet"><span class="by">MyMonkeyBalls</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609061">parent</a><span>|</span><a href="#38609777">prev</a><span>|</span><label class="collapse" for="c-38609084">[-]</label><label class="expand" for="c-38609084">[6 more]</label></div><br/><div class="children"><div class="content">Yeah and imagine advertising yourself as the &quot;most secure OS in the world&quot; at the same time</div><br/><div id="38609365" class="c"><input type="checkbox" id="c-38609365" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609084">parent</a><span>|</span><a href="#38610219">next</a><span>|</span><label class="collapse" for="c-38609365">[-]</label><label class="expand" for="c-38609365">[3 more]</label></div><br/><div class="children"><div class="content">Anyone else with their track record?</div><br/><div id="38609833" class="c"><input type="checkbox" id="c-38609833" checked=""/><div class="controls bullet"><span class="by">MyMonkeyBalls</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609365">parent</a><span>|</span><a href="#38610219">next</a><span>|</span><label class="collapse" for="c-38609833">[-]</label><label class="expand" for="c-38609833">[2 more]</label></div><br/><div class="children"><div class="content">Which track record exactly? Their slogan is known to be a complete lie</div><br/><div id="38610471" class="c"><input type="checkbox" id="c-38610471" checked=""/><div class="controls bullet"><span class="by">IntelMiner</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609833">parent</a><span>|</span><a href="#38610219">next</a><span>|</span><label class="collapse" for="c-38610471">[-]</label><label class="expand" for="c-38610471">[1 more]</label></div><br/><div class="children"><div class="content">[citation needed]</div><br/></div></div></div></div></div></div><div id="38610219" class="c"><input type="checkbox" id="c-38610219" checked=""/><div class="controls bullet"><span class="by">starcraft2wol</span><span>|</span><a href="#38608305">root</a><span>|</span><a href="#38609084">parent</a><span>|</span><a href="#38609365">prev</a><span>|</span><a href="#38609644">next</a><span>|</span><label class="collapse" for="c-38610219">[-]</label><label class="expand" for="c-38610219">[1 more]</label></div><br/><div class="children"><div class="content">Yep, they implement kernel level security, rather than obsessing over language.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>