<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722330064774" as="style"/><link rel="stylesheet" href="styles.css?v=1722330064774"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zverok.space/blog/2024-07-26-range-evolution.html">The evolution of Ruby&#x27;s Range class</a> <span class="domain">(<a href="https://zverok.space">zverok.space</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>31 comments</span></div><br/><div><div id="41104983" class="c"><input type="checkbox" id="c-41104983" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#41105489">next</a><span>|</span><label class="collapse" for="c-41104983">[-]</label><label class="expand" for="c-41104983">[17 more]</label></div><br/><div class="children"><div class="content">Ruby&#x27;s Range class has plenty of bugs to offer if you use it with anything except numbers, especially if you use any of its more &quot;exotic&quot; features.<p>I guess this isn&#x27;t super constructive, but to me the whole thing smells of not just a lack of discipline, but a lack of _interest_ in correctness that seems to be endemic in the Ruby community.<p>We ended up writing our own `TimeRange` class to paper over the base Range bugs that show up if you use it with times.<p>One awkward takeaway from the experience is that I&#x27;ve come to believe that sometimes it _is_ worth unit testing other people&#x27;s code, counter to the popular advice.</div><br/><div id="41106568" class="c"><input type="checkbox" id="c-41106568" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41104983">parent</a><span>|</span><a href="#41105608">next</a><span>|</span><label class="collapse" for="c-41106568">[-]</label><label class="expand" for="c-41106568">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I&#x27;ve come to believe that sometimes it _is_ worth unit testing other people&#x27;s code, counter to the popular advice.</i><p>The popular advice is that you shouldn&#x27;t test implementation, only interface behaviour. Which means that you shouldn&#x27;t explicitly test the usage of someone else&#x27;s code within your code. Their code is just an implementation detail. If the implementation is faulty, testing of the interface should still reveal that faulty behaviour.<p>That doesn&#x27;t necessarily mean you shouldn&#x27;t ever test someone else&#x27;s code (with their interfaces). But if someone else&#x27;s code is not tested it is undefined, and relying on undefined behaviour is fraught with problems. It is unlikely you would want to use it in the first place, which, practically speaking, leaves little justification to invest in improving the situation.</div><br/></div></div><div id="41105608" class="c"><input type="checkbox" id="c-41105608" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41104983">parent</a><span>|</span><a href="#41106568">prev</a><span>|</span><a href="#41106561">next</a><span>|</span><label class="collapse" for="c-41105608">[-]</label><label class="expand" for="c-41105608">[2 more]</label></div><br/><div class="children"><div class="content">&gt; sometimes it _is_ worth unit testing other people&#x27;s code, counter to the popular advice<p>Relying on a library you don&#x27;t have any tests for puts a lot of faith in it working. Also in it continuing to behave as you expected when you change the version.<p>People have weird ideas about other people&#x27;s code though. Something being found on GitHub may mean it doesn&#x27;t need it be reviewed or even glanced through before putting it into production while code written in house is obsessed over.</div><br/><div id="41106716" class="c"><input type="checkbox" id="c-41106716" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105608">parent</a><span>|</span><a href="#41106561">next</a><span>|</span><label class="collapse" for="c-41106716">[-]</label><label class="expand" for="c-41106716">[1 more]</label></div><br/><div class="children"><div class="content">People in the software industry are just weird in general, it seems. I regularly see the same type of behaviour around blog posts by random authors drawing <i>&quot;My, what a fantastic idea, we must try this!&quot;</i>, even when it clearly isn&#x27;t a good idea, but anyone with ideas internally are automatically discounted.</div><br/></div></div></div></div><div id="41106561" class="c"><input type="checkbox" id="c-41106561" checked=""/><div class="controls bullet"><span class="by">jaynetics</span><span>|</span><a href="#41104983">parent</a><span>|</span><a href="#41105608">prev</a><span>|</span><a href="#41105100">next</a><span>|</span><label class="collapse" for="c-41106561">[-]</label><label class="expand" for="c-41106561">[1 more]</label></div><br/><div class="children"><div class="content">What are some of the bugs when using Range with Time?</div><br/></div></div><div id="41105100" class="c"><input type="checkbox" id="c-41105100" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#41104983">parent</a><span>|</span><a href="#41106561">prev</a><span>|</span><a href="#41105489">next</a><span>|</span><label class="collapse" for="c-41105100">[-]</label><label class="expand" for="c-41105100">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that there&#x27;s a good chance many of these issues are well known by the Ruby community and many even get frustrated by them; *but*, so much code now relies on its behavior, predictably or otherwise, that they couldn&#x27;t change it.<p>My pet frustration in Ruby is `.slice` behavior.<p><pre><code>  &gt; &quot;abc&quot;.slice(0, 10)
  &quot;abc&quot;
  &gt; &quot;abc&quot;.slice(2, 10)
  &quot;c&quot;
  &gt; &quot;abc&quot;.slice(3, 10)
  &quot;&quot;
  &gt; &quot;abc&quot;.slice(4, 10)
  null
</code></pre>
In Python, the last would also return &quot;&quot;.<p>edit: updated the code to reflect a basic repl, without using puts or the &#x27;or&#x27; statement, which handles the falsy behavior that &quot;&quot; and null both have in Python.</div><br/><div id="41105203" class="c"><input type="checkbox" id="c-41105203" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105100">parent</a><span>|</span><a href="#41105296">next</a><span>|</span><label class="collapse" for="c-41105203">[-]</label><label class="expand" for="c-41105203">[4 more]</label></div><br/><div class="children"><div class="content">&gt; My pet frustration in Ruby is `.slice` behavior.<p>I would argue that any input that doesn&#x27;t have exactly one obviously correct output should result in an exception being raised. But Ruby often shies away from doing that. My interpretation is that they prefer to return _something_ rather than blowing up, so the show can go on.<p>I guess I sit at the opposite end of the philosophical spectrum from Ruby, so it&#x27;s no wonder choices like this frustrate me. My personal philosophy is &quot;explode early, explode often&quot;, because propagating invalid states only leads to future pain and suffering.<p>&gt; [...] so much code now relies on its behavior, predictably or otherwise, that they couldn&#x27;t change it.<p>I&#x27;m not denying this is a reason for keeping the questionably behaviour, but it&#x27;s kind of funny because Ruby also introduces subtly backward-incompatible changes semi-regularly, including in &quot;minor&quot; releases. (Maybe that last bit is unfair, because I don&#x27;t think that Ruby has ever claimed to follow semver.)</div><br/><div id="41107155" class="c"><input type="checkbox" id="c-41107155" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105203">parent</a><span>|</span><a href="#41106826">next</a><span>|</span><label class="collapse" for="c-41107155">[-]</label><label class="expand" for="c-41107155">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but Ruby often shies away from doing that. My interpretation is that they prefer to return _something_ rather than blowing up, so the show can go on.<p>There are two (intertwined) explanations:<p>- In Ruby exceptions are costly to generate.<p>- Similar to Go, Ruby&#x27;s stdlib design favours using return values for signalling, keeping exceptions for <i>exceptional</i> cases.<p>So in plain† Ruby there are a lot of places that use `nil` to signal that something&#x27;s off, e.g `[1,2,3][4]` returns `nil` because it&#x27;s an out of bounds access, or `&quot;123&quot;.downcase!` returns `nil` because nothing has been downcased, or `__FILE__` returns `nil` when a file is `eval`&#x27;d.<p>So yes, you have to check for things like `nil` (or explicitly swallow with `&amp;.` which is kind of a Maybe monad pattern) before doing stuff with values, just like you check for `if err == nil` in Go.<p>Running a type checker like `steep` helps a lot linting for these cases.<p>† Rails likes to generate exceptions, but Rails != the whole of Ruby.</div><br/></div></div><div id="41106826" class="c"><input type="checkbox" id="c-41106826" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105203">parent</a><span>|</span><a href="#41107155">prev</a><span>|</span><a href="#41105810">next</a><span>|</span><label class="collapse" for="c-41106826">[-]</label><label class="expand" for="c-41106826">[1 more]</label></div><br/><div class="children"><div class="content">I agree it isn&#x27;t entirely obvious at first glance why slice behaves the way it does, there is a pattern. If the first number in the range is a valid index into the string then you&#x27;ll get something back, and if it isn&#x27;t you can&#x27;t get anything back so you have to get back a nil.<p>Coming from a C++ background my time in Ruby was weird and enlightening, it was less specified than C++, but pretty much everything is. I don&#x27;t think it was underspecified, but a lot of the behavior was meant to be intuited and follows some kind of underlying pattern. If you miss the pattern you miss a lot of the functionality of that part of the language.<p>I agree that failing early and often is generally preferable. I don&#x27;t see that Ruby doesn&#x27;t do that, it just has more definitions for generic behaviors. Consider the amount of things in the range from the original post that produce type errors. Last time I checked both the C++ language and the C++ standard Library both had about twice as many pages in The Standard than all of Ruby in its standard Library have, yet there is still undefined and implementation to find behavior. So there are places where we get weird an unexpected Behavior that can result in bad State being passed around even in very formally specified places.</div><br/></div></div><div id="41105810" class="c"><input type="checkbox" id="c-41105810" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105203">parent</a><span>|</span><a href="#41106826">prev</a><span>|</span><a href="#41105296">next</a><span>|</span><label class="collapse" for="c-41105810">[-]</label><label class="expand" for="c-41105810">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My interpretation is that they prefer to return _something_ rather than blowing up, so the show can go on.<p>I think I saw this horror movie, but it was titled &quot;PHP.&quot; :p</div><br/></div></div></div></div><div id="41105296" class="c"><input type="checkbox" id="c-41105296" checked=""/><div class="controls bullet"><span class="by">marcianx</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105100">parent</a><span>|</span><a href="#41105203">prev</a><span>|</span><a href="#41105489">next</a><span>|</span><label class="collapse" for="c-41105296">[-]</label><label class="expand" for="c-41105296">[7 more]</label></div><br/><div class="children"><div class="content">I immediately see the logic in this API. When slicing, I look at indexes as being between elements or at the start (0) or end (length). This gives an in-bounds starting index between 0 and length, inclusive. So if the starting index is in bounds, you get a substring. If it&#x27;s not, you get no result.<p>And your answer for Python is not quite correct: &quot;&quot; is falsy in Python, and both of the last two when translated to Python give &quot;null&quot;.</div><br/><div id="41105441" class="c"><input type="checkbox" id="c-41105441" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105296">parent</a><span>|</span><a href="#41105329">next</a><span>|</span><label class="collapse" for="c-41105441">[-]</label><label class="expand" for="c-41105441">[4 more]</label></div><br/><div class="children"><div class="content">What I find weird here is the asymmetry: Ruby apparently allows the <i>end</i> index to be out of range, but not the <i>start</i> index. Contrast with, e.g., Rust&#x27;s slice syntax, where both endpoints have to be in range, or else it will cause a panic.</div><br/><div id="41106615" class="c"><input type="checkbox" id="c-41106615" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105441">parent</a><span>|</span><a href="#41105329">next</a><span>|</span><label class="collapse" for="c-41106615">[-]</label><label class="expand" for="c-41106615">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Ruby apparently allows the end index to be out of range, but not the start index.</i><p>What gives you that impression? &quot;abc&quot;.slice(4, 10) is perfectly valid and accepted, assuming the code above is accurate.</div><br/><div id="41106838" class="c"><input type="checkbox" id="c-41106838" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41106615">parent</a><span>|</span><a href="#41105329">next</a><span>|</span><label class="collapse" for="c-41106838">[-]</label><label class="expand" for="c-41106838">[2 more]</label></div><br/><div class="children"><div class="content">Underneath the hood that&#x27;s a C string, and the four points to the null terminator, so it&#x27;s indexable. And that&#x27;s why you get an empty string if you point exactly one past the end.<p>That&#x27;s why if you put five or more in for the first index it fails to produce a result entirely. I think I might I preferred an exception or a failure code being returned, but I can&#x27;t say the current design is truly awful.</div><br/><div id="41106894" class="c"><input type="checkbox" id="c-41106894" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41106838">parent</a><span>|</span><a href="#41105329">next</a><span>|</span><label class="collapse" for="c-41106894">[-]</label><label class="expand" for="c-41106894">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; That&#x27;s why if you put five or more in for the first index it fails to produce a result entirely.</i><p>Where does <i>this</i> come from? Are these discrepancies stemming from different Ruby implementations&#x2F;versions behaving differently? &quot;abc&quot;.slice(5, 10) returns the same value as &quot;abc&quot;.slice(4, 10) [which, curiously, does not return the same value as the original comment]  under MRI 2.6.1 that I had handy.</div><br/></div></div></div></div></div></div></div></div><div id="41105329" class="c"><input type="checkbox" id="c-41105329" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105296">parent</a><span>|</span><a href="#41105441">prev</a><span>|</span><a href="#41106458">next</a><span>|</span><label class="collapse" for="c-41105329">[-]</label><label class="expand" for="c-41105329">[1 more]</label></div><br/><div class="children"><div class="content">Apologies, you&#x27;re correct. I didn&#x27;t consider the ramifications of printing to the screen with an or. I was trying to get rid of the lack of distinction between `puts null` and `puts &quot;&quot;` in Ruby.<p>And yes, I also understand the logic of the API; but if you&#x27;re used to using slice to protect against random NPEs and out-of-bounds exceptions - which is something I do and am used to being able to trust in as a general pattern.</div><br/></div></div><div id="41106458" class="c"><input type="checkbox" id="c-41106458" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41104983">root</a><span>|</span><a href="#41105296">parent</a><span>|</span><a href="#41105329">prev</a><span>|</span><a href="#41105489">next</a><span>|</span><label class="collapse" for="c-41106458">[-]</label><label class="expand" for="c-41106458">[1 more]</label></div><br/><div class="children"><div class="content">I ask for a range whose start is in bounds but end is out of bounds.<p>I ask for a range whose start is in bounds but whose end is out of bounds.<p>Why should those return two entirely different types?</div><br/></div></div></div></div></div></div></div></div><div id="41105489" class="c"><input type="checkbox" id="c-41105489" checked=""/><div class="controls bullet"><span class="by">jballanc</span><span>|</span><a href="#41104983">prev</a><span>|</span><a href="#41106199">next</a><span>|</span><label class="collapse" for="c-41105489">[-]</label><label class="expand" for="c-41105489">[6 more]</label></div><br/><div class="children"><div class="content">Nice write-up, but no discussion of Ruby&#x27;s Range class is complete without at least a mention of the venerable flip-flop!<p>Can you predict the output of the following?<p><pre><code>    (1..20).each do |i|
      puts i if i.odd?..i.prime?
    end</code></pre></div><br/><div id="41105865" class="c"><input type="checkbox" id="c-41105865" checked=""/><div class="controls bullet"><span class="by">Lammy</span><span>|</span><a href="#41105489">parent</a><span>|</span><a href="#41105581">next</a><span>|</span><label class="collapse" for="c-41105865">[-]</label><label class="expand" for="c-41105865">[1 more]</label></div><br/><div class="children"><div class="content">Relevant documentation link for the uninitiated: <a href="https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;master&#x2F;syntax&#x2F;control_expressions_rdoc.html#label-Flip-Flop" rel="nofollow">https:&#x2F;&#x2F;docs.ruby-lang.org&#x2F;en&#x2F;master&#x2F;syntax&#x2F;control_expressi...</a><p>“The form of the flip-flop is an expression that indicates when the flip-flop turns on, .. (or ...), then an expression that indicates when the flip-flop will turn off. While the flip-flop is on it will continue to evaluate to true, and false when off.”</div><br/></div></div><div id="41105581" class="c"><input type="checkbox" id="c-41105581" checked=""/><div class="controls bullet"><span class="by">cout</span><span>|</span><a href="#41105489">parent</a><span>|</span><a href="#41105865">prev</a><span>|</span><a href="#41105709">next</a><span>|</span><label class="collapse" for="c-41105581">[-]</label><label class="expand" for="c-41105581">[3 more]</label></div><br/><div class="children"><div class="content">This is one of the few features of Ruby I&#x27;ve never found a use for, and not fit lack of trying.<p>I thought I remembered Matz once saying it would be removed, But I could be wrong.  Maybe someone uses it.</div><br/><div id="41105956" class="c"><input type="checkbox" id="c-41105956" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#41105489">root</a><span>|</span><a href="#41105581">parent</a><span>|</span><a href="#41106559">next</a><span>|</span><label class="collapse" for="c-41105956">[-]</label><label class="expand" for="c-41105956">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s from Awk, probably via Perl. <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gawk&#x2F;manual&#x2F;html_node&#x2F;Ranges.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gawk&#x2F;manual&#x2F;html_node&#x2F;Ranges.ht...</a></div><br/></div></div><div id="41106559" class="c"><input type="checkbox" id="c-41106559" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#41105489">root</a><span>|</span><a href="#41105581">parent</a><span>|</span><a href="#41105956">prev</a><span>|</span><a href="#41105709">next</a><span>|</span><label class="collapse" for="c-41106559">[-]</label><label class="expand" for="c-41106559">[1 more]</label></div><br/><div class="children"><div class="content">The flip-flop operator is very useful to extract continuous subsets, typically, sections of (multi-line) strings, where the dev defines the delimiters - think of the `=begin` and `=end` keywords.<p>I&#x27;ve personally never used for anything else than strings, but when I do, it&#x27;s very useful.</div><br/></div></div></div></div><div id="41105709" class="c"><input type="checkbox" id="c-41105709" checked=""/><div class="controls bullet"><span class="by">pooriar</span><span>|</span><a href="#41105489">parent</a><span>|</span><a href="#41105581">prev</a><span>|</span><a href="#41106199">next</a><span>|</span><label class="collapse" for="c-41105709">[-]</label><label class="expand" for="c-41105709">[1 more]</label></div><br/><div class="children"><div class="content">Same as this?<p><pre><code>  (1..20).each do |i|
    puts i if i.odd? || i.prime?
  end
</code></pre>
edit - upon testing, I just realized the parent&#x27;s code prints 10 &amp; 16, my code does not, so not the same.</div><br/></div></div></div></div><div id="41106199" class="c"><input type="checkbox" id="c-41106199" checked=""/><div class="controls bullet"><span class="by">anytime5704</span><span>|</span><a href="#41105489">prev</a><span>|</span><label class="collapse" for="c-41106199">[-]</label><label class="expand" for="c-41106199">[7 more]</label></div><br/><div class="children"><div class="content">God I hate ruby.<p>I&#x27;m happy that people like it, and recognize that a ton of real products use it to great effect, but I absolutely cannot stand it.</div><br/><div id="41106292" class="c"><input type="checkbox" id="c-41106292" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#41106199">parent</a><span>|</span><label class="collapse" for="c-41106292">[-]</label><label class="expand" for="c-41106292">[6 more]</label></div><br/><div class="children"><div class="content">Are there any important reasons as to _why?<p>(edit: fixed underscore position)</div><br/><div id="41106767" class="c"><input type="checkbox" id="c-41106767" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41106199">root</a><span>|</span><a href="#41106292">parent</a><span>|</span><a href="#41106755">next</a><span>|</span><label class="collapse" for="c-41106767">[-]</label><label class="expand" for="c-41106767">[2 more]</label></div><br/><div class="children"><div class="content">He is neither lucky, nor stiff.<p>(Your joke might have played better had you gotten the underscore in the right place)</div><br/><div id="41106844" class="c"><input type="checkbox" id="c-41106844" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#41106199">root</a><span>|</span><a href="#41106767">parent</a><span>|</span><a href="#41106755">next</a><span>|</span><label class="collapse" for="c-41106844">[-]</label><label class="expand" for="c-41106844">[1 more]</label></div><br/><div class="children"><div class="content">Maybe he just doesn&#x27;t like chunks in his bacon.</div><br/></div></div></div></div><div id="41106755" class="c"><input type="checkbox" id="c-41106755" checked=""/><div class="controls bullet"><span class="by">mkl95</span><span>|</span><a href="#41106199">root</a><span>|</span><a href="#41106292">parent</a><span>|</span><a href="#41106767">prev</a><span>|</span><label class="collapse" for="c-41106755">[-]</label><label class="expand" for="c-41106755">[3 more]</label></div><br/><div class="children"><div class="content">The top comment gives a good reason. The Ruby community embraces broken software. Running Ruby software in production gives many devs a perpetual feeling of impending doom.</div><br/><div id="41106861" class="c"><input type="checkbox" id="c-41106861" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#41106199">root</a><span>|</span><a href="#41106755">parent</a><span>|</span><a href="#41106900">next</a><span>|</span><label class="collapse" for="c-41106861">[-]</label><label class="expand" for="c-41106861">[1 more]</label></div><br/><div class="children"><div class="content">My time in the Ruby Community taught me about test driven development and a reliance on process that produced functioning and robust software. Things like continuous integration and careful specification through tests were promoted. If anything my most common problem with Ruby Community was too many different test suites to pick from. It seemed like there was a new one every week.<p>That said it was an non-typechecked interpreted scripting language and updates between versions could break things but if you had a process and a test suite those weren&#x27;t practical issues.<p>What are some possible reasons that are experiencing the community differed so wildly?</div><br/></div></div><div id="41106900" class="c"><input type="checkbox" id="c-41106900" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#41106199">root</a><span>|</span><a href="#41106755">parent</a><span>|</span><a href="#41106861">prev</a><span>|</span><label class="collapse" for="c-41106900">[-]</label><label class="expand" for="c-41106900">[1 more]</label></div><br/><div class="children"><div class="content">A solo dev friend of mine is about to sign a 150k usd&#x2F;year deal for his software written in JRuby. Initially installed on dozens of computers, it is to be run for months and years without intervention. So apparently there are ehhs and iffs and butts to all the off-hand dismissals. Maybe you have an elk here or there that would agree.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>