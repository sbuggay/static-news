<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694941255658" as="style"/><link rel="stylesheet" href="styles.css?v=1694941255658"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mariusbancila.ro/blog/2023/09/12/formatting-text-in-c-the-old-and-the-new-ways/">Formatting text in C++: Old and new ways</a> <span class="domain">(<a href="https://mariusbancila.ro">mariusbancila.ro</a>)</span></div><div class="subtext"><span>signa11</span> | <span>61 comments</span></div><br/><div><div id="37538397" class="c"><input type="checkbox" id="c-37538397" checked=""/><div class="controls bullet"><span class="by">havermeyer</span><span>|</span><a href="#37541903">next</a><span>|</span><label class="collapse" for="c-37538397">[-]</label><label class="expand" for="c-37538397">[2 more]</label></div><br/><div class="children"><div class="content">Something else to consider is compile time versus runtime validation with formatting libraries, e.g. due to passing the wrong number or type of arguments. The Abseil str_format library does compile time validation for both when possible: <a href="https:&#x2F;&#x2F;abseil.io&#x2F;docs&#x2F;cpp&#x2F;guides&#x2F;format" rel="nofollow noreferrer">https:&#x2F;&#x2F;abseil.io&#x2F;docs&#x2F;cpp&#x2F;guides&#x2F;format</a></div><br/><div id="37539318" class="c"><input type="checkbox" id="c-37539318" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#37538397">parent</a><span>|</span><a href="#37541903">next</a><span>|</span><label class="collapse" for="c-37539318">[-]</label><label class="expand" for="c-37539318">[1 more]</label></div><br/><div class="children"><div class="content">{fmt} certainly does this too.  It works quite nicely with the clangd language server flagging a line as an error until the format string and arguments match.</div><br/></div></div></div></div><div id="37538616" class="c"><input type="checkbox" id="c-37538616" checked=""/><div class="controls bullet"><span class="by">lysium</span><span>|</span><a href="#37541903">prev</a><span>|</span><a href="#37538061">next</a><span>|</span><label class="collapse" for="c-37538616">[-]</label><label class="expand" for="c-37538616">[6 more]</label></div><br/><div class="children"><div class="content">Why do execution times drop so drastically with increasing number of iterations? Shouldn’t the caches be filled after one iteration already? There is no JIT in C++, or is it?</div><br/><div id="37542595" class="c"><input type="checkbox" id="c-37542595" checked=""/><div class="controls bullet"><span class="by">xcvb</span><span>|</span><a href="#37538616">parent</a><span>|</span><a href="#37542260">next</a><span>|</span><label class="collapse" for="c-37542595">[-]</label><label class="expand" for="c-37542595">[2 more]</label></div><br/><div class="children"><div class="content">I only had a quick look at the code, but it looks like it&#x27;s timing memory allocation. For example the sprintf part uses std::string str(100, &#x27;\0&#x27;).  I&#x27;m not a C++ expert, but I believe this is essentially doing a malloc and memset of 100 bytes for every call to sprintf. So this is probably a poorly setup benchmark.</div><br/><div id="37542764" class="c"><input type="checkbox" id="c-37542764" checked=""/><div class="controls bullet"><span class="by">lysium</span><span>|</span><a href="#37538616">root</a><span>|</span><a href="#37542595">parent</a><span>|</span><a href="#37542260">next</a><span>|</span><label class="collapse" for="c-37542764">[-]</label><label class="expand" for="c-37542764">[1 more]</label></div><br/><div class="children"><div class="content">I think that might be it. Too bad, the results of this kind of benchmark would have been interesting.</div><br/></div></div></div></div><div id="37542260" class="c"><input type="checkbox" id="c-37542260" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#37538616">parent</a><span>|</span><a href="#37542595">prev</a><span>|</span><a href="#37539478">next</a><span>|</span><label class="collapse" for="c-37542260">[-]</label><label class="expand" for="c-37542260">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is no JIT in C++, or is it?<p>This question doesn&#x27;t make sense for the context*. C++ is Ahead of Time, by design; there is nothing to &quot;just in time&quot; compile.<p>JIT (as a concept) only makes sense if you are, in some way, abstracting your code from native machine code (usually via some sort of VM, like Python or Java&#x27;s), which the &quot;system&quot; languages (C, Rust, Zig, C++, etc) do not.<p>What I <i>think</i> you are trying to reference are &quot;runtime optimizations&quot;; in which case, the answer is probably no. Base and STD C++ are pretty conservative about what they put into the runtime. Extended runtimes like Windows&#x27; and glibc might do some conditional optimizations, however.<p>* Yes, some contrarian is going to point out a project like Cling or C++&#x2F;CLI. This is why I&#x27;m being very clear about &quot;context&quot;.</div><br/></div></div><div id="37539478" class="c"><input type="checkbox" id="c-37539478" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#37538616">parent</a><span>|</span><a href="#37542260">prev</a><span>|</span><a href="#37539115">next</a><span>|</span><label class="collapse" for="c-37539478">[-]</label><label class="expand" for="c-37539478">[1 more]</label></div><br/><div class="children"><div class="content">Your CPU is effectively a virtual machine with stuff like branch prediction, speculative execution w&#x2F;rollback, pipelining, implicit parallelism, etc. etc.<p>Of course, it isn&#x27;t able to do quite as much as a VM running in software (because fixed buffers for everything, etc.), but even so...</div><br/></div></div><div id="37539115" class="c"><input type="checkbox" id="c-37539115" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37538616">parent</a><span>|</span><a href="#37539478">prev</a><span>|</span><a href="#37538061">next</a><span>|</span><label class="collapse" for="c-37539115">[-]</label><label class="expand" for="c-37539115">[1 more]</label></div><br/><div class="children"><div class="content">Branch predictor maybe.</div><br/></div></div></div></div><div id="37538061" class="c"><input type="checkbox" id="c-37538061" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37538616">prev</a><span>|</span><a href="#37539180">next</a><span>|</span><label class="collapse" for="c-37538061">[-]</label><label class="expand" for="c-37538061">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    unsigned char str[]{3,4,5,6,0};
    std::stringstream ss;
    ss &lt;&lt; &quot;str=&quot; &lt;&lt; str;
    std::string text = ss.str();
</code></pre>
&gt; The content of text will be &quot;str=♥♦♣♠&quot;.<p>no, it wont. if you are on an old Windows with code page 437 then sure. but on any sane UTF-8 system, you&#x27;re just going to get some binary data.<p>1. <a href="https:&#x2F;&#x2F;wikipedia.org&#x2F;wiki&#x2F;Code_page_437" rel="nofollow noreferrer">https:&#x2F;&#x2F;wikipedia.org&#x2F;wiki&#x2F;Code_page_437</a></div><br/><div id="37538195" class="c"><input type="checkbox" id="c-37538195" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#37538061">parent</a><span>|</span><a href="#37539180">next</a><span>|</span><label class="collapse" for="c-37538195">[-]</label><label class="expand" for="c-37538195">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for finding this out as a codepage issue. The implementation of the operator&lt;&lt; will indeed call ostream::widen() to expand character into a locale dependent equivalent.</div><br/></div></div></div></div><div id="37539180" class="c"><input type="checkbox" id="c-37539180" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#37538061">prev</a><span>|</span><a href="#37538908">next</a><span>|</span><label class="collapse" for="c-37539180">[-]</label><label class="expand" for="c-37539180">[1 more]</label></div><br/><div class="children"><div class="content">finally!<p>I remember using variadic templates to print things in a single function call, like this:<p><pre><code>    int i; float f; string s;
    print_special(i, f, s);
</code></pre>
It would somehow imitate the behavior of python&#x27;s print()<p>I never really understood how variadic template worked, maybe one day I will, and to be honest, I&#x27;m suspecting it&#x27;s really not very kind to compile time, it&#x27;s a lot of type checks done under the hood.<p>It&#x27;s a bit problematic that C++ cannot be compiled quickly without a fast CPU, I wonder how this is going to be addressed one day, because it seems that modules aren&#x27;t a good solution to that, yet.</div><br/></div></div><div id="37538908" class="c"><input type="checkbox" id="c-37538908" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#37539180">prev</a><span>|</span><a href="#37538443">next</a><span>|</span><label class="collapse" for="c-37538908">[-]</label><label class="expand" for="c-37538908">[1 more]</label></div><br/><div class="children"><div class="content">Does `std::format` still use locales under the hood like `std::stringstream` does?<p>They dropped locale support for `std::to_chars` so hopefully they can be turned off for `std::format` too</div><br/></div></div><div id="37538443" class="c"><input type="checkbox" id="c-37538443" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538908">prev</a><span>|</span><a href="#37542482">next</a><span>|</span><label class="collapse" for="c-37538443">[-]</label><label class="expand" for="c-37538443">[29 more]</label></div><br/><div class="children"><div class="content">I find it disappointing that cpp20 still doesn&#x27;t have a solution that is more convenient than good ol printf (except for memory safety).<p>Another example would be convenient list comprehension, convenient maps wihout juggling around with tuples, first(), second(), at()...</div><br/><div id="37538608" class="c"><input type="checkbox" id="c-37538608" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#37538443">parent</a><span>|</span><a href="#37538809">next</a><span>|</span><label class="collapse" for="c-37538608">[-]</label><label class="expand" for="c-37538608">[11 more]</label></div><br/><div class="children"><div class="content">Maps have been improved quite a bit.<p>For example, if you have a std::map&lt;std::string, int&gt;, you can iterate over it like this:<p><pre><code>    for (auto [s, n]: my_map) {
        &#x2F;&#x2F; s = string key, n = int value
    }
</code></pre>
You can test for membership:<p><pre><code>    if (my_map.contains(“foo”)) { &#x2F;* do something * }
</code></pre>
Although I still usually use find because if the key is in the map, I probably want the value.<p>You can use initialization lists with them too:<p><pre><code>    std::map&lt;std::string, int&gt; my_map = {
      { “one”, 1 },
      { “two”, 2 },
      { “three”, 3 }
    };</code></pre></div><br/><div id="37538636" class="c"><input type="checkbox" id="c-37538636" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538608">parent</a><span>|</span><a href="#37538864">next</a><span>|</span><label class="collapse" for="c-37538636">[-]</label><label class="expand" for="c-37538636">[9 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    for (auto [s, n]: my_map)
</code></pre>
copies all the data needlessly, better to use<p><pre><code>    for (const auto&amp; [s, n]: my_map)</code></pre></div><br/><div id="37538931" class="c"><input type="checkbox" id="c-37538931" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538636">parent</a><span>|</span><a href="#37538748">next</a><span>|</span><label class="collapse" for="c-37538931">[-]</label><label class="expand" for="c-37538931">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why some newer languages have &#x27;const are the default&#x27;.</div><br/><div id="37538980" class="c"><input type="checkbox" id="c-37538980" checked=""/><div class="controls bullet"><span class="by">Tommstein</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538931">parent</a><span>|</span><a href="#37538748">next</a><span>|</span><label class="collapse" for="c-37538980">[-]</label><label class="expand" for="c-37538980">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure it&#x27;s the reference that makes the data not be copied.</div><br/><div id="37539584" class="c"><input type="checkbox" id="c-37539584" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538980">parent</a><span>|</span><a href="#37539291">next</a><span>|</span><label class="collapse" for="c-37539584">[-]</label><label class="expand" for="c-37539584">[1 more]</label></div><br/><div class="children"><div class="content">Without the const the key would still be const.</div><br/></div></div><div id="37539291" class="c"><input type="checkbox" id="c-37539291" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538980">parent</a><span>|</span><a href="#37539584">prev</a><span>|</span><a href="#37538748">next</a><span>|</span><label class="collapse" for="c-37539291">[-]</label><label class="expand" for="c-37539291">[1 more]</label></div><br/><div class="children"><div class="content">Copying the data to a const makes little sense in this case. The extra &amp; choice that has emerged makes things more complicated than needed. The sad faith of this old language.</div><br/></div></div></div></div></div></div><div id="37538748" class="c"><input type="checkbox" id="c-37538748" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538636">parent</a><span>|</span><a href="#37538931">prev</a><span>|</span><a href="#37538864">next</a><span>|</span><label class="collapse" for="c-37538748">[-]</label><label class="expand" for="c-37538748">[4 more]</label></div><br/><div class="children"><div class="content">what a language</div><br/><div id="37538962" class="c"><input type="checkbox" id="c-37538962" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538748">parent</a><span>|</span><a href="#37538864">next</a><span>|</span><label class="collapse" for="c-37538962">[-]</label><label class="expand" for="c-37538962">[3 more]</label></div><br/><div class="children"><div class="content">just consider const reference to be the default for non-primitive types</div><br/><div id="37539566" class="c"><input type="checkbox" id="c-37539566" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538962">parent</a><span>|</span><a href="#37538864">next</a><span>|</span><label class="collapse" for="c-37539566">[-]</label><label class="expand" for="c-37539566">[2 more]</label></div><br/><div class="children"><div class="content">My rule of thumb is to use const references when the sizeof the type is larger than the sizeof a pointer or reference.</div><br/><div id="37540776" class="c"><input type="checkbox" id="c-37540776" checked=""/><div class="controls bullet"><span class="by">repsilat</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37539566">parent</a><span>|</span><a href="#37538864">next</a><span>|</span><label class="collapse" for="c-37540776">[-]</label><label class="expand" for="c-37540776">[1 more]</label></div><br/><div class="children"><div class="content">Might be worth using values&#x2F;copies even a bit bigger, so long as it&#x27;s &quot;simple&quot; data. This[1] short post argues for passing `std::string_view` (~2 pointers) by value, for<p>- Omitting pointer indirections (loads),<p>- Not forcing the pointee to have an address (i.e. gotta be in memory, not just registers), and<p>- Eliminating aliasing questions, potentially leading to better codegen if the function isn&#x27;t inlined.<p>1: <a href="https:&#x2F;&#x2F;quuxplusone.github.io&#x2F;blog&#x2F;2021&#x2F;11&#x2F;09&#x2F;pass-string-view-by-value&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;quuxplusone.github.io&#x2F;blog&#x2F;2021&#x2F;11&#x2F;09&#x2F;pass-string-vi...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="37538864" class="c"><input type="checkbox" id="c-37538864" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538608">parent</a><span>|</span><a href="#37538636">prev</a><span>|</span><a href="#37538809">next</a><span>|</span><label class="collapse" for="c-37538864">[-]</label><label class="expand" for="c-37538864">[1 more]</label></div><br/><div class="children"><div class="content">This is very useful, thanks!</div><br/></div></div></div></div><div id="37538809" class="c"><input type="checkbox" id="c-37538809" checked=""/><div class="controls bullet"><span class="by">BenFrantzDale</span><span>|</span><a href="#37538443">parent</a><span>|</span><a href="#37538608">prev</a><span>|</span><a href="#37538738">next</a><span>|</span><label class="collapse" for="c-37538809">[-]</label><label class="expand" for="c-37538809">[6 more]</label></div><br/><div class="children"><div class="content">For list comprehension, we have (C++23): `std::ranges::to&lt;std::vector&gt;(items | std::views::filter(shouldInclude) | std::views::transform(f))` it’s not quite `[f(x) for x in items if shouldInclude(x)]` but it’s the same idea.</div><br/><div id="37538848" class="c"><input type="checkbox" id="c-37538848" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538809">parent</a><span>|</span><a href="#37539003">next</a><span>|</span><label class="collapse" for="c-37538848">[-]</label><label class="expand" for="c-37538848">[4 more]</label></div><br/><div class="children"><div class="content">To be honest, if that&#x27;s the notation, i will not be very eager to jump on cpp23. That said, I admire people who&#x27;s minds stay open for c++ improvements and make that effort.</div><br/><div id="37539326" class="c"><input type="checkbox" id="c-37539326" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538848">parent</a><span>|</span><a href="#37539003">next</a><span>|</span><label class="collapse" for="c-37539326">[-]</label><label class="expand" for="c-37539326">[3 more]</label></div><br/><div class="children"><div class="content">Well you could write it as<p><pre><code>    to&lt;vector&gt;(items | filter(shouldInclude) | transform(f))
</code></pre>
if you really want to, but generally C++ programmers prefer to be explicit and include the namespaces.</div><br/><div id="37541036" class="c"><input type="checkbox" id="c-37541036" checked=""/><div class="controls bullet"><span class="by">xmonkee</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37539326">parent</a><span>|</span><a href="#37539003">next</a><span>|</span><label class="collapse" for="c-37541036">[-]</label><label class="expand" for="c-37541036">[2 more]</label></div><br/><div class="children"><div class="content">&gt;but generally C++ programmers prefer to be explicit and include the namespaces.<p>why, though? Collisions in the stdlib? stdlib is too new to not be the default for these names?</div><br/><div id="37541574" class="c"><input type="checkbox" id="c-37541574" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37541036">parent</a><span>|</span><a href="#37539003">next</a><span>|</span><label class="collapse" for="c-37541574">[-]</label><label class="expand" for="c-37541574">[1 more]</label></div><br/><div class="children"><div class="content">The using declaration modifies your namespace.<p>From the docs:<p><pre><code>    namespace X
    {
        using ::f;        &#x2F;&#x2F; global f is now visible as ::X::f
        using A::g;       &#x2F;&#x2F; A::g is now visible as ::X::g
    }
 
    void h()
    {
        X::f(); &#x2F;&#x2F; calls ::f
        X::g(); &#x2F;&#x2F; calls A::g
    }
</code></pre>
Link to docs: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;namespace#Using-directives" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;namespace#Using-d...</a></div><br/></div></div></div></div></div></div></div></div><div id="37539003" class="c"><input type="checkbox" id="c-37539003" checked=""/><div class="controls bullet"><span class="by">Tommstein</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538809">parent</a><span>|</span><a href="#37538848">prev</a><span>|</span><a href="#37538738">next</a><span>|</span><label class="collapse" for="c-37539003">[-]</label><label class="expand" for="c-37539003">[1 more]</label></div><br/><div class="children"><div class="content">Sweet baby Jesus I thought that was a joke as I started reading it. Still not entirely sure.</div><br/></div></div></div></div><div id="37538738" class="c"><input type="checkbox" id="c-37538738" checked=""/><div class="controls bullet"><span class="by">halayli</span><span>|</span><a href="#37538443">parent</a><span>|</span><a href="#37538809">prev</a><span>|</span><a href="#37541464">next</a><span>|</span><label class="collapse" for="c-37538738">[-]</label><label class="expand" for="c-37538738">[10 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with std::format?</div><br/><div id="37538916" class="c"><input type="checkbox" id="c-37538916" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538738">parent</a><span>|</span><a href="#37540028">next</a><span>|</span><label class="collapse" for="c-37538916">[-]</label><label class="expand" for="c-37538916">[8 more]</label></div><br/><div class="children"><div class="content">Nothing but<p>(1) notation wise not very different from the old printf which is looked down upon.<p>(2) f&quot;{name}&#x27;s hobby is {hobby} &quot; 
would read like a novel and there a lot less comma seperated arguments.<p>(3) std::format is quite a lot of characters to type for something so ubiquitous.</div><br/><div id="37540165" class="c"><input type="checkbox" id="c-37540165" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538916">parent</a><span>|</span><a href="#37539150">next</a><span>|</span><label class="collapse" for="c-37540165">[-]</label><label class="expand" for="c-37540165">[2 more]</label></div><br/><div class="children"><div class="content">(2) is a point I firmly agree with (though not everyone does), but it’s a hard one.<p>Here’s the way I think about it. I don’t think I’m wrong but I’m absolutely open to being told otherwise.<p>C++ is a language. It has a standard library. The library depends on the language, but the language shouldn’t depend on the library. This is because many applications cannot use the standard library, or parts of it.<p>The conceptual issue with fstrings in C++ is that the formatting is done on a library level. An fstring would be a language feature. It wouldn’t be reasonable for syntax sugar to resolve to a library call.<p>So what we’d need is a way of having parameterised strings that the language knows to separate out into parameters in a function call. For instance:<p>f(f”Hello, {planet}”);<p>would resolve to:<p>f(“Hello, {}”, planet);<p>such that replacing f with std::format, std::print (C++23), fmt::format, fmt::print, spdlog::info, spdlog::error, or even scn::scan (?), would do exactly what you want.<p>However, the expression f”Hello, {planet}” would be meaningless on its own, and care would need to be taken to avoid:<p>std::string x = f”Hello, {planet}”;<p>from resolving to:<p>std::string x = “Hello, {}”, planet;<p>Which would be equivalent to<p>std::string x = planet;<p>Thanks to C++‘s ludicrous comma operator.</div><br/><div id="37542538" class="c"><input type="checkbox" id="c-37542538" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37540165">parent</a><span>|</span><a href="#37539150">next</a><span>|</span><label class="collapse" for="c-37542538">[-]</label><label class="expand" for="c-37542538">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s precedent for that in JavaScript&#x27;s format strings. It also allows for cute ideas, like passing the template to a function that does SQL.</div><br/></div></div></div></div><div id="37539150" class="c"><input type="checkbox" id="c-37539150" checked=""/><div class="controls bullet"><span class="by">f1refly</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538916">parent</a><span>|</span><a href="#37540165">prev</a><span>|</span><a href="#37540028">next</a><span>|</span><label class="collapse" for="c-37539150">[-]</label><label class="expand" for="c-37539150">[5 more]</label></div><br/><div class="children"><div class="content">Typically, you&#x27;d just `using namespace std` on top of you file. Afterwards calls to `format` have the exact same length as `printf`.</div><br/><div id="37539348" class="c"><input type="checkbox" id="c-37539348" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37539150">parent</a><span>|</span><a href="#37539738">next</a><span>|</span><label class="collapse" for="c-37539348">[-]</label><label class="expand" for="c-37539348">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand. I genuinely thought that using using namespace std is considered bad practice because of possible arising conflicts. Also you still need to write the word format (though you could alias it to one character, with same namespace conflict possibilities). Am i pedantic?</div><br/></div></div><div id="37539738" class="c"><input type="checkbox" id="c-37539738" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37539150">parent</a><span>|</span><a href="#37539348">prev</a><span>|</span><a href="#37540077">next</a><span>|</span><label class="collapse" for="c-37539738">[-]</label><label class="expand" for="c-37539738">[1 more]</label></div><br/><div class="children"><div class="content">This is not widely considered a good practice, please don&#x27;t &quot;using namespace std&quot;.</div><br/></div></div><div id="37540077" class="c"><input type="checkbox" id="c-37540077" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37539150">parent</a><span>|</span><a href="#37539738">prev</a><span>|</span><a href="#37539425">next</a><span>|</span><label class="collapse" for="c-37540077">[-]</label><label class="expand" for="c-37540077">[1 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s not recommended but I use it for main().<p>And extensive formatting and&#x2F;or output should be minimised outside main(), imho.</div><br/></div></div><div id="37539425" class="c"><input type="checkbox" id="c-37539425" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37539150">parent</a><span>|</span><a href="#37540077">prev</a><span>|</span><a href="#37540028">next</a><span>|</span><label class="collapse" for="c-37539425">[-]</label><label class="expand" for="c-37539425">[1 more]</label></div><br/><div class="children"><div class="content">This is questionable advice. In header files &#x27;using namespace&#x27; should never be used, in implementation files it opens up some weird edge cases. Instead, do<p><pre><code>   using fmt = std::format
</code></pre>
and then use fmt(...) as the function call.<p>... at least that the current advice AIUI.</div><br/></div></div></div></div></div></div><div id="37540028" class="c"><input type="checkbox" id="c-37540028" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#37538443">root</a><span>|</span><a href="#37538738">parent</a><span>|</span><a href="#37538916">prev</a><span>|</span><a href="#37541464">next</a><span>|</span><label class="collapse" for="c-37540028">[-]</label><label class="expand" for="c-37540028">[1 more]</label></div><br/><div class="children"><div class="content">It does not have enough greater or less signs in the function signature :)</div><br/></div></div></div></div></div></div><div id="37542482" class="c"><input type="checkbox" id="c-37542482" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#37538443">prev</a><span>|</span><a href="#37538132">next</a><span>|</span><label class="collapse" for="c-37542482">[-]</label><label class="expand" for="c-37542482">[2 more]</label></div><br/><div class="children"><div class="content">TIL C++ now has a third builtin way to format strings. Can&#x27;t wait to not use it.</div><br/></div></div><div id="37538132" class="c"><input type="checkbox" id="c-37538132" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37542482">prev</a><span>|</span><a href="#37539929">next</a><span>|</span><label class="collapse" for="c-37538132">[-]</label><label class="expand" for="c-37538132">[9 more]</label></div><br/><div class="children"><div class="content">It seems so trite, especially in 2023, but please don&#x27;t use sprintf. It isn&#x27;t safe in general. (Even snprintf is tricky.)</div><br/><div id="37539264" class="c"><input type="checkbox" id="c-37539264" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#37538132">parent</a><span>|</span><a href="#37538425">next</a><span>|</span><label class="collapse" for="c-37539264">[-]</label><label class="expand" for="c-37539264">[2 more]</label></div><br/><div class="children"><div class="content">There are a lot of use cases where &quot;isn&#x27;t safe&quot; is absolutely irrelevant</div><br/><div id="37540070" class="c"><input type="checkbox" id="c-37540070" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#37538132">root</a><span>|</span><a href="#37539264">parent</a><span>|</span><a href="#37538425">next</a><span>|</span><label class="collapse" for="c-37540070">[-]</label><label class="expand" for="c-37540070">[1 more]</label></div><br/><div class="children"><div class="content">OTOH, in many of the cases where “isn’t safe” IS relevant, the developer believes it isn’t.</div><br/></div></div></div></div><div id="37538425" class="c"><input type="checkbox" id="c-37538425" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37538132">parent</a><span>|</span><a href="#37539264">prev</a><span>|</span><a href="#37538237">next</a><span>|</span><label class="collapse" for="c-37538425">[-]</label><label class="expand" for="c-37538425">[4 more]</label></div><br/><div class="children"><div class="content">saying &quot;dont use&quot; something isn&#x27;t really actionable, unless you give a safe alternative.</div><br/><div id="37539120" class="c"><input type="checkbox" id="c-37539120" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#37538132">root</a><span>|</span><a href="#37538425">parent</a><span>|</span><a href="#37540655">next</a><span>|</span><label class="collapse" for="c-37539120">[-]</label><label class="expand" for="c-37539120">[1 more]</label></div><br/><div class="children"><div class="content">The safe alternatives are in the article.</div><br/></div></div><div id="37540655" class="c"><input type="checkbox" id="c-37540655" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#37538132">root</a><span>|</span><a href="#37538425">parent</a><span>|</span><a href="#37539120">prev</a><span>|</span><a href="#37538905">next</a><span>|</span><label class="collapse" for="c-37540655">[-]</label><label class="expand" for="c-37540655">[1 more]</label></div><br/><div class="children"><div class="content">asprintf is often a better choice if you&#x27;re heap allocating anyway. For a static or stack buffer, obviously snprintf, unless you know the maximum possible length won&#x27;t exceed (which you often do....).</div><br/></div></div><div id="37538905" class="c"><input type="checkbox" id="c-37538905" checked=""/><div class="controls bullet"><span class="by">thiht</span><span>|</span><a href="#37538132">root</a><span>|</span><a href="#37538425">parent</a><span>|</span><a href="#37540655">prev</a><span>|</span><a href="#37538237">next</a><span>|</span><label class="collapse" for="c-37538905">[-]</label><label class="expand" for="c-37538905">[1 more]</label></div><br/><div class="children"><div class="content">And explain why it’s not safe too</div><br/></div></div></div></div><div id="37538315" class="c"><input type="checkbox" id="c-37538315" checked=""/><div class="controls bullet"><span class="by">consoomer</span><span>|</span><a href="#37538132">parent</a><span>|</span><a href="#37538237">prev</a><span>|</span><a href="#37539929">next</a><span>|</span><label class="collapse" for="c-37538315">[-]</label><label class="expand" for="c-37538315">[1 more]</label></div><br/><div class="children"><div class="content">YOLO</div><br/></div></div></div></div><div id="37539929" class="c"><input type="checkbox" id="c-37539929" checked=""/><div class="controls bullet"><span class="by">ruph123</span><span>|</span><a href="#37538132">prev</a><span>|</span><a href="#37538824">next</a><span>|</span><label class="collapse" for="c-37539929">[-]</label><label class="expand" for="c-37539929">[6 more]</label></div><br/><div class="children"><div class="content">Will C++ ever get the possibility to just print the contents of an object like Rust does (with the automatic debug trait)?
I am tired of writing my own print functions for random objects when debugging because the API developers did not bother to override the &lt;&lt;operator. One of those things that are hard to accept when coming back from Rust.</div><br/><div id="37540023" class="c"><input type="checkbox" id="c-37540023" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#37539929">parent</a><span>|</span><a href="#37542285">next</a><span>|</span><label class="collapse" for="c-37540023">[-]</label><label class="expand" for="c-37540023">[2 more]</label></div><br/><div class="children"><div class="content">Not until we get reflection. And reflection efforts seem to be at an impasse, so I don’t imagine we will see it for a few years at least.<p>I will add, though, that I’ve found copilot to be very handy when it comes to generating formatting. Last week I used it while writing fmt::formatter specialisations for a library with 50 structs, some having over 20 members. Writing all of them took about 10 minutes. I dare say the same would hold for operator&lt;&lt; overloads.</div><br/><div id="37541880" class="c"><input type="checkbox" id="c-37541880" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37539929">root</a><span>|</span><a href="#37540023">parent</a><span>|</span><a href="#37542285">next</a><span>|</span><label class="collapse" for="c-37541880">[-]</label><label class="expand" for="c-37541880">[1 more]</label></div><br/><div class="children"><div class="content">Rust does not use reflection for this. Reflection support in rust isn’t actually much better than in C++.</div><br/></div></div></div></div><div id="37542285" class="c"><input type="checkbox" id="c-37542285" checked=""/><div class="controls bullet"><span class="by">shilangyu</span><span>|</span><a href="#37539929">parent</a><span>|</span><a href="#37540023">prev</a><span>|</span><a href="#37540611">next</a><span>|</span><label class="collapse" for="c-37542285">[-]</label><label class="expand" for="c-37542285">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am tired of writing my own print functions for random objects when debugging because the API developers did not bother to override the &lt;&lt;operator.<p>Won&#x27;t you face the same problem in Rust? If the library developer did not derive the Debug trait, you&#x27;re out of luck.</div><br/></div></div><div id="37540611" class="c"><input type="checkbox" id="c-37540611" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#37539929">parent</a><span>|</span><a href="#37542285">prev</a><span>|</span><a href="#37541467">next</a><span>|</span><label class="collapse" for="c-37540611">[-]</label><label class="expand" for="c-37540611">[1 more]</label></div><br/><div class="children"><div class="content">The fact that Rust also has a pretty-print(&quot;{:#}&quot;)[1] a single character away is also really convenient. When you&#x27;re working with JSON or debug printing types it&#x27;s nice to be able to format that without reaching for external tools.<p>[1] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;</a></div><br/></div></div></div></div><div id="37538824" class="c"><input type="checkbox" id="c-37538824" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#37539929">prev</a><span>|</span><label class="collapse" for="c-37538824">[-]</label><label class="expand" for="c-37538824">[1 more]</label></div><br/><div class="children"><div class="content">The C++ STL is so bad in so many ways, it never ceases to amaze me</div><br/></div></div></div></div></div></div></div></body></html>