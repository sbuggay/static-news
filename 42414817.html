<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734512460715" as="style"/><link rel="stylesheet" href="styles.css?v=1734512460715"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.uninformativ.de/blog/postings/2024-12-13/0/POSTING-en.html">A quick look at OS/2&#x27;s builtin virtualization</a>Â <span class="domain">(<a href="https://www.uninformativ.de">www.uninformativ.de</a>)</span></div><div class="subtext"><span>zdw</span> | <span>46 comments</span></div><br/><div><div id="42446742" class="c"><input type="checkbox" id="c-42446742" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#42446572">next</a><span>|</span><label class="collapse" for="c-42446742">[-]</label><label class="expand" for="c-42446742">[2 more]</label></div><br/><div class="children"><div class="content">A neat thing in Warp (I don&#x27;t know if it was also pre-Warp) was that when it booted if it didn&#x27;t have an OS&#x2F;2 driver for the hard disk it would create a v86 task that would take over the state of the BIOS and it would then use BIOS INT 13h calls to access the disk.<p>That meant you could install and use it on a PC with a disk controller that OS&#x2F;2 did not recognize out of the box as long as that controller provided BIOS INT 13h support.</div><br/><div id="42447424" class="c"><input type="checkbox" id="c-42447424" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42446742">parent</a><span>|</span><a href="#42446572">next</a><span>|</span><label class="collapse" for="c-42447424">[-]</label><label class="expand" for="c-42447424">[1 more]</label></div><br/><div class="children"><div class="content">I think 386+ Windows did the same, all through at least Windows 95. I even remember some goose chasing trying to enable the coveted &quot;32 bit disk access&quot; (which IIRC meant using native protected mode Win drivers for disk access) instead of the dreaded legacy disk access that called into the real mode BIOS:<p><a href="https:&#x2F;&#x2F;lh5.googleusercontent.com&#x2F;-EKxolyf8ZJY&#x2F;TePaQskPwCI&#x2F;AAAAAAAABw4&#x2F;RvWvoJVor-o&#x2F;s800&#x2F;diskAcc.jpg" rel="nofollow">https:&#x2F;&#x2F;lh5.googleusercontent.com&#x2F;-EKxolyf8ZJY&#x2F;TePaQskPwCI&#x2F;A...</a></div><br/></div></div></div></div><div id="42446572" class="c"><input type="checkbox" id="c-42446572" checked=""/><div class="controls bullet"><span class="by">bloatfish</span><span>|</span><a href="#42446742">prev</a><span>|</span><a href="#42447288">next</a><span>|</span><label class="collapse" for="c-42446572">[-]</label><label class="expand" for="c-42446572">[4 more]</label></div><br/><div class="children"><div class="content">So OS&#x2F;2 exposes VM86 to the user (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_8086_mode" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_8086_mode</a>) (as does Windows) but also emulates POST booting behaviour from diskettes?</div><br/><div id="42448488" class="c"><input type="checkbox" id="c-42448488" checked=""/><div class="controls bullet"><span class="by">MisterTea</span><span>|</span><a href="#42446572">parent</a><span>|</span><a href="#42447288">next</a><span>|</span><label class="collapse" for="c-42448488">[-]</label><label class="expand" for="c-42448488">[3 more]</label></div><br/><div class="children"><div class="content">I had no idea this was available. Seems like it is also capable of running doom so that means it allows 32 bit mode somehow?</div><br/><div id="42448556" class="c"><input type="checkbox" id="c-42448556" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42446572">root</a><span>|</span><a href="#42448488">parent</a><span>|</span><a href="#42447288">next</a><span>|</span><label class="collapse" for="c-42448556">[-]</label><label class="expand" for="c-42448556">[2 more]</label></div><br/><div class="children"><div class="content">Win95 (and beyond, and somewhat before) DOS boxes also allowed to run DOOM and other protected mode software. But pretty much only if the software was written for &quot;DPMI&quot; (&quot;DOS Protected Mode Interface&quot;)[1], which abstracted all of the protected mode &quot;management&quot; stuff away from the software, like switching into protected mode, allocating memory, etc.<p>If you ran DOOM, you might remember DOS&#x2F;4GW. That was a so called &quot;DOS extender&quot;, and the DPMI &quot;server&quot; when DOOM ran under DOS. When you ran DOOM under Windows, Windows itself became the DPMI server, and DOS&#x2F;4GW acted as a thinner layer.<p>Protected mode software written that way did not run as a v86 task anymore, but closer to a regular Win32 task (it was after all real 32bit software).<p>[1] Or its predecessor VCPI.</div><br/><div id="42448796" class="c"><input type="checkbox" id="c-42448796" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#42446572">root</a><span>|</span><a href="#42448556">parent</a><span>|</span><a href="#42447288">next</a><span>|</span><label class="collapse" for="c-42448796">[-]</label><label class="expand" for="c-42448796">[1 more]</label></div><br/><div class="children"><div class="content">Yes, OS&#x2F;2 had DPMI support starting from version 2.0, already in 1992.</div><br/></div></div></div></div></div></div></div></div><div id="42447288" class="c"><input type="checkbox" id="c-42447288" checked=""/><div class="controls bullet"><span class="by">Grimeton</span><span>|</span><a href="#42446572">prev</a><span>|</span><a href="#42445864">next</a><span>|</span><label class="collapse" for="c-42447288">[-]</label><label class="expand" for="c-42447288">[4 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re mistaking the Windows Subsystems for &quot;virtualization&quot;. Windows has&#x2F;had tons of subsystems beside the today well known WSL.<p>There were MSFU, NTVDM (Dos) or even OS&#x2F;2 subsystems. As Windows NT is based on the ideas and code of OS&#x2F;2 (the chkdsk output is the same till Windows 7 iirc) both OS support the subsystem feature. Printing is its own subsytem btw.<p>This went as far as having the Win32 subsystem available on OS&#x2F;2 and vice versa.<p>These subsystems are small layers that convert between the NT native system and the  software that is run on top of them. The thing you call Windows is just the Win32&#x2F;Win64 &quot;subsystem&quot; running on top of the NT-Kernel.<p>Here a few links I could find regarding this topic. This stuff is ancient and Microsoft doesn&#x27;t make a big fuzz about it, because it&#x27;s one of the core features that allows Microsoft to port Windows quickly to any platform and run software built for any architecture on top of the NT kernel.<p>There are enough &quot;subsystems&quot; out there, like Windows on Windows (WoW64) or even Windows on Arm and so on.<p>This hole is deeeeeeep. I recommend the sysinternals book.<p>[1] - <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;previous-versions&#x2F;&#x2F;cc767964(v=technet.10)?redirectedfrom=MSDN" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;previous-versions&#x2F;&#x2F;cc76796...</a><p>[2] - <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120112001543&#x2F;http:&#x2F;&#x2F;support.microsoft.com&#x2F;kb&#x2F;308259" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120112001543&#x2F;http:&#x2F;&#x2F;support.mi...</a><p>[3] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_DOS_machine" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_DOS_machine</a><p>[4] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;System#Subsystem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;System#Subsystem</a><p>[5] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Services_for_UNIX" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Services_for_UNIX</a></div><br/><div id="42447333" class="c"><input type="checkbox" id="c-42447333" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42447288">parent</a><span>|</span><a href="#42447672">next</a><span>|</span><label class="collapse" for="c-42447333">[-]</label><label class="expand" for="c-42447333">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think they&#x27;re mistaking anything. 386-era Windows and OS&#x2F;2 versions used the CPU&#x27;s v86 task support, which, while having some severe warts[1], can well and truly be called &quot;virtualization&quot;.<p>[1] Most of them fixed with later CPU extensions: <a href="https:&#x2F;&#x2F;www.rcollins.org&#x2F;articles&#x2F;vme1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.rcollins.org&#x2F;articles&#x2F;vme1&#x2F;</a></div><br/></div></div><div id="42447672" class="c"><input type="checkbox" id="c-42447672" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#42447288">parent</a><span>|</span><a href="#42447333">prev</a><span>|</span><a href="#42447339">next</a><span>|</span><label class="collapse" for="c-42447672">[-]</label><label class="expand" for="c-42447672">[1 more]</label></div><br/><div class="children"><div class="content">Win32 or Win16?</div><br/></div></div><div id="42447339" class="c"><input type="checkbox" id="c-42447339" checked=""/><div class="controls bullet"><span class="by">MisterTea</span><span>|</span><a href="#42447288">parent</a><span>|</span><a href="#42447672">prev</a><span>|</span><a href="#42445864">next</a><span>|</span><label class="collapse" for="c-42447339">[-]</label><label class="expand" for="c-42447339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There were MSFU<p>Before SFU there was <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Microsoft_POSIX_subsystem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Microsoft_POSIX_subsystem</a><p>&gt; The thing you call Windows is just the Win32&#x2F;Win64 &quot;subsystem&quot; running on top of the NT-Kernel.<p>Sounds like WINE is an open source Win32&#x2F;64 sub-system for Linux.</div><br/></div></div></div></div><div id="42445864" class="c"><input type="checkbox" id="c-42445864" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#42447288">prev</a><span>|</span><a href="#42445315">next</a><span>|</span><label class="collapse" for="c-42445864">[-]</label><label class="expand" for="c-42445864">[18 more]</label></div><br/><div class="children"><div class="content">If IBM had given OS&#x2F;2 to their mainframe division to develop (and hired someone to design a better GUI, with much better icons - these things matter), I think it could have been a hit. I was using hypervisor stuff on VM&#x2F;CMS in the early 1980s and it worked flawlessly (fun to run a vm inside a vm at the time). Of course, you need the hardware to support it, and IBM were too slow on using the latest Intel chips, and should probably have developed their own.</div><br/><div id="42446389" class="c"><input type="checkbox" id="c-42446389" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42445864">parent</a><span>|</span><a href="#42446738">next</a><span>|</span><label class="collapse" for="c-42446389">[-]</label><label class="expand" for="c-42446389">[4 more]</label></div><br/><div class="children"><div class="content">VM&#x2F;CMS wasn&#x27;t known for its great GUI though. So, the reason OS&#x2F;2 GUI looked bad might actually be because mainframe guys were too involved with its design. OS&#x2F;2 had few remarkable VM&#x2F;CMS characteristics that I could remember, including intricate, hierarchical error codes prefixing every error message like &quot;HPL1001A: File not found&quot;, and favoring upper-case on file names and configuration files.<p>Not to mention that OS&#x2F;2 came with XEDIT and REXX which were cornerstones in VM&#x2F;CMS.</div><br/><div id="42446505" class="c"><input type="checkbox" id="c-42446505" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42446389">parent</a><span>|</span><a href="#42446738">next</a><span>|</span><label class="collapse" for="c-42446505">[-]</label><label class="expand" for="c-42446505">[3 more]</label></div><br/><div class="children"><div class="content">In retrospect OS&#x2F;2 was an OS created for a certain kind of professional user just at the time when the nature of who actually used a computer underwent a fundamental shift.<p>If you were the kind of customer that had a mainframe in the head office, or maybe an AS&#x2F;400 and some terminals, and your IT stack was tightly managed, OS&#x2F;2 would have been quite familiar: Redbooks, prescriptive hardware compatibility, Rexx, manuals with <i>every</i> error code documented, and very IBM-ish approaches to development (eg System Object Model).<p>Sadly for IBM they didnt realize that people wanted an OS that was simple to use and would work well enough on any cheapo PC to get things done without needing a managed IT provider or somesuch.<p>I view NT as Microsoft understanding that while they would never want to be IBM, the Win31&#x2F;Win95 platform was too fragile to be a basis for the future and that they better take on board some of the lessons of OSes like OS&#x2F;2 and UNIX before their market window slammed shut.</div><br/><div id="42448189" class="c"><input type="checkbox" id="c-42448189" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42446505">parent</a><span>|</span><a href="#42446606">next</a><span>|</span><label class="collapse" for="c-42448189">[-]</label><label class="expand" for="c-42448189">[1 more]</label></div><br/><div class="children"><div class="content">Back in the day, large companies would often be &quot;IBM shops,&quot; meaning every piece of technology, from the mainframe to every terminal, every PC, every monitor, every printer was made by IBM, they would run OS&#x2F;2 on the PCs. I worked at such a place for about a year in the ~1993 time frame. The only time non-IBM tech was approved for purchase was if they simply didn&#x27;t offer the item needed.</div><br/></div></div><div id="42446606" class="c"><input type="checkbox" id="c-42446606" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42446505">parent</a><span>|</span><a href="#42448189">prev</a><span>|</span><a href="#42446738">next</a><span>|</span><label class="collapse" for="c-42446606">[-]</label><label class="expand" for="c-42446606">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good observation. Yes, IBM has always seen the money in enterprise and tried to solely focus on that while Microsoft has been able to remain ambivalent successfully. Both Windows 3.1 and Windows for Workgroups 3.11 were great success stories for example.<p>Even PS&#x2F;2 line could be a great consumer product if IBM weren&#x27;t so adamant on making it an enterprise product line.</div><br/></div></div></div></div></div></div><div id="42446738" class="c"><input type="checkbox" id="c-42446738" checked=""/><div class="controls bullet"><span class="by">VincentEvans</span><span>|</span><a href="#42445864">parent</a><span>|</span><a href="#42446389">prev</a><span>|</span><a href="#42448490">next</a><span>|</span><label class="collapse" for="c-42446738">[-]</label><label class="expand" for="c-42446738">[7 more]</label></div><br/><div class="children"><div class="content">OS&#x2F;2 competed against Windows 3.1 - and I donât recall it visually looking at all inferior.</div><br/><div id="42447002" class="c"><input type="checkbox" id="c-42447002" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42446738">parent</a><span>|</span><a href="#42448490">next</a><span>|</span><label class="collapse" for="c-42447002">[-]</label><label class="expand" for="c-42447002">[6 more]</label></div><br/><div class="children"><div class="content">It looked worse than Windows 3.1 IMO.</div><br/><div id="42448352" class="c"><input type="checkbox" id="c-42448352" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42447002">parent</a><span>|</span><a href="#42447307">next</a><span>|</span><label class="collapse" for="c-42448352">[-]</label><label class="expand" for="c-42448352">[3 more]</label></div><br/><div class="children"><div class="content">OS&#x2F;2 looked more modern than Win3.1 because, well, it was newer, but also because of the increased use of &quot;gray 3D slab&quot; style which meant modern at the time (see OSF&#x2F;Motif).<p>But the design language was less uniform in OS&#x2F;2 despite that it was based on Presentation Manager standard like Win3.1. The generous use of colors in OS&#x2F;2 made it look like a kindergarten scrapbook, rather than a serious desktop OS. Maybe, they thought people would find it friendlier that way, and it might have even looked friendlier.<p>Yet, Win95 looked way more professional than OS&#x2F;2 because the design language (fonts, conservative color use in UI elements and more incorporation of gray 3D style in the UI) was simply more elegant. That was mostly because of the influence of NeXTSTEP in the design of Win95 though, so thanks, Steve Jobs, I guess? :)<p>Not to mention completely innovative paradigms in Win95 like &quot;Start&quot; menu and taskbar which made it to 2024 and became the de-facto standard of desktop UX.</div><br/><div id="42448956" class="c"><input type="checkbox" id="c-42448956" checked=""/><div class="controls bullet"><span class="by">giamma</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42448352">parent</a><span>|</span><a href="#42448561">next</a><span>|</span><label class="collapse" for="c-42448956">[-]</label><label class="expand" for="c-42448956">[1 more]</label></div><br/><div class="children"><div class="content">Personally I would choose OS&#x2F;2 over Win3.1 anytime. OS&#x2F;2 was more &quot;Mac like&quot;, for example, properties and preferences dialogs did not have the Apply&#x2F;Cancel buttons, you had a Default button to reset to factory settings or you could simply close the dialog for your changes to be applied.<p>This said, I believe that what made a big difference in look and feel when Windows 95 was released was the introduction of TrueType fonts that had much better rendering. OS&#x2F;2 was using PostScript fonts, and introduced support for TrueType much later... If I remember correctly thanks to the open source efforts of the FreeType project.</div><br/></div></div><div id="42448561" class="c"><input type="checkbox" id="c-42448561" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42448352">parent</a><span>|</span><a href="#42448956">prev</a><span>|</span><a href="#42447307">next</a><span>|</span><label class="collapse" for="c-42448561">[-]</label><label class="expand" for="c-42448561">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The generous use of colors in OS&#x2F;2 made it look like a kindergarten scrapbook<p>Are we still talking about OS&#x2F;2 2.x? I somehow remember it to be more &quot;somber&quot;, and a very quick search seems to confirm that, though it&#x27;s not conclusive.<p><a href="https:&#x2F;&#x2F;www.classic-computers.org.nz&#x2F;blog&#x2F;images&#x2F;2009-10-3-os2.2-screen.jpg" rel="nofollow">https:&#x2F;&#x2F;www.classic-computers.org.nz&#x2F;blog&#x2F;images&#x2F;2009-10-3-o...</a></div><br/></div></div></div></div><div id="42447307" class="c"><input type="checkbox" id="c-42447307" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42447002">parent</a><span>|</span><a href="#42448352">prev</a><span>|</span><a href="#42447379">next</a><span>|</span><label class="collapse" for="c-42447307">[-]</label><label class="expand" for="c-42447307">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, tough call. I remember it looking &quot;more professional&quot;, in some ways even more logical, but overall I&#x27;d say Windows 3 (and yeah, especially 3.1&#x2F;WfW 3.11) was more &quot;pleasing&quot;. That was mostly the color scheme, I think.</div><br/></div></div><div id="42447379" class="c"><input type="checkbox" id="c-42447379" checked=""/><div class="controls bullet"><span class="by">sigzero</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42447002">parent</a><span>|</span><a href="#42447307">prev</a><span>|</span><a href="#42448490">next</a><span>|</span><label class="collapse" for="c-42447379">[-]</label><label class="expand" for="c-42447379">[1 more]</label></div><br/><div class="children"><div class="content">Nah, OS&#x2F;2 was visually better.</div><br/></div></div></div></div></div></div><div id="42448490" class="c"><input type="checkbox" id="c-42448490" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42445864">parent</a><span>|</span><a href="#42446738">prev</a><span>|</span><a href="#42446566">next</a><span>|</span><label class="collapse" for="c-42448490">[-]</label><label class="expand" for="c-42448490">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;support elements&quot; on the mainframe,  which are just a laptop connected to some internal buses and power controls,  did run OS&#x2F;2 for many years.  You could IPL the machine right from the Warp desktop.  It was neat.<p>They also continued VM with VM&#x2F;370, VM&#x2F;ESA and z&#x2F;VM operating systems which are equally rock solid systems.  Aside from these IBM did actually go big on Intel systems but they got completely blindsided by clone manufacturers and entirely failed to see what cloud infrastructure would do to their impressive mainframe lineups.</div><br/></div></div><div id="42446566" class="c"><input type="checkbox" id="c-42446566" checked=""/><div class="controls bullet"><span class="by">russellbeattie</span><span>|</span><a href="#42445864">parent</a><span>|</span><a href="#42448490">prev</a><span>|</span><a href="#42445315">next</a><span>|</span><label class="collapse" for="c-42446566">[-]</label><label class="expand" for="c-42446566">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no universe in which OS&#x2F;2 was a hit. IBM was simply delusional. They wanted OS&#x2F;2 to give them back the monopoly on computing hardware they once had in the early 1980s before the &quot;PC clones&quot; took over the marketplace. That was never going to happen.<p>You can pick from any number of business, technical or marketing decisions - and there are many to choose from - that contributed to its failure, but fundamentally, nothing was going to save OS&#x2F;2 from its original sin.</div><br/><div id="42447299" class="c"><input type="checkbox" id="c-42447299" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42446566">parent</a><span>|</span><a href="#42445315">next</a><span>|</span><label class="collapse" for="c-42447299">[-]</label><label class="expand" for="c-42447299">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really doubt that that&#x27;s true for business or marketing decisions, but what exactly were the technical reasons? I don&#x27;t know too much about OS&#x2F;2 internals, but what made it worse than, say, NT?</div><br/><div id="42449014" class="c"><input type="checkbox" id="c-42449014" checked=""/><div class="controls bullet"><span class="by">giamma</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42447299">parent</a><span>|</span><a href="#42448854">next</a><span>|</span><label class="collapse" for="c-42449014">[-]</label><label class="expand" for="c-42449014">[1 more]</label></div><br/><div class="children"><div class="content">At the time of OS&#x2F;2 vs NT, NT needed a huge amount of ram to work, while OS&#x2F;2, even though more greedy than Windows 3 or Windows 9.5 was still cheaper.<p>The system was very good, stable, snappy. The main issue was the lack of software. Microsoft made deals with all hardware vendors and whenever people bought a personal computer they would find Windows pre-installed. At that time most of the people did not know what an operating system was, they just thought of a PC as an appliance, and most believed that Windows was the only option, that PC=Windows. Plus, computer and software were quite expensive, so why buy another operating system when your new PC comes with Windows for free. There are articles over the internet that claim that Microsoft, to kill OS&#x2F;2, made deals with PC makers (HP, Compaq etc.) giving them OEM Windows licenses for free as long as they did not offer OS&#x2F;2 as an alternative purchase choice to the end users, which basically meant 99% of people did not even know OS&#x2F;2 existed. You would then find OS&#x2F;2 in airports, banks, public transport etc. (all big organizations who were IBM customers) but it was not known by regular users.<p>This said the main weakness of OS&#x2F;2 was the SIQ [1], single-input-queue. The user interface had a single queue for dispatching UI events, and due to a poor design, a single badly written UI program that got stuck while processing a call from the event loop, would freeze the whole OS&#x2F;2 user interface. This was improved in later releases but never completely solved, even though admittedly in the last years of OS&#x2F;2 this type of issues became quite rare.<p>[1] <a href="https:&#x2F;&#x2F;www.os2world.com&#x2F;wiki&#x2F;index.php&#x2F;Databook_for_OS&#x2F;2_%E2%80%93_Chapter_2_%E2%80%93_Inside_OS&#x2F;2_Warp#The_Single_Input_Queue_Dilemma" rel="nofollow">https:&#x2F;&#x2F;www.os2world.com&#x2F;wiki&#x2F;index.php&#x2F;Databook_for_OS&#x2F;2_%E...</a></div><br/></div></div><div id="42448854" class="c"><input type="checkbox" id="c-42448854" checked=""/><div class="controls bullet"><span class="by">fredoralive</span><span>|</span><a href="#42445864">root</a><span>|</span><a href="#42447299">parent</a><span>|</span><a href="#42449014">prev</a><span>|</span><a href="#42448015">next</a><span>|</span><label class="collapse" for="c-42448854">[-]</label><label class="expand" for="c-42448854">[1 more]</label></div><br/><div class="children"><div class="content">It didn&#x27;t really cause issues for end users, but OS&#x2F;2 was tied to x86, it actually uses more than two rings and AIUI even Warp 4 still has 16 bit code in various places. One of the reasons for creating NT back when it was &quot;NT OS&#x2F;2&quot; was as a &quot;Portable OS&#x2F;2&quot; so that the OS didn&#x27;t get left behind when one of the upcoming RISC architectures inevitably destroyed x86 (nobody then would expect a clunky CISC like x86 to be on top 30+ years later, or that the nearest challenging RISC would be the chip from the Acorn Archimedes).</div><br/></div></div></div></div></div></div></div></div><div id="42445315" class="c"><input type="checkbox" id="c-42445315" checked=""/><div class="controls bullet"><span class="by">daitangio</span><span>|</span><a href="#42445864">prev</a><span>|</span><a href="#42447171">next</a><span>|</span><label class="collapse" for="c-42445315">[-]</label><label class="expand" for="c-42445315">[2 more]</label></div><br/><div class="children"><div class="content">Os&#x2F;2 Warp had support for windows 3.x virtualization, so little surpise for me. Also IBM developed virtualizaion tenchnology (like LPAR) long time ago: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Logical_partition" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Logical_partition</a></div><br/><div id="42446122" class="c"><input type="checkbox" id="c-42446122" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42445315">parent</a><span>|</span><a href="#42447171">next</a><span>|</span><label class="collapse" for="c-42446122">[-]</label><label class="expand" for="c-42446122">[1 more]</label></div><br/><div class="children"><div class="content">Yes, one of its marketing highlights were &quot;a single Windows app won&#x27;t crash the whole OS&quot; as that was before Windows 95 came out. IIRC, some Windows apps even ran faster under OS&#x2F;2.</div><br/></div></div></div></div><div id="42447171" class="c"><input type="checkbox" id="c-42447171" checked=""/><div class="controls bullet"><span class="by">sehugg</span><span>|</span><a href="#42445315">prev</a><span>|</span><a href="#42448766">next</a><span>|</span><label class="collapse" for="c-42447171">[-]</label><label class="expand" for="c-42447171">[1 more]</label></div><br/><div class="children"><div class="content">OS&#x2F;2 was pretty boss. I could fuzz test multiple DOS apps while running two Windows 3.1 sessions that communicated over a null modem cable.</div><br/></div></div><div id="42448766" class="c"><input type="checkbox" id="c-42448766" checked=""/><div class="controls bullet"><span class="by">psd1</span><span>|</span><a href="#42447171">prev</a><span>|</span><a href="#42446300">next</a><span>|</span><label class="collapse" for="c-42448766">[-]</label><label class="expand" for="c-42448766">[1 more]</label></div><br/><div class="children"><div class="content">Nihil novum sub solem.<p>Which means, nothing new since Sun was bought out.</div><br/></div></div><div id="42446300" class="c"><input type="checkbox" id="c-42446300" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#42448766">prev</a><span>|</span><a href="#42446816">next</a><span>|</span><label class="collapse" for="c-42446300">[-]</label><label class="expand" for="c-42446300">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Windows 3 also uses virtualization for its DOS boxes, but this is &quot;internal&quot; to Windows. OS&#x2F;2, on the other hand, exposes this entire functionality to the user.<p>What does this mean? It looks wrong. Of course Windows exposes virtualization to users, otherwise they would not be able to run anything on DOS boxes. That&#x27;s the entire point, and that&#x27;s why virtualization is used. Because the difference between a &quot;DOS program&quot; and &quot;real mode operating system&quot; is, due to how such a thin layer DOS is, practically zero. So each DOS box is a full VM emulating everything from VGA to floppy, because your average DOS program is very likely going to access them directly.<p>The same test program happily runs in a Win95 DOS box.. or even a Windows 10 one. This is not a special OS&#x2F;2 feature, it&#x27;s a requirement for running a DOS box.</div><br/><div id="42446502" class="c"><input type="checkbox" id="c-42446502" checked=""/><div class="controls bullet"><span class="by">EgoIncarnate</span><span>|</span><a href="#42446300">parent</a><span>|</span><a href="#42446816">next</a><span>|</span><label class="collapse" for="c-42446502">[-]</label><label class="expand" for="c-42446502">[5 more]</label></div><br/><div class="children"><div class="content">In OS&#x2F;2, you can run any version of DOS, or even multiple different versions at the same time, and I think possibly any real-mode OS that doesn&#x27;t do anything too crazy with the hardware.<p>In Windows, you are limited to the version of DOS that Windows is running on. Windows does not expose the ability to run any other version of DOS or other OS; nor does Windows API expose any of its virtualization functionality that would be useful in doing so.</div><br/><div id="42446926" class="c"><input type="checkbox" id="c-42446926" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#42446300">root</a><span>|</span><a href="#42446502">parent</a><span>|</span><a href="#42446816">next</a><span>|</span><label class="collapse" for="c-42446926">[-]</label><label class="expand" for="c-42446926">[4 more]</label></div><br/><div class="children"><div class="content">And so you can on any other DOS box, including Windows ones. That is, again, a necessary requirement of a DOS box: you have to emulate a full (real mode) PC. Every DOS box is its separate VM, so it couldn&#x27;t care less if you run different versions of DOS on different instances. For example, you can run FreeDOS, and even real mode Windows 3 itself on a 9x DOS box. You can do int13h disk access from a DOS box and completely wreck your disks. This is _required_ by any minimally effective DOS box, otherwise FDISK wouldn&#x27;t work!
Keyboard, mouse, even sound have to be emulated as if they&#x27;re were real devices, too. Otherwise, your fancy &quot;DOS&quot; game (that happens to call practically no DOS interrupts) would not work .<p>As I was saying, there&#x27;s practically no difference between a DOS program and a real mode operating system. How would the VM manager notice you weren&#x27;t running (MS)DOS, much less care?<p>&gt; Windows does not expose the ability to run any other version of DOS or other OS; nor does Windows API expose any of its virtualization functionality that would be useful in doing so.<p>You really do not need _any_ functionality to boot another OS from DOS. It&#x27;s one int 19h away -- or copy the bootloader in memory and jump to it. It&#x27;s a shorter program than the vga.com program used in this article.<p>In fact, the moment you run the author&#x27;s vga.com on a DOS box, even from command.com, you are effectively no longer running DOS: you have already bootstrapped your own non-DOS operating system on a Windows DOS box.<p>If you want to be nitpicky, it&#x27;s likely your &quot;non-DOS&quot; OS has to keep certain DOS structures in the usual places, specially if you want to use e.g. host filesystem level accesses (not full disk), but this will most definitely also be the case for a OS&#x2F;2 DOS box.</div><br/><div id="42447650" class="c"><input type="checkbox" id="c-42447650" checked=""/><div class="controls bullet"><span class="by">EgoIncarnate</span><span>|</span><a href="#42446300">root</a><span>|</span><a href="#42446926">parent</a><span>|</span><a href="#42447217">next</a><span>|</span><label class="collapse" for="c-42447650">[-]</label><label class="expand" for="c-42447650">[1 more]</label></div><br/><div class="children"><div class="content">The context was you asking what the OP meant by &quot;internal&quot; to Windows (&quot;What does this mean?&quot;), not what was technically possible.<p>In OS&#x2F;2 it was a native, natural, advertised capability to run other versions of DOS, including file system access by including a supplied device driver.<p>In Windows, the supported, advertised, native method was to run the version booted from. While it be possible to hack together running under some other version of DOS, it isn&#x27;t what was expected, or exposed in the UI.<p>I believe that&#x27;s what the OP meant by &quot;internal&quot;.</div><br/></div></div><div id="42447217" class="c"><input type="checkbox" id="c-42447217" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42446300">root</a><span>|</span><a href="#42446926">parent</a><span>|</span><a href="#42447650">prev</a><span>|</span><a href="#42448496">next</a><span>|</span><label class="collapse" for="c-42447217">[-]</label><label class="expand" for="c-42447217">[1 more]</label></div><br/><div class="children"><div class="content">As some added context, that is probably[1] true for any Windows version that uses v86 (which implies at least a 386 and enhanced mode windows), not so much for any earlier, non-enhanced Windows, or any Windows running on anything less than a 386.<p>In those, a DOS box is relatively far from a &quot;separate VM&quot;.<p>But the same would apply to OS&#x2F;2.<p>[1] I say &quot;probably&quot; because I haven&#x27;t verified the limitations that Window may apply on its v86 tasks. It&#x27;s at least possible that there&#x27;s some tight integration between the DOS version that Windows is &quot;running on&quot; (which remained a thing for any non-NT-based Windows, including 95,98,me) and the &quot;DOS inside the DOS box&quot;. Which, yes, would limit what software you can run, but then so does for example the need of protected mode DOS software to use DPMI&#x2F;VCPI to be able to run in a DOS box, already. Some games just would not run in DOS boxes, that&#x27;s why you could still boot &quot;DOS mode&quot; in Win95 and later. It&#x27;s also possible that there is tight integration between Windows and the DOS box in other ways that also adds limitations.</div><br/></div></div><div id="42448496" class="c"><input type="checkbox" id="c-42448496" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42446300">root</a><span>|</span><a href="#42446926">parent</a><span>|</span><a href="#42447217">prev</a><span>|</span><a href="#42446816">next</a><span>|</span><label class="collapse" for="c-42448496">[-]</label><label class="expand" for="c-42448496">[1 more]</label></div><br/><div class="children"><div class="content">Prior to the internet vendor included features were significantly more important than they are now.</div><br/></div></div></div></div></div></div></div></div><div id="42446816" class="c"><input type="checkbox" id="c-42446816" checked=""/><div class="controls bullet"><span class="by">csense</span><span>|</span><a href="#42446300">prev</a><span>|</span><a href="#42446079">next</a><span>|</span><label class="collapse" for="c-42446816">[-]</label><label class="expand" for="c-42446816">[6 more]</label></div><br/><div class="children"><div class="content">This all kinda obvious if you&#x27;re familiar with the 386 hardware and early PC history.<p>The OG 8086 was a chip from a different world than what a modern developer is used to (even a modern PC developer).  The 8086 is definitely rooted in the tradition of earlier CPU&#x27;s of the first days of home computing in the 1970&#x27;s.  While it had segments instead of banks, the 8086 was a near-contemporary and near-peer of classical bank-switched 16-bit CPU&#x27;s of the 1970&#x27;s, like the Zilog Z80, Motorola 68000, or MOS 6502.<p>After the IBM PC had already gotten popular, people wanted to bring protected mode OS&#x27;s and software to the PC (especially as these were standard features on the &quot;big boy computers,&quot; i.e. time-shared multiuser systems like mainframes and VAX&#x27;s).  So Intel made the 286 and IBM put it in the PC&#x2F;AT and its successor, the PS&#x2F;2.<p>The 286 suffered from a number of design issues.  It was still 16-bit.  And critically, you couldn&#x27;t easily mix protected mode and real mode.  This meant anyone who wanted to run a fancy new protected-mode OS had to sacrifice their entire existing userspace of DOS software.  Interest in the feature was extremely tepid; most people simply used their 286 as a faster 8086.<p>For the next chip, the 386, Intel learned from those mistakes.  They added all the infrastructure needed to virtualize a complete 16-bit real-mode system (I&#x2F;O ports, memory ranges, interrupts).  The 386 has three operating modes:  Real mode, protected mode, and virtual 8086 mode.  The latter is what they use for DOS emulation in OS&#x2F;2 and Windows 95.<p>The OS&#x2F;2 2.x DOS emulator was pretty amazing technology back in 1992.  Equally amazing is that there was little technical reason it couldn&#x27;t have been released much earlier; the 386 debuted in 1985!<p>It was around this time that OS developers basically decided &quot;Segments were a mistake.  Let&#x27;s just give every process a flat address space and use the MMU to manage memory with pages rather than segments,&quot; a design decision doubtlessly helped along by the fact that the 386 MMU <i>could</i> manage memory with pages rather than segments.  (This was, in hindsight, a solid design decision that has stood the test of time.  C programmers these days have no idea what a far pointer even <i>is</i>, and it&#x27;s probably better that way.)<p>Unfortunately the 386&#x27;s protected mode had its own fatal flaw:  It was only designed with the necessary traps to emulate a real-mode guest.  Hardware support for emulating a protected-mode guest didn&#x27;t appear until well after the turn of the millenium, with Intel Vanderpool and AMD Pacifica.  (Not coincidentally, modern cloud computing and VPS hosting -- which we all take for granted today -- started to appear not long after.  Before this time, &quot;hosting&quot; was understood to mean &quot;rent a whole server&quot; or &quot;rent a UNIX &#x2F; Linux shell account on a shared server.&quot;)</div><br/><div id="42447274" class="c"><input type="checkbox" id="c-42447274" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42446816">parent</a><span>|</span><a href="#42448342">next</a><span>|</span><label class="collapse" for="c-42447274">[-]</label><label class="expand" for="c-42447274">[1 more]</label></div><br/><div class="children"><div class="content">From hands-on experience, I&#x27;ve learned that v86 initially had some severe, ugly warts, which made writing a v86 &quot;hypervisor&quot; way more tedious, and make it run slower, than what seemed reasonable. These limitations were addressed in much later CPUs in the so called &quot;VME&quot; extensions, for which there was apparently quite some drama related to NDAs, and subsequent reverse engineering: <a href="https:&#x2F;&#x2F;www.rcollins.org&#x2F;articles&#x2F;vme1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.rcollins.org&#x2F;articles&#x2F;vme1&#x2F;</a><p>My (long abandoned) toy OS used virtual 8086 to provide &quot;DOS services&quot; support. The idea was that I could focus on the interesting parts of the OS, and outsource everything that I either hadn&#x27;t gotten to yet, or that I didn&#x27;t want to get to, to DOS.<p>That included several devices, the filesystem, an entire shell (command.com isn&#x27;t great, but better than nothing), even networking through packet drivers if needed. The OS was a &quot;modern&quot; and full protected mode true multitasking OS, but one of its task was the DOS instance you started it from, transplanted as a v86 task, and my OS could just call into that (and vice versa, so you could run DOS programs that call into my OS). Initially, even allocating memory would just ask DOS to do the bookkeeping!<p>(I never got to implement VME since I made v86 work on itself, and I dropped this toy project once my work fully shifted to working on real OSes at that level anyway.)</div><br/></div></div><div id="42448342" class="c"><input type="checkbox" id="c-42448342" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42446816">parent</a><span>|</span><a href="#42447274">prev</a><span>|</span><a href="#42446880">next</a><span>|</span><label class="collapse" for="c-42448342">[-]</label><label class="expand" for="c-42448342">[2 more]</label></div><br/><div class="children"><div class="content">Some of this is quite revisionist. Intel didn&#x27;t learn from 8086 mistakes when they designed the 386. They had an order of magnitude more transistors to play with which allowed them to implement features that weren&#x27;t achievable in the 8086 time frame (1976).<p>If they learned from mistakes it was from the iAPX432.<p>Iirc hardware virtualization in x86 CPUs came <i>after</i> VMWare had demonstrated the concept and proven the market, using a software emulation approach.</div><br/><div id="42448579" class="c"><input type="checkbox" id="c-42448579" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42446816">root</a><span>|</span><a href="#42448342">parent</a><span>|</span><a href="#42446880">next</a><span>|</span><label class="collapse" for="c-42448579">[-]</label><label class="expand" for="c-42448579">[1 more]</label></div><br/><div class="children"><div class="content">Hardware virtualization <i>with feature parity</i> came very late. Hardware virtualization limited to real mode VMs came with the 386 itself, as the commenter you replied to mentioned.<p>It was absolutely crucial to its success. The 286&#x27;s protected mode was considered useless, more or less, because it could not coexist with DOS apps (not without severe hacks at least, stuff like resetting the entire CPU into real mode, something earlier OS&#x2F;2 did by the way). Intel learned massively from <i>that</i> mistake and made real mode VMs a first class citizen in the 386, so I don&#x27;t think it&#x27;s fair to say that Intel didn&#x27;t learn anything coming into the 386.<p>Now, as I&#x27;ve mentioned here elsewhere, v86 had some severe warts that made it a bit painful (and that were only corrected in the Pentium and late 486s), but it worked, and it was a cornerstone feature. Which part do you think was revisionist?</div><br/></div></div></div></div><div id="42446880" class="c"><input type="checkbox" id="c-42446880" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42446816">parent</a><span>|</span><a href="#42448342">prev</a><span>|</span><a href="#42447858">next</a><span>|</span><label class="collapse" for="c-42446880">[-]</label><label class="expand" for="c-42446880">[1 more]</label></div><br/><div class="children"><div class="content">Surely 6800 rather than 68000. You can&#x27;t put the 68000 in the same category as the 6502 and 8086! It just isn&#x27;t fast enough!<p>(Also: the 24-bit address bus meant not much need for bank switching. The 16 MB limit wasn&#x27;t a problem until well after 68000 systems had become outdated, or superseded by equivalents based on the (fully 32-bit) 68020 or later.)</div><br/></div></div><div id="42447858" class="c"><input type="checkbox" id="c-42447858" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#42446816">parent</a><span>|</span><a href="#42446880">prev</a><span>|</span><a href="#42446079">next</a><span>|</span><label class="collapse" for="c-42447858">[-]</label><label class="expand" for="c-42447858">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C programmers these days have no idea what a far pointer even is<p>I inherited a C++ project from 1999 or so that still had far pointers for some reason - I had to do some research that day.</div><br/></div></div></div></div><div id="42446079" class="c"><input type="checkbox" id="c-42446079" checked=""/><div class="controls bullet"><span class="by">smm11</span><span>|</span><a href="#42446816">prev</a><span>|</span><label class="collapse" for="c-42446079">[-]</label><label class="expand" for="c-42446079">[1 more]</label></div><br/><div class="children"><div class="content">The OS&#x2F;2 Warp commercials blew my mind in the mid-90s, and they never even once showed the system. I was a Mac person at the time, and would have been all over OS&#x2F;2 if I&#x27;d had the chance. But I was in a very small town, this was the world with a pre-functional-WWW, and it was just impossible to find anything but System 7 and Win 3.1 at the time.<p>Then I saw a NeXT slab and it was all over.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=AZRy-6E1FDQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=AZRy-6E1FDQ</a></div><br/></div></div></div></div></div></div></div></body></html>