<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728291677326" as="style"/><link rel="stylesheet" href="styles.css?v=1728291677326"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arnaud-carre.github.io/2024-10-06-vpternlogd/">AVX Bitwise ternary logic instruction busted</a> <span class="domain">(<a href="https://arnaud-carre.github.io">arnaud-carre.github.io</a>)</span></div><div class="subtext"><span>msephton</span> | <span>55 comments</span></div><br/><div><div id="41760202" class="c"><input type="checkbox" id="c-41760202" checked=""/><div class="controls bullet"><span class="by">mmozeiko</span><span>|</span><a href="#41759410">next</a><span>|</span><label class="collapse" for="c-41760202">[-]</label><label class="expand" for="c-41760202">[4 more]</label></div><br/><div class="children"><div class="content">There is a simple way to get that immediate from expression you want to calculate. For example, if you want to calculate following expression:<p><pre><code>    (NOT A) OR ((NOT B) XOR (C AND A))
</code></pre>
then you simply write<p><pre><code>    ~_MM_TERNLOG_A | (~_MM_TERNLOG_B ^ (_MM_TERNLOG_C &amp; _MM_TERNLOG_A))
</code></pre>
Literally the expression you want to calculate. It evaluates to immediate from _MM_TERNLOG_A&#x2F;B&#x2F;C constants defined in intrinsic headers, at least for gcc &amp; clang:<p><pre><code>    typedef enum {
      _MM_TERNLOG_A = 0xF0,
      _MM_TERNLOG_B = 0xCC,
      _MM_TERNLOG_C = 0xAA
    } _MM_TERNLOG_ENUM;
</code></pre>
For MSVC you define them yourself.</div><br/><div id="41761573" class="c"><input type="checkbox" id="c-41761573" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41760202">parent</a><span>|</span><a href="#41762969">next</a><span>|</span><label class="collapse" for="c-41761573">[-]</label><label class="expand" for="c-41761573">[1 more]</label></div><br/><div class="children"><div class="content">To take the magic away, write it in binary:<p><pre><code>  A = 0b11110000
  B = 0b11001100
  C = 0b10101010</code></pre></div><br/></div></div><div id="41762969" class="c"><input type="checkbox" id="c-41762969" checked=""/><div class="controls bullet"><span class="by">meow_catrix</span><span>|</span><a href="#41760202">parent</a><span>|</span><a href="#41761573">prev</a><span>|</span><a href="#41759410">next</a><span>|</span><label class="collapse" for="c-41762969">[-]</label><label class="expand" for="c-41762969">[2 more]</label></div><br/><div class="children"><div class="content">The Amiga manual suggests normalizing to a conjunctive normal form.</div><br/><div id="41763195" class="c"><input type="checkbox" id="c-41763195" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#41760202">root</a><span>|</span><a href="#41762969">parent</a><span>|</span><a href="#41759410">next</a><span>|</span><label class="collapse" for="c-41763195">[-]</label><label class="expand" for="c-41763195">[1 more]</label></div><br/><div class="children"><div class="content">The constant-math method above doesn&#x27;t require that and works on denormalized expressions, too.<p>That said, the trick for turning four or more argument bitwise operations into a series of vpternlogd operations has yet to be posted</div><br/></div></div></div></div></div></div><div id="41759410" class="c"><input type="checkbox" id="c-41759410" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#41760202">prev</a><span>|</span><a href="#41764007">next</a><span>|</span><label class="collapse" for="c-41759410">[-]</label><label class="expand" for="c-41759410">[5 more]</label></div><br/><div class="children"><div class="content">Oh, I thought the title was saying that the instruction doesn&#x27;t work properly!  (The article actually just explains how it works.)</div><br/><div id="41759447" class="c"><input type="checkbox" id="c-41759447" checked=""/><div class="controls bullet"><span class="by">SomeHacker44</span><span>|</span><a href="#41759410">parent</a><span>|</span><a href="#41764007">next</a><span>|</span><label class="collapse" for="c-41759447">[-]</label><label class="expand" for="c-41759447">[4 more]</label></div><br/><div class="children"><div class="content">Agreed on initial interpretation. Terrible title!</div><br/><div id="41759902" class="c"><input type="checkbox" id="c-41759902" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41759410">root</a><span>|</span><a href="#41759447">parent</a><span>|</span><a href="#41764007">next</a><span>|</span><label class="collapse" for="c-41759902">[-]</label><label class="expand" for="c-41759902">[3 more]</label></div><br/><div class="children"><div class="content">Amusingly, I had a third interpretation, which is &quot;busted&quot; as being too strong. I realized that when the author started talking about the Amiga though that&#x27;s probably not what they meant (as busted is a fairly modern gaming term, I&#x27;d be surprised to see someone as old as to be familiar with Amiga to use it. Sorry to anyone that feels personally attacked by this description :P)</div><br/><div id="41760357" class="c"><input type="checkbox" id="c-41760357" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#41759410">root</a><span>|</span><a href="#41759902">parent</a><span>|</span><a href="#41764007">next</a><span>|</span><label class="collapse" for="c-41760357">[-]</label><label class="expand" for="c-41760357">[2 more]</label></div><br/><div class="children"><div class="content">Is broken not cool enough anymore?</div><br/><div id="41761145" class="c"><input type="checkbox" id="c-41761145" checked=""/><div class="controls bullet"><span class="by">aspenmayer</span><span>|</span><a href="#41759410">root</a><span>|</span><a href="#41760357">parent</a><span>|</span><a href="#41764007">next</a><span>|</span><label class="collapse" for="c-41761145">[-]</label><label class="expand" for="c-41761145">[1 more]</label></div><br/><div class="children"><div class="content">I’ve heard broken and cracked used in this way, usually in a game-mechanics balance context implying something is overpowered, but busted in that same context has a negative connotation to me for some reason, signifying something being underpowered or bugged, if that makes sense. I can’t even tell if this is ironic or unironic at this point.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41764007" class="c"><input type="checkbox" id="c-41764007" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#41759410">prev</a><span>|</span><a href="#41759600">next</a><span>|</span><label class="collapse" for="c-41764007">[-]</label><label class="expand" for="c-41764007">[1 more]</label></div><br/><div class="children"><div class="content">In fact that means that there is a dedicated AVX instruction for Elementary cellular automaton (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Elementary_cellular_automaton" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Elementary_cellular_automaton</a>).</div><br/></div></div><div id="41759600" class="c"><input type="checkbox" id="c-41759600" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#41764007">prev</a><span>|</span><a href="#41760354">next</a><span>|</span><label class="collapse" for="c-41759600">[-]</label><label class="expand" for="c-41759600">[2 more]</label></div><br/><div class="children"><div class="content">My teenage self did not write &quot;CRAP!&quot; on that page of the hardware manual,  but I stared at it for so long trying to figure it out.<p>In the end I did what pretty much everyone else did,  Found the BLTCON0 for Bobs   and straight copies and then pretended I newer saw the thing.<p>I did however get an A+ in computational logic at university years later, so maybe some of the trauma turned out to be beneficial.</div><br/><div id="41763785" class="c"><input type="checkbox" id="c-41763785" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41759600">parent</a><span>|</span><a href="#41760354">next</a><span>|</span><label class="collapse" for="c-41763785">[-]</label><label class="expand" for="c-41763785">[1 more]</label></div><br/><div class="children"><div class="content">Yup. Learned so much from that page in Amiga Hardware Reference Manual!</div><br/></div></div></div></div><div id="41760354" class="c"><input type="checkbox" id="c-41760354" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41759600">prev</a><span>|</span><a href="#41759571">next</a><span>|</span><label class="collapse" for="c-41760354">[-]</label><label class="expand" for="c-41760354">[6 more]</label></div><br/><div class="children"><div class="content">About the title: &quot;Ternary logic&quot; usually means &quot;logic with three truth values&quot;. But this piece covers a compiler instruction which handles all binary logic gates with three inputs.</div><br/><div id="41763933" class="c"><input type="checkbox" id="c-41763933" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#41760354">parent</a><span>|</span><a href="#41760441">next</a><span>|</span><label class="collapse" for="c-41763933">[-]</label><label class="expand" for="c-41763933">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what ternary refers to here.<p>In C, &#x27;+&#x27; is a binary operator because it accepts two inputs. &#x27;?:&#x27; is a ternary operator because it accepts three inputs. It is usually referred to as <i>the</i> ternary operator because it is unique in C, but there&#x27;s nothing fundamental about that.<p>vpternlogd implements all bitwise ternary operators - those operators that accept three inputs.</div><br/></div></div><div id="41760441" class="c"><input type="checkbox" id="c-41760441" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41760354">parent</a><span>|</span><a href="#41763933">prev</a><span>|</span><a href="#41762885">next</a><span>|</span><label class="collapse" for="c-41760441">[-]</label><label class="expand" for="c-41760441">[2 more]</label></div><br/><div class="children"><div class="content">The x86 instruction is named &#x27;ternlog&#x27;, and intrinsic - &#x27;ternarylogic&#x27; though; while perhaps unfortunate, the title is appropriate. (and even then &#x27;bitwise&#x27; already sort of takes place of what &#x27;ternary&#x27;-as-three-valued would, and &#x27;ternary&#x27; is also very often three-input, so much so that &#x27;a ? b : c&#x27; is often called <i>the</i> ternary operator (and in fact ternlog can simulate this ternary operation; and in fact the article is even about exactly that))</div><br/><div id="41761215" class="c"><input type="checkbox" id="c-41761215" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41760354">root</a><span>|</span><a href="#41760441">parent</a><span>|</span><a href="#41762885">next</a><span>|</span><label class="collapse" for="c-41761215">[-]</label><label class="expand" for="c-41761215">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, though the article describes 0xE2, which is &#x27;b ? a : c&#x27;. &#x27;a ? b : c&#x27; would be 0xCA.</div><br/></div></div></div></div><div id="41762885" class="c"><input type="checkbox" id="c-41762885" checked=""/><div class="controls bullet"><span class="by">eapriv</span><span>|</span><a href="#41760354">parent</a><span>|</span><a href="#41760441">prev</a><span>|</span><a href="#41761321">next</a><span>|</span><label class="collapse" for="c-41762885">[-]</label><label class="expand" for="c-41762885">[1 more]</label></div><br/><div class="children"><div class="content">It’s “ternary (logic instruction)”, not “(ternary logic) instruction”.</div><br/></div></div><div id="41761321" class="c"><input type="checkbox" id="c-41761321" checked=""/><div class="controls bullet"><span class="by">someguydave</span><span>|</span><a href="#41760354">parent</a><span>|</span><a href="#41762885">prev</a><span>|</span><a href="#41759571">next</a><span>|</span><label class="collapse" for="c-41761321">[-]</label><label class="expand" for="c-41761321">[1 more]</label></div><br/><div class="children"><div class="content">Agree, I was also confused on this point.  I guess the name “evaluate a three term binary expression” is less snappy though.</div><br/></div></div></div></div><div id="41759571" class="c"><input type="checkbox" id="c-41759571" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#41760354">prev</a><span>|</span><a href="#41763505">next</a><span>|</span><label class="collapse" for="c-41759571">[-]</label><label class="expand" for="c-41759571">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll point out that this is the same way that FPGAs implement arbitrary logic functions, as lookup tables (LUTs).</div><br/><div id="41761487" class="c"><input type="checkbox" id="c-41761487" checked=""/><div class="controls bullet"><span class="by">okanat</span><span>|</span><a href="#41759571">parent</a><span>|</span><a href="#41759713">next</a><span>|</span><label class="collapse" for="c-41761487">[-]</label><label class="expand" for="c-41761487">[1 more]</label></div><br/><div class="children"><div class="content">Basically CPUs, GPUs and FPGAs all converge to the crab equivalent of computation. They all expose the same capability with different areas of optimization.</div><br/></div></div><div id="41759713" class="c"><input type="checkbox" id="c-41759713" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41759571">parent</a><span>|</span><a href="#41761487">prev</a><span>|</span><a href="#41759587">next</a><span>|</span><label class="collapse" for="c-41759713">[-]</label><label class="expand" for="c-41759713">[1 more]</label></div><br/><div class="children"><div class="content">Most but not all. Actel&#x2F;Microsemi use a small tree of muxes and gates.</div><br/></div></div><div id="41759587" class="c"><input type="checkbox" id="c-41759587" checked=""/><div class="controls bullet"><span class="by">tr352</span><span>|</span><a href="#41759571">parent</a><span>|</span><a href="#41759713">prev</a><span>|</span><a href="#41763505">next</a><span>|</span><label class="collapse" for="c-41759587">[-]</label><label class="expand" for="c-41759587">[2 more]</label></div><br/><div class="children"><div class="content">So does the 74181 ALU.</div><br/><div id="41760875" class="c"><input type="checkbox" id="c-41760875" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41759571">root</a><span>|</span><a href="#41759587">parent</a><span>|</span><a href="#41763505">next</a><span>|</span><label class="collapse" for="c-41760875">[-]</label><label class="expand" for="c-41760875">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the 74181 is implemented with a LUT.<p><a href="http:&#x2F;&#x2F;www.righto.com&#x2F;2017&#x2F;01&#x2F;die-photos-and-reverse-engineering.html" rel="nofollow">http:&#x2F;&#x2F;www.righto.com&#x2F;2017&#x2F;01&#x2F;die-photos-and-reverse-enginee...</a></div><br/></div></div></div></div></div></div><div id="41763505" class="c"><input type="checkbox" id="c-41763505" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#41759571">prev</a><span>|</span><a href="#41762349">next</a><span>|</span><label class="collapse" for="c-41763505">[-]</label><label class="expand" for="c-41763505">[1 more]</label></div><br/><div class="children"><div class="content">As someone who fits the description rather too well (although neither my teenage or current self would ever use a marker in the Hardware Reference, omg) this was really nice and satisfying to read.<p>In a weird sense it kind of helped me feel that, yes, I would probably understand stuff better if I tried re-learning the Amiga hardware today and also like I got a bit of it for free already! Is there such a thing as being protected from a nerd snipe? &quot;This article was my nerd trench&quot; ... or something. Thanks! :)</div><br/></div></div><div id="41762349" class="c"><input type="checkbox" id="c-41762349" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#41763505">prev</a><span>|</span><a href="#41763356">next</a><span>|</span><label class="collapse" for="c-41762349">[-]</label><label class="expand" for="c-41762349">[1 more]</label></div><br/><div class="children"><div class="content">Re the choice of function &quot;E2&quot; for the example in the docs: it&#x27;s sort of the most basic, canonical boolean function on 3 inputs, named mux: A if B else C. It&#x27;s universal -- you don&#x27;t need to be an Amiga fan to pick it (though for all I know they might&#x27;ve been).</div><br/></div></div><div id="41763356" class="c"><input type="checkbox" id="c-41763356" checked=""/><div class="controls bullet"><span class="by">worstspotgain</span><span>|</span><a href="#41762349">prev</a><span>|</span><a href="#41760922">next</a><span>|</span><label class="collapse" for="c-41763356">[-]</label><label class="expand" for="c-41763356">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice that they&#x27;re finally starting to &quot;compress&quot; the instruction space.<p>To take a related concept further, it would be nice if there were totally unportable, chip-superspecific ways of feeding uops directly, particularly with raw access to the unrenamed register file.<p>Say you have an inner loop, and a chip is popular. Let your compiler take a swing at it. If it&#x27;s way faster than the ISA translation, add a special case to the fat binary for a single function.<p>Alas, it will probably never happen due to security, integrity, and testing costs.</div><br/><div id="41763396" class="c"><input type="checkbox" id="c-41763396" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#41763356">parent</a><span>|</span><a href="#41760922">next</a><span>|</span><label class="collapse" for="c-41763396">[-]</label><label class="expand" for="c-41763396">[2 more]</label></div><br/><div class="children"><div class="content">Is it only security which stands in the way of compilers devising their own instructions. Certain architectures potentially would allow this, and most of the chips, even MCUs as ESP32 (which run RISC-V-like LX7 cores), have microcode. It is apparent what the gains can be, what is the typical show stopper - security or proprietary microcode lang?</div><br/><div id="41763475" class="c"><input type="checkbox" id="c-41763475" checked=""/><div class="controls bullet"><span class="by">worstspotgain</span><span>|</span><a href="#41763356">root</a><span>|</span><a href="#41763396">parent</a><span>|</span><a href="#41760922">next</a><span>|</span><label class="collapse" for="c-41763475">[-]</label><label class="expand" for="c-41763475">[1 more]</label></div><br/><div class="children"><div class="content">The uops aren&#x27;t smart or terribly proprietary IIRC. Aside from security&#x2F;integrity&#x2F;testing, the documentation would have to be automated, and releasing it early might tip off competitors to some stuff. I don&#x27;t think you&#x27;d even need to roll your own ISA, you&#x27;d just issue uops as a native ultra-low-level ISA.<p>One issue (without further architectural help) is that you&#x27;d save and restore every register you touch, which is fine for an inner loop that&#x27;s consequential enough. Another obstacle is any hardware that&#x27;s shared among cores, such as memory coherency.<p>In general, moving super-ad-hoc memory management into the compiler would suck for the compiler writers. Maybe some of your compiler can be a LLM?<p>If performance is key, I would totally deploy this if I have faith in my tests - and maybe a way for the user to turn it off just in case.</div><br/></div></div></div></div></div></div><div id="41760922" class="c"><input type="checkbox" id="c-41760922" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#41763356">prev</a><span>|</span><a href="#41760600">next</a><span>|</span><label class="collapse" for="c-41760922">[-]</label><label class="expand" for="c-41760922">[1 more]</label></div><br/><div class="children"><div class="content">Another example of packing bitwise ops into an integer is win32&#x27;s GDI ROP codes: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;gdi&#x2F;ternary-raster-operations" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;gdi&#x2F;ternary-...</a></div><br/></div></div><div id="41760600" class="c"><input type="checkbox" id="c-41760600" checked=""/><div class="controls bullet"><span class="by">leogao</span><span>|</span><a href="#41760922">prev</a><span>|</span><a href="#41761717">next</a><span>|</span><label class="collapse" for="c-41760600">[-]</label><label class="expand" for="c-41760600">[1 more]</label></div><br/><div class="children"><div class="content">Nvidia SASS has a similar instruction too (LOP3.LUT)</div><br/></div></div><div id="41761717" class="c"><input type="checkbox" id="c-41761717" checked=""/><div class="controls bullet"><span class="by">anon2024user</span><span>|</span><a href="#41760600">prev</a><span>|</span><a href="#41763207">next</a><span>|</span><label class="collapse" for="c-41761717">[-]</label><label class="expand" for="c-41761717">[1 more]</label></div><br/><div class="children"><div class="content">Head over to <a href="https:&#x2F;&#x2F;www.sandpile.org" rel="nofollow">https:&#x2F;&#x2F;www.sandpile.org</a>, and find VPTERNLOG on
the 3-byte opcode page <a href="https:&#x2F;&#x2F;www.sandpile.org&#x2F;x86&#x2F;opc_3.htm" rel="nofollow">https:&#x2F;&#x2F;www.sandpile.org&#x2F;x86&#x2F;opc_3.htm</a>
and you will not only see Intel&#x27;s apparent past plan for the
variants with byte and word masking (AVX512BITALG2), but also
the links from the Ib operand to the ternary logic table page
<a href="https:&#x2F;&#x2F;www.sandpile.org&#x2F;x86&#x2F;ternlog.htm" rel="nofollow">https:&#x2F;&#x2F;www.sandpile.org&#x2F;x86&#x2F;ternlog.htm</a> with all 256 cases.</div><br/></div></div><div id="41763207" class="c"><input type="checkbox" id="c-41763207" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#41761717">prev</a><span>|</span><a href="#41759943">next</a><span>|</span><label class="collapse" for="c-41763207">[-]</label><label class="expand" for="c-41763207">[1 more]</label></div><br/><div class="children"><div class="content">If you want to calculate the minterms why don&#x27;t you just get a K-Map?</div><br/></div></div><div id="41759943" class="c"><input type="checkbox" id="c-41759943" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#41763207">prev</a><span>|</span><a href="#41761419">next</a><span>|</span><label class="collapse" for="c-41759943">[-]</label><label class="expand" for="c-41759943">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t have the official Amiga hardware manual, but instead the book &quot;Mapping the Amiga&quot;. It said the same thing in a slight more verbose way. I don&#x27;t remember which minterms I used back then but I <i>think</i> I managed to work things out from this book to do shadebobs, bobs, XOR 3D line drawing and other things.<p>The page in Mapping the Amiga: <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;1993-thomson-randy-rhett-anderson&#x2F;page&#x2F;492&#x2F;mode&#x2F;2up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;1993-thomson-randy-rhett-anderso...</a></div><br/></div></div><div id="41761419" class="c"><input type="checkbox" id="c-41761419" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#41759943">prev</a><span>|</span><a href="#41762402">next</a><span>|</span><label class="collapse" for="c-41761419">[-]</label><label class="expand" for="c-41761419">[5 more]</label></div><br/><div class="children"><div class="content">This is an instruction I would like to implement in RISC-V if it isn&#x27;t already, (which yeah, I know, isn&#x27;t very RISC like)<p><pre><code>   movei (%r1),(%r2),(%r3),value
</code></pre>
Move the contents of memory pointed to by r1, to the contents of memory pointed to by r2, applying the boolean operator &lt;value&gt;, with the memory pointed to by r3. Then increment all three registers by 4 to point to the next word. There was something similar to this in the Intel 82786 graphics chip which had a sort of minimal cpu part that could run simple &quot;programs&quot;.<p>And yeah, I really enjoyed the blitter on the Amiga. It was a really cool bit of hardware.</div><br/><div id="41762441" class="c"><input type="checkbox" id="c-41762441" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41761419">parent</a><span>|</span><a href="#41762402">next</a><span>|</span><label class="collapse" for="c-41762441">[-]</label><label class="expand" for="c-41762441">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the value (no pun intended) of such an instruction if &quot;value&quot; is an immediate and not register-based?<p>If it&#x27;s an immediate then the compiler (human or machine) knows what the operation will be, so could just write that instead?</div><br/><div id="41763041" class="c"><input type="checkbox" id="c-41763041" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#41761419">root</a><span>|</span><a href="#41762441">parent</a><span>|</span><a href="#41762402">next</a><span>|</span><label class="collapse" for="c-41763041">[-]</label><label class="expand" for="c-41763041">[3 more]</label></div><br/><div class="children"><div class="content">The value is that a two instruction pipeline can do a blit at cache speed.</div><br/><div id="41763196" class="c"><input type="checkbox" id="c-41763196" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41761419">root</a><span>|</span><a href="#41763041">parent</a><span>|</span><a href="#41763308">next</a><span>|</span><label class="collapse" for="c-41763196">[-]</label><label class="expand" for="c-41763196">[1 more]</label></div><br/><div class="children"><div class="content">I totally get why you&#x27;d want mem-to-mem instructions, it just seemed more interesting in a blitting context (and others) to have the operation not be static but rather register-based. But perhaps in practice it matters not, been a <i>long</i> time since I wrote blitting code.<p>RISC-V already has what you want in terms of R-type instructions[1], ie &quot;dest = src1 op src2&quot; where &quot;op&quot; is effectively an immediate value, but being based on a load-store architecture it&#x27;s only register-to-register of course.<p>Though I suppose ISA-wise there&#x27;s nothing in the way of making an extension that introduces &quot;M-type instructions&quot; which act like the R-type instructions but are mem-to-mem instead. How much that messes with everything else I have no idea.<p>edit: ah, forgot about you wanting it to behave like movsb. Still, something that could be handled by the extension instruction.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-isa-manual&#x2F;releases&#x2F;download&#x2F;riscv-isa-release-1569c8d-2024-10-03&#x2F;riscv-unprivileged.pdf">https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-isa-manual&#x2F;releases&#x2F;download&#x2F;...</a> (section 2.4.2)</div><br/></div></div><div id="41763308" class="c"><input type="checkbox" id="c-41763308" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41761419">root</a><span>|</span><a href="#41763041">parent</a><span>|</span><a href="#41763196">prev</a><span>|</span><a href="#41762402">next</a><span>|</span><label class="collapse" for="c-41763308">[-]</label><label class="expand" for="c-41763308">[1 more]</label></div><br/><div class="children"><div class="content">But the “two instruction” part isn’t important there on most risc-v hardware, is it? That “memory to memory” instruction still routes the data through the CPU, so what does replacing a load instruction and a store instruction by a more complex but probably&#x2F;likely slightly shorter load-store instruction bring if your CPU is much faster than your memory?</div><br/></div></div></div></div></div></div></div></div><div id="41762402" class="c"><input type="checkbox" id="c-41762402" checked=""/><div class="controls bullet"><span class="by">ggerules</span><span>|</span><a href="#41761419">prev</a><span>|</span><a href="#41760514">next</a><span>|</span><label class="collapse" for="c-41762402">[-]</label><label class="expand" for="c-41762402">[1 more]</label></div><br/><div class="children"><div class="content">It looks like someone paid attention in their undergraduate Discrete Math class.</div><br/></div></div><div id="41760514" class="c"><input type="checkbox" id="c-41760514" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#41762402">prev</a><span>|</span><a href="#41760172">next</a><span>|</span><label class="collapse" for="c-41760514">[-]</label><label class="expand" for="c-41760514">[3 more]</label></div><br/><div class="children"><div class="content">Do compilers actually output this instruction?<p>So many super-clever instructions are next to impossible for compilers to automatically use.</div><br/><div id="41762592" class="c"><input type="checkbox" id="c-41762592" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41760514">parent</a><span>|</span><a href="#41763199">next</a><span>|</span><label class="collapse" for="c-41762592">[-]</label><label class="expand" for="c-41762592">[1 more]</label></div><br/><div class="children"><div class="content">This instruction at least is very trivial to emit - any sequence of bitwise logic ops over three inputs compiles to one ternlog always. This isn&#x27;t at all a super-clever instruction, it&#x27;s more a super-boring one. If anything, it simplifies codegen compared to having to emit a varying amount of instructions for three-operand logic, having to find the best one.</div><br/></div></div><div id="41763199" class="c"><input type="checkbox" id="c-41763199" checked=""/><div class="controls bullet"><span class="by">icelusxl</span><span>|</span><a href="#41760514">parent</a><span>|</span><a href="#41762592">prev</a><span>|</span><a href="#41760172">next</a><span>|</span><label class="collapse" for="c-41763199">[-]</label><label class="expand" for="c-41763199">[1 more]</label></div><br/><div class="children"><div class="content">Also supported in .NET 9<p>* <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvements-in-net-9&#x2F;#avx512" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvemen...</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;pull&#x2F;91227">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;pull&#x2F;91227</a></div><br/></div></div></div></div><div id="41760347" class="c"><input type="checkbox" id="c-41760347" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#41760172">prev</a><span>|</span><a href="#41759483">next</a><span>|</span><label class="collapse" for="c-41760347">[-]</label><label class="expand" for="c-41760347">[3 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t every Boolean operation be &quot;busted&quot; as a lookup table?</div><br/><div id="41760628" class="c"><input type="checkbox" id="c-41760628" checked=""/><div class="controls bullet"><span class="by">ekimekim</span><span>|</span><a href="#41760347">parent</a><span>|</span><a href="#41762008">next</a><span>|</span><label class="collapse" for="c-41760628">[-]</label><label class="expand" for="c-41760628">[1 more]</label></div><br/><div class="children"><div class="content">Yes! But your lookup table will need 2^N bits for a function with N inputs. In this way you can easily enumerate all possible functions from N bits to 1 bit.<p>As a fun exercise, you can do this for all 2-bit -&gt; 1-bit functions. There&#x27;s only 16 of them, and most of them have very well known names like &quot;and&quot; (LUT 1000) or &quot;xor&quot; (LUT 0110). Some of them don&#x27;t depend on some of the inputs (eg. LUT 1100 &#x2F; 1010 which is &quot;return A&quot; and &quot;return B&quot; respectively) or even any of them (eg. LUT 0000 which always returns 0).</div><br/></div></div><div id="41762008" class="c"><input type="checkbox" id="c-41762008" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#41760347">parent</a><span>|</span><a href="#41760628">prev</a><span>|</span><a href="#41759483">next</a><span>|</span><label class="collapse" for="c-41762008">[-]</label><label class="expand" for="c-41762008">[1 more]</label></div><br/><div class="children"><div class="content">The epiphany for me was that any boolean logic can be replaced by memory.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=BA12Z7gQ4P0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=BA12Z7gQ4P0</a> (ben eater)<p>I mean it is obvious in retrospect, sort of along the lines of memoizing a function. but it was mind blowing when I first saw that.<p>Not that at the hardware level memory is actually any simpler than whatever boolean logic it is pretending to be, but it feels simpler and is easily available in large quantities.</div><br/></div></div></div></div><div id="41759483" class="c"><input type="checkbox" id="c-41759483" checked=""/><div class="controls bullet"><span class="by">486sx33</span><span>|</span><a href="#41760347">prev</a><span>|</span><a href="#41761268">next</a><span>|</span><label class="collapse" for="c-41759483">[-]</label><label class="expand" for="c-41759483">[1 more]</label></div><br/><div class="children"><div class="content">it’s fundamentally just a lookup table</div><br/></div></div><div id="41761268" class="c"><input type="checkbox" id="c-41761268" checked=""/><div class="controls bullet"><span class="by">hvenev</span><span>|</span><a href="#41759483">prev</a><span>|</span><a href="#41760498">next</a><span>|</span><label class="collapse" for="c-41761268">[-]</label><label class="expand" for="c-41761268">[4 more]</label></div><br/><div class="children"><div class="content">&gt; an obscure instruction<p>Come on, vpternlog* is not obscure. It subsumes _all_ bitwise instructions, even loading the constant (-1) into a register.</div><br/><div id="41761687" class="c"><input type="checkbox" id="c-41761687" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41761268">parent</a><span>|</span><a href="#41760498">next</a><span>|</span><label class="collapse" for="c-41761687">[-]</label><label class="expand" for="c-41761687">[3 more]</label></div><br/><div class="children"><div class="content">Not if, like most people, you still aren&#x27;t using a CPU with AVX-512 support. And I don&#x27;t recall ever seeing it in compiler output in any case. It&#x27;s not like boolean operations on three variables occur very frequently in most programs, especially (EDIT: this last part apparently isn&#x27;t the case) not operations that can&#x27;t be decomposed into a pair of two-variable operations with no worse performance.</div><br/><div id="41761754" class="c"><input type="checkbox" id="c-41761754" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41761268">root</a><span>|</span><a href="#41761687">parent</a><span>|</span><a href="#41760498">next</a><span>|</span><label class="collapse" for="c-41761754">[-]</label><label class="expand" for="c-41761754">[2 more]</label></div><br/><div class="children"><div class="content">As far as everything on uops.info goes, ternlog has the same throughput and latency as the two-operand logic instructions everywhere (with the mild exception of Zen 4 where it goes from 0.50 to 0.56 cycles&#x2F;instr; which also shows as having 2-cycle latency to one operand but I think that might be measurement error), so it&#x27;s always bad to decompose ternlog into two two-operand logic ops.</div><br/></div></div></div></div></div></div><div id="41760498" class="c"><input type="checkbox" id="c-41760498" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#41761268">prev</a><span>|</span><a href="#41760147">next</a><span>|</span><label class="collapse" for="c-41760498">[-]</label><label class="expand" for="c-41760498">[1 more]</label></div><br/><div class="children"><div class="content">Great little article! Thank you.</div><br/></div></div></div></div></div></div></div></body></html>