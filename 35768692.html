<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1682931674111" as="style"/><link rel="stylesheet" href="styles.css?v=1682931674111"/><link rel="apple-touch-startup-image" href="https://png.pngtree.com/png-clipart/20210309/original/pngtree-a-squatting-tabby-cat-png-image_5803660.jpg"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://soasis.org/posts/a-mirror-for-rust-a-plan-for-generic-compile-time-introspection-in-rust/">A Mirror for Rust: Compile-Time Reflection Report</a>Â <span class="domain">(<a href="https://soasis.org">soasis.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>7 comments</span></div><br/><div><div id="35770307" class="c"><input type="checkbox" id="c-35770307" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#35770402">next</a><span>|</span><label class="collapse" for="c-35770307">[-]</label><label class="expand" for="c-35770307">[1 more]</label></div><br/><div class="children"><div class="content">Complicated, a bit reminiscent of the C++ reflection ideas. I wonder if there are some design decisions in the front end that make reflection awkward to implement. The general case of deriving code from other code implies an iterative fixpoint in the front end which might otherwise be built as a linear sequence.<p>Similar to the comment from duped, reflection is not a clear win. In particular, optimisation is essentially changing programs in non-observable fashion into equivalent programs.<p>Exposing more information about the program is in conflict with that goal. You either have to avoid changing things, which usually implies slower codegen, or do both the program transform and maintain what it used to look like to satisfy the reflection API which is confusing and error prone.</div><br/></div></div><div id="35769018" class="c"><input type="checkbox" id="c-35769018" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#35770402">prev</a><span>|</span><label class="collapse" for="c-35769018">[-]</label><label class="expand" for="c-35769018">[4 more]</label></div><br/><div class="children"><div class="content">I take issue with the motivating example.<p><pre><code>    pub struct Point {
      pub x: i32,
      pub y: i32,
    }
</code></pre>
I take it that the authors would wish it to be possible for the consumers of the crate that defines this struct to also be consumers of `serde` and allow it to be serializable, even though the authors of `Point` have not marked the struct `#[derive(Serialize, Deserialize)]`.<p>This is not a good thing, because it means that consumers of `Point` have observable behavior not intended by the authors of `Point` and makes it possible for previously unbreaking changes to become breaking. For example, say `Point` now has state that gets cached:<p><pre><code>    pub struct Point&lt;&#x27;a&gt; {
      pub x: i32,
      pub y: i32,
      cache: &amp;&#x27;a Cache, &#x2F;&#x2F; where cache is not serializable or observable
    }
</code></pre>
Under the current regime this is not a breaking change because the authors do not intend `Point` to be serializable and do not want its consumers to serialize it directly. Under the design of the authors it would be possible for other code to make bad assumptions about its inputs. This is perhaps a weak example, but say `Cache` contained functions or other non-serializable data. Now the versioning of the crate containing `Point` is meaningless.<p>The point is: `#[derive(Serialize, Deserialize)` is a <i>good</i> thing: it is not boilerplate. It is annotating the contract the code has with its consumers, and adding or removing from it is potentially a breaking change.<p>---<p>Reading a bit further: you need to expand on the reason the Orphan Rule is a Problem That Has To Be Solved.<p>While it&#x27;s true that the resulting headaches are because of a conservative choice, the reason that we need to deal with it is because without such a constraint, future code may lead to ambiguity that cannot be resolved by the compiler or by a programmer. I don&#x27;t see any reasoning in this post about how reflection would mitigate the same problem:<p>How do you prevent reflection from creating ambiguity in type&#x2F;method resolution and avoid inadvertent breaking changes in the ecosystem?<p>Because the Coherence problem is the actual Problem To Be Solved.<p>---<p>There are a lot of interesting applications of compile-time introspection on code, and I&#x27;ve had the experience of writing a lot of metaprogramming with it (and runtime introspection!).<p>The problem is that this is mostly an anti feature, because you do <i>not</i> want to have to evaluate code to understand code. It makes programs harder to reason about and fundamentally more buggy. In a language designed around explicitness and correctness like Rust, the proposal is naturally going to meet deaf ears. This belongs in a LISP dialect more than Rust, imho (as one who loves both!)</div><br/><div id="35769188" class="c"><input type="checkbox" id="c-35769188" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#35769018">parent</a><span>|</span><a href="#35769061">next</a><span>|</span><label class="collapse" for="c-35769188">[-]</label><label class="expand" for="c-35769188">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Under the current regime this is not a breaking change<p>It is. It would not be if the original `Point` definition was annotated with the `#[non_exhaustive]` attribute.<p>Or actually, that still wouldn&#x27;t be enough, because the new definition introduces a lifetime parameter. You could call the new definition `struct NewPoint` and introduce a `type Point = NewPoint&lt;&#x27;static&gt;` alias to preserve backward compatibility.</div><br/></div></div><div id="35769061" class="c"><input type="checkbox" id="c-35769061" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#35769018">parent</a><span>|</span><a href="#35769188">prev</a><span>|</span><label class="collapse" for="c-35769061">[-]</label><label class="expand" for="c-35769061">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Under the current regime this is not a breaking change because the authors do not intend `Point` to be serializable and do not want its consumers to serialize it directly.<p>Does your example not show a breaking change? With the old version, all fields are public, so users can construct Point values themselves, and fully deconstruct them with pattern matching. With the new version, the struct has a private field, so users cannot construct Point values directly. (Also, it has an extra lifetime parameter which users must specify!)<p>That is to say, the authors do not intend to allow access to private fields (they say that repeatedly), so something that wouldn&#x27;t ordinarily be a breaking change would not become a breaking change in the presence of this feature. Any additional behavior defined by consumers must be built on top of the provider&#x27;s contract. In this case, either the additional serialization behavior would have to require all fields to be public, or it would have to ignore any private fields. And additional deserialization behavior would similarly have to either require that all fields are public or only allow filling values into existing structs.</div><br/></div></div></div></div></div></div></div></div></div></body></html>