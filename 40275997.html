<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715072455713" as="style"/><link rel="stylesheet" href="styles.css?v=1715072455713"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://andersmurphy.com/2024/05/06/clojure-managing-throughput-with-virtual-threads.html">Clojure: Managing throughput with virtual threads</a> <span class="domain">(<a href="https://andersmurphy.com">andersmurphy.com</a>)</span></div><div class="subtext"><span>refset</span> | <span>10 comments</span></div><br/><div><div id="40278736" class="c"><input type="checkbox" id="c-40278736" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#40276030">next</a><span>|</span><label class="collapse" for="c-40278736">[-]</label><label class="expand" for="c-40278736">[2 more]</label></div><br/><div class="children"><div class="content">Pretty cool use case for virtual threads. Recently I implemented something with core.async in order to batch messages and dispatch them to some UI code at a fixed rate. It was definitely a lot more complicated than using a single sempahore like shown in this article.<p>On a related note, it would be nice to have an implementation of CSP using proper virtual threads rather than the thread pool currently used by core.async. The promesa library currently has a proof-of-concept[1], but it doesn&#x27;t seem interoperable with existing core.async code.<p>[1] <a href="https:&#x2F;&#x2F;funcool.github.io&#x2F;promesa&#x2F;latest&#x2F;promesa.exec.csp.html" rel="nofollow">https:&#x2F;&#x2F;funcool.github.io&#x2F;promesa&#x2F;latest&#x2F;promesa.exec.csp.ht...</a></div><br/><div id="40283458" class="c"><input type="checkbox" id="c-40283458" checked=""/><div class="controls bullet"><span class="by">andersmurphy</span><span>|</span><a href="#40278736">parent</a><span>|</span><a href="#40276030">next</a><span>|</span><label class="collapse" for="c-40283458">[-]</label><label class="expand" for="c-40283458">[1 more]</label></div><br/><div class="children"><div class="content">(author here) Virtual threads being &quot;free&quot; definitely makes things simpler to implement, I was actually quite surprised.<p>Where I think things would get more complicated is if you wanted to control how bursty the token bucket is. You&#x27;d probably need another semaphore to limit the bursts etc.<p>This implementation is naive and does create a virtual thread for each permit that is waiting, so you have 2x the number of threads as you would have with a more complex implementation (i.e 1 per running task and 1 per waiting permit). This would be a no go with regular threads, but seems to work fine with virtual threads. It&#x27;s pretty cool that virtual threads make naive implementations work.</div><br/></div></div></div></div><div id="40276030" class="c"><input type="checkbox" id="c-40276030" checked=""/><div class="controls bullet"><span class="by">harperlee</span><span>|</span><a href="#40278736">prev</a><span>|</span><a href="#40282238">next</a><span>|</span><label class="collapse" for="c-40276030">[-]</label><label class="expand" for="c-40276030">[2 more]</label></div><br/><div class="children"><div class="content">One related article that I found interesting: <a href="https:&#x2F;&#x2F;ericnormand.me&#x2F;guide&#x2F;clojure-virtual-threads" rel="nofollow">https:&#x2F;&#x2F;ericnormand.me&#x2F;guide&#x2F;clojure-virtual-threads</a></div><br/><div id="40283472" class="c"><input type="checkbox" id="c-40283472" checked=""/><div class="controls bullet"><span class="by">andersmurphy</span><span>|</span><a href="#40276030">parent</a><span>|</span><a href="#40282238">next</a><span>|</span><label class="collapse" for="c-40283472">[-]</label><label class="expand" for="c-40283472">[1 more]</label></div><br/><div class="children"><div class="content">I mention that article at the bottom of the blog post. It&#x27;s a really good overview!</div><br/></div></div></div></div><div id="40282238" class="c"><input type="checkbox" id="c-40282238" checked=""/><div class="controls bullet"><span class="by">amgreg</span><span>|</span><a href="#40276030">prev</a><span>|</span><a href="#40281039">next</a><span>|</span><label class="collapse" for="c-40282238">[-]</label><label class="expand" for="c-40282238">[2 more]</label></div><br/><div class="children"><div class="content">&gt; things get complicated with virtual threads, they shouldn&#x27;t be pooled, as they aren&#x27;t a scarce resource<p>Why not pool virtual threads, though?  I get that they’re not scarce, but if you’re looking to limit throughput anyway wouldn’t that be easier to achieve using a thread pool than semaphores?</div><br/><div id="40283416" class="c"><input type="checkbox" id="c-40283416" checked=""/><div class="controls bullet"><span class="by">andersmurphy</span><span>|</span><a href="#40282238">parent</a><span>|</span><a href="#40281039">next</a><span>|</span><label class="collapse" for="c-40283416">[-]</label><label class="expand" for="c-40283416">[1 more]</label></div><br/><div class="children"><div class="content">(author here) From what I&#x27;ve read, other than documentation saying they shouldn&#x27;t be pooled, is that by disign they are meant to run and then get garbage collected. There&#x27;s also some overhead in managing the pool. If someone has a deeper understanding of virtual threads I&#x27;d love to know why in more detail.<p>As to why use a semaphore over a thread pool for this implementation? A thread pool couples throughput to the number of running threads. A semaphore lets me couple throughput to started tasks per second. I don&#x27;t care how many threads are currently running, I care about how many requests I&#x27;m making per second. Does that make more sense?</div><br/></div></div></div></div><div id="40281039" class="c"><input type="checkbox" id="c-40281039" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#40282238">prev</a><span>|</span><label class="collapse" for="c-40281039">[-]</label><label class="expand" for="c-40281039">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if core.async will be updated to work well with virtual threads? Anyone more involved in Clojure know if it will?</div><br/><div id="40281279" class="c"><input type="checkbox" id="c-40281279" checked=""/><div class="controls bullet"><span class="by">lgrapenthin</span><span>|</span><a href="#40281039">parent</a><span>|</span><a href="#40282844">next</a><span>|</span><label class="collapse" for="c-40281279">[-]</label><label class="expand" for="c-40281279">[1 more]</label></div><br/><div class="children"><div class="content">Considering that 1.12 is close, its next in the pipeline I guess: <a href="https:&#x2F;&#x2F;ask.clojure.org&#x2F;index.php&#x2F;13366&#x2F;virtual-thread-executor-for-core-async" rel="nofollow">https:&#x2F;&#x2F;ask.clojure.org&#x2F;index.php&#x2F;13366&#x2F;virtual-thread-execu...</a></div><br/></div></div><div id="40282844" class="c"><input type="checkbox" id="c-40282844" checked=""/><div class="controls bullet"><span class="by">seancorfield</span><span>|</span><a href="#40281039">parent</a><span>|</span><a href="#40281279">prev</a><span>|</span><label class="collapse" for="c-40282844">[-]</label><label class="expand" for="c-40282844">[1 more]</label></div><br/><div class="children"><div class="content">There have been several comments from the core team folks that a vthread variant of core.async is being considered. It would be a different library and may be somewhat API-compatible -- but that&#x27;s all up in the air right now.</div><br/></div></div></div></div></div></div></div></div></div></body></html>