<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733130057877" as="style"/><link rel="stylesheet" href="styles.css?v=1733130057877"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.hillelwayne.com/post/divide-by-zero/">1/0 = 0 (2018)</a> <span class="domain">(<a href="https://www.hillelwayne.com">www.hillelwayne.com</a>)</span></div><div class="subtext"><span>revskill</span> | <span>121 comments</span></div><br/><div><div id="42293319" class="c"><input type="checkbox" id="c-42293319" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42290667">next</a><span>|</span><label class="collapse" for="c-42293319">[-]</label><label class="expand" for="c-42293319">[5 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s all good and nice that your types are sound and you don&#x27;t have panics, but I feel like this could get you in trouble in the real world (gleam also uses this division convention, and people very much use gleam for &quot;real world&quot; things).  Suppose you took an average over an unintentionally empty list (maybe your streaming data source just didn&#x27;t send anything over the last minute due to a backhoe hitting a fiber in your external data source&#x27;s data center) and took some downstream action based off of what you think is the rolling average.  You could get royally fucked if money is involved.<p>Crashing would have been preferable.<p>1&#x2F;0 = 0 is unsuitable and dangerous for anyone doing anything in the real world.</div><br/><div id="42293792" class="c"><input type="checkbox" id="c-42293792" checked=""/><div class="controls bullet"><span class="by">oDot</span><span>|</span><a href="#42293319">parent</a><span>|</span><a href="#42293571">next</a><span>|</span><label class="collapse" for="c-42293792">[-]</label><label class="expand" for="c-42293792">[1 more]</label></div><br/><div class="children"><div class="content">I use Gleam in production[0][1], and that is not really an issue.<p>Gleam offers division functions that return an error type, and you can use those if you need that check.<p>They fit a list-length use case well as they work better with a piping syntax which is popular in Gleam.<p>[0] <a href="https:&#x2F;&#x2F;nestful.app" rel="nofollow">https:&#x2F;&#x2F;nestful.app</a><p>[1] <a href="https:&#x2F;&#x2F;blog.nestful.app&#x2F;p&#x2F;why-i-rewrote-nestful-in-gleam" rel="nofollow">https:&#x2F;&#x2F;blog.nestful.app&#x2F;p&#x2F;why-i-rewrote-nestful-in-gleam</a></div><br/></div></div><div id="42293571" class="c"><input type="checkbox" id="c-42293571" checked=""/><div class="controls bullet"><span class="by">gregschlom</span><span>|</span><a href="#42293319">parent</a><span>|</span><a href="#42293792">prev</a><span>|</span><a href="#42290667">next</a><span>|</span><label class="collapse" for="c-42293571">[-]</label><label class="expand" for="c-42293571">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny, I hold the exact opposite opinion, but from the same example: In the course of my programming career, I&#x27;ve had at least 3 different instances where I crashed stuff in production because I was computing an average and forgot to handle the case of the empty list. Everything would have been just fine if dividing by zero yielded zero.<p>I&#x27;ve learned my lesson since, but still.</div><br/><div id="42293755" class="c"><input type="checkbox" id="c-42293755" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42293319">root</a><span>|</span><a href="#42293571">parent</a><span>|</span><a href="#42290667">next</a><span>|</span><label class="collapse" for="c-42293755">[-]</label><label class="expand" for="c-42293755">[2 more]</label></div><br/><div class="children"><div class="content">What was the problem with crashing?  Surely you had Kubernetes&#x2F;GCP&#x2F;ECS restart your container, or if you&#x27;re using a BEAM based language, it would have just restarted<p>&gt; Everything would have been just fine if dividing by zero yielded zero<p>perhaps you weren&#x27;t making business decisions based on the reported average, just logging it for metrics or something, in which case I can see how a crash&#x2F;restart would be annoying.</div><br/><div id="42294184" class="c"><input type="checkbox" id="c-42294184" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42293319">root</a><span>|</span><a href="#42293755">parent</a><span>|</span><a href="#42290667">next</a><span>|</span><label class="collapse" for="c-42294184">[-]</label><label class="expand" for="c-42294184">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What was the problem with crashing?<p>I imagine the problem was that it crashed the whole process, and so the processing of other, completely fine data that was happening in parallel, was aborted as well. Did that lead to that data being dropped on the floor? Who knows — but probably yes.<p>And process restarts are not instantaneous, just so you know, and that&#x27;s even without talking about bringing the application into the &quot;stable stream processing&quot; state, which includes establishing streaming connections with other up- and downstream services.</div><br/></div></div></div></div></div></div></div></div><div id="42290667" class="c"><input type="checkbox" id="c-42290667" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#42293319">prev</a><span>|</span><a href="#42290709">next</a><span>|</span><label class="collapse" for="c-42290667">[-]</label><label class="expand" for="c-42290667">[25 more]</label></div><br/><div class="children"><div class="content">This article invents a new binary operation, calls it &quot;division&quot; and uses the &quot;&#x2F;&quot; operator to denote it. But the article repeats multiple times that this new operation isn&#x27;t a multiplicative inverse, so it&#x27;s not actually division. For example, (a&#x2F;b)*b=a isn&#x27;t true for this new operation.</div><br/><div id="42292986" class="c"><input type="checkbox" id="c-42292986" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#42290667">parent</a><span>|</span><a href="#42290774">next</a><span>|</span><label class="collapse" for="c-42292986">[-]</label><label class="expand" for="c-42292986">[4 more]</label></div><br/><div class="children"><div class="content">(a&#x2F;b)*b=a isn&#x27;t true, but that&#x27;s also not true for the math that you&#x27;re thinking of. What is true is IF b≠0 THEN (a&#x2F;b)*b=a. And this definition works just fine even if you define division by zero.<p>Also just to point out, the statement here really is a*b‾*b=a, which might make it more clear why b≠0.</div><br/><div id="42293061" class="c"><input type="checkbox" id="c-42293061" checked=""/><div class="controls bullet"><span class="by">snickerbockers</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42292986">parent</a><span>|</span><a href="#42290774">next</a><span>|</span><label class="collapse" for="c-42293061">[-]</label><label class="expand" for="c-42293061">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no &quot;if&quot; in the division operation.  Division is not defined for b=0.  a&#x2F;0 is a nonsensical quantity because the zero directly contradicts the definition of division.<p>maybe someday there will be a revelation where somebody proposes that it&#x27;s a new class of numbers we&#x27;ve never considered before like how (1-1), (0-1) and sqrt(-1) used to be nonsensical values to past mathematicians.  For now it&#x27;s not defined.</div><br/><div id="42294173" class="c"><input type="checkbox" id="c-42294173" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42293061">parent</a><span>|</span><a href="#42293408">next</a><span>|</span><label class="collapse" for="c-42294173">[-]</label><label class="expand" for="c-42294173">[1 more]</label></div><br/><div class="children"><div class="content">Division by zero is perfectly well defined in floating point. x&#x2F;0 = INF and INF*0 = NaN. That means b*(a&#x2F;b) != a if b = 0.<p>It&#x27;s true that it&#x27;s not defined for integer types, but that wouldn&#x27;t make a = b*(a&#x2F;b) true for them either.<p>It&#x27;s also common to define x&#x2F;0 = infinity in the extended real numbers that floating point models.</div><br/></div></div><div id="42293408" class="c"><input type="checkbox" id="c-42293408" checked=""/><div class="controls bullet"><span class="by">acjohnson55</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42293061">parent</a><span>|</span><a href="#42294173">prev</a><span>|</span><a href="#42290774">next</a><span>|</span><label class="collapse" for="c-42293408">[-]</label><label class="expand" for="c-42293408">[1 more]</label></div><br/><div class="children"><div class="content">Did you fully read the article?<p>In modern math, the concept of a field establishes addition and multiplication within its structure. We are not free to redefine those without abandoning a boatload of things that depend on their definition.<p>Division is not inherent to field theory, but rather an operation defined by convention.<p>It seems like you&#x27;re fixating on the most common convention, but as Hilel points out, there is no reason we have to adopt this convention in all situations.</div><br/></div></div></div></div></div></div><div id="42290774" class="c"><input type="checkbox" id="c-42290774" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#42290667">parent</a><span>|</span><a href="#42292986">prev</a><span>|</span><a href="#42290930">next</a><span>|</span><label class="collapse" for="c-42290774">[-]</label><label class="expand" for="c-42290774">[12 more]</label></div><br/><div class="children"><div class="content">Reusing symbols like +, *, or &#x2F; to define operations that aren&#x27;t the + or the &#x2F; you&#x27;re used to is pretty common in math. It&#x27;s just notation.<p>At the end of the day, the &#x2F; that we have in programming has the same problem as this article&#x27;s &#x2F;, almost all programming languages will return 5&#x2F;2 = 2 when dividing integers, even though 2 * 2 is not 5! Division is not defined for all integers, but it&#x27;s just <i>convenient</i> to extend it when programming.<p>So if some languages want to define 1&#x2F;0 = 0, we really shouldn&#x27;t be surprised that 0*0 is not 1, we already had the  (a&#x2F;b)*b != a problem all along!</div><br/><div id="42292620" class="c"><input type="checkbox" id="c-42292620" checked=""/><div class="controls bullet"><span class="by">clipsy</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42290774">parent</a><span>|</span><a href="#42290983">next</a><span>|</span><label class="collapse" for="c-42292620">[-]</label><label class="expand" for="c-42292620">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Reusing symbols like +, *, or &#x2F; to define operations that aren&#x27;t the + or the &#x2F; you&#x27;re used to is pretty common in math. It&#x27;s just notation.<p>Reusing symbols <i>in a different context</i> is pretty common; taking a symbol that is already broadly used in a specific way (in this case, that `a&#x2F;b` is defined for elements in a field as multiplying `a` by the multiplicative inverse of `b`) is poor form and, frankly, a disingenuous argument.</div><br/></div></div><div id="42290983" class="c"><input type="checkbox" id="c-42290983" checked=""/><div class="controls bullet"><span class="by">ilius2</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42290774">parent</a><span>|</span><a href="#42292620">prev</a><span>|</span><a href="#42290930">next</a><span>|</span><label class="collapse" for="c-42290983">[-]</label><label class="expand" for="c-42290983">[10 more]</label></div><br/><div class="children"><div class="content">That&#x27;s nonsense. a&#x2F;b is float in Python 3, and even in other languages a&#x2F;b gets closer to it&#x27;s actual value as a and b get bigger (the &quot;limit&quot;, which is the basis of Algebra). So four operations in programming generally do agree with foundations of Algebra. But a&#x2F;0=0 is %100 against Algebra. And it&#x27;s very unintuitive. It&#x27;s basically saying zero is the same as infinity, and therefore all numbers are the same, so why bother having any numbers at all?</div><br/><div id="42291023" class="c"><input type="checkbox" id="c-42291023" checked=""/><div class="controls bullet"><span class="by">clipsy</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42290983">parent</a><span>|</span><a href="#42291072">next</a><span>|</span><label class="collapse" for="c-42291023">[-]</label><label class="expand" for="c-42291023">[3 more]</label></div><br/><div class="children"><div class="content">&gt; even in other languages a&#x2F;b gets closer to it&#x27;s actual value as a and b get bigger (the &quot;limit&quot;, which is the basis of Algebra)<p>This is not generally true. 5&#x2F;2 = 2, 50&#x2F;20 = 2, 500&#x2F;200 = 2, and so on no matter how big the numbers get.</div><br/><div id="42293005" class="c"><input type="checkbox" id="c-42293005" checked=""/><div class="controls bullet"><span class="by">ilius2</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291023">parent</a><span>|</span><a href="#42291072">next</a><span>|</span><label class="collapse" for="c-42293005">[-]</label><label class="expand" for="c-42293005">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I meant when the result gets bigger. You get the idea.</div><br/><div id="42293978" class="c"><input type="checkbox" id="c-42293978" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42293005">parent</a><span>|</span><a href="#42291072">next</a><span>|</span><label class="collapse" for="c-42293978">[-]</label><label class="expand" for="c-42293978">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the output of this Go program, without going to the playground link?<p><pre><code>  print(math.MinInt &#x2F; -1)
</code></pre>
<a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;Vy1kj0dEsqP" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;Vy1kj0dEsqP</a></div><br/></div></div></div></div></div></div><div id="42291072" class="c"><input type="checkbox" id="c-42291072" checked=""/><div class="controls bullet"><span class="by">scarmig</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42290983">parent</a><span>|</span><a href="#42291023">prev</a><span>|</span><a href="#42291008">next</a><span>|</span><label class="collapse" for="c-42291072">[-]</label><label class="expand" for="c-42291072">[2 more]</label></div><br/><div class="children"><div class="content">Floats don&#x27;t have multiplicative inverses, and the floating point operations don&#x27;t give us any of the mathematical structures we expect of numbers. Floating point division already abandons algebra for the sake of usefulness.</div><br/><div id="42291446" class="c"><input type="checkbox" id="c-42291446" checked=""/><div class="controls bullet"><span class="by">mjcohen</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291072">parent</a><span>|</span><a href="#42291008">next</a><span>|</span><label class="collapse" for="c-42291446">[-]</label><label class="expand" for="c-42291446">[1 more]</label></div><br/><div class="children"><div class="content">Knuth vol 2 has a nice discussion of floating point operations and shows how to reason about them. Wilkinson&#x27;s classic &quot;Rounding Errors in Algebraic Processes&quot; (1966) also has a good discussion.</div><br/></div></div></div></div><div id="42291008" class="c"><input type="checkbox" id="c-42291008" checked=""/><div class="controls bullet"><span class="by">ilius2</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42290983">parent</a><span>|</span><a href="#42291072">prev</a><span>|</span><a href="#42290930">next</a><span>|</span><label class="collapse" for="c-42291008">[-]</label><label class="expand" for="c-42291008">[4 more]</label></div><br/><div class="children"><div class="content">If you were to define a&#x2F;0 the most logical choice would be a new special value &quot;Infinity&quot;. The second best choice would be the maximum supported value of the type of a (int, int64 etc). Anything else would be stupid.</div><br/><div id="42292572" class="c"><input type="checkbox" id="c-42292572" checked=""/><div class="controls bullet"><span class="by">sidpatil</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291008">parent</a><span>|</span><a href="#42290930">next</a><span>|</span><label class="collapse" for="c-42292572">[-]</label><label class="expand" for="c-42292572">[3 more]</label></div><br/><div class="children"><div class="content">What if a is negative?</div><br/><div id="42293018" class="c"><input type="checkbox" id="c-42293018" checked=""/><div class="controls bullet"><span class="by">ilius2</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42292572">parent</a><span>|</span><a href="#42290930">next</a><span>|</span><label class="collapse" for="c-42293018">[-]</label><label class="expand" for="c-42293018">[2 more]</label></div><br/><div class="children"><div class="content">Same. Unless you want to differentiate -0 and +0 (which make it more complicated), you can not distinguish infinity from negative infinity.</div><br/><div id="42293767" class="c"><input type="checkbox" id="c-42293767" checked=""/><div class="controls bullet"><span class="by">jsnedjdn</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42293018">parent</a><span>|</span><a href="#42290930">next</a><span>|</span><label class="collapse" for="c-42293767">[-]</label><label class="expand" for="c-42293767">[1 more]</label></div><br/><div class="children"><div class="content">IEEE floating point representation does both</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42290930" class="c"><input type="checkbox" id="c-42290930" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#42290667">parent</a><span>|</span><a href="#42290774">prev</a><span>|</span><a href="#42290816">next</a><span>|</span><label class="collapse" for="c-42290930">[-]</label><label class="expand" for="c-42290930">[1 more]</label></div><br/><div class="children"><div class="content">Multiplicative inverse happens to be a convenient way to define division in the reals, but there are cases when multiplicative inverses do not correspond to any notion of division. E.g. take a finite  ring of integers, like what you’d use for cryptography or heck any operation on an `int`!<p>It’s all just definitions. Always has been.</div><br/></div></div><div id="42291153" class="c"><input type="checkbox" id="c-42291153" checked=""/><div class="controls bullet"><span class="by">beala</span><span>|</span><a href="#42290667">parent</a><span>|</span><a href="#42290816">prev</a><span>|</span><a href="#42290709">next</a><span>|</span><label class="collapse" for="c-42291153">[-]</label><label class="expand" for="c-42291153">[6 more]</label></div><br/><div class="children"><div class="content">Under what definition of division is (a&#x2F;b)*b=a true for all values?</div><br/><div id="42292926" class="c"><input type="checkbox" id="c-42292926" checked=""/><div class="controls bullet"><span class="by">sadeshmukh</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291153">parent</a><span>|</span><a href="#42291461">next</a><span>|</span><label class="collapse" for="c-42292926">[-]</label><label class="expand" for="c-42292926">[1 more]</label></div><br/><div class="children"><div class="content">The one that excludes 0. It&#x27;s not a terribly complicated thing to restrict domain: you don&#x27;t expect, for example, complex values in real-valued functions.</div><br/></div></div><div id="42291461" class="c"><input type="checkbox" id="c-42291461" checked=""/><div class="controls bullet"><span class="by">mjcohen</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291153">parent</a><span>|</span><a href="#42292926">prev</a><span>|</span><a href="#42290709">next</a><span>|</span><label class="collapse" for="c-42291461">[-]</label><label class="expand" for="c-42291461">[4 more]</label></div><br/><div class="children"><div class="content">If 0 is not an allowable value for b is necessary but not generally sufficient.</div><br/><div id="42291658" class="c"><input type="checkbox" id="c-42291658" checked=""/><div class="controls bullet"><span class="by">beala</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291461">parent</a><span>|</span><a href="#42290709">next</a><span>|</span><label class="collapse" for="c-42291658">[-]</label><label class="expand" for="c-42291658">[3 more]</label></div><br/><div class="children"><div class="content">Can you say more? If &quot;0 is not an allowable value for b&quot;, then it seems to me that (a&#x2F;b)*b=a isn&#x27;t true for all values. Specifically, it&#x27;s false when b=0.<p>IIUC, codeflo is arguing that the division operation defined in the article isn&#x27;t &quot;actual division&quot; because (a&#x2F;b)*b=a isn&#x27;t true for all values. But I can&#x27;t think of a definition of division that satisfies that criteria.</div><br/><div id="42292983" class="c"><input type="checkbox" id="c-42292983" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291658">parent</a><span>|</span><a href="#42293159">next</a><span>|</span><label class="collapse" for="c-42292983">[-]</label><label class="expand" for="c-42292983">[1 more]</label></div><br/><div class="children"><div class="content">When we say &quot;is not an allowable value&quot;, we are speaking about the domain [1]: all the values for which the function is defined. When we say &quot;for all values&quot;, we implicitly mean for all values of the domain.<p>The parallel in programming would be the contract : you provide a function that works on a given set of values. Or the type: the function would &quot;crash&quot; if you passed a value not of the type of its parameter, but it is admitted it won&#x27;t be done.<p>(In the remaining I&#x27;m referring to 1&#x2F;x instead of a&#x2F;b to simplify things a bit)<p>Another way of saying it is that the function is undefined for 0. (Or on {0}). Then the property is true for all values (on which the function is defined, but saying it is redundant, the function can&#x27;t be called outside its domain,  it is an error to try to do this).<p>The domain is often left out &#x2F; implicit, but it is always part of the definition of a function.<p>0 is not in the domain,  so it&#x27;s not to be considered at all when studying the function (except maybe when studying limits, but the function will still not be called with it).<p>[1] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Domain_of_a_function" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Domain_of_a_function</a></div><br/></div></div><div id="42293159" class="c"><input type="checkbox" id="c-42293159" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#42290667">root</a><span>|</span><a href="#42291658">parent</a><span>|</span><a href="#42292983">prev</a><span>|</span><a href="#42290709">next</a><span>|</span><label class="collapse" for="c-42293159">[-]</label><label class="expand" for="c-42293159">[1 more]</label></div><br/><div class="children"><div class="content">If &quot;0 is not an allowable value for b&quot;, then (a&#x2F;b)*b=a is not defined when b=0, so it is neither true nor false, since you had previously agreed that b=0 is not allowed (regardless of what &quot;&#x2F;&quot; and &quot;*&quot; are meaning in this context).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42290709" class="c"><input type="checkbox" id="c-42290709" checked=""/><div class="controls bullet"><span class="by">sethev</span><span>|</span><a href="#42290667">prev</a><span>|</span><a href="#42290590">next</a><span>|</span><label class="collapse" for="c-42290709">[-]</label><label class="expand" for="c-42290709">[17 more]</label></div><br/><div class="children"><div class="content">I debated this with my boss at my first programming job (this was 20+ years ago). He thought 1&#x2F;0 should be 0 rather than an error because &quot;that&#x27;s what people expect&quot;. My argument was from mathematical definitions (the argument which this blog post picks apart).<p>In retrospect, I see his point better - practical use trumps theory in most language design decisions.<p>I haven&#x27;t changed my mind but the reason has shifted more toward because &quot;it&#x27;s what a larger set of people expect in more situations&quot; rather than mathematical purity.</div><br/><div id="42293375" class="c"><input type="checkbox" id="c-42293375" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42290709">parent</a><span>|</span><a href="#42293306">next</a><span>|</span><label class="collapse" for="c-42293375">[-]</label><label class="expand" for="c-42293375">[3 more]</label></div><br/><div class="children"><div class="content">1&#x2F;0 = 0 is usually not a practical thing, it&#x27;s to satisfy that the output of the division operator stays in the type and you don&#x27;t want crashes (a &quot;feature&quot; of ponylang and gleam, e.g.).  Its kind of a PL wonk thing.<p>It&#x27;s not at all a good idea for very important practical reasons as I outline in a reply to parent.</div><br/><div id="42293939" class="c"><input type="checkbox" id="c-42293939" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42293375">parent</a><span>|</span><a href="#42293306">next</a><span>|</span><label class="collapse" for="c-42293939">[-]</label><label class="expand" for="c-42293939">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to handle errors after every division and division doesn&#x27;t crash, both sound rather practical, though.</div><br/><div id="42294224" class="c"><input type="checkbox" id="c-42294224" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42293939">parent</a><span>|</span><a href="#42293306">next</a><span>|</span><label class="collapse" for="c-42294224">[-]</label><label class="expand" for="c-42294224">[1 more]</label></div><br/><div class="children"><div class="content">The original purpose of defining it to be Nan&#x2F;INF in floating point was exactly that. You&#x27;d do all the work and then check if it was Nan&#x2F;INF at the end without having to check every intermediate result.</div><br/></div></div></div></div></div></div><div id="42293306" class="c"><input type="checkbox" id="c-42293306" checked=""/><div class="controls bullet"><span class="by">pasquinelli</span><span>|</span><a href="#42290709">parent</a><span>|</span><a href="#42293375">prev</a><span>|</span><a href="#42293753">next</a><span>|</span><label class="collapse" for="c-42293306">[-]</label><label class="expand" for="c-42293306">[4 more]</label></div><br/><div class="children"><div class="content">i would not expect 1&#x2F;0 to be zero. as you divide by smaller numbers, the quotient gets bigger, so i can&#x27;t understand why someone would expect &#x2F;0 to be zero.</div><br/><div id="42294108" class="c"><input type="checkbox" id="c-42294108" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42293306">parent</a><span>|</span><a href="#42293753">next</a><span>|</span><label class="collapse" for="c-42294108">[-]</label><label class="expand" for="c-42294108">[3 more]</label></div><br/><div class="children"><div class="content">If I have five apples and were to divide them among 0 people then nobody gets anything and I can eat them all, so the proper solution would be 5.</div><br/><div id="42294334" class="c"><input type="checkbox" id="c-42294334" checked=""/><div class="controls bullet"><span class="by">askvictor</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42294108">parent</a><span>|</span><a href="#42294243">next</a><span>|</span><label class="collapse" for="c-42294334">[-]</label><label class="expand" for="c-42294334">[1 more]</label></div><br/><div class="children"><div class="content">Paraphrasing you: &quot;If I have five apples and were to divide them among 0 people, how many does each person get?&quot; This sums up one approach to this problem, and can be thought of in a more intuitive manner than the limit approach. The answer could be zero. Or 1. Or 37. In fact, any number makes as much sense as the question. Which is why either an exception is raised, (or +- Inf is returned for floats, but that&#x27;s just the limit approach). But perhaps it would be more fun just to return a random number on divide by zero :)</div><br/></div></div><div id="42294243" class="c"><input type="checkbox" id="c-42294243" checked=""/><div class="controls bullet"><span class="by">Almondsetat</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42294108">parent</a><span>|</span><a href="#42294334">prev</a><span>|</span><a href="#42293753">next</a><span>|</span><label class="collapse" for="c-42294243">[-]</label><label class="expand" for="c-42294243">[1 more]</label></div><br/><div class="children"><div class="content">you can&#x27;t divide the apples among 0 people and then claim to still have them, because in that case you would have divided them among 1 people</div><br/></div></div></div></div></div></div><div id="42293753" class="c"><input type="checkbox" id="c-42293753" checked=""/><div class="controls bullet"><span class="by">jsnedjdn</span><span>|</span><a href="#42290709">parent</a><span>|</span><a href="#42293306">prev</a><span>|</span><a href="#42293750">next</a><span>|</span><label class="collapse" for="c-42293753">[-]</label><label class="expand" for="c-42293753">[4 more]</label></div><br/><div class="children"><div class="content">Never have I ever met anybody who would think dividing by zero yields zero O_o<p>If anything it feels natural to yield +&#x2F;-infinity</div><br/><div id="42294090" class="c"><input type="checkbox" id="c-42294090" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42293753">parent</a><span>|</span><a href="#42293750">next</a><span>|</span><label class="collapse" for="c-42294090">[-]</label><label class="expand" for="c-42294090">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about what I think zero division yields I&#x27;ve taken a math class before. It&#x27;s just about representation within the type system. If division can return infinities we can&#x27;t safely combine division with other functions that are expecting ints and floats.<p>Most languages throw an error instead, but there are tradeoffs there too. If you&#x27;ve decided not to throw an error you should at least return a usable number and zero makes more sense than -1 or 7 or a billion or whatever.<p>You could also build the number stack from the ground up to accommodate this edge case, and make it so all arithmetic functions can handle infinities, infinitesimals and limits. I&#x27;ve come across a racket sublang like that but it&#x27;s nearly unusable for the normal common things you want to do with numbers in code.</div><br/><div id="42294211" class="c"><input type="checkbox" id="c-42294211" checked=""/><div class="controls bullet"><span class="by">ctenb</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42294090">parent</a><span>|</span><a href="#42293750">next</a><span>|</span><label class="collapse" for="c-42294211">[-]</label><label class="expand" for="c-42294211">[2 more]</label></div><br/><div class="children"><div class="content">NaN is a valid float, so are infinities</div><br/><div id="42294272" class="c"><input type="checkbox" id="c-42294272" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42294211">parent</a><span>|</span><a href="#42293750">next</a><span>|</span><label class="collapse" for="c-42294272">[-]</label><label class="expand" for="c-42294272">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re valid according to a spec that doesn&#x27;t mean I want one showing up when I&#x27;m trying to calculate the area of a semicircle or whatever. In the context of getting one by surprise in simple arithmetic they are approximately as bad as zero. Either way you have to decide how to handle it and there are tradeoffs of different approaches, as the article discusses. It&#x27;s not about someone just being ignorant of basic math like the comment I was replying to implied.</div><br/></div></div></div></div></div></div></div></div><div id="42290953" class="c"><input type="checkbox" id="c-42290953" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#42290709">parent</a><span>|</span><a href="#42293750">prev</a><span>|</span><a href="#42290590">next</a><span>|</span><label class="collapse" for="c-42290953">[-]</label><label class="expand" for="c-42290953">[4 more]</label></div><br/><div class="children"><div class="content">Huh? The article shows why 1&#x2F;0=0 is mathematically sound, and then considers an error preferable in a programming context anyway, because practicality. It’s the opposite of the reasoning you’re describing.</div><br/><div id="42292958" class="c"><input type="checkbox" id="c-42292958" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42290953">parent</a><span>|</span><a href="#42292875">prev</a><span>|</span><a href="#42290590">next</a><span>|</span><label class="collapse" for="c-42292958">[-]</label><label class="expand" for="c-42292958">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The article shows why 1&#x2F;0=0 is mathematically sound<p>It does not, because it is not. And the “real mathematicians” that he quotes aren’t supporting his case either, they’re just saying that there are cases where it’s convenient to pretend. If you look at the Wikipedia page for division by zero you may find “it is possible to define the result of division by zero in other ways, resulting in different number systems”: in short, if it’s convenient, you can make up your own rules.</div><br/><div id="42293100" class="c"><input type="checkbox" id="c-42293100" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42290709">root</a><span>|</span><a href="#42292958">parent</a><span>|</span><a href="#42290590">next</a><span>|</span><label class="collapse" for="c-42293100">[-]</label><label class="expand" for="c-42293100">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in short, if it’s convenient, you can make up your own rules.<p>Yes.<p>People find it confusing that there is no simple model that encapsulates arithmetic.  Fields do not capture it in its entirety.  The models of arithmetic that describe it end up being extremely complex.<p>Arithmetic is ubiquitous in proofs of other things, and people like the author of this blog cannot get over it.<p>Reality is weird, inconsistent, and weirdly incomplete.<p>Get used to it!</div><br/></div></div></div></div></div></div></div></div><div id="42290590" class="c"><input type="checkbox" id="c-42290590" checked=""/><div class="controls bullet"><span class="by">rsp1984</span><span>|</span><a href="#42290709">prev</a><span>|</span><a href="#42291130">next</a><span>|</span><label class="collapse" for="c-42290590">[-]</label><label class="expand" for="c-42290590">[20 more]</label></div><br/><div class="children"><div class="content">As long as lim(1&#x2F;x)_x-&gt;0 = inf, 1&#x2F;0 = 0 doesn&#x27;t make a whole lot of sense, mathematically speaking.
I might be wrong but I don&#x27;t think it was addressed in the article either.</div><br/><div id="42290655" class="c"><input type="checkbox" id="c-42290655" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42290590">parent</a><span>|</span><a href="#42290725">next</a><span>|</span><label class="collapse" for="c-42290655">[-]</label><label class="expand" for="c-42290655">[10 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a great Radiolab episode[0] that talks about divide by zero in perhaps more conceptual terms.<p><pre><code>    KARIM ANI: If you take 10 and divide it by 10, you get one. 10 divided by five is two. 10 divided by half is 20. The smaller the number on the bottom, the number that you&#x27;re dividing by, the larger the result. And so by that reasoning ...
    
    LULU: If you divide by zero, the smallest nothingness number we can conceive of, then your answer ...
    
    KARIM ANI: Would be infinity.
    
    LULU: Why isn&#x27;t it infinity? Infinity feels like a great answer.
    
    KARIM ANI: Because infinity in mathematics isn&#x27;t actually a number, it&#x27;s a direction. It&#x27;s a direction that we can move towards, but it isn&#x27;t a destination that we can get to. And the reason is because if you allow for infinity then you get really weird results.  For instance, infinity plus zero is ...
    
    LATIF: Infinity.
    
    KARIM ANI: Infinity plus two is infinity. Infinity plus three is infinity. And what that would suggest is zero is equal to one, is equal to two, is equal to three, is equal to four ...
    
    STEVE STROGATZ: And that would break math as we know it.  Because then, as your friend says, all numbers would become the same number.
</code></pre>
[0] <a href="https:&#x2F;&#x2F;radiolab.org&#x2F;podcast&#x2F;zeroworld" rel="nofollow">https:&#x2F;&#x2F;radiolab.org&#x2F;podcast&#x2F;zeroworld</a></div><br/><div id="42290678" class="c"><input type="checkbox" id="c-42290678" checked=""/><div class="controls bullet"><span class="by">v4vvdq</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290655">parent</a><span>|</span><a href="#42290714">next</a><span>|</span><label class="collapse" for="c-42290678">[-]</label><label class="expand" for="c-42290678">[7 more]</label></div><br/><div class="children"><div class="content">Then take 10 and divide it by -10 = -1. 10 &#x2F; -5 = -2. 10 &#x2F; -0.5 = -20.
So from the other side of the y-axis it behaves the exact opposite. It goes to minus infinity. So at x=0 we would have infinity and minus infinity at the same time. Imho that is why it is undefined.</div><br/><div id="42293959" class="c"><input type="checkbox" id="c-42293959" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290678">parent</a><span>|</span><a href="#42292988">next</a><span>|</span><label class="collapse" for="c-42293959">[-]</label><label class="expand" for="c-42293959">[1 more]</label></div><br/><div class="children"><div class="content">I always thought the answer to verbal query &quot;let y=1&#x2F;x, x=0, find y&quot; was &quot;Well, the answer is the Y axis of the plot&quot;. Surprising that people have to be reminded that X can be signed. I&#x27;ve had similar conversation IRL.</div><br/></div></div><div id="42292988" class="c"><input type="checkbox" id="c-42292988" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290678">parent</a><span>|</span><a href="#42293959">prev</a><span>|</span><a href="#42290693">next</a><span>|</span><label class="collapse" for="c-42292988">[-]</label><label class="expand" for="c-42292988">[1 more]</label></div><br/><div class="children"><div class="content">In IEEE 754 math, x&#x2F;0 for x &lt; 0 is in fact negative infinity.<p><pre><code>  &gt;&gt;&gt; np.float64(-1.)&#x2F;0.
  -inf
  &gt;&gt;&gt; np.float64(1.)&#x2F;0.
  inf
</code></pre>
And you&#x27;re exactly right, 0&#x2F;0 is NaN in 754 math exactly because it approaches negative infinity, zero (from 0&#x2F;x), and positive infinity at the same time.</div><br/></div></div><div id="42290693" class="c"><input type="checkbox" id="c-42290693" checked=""/><div class="controls bullet"><span class="by">WithinReason</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290678">parent</a><span>|</span><a href="#42292988">prev</a><span>|</span><a href="#42290714">next</a><span>|</span><label class="collapse" for="c-42290693">[-]</label><label class="expand" for="c-42290693">[4 more]</label></div><br/><div class="children"><div class="content">on computers you can have negative zeros</div><br/><div id="42290757" class="c"><input type="checkbox" id="c-42290757" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290693">parent</a><span>|</span><a href="#42293317">next</a><span>|</span><label class="collapse" for="c-42290757">[-]</label><label class="expand" for="c-42290757">[2 more]</label></div><br/><div class="children"><div class="content">Negative zero is equal to zero, so it&#x27;s not really a distinct number, just another representation of the same value.</div><br/><div id="42292844" class="c"><input type="checkbox" id="c-42292844" checked=""/><div class="controls bullet"><span class="by">epidemian</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290757">parent</a><span>|</span><a href="#42293317">next</a><span>|</span><label class="collapse" for="c-42292844">[-]</label><label class="expand" for="c-42292844">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s equal (as in, comparing them with == is true), but they are not the same value. At least in IEEE 754 floats, which is what most languages with floating point numbers use. E.g., in JS:<p><pre><code>  &gt; 1 &#x2F; 0
  Infinity
  &gt; 1 &#x2F; -0
  -Infinity
  &gt; 0 === -0
  true
  &gt; Object.is(0, -0)
  false</code></pre></div><br/></div></div></div></div><div id="42293317" class="c"><input type="checkbox" id="c-42293317" checked=""/><div class="controls bullet"><span class="by">pasquinelli</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290693">parent</a><span>|</span><a href="#42290757">prev</a><span>|</span><a href="#42290714">next</a><span>|</span><label class="collapse" for="c-42293317">[-]</label><label class="expand" for="c-42293317">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s really just an encoding of the number to help you understand how the hell you got here</div><br/></div></div></div></div></div></div><div id="42290714" class="c"><input type="checkbox" id="c-42290714" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290655">parent</a><span>|</span><a href="#42290678">prev</a><span>|</span><a href="#42290935">next</a><span>|</span><label class="collapse" for="c-42290714">[-]</label><label class="expand" for="c-42290714">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s even worse than that. The other issue is what happens when you&#x27;ve got a negative number as the numerator (number on top). Then the smaller the denominator (number on bottom) the <i>more negative</i> the result. -10&#x2F;10 = -1. -10&#x2F;5 = -2. -10&#x2F;2 = -20. So if you divide by zero, it&#x27;s obviously negative infinity! And it&#x27;s positive infinity! At the same time.</div><br/></div></div><div id="42290935" class="c"><input type="checkbox" id="c-42290935" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290655">parent</a><span>|</span><a href="#42290714">prev</a><span>|</span><a href="#42290725">next</a><span>|</span><label class="collapse" for="c-42290935">[-]</label><label class="expand" for="c-42290935">[1 more]</label></div><br/><div class="children"><div class="content">Ordinal and cardinal infinities are different. There are hierarchies of infinities.<p>`1&#x2F;0` and `1&#x2F;0 + 1` aren&#x27;t meaningfully different, so it kinda does make sense for whatever notation to not make a distinction.</div><br/></div></div></div></div><div id="42290725" class="c"><input type="checkbox" id="c-42290725" checked=""/><div class="controls bullet"><span class="by">judofyr</span><span>|</span><a href="#42290590">parent</a><span>|</span><a href="#42290655">prev</a><span>|</span><a href="#42290660">next</a><span>|</span><label class="collapse" for="c-42290725">[-]</label><label class="expand" for="c-42290725">[1 more]</label></div><br/><div class="children"><div class="content">The arguments around limits are addressed towards the end (under &quot;Update 8&#x2F;12&#x2F;2018&quot;):<p>&gt; &gt; If 0&#x2F;0 = 0 then lim_(x -&gt; 0) sin(x) &#x2F; x = sin(0) &#x2F; 0 = 0, but by L’Hospitals’ Rule lim_(x -&gt; 0) sin(x) &#x2F; x = lim_(x -&gt; 0) cos(x) &#x2F; 1 = 1. So we have 0 = 1.<p>&gt; This was a really clever one. The issue is that the counterargument assumes that if the limit exists and f(0) is defined, then lim_(x -&gt; 0) f(x) = f(0). This isn’t always true: take a continuous function and add a point discontinuity. The limit of sin(x) &#x2F; x is not sin(0) &#x2F; 0, because sin(x) &#x2F; x is discontinuous at 0. For the unextended division it’s because sin(0) &#x2F; 0 is undefined, while for our extended division it’s a point discontinuity. Funnily enough if we instead picked x&#x2F;0 = 1 then sin(x) &#x2F; x would be continuous everywhere.<p>Similar examples can be constructed for any regular function which is discontinuous (e.g. Heaviside step function).</div><br/></div></div><div id="42290660" class="c"><input type="checkbox" id="c-42290660" checked=""/><div class="controls bullet"><span class="by">v4vvdq</span><span>|</span><a href="#42290590">parent</a><span>|</span><a href="#42290725">prev</a><span>|</span><a href="#42290641">next</a><span>|</span><label class="collapse" for="c-42290660">[-]</label><label class="expand" for="c-42290660">[3 more]</label></div><br/><div class="children"><div class="content">I was also looking for this. And would like to add: lim(-1&#x2F;x)_x -&gt; 0 = -inf
That is (in my opinion) the whole point why it is actually undefined. On one side of the y-axis it goes to infinity, on the other to minus infinity. I don&#x27;t see a solution to this and therefore always have accepted that it is undefined.</div><br/><div id="42290752" class="c"><input type="checkbox" id="c-42290752" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290660">parent</a><span>|</span><a href="#42290641">next</a><span>|</span><label class="collapse" for="c-42290752">[-]</label><label class="expand" for="c-42290752">[2 more]</label></div><br/><div class="children"><div class="content">No. 1&#x2F;x^2 is undefined at 0 but has the same <i>limit behavior</i>, because <i>limit behavior</i> is not a function from &quot;pairs of (functions from R to R, R)&quot; to R<p>Infinity is not a real number.</div><br/><div id="42291045" class="c"><input type="checkbox" id="c-42291045" checked=""/><div class="controls bullet"><span class="by">ganzuul</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290752">parent</a><span>|</span><a href="#42290641">next</a><span>|</span><label class="collapse" for="c-42291045">[-]</label><label class="expand" for="c-42291045">[1 more]</label></div><br/><div class="children"><div class="content">Can limit behavior be defined as Cauchy sequences?</div><br/></div></div></div></div></div></div><div id="42290641" class="c"><input type="checkbox" id="c-42290641" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42290590">parent</a><span>|</span><a href="#42290660">prev</a><span>|</span><a href="#42290700">next</a><span>|</span><label class="collapse" for="c-42290641">[-]</label><label class="expand" for="c-42290641">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fine. Infinity isn&#x27;t a real number, so 1&#x2F;x isn&#x27;t continuous at 0, so it doesn&#x27;t matter what the value of 1&#x2F;0 is. All your open sets still behave the way you expect. Whether you choose &quot;this function is undefined here&quot; vs &quot;it&#x27;s impossible to ever reach the value of this function at this value, under any assumptions I&#x27;ll ever care about&quot; is purely a matter of convenience.</div><br/><div id="42290837" class="c"><input type="checkbox" id="c-42290837" checked=""/><div class="controls bullet"><span class="by">rsp1984</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290641">parent</a><span>|</span><a href="#42290700">next</a><span>|</span><label class="collapse" for="c-42290837">[-]</label><label class="expand" for="c-42290837">[3 more]</label></div><br/><div class="children"><div class="content">Yea, but conceptually it&#x27;s a bit smelly to have f(x) get larger and larger the closer x is to 0 and then suddenly have it be 0 once x reaches 0.</div><br/><div id="42293523" class="c"><input type="checkbox" id="c-42293523" checked=""/><div class="controls bullet"><span class="by">_carbyau_</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290837">parent</a><span>|</span><a href="#42293326">next</a><span>|</span><label class="collapse" for="c-42293523">[-]</label><label class="expand" for="c-42293523">[1 more]</label></div><br/><div class="children"><div class="content">As others have pointed out &quot;larger and larger&quot; is the same when it is negative too. So I think people are just going: positive infinity + negative infinity = 0.<p>Intuitively nice in a sense but I honestly think &#x27;0&#x27; is misrepresenting what is going on here. I&#x27;m ok with it being &#x27; &quot;+ and&#x2F;or -&quot; infinity&#x27; as a new definition.<p>Programmatically I think it should result in a NULL or VOID or similar. I mean, by definition it has no definition.</div><br/></div></div><div id="42293326" class="c"><input type="checkbox" id="c-42293326" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#42290590">root</a><span>|</span><a href="#42290837">parent</a><span>|</span><a href="#42293523">prev</a><span>|</span><a href="#42290700">next</a><span>|</span><label class="collapse" for="c-42293326">[-]</label><label class="expand" for="c-42293326">[1 more]</label></div><br/><div class="children"><div class="content">But once you go behind, it flips suddenly anyway so you could just as well have it be intuitively “halfway between the positive and negative infinities” which is at least fun and could spawn a few “Why is 1&#x2F;x suddenly go to zero” articles on HN in 2053</div><br/></div></div></div></div></div></div></div></div><div id="42291130" class="c"><input type="checkbox" id="c-42291130" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#42290590">prev</a><span>|</span><a href="#42290582">next</a><span>|</span><label class="collapse" for="c-42291130">[-]</label><label class="expand" for="c-42291130">[2 more]</label></div><br/><div class="children"><div class="content">So, how often do devs actually want a `&#x2F;` that isn&#x27;t the inverse of multiplication?<p>Trying to calculate... I don&#x27;t know, how many 2-disk raid6 groups I need to hold some amount of data is an <i>error</i>, not &quot;lol you don&#x27;t need any&quot;.<p>If my queue consumer can handle 0 concurrent tasks, it will take <i>literally forever</i> to finish, not finish instantly.</div><br/><div id="42294321" class="c"><input type="checkbox" id="c-42294321" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#42291130">parent</a><span>|</span><a href="#42290582">next</a><span>|</span><label class="collapse" for="c-42294321">[-]</label><label class="expand" for="c-42294321">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, if my queue consumer can handle 0 concurrent tasks, I’d rather it finishes instantly than never.</div><br/></div></div></div></div><div id="42290582" class="c"><input type="checkbox" id="c-42290582" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#42291130">prev</a><span>|</span><a href="#42292632">next</a><span>|</span><label class="collapse" for="c-42290582">[-]</label><label class="expand" for="c-42290582">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d agree to some kind of 1&#x2F;&#x2F;0=0 for ints; but for floats you&#x27;ll take 1&#x2F;0=inf from my cold, dead hands.</div><br/></div></div><div id="42292632" class="c"><input type="checkbox" id="c-42292632" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42290582">prev</a><span>|</span><a href="#42290945">next</a><span>|</span><label class="collapse" for="c-42292632">[-]</label><label class="expand" for="c-42292632">[1 more]</label></div><br/><div class="children"><div class="content">Not that anybody asked me, but I think about it like this:<p>You have a field (a set of &quot;numbers&quot;). Multiplication is defined over the field. You want to invent a notion of division. Let&#x27;s introduce the notation &quot;a&#x2F;b&quot; to refer to some member of a field such that &quot;a&#x2F;b&quot; * b = a.<p>As Hillel points out, you can identify &quot;a&#x2F;b&quot; with a*inverse(b), where &quot;inverse&quot; is the multiplicative inverse. And yes, there is no inverse(0). But really let&#x27;s just stick with the previous definition: &quot;a&#x2F;b&quot; * b = a.<p>Now consider &quot;a&#x2F;0&quot;. If &quot;a&#x2F;0&quot; is in the field, then &quot;a&#x2F;0&quot; * 0 = a. Let&#x27;s consider the case where a != 0. Then we have &quot;a&#x2F;0&quot; * 0 != 0. But this cannot be true if &quot;a&#x2F;0&quot; is in the field, because for every x we have x * 0 = 0. Thus &quot;a&#x2F;0&quot; is not in the field.<p>Consider &quot;a&#x2F;0&quot; with a=0. Then &quot;a&#x2F;0&quot; * 0 = 0. Any member of the field satisfies this equation, because for every x we have x * 0 = 0. So, &quot;a&#x2F;0&quot; could be any member of the field. Our definition of division does not determine &quot;0&#x2F;0&quot;.<p>Whether you can assign &quot;1&#x2F;0&quot; to a member of the field (such as 0) depends on how you define division.</div><br/></div></div><div id="42290945" class="c"><input type="checkbox" id="c-42290945" checked=""/><div class="controls bullet"><span class="by">_Sycamore</span><span>|</span><a href="#42292632">prev</a><span>|</span><a href="#42290717">next</a><span>|</span><label class="collapse" for="c-42290945">[-]</label><label class="expand" for="c-42290945">[2 more]</label></div><br/><div class="children"><div class="content">My head-canon with dividing by zero is that 1&#x2F;0 = undefined and 1&#x2F;-0 = -undefined, and that&#x27;s where I leave it because anything less funny than that seems like an impractical answer.</div><br/><div id="42290954" class="c"><input type="checkbox" id="c-42290954" checked=""/><div class="controls bullet"><span class="by">maxk42</span><span>|</span><a href="#42290945">parent</a><span>|</span><a href="#42290717">next</a><span>|</span><label class="collapse" for="c-42290954">[-]</label><label class="expand" for="c-42290954">[1 more]</label></div><br/><div class="children"><div class="content">0 &#x2F; 0 = Any number<p>non-zero &#x2F; 0 = No number</div><br/></div></div></div></div><div id="42290717" class="c"><input type="checkbox" id="c-42290717" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42290945">prev</a><span>|</span><a href="#42294303">next</a><span>|</span><label class="collapse" for="c-42290717">[-]</label><label class="expand" for="c-42290717">[2 more]</label></div><br/><div class="children"><div class="content">Note 1&#x2F;0 (or x&#x2F;0 with x&gt;0) isn&#x27;t undefined or an exception in 754 FP math, it&#x27;s +infinity. It&#x27;s 0&#x2F;0 that&#x27;s the problem. Defining 1&#x2F;0=0 isn&#x27;t really helpful imho.</div><br/><div id="42290924" class="c"><input type="checkbox" id="c-42290924" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#42290717">parent</a><span>|</span><a href="#42294303">next</a><span>|</span><label class="collapse" for="c-42290924">[-]</label><label class="expand" for="c-42290924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Defining 1&#x2F;0=0 isn&#x27;t really helpful imho<p>But it&#x27;s quite a nice way to mask program bugs.</div><br/></div></div></div></div><div id="42294303" class="c"><input type="checkbox" id="c-42294303" checked=""/><div class="controls bullet"><span class="by">MaxGripe</span><span>|</span><a href="#42290717">prev</a><span>|</span><a href="#42290833">next</a><span>|</span><label class="collapse" for="c-42294303">[-]</label><label class="expand" for="c-42294303">[1 more]</label></div><br/><div class="children"><div class="content">Not zero. Infinity</div><br/></div></div><div id="42290833" class="c"><input type="checkbox" id="c-42290833" checked=""/><div class="controls bullet"><span class="by">d_tr</span><span>|</span><a href="#42294303">prev</a><span>|</span><a href="#42293153">next</a><span>|</span><label class="collapse" for="c-42290833">[-]</label><label class="expand" for="c-42290833">[5 more]</label></div><br/><div class="children"><div class="content">Whatever as long as the name does not imply that these are integers, because then it is just wrong. The same holds for overflowing results being clamped or resulting in smaller or negative values due to wraparound. These are not integers.<p>There is only one correct behavior for something named &quot;int&quot;. Give the correct result or throw an error.</div><br/><div id="42292627" class="c"><input type="checkbox" id="c-42292627" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#42290833">parent</a><span>|</span><a href="#42290898">next</a><span>|</span><label class="collapse" for="c-42292627">[-]</label><label class="expand" for="c-42292627">[1 more]</label></div><br/><div class="children"><div class="content">Agree `int` is the problem. This implies we&#x27;re doing math over all integers, when in most languages what we&#x27;re actually working with are bounded integers. (There&#x27;s some counter-examples, Python and Haskell come to mind.) Calling them sane names like `i32` and `i64` makes it clear that overflow exists.</div><br/></div></div><div id="42290898" class="c"><input type="checkbox" id="c-42290898" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#42290833">parent</a><span>|</span><a href="#42292627">prev</a><span>|</span><a href="#42293153">next</a><span>|</span><label class="collapse" for="c-42290898">[-]</label><label class="expand" for="c-42290898">[3 more]</label></div><br/><div class="children"><div class="content">Those are all integers. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Modular_arithmetic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Modular_arithmetic</a> - &quot;The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801.&quot; They have been integers for over 200 years now.</div><br/><div id="42291017" class="c"><input type="checkbox" id="c-42291017" checked=""/><div class="controls bullet"><span class="by">d_tr</span><span>|</span><a href="#42290833">root</a><span>|</span><a href="#42290898">parent</a><span>|</span><a href="#42290949">next</a><span>|</span><label class="collapse" for="c-42291017">[-]</label><label class="expand" for="c-42291017">[1 more]</label></div><br/><div class="children"><div class="content">But if you write a + b and the result is wrapped around or saturated, it&#x27;s not integer addition. It&#x27;s something else and should be written in another way in code and have a different name. I am aware of modular arithmetic.<p>If you have a type named &quot;int&quot; with an operation called &quot;addition&quot;, and that operation is not actually integer addition... it&#x27;s wrong.</div><br/></div></div><div id="42290949" class="c"><input type="checkbox" id="c-42290949" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42290833">root</a><span>|</span><a href="#42290898">parent</a><span>|</span><a href="#42291017">prev</a><span>|</span><a href="#42293153">next</a><span>|</span><label class="collapse" for="c-42290949">[-]</label><label class="expand" for="c-42290949">[1 more]</label></div><br/><div class="children"><div class="content">Wrapping around is correct integer behavior; clamping (&quot;5 + 1 = 5&quot;) isn&#x27;t. Clamping implies immediately that all positive numbers are equal to zero.</div><br/></div></div></div></div></div></div><div id="42293153" class="c"><input type="checkbox" id="c-42293153" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#42290833">prev</a><span>|</span><a href="#42292908">next</a><span>|</span><label class="collapse" for="c-42293153">[-]</label><label class="expand" for="c-42293153">[1 more]</label></div><br/><div class="children"><div class="content">In uxn, the result of division of anything by zero is defined as zero (there are no error conditions in uxn). I did not know that Pony is also doing that. This is not a proper &quot;division&quot; (since it is not always a multiplicative inverse operation), but it does not necessarily have to be (and, as another comment mentions, the integer division operator in many programming languages is not a proper &quot;division&quot; either); it is something else which might use a &quot;&#x2F;&quot; sign or the instruction name &quot;DIV&quot; or whatever.</div><br/></div></div><div id="42292908" class="c"><input type="checkbox" id="c-42292908" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42293153">prev</a><span>|</span><a href="#42292425">next</a><span>|</span><label class="collapse" for="c-42292908">[-]</label><label class="expand" for="c-42292908">[2 more]</label></div><br/><div class="children"><div class="content">Maybe division by zero should just not exist.<p>If you actually write 1&#x2F;0 in a manner that can be discovered through static analysis, that could just be a compile time error.<p>If you compute a zero, and then divide by it… I dunno. Probably what happened was the denominator rounded or truncated to zero. So, you actually have 1&#x2F;(0+-e), for some type-dependent e. You have an interval which contains a ton of valid values, why pick the <i>one very specific</i> invalid value?</div><br/><div id="42293102" class="c"><input type="checkbox" id="c-42293102" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42292908">parent</a><span>|</span><a href="#42292425">next</a><span>|</span><label class="collapse" for="c-42293102">[-]</label><label class="expand" for="c-42293102">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe division by zero should just not exist.<p>It does not.  It is undefined</div><br/></div></div></div></div><div id="42292425" class="c"><input type="checkbox" id="c-42292425" checked=""/><div class="controls bullet"><span class="by">dccsillag</span><span>|</span><a href="#42292908">prev</a><span>|</span><a href="#42293822">next</a><span>|</span><label class="collapse" for="c-42292425">[-]</label><label class="expand" for="c-42292425">[1 more]</label></div><br/><div class="children"><div class="content">I find it odd that all of the mathematicians cited at the end are actually pretty much CS people, working on proof assistants. Kinda renders that section pointless, IMO (though the comment by Isabelle&#x27;s author was interesting).<p>IMO, whether something like this makes sense is a separate matter. Personally I always just think of division in terms of multiplicative inverses, so I don&#x27;t see how defining division by zero helps other than perhaps making implementation easier in a proof assistant. But I&#x27;ve seen people say that there are some cases where having a&#x2F;0 = 0 works out nicely. I&#x27;m curious to know what these cases are, though.</div><br/></div></div><div id="42293822" class="c"><input type="checkbox" id="c-42293822" checked=""/><div class="controls bullet"><span class="by">ashoeafoot</span><span>|</span><a href="#42292425">prev</a><span>|</span><a href="#42292376">next</a><span>|</span><label class="collapse" for="c-42293822">[-]</label><label class="expand" for="c-42293822">[1 more]</label></div><br/><div class="children"><div class="content">So,it gives you a infinite list with binary system digit values, that produces a ranked infinity?</div><br/></div></div><div id="42292376" class="c"><input type="checkbox" id="c-42292376" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42293822">prev</a><span>|</span><a href="#42291152">next</a><span>|</span><label class="collapse" for="c-42292376">[-]</label><label class="expand" for="c-42292376">[1 more]</label></div><br/><div class="children"><div class="content">One megathread and a couple small ones. Others?<p><i>1 &#x2F; 0 = 0 (2018)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42167875">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42167875</a> - Nov 2024 (8 comments)<p><i>What is the best answer to divide by 0</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40210775">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40210775</a> - April 2024 (3 comments)<p><i>1&#x2F;0 = 0</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17736046">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17736046</a> - Aug 2018 (570 comments)</div><br/></div></div><div id="42291152" class="c"><input type="checkbox" id="c-42291152" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#42292376">prev</a><span>|</span><a href="#42290865">next</a><span>|</span><label class="collapse" for="c-42291152">[-]</label><label class="expand" for="c-42291152">[1 more]</label></div><br/><div class="children"><div class="content">Most definitions of division that I have seen use q * d + r = n if q is unique and abs(r)&lt;abs(d), which doesn&#x27;t require the definition of an inverse.  Rather, d that exist for n = 1 and r = 0 can be labelled q&#x27;s inverse but it doesn&#x27;t require a new definition.<p>Additionally, if inverses are defined as separate objects then what is 2 plus the inverse of 2?  It doesn&#x27;t simplify to 2.5 because there&#x27;s no addition axiom for numbers and multiplicative inverses, or for that matter any rules for inverses with inverses.  So you might have 1&#x2F;2 and 5&#x2F;10 but they&#x27;re not equal and can&#x27;t be multiplied together.</div><br/></div></div><div id="42290865" class="c"><input type="checkbox" id="c-42290865" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#42291152">prev</a><span>|</span><a href="#42290632">next</a><span>|</span><label class="collapse" for="c-42290865">[-]</label><label class="expand" for="c-42290865">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wondered what would happen if we defined &#x2F;0 as a new symbol, for example &#x27;z&#x27;. The same as we define sqrt(-1) as &#x27;i&#x27;. So if you can do 4*sqrt(-1)=4i, you could also do 4&#x2F;0 = 4z. These two seems similar, as in taking something that should not exist, and just letting it exists in a totally different and orthogonal domain.<p>I tried once to investigate the implications, but it quickly became far more complex that with &#x27;i&#x27; and never went far. Still intrigued if this is somewhat interesting or a total time loss though.</div><br/><div id="42291157" class="c"><input type="checkbox" id="c-42291157" checked=""/><div class="controls bullet"><span class="by">ganzuul</span><span>|</span><a href="#42290865">parent</a><span>|</span><a href="#42291025">next</a><span>|</span><label class="collapse" for="c-42291157">[-]</label><label class="expand" for="c-42291157">[1 more]</label></div><br/><div class="children"><div class="content">1,000,000 grains of sand is a heap of sand (Premise 1)
A heap of sand minus one grain is still a heap. (Premise 2)
- <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sorites_paradox" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sorites_paradox</a><p>So one grain of sand is a heap and then when you remove that grain the heap disappears, but you only removed one grain from a heap so this is impossible because it is discontinuous. One solution is to wrap the problem in fuzzy logic with a &#x27;heapness&#x27; measure.<p>Generalizing this type of solution we have a practice of wrapping paradoxes in other forms of logic. You would define an interface between these logics. For example in Trits (0,1,UNKNOWN) you could define an interface where you can change the type of NOT-UNKNOWN from Trit to Boolean. This would return at least some part of the entropy to the original domain, preserving a continuity. Wave Function Collapse is another example of translating from one logical domain to another.</div><br/></div></div><div id="42291005" class="c"><input type="checkbox" id="c-42291005" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#42290865">parent</a><span>|</span><a href="#42291025">prev</a><span>|</span><a href="#42292755">next</a><span>|</span><label class="collapse" for="c-42291005">[-]</label><label class="expand" for="c-42291005">[3 more]</label></div><br/><div class="children"><div class="content">In SQL, if you divide by zero, you get a NULL. If you divide by NULL, you get NULL (any operation involving a NULL yields NULL, even GROUP BY). I call it &quot;a black hole zero&quot;, if it touches anything, that thing becomes a black hole zero.<p>Some languages will wrap division by zero in a special type, a NaN (not a number). You can then reason on top if that NaN if you want to.<p>So, in a sense, there are some people already doing practical stuff with substituting &#x2F;0 for a new symbol.</div><br/><div id="42291200" class="c"><input type="checkbox" id="c-42291200" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#42290865">root</a><span>|</span><a href="#42291005">parent</a><span>|</span><a href="#42292755">next</a><span>|</span><label class="collapse" for="c-42291200">[-]</label><label class="expand" for="c-42291200">[2 more]</label></div><br/><div class="children"><div class="content">Does it? Under SQL standard or what engine? At least Postgres raises when dividing by zero.</div><br/><div id="42291233" class="c"><input type="checkbox" id="c-42291233" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#42290865">root</a><span>|</span><a href="#42291200">parent</a><span>|</span><a href="#42292755">next</a><span>|</span><label class="collapse" for="c-42291233">[-]</label><label class="expand" for="c-42291233">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right about division by zero. From SQL92:<p><pre><code>         4) The dyadic arithmetic operators &lt;plus sign&gt;, &lt;minus sign&gt;, &lt;as-
            terisk&gt;, and &lt;solidus&gt; (+, -, *, and &#x2F;, respectively) specify
            addition, subtraction, multiplication, and division, respec-
            tively. If the value of a divisor is zero, then an exception
            condition is raised: data exception-division by zero.
</code></pre>
However, the &quot;any operation involving NULL yields NULL&quot; is standard:<p><pre><code>         1) If the value of any &lt;numeric primary&gt; simply contained in a
            &lt;numeric value expression&gt; is the null value, then the result of
            the &lt;numeric value expression&gt; is the null value.
</code></pre>
<a href="https:&#x2F;&#x2F;www.contrib.andrew.cmu.edu&#x2F;~shadow&#x2F;sql&#x2F;sql1992.txt" rel="nofollow">https:&#x2F;&#x2F;www.contrib.andrew.cmu.edu&#x2F;~shadow&#x2F;sql&#x2F;sql1992.txt</a><p>So, dividing by NULL is allowed and yields NULL. Dividing by zero yielding NULL is non-standard (I used it though).</div><br/></div></div></div></div></div></div><div id="42292755" class="c"><input type="checkbox" id="c-42292755" checked=""/><div class="controls bullet"><span class="by">sgentle</span><span>|</span><a href="#42290865">parent</a><span>|</span><a href="#42291005">prev</a><span>|</span><a href="#42290920">next</a><span>|</span><label class="collapse" for="c-42292755">[-]</label><label class="expand" for="c-42292755">[2 more]</label></div><br/><div class="children"><div class="content">You might be interested in the hyperreal numbers, which sound a bit like the avenue you were exploring.</div><br/><div id="42293654" class="c"><input type="checkbox" id="c-42293654" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42290865">root</a><span>|</span><a href="#42292755">parent</a><span>|</span><a href="#42290920">next</a><span>|</span><label class="collapse" for="c-42293654">[-]</label><label class="expand" for="c-42293654">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t divide by zero in the hyperreals any more than you can in the reals.</div><br/></div></div></div></div><div id="42290939" class="c"><input type="checkbox" id="c-42290939" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42290865">parent</a><span>|</span><a href="#42290920">prev</a><span>|</span><a href="#42290632">next</a><span>|</span><label class="collapse" for="c-42290939">[-]</label><label class="expand" for="c-42290939">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just a waste of time. The reason no value is conventionally assigned for division by zero is that assigning a consistent value doesn&#x27;t help. When you want a value for that kind of expression at all, you&#x27;ll want different values in different expressions.</div><br/></div></div></div></div><div id="42290632" class="c"><input type="checkbox" id="c-42290632" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#42290865">prev</a><span>|</span><a href="#42294112">next</a><span>|</span><label class="collapse" for="c-42290632">[-]</label><label class="expand" for="c-42290632">[6 more]</label></div><br/><div class="children"><div class="content">Q on this post: 
Is the field rule &quot;Every element Except Zero has ... &quot; (the 9th rule) defined with respect to the additive identity &quot;zero&quot; or the magical other undefined &quot;Zero&quot; that is the number we&#x27;re all familiar with?<p>If so, how weirdly arbitrary that the additive zero is omitted for all multiplicative inverse definitions. (At least it seems to me). I always figured this was a consequence of our number systems, not of all fields.</div><br/><div id="42290789" class="c"><input type="checkbox" id="c-42290789" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42290632">parent</a><span>|</span><a href="#42294112">next</a><span>|</span><label class="collapse" for="c-42290789">[-]</label><label class="expand" for="c-42290789">[5 more]</label></div><br/><div class="children"><div class="content">I am not familiar with any &quot;magical other undefined Zero&quot;. Please familiarize me :-)<p>What is your, uh, <i>definition</i> of this <i>undefined* number you are familiar with?</i></div><br/><div id="42290925" class="c"><input type="checkbox" id="c-42290925" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#42290632">root</a><span>|</span><a href="#42290789">parent</a><span>|</span><a href="#42294112">next</a><span>|</span><label class="collapse" for="c-42290925">[-]</label><label class="expand" for="c-42290925">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Every element EXCEPT 0 has a multiplicative inverse, a⁻, such that a*a⁻ = 1.<p>What is &quot;0&quot;? It&#x27;s not defined in the axioms other than additive zero. Or is it multiplicative zero? (1?). Is it the number zero?<p>If it is the additive zero defined in axiom (3), then it just seems weird to me that additive zero is undefined for multiplicative inverse for all fields always and forever.<p>If it is the number zero, then how does that generalize to other fields?<p>If the answer is &quot;Numbers are the first field and all fields generalize that&quot;, then I suppose we are referring to the number (0), and that&#x27;s fine, as other fields are welcome to define their own larger definition of zero that includes the number (0) ... ?</div><br/><div id="42291117" class="c"><input type="checkbox" id="c-42291117" checked=""/><div class="controls bullet"><span class="by">clipsy</span><span>|</span><a href="#42290632">root</a><span>|</span><a href="#42290925">parent</a><span>|</span><a href="#42291020">next</a><span>|</span><label class="collapse" for="c-42291117">[-]</label><label class="expand" for="c-42291117">[1 more]</label></div><br/><div class="children"><div class="content">The definition is that it is the additive identity for the field; eg x + a = x no matter what value x takes and what field you are considering. This must be unique; suppose a and b are both additive identities for a field, then b + a = b and a + b = a, but commutativity gives us a + b = b + a, resulting in a = b.<p>The reason the additive identity cannot have a multiplicative inverse is likewise fairly straightforward: once again using `a` as our additive identity we have y.(x+a) = y.x for all x, y in our field; distributing on the LHS gives y.x + y.a = y.x for all x, y in our field; subtracting y.x from both sides finally gives us y.a = 0 for all y in our field.<p>You would need to relax one or more of the field axioms to have a structure in which the additive identity can have a multiplicative inverse. I&#x27;m not aware of any algebraic structure of particular interest that would allow a multiplicative inverse of the additive identity, but in general if you&#x27;re interested in reading more on this sort of thing I&#x27;d recommend reading about rings, commutative rings, and division algebras.</div><br/></div></div><div id="42291020" class="c"><input type="checkbox" id="c-42291020" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#42290632">root</a><span>|</span><a href="#42290925">parent</a><span>|</span><a href="#42291117">prev</a><span>|</span><a href="#42294112">next</a><span>|</span><label class="collapse" for="c-42291020">[-]</label><label class="expand" for="c-42291020">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Zero&quot; is just a specific element of the field which satisfies being the additive identity as well as the rest of the properties of a field where 0 is mentioned. When the rest of the axioms refer to &quot;zero&quot; they refer to the exact same element of the set that is also the additive identity.<p>It&#x27;s not the &quot;number zero&quot; because a field does not care about numbers, it&#x27;s just elements of a set (which might be numbers like in R&#x27;s case).<p>1 is not &quot;multiplicative zero&quot;, it&#x27;s the &quot;multiplicative identity&quot;.<p>0 and 1 are just the shorthand we give for those elements. because those are the symbols we use in R which is the most common field we deal with in everyday life.<p>Or am I misunderstanding your question?</div><br/><div id="42291050" class="c"><input type="checkbox" id="c-42291050" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#42290632">root</a><span>|</span><a href="#42291020">parent</a><span>|</span><a href="#42294112">next</a><span>|</span><label class="collapse" for="c-42291050">[-]</label><label class="expand" for="c-42291050">[1 more]</label></div><br/><div class="children"><div class="content">Nope that&#x27;s the answer. Additive zero is the only zero.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42294112" class="c"><input type="checkbox" id="c-42294112" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#42290632">prev</a><span>|</span><a href="#42290670">next</a><span>|</span><label class="collapse" for="c-42294112">[-]</label><label class="expand" for="c-42294112">[1 more]</label></div><br/><div class="children"><div class="content">The only thing that truly matters is this:<p>When software engineers make mistakes dividing by 0 and end up with Exceptions being raised or NaNs being output, they&#x27;ll usually blame themselves.<p>When the results are wrong numbers all over the place, they&#x27;ll blame the language.<p>There are 2 cases when people are going to &quot;use&quot; x&#x2F;0:<p>1. They made a mistake.<p>2. They KNOW that x&#x2F;0 returns 0 and they take it as a shortcut for (y == 0 ? 0 : x&#x2F;y)<p>Is that shortcut useful? No. Is it dangerous? Yes. Hence, this is a bad idea.</div><br/></div></div><div id="42290670" class="c"><input type="checkbox" id="c-42290670" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42294112">prev</a><span>|</span><a href="#42290617">next</a><span>|</span><label class="collapse" for="c-42290670">[-]</label><label class="expand" for="c-42290670">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It’s saying that Pony is mathematically wrong. This is objectively false.<p>Pff. The author wants to show off their knowledge of fields by defining a &quot;division&quot; operator where 1&#x2F;0 = 0. Absolutely fine. I could define &quot;addition&quot; where 1 + 2 = 7. Totally fine.<p>What I <i>can&#x27;t</i> do is write a programming language where I use the universally recognised &quot;+&quot; symbols for this operation, call it &quot;addition&quot; and claim that it&#x27;s totally reasonable.<p>Under the <i>standard definition of division implied by &#x27;&#x2F;&#x27;</i> it is mathematically wrong.<p>What they obviously should have done is use a different symbol, say `&#x2F;!`. Obviously now they&#x27;ve done the classic thing and made the obvious choice unsafe and the safe choice unobvious (`&#x2F;?`).</div><br/><div id="42290858" class="c"><input type="checkbox" id="c-42290858" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#42290670">parent</a><span>|</span><a href="#42291538">next</a><span>|</span><label class="collapse" for="c-42290858">[-]</label><label class="expand" for="c-42290858">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>What I can&#x27;t do is write a programming language where I use the universally recognised &quot;+&quot; symbols for this operation, call it &quot;addition&quot; and claim that it&#x27;s totally reasonable.</i><p>As a programmer, you&#x27;re right: we have standard expectations around how computers do mathematics.<p>As a pedant: Why not? Commonly considered &#x27;reasonable&#x27; things surrounding addition in programming languages are:<p>* (Particularly for older programming languages): If we let Z = X + Y, where X &gt; 0 and Y &gt; 0, any of the following can be true: Z &lt; X, Z &lt; Y, (Z - X) &lt; Y. Which we commonly know as &#x27;wrap around&#x27;.<p>* I haven&#x27;t yet encountered a language which solves this issue: X + Y has no result for sufficiently large values for X and Y (any integer whose binary representation exceeds the storage capacity of the machine the code runs on will do). Depending on whether or not the language supports integer promotion and arbitrary precision integers the values of X and Y don&#x27;t even have to be particularly large.<p>* Non-integer addition. You&#x27;re lucky if 0.3 = 0.1 + 0.2, good luck trying to to get anything sensible out of X + 0.2, where X = (2 ^ 128) + 0.1.</div><br/><div id="42294106" class="c"><input type="checkbox" id="c-42294106" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42290670">root</a><span>|</span><a href="#42290858">parent</a><span>|</span><a href="#42291538">next</a><span>|</span><label class="collapse" for="c-42294106">[-]</label><label class="expand" for="c-42294106">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I haven&#x27;t yet encountered a language which solves this issue:<p>Well, Python supports arbitrary precision integers. And some other niche languages (Sail is one I know).<p>I don&#x27;t think &quot;running out of memory&quot; counts as a caveat because it still won&#x27;t give the wrong answer.<p>For floats, I don&#x27;t think it&#x27;s actually unreasonable to use different operators there. I vaguely recall some languages use +. or .+ or something for float addition.<p>Fair point about wrapping.</div><br/></div></div></div></div><div id="42291538" class="c"><input type="checkbox" id="c-42291538" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#42290670">parent</a><span>|</span><a href="#42290858">prev</a><span>|</span><a href="#42290617">next</a><span>|</span><label class="collapse" for="c-42291538">[-]</label><label class="expand" for="c-42291538">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a question of usefulness. If in your problem domain &quot;1+2=7&quot; is the most useful definition, then by all means do that. Why does the semicolon terminate statements and not the universally agreed upon period? Why does the period denote member access? Why is multiplication not denoted by the universally agreed [middle dot &#x2F; cross character] (strike out the one that is not universally agreed in your country). The design and semantics of a programming language ought to be in service of the programs we wish to express, and informed by our decades of experience in human ergonomics. Blind reverence to religions of yore does us no good. Mathematical notation itself has gone through centuries of development and is not universal, with papers within the same field using different notation depending on what strikes the author&#x27;s fancy. To treat it as sacred and immutable is to behave most un-mathematically. Hell, you can still get into a nice hours-long argument about whether or not the set of natural numbers includes zero or not (neither side will accept defeat, even though there is clearly a right answer)!</div><br/></div></div></div></div><div id="42290617" class="c"><input type="checkbox" id="c-42290617" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#42290670">prev</a><span>|</span><a href="#42291014">next</a><span>|</span><label class="collapse" for="c-42290617">[-]</label><label class="expand" for="c-42290617">[1 more]</label></div><br/><div class="children"><div class="content">It’s unexpected and that makes it dangerous.</div><br/></div></div><div id="42291014" class="c"><input type="checkbox" id="c-42291014" checked=""/><div class="controls bullet"><span class="by">ganzuul</span><span>|</span><a href="#42290617">prev</a><span>|</span><a href="#42290740">next</a><span>|</span><label class="collapse" for="c-42291014">[-]</label><label class="expand" for="c-42291014">[1 more]</label></div><br/><div class="children"><div class="content">In the computational domain we hold entropy in high esteem. Arbitrarily assigning a value of 0 does not preserve entropy. We could return a promise that eventually we will not overflow if we get to be very very clever (arbitrary time) so that we can maintain purity.</div><br/></div></div><div id="42290740" class="c"><input type="checkbox" id="c-42290740" checked=""/><div class="controls bullet"><span class="by">blueblimp</span><span>|</span><a href="#42291014">prev</a><span>|</span><a href="#42290661">next</a><span>|</span><label class="collapse" for="c-42290740">[-]</label><label class="expand" for="c-42290740">[1 more]</label></div><br/><div class="children"><div class="content">This sort of convenient semi-arbitrary extension of a partial function is ubiquitous in Lean 4 mathlib, the most active mathematics formalization project today. It turns out that the most convenient way to do informal math and formal math differ in this aspect.</div><br/></div></div><div id="42290661" class="c"><input type="checkbox" id="c-42290661" checked=""/><div class="controls bullet"><span class="by">jmclnx</span><span>|</span><a href="#42290740">prev</a><span>|</span><a href="#42290967">next</a><span>|</span><label class="collapse" for="c-42290661">[-]</label><label class="expand" for="c-42290661">[1 more]</label></div><br/><div class="children"><div class="content">I set this to zero and print a warning&#x2F;error about divide by zero on the log with data that caused it.  That log would be sent to the business person worry about.<p>If they ignore it, I do not care, it is the business problem anyway.<p>Worked for me for decades :)</div><br/></div></div><div id="42290967" class="c"><input type="checkbox" id="c-42290967" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#42290661">prev</a><span>|</span><a href="#42291319">next</a><span>|</span><label class="collapse" for="c-42290967">[-]</label><label class="expand" for="c-42290967">[1 more]</label></div><br/><div class="children"><div class="content">MySQL has ignored math rules for ages as well. 1&#x2F;0 yields NULL there</div><br/></div></div><div id="42291319" class="c"><input type="checkbox" id="c-42291319" checked=""/><div class="controls bullet"><span class="by">daft_pink</span><span>|</span><a href="#42290967">prev</a><span>|</span><a href="#42290605">next</a><span>|</span><label class="collapse" for="c-42291319">[-]</label><label class="expand" for="c-42291319">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn’t the logical value when dividing by zero be infinity, because zero can go into any number an infinite number of times?</div><br/><div id="42291475" class="c"><input type="checkbox" id="c-42291475" checked=""/><div class="controls bullet"><span class="by">amavect</span><span>|</span><a href="#42291319">parent</a><span>|</span><a href="#42293682">next</a><span>|</span><label class="collapse" for="c-42291475">[-]</label><label class="expand" for="c-42291475">[1 more]</label></div><br/><div class="children"><div class="content">Saying 1&#x2F;0=∞ means creating a new number system with ∞ as a number. Now you have to figure out all operations with ∞, like -1*∞, 0*∞, ∞*∞, ∞&#x2F;∞, or ∞-∞.<p>Making wrong definitions creates contradictions. With 1*x=x, ∞&#x2F;∞=1, the associative property x*(y&#x2F;z)=(x*y)&#x2F;z, and ∞*∞=∞:<p>∞ = ∞*1 = ∞*(∞&#x2F;∞) = (∞*∞)&#x2F;∞ = ∞&#x2F;∞ = 1</div><br/></div></div><div id="42293682" class="c"><input type="checkbox" id="c-42293682" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42291319">parent</a><span>|</span><a href="#42291475">prev</a><span>|</span><a href="#42290605">next</a><span>|</span><label class="collapse" for="c-42293682">[-]</label><label class="expand" for="c-42293682">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn’t the logical value when dividing by zero be infinity, because zero can go into any number an infinite number of times?<p>No, just look at the graph of f(x) = 1&#x2F;x. +inf can&#x27;t work.<p>It can work if you assume that no numbers are ever negative.</div><br/></div></div></div></div><div id="42290605" class="c"><input type="checkbox" id="c-42290605" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42291319">prev</a><span>|</span><a href="#42292942">next</a><span>|</span><label class="collapse" for="c-42290605">[-]</label><label class="expand" for="c-42290605">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;xenaproject.wordpress.com&#x2F;2020&#x2F;07&#x2F;05&#x2F;division-by-zero-in-type-theory-a-faq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xenaproject.wordpress.com&#x2F;2020&#x2F;07&#x2F;05&#x2F;division-by-zer...</a><p>explains Lean&#x27;s behavior. Basically, you use a goofy alternate definition of division (and sqrt, and more), and to compensate you have to assume (or prove based on assumptions) that the things you will divide by are never zero.<p>Hillel&#x27;s pedantry is ill-taken, though, because he starts off with a false accusation that the headline tweet was insulting anyone.<p>Also, 1&#x2F;0=0&quot; is sound only if you <i>change the field axiom.of division</i>, which is fine, but quite rather hiding the ball. If you add &quot; 1&#x2F;0=0&quot; as an axiom to the usual field axioms, you do get an unsound system.</div><br/></div></div><div id="42292942" class="c"><input type="checkbox" id="c-42292942" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42290605">prev</a><span>|</span><a href="#42293074">next</a><span>|</span><label class="collapse" for="c-42292942">[-]</label><label class="expand" for="c-42292942">[1 more]</label></div><br/><div class="children"><div class="content">I despise that answer because it’s so context-dependent. What’s? 10&#x2F;10? 1. 5&#x2F;5? 1. .3&#x2F;.3? 1. .0000000578&#x2F;.0000000578? 1.<p>Ergo, x&#x2F;x=1, so 0&#x2F;0=1. You can use the same logic for x&#x2F;0=any rational number.<p>Defining x&#x2F;0=0 is impossibly arbitrary.</div><br/></div></div><div id="42293074" class="c"><input type="checkbox" id="c-42293074" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42292942">prev</a><span>|</span><label class="collapse" for="c-42293074">[-]</label><label class="expand" for="c-42293074">[1 more]</label></div><br/><div class="children"><div class="content">Division has an intuitive meaning:  A divided by B is the number of  Bs in A.<p>That is an intuition why division by zero is undefined.<p>Defining it arbitrarily is uninteresting.<p>Disapointing</div><br/></div></div></div></div></div></div></div></body></html>