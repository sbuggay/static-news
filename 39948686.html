<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712394053291" as="style"/><link rel="stylesheet" href="styles.css?v=1712394053291"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cockroachlabs.com/blog/why-cockroachdb-doesnt-use-evalplanqual/">Why CockroachDB doesn&#x27;t use EvalPlanQual</a> <span class="domain">(<a href="https://www.cockroachlabs.com">www.cockroachlabs.com</a>)</span></div><div class="subtext"><span>michae2</span> | <span>35 comments</span></div><br/><div><div id="39951034" class="c"><input type="checkbox" id="c-39951034" checked=""/><div class="controls bullet"><span class="by">npstr</span><span>|</span><a href="#39949057">next</a><span>|</span><label class="collapse" for="c-39951034">[-]</label><label class="expand" for="c-39951034">[1 more]</label></div><br/><div class="children"><div class="content">Idk to me this looks like a modeling issue of the data. There should be a team table that contains team specific data such as the skill level, then these two queries wouldn&#x27;t run into any problems.</div><br/></div></div><div id="39949057" class="c"><input type="checkbox" id="c-39949057" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39951034">prev</a><span>|</span><a href="#39948981">next</a><span>|</span><label class="collapse" for="c-39949057">[-]</label><label class="expand" for="c-39949057">[3 more]</label></div><br/><div class="children"><div class="content">Author here. We&#x27;ve spent the past year adding read committed isolation to CockroachDB.<p>There were many interesting design decisions, such as:<p>- whether to use multiple snapshots or a single snapshot per statement<p>- how to handle read uncertainty intervals<p>- how to incorporate SELECT FOR UPDATE locking into Raft<p>- how to handle SELECT FOR UPDATE subqueries<p>- how to prevent lost update anomalies between two UPDATEs<p>Some of the gory details are in the public RFC: <a href="https:&#x2F;&#x2F;github.com&#x2F;cockroachdb&#x2F;cockroach&#x2F;blob&#x2F;master&#x2F;docs&#x2F;RFCS&#x2F;20230122_read_committed_isolation.md">https:&#x2F;&#x2F;github.com&#x2F;cockroachdb&#x2F;cockroach&#x2F;blob&#x2F;master&#x2F;docs&#x2F;RF...</a><p>This blog post just discusses the last point, but please AMA.</div><br/><div id="39950217" class="c"><input type="checkbox" id="c-39950217" checked=""/><div class="controls bullet"><span class="by">sbstp</span><span>|</span><a href="#39949057">parent</a><span>|</span><a href="#39948981">next</a><span>|</span><label class="collapse" for="c-39950217">[-]</label><label class="expand" for="c-39950217">[2 more]</label></div><br/><div class="children"><div class="content">Why is Cockroach adding READ COMMITTED? Is using a lower level of isolation better for performance or just reduces the amount of serialization errors and retries that need to be done?</div><br/><div id="39950315" class="c"><input type="checkbox" id="c-39950315" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39949057">root</a><span>|</span><a href="#39950217">parent</a><span>|</span><a href="#39948981">next</a><span>|</span><label class="collapse" for="c-39950315">[-]</label><label class="expand" for="c-39950315">[1 more]</label></div><br/><div class="children"><div class="content">The main motivation is reduce serialization errors, for applications that can handle the weaker isolation level. Especially for applications that were previously running fine under RC on another database.</div><br/></div></div></div></div></div></div><div id="39948981" class="c"><input type="checkbox" id="c-39948981" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#39949057">prev</a><span>|</span><a href="#39949769">next</a><span>|</span><label class="collapse" for="c-39948981">[-]</label><label class="expand" for="c-39948981">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s often talked about how new sql databases offer better scalability than standard SQL databases, but I think it&#x27;s maybe sometimes underappreciated how (some, not all) of them are also much simpler in terms of their consistency models.<p>I&#x27;d speculate this is because postgres and friends try to eek out every bit of single node performance (which helps with single row throughout and overall throughout, which is obviously much better for them than newsql) but the scalability of new SQL databases might allow them to prefer easy consistency over single node performance.<p>Possibly this is also just the passage of time benefiting newer systems.</div><br/><div id="39950258" class="c"><input type="checkbox" id="c-39950258" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#39948981">parent</a><span>|</span><a href="#39949510">next</a><span>|</span><label class="collapse" for="c-39950258">[-]</label><label class="expand" for="c-39950258">[1 more]</label></div><br/><div class="children"><div class="content">Read committed is explicitly asking for hard mode. If you want a simple life stick with Serializable as always. It took years before people found anomalies in Repeatable Read in Postgres. This stuff is hard even for world class researchers.</div><br/></div></div><div id="39949510" class="c"><input type="checkbox" id="c-39949510" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#39948981">parent</a><span>|</span><a href="#39950258">prev</a><span>|</span><a href="#39949769">next</a><span>|</span><label class="collapse" for="c-39949510">[-]</label><label class="expand" for="c-39949510">[1 more]</label></div><br/><div class="children"><div class="content">Even more generally, distributed systems can find simpler solutions to things like &quot;raise the throughput ceiling&quot;, and &quot;handle disk failure&quot;, and &quot;handle power failure&quot; than single-box systems. This is for the simple reason that they have more options: beyond the constraints of a box, resource allocation is more flexible, failures less correlated, etc. That allows modern distributed databases to simply avoid some of the super hard problems that prior databases had to solve. Efficiency is still important, but the thing to optimize is mean system efficiency, not the peak performance of a handful of super hot boxes.<p>There&#x27;s also the fact that decades of DB research have brought techniques and approaches that beat old ones, and retrofitting existing systems with them can be hard (e.g. see the efforts to remove some of the sharp edges of PG&#x27;s MVCC behavior and how hard they&#x27;ve turned out to be).</div><br/></div></div></div></div><div id="39949769" class="c"><input type="checkbox" id="c-39949769" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#39948981">prev</a><span>|</span><a href="#39949337">next</a><span>|</span><label class="collapse" for="c-39949769">[-]</label><label class="expand" for="c-39949769">[3 more]</label></div><br/><div class="children"><div class="content">How does the CockroachDB approach not deadlock? Surely retrying could encounter a situation where two competing UPDATE will lock rows in different order, and no amount of retrying will unlock the required rows, right?</div><br/><div id="39950474" class="c"><input type="checkbox" id="c-39950474" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39949769">parent</a><span>|</span><a href="#39950366">next</a><span>|</span><label class="collapse" for="c-39950474">[-]</label><label class="expand" for="c-39950474">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good question. For simple UPDATEs, CockroachDB always executes in a deterministic, serial order and so it&#x27;s likely the rows will be locked in the same order by any competing updates. (This can be confirmed by looking at the query plans.) Complex UPDATEs using joins and subqueries will need explicit ORDER BY to always lock in the same order.<p>If an UPDATE has to retry halfway through, locks are held across the retry to help the system make progress. But as you point out, this could cause lock acquisition to happen in an unexpected order if new rows qualify during a retry. So far we haven&#x27;t run into this, but we might need to provide an option for an UPDATE to drop locks on retry if deadlock turns into a bigger problem than livelock. It depends on the workload.</div><br/></div></div><div id="39950366" class="c"><input type="checkbox" id="c-39950366" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#39949769">parent</a><span>|</span><a href="#39950474">prev</a><span>|</span><a href="#39949337">next</a><span>|</span><label class="collapse" for="c-39950366">[-]</label><label class="expand" for="c-39950366">[1 more]</label></div><br/><div class="children"><div class="content">I wondered this too and found this in the docs[0]:<p><pre><code>  Transactions at all isolation levels are subject to lock contention, where a transaction attempts to lock a row that is already locked by a write or
  locking read. In such cases, the later transaction is blocked until the earlier transaction commits or rolls back, thus releasing its lock on the row.
  Lock contention that produces a deadlock between two transactions will result in a transaction abort and a 40001 error
  (ABORT_REASON_ABORTED_RECORD_FOUND or ABORT_REASON_PUSHER_ABORTED) returned to the client.
</code></pre>
So looks like you still get a good old 40001 error just like with SERIALIZABLE isolation.<p>[0] - <a href="https:&#x2F;&#x2F;www.cockroachlabs.com&#x2F;docs&#x2F;stable&#x2F;read-committed#read-committed-transaction-behavior" rel="nofollow">https:&#x2F;&#x2F;www.cockroachlabs.com&#x2F;docs&#x2F;stable&#x2F;read-committed#rea...</a></div><br/></div></div></div></div><div id="39949337" class="c"><input type="checkbox" id="c-39949337" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#39949769">prev</a><span>|</span><a href="#39949585">next</a><span>|</span><label class="collapse" for="c-39949337">[-]</label><label class="expand" for="c-39949337">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m having trouble with the example given.<p>If `UPDATE player SET level = &#x27;AA&#x27; WHERE team = &#x27;Gophers&#x27;;` is executed before the player swap, then why should &quot;Stonebreaker&quot; be upgraded to &quot;AA&quot;? I&#x27;d be pretty mad at my database if I sent those 2 queries <i>in sequence</i> and my DB decided to re-order them.<p>The sleep actually really complicates things here. I understand some queries run slower than others and the sleep is a useful tool to artificially slow things down, but now I don&#x27;t know I don&#x27;t know if I should interpret that as one command or two. If `WITH sleep AS (SELECT pg_sleep(5))
    UPDATE player SET level = &#x27;AA&#x27; FROM sleep WHERE team = &#x27;Gophers&#x27;;` is atomic then I&#x27;d expect it to put a lock on the 3 Gophers (which doesn&#x27;t include Stonebreaker), wait the 5 seconds and then complete the update. The player swap would be blocked for those 5 seconds because it touches a row that&#x27;s being updated.</div><br/><div id="39950603" class="c"><input type="checkbox" id="c-39950603" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39949337">parent</a><span>|</span><a href="#39949542">next</a><span>|</span><label class="collapse" for="c-39950603">[-]</label><label class="expand" for="c-39950603">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If `UPDATE player SET level = &#x27;AA&#x27; WHERE team = &#x27;Gophers&#x27;;` is executed before the player swap, then why should &quot;Stonebreaker&quot; be upgraded to &quot;AA&quot;? I&#x27;d be pretty mad at my database if I sent those 2 queries in sequence and my DB decided to re-order them.<p>It’s easy to miss but in the swap query the levels also get swapped. Because — and it’s harder to miss but easy to skip over — given what constraint 2 says the level is actually a team level, not a player level.<p>So in a seqcst view, either the team’s players get upgraded to AA then the players’ levels get swapped during the exchange, or the players get exchanged then the team’s players get upgraded.<p>In both sequences you end up with Stonebaker as an AA gopher and Lamport as an A dolphin.</div><br/><div id="39951018" class="c"><input type="checkbox" id="c-39951018" checked=""/><div class="controls bullet"><span class="by">npstr</span><span>|</span><a href="#39949337">root</a><span>|</span><a href="#39950603">parent</a><span>|</span><a href="#39949542">next</a><span>|</span><label class="collapse" for="c-39951018">[-]</label><label class="expand" for="c-39951018">[1 more]</label></div><br/><div class="children"><div class="content">&gt; given what constraint 2 says the level is actually a team level, not a player level.<p>Then it&#x27;s bad unnormalized data design that is the problem here. If that is a team level, it should be in the team table, not the player table.</div><br/></div></div></div></div><div id="39949542" class="c"><input type="checkbox" id="c-39949542" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39949337">parent</a><span>|</span><a href="#39950603">prev</a><span>|</span><a href="#39949585">next</a><span>|</span><label class="collapse" for="c-39949542">[-]</label><label class="expand" for="c-39949542">[1 more]</label></div><br/><div class="children"><div class="content">The timing of this example is tricky because the two update statements execute concurrently (which is only possible under read committed isolation; under serializable isolation it&#x27;s much more like what you&#x27;re describing).<p>Here&#x27;s a full timeline in PG (U1 for first update, U2 for second update):<p>0. U1 begins executing, establishes read snapshot, starts pg_sleep(5).<p>1. U2 runs to completion.<p>2. U1 wakes up after 5 sec, scans `player` using snapshot from step 0.<p>3. U1 filters `team = Gophers`, gets 4, 5, 6.<p>4. U1 locks 4, 5, 6.<p>5. U1 performs EvalQualPlan: re-scans latest version of those locked rows, which sees U2&#x27;s write to 4 but not to 3.<p>6. U1 performs EvalQualPlan: re-filters those locked rows using latest version, gets 5, 6.<p>7. U1 writes new versions.<p>CRDB is easier to reason about: after U1 wakes up from the sleep, it sees that it conflicts with U2 and simply retries the entire statement.</div><br/></div></div></div></div><div id="39949585" class="c"><input type="checkbox" id="c-39949585" checked=""/><div class="controls bullet"><span class="by">ngalstyan4</span><span>|</span><a href="#39949337">prev</a><span>|</span><a href="#39949125">next</a><span>|</span><label class="collapse" for="c-39949585">[-]</label><label class="expand" for="c-39949585">[1 more]</label></div><br/><div class="children"><div class="content">For similar isolation level anomalies in real world applications check out this SIGMOD &#x27;17 paper:<p>ACIDRain: Concurrency-Related Attacks on
Database-Backed Web Applications: <a href="http:&#x2F;&#x2F;www.bailis.org&#x2F;papers&#x2F;acidrain-sigmod2017.pdf" rel="nofollow">http:&#x2F;&#x2F;www.bailis.org&#x2F;papers&#x2F;acidrain-sigmod2017.pdf</a></div><br/></div></div><div id="39949125" class="c"><input type="checkbox" id="c-39949125" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#39949585">prev</a><span>|</span><a href="#39950329">next</a><span>|</span><label class="collapse" for="c-39949125">[-]</label><label class="expand" for="c-39949125">[1 more]</label></div><br/><div class="children"><div class="content">Great article. The `pg_sleep` is a nice trick to test for concurrency issues in postgres.</div><br/></div></div><div id="39950329" class="c"><input type="checkbox" id="c-39950329" checked=""/><div class="controls bullet"><span class="by">qazxcvbnm</span><span>|</span><a href="#39949125">prev</a><span>|</span><a href="#39950007">next</a><span>|</span><label class="collapse" for="c-39950329">[-]</label><label class="expand" for="c-39950329">[2 more]</label></div><br/><div class="children"><div class="content">Which of these strategies does Postgres use under Repeatable Read?</div><br/><div id="39950516" class="c"><input type="checkbox" id="c-39950516" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39950329">parent</a><span>|</span><a href="#39950007">next</a><span>|</span><label class="collapse" for="c-39950516">[-]</label><label class="expand" for="c-39950516">[1 more]</label></div><br/><div class="children"><div class="content">PG only uses EvalPlanQual under read committed isolation. Under repeatable read the first update fails with a &quot;could not serialize&quot; error, just as it does under serializable.</div><br/></div></div></div></div></div></div></div></div></div></body></html>