<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711530068056" as="style"/><link rel="stylesheet" href="styles.css?v=1711530068056"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://twitter.com/jedisct1/status/1772647350554464448">First practical SHA-256 collision for 31 steps. fse2024</a> <span class="domain">(<a href="https://twitter.com">twitter.com</a>)</span></div><div class="subtext"><span>devStorms</span> | <span>7 comments</span></div><br/><div><div id="39836469" class="c"><input type="checkbox" id="c-39836469" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#39836531">next</a><span>|</span><label class="collapse" for="c-39836469">[-]</label><label class="expand" for="c-39836469">[3 more]</label></div><br/><div class="children"><div class="content">I assume “steps” here means rounds? For reference, standard SHA-256 is 64 rounds.</div><br/><div id="39836522" class="c"><input type="checkbox" id="c-39836522" checked=""/><div class="controls bullet"><span class="by">slau</span><span>|</span><a href="#39836469">parent</a><span>|</span><a href="#39836521">next</a><span>|</span><label class="collapse" for="c-39836522">[-]</label><label class="expand" for="c-39836522">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the follow-up post (hidden by default) reads:<p>&gt; Don’t panic, folks. This is very good work, especially given the low memory complexity of this attack. But there are 33 steps left. Your bitcoins are safe.</div><br/></div></div></div></div><div id="39836531" class="c"><input type="checkbox" id="c-39836531" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39836469">prev</a><span>|</span><a href="#39836525">next</a><span>|</span><label class="collapse" for="c-39836531">[-]</label><label class="expand" for="c-39836531">[1 more]</label></div><br/><div class="children"><div class="content">It took me a lot of head scratching to exactly understand what this means, so for your information: this is not a full attack and you are safe (for now). If you need a concrete proof:<p><pre><code>    import hashlib
    m0 = bytes.fromhex(&#x27;&#x27;&#x27;
        c32aef52 512294ba 9db5ed8c 8c8c88ed b2de2765 63a2d14e ec7619cc 93b21182
        e5050f50 f0839b60 7b1ee176 aaa06d68 c462343c 67898962 9558f495 04281f2c
    &#x27;&#x27;&#x27;)
    m1 = bytes.fromhex(&#x27;&#x27;&#x27;
        5d0f5ae6 05e98311 8fa3c73a 9af8c49d a2bf31f7 de547b67 5baecee3 da0d8c94
        e4c19564 f682d45c f7c57698 f871f9b5 f14469b7 fc28eb0c 2d76db75 043fe071
    &#x27;&#x27;&#x27;)
    m1p = bytes.fromhex(&#x27;&#x27;&#x27;
        5d0f5ae6 05e98311 8fa3c73a 9af8c49d a2bf31f7 de548b61 5b8e46f2 8a1dd69a
        bcc08464 f6825458 f7c57698 f871f9b5 f14469b7 fc28eb0c 2d76db75 043fe071
    &#x27;&#x27;&#x27;)
    print(hashlib.sha256(m0 + m1).hexdigest())
    # 2627577ac401cf44d837cf8471cac13ad7d8385bd00e4daf59fd3c3c646eaaae
    print(hashlib.sha256(m0 + m1p).hexdigest())
    # c945222bf0868a2218d5683c69b2b6c4720093e40c46d1197262d991e4d483b6
</code></pre>
As far as I can understand, this is same as [1] and the first practical semi-free-start collision of <i>31 out of 64 rounds</i> of SHA-256, at the complexity of 2^49.8. &quot;Step&quot; here equates to &quot;round&quot;, which is not always the case and I was much confused. (RIPEMD-160 for example has 5 rounds and 16 steps per each round.) There are other theoretical cryptanalyses with more rounds of SHA-256, but this one is fairly practical and the group has explicitly demonstrated. But it is still far from the full collision attack or more like MD5 suffered back in 2009.<p>(By the way I couldn&#x27;t exactly reproduce the claimed result even with a 31-round version of SHA-256. Maybe they simply ran a step function 31 times without any initial rounds? I don&#x27;t know.)<p>EDIT: @Retr0id has reproduced this result: <a href="https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;retr0.id&#x2F;post&#x2F;3konobbmf6o2a" rel="nofollow">https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;retr0.id&#x2F;post&#x2F;3konobbmf6o2a</a><p>[1] <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2024&#x2F;349.pdf" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2024&#x2F;349.pdf</a></div><br/></div></div><div id="39836525" class="c"><input type="checkbox" id="c-39836525" checked=""/><div class="controls bullet"><span class="by">popol12</span><span>|</span><a href="#39836531">prev</a><span>|</span><label class="collapse" for="c-39836525">[-]</label><label class="expand" for="c-39836525">[2 more]</label></div><br/><div class="children"><div class="content">Bitcoin is using double sha256, just in case someone is wondering.<p>Though I wonder if double sha256 makes it twice harder to break or if it&#x27;s better or lower than that.</div><br/><div id="39836877" class="c"><input type="checkbox" id="c-39836877" checked=""/><div class="controls bullet"><span class="by">Karliss</span><span>|</span><a href="#39836525">parent</a><span>|</span><label class="collapse" for="c-39836877">[-]</label><label class="expand" for="c-39836877">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think double sha256 makes any difference with regards to collisions. If there is a collision after single sha256 they will still collide after second layer of hashing sha256(x)=sha256(y) =&gt; sha256(sha256(x))=sha256(sha256(y)).</div><br/></div></div></div></div></div></div></div></div></div></body></html>