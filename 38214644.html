<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699606860631" as="style"/><link rel="stylesheet" href="styles.css?v=1699606860631"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.leemeichin.com/posts/switching-to-elixir.html">Switching to Elixir</a> <span class="domain">(<a href="https://www.leemeichin.com">www.leemeichin.com</a>)</span></div><div class="subtext"><span>orlandohill</span> | <span>112 comments</span></div><br/><div><div id="38215205" class="c"><input type="checkbox" id="c-38215205" checked=""/><div class="controls bullet"><span class="by">byhemechi</span><span>|</span><a href="#38215523">next</a><span>|</span><label class="collapse" for="c-38215205">[-]</label><label class="expand" for="c-38215205">[29 more]</label></div><br/><div class="children"><div class="content">I often see people say static typing slows them down and I&#x27;d really like to know why that is because for me it&#x27;s the exact opposite, I really don&#x27;t like not knowing what format data is in.  I&#x27;d much rather have to write slightly more verbose code and have a vast number of possible errors caught at compile time instead of having things go wrong in production when someone inputs something a bit weird with nothing so much as an error.</div><br/><div id="38216529" class="c"><input type="checkbox" id="c-38216529" checked=""/><div class="controls bullet"><span class="by">wofo</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38216642">next</a><span>|</span><label class="collapse" for="c-38216529">[-]</label><label class="expand" for="c-38216529">[1 more]</label></div><br/><div class="children"><div class="content">Lack of proper types is what killed the joy of programming in Elixir for me (I lasted 6 months, hoping I would somehow adapt, but the experience was so miserable that I decided to move on). I simply can&#x27;t understand how anyone can be productive in a big codebase without the rigor of static typing, but those people exist, so I guess there must be something about our brains that divides us in the dynamic vs static typing camps.</div><br/></div></div><div id="38216642" class="c"><input type="checkbox" id="c-38216642" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38216529">prev</a><span>|</span><a href="#38215922">next</a><span>|</span><label class="collapse" for="c-38216642">[-]</label><label class="expand" for="c-38216642">[1 more]</label></div><br/><div class="children"><div class="content">Better type inference is faster than more ceremony, but more ceremony is faster than nothing at all, in moderately complex projects.</div><br/></div></div><div id="38215922" class="c"><input type="checkbox" id="c-38215922" checked=""/><div class="controls bullet"><span class="by">mijamo</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38216642">prev</a><span>|</span><a href="#38216297">next</a><span>|</span><label class="collapse" for="c-38215922">[-]</label><label class="expand" for="c-38215922">[6 more]</label></div><br/><div class="children"><div class="content">I think it vastly depends what you&#x27;re writing. Any kind of function that does not have a fixed input and output gets a lot more complex with static types. And by extension any code that depends on that also gets more complex.<p>I tried at some point to use Rust for an API but then I depended on making calls to a very complex API. In JavaScript I would have just gotten back a complex object where I can then pick whatever I want progressively through object access methods. In Rust I ended up with more than 500 lines of type definition for the API and it still wasn&#x27;t enough so I gave up. It is a bit extreme but when you work with an API from an ERP for instance you can get very very complex and extensive types that are not in your control and not very well specified.<p>Another good example is how complex all ORM internal code get once they try to add static typing. The typing in the ORMs code feels like black magic because they would really really need types as code but don&#x27;t have it so have to rely on a bunch of crazy generic combinators.</div><br/><div id="38216596" class="c"><input type="checkbox" id="c-38216596" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215922">parent</a><span>|</span><a href="#38216374">next</a><span>|</span><label class="collapse" for="c-38216596">[-]</label><label class="expand" for="c-38216596">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Any kind of function that does not have a fixed input and output gets a lot more complex with static types.<p>If you don&#x27;t know what kind of data people give your function and you don&#x27;t know what&#x27;s supposed to happen, how can you write that function?
I think many people use too strict of a type system. If your function works with any object that has a toString()-&gt;string function, then just write an in-line interface that defines it.<p>I actually love TypeScript here. It allows for `any` if you&#x27;re prototyping, lazy or simply don&#x27;t care.
It allows mapped types, where the next dev can see how a type came into being - for example, Mutable&lt;T&gt;, Readonly&lt;T&gt;, Required&lt;T&gt;, Partial&lt;T&gt;. The names actually speak for themselves! And it eliminates the Java-style verbosity of creating classes and files all just for a type.</div><br/></div></div><div id="38216374" class="c"><input type="checkbox" id="c-38216374" checked=""/><div class="controls bullet"><span class="by">rTX5CMRXIfFG</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215922">parent</a><span>|</span><a href="#38216596">prev</a><span>|</span><a href="#38216091">next</a><span>|</span><label class="collapse" for="c-38216374">[-]</label><label class="expand" for="c-38216374">[1 more]</label></div><br/><div class="children"><div class="content">The perceived difficulty of static typing depends on the type system itself. For example, there was a version of Swift where it became extremely painful to work with String and Substring, or Array and ArraySlice, which you’d intuitively just pass around whenever you’re making smaller pieces of collections but which the compiler complained about during type-checking when you are substituting one type for another. They solved the problem by just defining a protocol such as StringProtocol (and just reusing Sequence for arrays I think) and using that protocol wherever parameters are passed around, so it became possible again to swap those types for each other.<p>So then there’s more code for the language devs to write of course, but that’s just the cost of safety, which is highly desirable if you want the technology that you are building to be attractive for use in systems where correctness is critical, which also tend to be highly valuable. As a working professional it’s in my best economic interests to have such valuable tools in my skillset.</div><br/></div></div><div id="38216091" class="c"><input type="checkbox" id="c-38216091" checked=""/><div class="controls bullet"><span class="by">olivermuty</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215922">parent</a><span>|</span><a href="#38216374">prev</a><span>|</span><a href="#38216153">next</a><span>|</span><label class="collapse" for="c-38216091">[-]</label><label class="expand" for="c-38216091">[2 more]</label></div><br/><div class="children"><div class="content">Elixir dev here, just to put the context in place first hehe.<p>Couldn’t that thing be typed as the web format? A nested set of string props with either string or number types in the leaves.<p>Then use those types to traverse and pull into «real» types?<p>I like to put structured data into structs in elixir too and the above is essentially what I would do in Elixir.<p>I don’t know rust well enough to see if I am missing some nuance</div><br/><div id="38216506" class="c"><input type="checkbox" id="c-38216506" checked=""/><div class="controls bullet"><span class="by">miroljub</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38216091">parent</a><span>|</span><a href="#38216153">next</a><span>|</span><label class="collapse" for="c-38216506">[-]</label><label class="expand" for="c-38216506">[1 more]</label></div><br/><div class="children"><div class="content">You can do that in every language, even in Java 1.0, by just using a hash maps of objects, and cast those objects to whatever you like at runtime before accessing them.<p>But then, you are basically throwing out your static type checks and just using it as a dynamic language, but with much more verbosity, cruft and additional ways to should yourself in the foot.</div><br/></div></div></div></div><div id="38216153" class="c"><input type="checkbox" id="c-38216153" checked=""/><div class="controls bullet"><span class="by">mdx97</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215922">parent</a><span>|</span><a href="#38216091">prev</a><span>|</span><a href="#38216297">next</a><span>|</span><label class="collapse" for="c-38216153">[-]</label><label class="expand" for="c-38216153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I tried at some point to use Rust for an API but then I depended on making calls to a very complex API. In JavaScript I would have just gotten back a complex object where I can then pick whatever I want progressively through object access methods. In Rust I ended up with more than 500 lines of type definition for the API and it still wasn&#x27;t enough so I gave up.<p>You can always deserialize things as `serde_json::Value` instead of making types for everything to get similar behavior out of Rust.</div><br/></div></div></div></div><div id="38216297" class="c"><input type="checkbox" id="c-38216297" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38215922">prev</a><span>|</span><a href="#38215394">next</a><span>|</span><label class="collapse" for="c-38216297">[-]</label><label class="expand" for="c-38216297">[2 more]</label></div><br/><div class="children"><div class="content">I think static typing (without escape hatches) slow you down when you&#x27;re a library or framework author, or you&#x27;re doing something high performance. The reason being that there are many trivial and non-trivial propositions which the field has ironed over but the core language&#x2F;compiler team hasn&#x27;t caught up yet.<p>I&#x27;ve seen a lot of authors do crazy type things to get around the type system (like typing out recursion to the n-th level by hand), and I think many open source projects are slowed down by the lack of a type wizard on their team.</div><br/><div id="38216327" class="c"><input type="checkbox" id="c-38216327" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38216297">parent</a><span>|</span><a href="#38215394">next</a><span>|</span><label class="collapse" for="c-38216327">[-]</label><label class="expand" for="c-38216327">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, static typing greatly slows you down when you&#x27;re prototyping, at least for a short time, then it moderately speeds you up when you&#x27;re productionizing and maintaining.</div><br/></div></div></div></div><div id="38215394" class="c"><input type="checkbox" id="c-38215394" checked=""/><div class="controls bullet"><span class="by">rishav_sharan</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38216297">prev</a><span>|</span><a href="#38215276">next</a><span>|</span><label class="collapse" for="c-38215394">[-]</label><label class="expand" for="c-38215394">[4 more]</label></div><br/><div class="children"><div class="content">I just moved from typescript to javascript and for me it was just that I own the database, i own the api surfaces and as such I don&#x27;t need to enforce any kind of type checking as the api schemas are sufficient for my case.<p>I would definitely use type safety if I had a lot of external data sources. or if there are lots of people working with me. Otherwise, I am beginning to go back to dynamic languages at least for web dev.</div><br/><div id="38215583" class="c"><input type="checkbox" id="c-38215583" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215394">parent</a><span>|</span><a href="#38215701">next</a><span>|</span><label class="collapse" for="c-38215583">[-]</label><label class="expand" for="c-38215583">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting decision, because it&#x27;s the reverse of one of the big complaints about Typescript: that it only works up to the API boundary, and doesn&#x27;t include external data sources (unless you use libraries like Zod to combine runtime and static type checking).<p>For me, Typescript is more useful, the more of the codebase I &quot;own&quot;, because it means I can be more confident that all the types reflect the true types of the runtime data, which means I can change things more confidently and quickly. Do you find that you&#x27;re refactoring and changing things less with dynamic languages? For me, I think that&#x27;s the number one magic feature that I miss when I use languages without explicit type systems.</div><br/></div></div><div id="38215701" class="c"><input type="checkbox" id="c-38215701" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215394">parent</a><span>|</span><a href="#38215583">prev</a><span>|</span><a href="#38216438">next</a><span>|</span><label class="collapse" for="c-38215701">[-]</label><label class="expand" for="c-38215701">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently working on a data engineering team, unborking some things on a team where all the original developers of the codebase had left. Up until then, I wrote Ruby for over 10 years, and Elixir for 3. I didn&#x27;t have an opinion about JS or Typescript before this project.<p>Typescript does not solve the fundamental problems of JS. I&#x27;m not convinced it really solved the issues related to ingesting data from many different data sources. The data quality issues were still there.<p>If I were rewriting the whole thing, I&#x27;d rewrite it with Elixir (of course), if only to have a sane way of handling errors.</div><br/></div></div><div id="38216438" class="c"><input type="checkbox" id="c-38216438" checked=""/><div class="controls bullet"><span class="by">Kiro</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215394">parent</a><span>|</span><a href="#38215701">prev</a><span>|</span><a href="#38215276">next</a><span>|</span><label class="collapse" for="c-38216438">[-]</label><label class="expand" for="c-38216438">[1 more]</label></div><br/><div class="children"><div class="content">That only works for people with super memory. I&#x27;ve already forgot what the code I wrote yesterday does. If you showed me code I wrote a month ago I wouldn&#x27;t even know it was me who wrote it. I could never rely on just remembering API surfaces.</div><br/></div></div></div></div><div id="38215276" class="c"><input type="checkbox" id="c-38215276" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38215394">prev</a><span>|</span><a href="#38215262">next</a><span>|</span><label class="collapse" for="c-38215276">[-]</label><label class="expand" for="c-38215276">[2 more]</label></div><br/><div class="children"><div class="content">Does the code really need to be verbose? Scala does a pretty good job. Infer once at first declaration and enforce throughout.</div><br/><div id="38215560" class="c"><input type="checkbox" id="c-38215560" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215276">parent</a><span>|</span><a href="#38215262">next</a><span>|</span><label class="collapse" for="c-38215560">[-]</label><label class="expand" for="c-38215560">[1 more]</label></div><br/><div class="children"><div class="content">As does swift.</div><br/></div></div></div></div><div id="38215262" class="c"><input type="checkbox" id="c-38215262" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38215276">prev</a><span>|</span><a href="#38216104">next</a><span>|</span><label class="collapse" for="c-38215262">[-]</label><label class="expand" for="c-38215262">[2 more]</label></div><br/><div class="children"><div class="content">static typing is a means to an end. if you can achieve the same end without static typing, good right? that is the goal of spec.<p>the creator of the language has a fantastic talk on this <a href="https:&#x2F;&#x2F;youtu.be&#x2F;giYbq4HmfGA?si=LgSHZupSuR-kMXmj" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;giYbq4HmfGA?si=LgSHZupSuR-kMXmj</a></div><br/><div id="38215629" class="c"><input type="checkbox" id="c-38215629" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215262">parent</a><span>|</span><a href="#38216104">next</a><span>|</span><label class="collapse" for="c-38215629">[-]</label><label class="expand" for="c-38215629">[1 more]</label></div><br/><div class="children"><div class="content">For me, a huge part of it is that I find static typing to make the code a lot more self-documenting.<p>I can easily see what is passes or returned, and if I&#x27;m unsure about the details of the type the answer is a click away, or a short web search away at worst.<p>Significantly reduces my mental load, allowing me to be vastly more productive.</div><br/></div></div></div></div><div id="38216104" class="c"><input type="checkbox" id="c-38216104" checked=""/><div class="controls bullet"><span class="by">csan_gonzo</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38215262">prev</a><span>|</span><a href="#38215988">next</a><span>|</span><label class="collapse" for="c-38216104">[-]</label><label class="expand" for="c-38216104">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Elixir for over a year now and the only thing that&#x27;s missing for me is a static type system, really looking forward to this: <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;09&#x2F;20&#x2F;strong-arrows-gradual-typing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;09&#x2F;20&#x2F;strong-arrows-gradua...</a>
Also keeping an eye on Gleam: <a href="https:&#x2F;&#x2F;gleam.run&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gleam.run&#x2F;</a> .</div><br/></div></div><div id="38215988" class="c"><input type="checkbox" id="c-38215988" checked=""/><div class="controls bullet"><span class="by">jwells89</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38216104">prev</a><span>|</span><a href="#38216098">next</a><span>|</span><label class="collapse" for="c-38215988">[-]</label><label class="expand" for="c-38215988">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, static typing takes a different way of thinking that can take a while to get the hang of, and during that adjustment period a lot of people are going to significantly slower. I definitely felt it coming into Swift, being used to Objective-C and to a lesser extent Ruby.<p>Having grown accustomed to static typing, not encountering errors until runtime, or worse having errors manifest as type-related misbehavior and potentially not be immediately apparent is much more frustrating than it used to be.</div><br/></div></div><div id="38216098" class="c"><input type="checkbox" id="c-38216098" checked=""/><div class="controls bullet"><span class="by">realusername</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38215988">prev</a><span>|</span><a href="#38215228">next</a><span>|</span><label class="collapse" for="c-38216098">[-]</label><label class="expand" for="c-38216098">[1 more]</label></div><br/><div class="children"><div class="content">Elixir is a bit in the middle, with the massive amount of very specific pattern matching for each function and the fact that modules are just plain collection of functions and not objects I would say it&#x27;s the most static of dynamic languages.<p>They are working on typing it now from the blog posts I&#x27;ve seen and they will probably be successful because the language is well suited for that in my opinion</div><br/></div></div><div id="38215228" class="c"><input type="checkbox" id="c-38215228" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#38215205">parent</a><span>|</span><a href="#38216098">prev</a><span>|</span><a href="#38215222">next</a><span>|</span><label class="collapse" for="c-38215228">[-]</label><label class="expand" for="c-38215228">[6 more]</label></div><br/><div class="children"><div class="content">because of unification&#x2F;pattern-matching you have a pretty good idea, just looking at function name + args what the shape of the data is going to be.</div><br/><div id="38215261" class="c"><input type="checkbox" id="c-38215261" checked=""/><div class="controls bullet"><span class="by">artdigital</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215228">parent</a><span>|</span><a href="#38215382">next</a><span>|</span><label class="collapse" for="c-38215261">[-]</label><label class="expand" for="c-38215261">[4 more]</label></div><br/><div class="children"><div class="content">As someone who worked with Elixir for the past couple years, and maintains multiple libraries in Elixir - nah not really. Static typing is <i>the</i> thing I&#x27;m missing with Elixir.<p>No matter how much pattern matching you do, and how many typespecs you add to get a better understanding of what&#x27;s behind a variable, you&#x27;ll still run into issues at runtime frequently that could have been avoided if it was statically typed.<p>Dialyzer is great but typespecs and pattern matching only get you so far. You&#x27;ll always run into situations where the shape of data is not clear, and you have to open a REPL to do an IO.inspect somewhere</div><br/><div id="38215646" class="c"><input type="checkbox" id="c-38215646" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215261">parent</a><span>|</span><a href="#38215476">next</a><span>|</span><label class="collapse" for="c-38215646">[-]</label><label class="expand" for="c-38215646">[1 more]</label></div><br/><div class="children"><div class="content">I miss static typing for two separate and quite opposite cases:<p>* trivial errors, that still cause a crash and waste my  time (&quot;foo(:yo, 7)&quot; but was &quot;foo(7, :yo)&quot;) - sometimes spotted by Dyalizer<p>* complex nested structures. In Java I never have surprises as to what foo.bar.baz is and I can use autocomplete reliably. Expressing the same invariant in Elixir is something less straightforward</div><br/></div></div><div id="38215476" class="c"><input type="checkbox" id="c-38215476" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215261">parent</a><span>|</span><a href="#38215646">prev</a><span>|</span><a href="#38215714">next</a><span>|</span><label class="collapse" for="c-38215476">[-]</label><label class="expand" for="c-38215476">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;ll always run into situations where the shape of data is not clear<p>If you&#x27;re using typespecs, then I think the deficiency is with tooling.  I think the language servers (like ElixirLS) were quite buggy for a while, but it&#x27;s getting better at code completion and inspection.  But if the type has no spec then you&#x27;re in the same situation as any gradually typed language.</div><br/></div></div><div id="38215714" class="c"><input type="checkbox" id="c-38215714" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215261">parent</a><span>|</span><a href="#38215476">prev</a><span>|</span><a href="#38215382">next</a><span>|</span><label class="collapse" for="c-38215714">[-]</label><label class="expand" for="c-38215714">[1 more]</label></div><br/><div class="children"><div class="content">The fact that you _can_ open a REPL in production and inspect the data at runtime is huge.<p>Although few people use hotloading in code before, shapes of data can change from deployment to deployment.</div><br/></div></div></div></div><div id="38215382" class="c"><input type="checkbox" id="c-38215382" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#38215205">root</a><span>|</span><a href="#38215228">parent</a><span>|</span><a href="#38215261">prev</a><span>|</span><a href="#38215222">next</a><span>|</span><label class="collapse" for="c-38215382">[-]</label><label class="expand" for="c-38215382">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m building a static analyzer for Solidity in F# and the data shape of Solidity AST nodes overlaps frequently enough that explicitly specifying types is necessary just to get things to compile.<p>I can&#x27;t imagine building something like this in a dynamically typed language. The way I see it, static typing is like writing inline unit tests to save yourself many, many headaches later.</div><br/></div></div></div></div></div></div><div id="38215523" class="c"><input type="checkbox" id="c-38215523" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#38215205">prev</a><span>|</span><a href="#38214967">next</a><span>|</span><label class="collapse" for="c-38215523">[-]</label><label class="expand" for="c-38215523">[15 more]</label></div><br/><div class="children"><div class="content">I have been watching Elixir YouTube videos pretty much every day for the last few weeks. I guess there was an Elixir conference recently and after I watched a couple, YouTube has been sending me a consistent stream of Elixir content.<p>I really want to try out this language. I love the idea of Erlang but the few times I&#x27;ve had to deal with it (an ejabberd chat server was one) I found it to be a bit too quirky. Every video I&#x27;ve seen with Joe Armstrong leads me to believe he was an under-appreciated genius. Isolated processes and message passing (Actors) seem a good candidate for the future of distributed programming (see this recent video from Crockford on his new Misty programming language [1] - notice how the questions were about Elixir&#x2F;Erlang). I love pattern matching and elixir uses this to a high degree.<p>However, I am not 100% sold. Clearly this community punches above its weight, and the BEAM is obviously no slouch and is a brilliant choice for a platform to build upon. But I get concerned looking at the magic of LiveView (and LiveBook). My experience is that if something sounds too good to be true, it often is. A lot of the jargon is also totally unfamiliar to me - things like GenServers and other esoteric kinds of platform specific knowledge. It feels like stepping into a one-way portal, I&#x27;m not sure any knowledge in that universe is transferable.<p>There is a huge risk in niche languages and platforms. Hard to hire for, hard to find libraries for, hard to find blogs&#x2F;tutorials&#x2F;etc. With alternatives like Go having a pretty respectable concurrency story ... it is pretty hard to justify taking the risk on such a small community.<p>But kudos to that community. It is honestly impressive to me what they have achieved. I&#x27;m also very excited to see what happens with their type system implementation.<p>1. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=R2idkNdKqpQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=R2idkNdKqpQ</a></div><br/><div id="38215799" class="c"><input type="checkbox" id="c-38215799" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#38215523">parent</a><span>|</span><a href="#38215778">next</a><span>|</span><label class="collapse" for="c-38215799">[-]</label><label class="expand" for="c-38215799">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There is a huge risk in niche languages and platforms. Hard to hire for, hard to find libraries for, hard to find blogs&#x2F;tutorials&#x2F;etc.<p>There is a real need to push Elixir outside its initial circles and it&#x27;s being done a bit at the moment (I feel).<p>Both Chris &amp; José are doing a lot of work for exposure outside the initial Elixir circles, and some people in the community are doing the same at their own levels.<p>Hiring is not that complicated actually, because a fair bit of people want to work in the language (I experience that first-hand), and a good developer will be up-to-speed quite quickly too.<p>But the &quot;niche&quot; aspect must be tamed in my opinion, and is both a risk (for the language itself) and a short-term reward (being proficient in a niche something is usually quite good).</div><br/><div id="38216554" class="c"><input type="checkbox" id="c-38216554" checked=""/><div class="controls bullet"><span class="by">Champagn3Papi</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215799">parent</a><span>|</span><a href="#38215778">next</a><span>|</span><label class="collapse" for="c-38216554">[-]</label><label class="expand" for="c-38216554">[2 more]</label></div><br/><div class="children"><div class="content">I switched jobs and working as an elixir dev now. I love elixir don&#x27;t get me wrong, but some of the documentation especially some of the more advanced features in ecto are very confusing.<p>It doesn&#x27;t help you can define your ecto instructions in multiple flavors too (inline vs piping)<p>You can&#x27;t mix inline with pipe operators without creating an additiona variable too hold the original query.<p>If we want to make it less niche, there&#x27;s definitely good working points there. Once people understand how to hit a database from elixir it magically clicks and the other stuff is more trivial.</div><br/><div id="38216575" class="c"><input type="checkbox" id="c-38216575" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38216554">parent</a><span>|</span><a href="#38215778">next</a><span>|</span><label class="collapse" for="c-38216575">[-]</label><label class="expand" for="c-38216575">[1 more]</label></div><br/><div class="children"><div class="content">Ecto is a specific area and I must say I share your view on the &quot;flavours&quot; aspect (keywords vs not). I would personally love if there was only &quot;one way&quot;.<p>And agree that there are both excellent documentation, _and_ things that are kind of &quot;assumed&quot; and would need better &quot;beginner&quot; stuff (in my opinion).</div><br/></div></div></div></div></div></div><div id="38215778" class="c"><input type="checkbox" id="c-38215778" checked=""/><div class="controls bullet"><span class="by">jb3689</span><span>|</span><a href="#38215523">parent</a><span>|</span><a href="#38215799">prev</a><span>|</span><a href="#38215773">next</a><span>|</span><label class="collapse" for="c-38215778">[-]</label><label class="expand" for="c-38215778">[3 more]</label></div><br/><div class="children"><div class="content">You are overthinking some of it at least when it comes to concurrency. Look at what a process is and how send works. GenServer is a natural generalization of a pattern you’d write a thousand times. Knowledge of actors is transferable. Go has libraries which implement actor abstractions for example. Process mailboxes are just message queues like Go’s channels are. There are differences with respect to how the interpreters work and how processor yields work.<p>Stuff like LiveView though looks like magic because it is magic. There are a lot of moving parts involved in getting it working. It’s the result of work that has been going on for the past decade across multiple communities though. The ideas are mature even if there is a lot of abstraction.<p>Stuff like Riak was well ahead of its time. They basically had the idea of being able to create robust distributed systems much the same way you would a GenServer.</div><br/><div id="38216312" class="c"><input type="checkbox" id="c-38216312" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215778">parent</a><span>|</span><a href="#38215845">next</a><span>|</span><label class="collapse" for="c-38216312">[-]</label><label class="expand" for="c-38216312">[1 more]</label></div><br/><div class="children"><div class="content">Riak was pretty bad at ops. Leaving and joining nodes took ages and god forbid you tried to use any of the added features like solr search. If you settled on a very small subset of all features it worked nicely... it just wasn&#x27;t very useful if anything went wrong due to app or user error.</div><br/></div></div><div id="38215845" class="c"><input type="checkbox" id="c-38215845" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215778">parent</a><span>|</span><a href="#38216312">prev</a><span>|</span><a href="#38215773">next</a><span>|</span><label class="collapse" for="c-38215845">[-]</label><label class="expand" for="c-38215845">[1 more]</label></div><br/><div class="children"><div class="content">Why do you think riak was well ahead of its time? (actual question, I&#x27;m not arguing)<p>IIRC it was a few years after the dynamo paper came out, and at a time when a bunch of other nosql+high scalability solutions did (e.g. Cassandra)</div><br/></div></div></div></div><div id="38215773" class="c"><input type="checkbox" id="c-38215773" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#38215523">parent</a><span>|</span><a href="#38215778">prev</a><span>|</span><a href="#38215740">next</a><span>|</span><label class="collapse" for="c-38215773">[-]</label><label class="expand" for="c-38215773">[2 more]</label></div><br/><div class="children"><div class="content">I actually find the opposite to be true. Elixir is less &quot;magic&quot; once you learn it. I can see and understand what most things are doing and read the code. With javascript? Not so much.<p>On the point of hard to hire and hard to find tutorials. It is true. It is way harder to find for example someone that done what you wanna do in elixir vs javascript. When it comes to libaries it isnt so big problem. There are lots of libraries and so far I havent really encountered any problems. Only thing would be if you interact with an API they might provide a client library for javascript and python (but less common for Go) but not elixir. But honestly it is usually not so hard to use an API with just a http-client.</div><br/><div id="38216428" class="c"><input type="checkbox" id="c-38216428" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215773">parent</a><span>|</span><a href="#38215740">next</a><span>|</span><label class="collapse" for="c-38216428">[-]</label><label class="expand" for="c-38216428">[1 more]</label></div><br/><div class="children"><div class="content">Elixir is actually the easiest language to read (for me), once I knew it.  You can make it difficult to follow if you want to, but when people are using it to pass around plain old data structures, it&#x27;s very legible.  Speaking only for myself.  YMMV.</div><br/></div></div></div></div><div id="38215740" class="c"><input type="checkbox" id="c-38215740" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#38215523">parent</a><span>|</span><a href="#38215773">prev</a><span>|</span><a href="#38215547">next</a><span>|</span><label class="collapse" for="c-38215740">[-]</label><label class="expand" for="c-38215740">[2 more]</label></div><br/><div class="children"><div class="content">I went from Ruby to Elixir to Nodejs.<p>I am writing Nodejs because I have to, not because I want to. Having used it now, I will never ever start a new project with it.<p>Nodejs&#x27;s concurrency controls, ability to scale, tools for reliability and observability are so far behind from the BEAM ecosystem. I sometimes think people think Elixir is too good to be true because they&#x27;re too used to platforms not designed to be resilient.</div><br/><div id="38216094" class="c"><input type="checkbox" id="c-38216094" checked=""/><div class="controls bullet"><span class="by">conradfr</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215740">parent</a><span>|</span><a href="#38215547">next</a><span>|</span><label class="collapse" for="c-38216094">[-]</label><label class="expand" for="c-38216094">[1 more]</label></div><br/><div class="children"><div class="content">Elixir is definitely a better Nodejs... that JS developers don&#x27;t know about.</div><br/></div></div></div></div><div id="38215547" class="c"><input type="checkbox" id="c-38215547" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#38215523">parent</a><span>|</span><a href="#38215740">prev</a><span>|</span><a href="#38214967">next</a><span>|</span><label class="collapse" for="c-38215547">[-]</label><label class="expand" for="c-38215547">[4 more]</label></div><br/><div class="children"><div class="content">&gt; looking at the magic of LiveView (and LiveBook)<p>What&#x27;s the magic?  I think it&#x27;s pretty easy to get a correct mental model of everything in livebook maybe excepting exact details of how the diff calculation&#x2F;data compression works.  Even so, you can spy on the websocket messages and get a reasonable picture of what&#x27;s going on in a pinch.<p>Liveview is incredibly straightforward.</div><br/><div id="38215719" class="c"><input type="checkbox" id="c-38215719" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215547">parent</a><span>|</span><a href="#38215782">next</a><span>|</span><label class="collapse" for="c-38215719">[-]</label><label class="expand" for="c-38215719">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Liveview is incredibly straightforward.<p>I don&#x27;t agree. One of the keynotes from the 2023 ElixirConf was Chris McCord (one of the principle developers of LiveView) describing how it is <i>almost</i> 1.0 [1]. One thing that made me laugh a bit was him emphasizing how much Javascript he&#x27;s had to write (he was referencing the fact that there is an internal community meme that you can achieve such incredible behaviors <i>without writing Javascript</i>). His quip was &quot;because I wrote it all&quot;. I wonder if you asked him &quot;was it straightforward?&quot; what do you think <i>his</i> answer would be?<p>There are a lot of videos of people talking about how they managed to write something in LiveView. Here is one from 2022 &quot;How I built a block based editor in LiveView&quot; [2]. That is a good one to see how non-trivial tasks can be difficult in LiveView, describing a few times how he had to fight with it to get it to kinda-sorta do what he wanted. Certainly this man will achieve his goal since he is smart and motivated, but his description of his journey does not lead me to a conclusion of &quot;this is incredibly straightforward&quot;.<p>This is impressive tech no doubt, but it is far from clear it is currently reliable enough to stake a startup on. Another tangential issue I have with LiveView is the obvious requirement for a persistent socket connection ... which leads me to wonder how one would approach local-first type developments. Again, certainly possible but definitely not straightforward.<p>1. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=FADQAnq0RpA&amp;ab_channel=CodeSync">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=FADQAnq0RpA&amp;ab_channel=CodeS...</a><p>2. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7yZwxsG7tVs">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7yZwxsG7tVs</a></div><br/><div id="38215903" class="c"><input type="checkbox" id="c-38215903" checked=""/><div class="controls bullet"><span class="by">porker</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215719">parent</a><span>|</span><a href="#38215782">next</a><span>|</span><label class="collapse" for="c-38215903">[-]</label><label class="expand" for="c-38215903">[1 more]</label></div><br/><div class="children"><div class="content">LiveView is optional though and IMO is still overused for tasks that would be better accomplished with client side JS.<p>Where this gets messy is mixing LiveView and client side JS, and I need to experiment further with this (or find people who have).</div><br/></div></div></div></div><div id="38215782" class="c"><input type="checkbox" id="c-38215782" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#38215523">root</a><span>|</span><a href="#38215547">parent</a><span>|</span><a href="#38215719">prev</a><span>|</span><a href="#38214967">next</a><span>|</span><label class="collapse" for="c-38215782">[-]</label><label class="expand" for="c-38215782">[1 more]</label></div><br/><div class="children"><div class="content">I find LiveView either straightforward or a bit complicated, compared to other solutions, depending on the exact use cases. It&#x27;s not necessarily easy initially to grow you own way to properly handle some scenarios, and some people can find the mental switch not that easy (but in general, it has been very useful to me!).</div><br/></div></div></div></div></div></div><div id="38214967" class="c"><input type="checkbox" id="c-38214967" checked=""/><div class="controls bullet"><span class="by">superdisk</span><span>|</span><a href="#38215523">prev</a><span>|</span><a href="#38214865">next</a><span>|</span><label class="collapse" for="c-38214967">[-]</label><label class="expand" for="c-38214967">[9 more]</label></div><br/><div class="children"><div class="content">For me the big sell of Elixir&#x2F;Erlang is that it makes running &quot;background jobs&quot; a complete breeze with no concern for blocking IO bringing the entire server to a halt, especially in a web server context.<p>At my last job I had to do a bunch of HTTP requests in a webhook handler and if enough happened at once, the entire site would just crash due to all the OS processes being busy. I found myself desperately wishing I was just using Elixir instead because it would have been trivial to just spin up a Task to do it and move on.</div><br/><div id="38215061" class="c"><input type="checkbox" id="c-38215061" checked=""/><div class="controls bullet"><span class="by">ghayes</span><span>|</span><a href="#38214967">parent</a><span>|</span><a href="#38215230">next</a><span>|</span><label class="collapse" for="c-38215061">[-]</label><label class="expand" for="c-38215061">[1 more]</label></div><br/><div class="children"><div class="content">We recently switched from Rust to Elixir on a new service in no small part to this. The idea of sharing objects through Tokio async processes felt difficult compared to this being a first class feature of Elixir. It’s not that it’s hard, per se, but it felt harder to get right.</div><br/></div></div><div id="38215230" class="c"><input type="checkbox" id="c-38215230" checked=""/><div class="controls bullet"><span class="by">jbmsf</span><span>|</span><a href="#38214967">parent</a><span>|</span><a href="#38215061">prev</a><span>|</span><a href="#38214865">next</a><span>|</span><label class="collapse" for="c-38215230">[-]</label><label class="expand" for="c-38215230">[7 more]</label></div><br/><div class="children"><div class="content">Meh. I don&#x27;t want background jobs to be a breeze in quite this way. I want background work to live on different compute capacity than http requests, both because they have very different resources usage and because I want to have state or queues in front of background work so there&#x27;s a well-defined process for retry, error handling, and back-pressure.<p>I get it, of course, it&#x27;d be lovely if these complications didn&#x27;t exist and the same framework handled everything... but I don&#x27;t think a programming language or even a runtime gets you there. You also need monitoring and ops processes to be part of the solution.</div><br/><div id="38216119" class="c"><input type="checkbox" id="c-38216119" checked=""/><div class="controls bullet"><span class="by">olivermuty</span><span>|</span><a href="#38214967">root</a><span>|</span><a href="#38215230">parent</a><span>|</span><a href="#38215292">next</a><span>|</span><label class="collapse" for="c-38216119">[-]</label><label class="expand" for="c-38216119">[1 more]</label></div><br/><div class="children"><div class="content">If you want a language and VM that makes it easy to run jobs on different compute then boy do I have great news for you ;)<p>Running heterogenous loads on an elixir cluster is almost trivial. Certainly trivial compared to other languages. No external deps required.</div><br/></div></div><div id="38215292" class="c"><input type="checkbox" id="c-38215292" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#38214967">root</a><span>|</span><a href="#38215230">parent</a><span>|</span><a href="#38216119">prev</a><span>|</span><a href="#38215729">next</a><span>|</span><label class="collapse" for="c-38215292">[-]</label><label class="expand" for="c-38215292">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re creating a really difficult distributed systems problem then.  What happens if the async request gets swallowed?  Are you coordinating telemetry and tracing across these compute units?<p>Not all of us can afford elaborate ops teams</div><br/><div id="38216386" class="c"><input type="checkbox" id="c-38216386" checked=""/><div class="controls bullet"><span class="by">yuppiepuppie</span><span>|</span><a href="#38214967">root</a><span>|</span><a href="#38215292">parent</a><span>|</span><a href="#38215729">next</a><span>|</span><label class="collapse" for="c-38216386">[-]</label><label class="expand" for="c-38216386">[1 more]</label></div><br/><div class="children"><div class="content">Its really not that difficult to trace this stuff with modern APM tools. Datadog and Elastic APM support this out of the box for most languages&#x2F;frameworks. And id be suprised if other big players in space didnt also.</div><br/></div></div></div></div><div id="38215729" class="c"><input type="checkbox" id="c-38215729" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#38214967">root</a><span>|</span><a href="#38215230">parent</a><span>|</span><a href="#38215292">prev</a><span>|</span><a href="#38216063">next</a><span>|</span><label class="collapse" for="c-38215729">[-]</label><label class="expand" for="c-38215729">[1 more]</label></div><br/><div class="children"><div class="content">You can actually have &quot;background jobs&quot; in very different ways in Elixir.<p>&gt; I want background work to live on different compute capacity than http requests, both because they have very different resources usage<p>In Elixir, because of the way the BEAM works (the unit of parallelism is much cheaper and consume a low amount of memory), &quot;incoming http requests&quot; and related &quot;workers&quot; are not as expensive (a lot less actually) compared to other stacks (for instance Ruby and Python), where it is quite critical to release &quot;http workers&quot; and not hold the connection (which is what lead to the creation of background job tools like Resque, DelayedJob, Sidekiq, Celery...).<p>This means that you can actually hold incoming HTTP connections a lot longer without troubles.<p>A consequence of this is that implementing &quot;reverse proxies&quot;, or anything calling third party servers _right in the middle_ of your own HTTP call, is usually perfectly acceptable (something I&#x27;ve done more than a couple of times, the latest one powering the reverse proxy behind <a href="https:&#x2F;&#x2F;transport.data.gouv.fr" rel="nofollow noreferrer">https:&#x2F;&#x2F;transport.data.gouv.fr</a> - code available at <a href="https:&#x2F;&#x2F;github.com&#x2F;etalab&#x2F;transport-site&#x2F;tree&#x2F;master&#x2F;apps&#x2F;unlock">https:&#x2F;&#x2F;github.com&#x2F;etalab&#x2F;transport-site&#x2F;tree&#x2F;master&#x2F;apps&#x2F;un...</a>).<p>As a consequence, what would be a bad pattern in Python or Ruby (holding the incoming HTTP connection) is not a problem with Elixir.<p>&gt; because I want to have state or queues in front of background work so there&#x27;s a well-defined process for retry, error handling, and back-pressure.<p>Unless you deal with immediate stuff like reverse proxying or cheap &quot;one off async tasks&quot; (like recording a metric), there also are solutions to have more &quot;stateful&quot; background works in Elixir, too.<p>A popular background job queue is <a href="https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban">https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban</a> (roughly similar to Sidekiq at al), which uses Postgres.<p>It handles retries, errors etc.<p>But it&#x27;s not the only solution, as you have other tools dedicated to processing, such as Broadway (<a href="https:&#x2F;&#x2F;github.com&#x2F;dashbitco&#x2F;broadway">https:&#x2F;&#x2F;github.com&#x2F;dashbitco&#x2F;broadway</a>), which handles back-pressure, fault-tolerance, batching etc natively.<p>You also have more simple options, such as flow (<a href="https:&#x2F;&#x2F;github.com&#x2F;dashbitco&#x2F;flow">https:&#x2F;&#x2F;github.com&#x2F;dashbitco&#x2F;flow</a>), gen_stage (<a href="https:&#x2F;&#x2F;github.com&#x2F;elixir-lang&#x2F;gen_stage">https:&#x2F;&#x2F;github.com&#x2F;elixir-lang&#x2F;gen_stage</a>), Task.async_stream (<a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.12&#x2F;Task.html#async_stream&#x2F;5" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.12&#x2F;Task.html#async_stream&#x2F;5</a>) etc.<p>It allows to use the &quot;right tool for the job&quot; quite easily.<p>It is also interesting to note there is no need to &quot;go evented&quot; if you need to fetch data from multiple HTTP servers: it can happen in the exact same process (even: in a background task attached to your HTTP server), as done here <a href="https:&#x2F;&#x2F;transport.data.gouv.fr&#x2F;explore" rel="nofollow noreferrer">https:&#x2F;&#x2F;transport.data.gouv.fr&#x2F;explore</a> (if you zoom you will see vehicle moving in realtime, and ~80 data sources are being polled every 10 seconds &amp; broadcasted to the visitors via pubsub &amp; websockets).</div><br/></div></div><div id="38215346" class="c"><input type="checkbox" id="c-38215346" checked=""/><div class="controls bullet"><span class="by">cultofmetatron</span><span>|</span><a href="#38214967">root</a><span>|</span><a href="#38215230">parent</a><span>|</span><a href="#38216063">prev</a><span>|</span><a href="#38214865">next</a><span>|</span><label class="collapse" for="c-38215346">[-]</label><label class="expand" for="c-38215346">[1 more]</label></div><br/><div class="children"><div class="content">there&#x27;s nothing stopping you from doing this but its a real game changer for an early stage startup to need a new service and the steps to getting that out is one file and an extra line in your config.</div><br/></div></div></div></div></div></div><div id="38214865" class="c"><input type="checkbox" id="c-38214865" checked=""/><div class="controls bullet"><span class="by">isodev</span><span>|</span><a href="#38214967">prev</a><span>|</span><a href="#38214882">next</a><span>|</span><label class="collapse" for="c-38214865">[-]</label><label class="expand" for="c-38214865">[2 more]</label></div><br/><div class="children"><div class="content">I only learned about Elixir a little more than a year ago and it’s been a lot of fun to learn and incorporate in different components.<p>My biggest joy comes from how much one can do out of the box with beam&#x2F;otp. Someone in a team I worked with once said “BEAM&#x2F;OTP is like k8s only without the complicated parts”.</div><br/><div id="38215256" class="c"><input type="checkbox" id="c-38215256" checked=""/><div class="controls bullet"><span class="by">bananadonkey</span><span>|</span><a href="#38214865">parent</a><span>|</span><a href="#38214882">next</a><span>|</span><label class="collapse" for="c-38215256">[-]</label><label class="expand" for="c-38215256">[1 more]</label></div><br/><div class="children"><div class="content">When all else fails that&#x27;s how I explain it to my team.<p>I spent years learning Elixir but unfortunately the benefits were somewhat undermined by the recent migration to OpenShift (k8s) I had just architected.<p>It would have been a much more tantalizing proposition if k8s was not in the picture; instead we kept our existing dev stack and utilized k8s concepts to achieve what we would have been doing in OTP, with different trade-offs of course.</div><br/></div></div></div></div><div id="38214882" class="c"><input type="checkbox" id="c-38214882" checked=""/><div class="controls bullet"><span class="by">alskdj21</span><span>|</span><a href="#38214865">prev</a><span>|</span><a href="#38215175">next</a><span>|</span><label class="collapse" for="c-38214882">[-]</label><label class="expand" for="c-38214882">[1 more]</label></div><br/><div class="children"><div class="content">Sasa Juric&#x27;s <i>The Soul of Erlang and Elixir</i> talk[1] showcases how powerful the language can be.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JvBT4XBdoUE&amp;t=4">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JvBT4XBdoUE&amp;t=4</a></div><br/></div></div><div id="38215175" class="c"><input type="checkbox" id="c-38215175" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#38214882">prev</a><span>|</span><a href="#38215065">next</a><span>|</span><label class="collapse" for="c-38215175">[-]</label><label class="expand" for="c-38215175">[7 more]</label></div><br/><div class="children"><div class="content">“In fact, I might go as far as saying that Elixir gives you a fun language (like Ruby) while leaving out the stateful footguns OOP languages give you. There are no classes, no instances, no inheritance…it&#x27;s immutable and functional and you&#x27;re not bogged down by a static type system.”<p>I want this but with types. I’m convinced strongly typed is the way to go for larger code bases as it hides the magic of a lot of things and is easier to reason about.</div><br/><div id="38215221" class="c"><input type="checkbox" id="c-38215221" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#38215175">parent</a><span>|</span><a href="#38215194">next</a><span>|</span><label class="collapse" for="c-38215221">[-]</label><label class="expand" for="c-38215221">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s less of an issue with elixir than it is with ruby or python or any other dynamic lang (or static lang) with mutability. Because of pattern matching&#x2F;unification in functions, you have a good idea what shape your data is as it&#x27;s being passed around. if you still don&#x27;t feel comfortable, there&#x27;s always Dialyzer.<p>Dialyzer is a static analysis tool for erlang&#x2F;elixir. It&#x27;s part of the standard Erlang Release and stands for DIscrepancy AnaLYZer for ERlang programs. It identifies software discrepancies such as type errors, dead code, unnecessary tests, etc., in single Erlang modules or entire (sets of) applications. Dialyzer starts from a base of correct programs and infers types; it doesn&#x27;t require type annotations but uses them if they are available to provide better warnings.<p><a href="https:&#x2F;&#x2F;fly.io&#x2F;phoenix-files&#x2F;adding-dialyzer-without-the-pain&#x2F;">https:&#x2F;&#x2F;fly.io&#x2F;phoenix-files&#x2F;adding-dialyzer-without-the-pai...</a></div><br/></div></div><div id="38215194" class="c"><input type="checkbox" id="c-38215194" checked=""/><div class="controls bullet"><span class="by">creakingstairs</span><span>|</span><a href="#38215175">parent</a><span>|</span><a href="#38215221">prev</a><span>|</span><a href="#38215692">next</a><span>|</span><label class="collapse" for="c-38215194">[-]</label><label class="expand" for="c-38215194">[1 more]</label></div><br/><div class="children"><div class="content">Types are coming! Hopefully not too far away.<p><a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;06&#x2F;22&#x2F;type-system-updates-research-dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;06&#x2F;22&#x2F;type-system-updates-...</a></div><br/></div></div><div id="38215692" class="c"><input type="checkbox" id="c-38215692" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#38215175">parent</a><span>|</span><a href="#38215194">prev</a><span>|</span><a href="#38215455">next</a><span>|</span><label class="collapse" for="c-38215692">[-]</label><label class="expand" for="c-38215692">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a contrarian here. I really wished we had inheritance in Elixir for GenServers - because those <i>are</i> objects, interacting out of messages and not just glorified structs with associated functions.<p>So I wish I could have a generic template for a project&#x27;s GenServer (for basic common registration, memory configuration, logging), that is specialized for a specific task, of which there are three flavours.<p>Speaking of footguns, Elixir patches this problem with macro code generation, but it is not so good. Any my GenServers are full of trivial repetitions.</div><br/><div id="38215842" class="c"><input type="checkbox" id="c-38215842" checked=""/><div class="controls bullet"><span class="by">POiNTx</span><span>|</span><a href="#38215175">root</a><span>|</span><a href="#38215692">parent</a><span>|</span><a href="#38215455">next</a><span>|</span><label class="collapse" for="c-38215842">[-]</label><label class="expand" for="c-38215842">[2 more]</label></div><br/><div class="children"><div class="content">Behaviours might be what you&#x27;re looking for, they&#x27;re the closest thing to inheritance in Elixir.<p>And you&#x27;re absolutely right about genservers being objects :)</div><br/><div id="38216018" class="c"><input type="checkbox" id="c-38216018" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#38215175">root</a><span>|</span><a href="#38215842">parent</a><span>|</span><a href="#38215455">next</a><span>|</span><label class="collapse" for="c-38216018">[-]</label><label class="expand" for="c-38216018">[1 more]</label></div><br/><div class="children"><div class="content">They are, but it&#x27;s not as natural as A specializes B that specializes C.</div><br/></div></div></div></div></div></div><div id="38215455" class="c"><input type="checkbox" id="c-38215455" checked=""/><div class="controls bullet"><span class="by">GavinMcG</span><span>|</span><a href="#38215175">parent</a><span>|</span><a href="#38215692">prev</a><span>|</span><a href="#38215065">next</a><span>|</span><label class="collapse" for="c-38215455">[-]</label><label class="expand" for="c-38215455">[1 more]</label></div><br/><div class="children"><div class="content">You might like Gleam, then. Seems to have a similar feel.</div><br/></div></div></div></div><div id="38215065" class="c"><input type="checkbox" id="c-38215065" checked=""/><div class="controls bullet"><span class="by">sinuhe69</span><span>|</span><a href="#38215175">prev</a><span>|</span><a href="#38215193">next</a><span>|</span><label class="collapse" for="c-38215065">[-]</label><label class="expand" for="c-38215065">[6 more]</label></div><br/><div class="children"><div class="content">Coming from F# and only dabbled in Elixir, I find the language unfortunately a bit confusing. For instance, the signature of a function only reveals the name and number of the parameters but not type, so in a big library, it’s quite hard to recognize (mentally) what goes into what and one can only see one plugged the wrong parameters after one had ran and debugged the code. In strict-type language like F#, such issues would be detected right away during coding, thus it helps to reduce the time and effort immensely.<p>So my question is what are the main selling points of Elixir besides the Erlang environment?</div><br/><div id="38215155" class="c"><input type="checkbox" id="c-38215155" checked=""/><div class="controls bullet"><span class="by">shirvan</span><span>|</span><a href="#38215065">parent</a><span>|</span><a href="#38216347">next</a><span>|</span><label class="collapse" for="c-38215155">[-]</label><label class="expand" for="c-38215155">[1 more]</label></div><br/><div class="children"><div class="content">There is a lot to like about Elixir itself including the nice syntax, which as mentioned in the article is inspired by Ruby and very easy to pickup. The BEAM&#x2F;OTP is what really give Elixir the edge over other languages that I&#x27;ve used.<p>In my experience they include many batteries that would be libraries in other languages, and most times those libraries add a ton of complexity, and sometimes a big learning curve; Async anything is a good example.<p>I think once one works with Elixir for some time, and gets to learn these builtin tools and abstractions they understand the power of the ecosystem as a whole.</div><br/></div></div><div id="38216347" class="c"><input type="checkbox" id="c-38216347" checked=""/><div class="controls bullet"><span class="by">conradfr</span><span>|</span><a href="#38215065">parent</a><span>|</span><a href="#38215155">prev</a><span>|</span><a href="#38215770">next</a><span>|</span><label class="collapse" for="c-38216347">[-]</label><label class="expand" for="c-38216347">[1 more]</label></div><br/><div class="children"><div class="content">The lack of typehinting for function parameters is definitely the biggest productivity hit for me in Elixir.<p>You can go by with typespecs, pattern matching and guards but that&#x27;s kind of exhaustive and not really IDE &#x2F; Intellisense friendly (at least with the community-led Jetbrains plugin).</div><br/></div></div><div id="38215770" class="c"><input type="checkbox" id="c-38215770" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#38215065">parent</a><span>|</span><a href="#38216347">prev</a><span>|</span><a href="#38215120">next</a><span>|</span><label class="collapse" for="c-38215770">[-]</label><label class="expand" for="c-38215770">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used .Net quite a bit (but F# only occasionally), I would say some selling points are:<p>- the native integration of Machine Learning (including compiled to GPU) with e.g. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HK38-HIK6NA">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HK38-HIK6NA</a>, Axon, Nx, BumbleBee etc (there is a real push for that in the community)<p>- the way LiveView works (although there is Blazor in .Net)<p>- the fact that Elixir can be used in a large number of contexts (including embedded, see Nerves, or scripting but F# is usable for scripting too afaik)<p>- overall, the BEAM and associated structures<p>- package manager (Hex) is really nice (but .Net has nice tooling too)<p>Just a couple of points from my own experience</div><br/></div></div><div id="38215120" class="c"><input type="checkbox" id="c-38215120" checked=""/><div class="controls bullet"><span class="by">jswny</span><span>|</span><a href="#38215065">parent</a><span>|</span><a href="#38215770">prev</a><span>|</span><a href="#38215119">next</a><span>|</span><label class="collapse" for="c-38215120">[-]</label><label class="expand" for="c-38215120">[1 more]</label></div><br/><div class="children"><div class="content">Static typing for Elixir is in active development: <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;09&#x2F;20&#x2F;strong-arrows-gradual-typing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;09&#x2F;20&#x2F;strong-arrows-gradua...</a><p>Yes, it is currently dynamic and yes, that means you won&#x27;t get much int he way of type information from the language itself, it&#x27;s not currently a statically typed language.</div><br/></div></div><div id="38215119" class="c"><input type="checkbox" id="c-38215119" checked=""/><div class="controls bullet"><span class="by">rapind</span><span>|</span><a href="#38215065">parent</a><span>|</span><a href="#38215120">prev</a><span>|</span><a href="#38215193">next</a><span>|</span><label class="collapse" for="c-38215119">[-]</label><label class="expand" for="c-38215119">[1 more]</label></div><br/><div class="children"><div class="content">As a language, I wouldn&#x27;t call it an upgrade over F# (subjective). The main selling point is probably running on BEAM w&#x2F; ruby-ish syntax. BEAM is kind of a big deal IMO.<p>I don&#x27;t think it compares very well to F# types, but you can use typespecs: <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15.7&#x2F;typespecs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15.7&#x2F;typespecs.html</a></div><br/></div></div></div></div><div id="38215193" class="c"><input type="checkbox" id="c-38215193" checked=""/><div class="controls bullet"><span class="by">BMorearty</span><span>|</span><a href="#38215065">prev</a><span>|</span><a href="#38215289">next</a><span>|</span><label class="collapse" for="c-38215193">[-]</label><label class="expand" for="c-38215193">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In Ruby it&#x27;s common to use exceptions for control flow.<p>I think this is just plain incorrect. The example given later in this paragraph is the Rails `update` method--but the approach used in all canonical Rails examples and generators is the non-exception version of `update`.</div><br/><div id="38215744" class="c"><input type="checkbox" id="c-38215744" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#38215193">parent</a><span>|</span><a href="#38215313">next</a><span>|</span><label class="collapse" for="c-38215744">[-]</label><label class="expand" for="c-38215744">[1 more]</label></div><br/><div class="children"><div class="content">I do not find it incorrect at all, as a Ruby user since 2004. A lot of gems use exceptions for control flow and it is also common in apps or libraries I&#x27;ve written or maintained (just a data point).</div><br/></div></div><div id="38215313" class="c"><input type="checkbox" id="c-38215313" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38215193">parent</a><span>|</span><a href="#38215744">prev</a><span>|</span><a href="#38215289">next</a><span>|</span><label class="collapse" for="c-38215313">[-]</label><label class="expand" for="c-38215313">[2 more]</label></div><br/><div class="children"><div class="content">Ruby != Rails. There are a lot of bang! methods that will raise on error in Rails. But in general Ruby is just like Python in that it is indeed common to use exceptions for control flow.</div><br/><div id="38215797" class="c"><input type="checkbox" id="c-38215797" checked=""/><div class="controls bullet"><span class="by">BMorearty</span><span>|</span><a href="#38215193">root</a><span>|</span><a href="#38215313">parent</a><span>|</span><a href="#38215289">next</a><span>|</span><label class="collapse" for="c-38215797">[-]</label><label class="expand" for="c-38215797">[1 more]</label></div><br/><div class="children"><div class="content">I know Ruby != Rails but the example wasn’t mine. It was from the paragraph I quoted from the post, which conflates the two.<p>It may be true in Python--I don’t use it much--but I know Ruby well. It was my primary language for 13 years, at multiple companies. I taught it to over a thousand engineers at Airbnb over the course of five years. I still disagree that it is common to use exceptions for control flow.<p>Maybe it’s a matter of the interpretation of the word “common.” ¯\_(ツ)_&#x2F;¯</div><br/></div></div></div></div></div></div><div id="38215289" class="c"><input type="checkbox" id="c-38215289" checked=""/><div class="controls bullet"><span class="by">aryehof</span><span>|</span><a href="#38215193">prev</a><span>|</span><a href="#38215549">next</a><span>|</span><label class="collapse" for="c-38215289">[-]</label><label class="expand" for="c-38215289">[2 more]</label></div><br/><div class="children"><div class="content">Write after you’ve been there for 2 years, instead of at the start. That new thing always looks like a flawless shiny new silver bullet when starting out.</div><br/><div id="38215607" class="c"><input type="checkbox" id="c-38215607" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38215289">parent</a><span>|</span><a href="#38215549">next</a><span>|</span><label class="collapse" for="c-38215607">[-]</label><label class="expand" for="c-38215607">[1 more]</label></div><br/><div class="children"><div class="content">I work professionally as an elixir developer for longer than that before starting a PhD program; Elixir was and still is a gem. It’s not perfect. It holds up incredibly well though.</div><br/></div></div></div></div><div id="38215549" class="c"><input type="checkbox" id="c-38215549" checked=""/><div class="controls bullet"><span class="by">danjac</span><span>|</span><a href="#38215289">prev</a><span>|</span><a href="#38214815">next</a><span>|</span><label class="collapse" for="c-38215549">[-]</label><label class="expand" for="c-38215549">[1 more]</label></div><br/><div class="children"><div class="content">It would be nice to work with Elixir, having played around with it.<p>However every Elixir job I&#x27;ve seen requires Elixir experience, so I don&#x27;t really see much opportunity for working with it professionally.</div><br/></div></div><div id="38214815" class="c"><input type="checkbox" id="c-38214815" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38215549">prev</a><span>|</span><a href="#38215437">next</a><span>|</span><label class="collapse" for="c-38214815">[-]</label><label class="expand" for="c-38214815">[1 more]</label></div><br/><div class="children"><div class="content">The true power of Elixir comes from processes and OTP.</div><br/></div></div><div id="38215437" class="c"><input type="checkbox" id="c-38215437" checked=""/><div class="controls bullet"><span class="by">99miles</span><span>|</span><a href="#38214815">prev</a><span>|</span><a href="#38214894">next</a><span>|</span><label class="collapse" for="c-38215437">[-]</label><label class="expand" for="c-38215437">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Ruby since about 2007. Every time I attempt to switch to the next &quot;cool&quot; thing, I ended up switching back, because Ruby is what I love and am the fastest with, and that&#x27;s all that matters.<p>However, I&#x27;ve been starting to see a lot more Elixir buzz, and I love the looks and sounds of it. Looks like I&#x27;ll need to start a new side project soon to give it a try.</div><br/></div></div><div id="38214894" class="c"><input type="checkbox" id="c-38214894" checked=""/><div class="controls bullet"><span class="by">cheema33</span><span>|</span><a href="#38215437">prev</a><span>|</span><a href="#38214863">next</a><span>|</span><label class="collapse" for="c-38214894">[-]</label><label class="expand" for="c-38214894">[10 more]</label></div><br/><div class="children"><div class="content">How do people switch programming languages?  Established languages have massive ecosystems.  Large set of libraries.  For example, I cannot give up MS Entity Framework Core or Hot Chocolate graphql server for C#.  Sure, there are alternatives, but nothing as feature complete.<p>Perhaps it is possible for applications that have small set of requirements.</div><br/><div id="38214958" class="c"><input type="checkbox" id="c-38214958" checked=""/><div class="controls bullet"><span class="by">john-radio</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38216384">next</a><span>|</span><label class="collapse" for="c-38214958">[-]</label><label class="expand" for="c-38214958">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Perhaps it is possible for applications that have small set of requirements.<p>Well, for existing <i>applications</i> it is extremely difficult, not because Elixir lacks many important features that C# delivers (although I&#x27;m sure it does lack some, and vice versa in a big way), but more just because rebuilding any project that&#x27;s had hundreds or thousands of person-hours poured into it, that&#x27;s currently satisfying hundreds or thousands of business requirements which may or may not be documented, is a huge project with few rewards; the investment is huge and the return on investment is... I mean, being on {sexy new language} is nice, but nobody&#x27;s paying you for that.<p>But that&#x27;s not what the OP&#x27;s job is talking about. They just got a different job using Elixir, and are learning the technologies the same way anyone else does, and they&#x27;re excited about this instance of it enough to write about it.</div><br/></div></div><div id="38216384" class="c"><input type="checkbox" id="c-38216384" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38214958">prev</a><span>|</span><a href="#38215093">next</a><span>|</span><label class="collapse" for="c-38216384">[-]</label><label class="expand" for="c-38216384">[1 more]</label></div><br/><div class="children"><div class="content">You just have to learn to let go of your favorite frameworks and libraries.<p>If you do that then you&#x27;ll often find loads of other amazing things that are better on the other side.<p>For example; maybe there&#x27;s nothing like the MS Entity Framework Core, but instead you&#x27;ll get to use OTP that everyone&#x27;s always gushing about which may solve many issues you&#x27;re having with your current tech stack.<p>Switching languages (and frameworks and libraries) is amazingly useful because you&#x27;ll get exposed to solutions you didn&#x27;t even knew you wanted.</div><br/></div></div><div id="38215093" class="c"><input type="checkbox" id="c-38215093" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38216384">prev</a><span>|</span><a href="#38215017">next</a><span>|</span><label class="collapse" for="c-38215093">[-]</label><label class="expand" for="c-38215093">[3 more]</label></div><br/><div class="children"><div class="content">&gt; MS Entity Framework Core<p>Having worked with both EF Core and Ecto, I would gladly see the back of EF Core.  Ecto is flexible enough to basically do everything you would with a raw SQL statement, but still use a relation mapper with it&#x27;s validations.  And if you have freeform output because you&#x27;re doing a bunch of JOINs or querying a MATERIALIZED VIEW or whatever, you can just pipe that straight into a struct inline without having to declare a definition somewhere.</div><br/><div id="38215138" class="c"><input type="checkbox" id="c-38215138" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#38214894">root</a><span>|</span><a href="#38215093">parent</a><span>|</span><a href="#38215017">next</a><span>|</span><label class="collapse" for="c-38215138">[-]</label><label class="expand" for="c-38215138">[2 more]</label></div><br/><div class="children"><div class="content">EF Core these days is insanely good.<p>It definitely has an initial learning curve, but once you&#x27;ve built a small sample app, it&#x27;s quite easy to move ridiculous fast.<p>It still provides access to raw SQL and can always add in Dapper if you want&#x2F;need more complicated queries.  But productivity is really, really good with very little sacrifice in terms of performance.</div><br/><div id="38215216" class="c"><input type="checkbox" id="c-38215216" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#38214894">root</a><span>|</span><a href="#38215138">parent</a><span>|</span><a href="#38215017">next</a><span>|</span><label class="collapse" for="c-38215216">[-]</label><label class="expand" for="c-38215216">[1 more]</label></div><br/><div class="children"><div class="content">I <i>am</i> using it these days and I&#x27;ve found it wanting compared to Ecto.  The only thing I think is great about EF Core is automated migrations, but in practice that&#x27;s not where the complexity lies.  It&#x27;s in all the odd queries you need to make to satisfy the business logic as it evolves.<p>Edit: Probably the other good thing about EF Core is the designer, which as you mentioned is great for Rapid Application Development.  Not really a time saver vs coding as the application scales, or if you prefer reasoning in code vs visually.  Would like to see Ecto feature more user friendly tooling like a designer and automated migrations in the future though.</div><br/></div></div></div></div></div></div><div id="38215017" class="c"><input type="checkbox" id="c-38215017" checked=""/><div class="controls bullet"><span class="by">bradteamworks</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38215093">prev</a><span>|</span><a href="#38214951">next</a><span>|</span><label class="collapse" for="c-38215017">[-]</label><label class="expand" for="c-38215017">[1 more]</label></div><br/><div class="children"><div class="content">I used C# before using Elixir. I also thought Entity was awesome. But Ecto and Absinthe are even better from my perspective.</div><br/></div></div><div id="38214951" class="c"><input type="checkbox" id="c-38214951" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38215017">prev</a><span>|</span><a href="#38214925">next</a><span>|</span><label class="collapse" for="c-38214951">[-]</label><label class="expand" for="c-38214951">[1 more]</label></div><br/><div class="children"><div class="content">Erlang is fairly established 37 years young language and Elixir got to build on top of Erlang ecosystem.</div><br/></div></div><div id="38214925" class="c"><input type="checkbox" id="c-38214925" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38214951">prev</a><span>|</span><a href="#38215154">next</a><span>|</span><label class="collapse" for="c-38214925">[-]</label><label class="expand" for="c-38214925">[1 more]</label></div><br/><div class="children"><div class="content">Elixir and Erlang are very well established ecosystems.</div><br/></div></div><div id="38215154" class="c"><input type="checkbox" id="c-38215154" checked=""/><div class="controls bullet"><span class="by">dimgl</span><span>|</span><a href="#38214894">parent</a><span>|</span><a href="#38214925">prev</a><span>|</span><a href="#38214863">next</a><span>|</span><label class="collapse" for="c-38215154">[-]</label><label class="expand" for="c-38215154">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, I cannot give up MS Entity Framework Core or Hot Chocolate graphql server for C#.<p>What? Why? Also, what do you mean nothing is as feature complete as Entity Framework? What about ActiveRecord, Ecto, Django ORM, Knex, even Dapper in C# itself......</div><br/></div></div></div></div><div id="38214863" class="c"><input type="checkbox" id="c-38214863" checked=""/><div class="controls bullet"><span class="by">hbcondo714</span><span>|</span><a href="#38214894">prev</a><span>|</span><a href="#38214890">next</a><span>|</span><label class="collapse" for="c-38214863">[-]</label><label class="expand" for="c-38214863">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Elixir&#x27;s |&gt;, and it inserts the result of the previous expression into the first argument of the next function<p>I found this convenient while writing my first Elixir app with Phoenix Liveview:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hbcondo&#x2F;last10k_liveview">https:&#x2F;&#x2F;github.com&#x2F;hbcondo&#x2F;last10k_liveview</a></div><br/></div></div><div id="38214890" class="c"><input type="checkbox" id="c-38214890" checked=""/><div class="controls bullet"><span class="by">andsbf</span><span>|</span><a href="#38214863">prev</a><span>|</span><a href="#38214816">next</a><span>|</span><label class="collapse" for="c-38214890">[-]</label><label class="expand" for="c-38214890">[2 more]</label></div><br/><div class="children"><div class="content">`...If you call model.update(params) in Ruby, then it returns false if it fails and updates model.errors with what went wrong. Mutable state.`<p>This is Rails stuff, not Ruby</div><br/><div id="38215063" class="c"><input type="checkbox" id="c-38215063" checked=""/><div class="controls bullet"><span class="by">krainboltgreene</span><span>|</span><a href="#38214890">parent</a><span>|</span><a href="#38214816">next</a><span>|</span><label class="collapse" for="c-38215063">[-]</label><label class="expand" for="c-38215063">[1 more]</label></div><br/><div class="children"><div class="content">True, you could implement Ecto exactly in Ruby, except you&#x27;d be writing effectively Elixir and every library released that got close to this in the 15 years I&#x27;ve been doing Ruby has been either disliked or disregarded. Each with less contributor activity in their lifespan than a month of ActiveRecord attention.</div><br/></div></div></div></div><div id="38214816" class="c"><input type="checkbox" id="c-38214816" checked=""/><div class="controls bullet"><span class="by">jononomo</span><span>|</span><a href="#38214890">prev</a><span>|</span><a href="#38215878">next</a><span>|</span><label class="collapse" for="c-38214816">[-]</label><label class="expand" for="c-38214816">[1 more]</label></div><br/><div class="children"><div class="content">I love Elixir.</div><br/></div></div><div id="38215878" class="c"><input type="checkbox" id="c-38215878" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#38214816">prev</a><span>|</span><a href="#38215055">next</a><span>|</span><label class="collapse" for="c-38215878">[-]</label><label class="expand" for="c-38215878">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are no classes, no instances, no inheritance<p>I don&#x27;t know anything about Elixir, but it bothers me when people claim that languages like Rust and Go are &quot;not object oriented&quot;. If you create structs and have special syntax for defining functions that operate on instances of those structs, then those are called objects and you are doing OOP. Just because some Java people came up with a definition of OOP that says it has to have inheritance, doesn&#x27;t mean you actually have to pay attention to their definition.</div><br/><div id="38216396" class="c"><input type="checkbox" id="c-38216396" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#38215878">parent</a><span>|</span><a href="#38215055">next</a><span>|</span><label class="collapse" for="c-38216396">[-]</label><label class="expand" for="c-38216396">[1 more]</label></div><br/><div class="children"><div class="content">And Erlang (and Elixir) is also closer to the original definition of OOP, with it&#x27;s focus on message passing between processes (&quot;objects&quot;).</div><br/></div></div></div></div><div id="38215055" class="c"><input type="checkbox" id="c-38215055" checked=""/><div class="controls bullet"><span class="by">colesantiago</span><span>|</span><a href="#38215878">prev</a><span>|</span><a href="#38215188">next</a><span>|</span><label class="collapse" for="c-38215055">[-]</label><label class="expand" for="c-38215055">[5 more]</label></div><br/><div class="children"><div class="content">Which companies have used Elixir in production, I know Brex used to use Elixir but now used Kotlin and also the Bleacher Report.<p>Are there any more?</div><br/><div id="38216586" class="c"><input type="checkbox" id="c-38216586" checked=""/><div class="controls bullet"><span class="by">voxadam</span><span>|</span><a href="#38215055">parent</a><span>|</span><a href="#38215370">next</a><span>|</span><label class="collapse" for="c-38216586">[-]</label><label class="expand" for="c-38216586">[1 more]</label></div><br/><div class="children"><div class="content">Some case studies of Elixir&#x27;s use at various companies can be found on the main Elixir site.[0]<p>[0] <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;cases.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;cases.html</a></div><br/></div></div><div id="38215370" class="c"><input type="checkbox" id="c-38215370" checked=""/><div class="controls bullet"><span class="by">sho</span><span>|</span><a href="#38215055">parent</a><span>|</span><a href="#38216586">prev</a><span>|</span><a href="#38215095">next</a><span>|</span><label class="collapse" for="c-38215370">[-]</label><label class="expand" for="c-38215370">[1 more]</label></div><br/><div class="children"><div class="content">There are tons, I can name at least 4 in my city alone, all fintech. Elixir really excels, and is heavily used, at payment processing workflows, where genservers and the concurrency model is amazingly useful at handling complex, multi-step transactions involving multiple, often external, actors.<p>None of the companies appear on that list, I think those kinds of things should always be taken with a grain of salt.</div><br/></div></div><div id="38215095" class="c"><input type="checkbox" id="c-38215095" checked=""/><div class="controls bullet"><span class="by">romanhn</span><span>|</span><a href="#38215055">parent</a><span>|</span><a href="#38215370">prev</a><span>|</span><a href="#38215112">next</a><span>|</span><label class="collapse" for="c-38215095">[-]</label><label class="expand" for="c-38215095">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a pretty large list here: <a href="https:&#x2F;&#x2F;elixir-companies.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-companies.com</a></div><br/></div></div><div id="38215112" class="c"><input type="checkbox" id="c-38215112" checked=""/><div class="controls bullet"><span class="by">schainks</span><span>|</span><a href="#38215055">parent</a><span>|</span><a href="#38215095">prev</a><span>|</span><a href="#38215188">next</a><span>|</span><label class="collapse" for="c-38215112">[-]</label><label class="expand" for="c-38215112">[1 more]</label></div><br/><div class="children"><div class="content">Adobe and Apple.</div><br/></div></div></div></div><div id="38215188" class="c"><input type="checkbox" id="c-38215188" checked=""/><div class="controls bullet"><span class="by">hartator</span><span>|</span><a href="#38215055">prev</a><span>|</span><a href="#38214956">next</a><span>|</span><label class="collapse" for="c-38215188">[-]</label><label class="expand" for="c-38215188">[7 more]</label></div><br/><div class="children"><div class="content">And still 0 successful startup has been built on top of elixir.</div><br/><div id="38215805" class="c"><input type="checkbox" id="c-38215805" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#38215188">parent</a><span>|</span><a href="#38215613">next</a><span>|</span><label class="collapse" for="c-38215805">[-]</label><label class="expand" for="c-38215805">[1 more]</label></div><br/><div class="children"><div class="content">Yea, like that failure called discord. Is anyone even using discord?! What a failure!</div><br/></div></div><div id="38215613" class="c"><input type="checkbox" id="c-38215613" checked=""/><div class="controls bullet"><span class="by">SamFold</span><span>|</span><a href="#38215188">parent</a><span>|</span><a href="#38215805">prev</a><span>|</span><a href="#38216375">next</a><span>|</span><label class="collapse" for="c-38215613">[-]</label><label class="expand" for="c-38215613">[1 more]</label></div><br/><div class="children"><div class="content">SumUp (8B valuation) uses Elixir and I&#x27;m sure there are more.<p><a href="https:&#x2F;&#x2F;www.crunchbase.com&#x2F;organization&#x2F;sumup" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.crunchbase.com&#x2F;organization&#x2F;sumup</a>
<a href="https:&#x2F;&#x2F;www.sumup.com&#x2F;careers&#x2F;positions&#x2F;berlin-germany&#x2F;engineering&#x2F;senior-backend-engineer-elixir-hardware-tribe&#x2F;6960932002&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sumup.com&#x2F;careers&#x2F;positions&#x2F;berlin-germany&#x2F;engin...</a></div><br/></div></div><div id="38216375" class="c"><input type="checkbox" id="c-38216375" checked=""/><div class="controls bullet"><span class="by">lord-squirrel</span><span>|</span><a href="#38215188">parent</a><span>|</span><a href="#38215613">prev</a><span>|</span><a href="#38215265">next</a><span>|</span><label class="collapse" for="c-38216375">[-]</label><label class="expand" for="c-38216375">[1 more]</label></div><br/><div class="children"><div class="content">Even one developer startups have had huge success using elxir <a href="https:&#x2F;&#x2F;plausible.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;plausible.io&#x2F;</a></div><br/></div></div><div id="38215265" class="c"><input type="checkbox" id="c-38215265" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38215188">parent</a><span>|</span><a href="#38216375">prev</a><span>|</span><a href="#38215550">next</a><span>|</span><label class="collapse" for="c-38215265">[-]</label><label class="expand" for="c-38215265">[1 more]</label></div><br/><div class="children"><div class="content">Hogwash. I used to work for one. Left to go back to school. They’re still going strong. Maybe I’ll go back some day.</div><br/></div></div><div id="38215550" class="c"><input type="checkbox" id="c-38215550" checked=""/><div class="controls bullet"><span class="by">Supermancho</span><span>|</span><a href="#38215188">parent</a><span>|</span><a href="#38215265">prev</a><span>|</span><a href="#38214956">next</a><span>|</span><label class="collapse" for="c-38215550">[-]</label><label class="expand" for="c-38215550">[2 more]</label></div><br/><div class="children"><div class="content">Real talk. HN posts on anything OTP continue to be the same echo chamber of responses, with most readers just leaving them to it. Many people have been trying to nicely point out that &quot;uses Elixir in some places&quot; is not the same as &quot;built on Elixir&quot;. ie It&#x27;s exceedingly rare for any system to have a secret sauce called Elixir and none of them have sparked a race to use it. How many decades before someone points out it&#x27;s a dead horse?<p>From my few years off-and-on, Elixir is a nice syntax on top of Erlang. Erlang is intrinsically a flow-based system. Just because you can prove something is turing complete, doesn&#x27;t make Elixir&#x2F;Erlang a good general language choice. The no-side effect philosophy is a dead end. You just store state somewhere else anyway, so what have you gained? The current type system is problematic, at best, and everyone knows that. Decades have passed and the same tired phrasing appears in every paper and every talk. &quot;dynamic, scalable language built on Erlang VM, designed for building maintainable, high-concurrency apps&quot;. It&#x27;s clear that this isn&#x27;t special anymore and it reads as desperate for relevancy, or left to rot. Either way, Elixir&#x2F;Erlang is a specialty tool like Apache Nifi or CockroachDB. Niche, at best, a sub-optimal choice at worst, for most projects.<p>It&#x27;s oft repeated that Elixir&#x2F;Erlange tooling is &quot;established&quot;. Whenever I have used the tooling or a framework (looking at you Phoenix), it&#x27;s been primitive (Observer has gotten better), poorly implemented (IDEA, VScode), or requires a large amount of memorization to &quot;learn&quot; it. Not the language, the tooling. It&#x27;s not enough to know Elixir or Erlang. You better understand BEAM (to some extent), shell scripting (just run it in a docker on windows), some glue technologies (something to build the UI, maintain state, etc), and then you can get down to building your backend application.</div><br/><div id="38215597" class="c"><input type="checkbox" id="c-38215597" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38215188">root</a><span>|</span><a href="#38215550">parent</a><span>|</span><a href="#38214956">next</a><span>|</span><label class="collapse" for="c-38215597">[-]</label><label class="expand" for="c-38215597">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The no-side effect philosophy is a dead end.<p>??? Erlang and Elixir have of tons of side effects. You must not either know the languages well—or maybe you mean immutability?<p>If you mean immutability, have fun building highly concurrent systems without it. The local reasoning and safety guarantees that immutability gives you makes building large scale applications sane—that’s the only way I’d want to program.</div><br/></div></div></div></div></div></div><div id="38214956" class="c"><input type="checkbox" id="c-38214956" checked=""/><div class="controls bullet"><span class="by">block_dagger</span><span>|</span><a href="#38215188">prev</a><span>|</span><label class="collapse" for="c-38214956">[-]</label><label class="expand" for="c-38214956">[5 more]</label></div><br/><div class="children"><div class="content">Longtime Rubyist here that has worked with Elixir. It is only loosely based on Ruby&#x27;s syntax - there is a _lot_ more punctuation in Elixir. Also much more explicit passing of parameters, including database connections and error handlers in the case of a Phoenix application. It&#x27;s also a challenge to deploy OTP along other non-hypervised runtimes. BEAM and Elixir are very cool, don&#x27;t get me wrong, but after some programming web services in Elixir I was ready to head back to Ruby. If I need a highly fault tolerant near realtime comms system, I&#x27;ll look at Elixir, otherwise I avoid.</div><br/><div id="38215140" class="c"><input type="checkbox" id="c-38215140" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#38214956">parent</a><span>|</span><a href="#38214960">next</a><span>|</span><label class="collapse" for="c-38215140">[-]</label><label class="expand" for="c-38215140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s also a challenge to deploy OTP along other non-hypervised runtimes.<p>What in tarnation. Please expand on this one.</div><br/></div></div><div id="38214960" class="c"><input type="checkbox" id="c-38214960" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38214956">parent</a><span>|</span><a href="#38215140">prev</a><span>|</span><label class="collapse" for="c-38214960">[-]</label><label class="expand" for="c-38214960">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s also a challenge to deploy OTP along other non-hypervised runtimes.<p>Pardon?</div><br/><div id="38215074" class="c"><input type="checkbox" id="c-38215074" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#38214956">root</a><span>|</span><a href="#38214960">parent</a><span>|</span><label class="collapse" for="c-38215074">[-]</label><label class="expand" for="c-38215074">[2 more]</label></div><br/><div class="children"><div class="content">This part stumped me too.  Maybe op had some deployment issues on VM systems.</div><br/><div id="38215270" class="c"><input type="checkbox" id="c-38215270" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38214956">root</a><span>|</span><a href="#38215074">parent</a><span>|</span><label class="collapse" for="c-38215270">[-]</label><label class="expand" for="c-38215270">[1 more]</label></div><br/><div class="children"><div class="content">ngl I get a sense the op and most people commenting in this thread don’t understand elixir at all. the fact that the syntax somewhat resembles ruby is really just 5% of what makes elixir interesting. It’s a distraction from the real value of the beam, OTP, and immutable data.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>