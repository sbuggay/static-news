<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719219674315" as="style"/><link rel="stylesheet" href="styles.css?v=1719219674315"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eprint.iacr.org/2024/677">Asynchronous Consensus Without Trusted Setup or Public-Key Cryptography</a> <span class="domain">(<a href="https://eprint.iacr.org">eprint.iacr.org</a>)</span></div><div class="subtext"><span>simonpure</span> | <span>49 comments</span></div><br/><div><div id="40768030" class="c"><input type="checkbox" id="c-40768030" checked=""/><div class="controls bullet"><span class="by">Rhapso</span><span>|</span><a href="#40767494">next</a><span>|</span><label class="collapse" for="c-40768030">[-]</label><label class="expand" for="c-40768030">[12 more]</label></div><br/><div class="children"><div class="content">So the protocol seems to boil down to:<p>1) Already have a leader &quot;Dealer&quot;<p>2) The leader builds a K-of-N set of shared secret keys.<p>3) They publish a mapping of each participant (participant_i-&gt;hash(secret_i))<p>4) The leader transmits each key to each participant<p>5) Participants exchange secrets pairwise, armed with the upfront mapping of participants-&gt;secrets<p>6) Select K and a k-of-N secret scheme such that a majority of participants now have a shared key<p>lots of the claims aren&#x27;t meaningful:<p>- &quot;post quantum&quot; for example isn&#x27;t a special value in this situation.<p>- &quot;minimal use of cryptography&quot; isn&#x27;t relevant to practicality<p>- The &quot;experimental&quot; component doesn&#x27;t meaningful contribute to the conclusion.<p>- No public-key-encryption really means &quot;outsource sender identification to the network layer&quot;<p>- They pretend using a system of equations to solve for a shared key isn&#x27;t&quot;cryptography&quot;.<p>In general the contribution of the paper reads as &quot;offusicated&quot;. The lack of &quot;public key cryptography&quot; sets them up for a novel problem to solve, but it is an arbitrary handicap that doesn&#x27;t provide utility.<p>This is academic &quot;make up a novel and nontrivial problem and then solve it&quot;, its of utility to the process of producing grad students and publication count but not something we need to get excited about. Read it like a survey paper of the space, which it does well as.</div><br/><div id="40771248" class="c"><input type="checkbox" id="c-40771248" checked=""/><div class="controls bullet"><span class="by">c0742e9366</span><span>|</span><a href="#40768030">parent</a><span>|</span><a href="#40768550">next</a><span>|</span><label class="collapse" for="c-40771248">[-]</label><label class="expand" for="c-40771248">[2 more]</label></div><br/><div class="children"><div class="content">I disagree with this uncharitable view of the paper.<p>First, an important missing point is that the protocol does <i>not</i> require trusted setup. In contrast, most prior works require that parties hold threshold secret keys (necessitating a trusted third-party or expensive setup procedure).<p>Second, a lot of effort is currently being poured into the transition to post-quantum. So having a post-quantum secure protocol is evidently valuable to a lot of people.<p>Third, Byzantine agreement protocols usually always assume pairwise private and authenticated communication channels. It makes sense that  protocols should not need to concern themselves with the communication layer and such channels can be realized from standard cryptographic building blocks anyways. Here the paper not using any PK-cryptography is especially nice because the protocol can be layered on top without a lot of fuss—no matter what the channels are based on.<p>Last, this problem is far from &quot;made up&quot;. It was an obvious (and also seemingly hard to solve) to people working in this area. Also, Byzantine agreement is a practically important problem and this is an elegant solution.</div><br/></div></div><div id="40768550" class="c"><input type="checkbox" id="c-40768550" checked=""/><div class="controls bullet"><span class="by">xhkkffbf</span><span>|</span><a href="#40768030">parent</a><span>|</span><a href="#40771248">prev</a><span>|</span><a href="#40769079">next</a><span>|</span><label class="collapse" for="c-40768550">[-]</label><label class="expand" for="c-40768550">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not as cynical. I think quests like this are important to understanding what&#x27;s important and not-so-important in protocols. Quests like post-quantum algorithms are important for me not because I believe in the chance of any quantum machine coming along. It&#x27;s because we learn so much. The foundation of many public key systems is pretty sketchy. We trust them because no one has publicly described how to break them. But that doesn&#x27;t mean that the truth isn&#x27;t out there.</div><br/><div id="40769293" class="c"><input type="checkbox" id="c-40769293" checked=""/><div class="controls bullet"><span class="by">Rhapso</span><span>|</span><a href="#40768030">root</a><span>|</span><a href="#40768550">parent</a><span>|</span><a href="#40769079">next</a><span>|</span><label class="collapse" for="c-40769293">[-]</label><label class="expand" for="c-40769293">[6 more]</label></div><br/><div class="children"><div class="content">Right but &quot;Avoiding PKI&quot; and &quot;Secure Against Quantum Computers&quot; barely even correlate. We have methods we consider post-quantum in heavy use. &quot;PKI is generally sketchy and we would like to explore alternatives&quot; is actually a much better rationalization than &quot;post-quantum buzzword dropping&quot;</div><br/><div id="40770315" class="c"><input type="checkbox" id="c-40770315" checked=""/><div class="controls bullet"><span class="by">ogisan</span><span>|</span><a href="#40768030">root</a><span>|</span><a href="#40769293">parent</a><span>|</span><a href="#40770343">next</a><span>|</span><label class="collapse" for="c-40770315">[-]</label><label class="expand" for="c-40770315">[2 more]</label></div><br/><div class="children"><div class="content">I disagree. Avoiding PKI and post-quantum security correlate very much. Even under <i>plausibly</i> post-quantum assumptions we only have a couple of assumptions from which we can build public key encryption. In contrast, here they avoid all use of public key cryptography which makes it <i>provably</i> post-quantum secure.  It’s not using a buzzword for the sole sake of selling the paper. In general, using “minimal cryptography” (like random oracles &#x2F; one-way functions) translates to real-world efficiency because you can instantiate these from a plethora of different concrete candidates.</div><br/><div id="40770614" class="c"><input type="checkbox" id="c-40770614" checked=""/><div class="controls bullet"><span class="by">ilya_m</span><span>|</span><a href="#40768030">root</a><span>|</span><a href="#40770315">parent</a><span>|</span><a href="#40770343">next</a><span>|</span><label class="collapse" for="c-40770614">[-]</label><label class="expand" for="c-40770614">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Avoiding PKI and post-quantum security correlate very much. Even under plausibly post-quantum assumptions we only have a couple of assumptions from which we can build public key encryption.<p>These statements presuppose an overly expansive definition of PKI, i.e., distribution of keys for public-key <i>encryption</i>. A more conservative definition is PKI = availability of trustworthy publicly verifiable <i>signatures</i> (i.e., public-key certificates). Post-quantum signatures can be based on target collision-resistant hash functions, like XMSS.<p>The paper assumes pairwise private and authenticated channels. While in practice this is not necessarily a good substitute for PKI, in theory it is a strictly weaker setting.</div><br/></div></div></div></div><div id="40770343" class="c"><input type="checkbox" id="c-40770343" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#40768030">root</a><span>|</span><a href="#40769293">parent</a><span>|</span><a href="#40770315">prev</a><span>|</span><a href="#40769079">next</a><span>|</span><label class="collapse" for="c-40770343">[-]</label><label class="expand" for="c-40770343">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m only somewhat into cryptography, but is PKI considered as sketchy in some way?</div><br/><div id="40770534" class="c"><input type="checkbox" id="c-40770534" checked=""/><div class="controls bullet"><span class="by">Rhapso</span><span>|</span><a href="#40768030">root</a><span>|</span><a href="#40770343">parent</a><span>|</span><a href="#40769079">next</a><span>|</span><label class="collapse" for="c-40770534">[-]</label><label class="expand" for="c-40770534">[2 more]</label></div><br/><div class="children"><div class="content">No.<p>The proofs for the security security of most of the methods of public&#x2F;private key systems are weaker than &quot;you can&#x27;t reverse this hash function&quot;.<p>They are still robust in the face of computers that may physically exist in foreseeable futures. Elliptic Curve Encryption was adopted for being post-quantum twenty years ago and more work since then I haven&#x27;t followed.<p>The person I am arguing with is imagining a future pessimistic beyond what most would consider reasonable.</div><br/><div id="40773079" class="c"><input type="checkbox" id="c-40773079" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#40768030">root</a><span>|</span><a href="#40770534">parent</a><span>|</span><a href="#40769079">next</a><span>|</span><label class="collapse" for="c-40773079">[-]</label><label class="expand" for="c-40773079">[1 more]</label></div><br/><div class="children"><div class="content">Elliptic curve crypto is not post-quantum. (Indeed it’s likely to be broken before RSA if cryptographically relevant quantum computers occur).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40769079" class="c"><input type="checkbox" id="c-40769079" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40768030">parent</a><span>|</span><a href="#40768550">prev</a><span>|</span><a href="#40771854">next</a><span>|</span><label class="collapse" for="c-40769079">[-]</label><label class="expand" for="c-40769079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - No public-key-encryption really means &quot;outsource sender identification to the network layer&quot;<p>Yeah I didn&#x27;t read the full paper but from the abstract my intuition was telling me they just assumed away a bunch of things that are fairly necessary when actually implementing a BFT consensus as part of the environment.</div><br/></div></div></div></div><div id="40767494" class="c"><input type="checkbox" id="c-40767494" checked=""/><div class="controls bullet"><span class="by">monocultured</span><span>|</span><a href="#40768030">prev</a><span>|</span><a href="#40769624">next</a><span>|</span><label class="collapse" for="c-40767494">[-]</label><label class="expand" for="c-40767494">[2 more]</label></div><br/><div class="children"><div class="content">This sounds interesting but the description goes way over my head. Anyone care to explain in layman&#x27;s terms the concept and the non-obvious benefits?</div><br/><div id="40768023" class="c"><input type="checkbox" id="c-40768023" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#40767494">parent</a><span>|</span><a href="#40769624">next</a><span>|</span><label class="collapse" for="c-40768023">[-]</label><label class="expand" for="c-40768023">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to answer that without you saying what you think the obvious benefits are.<p>Consensus algorithms are important for all kinds of distributed computing problems. A simple example would be failover. If you have a leader database that replicates to 4 others, and you want another node to take over if the leader DB fails, then you need a consensus algorithm to prevent a situation where 2 different machines both think they&#x27;re the new leader in a netsplit.<p>There are many other equivalent problems in distributed computing, from atomic transactions to &quot;exactly once&quot; messaging systems.<p>Asynchronous consensus is a model where you cannot make assumptions about the bounded nature of call timings, whereas in a synchronous model, you can assume everything is bounded.<p>Byzantine fault tolerance is important for security under byzantine faults, that is to say malicious actors acting deliberately against what the protocol specifies they should do.</div><br/></div></div></div></div><div id="40769624" class="c"><input type="checkbox" id="c-40769624" checked=""/><div class="controls bullet"><span class="by">ngneer</span><span>|</span><a href="#40767494">prev</a><span>|</span><a href="#40768212">next</a><span>|</span><label class="collapse" for="c-40769624">[-]</label><label class="expand" for="c-40769624">[1 more]</label></div><br/><div class="children"><div class="content">I was expecting multivariate polynomials, as those used to be all the rage. Just an example: <a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;9066840" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;9066840</a></div><br/></div></div><div id="40768212" class="c"><input type="checkbox" id="c-40768212" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#40769624">prev</a><span>|</span><a href="#40767579">next</a><span>|</span><label class="collapse" for="c-40768212">[-]</label><label class="expand" for="c-40768212">[7 more]</label></div><br/><div class="children"><div class="content">I kind of wish Git had a feature where multiple people could sign a PR or commit.<p>Is there a multiple signature method that isn&#x27;t &quot;just&quot; signing other people&#x27;s signatures?</div><br/><div id="40769670" class="c"><input type="checkbox" id="c-40769670" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40768212">parent</a><span>|</span><a href="#40772252">next</a><span>|</span><label class="collapse" for="c-40769670">[-]</label><label class="expand" for="c-40769670">[1 more]</label></div><br/><div class="children"><div class="content">I guess you could sign a git note[1] on an existing commit. As a bonus you could add metadata about what you are actually signing off, like &quot;approved&quot; or even &quot;rejected&quot;.<p>Just adding an additional signature on top of an existing commit wouldn&#x27;t carry too much info. What are you actually signing off on? Is it approval? Is it acknowledgement? And then it can be hard to sign off on something negative, like  a code review that rejects.<p>[1] <a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-notes" rel="nofollow">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-notes</a></div><br/></div></div><div id="40772252" class="c"><input type="checkbox" id="c-40772252" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#40768212">parent</a><span>|</span><a href="#40769670">prev</a><span>|</span><a href="#40768727">next</a><span>|</span><label class="collapse" for="c-40772252">[-]</label><label class="expand" for="c-40772252">[1 more]</label></div><br/><div class="children"><div class="content">You can sign tags, and you can make as many tags as you want. So for example you could have &#x27;dev1-1.0&#x27; signed by dev1, &#x27;dev2-1.0&#x27; signed by dev2, etc to have that revision signed by multiple developers.</div><br/></div></div><div id="40768727" class="c"><input type="checkbox" id="c-40768727" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#40768212">parent</a><span>|</span><a href="#40772252">prev</a><span>|</span><a href="#40768483">next</a><span>|</span><label class="collapse" for="c-40768727">[-]</label><label class="expand" for="c-40768727">[3 more]</label></div><br/><div class="children"><div class="content">if you have a trusted central party you could reconstruct shards of a signing key, known as threshold cryptography eg Shamirs Secret Sharing</div><br/><div id="40769094" class="c"><input type="checkbox" id="c-40769094" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40768212">root</a><span>|</span><a href="#40768727">parent</a><span>|</span><a href="#40768483">next</a><span>|</span><label class="collapse" for="c-40769094">[-]</label><label class="expand" for="c-40769094">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need a trusted central party.  You can sign using just shamir shares with a multi-round MPC protocol without ever reconstructing the real key.  There&#x27;s round-optimized schemes like MuSig2 and FROST for specifically schnorr-based signatures, which GPG doesn&#x27;t support but are used in other places.  I don&#x27;t know what the effort to integrate that into git would look like.</div><br/><div id="40770465" class="c"><input type="checkbox" id="c-40770465" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#40768212">root</a><span>|</span><a href="#40769094">parent</a><span>|</span><a href="#40768483">next</a><span>|</span><label class="collapse" for="c-40770465">[-]</label><label class="expand" for="c-40770465">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re just signing, is there any role for MPC in in there?</div><br/></div></div></div></div></div></div></div></div><div id="40767579" class="c"><input type="checkbox" id="c-40767579" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#40768212">prev</a><span>|</span><a href="#40769784">next</a><span>|</span><label class="collapse" for="c-40767579">[-]</label><label class="expand" for="c-40767579">[9 more]</label></div><br/><div class="children"><div class="content">Haven’t had a chance to go through this but my instant #1 question is security against malicious nodes.<p>All such protocols, even Bitcoin and friends, break under a sufficiently costly Sybil attack. The trick with cryptocurrency is to make the attack so expensive that it requires a highly economically irrational actor.<p>What are the thresholds here?</div><br/><div id="40767715" class="c"><input type="checkbox" id="c-40767715" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40767579">parent</a><span>|</span><a href="#40771990">next</a><span>|</span><label class="collapse" for="c-40767715">[-]</label><label class="expand" for="c-40767715">[4 more]</label></div><br/><div class="children"><div class="content">This is a Byzantine agreement protocol. By definition it is a construction taking into account malicious nodes: that is what Byzantine agreement means. Table 1 says that this algorithm, like all the rest except one in the table, has fault tolerance 1&#x2F;3 which is optimal. The second page also says &quot;We consider the presence of a static adversary A that can
corrupt up to t out of the n ≥ 3t + 1 parties. &quot;</div><br/><div id="40767939" class="c"><input type="checkbox" id="c-40767939" checked=""/><div class="controls bullet"><span class="by">repelsteeltje</span><span>|</span><a href="#40767579">root</a><span>|</span><a href="#40767715">parent</a><span>|</span><a href="#40771990">next</a><span>|</span><label class="collapse" for="c-40767939">[-]</label><label class="expand" for="c-40767939">[3 more]</label></div><br/><div class="children"><div class="content">&gt; ... <i>static adversary A</i> that can corrupt ...<p>Doesn&#x27;t that mean that an adversary using multiple identities <i>would</i> be able to do so? And therefore, some means of limiting the number of identities (through public key or prior trust) would still be desirable?<p>What am I missing? Is this mitigated through staking?</div><br/><div id="40768059" class="c"><input type="checkbox" id="c-40768059" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40767579">root</a><span>|</span><a href="#40767939">parent</a><span>|</span><a href="#40771990">next</a><span>|</span><label class="collapse" for="c-40768059">[-]</label><label class="expand" for="c-40768059">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not missing anything. Systems like this assume there is a pre-created set of honest and independent nodes, which might later get hacked. They don&#x27;t apply in the more realistic setting the PoW blockchain algorithm solves, where nodes can enter and leave the consensus at will and may be malicious or non-independent from the start.</div><br/><div id="40768207" class="c"><input type="checkbox" id="c-40768207" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40767579">root</a><span>|</span><a href="#40768059">parent</a><span>|</span><a href="#40771990">next</a><span>|</span><label class="collapse" for="c-40768207">[-]</label><label class="expand" for="c-40768207">[1 more]</label></div><br/><div class="children"><div class="content">You just do rounds of fixed sets of parties, like Ethereum proof of stake does. The set of nodes in each round are then needed to be 2&#x2F;3rds honest. They then have Sybil resistance in each round as identities aren&#x27;t free, since you need a stake in order to be selected for a round.</div><br/></div></div></div></div></div></div></div></div><div id="40771990" class="c"><input type="checkbox" id="c-40771990" checked=""/><div class="controls bullet"><span class="by">Quiark</span><span>|</span><a href="#40767579">parent</a><span>|</span><a href="#40767715">prev</a><span>|</span><a href="#40767714">next</a><span>|</span><label class="collapse" for="c-40771990">[-]</label><label class="expand" for="c-40771990">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s important to realise the difference between consensus and Sybil prevention protocols. Consensus such as this one assumes participants are already selected and known to some extent. Then it runs its network messages to ensure it agrees on a value where everyone has the same value and won&#x27;t revert or anything.<p>Sybil prevention is something that I wasn&#x27;t taught at school and it concerns itself with creating the pre-requisites for consensus algorithm. Given the world population, how do we establish participant set for consensus while minimizing their chance to attack. Well, maybe by requiring them to waste record-breaking amounts of stupid compute.</div><br/></div></div><div id="40767906" class="c"><input type="checkbox" id="c-40767906" checked=""/><div class="controls bullet"><span class="by">alfiedotwtf</span><span>|</span><a href="#40767579">parent</a><span>|</span><a href="#40767714">prev</a><span>|</span><a href="#40772711">next</a><span>|</span><label class="collapse" for="c-40767906">[-]</label><label class="expand" for="c-40767906">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think a Sybil attack will work on a Staking network since the leader is known and a MITM can’t broadcast a block without the leader’s key. The only think they can do is take them off line to prevent a solved block from getting sent to the network, but that problem exists without taking into account Sybil attacks</div><br/></div></div><div id="40772711" class="c"><input type="checkbox" id="c-40772711" checked=""/><div class="controls bullet"><span class="by">kfrzcode</span><span>|</span><a href="#40767579">parent</a><span>|</span><a href="#40767906">prev</a><span>|</span><a href="#40769784">next</a><span>|</span><label class="collapse" for="c-40772711">[-]</label><label class="expand" for="c-40772711">[1 more]</label></div><br/><div class="children"><div class="content">Hedera Hashgraph uses Proof-of-Stake consensus, stake weighting, aBFT and minimum stake threshold with node staking delegation. Malicious nodes can lose delegators. If a node doesn&#x27;t participate in consensus it won&#x27;t receive rewards. 
I&#x27;m not aware of any consensus mechanisms invulnerable to Sybil attacks but I am simple pleb.<p><a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;9191430" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;9191430</a></div><br/></div></div></div></div><div id="40769784" class="c"><input type="checkbox" id="c-40769784" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#40767579">prev</a><span>|</span><a href="#40768509">next</a><span>|</span><label class="collapse" for="c-40769784">[-]</label><label class="expand" for="c-40769784">[6 more]</label></div><br/><div class="children"><div class="content">Please note the Cryptology ePrint Archive is not a peer-reviewed source. The description of the paper may indicate another (peer-reviewed) publication, but this is entirely optional and not required for a submission.<p>Edit: Adding this as a PSA in case folks start debating the veracity assuming this has undergone review by experts.</div><br/><div id="40770655" class="c"><input type="checkbox" id="c-40770655" checked=""/><div class="controls bullet"><span class="by">ilya_m</span><span>|</span><a href="#40769784">parent</a><span>|</span><a href="#40771857">next</a><span>|</span><label class="collapse" for="c-40770655">[-]</label><label class="expand" for="c-40770655">[4 more]</label></div><br/><div class="children"><div class="content">To be fair, peer-reviewed publications are not what they used to be. For example, the conference reviewing process is not designed to validate correctness of the submissions. (Obviously wrong papers are filtered out most of the time, but this is a welcome side effect, not - apparently - their main objective.) See, for instance, recent Carlini&#x27;s experience of reporting a demonstrably flawed paper to the chairs of a major conference: <a href="https:&#x2F;&#x2F;nicholas.carlini.com&#x2F;writing&#x2F;2024&#x2F;yet-another-broken-defense.html" rel="nofollow">https:&#x2F;&#x2F;nicholas.carlini.com&#x2F;writing&#x2F;2024&#x2F;yet-another-broken...</a></div><br/><div id="40770761" class="c"><input type="checkbox" id="c-40770761" checked=""/><div class="controls bullet"><span class="by">Rhapso</span><span>|</span><a href="#40769784">root</a><span>|</span><a href="#40770655">parent</a><span>|</span><a href="#40772943">next</a><span>|</span><label class="collapse" for="c-40770761">[-]</label><label class="expand" for="c-40770761">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, sadly this paper is a reasonable example of the status quo. There is a contribution in there under all the cruft (if we assume a trusted leader, and we can authenticate message origin, we don&#x27;t have to use Public&#x2F;private key encryption to build a shared secret key, hash functions and k-of-n secret sharing are enough) it is just very narrow and they feel like they have to &quot;dress it up&quot; a lot.<p>If they actually wrote their contribution in clear terms they couldn&#x27;t get it published because it sounds too simple. I think they should be able able to get it published without inflating it&#x27;s complexity like this. They are just reacting to a broken system.</div><br/><div id="40771341" class="c"><input type="checkbox" id="c-40771341" checked=""/><div class="controls bullet"><span class="by">c0742e9366</span><span>|</span><a href="#40769784">root</a><span>|</span><a href="#40770761">parent</a><span>|</span><a href="#40772943">next</a><span>|</span><label class="collapse" for="c-40771341">[-]</label><label class="expand" for="c-40771341">[1 more]</label></div><br/><div class="children"><div class="content">It’s unfair to equate this paper to obviously flawed ones since all their claims seem to be properly substantiated. Also, the protocol does not assume a trusted leader (otherwise agreement would be trivially solved).<p>In general, I am also not fond of this writing style. However, if one reads more papers published in this community&#x2F;area, then one notices that many of them are written similarly. Since the primary audience of these papers are other researchers in the same area, they are presumably able to read past the cruft efficiently.<p>I also agree that academia incentivizes overselling results. In this case, however, this is a nice result and not oversold by the authors (being somewhat knowledgeable in this field).</div><br/></div></div></div></div><div id="40772943" class="c"><input type="checkbox" id="c-40772943" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#40769784">root</a><span>|</span><a href="#40770655">parent</a><span>|</span><a href="#40770761">prev</a><span>|</span><a href="#40771857">next</a><span>|</span><label class="collapse" for="c-40772943">[-]</label><label class="expand" for="c-40772943">[1 more]</label></div><br/><div class="children"><div class="content">&gt;To be fair, peer-reviewed publications are not what they used to be.<p>They were never what most people thought they were. At their best, they amounted to &quot;a few relevant experts in the same field read the paper and didn&#x27;t find any blatantly obvious methodological errors.&quot;</div><br/></div></div></div></div></div></div><div id="40767556" class="c"><input type="checkbox" id="c-40767556" checked=""/><div class="controls bullet"><span class="by">steelframe</span><span>|</span><a href="#40768509">prev</a><span>|</span><label class="collapse" for="c-40767556">[-]</label><label class="expand" for="c-40767556">[10 more]</label></div><br/><div class="children"><div class="content">Their protocol only uses cryptographic hash functions, which means that it&#x27;s post-quantum secure. One reason why this is significant is because existing post-quantum public key algorithms such as SPHINCS+ use much larger keys than classic public key algorithms such as RSA or ECDH.<p>*Edit: As other have pointed out, for SPHINCS+ it&#x27;s the signature size and not the key size that&#x27;s significantly larger.</div><br/><div id="40767819" class="c"><input type="checkbox" id="c-40767819" checked=""/><div class="controls bullet"><span class="by">jythonscript</span><span>|</span><a href="#40767556">parent</a><span>|</span><a href="#40767876">next</a><span>|</span><label class="collapse" for="c-40767819">[-]</label><label class="expand" for="c-40767819">[1 more]</label></div><br/><div class="children"><div class="content">Minor note, I&#x27;m not an expert in this field but I believe SPHINCS+ uses smaller key sizes than RSA, but is notable for producing much larger signatures than RSA or ECDSA.</div><br/></div></div><div id="40767876" class="c"><input type="checkbox" id="c-40767876" checked=""/><div class="controls bullet"><span class="by">lagniappe</span><span>|</span><a href="#40767556">parent</a><span>|</span><a href="#40767819">prev</a><span>|</span><a href="#40767806">next</a><span>|</span><label class="collapse" for="c-40767876">[-]</label><label class="expand" for="c-40767876">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Their protocol only uses cryptographic hash functions, which means that it&#x27;s post-quantum secure<p>Can you elaborate on this?</div><br/><div id="40767996" class="c"><input type="checkbox" id="c-40767996" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40767556">root</a><span>|</span><a href="#40767876">parent</a><span>|</span><a href="#40767806">next</a><span>|</span><label class="collapse" for="c-40767996">[-]</label><label class="expand" for="c-40767996">[1 more]</label></div><br/><div class="children"><div class="content">Inverting a general-purpose cryptographic hash function in the quantum setting is (roughly) as hard as it is in the classical setting.<p>(Roughly because of Grover’s algorithm, but there are algorithms that perform similarly or better on classical machines. Which is why modern hash functions have relatively large margins anyways.)</div><br/></div></div></div></div><div id="40767806" class="c"><input type="checkbox" id="c-40767806" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40767556">parent</a><span>|</span><a href="#40767876">prev</a><span>|</span><a href="#40767677">next</a><span>|</span><label class="collapse" for="c-40767806">[-]</label><label class="expand" for="c-40767806">[1 more]</label></div><br/><div class="children"><div class="content">Only PQ hash functions are PQ FWIU. Other cryptographic hash functions are not NIST PQ standardization finalists; I don&#x27;t think any were even submitted with &quot;just double the key&#x2F;hash size for the foreseeable future&quot; as a parameter as is suggested here. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25009925">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25009925</a><p>NIST Post-Quantum Cryptography Standardization &gt; Round 3 &gt;
Selected Algorithms 2022 &gt; Hash based &gt; SPHINCS+: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NIST_Post-Quantum_Cryptography_Standardization#Finalists" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NIST_Post-Quantum_Cryptography...</a><p>SPHINCS+ is a hash based PQ Post Quantum (quantum resistant) cryptographic signature algorithm.<p>SPHINCS+: <a href="https:&#x2F;&#x2F;github.com&#x2F;sphincs&#x2F;sphincsplus">https:&#x2F;&#x2F;github.com&#x2F;sphincs&#x2F;sphincsplus</a></div><br/></div></div><div id="40767677" class="c"><input type="checkbox" id="c-40767677" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#40767556">parent</a><span>|</span><a href="#40767806">prev</a><span>|</span><label class="collapse" for="c-40767677">[-]</label><label class="expand" for="c-40767677">[5 more]</label></div><br/><div class="children"><div class="content">For those here who don’t know<p>SPHINCS is essentially Lamport Signatures and SPHINCS+ is essentially removing the need to store “state” by using chains of hashes and a random oracle<p><a href="https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;54304&#x2F;difference-between-gravity-sphincs-and-sphincs" rel="nofollow">https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;54304&#x2F;difference-...</a><p>I prefer tham to lattice-based methods because it seems to me that cryptographic hashes (and other trapdoor functions) are more likely to be quantum-resistant than lattices (for which an algorithm like Shor’s algorithm merely hasn’t been found yet).</div><br/><div id="40767770" class="c"><input type="checkbox" id="c-40767770" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40767556">root</a><span>|</span><a href="#40767677">parent</a><span>|</span><label class="collapse" for="c-40767770">[-]</label><label class="expand" for="c-40767770">[4 more]</label></div><br/><div class="children"><div class="content">In case you haven&#x27;t seen, there was actually a quantum algorithm on preprint recently for solving some class of learning with errors problems in polynomial time. <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2024&#x2F;555" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2024&#x2F;555</a></div><br/><div id="40767832" class="c"><input type="checkbox" id="c-40767832" checked=""/><div class="controls bullet"><span class="by">fdupress</span><span>|</span><a href="#40767556">root</a><span>|</span><a href="#40767770">parent</a><span>|</span><a href="#40767930">next</a><span>|</span><label class="collapse" for="c-40767832">[-]</label><label class="expand" for="c-40767832">[2 more]</label></div><br/><div class="children"><div class="content">And since you apparently haven&#x27;t seen, the abstract now includes the following note.<p>&gt; Note: Update on April 18: Step 9 of the algorithm contains a bug, which I don’t know how to fix. See Section 3.5.9 (Page 37) for details. I sincerely thank Hongxun Wu and (independently) Thomas Vidick for finding the bug today. Now the claim of showing a polynomial time quantum algorithm for solving LWE with polynomial modulus-noise ratios does not hold. I leave the rest of the paper as it is (added a clarification of an operation in Step 8) as a hope that ideas like Complex Gaussian and windowed QFT may find other applications in quantum computation, or tackle LWE in other ways.</div><br/><div id="40768211" class="c"><input type="checkbox" id="c-40768211" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40767556">root</a><span>|</span><a href="#40767832">parent</a><span>|</span><a href="#40767930">next</a><span>|</span><label class="collapse" for="c-40768211">[-]</label><label class="expand" for="c-40768211">[1 more]</label></div><br/><div class="children"><div class="content">Oops, I did not, thank you!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>