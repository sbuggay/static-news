<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721898068683" as="style"/><link rel="stylesheet" href="styles.css?v=1721898068683"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://righteousit.com/2024/07/24/hiding-linux-processes-with-bind-mounts/">Hiding Linux Processes with Bind Mounts</a>Â <span class="domain">(<a href="https://righteousit.com">righteousit.com</a>)</span></div><div class="subtext"><span>indigodaddy</span> | <span>48 comments</span></div><br/><div><div id="41060563" class="c"><input type="checkbox" id="c-41060563" checked=""/><div class="controls bullet"><span class="by">jordemort</span><span>|</span><a href="#41059861">next</a><span>|</span><label class="collapse" for="c-41060563">[-]</label><label class="expand" for="c-41060563">[17 more]</label></div><br/><div class="children"><div class="content">If you have the privilege to pull off bind-mounting on top of a particular process directory in &#x2F;proc you should also be able to mount something on top of &#x2F;proc itself that will present a false &#x2F;proc&#x2F;mounts and conceal your trickery. I experimented a bit and wasn&#x27;t able to bind a single file on top of &#x2F;proc&#x2F;mounts and I seem to be having trouble getting procfs to participate in an overlayfs, but if you were really dedicated you could construct a whole fake &#x2F;proc by hand, or create something using FUSE to create a &#x2F;proc that redacts anything you want, including mountpoints.</div><br/><div id="41062077" class="c"><input type="checkbox" id="c-41062077" checked=""/><div class="controls bullet"><span class="by">jasonjayr</span><span>|</span><a href="#41060563">parent</a><span>|</span><a href="#41061348">next</a><span>|</span><label class="collapse" for="c-41062077">[-]</label><label class="expand" for="c-41062077">[3 more]</label></div><br/><div class="children"><div class="content">If you have root of course, you can do anything, BUT -- could a eBPF module be loaded into the kernel to just filter the syscalls to hide some nefarious process?  This simplifies the &#x27;evil VM&#x27; attack.  Does eBPF have anything that could plausably help with that?</div><br/><div id="41062775" class="c"><input type="checkbox" id="c-41062775" checked=""/><div class="controls bullet"><span class="by">tatref</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41062077">parent</a><span>|</span><a href="#41064023">next</a><span>|</span><label class="collapse" for="c-41062775">[-]</label><label class="expand" for="c-41062775">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;sysdig.com&#x2F;blog&#x2F;ebpf-offensive-capabilities&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sysdig.com&#x2F;blog&#x2F;ebpf-offensive-capabilities&#x2F;</a></div><br/></div></div><div id="41064023" class="c"><input type="checkbox" id="c-41064023" checked=""/><div class="controls bullet"><span class="by">chucky_z</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41062077">parent</a><span>|</span><a href="#41062775">prev</a><span>|</span><a href="#41061348">next</a><span>|</span><label class="collapse" for="c-41064023">[-]</label><label class="expand" for="c-41064023">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure you can do this with standard MAC ala SELinux&#x2F;AppArmor.</div><br/></div></div></div></div><div id="41061348" class="c"><input type="checkbox" id="c-41061348" checked=""/><div class="controls bullet"><span class="by">compsciphd</span><span>|</span><a href="#41060563">parent</a><span>|</span><a href="#41062077">prev</a><span>|</span><a href="#41061002">next</a><span>|</span><label class="collapse" for="c-41061348">[-]</label><label class="expand" for="c-41061348">[1 more]</label></div><br/><div class="children"><div class="content">creating a whole fake proc is simple.  I mean the code is already in the kernel as a module.  Just copy it, put a few if&#x2F;else&#x27;s in the code to control what its readdir ( this case just pid&#x27;s there&#x27;s proc_readdir() that calls proc_pid_readdir(), just modify that very simply).<p>mount is a bit harder (as its calls into code that is more in the core kernel fs code, but one can just reimplement it oneself, to filter out the mounts you don&#x27;t want to show.</div><br/></div></div><div id="41061002" class="c"><input type="checkbox" id="c-41061002" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41060563">parent</a><span>|</span><a href="#41061348">prev</a><span>|</span><a href="#41060596">next</a><span>|</span><label class="collapse" for="c-41061002">[-]</label><label class="expand" for="c-41061002">[8 more]</label></div><br/><div class="children"><div class="content">Can you do similar trickery to ensure `mount` doesn&#x27;t list your bind mount?</div><br/><div id="41062087" class="c"><input type="checkbox" id="c-41062087" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41061002">parent</a><span>|</span><a href="#41060596">next</a><span>|</span><label class="collapse" for="c-41062087">[-]</label><label class="expand" for="c-41062087">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why not - that&#x27;s just reading from &#x2F;proc&#x2F;mounts.</div><br/><div id="41062606" class="c"><input type="checkbox" id="c-41062606" checked=""/><div class="controls bullet"><span class="by">dredmorbius</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41062087">parent</a><span>|</span><a href="#41060596">next</a><span>|</span><label class="collapse" for="c-41062606">[-]</label><label class="expand" for="c-41062606">[6 more]</label></div><br/><div class="children"><div class="content">Nitpicking:  <i>mount</i> reads from &#x2F;proc&#x2F;<i>self</i>&#x2F;mounts, that is, the mounts as seen <i>from that process</i>.   This is how tricks such as chroot jails work, as they present a different mount set and filesystem tree from the base system.</div><br/><div id="41063249" class="c"><input type="checkbox" id="c-41063249" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41062606">parent</a><span>|</span><a href="#41063956">next</a><span>|</span><label class="collapse" for="c-41063249">[-]</label><label class="expand" for="c-41063249">[2 more]</label></div><br/><div class="children"><div class="content">Same thing, really - &#x2F;proc&#x2F;mounts is a symlink to &#x2F;proc&#x2F;self&#x2F;mounts.</div><br/><div id="41063470" class="c"><input type="checkbox" id="c-41063470" checked=""/><div class="controls bullet"><span class="by">dredmorbius</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41063249">parent</a><span>|</span><a href="#41063956">next</a><span>|</span><label class="collapse" for="c-41063470">[-]</label><label class="expand" for="c-41063470">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough, though casual readers may not realise this.</div><br/></div></div></div></div><div id="41063956" class="c"><input type="checkbox" id="c-41063956" checked=""/><div class="controls bullet"><span class="by">caf</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41062606">parent</a><span>|</span><a href="#41063249">prev</a><span>|</span><a href="#41060596">next</a><span>|</span><label class="collapse" for="c-41063956">[-]</label><label class="expand" for="c-41063956">[3 more]</label></div><br/><div class="children"><div class="content">chroot is a different, older system that pre-dates different mount namespaces.</div><br/><div id="41064027" class="c"><input type="checkbox" id="c-41064027" checked=""/><div class="controls bullet"><span class="by">dredmorbius</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41063956">parent</a><span>|</span><a href="#41060596">next</a><span>|</span><label class="collapse" for="c-41064027">[-]</label><label class="expand" for="c-41064027">[2 more]</label></div><br/><div class="children"><div class="content">My understanding is that chroot presently <i>does</i> make use of the different mount namespaces, though I could be wrong here.<p>How did chroot used to work in this regard?  Were mountpoints outside the chroot jail itself accessible?  Because if so, that ... would violate some key points of using a chroot jail in the first place.  Though if chroot applied strictly to the <i>filesystem</i> and not <i>mount points</i> that might still offer benefits, and I seem to recall running into ... unexpected behaviours ... using chroots in the past.</div><br/><div id="41064669" class="c"><input type="checkbox" id="c-41064669" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41064027">parent</a><span>|</span><a href="#41060596">next</a><span>|</span><label class="collapse" for="c-41064669">[-]</label><label class="expand" for="c-41064669">[1 more]</label></div><br/><div class="children"><div class="content">When you create a new mount namespace, the kernel creates a copy of every mount reachable from the filesystem (as visible to the process creating it). Then, it changes the current process&#x27;s root directory and current directory to point to the same paths in the corresponding mounts. Changing a process&#x27;s root via chroot is otherwise a totally separate operation.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41060596" class="c"><input type="checkbox" id="c-41060596" checked=""/><div class="controls bullet"><span class="by">indigodaddy</span><span>|</span><a href="#41060563">parent</a><span>|</span><a href="#41061002">prev</a><span>|</span><a href="#41059861">next</a><span>|</span><label class="collapse" for="c-41060596">[-]</label><label class="expand" for="c-41060596">[4 more]</label></div><br/><div class="children"><div class="content">Interesting.  Could you not perhaps tank the system attempting something like that?</div><br/><div id="41060729" class="c"><input type="checkbox" id="c-41060729" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41060596">parent</a><span>|</span><a href="#41060735">next</a><span>|</span><label class="collapse" for="c-41060729">[-]</label><label class="expand" for="c-41060729">[2 more]</label></div><br/><div class="children"><div class="content">How?  I don&#x27;t think the kernel cares what the directory looks like - userspace will break in funny ways, but you can boot without procfs even mounted (well, I say boot, but more like &quot;you can start a shell and some things will still work&quot;)</div><br/><div id="41065625" class="c"><input type="checkbox" id="c-41065625" checked=""/><div class="controls bullet"><span class="by">tetris11</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41060729">parent</a><span>|</span><a href="#41060735">next</a><span>|</span><label class="collapse" for="c-41065625">[-]</label><label class="expand" for="c-41065625">[1 more]</label></div><br/><div class="children"><div class="content">TIL that the kernel presents &#x2F;proc as a convenience to the user, and does not actively read from it</div><br/></div></div></div></div><div id="41060735" class="c"><input type="checkbox" id="c-41060735" checked=""/><div class="controls bullet"><span class="by">jordemort</span><span>|</span><a href="#41060563">root</a><span>|</span><a href="#41060596">parent</a><span>|</span><a href="#41060729">prev</a><span>|</span><a href="#41059861">next</a><span>|</span><label class="collapse" for="c-41060735">[-]</label><label class="expand" for="c-41060735">[1 more]</label></div><br/><div class="children"><div class="content">Oh yes, very easily, although you&#x27;d be surprised at how much works without a functional &#x2F;proc.</div><br/></div></div></div></div></div></div><div id="41059861" class="c"><input type="checkbox" id="c-41059861" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41060563">prev</a><span>|</span><a href="#41065968">next</a><span>|</span><label class="collapse" for="c-41059861">[-]</label><label class="expand" for="c-41059861">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re relying on such superficial disguising, just put your process name in brackets directly, no mount privileges required.<p>As a general rule, if malware gets root privilege, no other process on the same system (container, at least) should be expected to be able to detect it.</div><br/><div id="41062120" class="c"><input type="checkbox" id="c-41062120" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#41059861">parent</a><span>|</span><a href="#41061775">next</a><span>|</span><label class="collapse" for="c-41062120">[-]</label><label class="expand" for="c-41062120">[1 more]</label></div><br/><div class="children"><div class="content">This would help against basic ps commands but if your security tool reads the task&#x27;s PF_ flags (from &#x2F;proc&#x2F;PID&#x2F;stat or kernel memory), you&#x27;d still see that your [task] is not an actual kernel task... (the PF_KTHREAD flag is 0x200000):<p><pre><code>  $ ln -s &#x2F;bin&#x2F;sleep &#x27;[kernelstuff]&#x27;
  $ .&#x2F;\[kernelstuff\] 999 &amp;
  [2] 29499
   
  $ awk &#x27;{ printf(&quot;%x\n&quot;, $9) }&#x27; &#x2F;proc&#x2F;29499&#x2F;stat
  40400000
   
  $ pgrep kthreadd
  2
   
  $ awk &#x27;{ printf(&quot;%x\n&quot;, $9) }&#x27; &#x2F;proc&#x2F;2&#x2F;stat
  208040
</code></pre>
Edit: as you said, it&#x27;s superficial disguising (that may even work in some cases)</div><br/></div></div><div id="41061775" class="c"><input type="checkbox" id="c-41061775" checked=""/><div class="controls bullet"><span class="by">breakingcups</span><span>|</span><a href="#41059861">parent</a><span>|</span><a href="#41062120">prev</a><span>|</span><a href="#41065968">next</a><span>|</span><label class="collapse" for="c-41061775">[-]</label><label class="expand" for="c-41061775">[1 more]</label></div><br/><div class="children"><div class="content">It rather involved being on the other side of this airtight hatchway: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20060508-22&#x2F;?p=31283" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20060508-22&#x2F;?p=31...</a></div><br/></div></div></div></div><div id="41065968" class="c"><input type="checkbox" id="c-41065968" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#41059861">prev</a><span>|</span><a href="#41060073">next</a><span>|</span><label class="collapse" for="c-41065968">[-]</label><label class="expand" for="c-41065968">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re looking for naughty processes you could start with:<p><pre><code>    mkdir &#x2F;tmp&#x2F;foo
    mount -t proc none &#x2F;tmp&#x2F;foo</code></pre></div><br/></div></div><div id="41060073" class="c"><input type="checkbox" id="c-41060073" checked=""/><div class="controls bullet"><span class="by">bpoyner</span><span>|</span><a href="#41065968">prev</a><span>|</span><a href="#41065264">next</a><span>|</span><label class="collapse" for="c-41060073">[-]</label><label class="expand" for="c-41060073">[18 more]</label></div><br/><div class="children"><div class="content">I&#x27;m so old I remember when ps would directly get the processes via system calls to the kernel and none of this reading from &#x2F;proc.</div><br/><div id="41060874" class="c"><input type="checkbox" id="c-41060874" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#41060073">parent</a><span>|</span><a href="#41060660">next</a><span>|</span><label class="collapse" for="c-41060874">[-]</label><label class="expand" for="c-41060874">[1 more]</label></div><br/><div class="children"><div class="content">The original &#x27;ps&#x27; got the data by reading kernel memory directly (&#x2F;dev&#x2F;kmem or &#x2F;dev&#x2F;mem), and I&#x27;m old enough to remember systems doing that.  I don&#x27;t think there were any Unix-derivatives that used system calls?  Minix is closest, in that you could query the &#x27;mm&#x27; task using RPCs which are sort of system calls.</div><br/></div></div><div id="41060660" class="c"><input type="checkbox" id="c-41060660" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#41060073">parent</a><span>|</span><a href="#41060874">prev</a><span>|</span><a href="#41060181">next</a><span>|</span><label class="collapse" for="c-41060660">[-]</label><label class="expand" for="c-41060660">[4 more]</label></div><br/><div class="children"><div class="content">Are you sure? I know BSDs use kvm_getprocs, but I don&#x27;t know what the comparable sys call would have been on Linux.<p>FWIW, &#x2F;proc was added in Linux v0.97.3, September 1992, which is early enough I couldn&#x27;t find ps source for linux earlier then that date.</div><br/><div id="41060749" class="c"><input type="checkbox" id="c-41060749" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060660">parent</a><span>|</span><a href="#41063621">next</a><span>|</span><label class="collapse" for="c-41060749">[-]</label><label class="expand" for="c-41060749">[2 more]</label></div><br/><div class="children"><div class="content">The post you&#x27;re replying to didn&#x27;t say &quot;on Linux&quot; - IIRC, <i>unix</i> ps worked by reading &#x2F;dev&#x2F;kmem or so<p>Edit: My mistake, it was &#x2F;dev&#x2F;mem - <a href="https:&#x2F;&#x2F;github.com&#x2F;lsahn-gh&#x2F;unix-v6&#x2F;blob&#x2F;master&#x2F;source&#x2F;s2&#x2F;ps.c#L100">https:&#x2F;&#x2F;github.com&#x2F;lsahn-gh&#x2F;unix-v6&#x2F;blob&#x2F;master&#x2F;source&#x2F;s2&#x2F;ps...</a></div><br/><div id="41061417" class="c"><input type="checkbox" id="c-41061417" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060749">parent</a><span>|</span><a href="#41063621">next</a><span>|</span><label class="collapse" for="c-41061417">[-]</label><label class="expand" for="c-41061417">[1 more]</label></div><br/><div class="children"><div class="content">Agh, completely fair. The topic was about Linux and I incorrectly presumed that the original comment was made in the same context. My mistake.</div><br/></div></div></div></div><div id="41063621" class="c"><input type="checkbox" id="c-41063621" checked=""/><div class="controls bullet"><span class="by">donio</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060660">parent</a><span>|</span><a href="#41060749">prev</a><span>|</span><a href="#41060181">next</a><span>|</span><label class="collapse" for="c-41063621">[-]</label><label class="expand" for="c-41063621">[1 more]</label></div><br/><div class="children"><div class="content">I remember this too. Very early on there were both proc and a &#x2F;dev&#x2F;kmem versions of ps and maybe top too.<p>Yep, found it: <a href="https:&#x2F;&#x2F;www.ibiblio.org&#x2F;pub&#x2F;historic-linux&#x2F;ftp-archives&#x2F;sunsite.unc.edu&#x2F;Sep-29-1996&#x2F;system&#x2F;Status&#x2F;ps&#x2F;INDEX.html" rel="nofollow">https:&#x2F;&#x2F;www.ibiblio.org&#x2F;pub&#x2F;historic-linux&#x2F;ftp-archives&#x2F;suns...</a><p>And the Linux kernel CREDITS file has an entry mentioning it too:<p><pre><code>    N: Rick Sladkey
    D: utility hacker: Emacs, NFS server, mount, kmem-ps, UPS debugger, strace, GDB
    [...]</code></pre></div><br/></div></div></div></div><div id="41060181" class="c"><input type="checkbox" id="c-41060181" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#41060073">parent</a><span>|</span><a href="#41060660">prev</a><span>|</span><a href="#41060381">next</a><span>|</span><label class="collapse" for="c-41060181">[-]</label><label class="expand" for="c-41060181">[8 more]</label></div><br/><div class="children"><div class="content">To me it actually sounds like a better approach than blindly following &quot;everything is a file&quot; mantra.</div><br/><div id="41060969" class="c"><input type="checkbox" id="c-41060969" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060181">parent</a><span>|</span><a href="#41060896">next</a><span>|</span><label class="collapse" for="c-41060969">[-]</label><label class="expand" for="c-41060969">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s blind about it? Reading files is nicer than parsing ps output or needing to write native code over a syscall.</div><br/><div id="41065925" class="c"><input type="checkbox" id="c-41065925" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060969">parent</a><span>|</span><a href="#41061546">next</a><span>|</span><label class="collapse" for="c-41065925">[-]</label><label class="expand" for="c-41065925">[1 more]</label></div><br/><div class="children"><div class="content">One problem with reading &#x2F;proc is that its impossible to get consistent view of the whole system because you are iterating the processes one by one, instead of getting snapshot of all the processes.</div><br/></div></div><div id="41061546" class="c"><input type="checkbox" id="c-41061546" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060969">parent</a><span>|</span><a href="#41065925">prev</a><span>|</span><a href="#41060896">next</a><span>|</span><label class="collapse" for="c-41061546">[-]</label><label class="expand" for="c-41061546">[3 more]</label></div><br/><div class="children"><div class="content">Trying to parse the output of several procfs files isn&#x27;t as easy as it looks. The per-pid maps file for one (smaps is even worse). Much better if I could just get a struct with all this information.</div><br/><div id="41064095" class="c"><input type="checkbox" id="c-41064095" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41061546">parent</a><span>|</span><a href="#41062887">next</a><span>|</span><label class="collapse" for="c-41064095">[-]</label><label class="expand" for="c-41064095">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not looked at kernel source but, when I had a task to read info from &#x2F;proc it looked like a lot of info was just pack() in there. So my parsing was just done with unpack(). Mapping those values from things that could be found in existing userland tools.</div><br/></div></div><div id="41062887" class="c"><input type="checkbox" id="c-41062887" checked=""/><div class="controls bullet"><span class="by">0xedd</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41061546">parent</a><span>|</span><a href="#41064095">prev</a><span>|</span><a href="#41060896">next</a><span>|</span><label class="collapse" for="c-41062887">[-]</label><label class="expand" for="c-41062887">[1 more]</label></div><br/><div class="children"><div class="content">Asking DevOps to program for basic tasks. Cool story, bro.</div><br/></div></div></div></div></div></div><div id="41060896" class="c"><input type="checkbox" id="c-41060896" checked=""/><div class="controls bullet"><span class="by">kjeetgill</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060181">parent</a><span>|</span><a href="#41060969">prev</a><span>|</span><a href="#41060381">next</a><span>|</span><label class="collapse" for="c-41060896">[-]</label><label class="expand" for="c-41060896">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m totally with you for processes should probably use glibc&#x2F;platform API calls, but procfs is nothing short of brilliant and a great validation of the power of the &quot;everything is a file&quot;.</div><br/><div id="41065604" class="c"><input type="checkbox" id="c-41065604" checked=""/><div class="controls bullet"><span class="by">Sophira</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060896">parent</a><span>|</span><a href="#41060381">next</a><span>|</span><label class="collapse" for="c-41065604">[-]</label><label class="expand" for="c-41065604">[1 more]</label></div><br/><div class="children"><div class="content">Except that any process that has obtained root (through a security flaw or otherwise) can extremely easily hide itself, as shown here.<p>I will admit that it&#x27;s likely that the same thing could be done with loadable kernel modules, that said.</div><br/></div></div></div></div></div></div><div id="41060381" class="c"><input type="checkbox" id="c-41060381" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41060073">parent</a><span>|</span><a href="#41060181">prev</a><span>|</span><a href="#41065264">next</a><span>|</span><label class="collapse" for="c-41060381">[-]</label><label class="expand" for="c-41060381">[4 more]</label></div><br/><div class="children"><div class="content">Is this still possible in Linux?  Or were the aforementioned syscalls removed?</div><br/><div id="41061131" class="c"><input type="checkbox" id="c-41061131" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41060381">parent</a><span>|</span><a href="#41065264">next</a><span>|</span><label class="collapse" for="c-41061131">[-]</label><label class="expand" for="c-41061131">[3 more]</label></div><br/><div class="children"><div class="content">Linux never removes syscalls.</div><br/><div id="41062319" class="c"><input type="checkbox" id="c-41062319" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41061131">parent</a><span>|</span><a href="#41065264">next</a><span>|</span><label class="collapse" for="c-41062319">[-]</label><label class="expand" for="c-41062319">[2 more]</label></div><br/><div class="children"><div class="content">Though it does stop implementing obsolete syscalls on newer architectures. So the set of syscalls you can effectively use often rotates as the hardware treadmill turns.</div><br/><div id="41063560" class="c"><input type="checkbox" id="c-41063560" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41060073">root</a><span>|</span><a href="#41062319">parent</a><span>|</span><a href="#41065264">next</a><span>|</span><label class="collapse" for="c-41063560">[-]</label><label class="expand" for="c-41063560">[1 more]</label></div><br/><div class="children"><div class="content">And since they haven&#x27;t been removed, just not implemented, you get the joy of finding out it doesn&#x27;t work anymore when you try to use it, instead of when you build it!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41065264" class="c"><input type="checkbox" id="c-41065264" checked=""/><div class="controls bullet"><span class="by">Szpadel</span><span>|</span><a href="#41060073">prev</a><span>|</span><a href="#41063502">next</a><span>|</span><label class="collapse" for="c-41065264">[-]</label><label class="expand" for="c-41065264">[2 more]</label></div><br/><div class="children"><div class="content">in Linux you can rename your own process name, many applications do that to name their threads or to describe what they are doing<p>isn&#x27;t it just much easier to rename our process to looks like kernel thread or some other process?
we could easily escape process tree by forking child and exiting parent (we would get adopted by init)</div><br/><div id="41065642" class="c"><input type="checkbox" id="c-41065642" checked=""/><div class="controls bullet"><span class="by">tetris11</span><span>|</span><a href="#41065264">parent</a><span>|</span><a href="#41063502">next</a><span>|</span><label class="collapse" for="c-41065642">[-]</label><label class="expand" for="c-41065642">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s taking up a lot of CPU and MEM, someone runnning htop will begin to wonder what that process is doing. By bind mounting it, you obscure it from htop altogether</div><br/></div></div></div></div><div id="41063502" class="c"><input type="checkbox" id="c-41063502" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41065264">prev</a><span>|</span><a href="#41060417">next</a><span>|</span><label class="collapse" for="c-41063502">[-]</label><label class="expand" for="c-41063502">[1 more]</label></div><br/><div class="children"><div class="content">Coincidentally, I just used a veritable litany of bind mounts this week. I did not attempt to hide anything, though one of those bind mounts exists in order to fake something. I needed this to be able to properly run some x86 software under Rosetta 2 in an arm64 Ubuntu VM.<p>I wasn&#x27;t happy with how handling packages for multiple architectures seems to work in Ubuntu&#x2F;Debian: It looks like you basically have to choose what package you want to install with each architecture, because if you try to install a package for both architectures, they almost always conflict with each other (trying to occupy the same files).<p>So instead, I made an x86 chroot. I used &quot;debootstrap&quot; to populate the x86 chroot with an x86 Ubuntu base system, and schroot so that a regular non-root user could use that chroot. That way, I can install any x86 package I want without conflicting with the surrounding VM by just chroot&#x27;ing into it and regularly typing e.g. &quot;apt install emacs&quot;.<p>But both because a lot of software needs it, and for interop with the surrounding VM (unix domain sockets etc.), I had to create a bunch of bind mounts to bring shared &quot;state&quot; directories into the x86 chroot:<p><pre><code>    mount --make-private --bind &#x2F;proc &#x2F;data&#x2F;x86&#x2F;proc
    mount --make-private --bind &#x2F;proc &#x2F;data&#x2F;x86&#x2F;sys
    ...
</code></pre>
I did this for at least &#x2F;proc, &#x2F;sys, &#x2F;run, &#x2F;dev, &#x2F;dev&#x2F;pts and &#x2F;home. Depending on how much you want to bring the environments together, you could also add &#x2F;run, &#x2F;tmp, and others.<p>I also added bind mounts for individual <i>files</i>:<p><pre><code>   mount --make-private --bind &#x2F;etc&#x2F;passwd &#x2F;data&#x2F;x86&#x2F;etc&#x2F;passwd
   mount --make-private --bind &#x2F;etc&#x2F;shadow &#x2F;data&#x2F;x86&#x2F;etc&#x2F;shadow
   mount --make-private --bind &#x2F;etc&#x2F;group &#x2F;data&#x2F;x86&#x2F;etc&#x2F;group
</code></pre>
so that my x86 environment has the same user&#x2F;group database.<p>Finally, and I think this is the most interesting piece, some x86 software I tried to run did not work because it tried to parse &#x2F;proc&#x2F;cpuinfo for some x86 CPU features. Rosetta 2 implements those, but of course &#x2F;proc&#x2F;cpuinfo in the system describes the actual (virtualized) ARM CPUs, which is of course not what x86 software expects.<p>So, I crafted my own fake cpuinfo text file that looked roughly like it would look in a real x86 environment (I did not put much effort in it, just copied an output from a random real x86 machine and adjusted the number of CPUs), and bind mounted that into the x86 &#x2F;proc overlay:<p><pre><code>   mount --make-private --bind &#x2F;data&#x2F;fake-x86-cpuinfo.txt &#x2F;data&#x2F;x86&#x2F;proc&#x2F;cpuinfo
</code></pre>
Now, &#x2F;proc&#x2F;cpuinfo inside the chroot (so, &#x2F;data&#x2F;x86&#x2F;proc&#x2F;cpuinfo) would give the fake cpuinfo and make the x86 software that parses it happy. This is also where the --make-private that I applied to &#x2F;data&#x2F;x86&#x2F;proc earlier becomes important: Without that, that last command would not just overlay &#x2F;data&#x2F;x86&#x2F;proc&#x2F;cpuinfo, but also &#x2F;proc&#x2F;cpuinfo itself, now in turn making arm64 software potentially unhappy. With --make-private on the &#x2F;proc bind mount, it effectively becomes a separate filesystem in that regard (only).<p>Finally, the biggest hurdle I had was getting systemd to properly mount all of these in the right order at startup. systemd parallelizes the mounts in fstab (and mounts generally). But if e.g. the &#x2F;data&#x2F;x86&#x2F;proc mount does not happen after <i>both</i> &#x2F;proc and &#x2F;data&#x2F;x86 have been mounted already, you effectively get an empty directory (you can easily work out yourself why that results in all improper cases). This was even more complicated because I use ZFS, and so &#x2F;data&#x2F;x86 gets mounted by zfs.mount-service. After much fiddling, I gave up. No combination of &quot;x-systemd.requires=&lt;mountpoint&gt;&quot;, &quot;x-systemd.after=zfs-mount.service&quot; and whatever else in the fstab options really fully did the right thing.<p>I resorted to having a shell script that just runs the bind mounts in the correct order.</div><br/></div></div><div id="41060417" class="c"><input type="checkbox" id="c-41060417" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#41063502">prev</a><span>|</span><a href="#41058689">next</a><span>|</span><label class="collapse" for="c-41060417">[-]</label><label class="expand" for="c-41060417">[1 more]</label></div><br/><div class="children"><div class="content">The abstraction of representing everything as files is often leaky (and often clunky).</div><br/></div></div><div id="41058689" class="c"><input type="checkbox" id="c-41058689" checked=""/><div class="controls bullet"><span class="by">awaythrow999</span><span>|</span><a href="#41060417">prev</a><span>|</span><label class="collapse" for="c-41058689">[-]</label><label class="expand" for="c-41058689">[4 more]</label></div><br/><div class="children"><div class="content">Interesting but<p>&gt;&gt; My guess is that nobody is going to notice this unless they are specifically looking for this technique.<p>But having two identical PIDs is a pretty weak cloak.  Even more so when reducing terminal clutter e.g. run &quot;ps | grep procname&quot;  ... anyone not completely asleep is bound to notice it.</div><br/><div id="41063521" class="c"><input type="checkbox" id="c-41063521" checked=""/><div class="controls bullet"><span class="by">theteapot</span><span>|</span><a href="#41058689">parent</a><span>|</span><label class="collapse" for="c-41063521">[-]</label><label class="expand" for="c-41063521">[3 more]</label></div><br/><div class="children"><div class="content">Did we read the same article? What two identical PIDs? The process doesn&#x27;t show up in ps so doesn&#x27;t show up in &quot;ps | grep ...&quot; either.</div><br/><div id="41065700" class="c"><input type="checkbox" id="c-41065700" checked=""/><div class="controls bullet"><span class="by">Sophira</span><span>|</span><a href="#41058689">root</a><span>|</span><a href="#41063521">parent</a><span>|</span><a href="#41063654">next</a><span>|</span><label class="collapse" for="c-41065700">[-]</label><label class="expand" for="c-41065700">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Did we read the same article?<p>Probably you read the article that was <i>linked</i> from this article, which does indeed make the process completely vanish, but leaves a suspicious empty &#x2F;proc directory.<p>This article &#x27;solves&#x27; the problem of an empty directory by simply bind-mounting another process instead - but that causes ps to output a duplicate line (including process ID) for the other process, in lieu of the process being hidden.</div><br/></div></div><div id="41063654" class="c"><input type="checkbox" id="c-41063654" checked=""/><div class="controls bullet"><span class="by">jaimehrubiks</span><span>|</span><a href="#41058689">root</a><span>|</span><a href="#41063521">parent</a><span>|</span><a href="#41065700">prev</a><span>|</span><label class="collapse" for="c-41063654">[-]</label><label class="expand" for="c-41063654">[1 more]</label></div><br/><div class="children"><div class="content">Probably yes, because in the op&#x27;s article it&#x27;s using a bind mount from another kernel thread and it does show up in ps twice</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>