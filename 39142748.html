<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706346051645" as="style"/><link rel="stylesheet" href="styles.css?v=1706346051645"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/oasislinux/oasis">Oasis – a small, statically-linked Linux system</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>smartmic</span> | <span>223 comments</span></div><br/><div><div id="39143165" class="c"><input type="checkbox" id="c-39143165" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39143840">next</a><span>|</span><label class="collapse" for="c-39143165">[-]</label><label class="expand" for="c-39143165">[18 more]</label></div><br/><div class="children"><div class="content">I cant speak much about the system, it just works, but the community was really nice when I interacted with them over IRC<p>I had the plan to build oasis with bazel for some immutable OS images that could run as kubernetes nodes. I succeeded with a little pointing.</div><br/><div id="39152240" class="c"><input type="checkbox" id="c-39152240" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#39143165">parent</a><span>|</span><a href="#39151291">next</a><span>|</span><label class="collapse" for="c-39152240">[-]</label><label class="expand" for="c-39152240">[1 more]</label></div><br/><div class="children"><div class="content">&quot;it just works&quot; so you are doing the tech support when it doesn&#x27;t, right?<p>EDIT: that was meant to be a joke, I forgo HN doesn&#x27;t support emojies.</div><br/></div></div><div id="39151291" class="c"><input type="checkbox" id="c-39151291" checked=""/><div class="controls bullet"><span class="by">colatkinson</span><span>|</span><a href="#39143165">parent</a><span>|</span><a href="#39152240">prev</a><span>|</span><a href="#39143428">next</a><span>|</span><label class="collapse" for="c-39151291">[-]</label><label class="expand" for="c-39151291">[1 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t mind I&#x27;m super curious as to what approach you ended up taking. Did you use rules_foreign_cc to build the ninja files they generate? Or generating BUILD files directly? Or something completely different? Sounds like a really cool project!</div><br/></div></div><div id="39143428" class="c"><input type="checkbox" id="c-39143428" checked=""/><div class="controls bullet"><span class="by">gravypod</span><span>|</span><a href="#39143165">parent</a><span>|</span><a href="#39151291">prev</a><span>|</span><a href="#39144017">next</a><span>|</span><label class="collapse" for="c-39143428">[-]</label><label class="expand" for="c-39143428">[2 more]</label></div><br/><div class="children"><div class="content">Have you shared your BUILD files upstream?</div><br/><div id="39143584" class="c"><input type="checkbox" id="c-39143584" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39143428">parent</a><span>|</span><a href="#39144017">next</a><span>|</span><label class="collapse" for="c-39143584">[-]</label><label class="expand" for="c-39143584">[1 more]</label></div><br/><div class="children"><div class="content">No, they were quite happy with Samurai</div><br/></div></div></div></div><div id="39144017" class="c"><input type="checkbox" id="c-39144017" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#39143165">parent</a><span>|</span><a href="#39143428">prev</a><span>|</span><a href="#39147739">next</a><span>|</span><label class="collapse" for="c-39144017">[-]</label><label class="expand" for="c-39144017">[1 more]</label></div><br/><div class="children"><div class="content">Thats a cool idea! Will you open source it or make it available somehow? I would like to play with it for running Atomic T</div><br/></div></div><div id="39147739" class="c"><input type="checkbox" id="c-39147739" checked=""/><div class="controls bullet"><span class="by">public_void</span><span>|</span><a href="#39143165">parent</a><span>|</span><a href="#39144017">prev</a><span>|</span><a href="#39148244">next</a><span>|</span><label class="collapse" for="c-39147739">[-]</label><label class="expand" for="c-39147739">[10 more]</label></div><br/><div class="children"><div class="content">Why did you need to use bazel?</div><br/><div id="39147802" class="c"><input type="checkbox" id="c-39147802" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39147739">parent</a><span>|</span><a href="#39148244">next</a><span>|</span><label class="collapse" for="c-39147802">[-]</label><label class="expand" for="c-39147802">[9 more]</label></div><br/><div class="children"><div class="content">I didnt need to use bazel, I like bazel and want to learn more about it.<p>I also have a small, but burning, passion for reproducible builds, distributed compilation and distributed caching.<p>Being able to build an entire OS and essentially anything I want on top in a reproducible and relatively organic way (with incremental compilation) is pretty dope.</div><br/><div id="39149777" class="c"><input type="checkbox" id="c-39149777" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39147802">parent</a><span>|</span><a href="#39151890">next</a><span>|</span><label class="collapse" for="c-39149777">[-]</label><label class="expand" for="c-39149777">[7 more]</label></div><br/><div class="children"><div class="content">You sound like the perfect Nix cult memb… erm, user. It’s everything you describe and more (plus the language is incredibly powerful compared with starlark).<p>But you speak from sufficient experience that I presume Nix is a “been there, done that” thing for you. What gives?</div><br/><div id="39149890" class="c"><input type="checkbox" id="c-39149890" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39149777">parent</a><span>|</span><a href="#39149926">next</a><span>|</span><label class="collapse" for="c-39149890">[-]</label><label class="expand" for="c-39149890">[4 more]</label></div><br/><div class="children"><div class="content">Nix has decentralized caching and memorizing?</div><br/><div id="39150344" class="c"><input type="checkbox" id="c-39150344" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39149890">parent</a><span>|</span><a href="#39149926">next</a><span>|</span><label class="collapse" for="c-39150344">[-]</label><label class="expand" for="c-39150344">[3 more]</label></div><br/><div class="children"><div class="content">Decentralised caching, absolutely - unless I’m misunderstanding what you mean there. You can build across many machines, merge stores, host caches online with cachix (or your own approach), etc. I make fairly heavy use of that, otherwise my CI builds would be brutal.<p>Memorizing isn’t a term I’m familiar with in this context.</div><br/><div id="39150796" class="c"><input type="checkbox" id="c-39150796" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39150344">parent</a><span>|</span><a href="#39149926">next</a><span>|</span><label class="collapse" for="c-39150796">[-]</label><label class="expand" for="c-39150796">[2 more]</label></div><br/><div class="children"><div class="content">Sorry - <i>memoizing</i>.<p>I am interested in making a system that can memoize large databases from ETL systems and then serve that on iroh or ipfs&#x2F;torrent, such that a process that may take a supercomputer a week to process can have the same code run on a laptop and it will notice it&#x27;s been done my a university supercomputer before already and grab that result automatically from the decentralized network of all people using the software (who downloaded the ETL database).<p>That way you save compute and time.</div><br/><div id="39151993" class="c"><input type="checkbox" id="c-39151993" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39150796">parent</a><span>|</span><a href="#39149926">next</a><span>|</span><label class="collapse" for="c-39151993">[-]</label><label class="expand" for="c-39151993">[1 more]</label></div><br/><div class="children"><div class="content">Oh I see!<p>Yes, absolutely doable in Nix.<p>Derivations are just a set of instructions combined with a set of inputs, and a unique hash is made from that.<p>If you make a derivation whose result is the invocation of another, and you try and grab the outcome from that derivation, here’s what will happen:
- it will generate the hash
- it will look that hash up in your local &#x2F;nix&#x2F;store
- if not found it will look that hash up in any remote caches you have configured
- if not found it will create it using the inputs and instructions<p>This is transitive so any missing inputs will also be searched for and built if missing, etc.<p>So if the outcome from your process is something you want to keep and make accessible to other machines, you can do that.<p>If the machines differ in architecture, the “inputs” might differ between machines (e.g. clang on Mac silicon is not the same as clang on x86-64) and that would result in a different final hash, thus one computation per unique architecture.<p>This is ultimately the correct behaviour as guaranteeing identical output on different architectures is somewhat unrealistic.</div><br/></div></div></div></div></div></div></div></div><div id="39149926" class="c"><input type="checkbox" id="c-39149926" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39149777">parent</a><span>|</span><a href="#39149890">prev</a><span>|</span><a href="#39151890">next</a><span>|</span><label class="collapse" for="c-39149926">[-]</label><label class="expand" for="c-39149926">[2 more]</label></div><br/><div class="children"><div class="content">Nix isn&#x27;t as fine-grained as Bazel as I understand it? I don&#x27;t think it&#x27;s incremental within a package, which is presumably what dijit achieved.</div><br/><div id="39150276" class="c"><input type="checkbox" id="c-39150276" checked=""/><div class="controls bullet"><span class="by">i-use-nixos-btw</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39149926">parent</a><span>|</span><a href="#39151890">next</a><span>|</span><label class="collapse" for="c-39150276">[-]</label><label class="expand" for="c-39150276">[1 more]</label></div><br/><div class="children"><div class="content">Weirdly enough I came across a blog post last week that talked about exactly this. <a href="https:&#x2F;&#x2F;j.phd&#x2F;nix-needs-a-native-build-system&#x2F;" rel="nofollow">https:&#x2F;&#x2F;j.phd&#x2F;nix-needs-a-native-build-system&#x2F;</a><p>Nix can be used as a build system in the same way that bazel can. It already has all of the tooling - a fundamental representation of a hermetic DAG, caching, access to any tool you need, and a vast selection of libraries.<p>The only catch is that no one has used it to write a build system for it in public yet. I’ve seen it done in a couple of companies, though, as using Nix to only partially manage builds can be awkward due to caching loss (if your unit of source is the entire source tree, a tiny change is an entirely new source).</div><br/></div></div></div></div></div></div><div id="39151890" class="c"><input type="checkbox" id="c-39151890" checked=""/><div class="controls bullet"><span class="by">yx827ha</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39147802">parent</a><span>|</span><a href="#39149777">prev</a><span>|</span><a href="#39148244">next</a><span>|</span><label class="collapse" for="c-39151890">[-]</label><label class="expand" for="c-39151890">[1 more]</label></div><br/><div class="children"><div class="content">You should check out the ChromeOS Bazelification project[1]. It has those exact same goals. Not all packages are reproducible though because they embed timestamps.<p>[1]: <a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromiumos&#x2F;bazel&#x2F;+&#x2F;HEAD&#x2F;docs&#x2F;getting_started.md" rel="nofollow">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromiumos&#x2F;bazel&#x2F;+&#x2F;HEAD&#x2F;do...</a></div><br/></div></div></div></div></div></div><div id="39148244" class="c"><input type="checkbox" id="c-39148244" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#39143165">parent</a><span>|</span><a href="#39147739">prev</a><span>|</span><a href="#39143840">next</a><span>|</span><label class="collapse" for="c-39148244">[-]</label><label class="expand" for="c-39148244">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I cant speak much about the system, it just works,<p>What systems don&#x27;t just work by this criteria?<p>Just because something is statically linked vs dynamically linked, as long as you are within &quot;normal expected operating conditions&quot;, does it really make a &quot;just works vs doesn&#x27;t work&quot; quality difference?</div><br/><div id="39148612" class="c"><input type="checkbox" id="c-39148612" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#39143165">root</a><span>|</span><a href="#39148244">parent</a><span>|</span><a href="#39143840">next</a><span>|</span><label class="collapse" for="c-39148612">[-]</label><label class="expand" for="c-39148612">[1 more]</label></div><br/><div class="children"><div class="content">Read after the comma:<p>&gt; <i>it just works, but...</i></div><br/></div></div></div></div></div></div><div id="39143840" class="c"><input type="checkbox" id="c-39143840" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#39143165">prev</a><span>|</span><a href="#39143551">next</a><span>|</span><label class="collapse" for="c-39143840">[-]</label><label class="expand" for="c-39143840">[101 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t linking everything statically imply that the base image -- and memory, at runtime -- will be bloated by many copies of libc and other common libraries? I do like the simplicity of static linking but it sort of seems to go against the idea of avoiding &quot;bloat&quot;.</div><br/><div id="39144281" class="c"><input type="checkbox" id="c-39144281" checked=""/><div class="controls bullet"><span class="by">jezze</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39151400">next</a><span>|</span><label class="collapse" for="c-39144281">[-]</label><label class="expand" for="c-39144281">[47 more]</label></div><br/><div class="children"><div class="content">A linker typically only includes the parts of the library it needs for each binary so some parts will definately have many copies of the same code when you statically link but it will not make complete copies.<p>But I wouldnt consider this bloat. To me it is just a better seperation of concerns. To me bloat would be to have a system that has to keep track of all library dependencies instead, both from a packaging perspective but also in runtime. I think it depends where you are coming from. To me static linking is just cleaner. I dont care much for the extra memory it might use.</div><br/><div id="39144348" class="c"><input type="checkbox" id="c-39144348" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144281">parent</a><span>|</span><a href="#39145752">next</a><span>|</span><label class="collapse" for="c-39144348">[-]</label><label class="expand" for="c-39144348">[40 more]</label></div><br/><div class="children"><div class="content">Dynamic linking served us when OS upgrades came infrequently, user software was almost never upgraded short of mailing out new disks, and vendors had long lead times to incorporate security fixes.<p>In the days of fast networks, embedded OSs, emphemeral containers, and big hard drives, a portable static binary is way less complex and only somewhat less secure (unless you&#x27;re regularly rebuilding your containers&#x2F;execs in which case it&#x27;s break even security wise or possibly more secure, simply because each exec may not include vulnerable code)</div><br/><div id="39146594" class="c"><input type="checkbox" id="c-39146594" checked=""/><div class="controls bullet"><span class="by">bscphil</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144348">parent</a><span>|</span><a href="#39153566">next</a><span>|</span><label class="collapse" for="c-39146594">[-]</label><label class="expand" for="c-39146594">[16 more]</label></div><br/><div class="children"><div class="content">&gt; In the days of fast networks, embedded OSs, emphemeral containers, and big hard drives, a portable static binary is way less complex and only somewhat less secure<p>If what you&#x27;re trying to do is run a single program on a server somewhere, then yes absolutely a static binary is the way to go. There are lots of cases, especially end user desktops, where this doesn&#x27;t really apply though.<p>In my opinion the debate over static vs dynamic linking is resolved by understanding that they are different tools for different jobs.</div><br/><div id="39149716" class="c"><input type="checkbox" id="c-39149716" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146594">parent</a><span>|</span><a href="#39152021">next</a><span>|</span><label class="collapse" for="c-39149716">[-]</label><label class="expand" for="c-39149716">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  understanding that they are different tools for different jobs
</code></pre>
Right, but this goes against the dogma on both sides and the fact that much of Linux userspace is the wild west. Ideally, there should be a set of core system libraries (ex glibc, openssl, xlib, etc) that have extremely stable API&#x2F;ABI somatics and are rarely updated.<p>Then one dynamically links the core libraries and statically links everything else. This solves the problem that a bug&#x2F;exploit found in something like OpenSSL doesn&#x27;t require the entire system to be recompiled and updated while allowing libraries that are not stable, used by few packages, etc, to be statically linked to their users. Then, when lib_coolnew_pos has a bug, it only requires rebuilding the two apps linked to it, and not necessarily even then if those applications don&#x27;t expose the bug.</div><br/><div id="39149986" class="c"><input type="checkbox" id="c-39149986" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149716">parent</a><span>|</span><a href="#39152021">next</a><span>|</span><label class="collapse" for="c-39149986">[-]</label><label class="expand" for="c-39149986">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Then one dynamically links the core libraries and statically links everything else.<p>Agreed, and that is already totally possible.<p>- If you split your project in libraries (there are reasons to do that), then by all means link them statically.<p>- If you depend on a third party library that is so unstable that nobody maintains a package for it, then the first question should be: do you really want to depend on it? If yes, you have to understand that you are now the maintainer of that library. Link it dynamically or statically, whichever you want, but you are responsible for its updates in any case.<p>The fashion that goes towards statically linking everything shows, to me, that people generally don&#x27;t know how to handle dependencies. &quot;It&#x27;s simpler&quot; to copy-paste the library code in your project, build it as part of it, and call that &quot;statically linking&quot;. And then probably never update it, or try to update it and give up after 10min the first time the update fails (&quot;well, the old version works for now, I don&#x27;t have time for an update&quot;).<p>I am fine with people who know how to do both and choose to statically link. I don&#x27;t like the arguments coming from those who statically link because they don&#x27;t know better, but still try to justify themselves.</div><br/><div id="39150855" class="c"><input type="checkbox" id="c-39150855" checked=""/><div class="controls bullet"><span class="by">superb_dev</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149986">parent</a><span>|</span><a href="#39152021">next</a><span>|</span><label class="collapse" for="c-39150855">[-]</label><label class="expand" for="c-39150855">[2 more]</label></div><br/><div class="children"><div class="content">Statically linking does not imply copying the code into the project</div><br/><div id="39151228" class="c"><input type="checkbox" id="c-39151228" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150855">parent</a><span>|</span><a href="#39152021">next</a><span>|</span><label class="collapse" for="c-39151228">[-]</label><label class="expand" for="c-39151228">[1 more]</label></div><br/><div class="children"><div class="content">Of course not. My point was that people who say &quot;static linking is better&quot; because the only thing they know (which is copying the code into their project) results in something that looks like static linking are in the wrong.</div><br/></div></div></div></div></div></div></div></div><div id="39152021" class="c"><input type="checkbox" id="c-39152021" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146594">parent</a><span>|</span><a href="#39149716">prev</a><span>|</span><a href="#39148206">next</a><span>|</span><label class="collapse" for="c-39152021">[-]</label><label class="expand" for="c-39152021">[1 more]</label></div><br/><div class="children"><div class="content">Windows makes up the lion&#x27;s share of desktop computing, and seems to be doing fine without actually sharing libraries. Lots of dynamic linking going on, but since about the XP days the entire Windows ecosystem has given up on different software linking the same library file, except for OS interfaces and C runtimes. Instead everyone just ships their own version of everything they use, and dynamic linking is mostly used to solve licencing, for developer convenience, or for plugin systems. The end result isn&#x27;t that different from everything being statically linked</div><br/></div></div><div id="39148206" class="c"><input type="checkbox" id="c-39148206" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146594">parent</a><span>|</span><a href="#39152021">prev</a><span>|</span><a href="#39153566">next</a><span>|</span><label class="collapse" for="c-39148206">[-]</label><label class="expand" for="c-39148206">[10 more]</label></div><br/><div class="children"><div class="content">It applies very much to end user desktops as well, with snap, flatpak, etc. working towards it. Lots of software requires dependencies that aren&#x27;t compatible with each other and result in absolute dependency hell or even a broken install when you dare to have more than one version of something. Because who would ever need that, right? Especially not in a dev desktop environment...<p>Windows is basically all self-contained executables and the few times it isn&#x27;t it&#x27;s a complete mess with installing VC++ redistributables or the correct Java runtime or whatever that clueless users inevitably mess up.<p>We have the disk space, we have the memory, we have the broadband to download it all. Even more so on desktop than on some cheap VPS.</div><br/><div id="39148638" class="c"><input type="checkbox" id="c-39148638" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148206">parent</a><span>|</span><a href="#39150018">next</a><span>|</span><label class="collapse" for="c-39148638">[-]</label><label class="expand" for="c-39148638">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Windows is basically all self-contained executables<p>With the caveat that the &quot;standard library&quot; they depend on is multiple GBs and provides more features than entire Gnome.<p>Also MS always worked in some tech to avoid library duplication such as WinSxS or now MSIX has autodedupe even at the time of download.</div><br/></div></div><div id="39150018" class="c"><input type="checkbox" id="c-39150018" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148206">parent</a><span>|</span><a href="#39148638">prev</a><span>|</span><a href="#39151823">next</a><span>|</span><label class="collapse" for="c-39150018">[-]</label><label class="expand" for="c-39150018">[7 more]</label></div><br/><div class="children"><div class="content">&gt; when you dare to have more than one version of something. Because who would ever need that, right?<p>If done properly, you can have multiple major versions of something and that&#x27;s fine. If one app depends on libA.so.1.0.3, the other on libA.so.1.1.4, and they can&#x27;t both live with 1.1.4, it means that `libA` did something wrong.<p>One pretty clear solution to me is that the dev of libA should learn good practice.</div><br/><div id="39150317" class="c"><input type="checkbox" id="c-39150317" checked=""/><div class="controls bullet"><span class="by">zaphar</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150018">parent</a><span>|</span><a href="#39150647">next</a><span>|</span><label class="collapse" for="c-39150317">[-]</label><label class="expand" for="c-39150317">[4 more]</label></div><br/><div class="children"><div class="content">Yep, the dev(s) of libA should learn good practice. But they didn&#x27;t and app1 and app2 still have the problem. Static linking solves it for them more reliably than trying to get the dev of libA to &quot;git gud&quot;. Much of the desire to statically link binaries comes from this specific scenario playing out over and over and over.<p>Heck for a long time upgrading glibc by a minor version was almost guaranteed to break your app and that was often <i>intentional</i>.</div><br/><div id="39150369" class="c"><input type="checkbox" id="c-39150369" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150317">parent</a><span>|</span><a href="#39150647">next</a><span>|</span><label class="collapse" for="c-39150369">[-]</label><label class="expand" for="c-39150369">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Yep, the dev(s) of libA should learn good practice. But they didn&#x27;t and app1 and app2 still have the problem.<p>Sure :-). I just find it sad that app1 and app2 then use the bad libA. Of course that is more productive, but I believe this is exactly the kind of philosophy that makes the software industry produce worse software every year :(.</div><br/><div id="39150587" class="c"><input type="checkbox" id="c-39150587" checked=""/><div class="controls bullet"><span class="by">zaphar</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150369">parent</a><span>|</span><a href="#39150647">next</a><span>|</span><label class="collapse" for="c-39150587">[-]</label><label class="expand" for="c-39150587">[2 more]</label></div><br/><div class="children"><div class="content">I used to think the same. But after nearly 30 years of doing this. I no longer think that people will meet the standard you propose. You can either work around it or you can abandon mainstream software entirely and make everything you use bespoke. There are basically no other choices.</div><br/><div id="39151197" class="c"><input type="checkbox" id="c-39151197" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150587">parent</a><span>|</span><a href="#39150647">next</a><span>|</span><label class="collapse" for="c-39151197">[-]</label><label class="expand" for="c-39151197">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I try really hard to not use &quot;bad&quot; dependencies. When I really can&#x27;t, well... I can&#x27;t.<p>But still I like to make it clear that the software industry goes in that direction because of quality issues, and not because the modern ways are superior (on the contrary, quite often) :-).</div><br/></div></div></div></div></div></div></div></div><div id="39150647" class="c"><input type="checkbox" id="c-39150647" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150018">parent</a><span>|</span><a href="#39150317">prev</a><span>|</span><a href="#39151823">next</a><span>|</span><label class="collapse" for="c-39150647">[-]</label><label class="expand" for="c-39150647">[2 more]</label></div><br/><div class="children"><div class="content">Wishing that all people will be smart and always do the correct thing is setting yourself up for madness. The dependency system needs to be robust enough to endure a considerable amount of dumbfuckery. Because there will be a lot of it.</div><br/><div id="39151214" class="c"><input type="checkbox" id="c-39151214" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150647">parent</a><span>|</span><a href="#39151823">next</a><span>|</span><label class="collapse" for="c-39151214">[-]</label><label class="expand" for="c-39151214">[1 more]</label></div><br/><div class="children"><div class="content">Because I have to live with &quot;malpractice&quot; doesn&#x27;t mean I should not say it is, IMHO.<p>I can accept that someone needs to make a hack, but I really want them to realize (and acknowledge) that it is a hack.</div><br/></div></div></div></div></div></div><div id="39151823" class="c"><input type="checkbox" id="c-39151823" checked=""/><div class="controls bullet"><span class="by">shusfuejdn</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148206">parent</a><span>|</span><a href="#39150018">prev</a><span>|</span><a href="#39153566">next</a><span>|</span><label class="collapse" for="c-39151823">[-]</label><label class="expand" for="c-39151823">[1 more]</label></div><br/><div class="children"><div class="content">It should be noted though that flatpaks and related solutions are NOT equivalent to static linking. They do a lot more and serve a wildly different audience than something like Oasis. They are really much too extreme for non-GUI applications, and I would question the competence of anybody found running ordinary programs packaged in that manner.<p>I recognize that you probably weren&#x27;t confused on this I&#x27;m just clarifying for others since the whole ecosystem can be a bit confusing.</div><br/></div></div></div></div></div></div><div id="39153566" class="c"><input type="checkbox" id="c-39153566" checked=""/><div class="controls bullet"><span class="by">manmal</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144348">parent</a><span>|</span><a href="#39146594">prev</a><span>|</span><a href="#39146314">next</a><span>|</span><label class="collapse" for="c-39153566">[-]</label><label class="expand" for="c-39153566">[1 more]</label></div><br/><div class="children"><div class="content">Apple has been pushing dynamic libraries for a while, but now realized that they really like static linking better. The result is they found a way to convert dynamic libraries into static ones for release builds, while keeping them dynamic for debug builds: <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;xcode&#x2F;configuring-your-project-to-use-mergeable-libraries" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;xcode&#x2F;configuring-...</a></div><br/></div></div><div id="39146314" class="c"><input type="checkbox" id="c-39146314" checked=""/><div class="controls bullet"><span class="by">gnramires</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144348">parent</a><span>|</span><a href="#39153566">prev</a><span>|</span><a href="#39149940">next</a><span>|</span><label class="collapse" for="c-39146314">[-]</label><label class="expand" for="c-39146314">[14 more]</label></div><br/><div class="children"><div class="content">As far as I can see, it would be unwise to roll back 30 years of (Linux) systems building with dynamic linking in favor of static linking. It mostly works very well and does save some memory, disk, and has nice security properties. Both have significant pros and cons.<p>I&#x27;ve been thinking (not a Linux expert by any means) the ideal solution would be to have better dependency management: I think a solution could be if say binaries themselves carried dependency information. That way you get the benefits of dynamic and static linking by just distributing binaries with embedded library requirements. Also, I think there should be a change of culture in library development to clearly mark compatibility breaks (I think something like semantic versioning works like that?).<p>That way, your software could support any newer version up to a compatibility break -- which should be extremely rare. And if you must break compatibility there should be an effort to keep old versions available, secure and bug free (or at least the old versions should be flagged as insecure in some widely accessible database).<p>Moreover, executing old&#x2F;historical software should become significantly easier if library information was kept in the executable itself (you&#x27;d just have to find the old libraries, which could be kept available in repositories).<p>I think something like that could finally enable portable Linux software? (Flatpak and AppImage notwithstanding)</div><br/><div id="39146836" class="c"><input type="checkbox" id="c-39146836" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146314">parent</a><span>|</span><a href="#39146632">next</a><span>|</span><label class="collapse" for="c-39146836">[-]</label><label class="expand" for="c-39146836">[6 more]</label></div><br/><div class="children"><div class="content">Everything you describe already exists. Executables <i>do</i> list their dependencies, and we have well-defined conventions for indicating ABI breaks. It is entirely normal to have multiple major versions of a library installed for ABI compatibility reasons, and it is also entirely normal to expect that you can upgrade the dependencies out from under a binary as long as the library hasn&#x27;t had an ABI break.<p>The bigger dependency management problem is that every distro has their own package manager and package repository and it&#x27;s tough for one application developer to build and test every kind of package. But if they just ship a binary, then it&#x27;s up to the poor user to figure out what packages to install. Often the library you need may not even be available on some distros or the version may be too old.</div><br/><div id="39147128" class="c"><input type="checkbox" id="c-39147128" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146836">parent</a><span>|</span><a href="#39149714">next</a><span>|</span><label class="collapse" for="c-39147128">[-]</label><label class="expand" for="c-39147128">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why distros ask you to provide just the sources and we&#x27;ll do the packaging work for you.  The upstream developers shouldn&#x27;t need to provide packages for every distro.  (Of course you can <i>help</i> us downstream packagers by not having insane build requirements, using semantic versioning, not breaking stuff randomly etc).</div><br/><div id="39149096" class="c"><input type="checkbox" id="c-39149096" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39147128">parent</a><span>|</span><a href="#39149714">next</a><span>|</span><label class="collapse" for="c-39149096">[-]</label><label class="expand" for="c-39149096">[3 more]</label></div><br/><div class="children"><div class="content">This is only realistic for established applications with large userbases. For new or very niche apps, distros are understandably not going to be very interested in doing this work. In that case the developer needs to find a way to distribute the app that they can reasonably maintain directly, and that&#x27;s where containers or statically-linked binaries are really convenient.</div><br/><div id="39150147" class="c"><input type="checkbox" id="c-39150147" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149096">parent</a><span>|</span><a href="#39149243">next</a><span>|</span><label class="collapse" for="c-39150147">[-]</label><label class="expand" for="c-39150147">[1 more]</label></div><br/><div class="children"><div class="content">I agree with everything you said up to this. We&#x27;re talking about a software library, for which the user is a software developer. IMO a software developer should be able to package a library for their own distro (then they can share that package with their community and become this package&#x27;s maintainer).<p>As the developer of an open source library, I don&#x27;t think that you should distribute it for systems that you don&#x27;t use; someone else who uses it should maintain the package. It doesn&#x27;t have to be a &quot;distro maintainer&quot;. Anyone can maintain a single package. I am not on a very mainstream distro, and I still haven&#x27;t found a single package that I use and is not already maintained by someone in the community (though I wish I did, I would like to maintain a package). My point is that it really works well :-).<p>I disagree with the idea that we should build a lot of tooling to &quot;lower the bar&quot; such that devs who don&#x27;t know how to handle a library don&#x27;t have to learn how to do it. They should learn, it&#x27;s their job.<p>For proprietary software, it&#x27;s admittedly a bit harder (I guess? I don&#x27;t have much experience there).</div><br/></div></div><div id="39149243" class="c"><input type="checkbox" id="c-39149243" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149096">parent</a><span>|</span><a href="#39150147">prev</a><span>|</span><a href="#39149714">next</a><span>|</span><label class="collapse" for="c-39149243">[-]</label><label class="expand" for="c-39149243">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t really true, Fedora, Debian and Arch have huge numbers of packages, many very niche.  You might well need to make the distro aware that the new program exists, but there are established routes for doing that.</div><br/></div></div></div></div></div></div><div id="39149714" class="c"><input type="checkbox" id="c-39149714" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146836">parent</a><span>|</span><a href="#39147128">prev</a><span>|</span><a href="#39146632">next</a><span>|</span><label class="collapse" for="c-39149714">[-]</label><label class="expand" for="c-39149714">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Executables do list their dependencies<p>They list paths to libraries, but not the exact version that the executable depends on. It is a common occurrence for executables to load versions of libraries they were not designed to be used with.</div><br/></div></div></div></div><div id="39146632" class="c"><input type="checkbox" id="c-39146632" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146314">parent</a><span>|</span><a href="#39146836">prev</a><span>|</span><a href="#39151576">next</a><span>|</span><label class="collapse" for="c-39146632">[-]</label><label class="expand" for="c-39146632">[6 more]</label></div><br/><div class="children"><div class="content">Yes, if someone actually did dependency management in Linux properly then I agree - dynamic linking would be fine. It works pretty well in Nixos as I understand it. But it’s called dependency hell for a reason. And the reason is almost no operating systems handle C dependencies well. There’s always weird, complex, distribution specific systems involving 18 different versions of every library. Do you want llvm18 or llvm18-dev or llvm-18-full-dev or something else entirely? Oh, you’re on gentoo? Better enable some USE flags. Redhat? It’s different again.<p>If Linux dependency management worked well, there would be no need or appetite for docker. But it works badly. So people just use docker and flatpak and whatnot instead, while my hard drive gently weeps. I don’t know about you, but I’m happy to declare bankruptcy on this project. I’d take a 2mb statically linked binary over a 300mb Linux docker image any day of the week.</div><br/><div id="39150221" class="c"><input type="checkbox" id="c-39150221" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146632">parent</a><span>|</span><a href="#39149859">next</a><span>|</span><label class="collapse" for="c-39150221">[-]</label><label class="expand" for="c-39150221">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If Linux dependency management worked well, there would be no need or appetite for docker.<p>I kindly disagree here. Linux dependency management does work well. The problem is the bad libraries that don&#x27;t do semver properly, and the users who still decide to use bad libraries.<p>If people stopped using libraries that break ABI compatibility, then the authors of those libraries would have to do it properly, and it would work. The reason it doesn&#x27;t work is really just malpractice.</div><br/><div id="39150359" class="c"><input type="checkbox" id="c-39150359" checked=""/><div class="controls bullet"><span class="by">zaphar</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150221">parent</a><span>|</span><a href="#39149859">next</a><span>|</span><label class="collapse" for="c-39150359">[-]</label><label class="expand" for="c-39150359">[2 more]</label></div><br/><div class="children"><div class="content">If Linux dependency management works well in theory but not in practice then it doesn&#x27;t work. It works in nix because it can literally use multiple minor versions of a library when it needs to with no problem. Most distro&#x27;s can&#x27;t or won&#x27;t do that.<p>You can call it malpractice but it&#x27;s not going to stop so in practice you need a way to deal with it.</div><br/><div id="39150498" class="c"><input type="checkbox" id="c-39150498" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150359">parent</a><span>|</span><a href="#39149859">next</a><span>|</span><label class="collapse" for="c-39150498">[-]</label><label class="expand" for="c-39150498">[1 more]</label></div><br/><div class="children"><div class="content">Well, by calling it &quot;malpractice&quot;, I say that it works for &quot;true professionals&quot;. Then we could say that &quot;it doesn&#x27;t work in practice if people who don&#x27;t know what they are doing cannot use it&quot;, of course.<p>The question then is where we want to put the bar. I feel like it is too low, and most software is too bad. And I don&#x27;t want to participate in making tooling that helps lowering the bar even more.</div><br/></div></div></div></div></div></div><div id="39149859" class="c"><input type="checkbox" id="c-39149859" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146632">parent</a><span>|</span><a href="#39150221">prev</a><span>|</span><a href="#39151576">next</a><span>|</span><label class="collapse" for="c-39149859">[-]</label><label class="expand" for="c-39149859">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t really an &quot;operating system&quot; problem. Particularly in the open-source world, there are a number of fairly core libraries that refuse to provide any kind of API compatibility.<p>Then, when there are a couple dozen applications&#x2F;etc that depend on that library, it&#x27;s almost an impossible problem because each of those applications then needs to be updated in lockstep with the library version. There is nothing &quot;clean&quot; about how to handle this situation short of having loads of distro maintainers showing up in the upstream packages to fix them to support newer versions of the library. Of course, then all the distro&#x27;s need to agree on what those versions are going to be...<p>Hence containers, which don&#x27;t fix the problem at all. Instead they just move the responsibility away from the distro, which should never really have been packaging applications to begin with.</div><br/><div id="39150241" class="c"><input type="checkbox" id="c-39150241" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149859">parent</a><span>|</span><a href="#39151576">next</a><span>|</span><label class="collapse" for="c-39150241">[-]</label><label class="expand" for="c-39150241">[1 more]</label></div><br/><div class="children"><div class="content">&gt; away from the distro, which should never really have been packaging applications to begin with.<p>I disagree here: the whole point of a &quot;software distribution&quot; is to &quot;distribute&quot; software. And it does so by packaging it. There is a ton of benefit in having distro&#x2F;package maintainers, and we tend to forget it.</div><br/></div></div></div></div></div></div><div id="39151576" class="c"><input type="checkbox" id="c-39151576" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146314">parent</a><span>|</span><a href="#39146632">prev</a><span>|</span><a href="#39149940">next</a><span>|</span><label class="collapse" for="c-39151576">[-]</label><label class="expand" for="c-39151576">[1 more]</label></div><br/><div class="children"><div class="content">Linus Torvalds disagrees: <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;CAHk-=whs8QZf3YnifdLv57+FhBi5_WeNTG1B-suOES=RcUSmQg@mail.gmail.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;CAHk-=whs8QZf3YnifdLv57+FhBi5_W...</a></div><br/></div></div></div></div><div id="39149940" class="c"><input type="checkbox" id="c-39149940" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144348">parent</a><span>|</span><a href="#39146314">prev</a><span>|</span><a href="#39149952">next</a><span>|</span><label class="collapse" for="c-39149940">[-]</label><label class="expand" for="c-39149940">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Dynamic linking served us when OS upgrades came infrequently, user software was almost never upgraded<p>Even today, dynamic linking is not only a security feature but also serves convenience. A security fix in OpenSSL or libwebp can be applied to everything that uses them by just updating those libraries instead of having to rebuild userland, with Firefox, Emacs, and so on.</div><br/><div id="39152414" class="c"><input type="checkbox" id="c-39152414" checked=""/><div class="controls bullet"><span class="by">plopz</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149940">parent</a><span>|</span><a href="#39149952">next</a><span>|</span><label class="collapse" for="c-39152414">[-]</label><label class="expand" for="c-39152414">[2 more]</label></div><br/><div class="children"><div class="content">Then why does every steam game need to install a different version of visual c++ redistributable?</div><br/><div id="39152527" class="c"><input type="checkbox" id="c-39152527" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39152414">parent</a><span>|</span><a href="#39149952">next</a><span>|</span><label class="collapse" for="c-39152527">[-]</label><label class="expand" for="c-39152527">[1 more]</label></div><br/><div class="children"><div class="content">Because they are not packaged by the distros so they are not guaranteed to have the libraries present that they were linked against? I am just guessing, I haven’t used Steam.</div><br/></div></div></div></div></div></div><div id="39149952" class="c"><input type="checkbox" id="c-39149952" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144348">parent</a><span>|</span><a href="#39149940">prev</a><span>|</span><a href="#39144383">next</a><span>|</span><label class="collapse" for="c-39149952">[-]</label><label class="expand" for="c-39149952">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not versed in this, so apologies for the stupid question, but wouldn&#x27;t statically linking be <i>more</i> secure, if anything?  Or at least have potentially better security?<p>I always thought the better security practice is statically linked Go binary in a docker container for namespace isolation.</div><br/><div id="39150014" class="c"><input type="checkbox" id="c-39150014" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149952">parent</a><span>|</span><a href="#39144383">next</a><span>|</span><label class="collapse" for="c-39150014">[-]</label><label class="expand" for="c-39150014">[3 more]</label></div><br/><div class="children"><div class="content">If there is a mechanism to monitor the dependency chain.  Otherwise, you may be blissfully unaware that some vulnerability in libwhatever is in some binary you&#x27;re using.<p>Golang tooling provides some reasonable mechanisms to keep dependencies up to date.  Any given C program might or might not.</div><br/><div id="39150479" class="c"><input type="checkbox" id="c-39150479" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150014">parent</a><span>|</span><a href="#39144383">next</a><span>|</span><label class="collapse" for="c-39150479">[-]</label><label class="expand" for="c-39150479">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If there is a mechanism to monitor the dependency chain.<p>So that would not be <i>less</i> secure, but it would also not make it <i>more</i> secure than dynamic linking with a good mechanism, right?</div><br/><div id="39150954" class="c"><input type="checkbox" id="c-39150954" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150479">parent</a><span>|</span><a href="#39144383">next</a><span>|</span><label class="collapse" for="c-39150954">[-]</label><label class="expand" for="c-39150954">[1 more]</label></div><br/><div class="children"><div class="content">Personally, I think any inherent security advantage (assuming it has great dependency management) would be very small.  This &quot;Oasis&quot; project doesn&#x27;t seem to call it out at all, even though they are making a fair amount of effort to track dependencies per binary.<p>They cite the main benefits being this: <i>&quot;Compared to dynamic linking, this is a simpler mechanism which eliminates problems with upgrading libraries, and results in completely self-contained binaries that can easily be copied to other systems&quot;</i>.<p>Even that &quot;easily be copied to other systems&quot; sort of cites one of the security downsides.  Is the system you&#x27;re copying it to going to make any effort to keep the transient statically linked stuff in it up to date?</div><br/></div></div></div></div></div></div></div></div><div id="39144383" class="c"><input type="checkbox" id="c-39144383" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144348">parent</a><span>|</span><a href="#39149952">prev</a><span>|</span><a href="#39145752">next</a><span>|</span><label class="collapse" for="c-39144383">[-]</label><label class="expand" for="c-39144383">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I’d prefer we just use another gigabyte of storage than add so much complexity. Even with what is a modest SSD capacity today I have a hard time imagining how I’d fill my storage. I’m reminded of my old workstation from 8 years ago. It had a 500GB hard drive and a 32GB SSD for caching. I immediately reconfigured to just use the SSD for everything by default. It ended up being plenty.</div><br/></div></div></div></div><div id="39145752" class="c"><input type="checkbox" id="c-39145752" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144281">parent</a><span>|</span><a href="#39144348">prev</a><span>|</span><a href="#39147092">next</a><span>|</span><label class="collapse" for="c-39145752">[-]</label><label class="expand" for="c-39145752">[2 more]</label></div><br/><div class="children"><div class="content">&gt;A linker typically only includes the parts of the library it needs for each binary so some parts will definately have many copies of the same code when you statically link but it will not make complete copies.<p>Just to add to what you said: in the old days the linker would include only the .o files in the .a library that were referenced.  Really common libraries like libc should be made to have only a single function per .o for this reason.<p>But modern compilers have link time optimization, which changes everything.  The compiler will automatically leave out any items not referenced without regard to .o file boundaries.  But more importantly, it can perform more optimizations.  Perhaps for a given program a libc function is always called with a constant for a certain argument.  The compiler could use this fact to simplify the function.<p>I&#x27;m thinking that you might be giving up quite a lot of performance by using shared libraries, unless you are willing to run the compiler during actual loading.<p>Even without lto, you can have the same results in C++ by having your library in the form of a template- so the library is fully in the &#x2F;usr&#x2F;include header file, with nothing in &#x2F;usr&#x2F;lib.</div><br/><div id="39151941" class="c"><input type="checkbox" id="c-39151941" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145752">parent</a><span>|</span><a href="#39147092">next</a><span>|</span><label class="collapse" for="c-39151941">[-]</label><label class="expand" for="c-39151941">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just to add to what you said: in the old days the linker would include only the .o files in the .a library that were referenced.<p>It was not exactly like that. Yes, the .o file granularity was there but the unused code from that .o file would also get linked in.<p>The original UNIX linker had a very simple and unsophisticated design (compared to its contemporaries) and would not attempt to optimise the final product being linked. Consider a scenario where the binary being linked references A from an «abcde.o» file, and the «abcde.o» file has A, B, C, D and E defined in it, so the original «ld» would link the entire «abcde.o» into the final product. Advanced optimisations came along much later on.</div><br/></div></div></div></div><div id="39147092" class="c"><input type="checkbox" id="c-39147092" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144281">parent</a><span>|</span><a href="#39145752">prev</a><span>|</span><a href="#39149844">next</a><span>|</span><label class="collapse" for="c-39147092">[-]</label><label class="expand" for="c-39147092">[2 more]</label></div><br/><div class="children"><div class="content">You should be keeping track of those library dependencies anyway if you want to know what you have to recompile when, say, zlib or openssl has a security problem.</div><br/><div id="39147393" class="c"><input type="checkbox" id="c-39147393" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39147092">parent</a><span>|</span><a href="#39149844">next</a><span>|</span><label class="collapse" for="c-39147393">[-]</label><label class="expand" for="c-39147393">[1 more]</label></div><br/><div class="children"><div class="content">Well, you have to do that anyways</div><br/></div></div></div></div><div id="39149844" class="c"><input type="checkbox" id="c-39149844" checked=""/><div class="controls bullet"><span class="by">giljabeab</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144281">parent</a><span>|</span><a href="#39147092">prev</a><span>|</span><a href="#39151900">next</a><span>|</span><label class="collapse" for="c-39149844">[-]</label><label class="expand" for="c-39149844">[1 more]</label></div><br/><div class="children"><div class="content">Can’t file systems de dupe this now</div><br/></div></div><div id="39151900" class="c"><input type="checkbox" id="c-39151900" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144281">parent</a><span>|</span><a href="#39149844">prev</a><span>|</span><a href="#39151400">next</a><span>|</span><label class="collapse" for="c-39151900">[-]</label><label class="expand" for="c-39151900">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A linker typically only includes the parts of the library it needs for each binary […]<p>It is exactly the same with the dynamic linking due to the demand paging available in all modern UNIX systems: the dynamic library is <i>not loaded</i> into memory in its entirety, it is <i>mapped</i> into the process&#x27;s <i>virtual</i> address space.<p>Initially, there is no code from the dynamic library loaded into memory until the process attempts to access the first instruction from the required code at which point a memory fault occurs, and the virtual memory management system loads the required page(s) into the process&#x27;s memory. A dynamic library can be 10Gb in size and appear as a 10Gb in the process&#x27;s memory map but only 1 page can be physically present in memory. Moreover, under the heavy memory pressure the kernel can invalidate the memory page(s) (using LRU or a more advanced memory page tracking technique) and the process (especially true for background or idlying processes) will reference zero pages with the code from the dynamic library.<p>Fundamentally, dynamic linking is the deferred static linking where the linking functions are delegated to the dynamic library loader. Dynamic libraries incur a [relatively] small overhead of slower (compared to statically linked binaries) process startup times due to the dynamic linker having to load the symbol table, the global offset table from the dynamic library and performing the symbol fixup according to the process&#x27;s own virtual memory layout. It is a one-off step, though. For large, very large and frequently used dynamic libraries, caching can be employed to reduce such overhead.<p>Dynamic library mapping into the virtual address space != loading the dynamic library into memory, they are two disjoint things. It almost never happens when the entire dynamic library is <i>loaded</i> into memory as the 100% code coverage is exceedingly rare.</div><br/></div></div></div></div><div id="39151400" class="c"><input type="checkbox" id="c-39151400" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39144281">prev</a><span>|</span><a href="#39144029">next</a><span>|</span><label class="collapse" for="c-39151400">[-]</label><label class="expand" for="c-39151400">[1 more]</label></div><br/><div class="children"><div class="content">I have seen this sort of statement on HN before.  I am guessing that the persons who propagate this idea have never actually experimented with replacing dynamically-linked programs having numerous dependencies with statically-compiled ones.  It&#x27;s a theory that makes sense in the abstract, but they have not actually tested it.<p>Though it is not a goal of mine to save storage space by using static binaries, and I actually expect to lose space as a tradeoff, I have actually saved storage space in some cases by using static binaries.  This comes from being able to remove libraries from &#x2F;usr&#x2F;lib.  TBH, I am not exactly sure why this is the case.  Perhaps in part because one might be storing large libraries containing significant numbers of functions that one&#x27;s programs never use.<p>For me using static binaries works well.  Even &quot;common&quot; libraries can be removed in some cases by using a multi-call&#x2F;crunched binary like busybox.  This might not work for everyone.  I think much depends on what selection of programs the computer owner prefers.   (Namely, the dependencies required by those programs.)</div><br/></div></div><div id="39144029" class="c"><input type="checkbox" id="c-39144029" checked=""/><div class="controls bullet"><span class="by">Shorel</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39151400">prev</a><span>|</span><a href="#39145431">next</a><span>|</span><label class="collapse" for="c-39144029">[-]</label><label class="expand" for="c-39144029">[14 more]</label></div><br/><div class="children"><div class="content">In a world where Docker and Kubernetes exist, where whole copies of operating systems are added to each running service...<p>This seems a weird thing to complain about  =)</div><br/><div id="39145611" class="c"><input type="checkbox" id="c-39145611" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144029">parent</a><span>|</span><a href="#39144093">next</a><span>|</span><label class="collapse" for="c-39145611">[-]</label><label class="expand" for="c-39145611">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This seems a weird thing to complain about =)<p>On the contrary, I find it relevant: I think that the modern way is wasting way, way too much.</div><br/><div id="39147145" class="c"><input type="checkbox" id="c-39147145" checked=""/><div class="controls bullet"><span class="by">Shorel</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145611">parent</a><span>|</span><a href="#39144093">next</a><span>|</span><label class="collapse" for="c-39147145">[-]</label><label class="expand" for="c-39147145">[1 more]</label></div><br/><div class="children"><div class="content">On that respect, we agree.</div><br/></div></div></div></div><div id="39144093" class="c"><input type="checkbox" id="c-39144093" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144029">parent</a><span>|</span><a href="#39145611">prev</a><span>|</span><a href="#39144087">next</a><span>|</span><label class="collapse" for="c-39144093">[-]</label><label class="expand" for="c-39144093">[7 more]</label></div><br/><div class="children"><div class="content">Yeah but there I can still update vulnerable libraries independently, to be a statically linked system just means that if there is a bug in libpng then I have to recompile everything?</div><br/><div id="39145537" class="c"><input type="checkbox" id="c-39145537" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144093">parent</a><span>|</span><a href="#39145723">next</a><span>|</span><label class="collapse" for="c-39145537">[-]</label><label class="expand" for="c-39145537">[1 more]</label></div><br/><div class="children"><div class="content">Not recompile I guess, but you need to relink everything.<p>Oasis seems to have a good way of doing that, with the whole system being built in a single tree by an efficient build tool (my recollection from last time it was posted).<p>A dynamic executable needs to relink every time it&#x27;s run, which also takes time.</div><br/></div></div><div id="39145723" class="c"><input type="checkbox" id="c-39145723" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144093">parent</a><span>|</span><a href="#39145537">prev</a><span>|</span><a href="#39144669">next</a><span>|</span><label class="collapse" for="c-39145723">[-]</label><label class="expand" for="c-39145723">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if there is a bug in libpng then I have to recompile everything?<p>You say that as if it&#x27;s such a burden. But it&#x27;s really not.<p>I&#x27;m somewhat sympathetic to the space argument, but a package manager&#x2F;docker registry means that updating software is very easy. And it happens all the time for other reasons today anyhow.</div><br/></div></div><div id="39144669" class="c"><input type="checkbox" id="c-39144669" checked=""/><div class="controls bullet"><span class="by">Shorel</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144093">parent</a><span>|</span><a href="#39145723">prev</a><span>|</span><a href="#39144245">next</a><span>|</span><label class="collapse" for="c-39144669">[-]</label><label class="expand" for="c-39144669">[2 more]</label></div><br/><div class="children"><div class="content">I was under the impression only Gentoo users recompile everything.<p>In a statically linked system, your dependency manager will update more packages.<p>And if your program is written in C&#x2F;C++&#x2F;Go&#x2F;Rust, then yes, it will be recompiled.</div><br/><div id="39145009" class="c"><input type="checkbox" id="c-39145009" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144669">parent</a><span>|</span><a href="#39144245">next</a><span>|</span><label class="collapse" for="c-39145009">[-]</label><label class="expand" for="c-39145009">[1 more]</label></div><br/><div class="children"><div class="content">I use Gentoo, so I am not against rebuild everything, but afaik unless you have static-libs USE flag for something, it&#x27;s dynamically linked so relinking on rebuilding the dependency is enough, with static-libs the dependent package is also rebuilt</div><br/></div></div></div></div><div id="39144245" class="c"><input type="checkbox" id="c-39144245" checked=""/><div class="controls bullet"><span class="by">bzzzt</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144093">parent</a><span>|</span><a href="#39144669">prev</a><span>|</span><a href="#39144612">next</a><span>|</span><label class="collapse" for="c-39144245">[-]</label><label class="expand" for="c-39144245">[1 more]</label></div><br/><div class="children"><div class="content">Yes, although it very much depends on how big &#x27;everything&#x27; is if that&#x27;s a problem.</div><br/></div></div><div id="39144612" class="c"><input type="checkbox" id="c-39144612" checked=""/><div class="controls bullet"><span class="by">greyw</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144093">parent</a><span>|</span><a href="#39144245">prev</a><span>|</span><a href="#39144087">next</a><span>|</span><label class="collapse" for="c-39144612">[-]</label><label class="expand" for="c-39144612">[1 more]</label></div><br/><div class="children"><div class="content">In most cases relinking is enough.</div><br/></div></div></div></div><div id="39144087" class="c"><input type="checkbox" id="c-39144087" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144029">parent</a><span>|</span><a href="#39144093">prev</a><span>|</span><a href="#39145431">next</a><span>|</span><label class="collapse" for="c-39144087">[-]</label><label class="expand" for="c-39144087">[4 more]</label></div><br/><div class="children"><div class="content">I mean, if you ran <i>every single executable</i> on your desktop in a separate container I think you&#x27;d see problems. There are a pretty large number of programs running on most desktops, plus all the programs that get called by shell scripts, etc.<p>Running a handful of containers representing major applications is more reasonable and the memory wastage may be worth it to avoid dependency conflicts.</div><br/><div id="39144473" class="c"><input type="checkbox" id="c-39144473" checked=""/><div class="controls bullet"><span class="by">drakenot</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144087">parent</a><span>|</span><a href="#39144959">next</a><span>|</span><label class="collapse" for="c-39144473">[-]</label><label class="expand" for="c-39144473">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve just described Qubes OS!</div><br/><div id="39147886" class="c"><input type="checkbox" id="c-39147886" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144473">parent</a><span>|</span><a href="#39144959">next</a><span>|</span><label class="collapse" for="c-39147886">[-]</label><label class="expand" for="c-39147886">[1 more]</label></div><br/><div class="children"><div class="content">Except that QubesOS uses VMs for their security benefits, which are greater than those of containers.<p>Containers make a lot of sense to me on servers (&quot;deploy a controlled environment&quot;), but often on Desktop I feel like they are used as a solution to &quot;I don&#x27;t know how to handle dependencies&quot; or &quot;My dependencies are so unstable that it is impossible to install them system-wide&quot;, both of which should be solved by making slightly better software.</div><br/></div></div></div></div><div id="39144959" class="c"><input type="checkbox" id="c-39144959" checked=""/><div class="controls bullet"><span class="by">Gabrys1</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144087">parent</a><span>|</span><a href="#39144473">prev</a><span>|</span><a href="#39145431">next</a><span>|</span><label class="collapse" for="c-39144959">[-]</label><label class="expand" for="c-39144959">[1 more]</label></div><br/><div class="children"><div class="content">Each electron app is like that</div><br/></div></div></div></div></div></div><div id="39145431" class="c"><input type="checkbox" id="c-39145431" checked=""/><div class="controls bullet"><span class="by">Gazoche</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39144029">prev</a><span>|</span><a href="#39148420">next</a><span>|</span><label class="collapse" for="c-39145431">[-]</label><label class="expand" for="c-39145431">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll take bloat over dependency hell every day of the week. Feels like every single app is a bundled web browser these days anyways.</div><br/><div id="39145603" class="c"><input type="checkbox" id="c-39145603" checked=""/><div class="controls bullet"><span class="by">nerpderp82</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145431">parent</a><span>|</span><a href="#39145563">next</a><span>|</span><label class="collapse" for="c-39145603">[-]</label><label class="expand" for="c-39145603">[7 more]</label></div><br/><div class="children"><div class="content">Dynamic Library hell is why Docker exists. If operating systems had less global state and less ambient authority, our systems would be vastly more tractable. Instead we still create environments that look like replicas of whole hosts.<p>Might as well go all in and use something with pervasive virtualization like Qubes.<p><a href="https:&#x2F;&#x2F;www.qubes-os.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.qubes-os.org&#x2F;</a></div><br/><div id="39149810" class="c"><input type="checkbox" id="c-39149810" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145603">parent</a><span>|</span><a href="#39146530">next</a><span>|</span><label class="collapse" for="c-39149810">[-]</label><label class="expand" for="c-39149810">[2 more]</label></div><br/><div class="children"><div class="content">To be fair, QubesOS does not really solve the problem of bad libraries creating dependency hell. If you need to ship <i>every app</i> with its own rootfs because you can&#x27;t handle dependencies, then you will have to do that on QubesOS as well (you don&#x27;t want one VM per app).<p>Also the biggest problem I had with QubesOS is that it doesn&#x27;t support GPU (for security reasons). It feels like that was a big cause for the reduced performance. I wish there was a solution for the GPU, and then I would love to daily-drive QubesOS.</div><br/><div id="39150045" class="c"><input type="checkbox" id="c-39150045" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149810">parent</a><span>|</span><a href="#39146530">next</a><span>|</span><label class="collapse" for="c-39150045">[-]</label><label class="expand" for="c-39150045">[1 more]</label></div><br/><div class="children"><div class="content">Same, I love Qubes&#x27; philosophy and UX, but GPU passthrough support was a dealbreaker in the end and I switched to a KVM system.</div><br/></div></div></div></div><div id="39149941" class="c"><input type="checkbox" id="c-39149941" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145603">parent</a><span>|</span><a href="#39146530">prev</a><span>|</span><a href="#39145563">next</a><span>|</span><label class="collapse" for="c-39149941">[-]</label><label class="expand" for="c-39149941">[3 more]</label></div><br/><div class="children"><div class="content">Exactly this. Windows apps aren&#x27;t distributed as Docker images. Guess why...</div><br/><div id="39150268" class="c"><input type="checkbox" id="c-39150268" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149941">parent</a><span>|</span><a href="#39145563">next</a><span>|</span><label class="collapse" for="c-39150268">[-]</label><label class="expand" for="c-39150268">[2 more]</label></div><br/><div class="children"><div class="content">Well nothing prevents you from dynamically linking only glibc and statically linking everything else, <i>without Docker at all</i>.<p>The fact that people distribute their app with a full rootfs in a Docker containers says more about the fact that they don&#x27;t know how to link stuff properly, IMHO.</div><br/><div id="39153669" class="c"><input type="checkbox" id="c-39153669" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150268">parent</a><span>|</span><a href="#39145563">next</a><span>|</span><label class="collapse" for="c-39153669">[-]</label><label class="expand" for="c-39153669">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about static vs dynamic linking at all. It&#x27;s about bundling dependencies or not.<p>And yes, you totally can do it. Most Linux software just doesn&#x27;t bother because - while you <i>can</i> do it, in a lot of languages (C, Python, etc.) it&#x27;s quite a pain to do. Especially if you have lots of dependencies.<p>It&#x27;s much easier to bundle dependencies in languages that statically link by default (Go, Rust) because of course statically linking implicitly bundles them.</div><br/></div></div></div></div></div></div></div></div><div id="39145563" class="c"><input type="checkbox" id="c-39145563" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145431">parent</a><span>|</span><a href="#39145603">prev</a><span>|</span><a href="#39148420">next</a><span>|</span><label class="collapse" for="c-39145563">[-]</label><label class="expand" for="c-39145563">[9 more]</label></div><br/><div class="children"><div class="content">&gt; dependency hell<p>Dependency hell comes from bad dependencies that don&#x27;t do semver properly. Choose your deps carefully, and that&#x27;s perfectly fine.<p>&gt; Feels like every single app is a bundled web browser these days anyways.<p>Yep, that&#x27;s apparently the best way to use the bad libraries people want to use and not give a damn about semver.</div><br/><div id="39145876" class="c"><input type="checkbox" id="c-39145876" checked=""/><div class="controls bullet"><span class="by">hn_go_brrrrr</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145563">parent</a><span>|</span><a href="#39150093">next</a><span>|</span><label class="collapse" for="c-39145876">[-]</label><label class="expand" for="c-39145876">[5 more]</label></div><br/><div class="children"><div class="content">Semver is nearly impossible to do &quot;properly&quot; because of <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172</a>. With a sufficient number of users, all bug fixes are breaking changes. If the behavior can possibly be observed in any way, some user will be depending on it, deliberately or otherwise.</div><br/><div id="39148197" class="c"><input type="checkbox" id="c-39148197" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145876">parent</a><span>|</span><a href="#39147988">next</a><span>|</span><label class="collapse" for="c-39148197">[-]</label><label class="expand" for="c-39148197">[1 more]</label></div><br/><div class="children"><div class="content">Semver doesn&#x27;t stop people from depending on unstable&#x2F;implementation-specific behaviour; it needs to be coupled with a strong mechanism for defining what behaviour is defined by an API, and the result is that &quot;the bug&quot; is with all those users who depend on un-guaranteed behaviour.<p>The breaks happen regardless, but you have a principled way of defining whose fault&#x2F;problem it is.</div><br/></div></div><div id="39147988" class="c"><input type="checkbox" id="c-39147988" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145876">parent</a><span>|</span><a href="#39148197">prev</a><span>|</span><a href="#39146186">next</a><span>|</span><label class="collapse" for="c-39147988">[-]</label><label class="expand" for="c-39147988">[1 more]</label></div><br/><div class="children"><div class="content">I would argue that <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172</a> is a case where the user &quot;deserves&quot; the breaking change, because they relied on a hack in the first place.<p>That&#x27;s the thing: I feel like people tend to call &quot;dependency hell&quot; what I would consider downright malpractice. &quot;Shared libraries don&#x27;t work because they require good practice&quot; is, IMO, not a good argument against shared libraries. If you need to design your tool with the constraints that &quot;users will use it wrongly&quot;, then it&#x27;s already lost.</div><br/></div></div><div id="39146186" class="c"><input type="checkbox" id="c-39146186" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145876">parent</a><span>|</span><a href="#39147988">prev</a><span>|</span><a href="#39150093">next</a><span>|</span><label class="collapse" for="c-39146186">[-]</label><label class="expand" for="c-39146186">[2 more]</label></div><br/><div class="children"><div class="content">Semver defines what is breaking and not-breaking. E.g., Rust semver says that &quot;code should continue compiling with a minor version bump, but not necessarily for a major version bump&quot;</div><br/><div id="39146804" class="c"><input type="checkbox" id="c-39146804" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39146186">parent</a><span>|</span><a href="#39150093">next</a><span>|</span><label class="collapse" for="c-39146804">[-]</label><label class="expand" for="c-39146804">[1 more]</label></div><br/><div class="children"><div class="content">Yes. The very first line of the spec:<p>&gt; Software using Semantic Versioning MUST declare a public API. This API could be declared in the code itself or exist strictly in documentation. However it is done, it SHOULD be precise and comprehensive.<p>If it&#x27;s not in the API, it is not bound by the rules. Many ecosystems come up with various norms, like Rust has, to help guide people in this. But it&#x27;s almost certainly not a semver violation to make the change described in the XKCD because &quot;handle unknown unknowns&quot; is not possible. That doesn&#x27;t mean that we should throw out the entire idea of software assisted upgrades to dependencies.</div><br/></div></div></div></div></div></div><div id="39150093" class="c"><input type="checkbox" id="c-39150093" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39145563">parent</a><span>|</span><a href="#39145876">prev</a><span>|</span><a href="#39148420">next</a><span>|</span><label class="collapse" for="c-39150093">[-]</label><label class="expand" for="c-39150093">[3 more]</label></div><br/><div class="children"><div class="content">There are various kinds of &quot;dependency hell&quot;. To be honest I can&#x27;t think of any that are due to not doing semver properly. Usually it&#x27;s:<p>1. Software depending on versions of libraries that are newer than the latest version available on the distro you have to use (<i>cough RHEL 8</i>). E.g. this very day I ran into a bug where some Asciidoctor plugin craps out with an error because my version of Ruby isn&#x27;t new enough. Ruby&#x27;s advice for how to install Ruby is &quot;use your package manager; you will get an old version btw fuck you&quot;.<p>90% of the time it&#x27;s bloody glibc. Every Linux user has run into the dreaded glibc version error dozens of times in their career.<p>2. Software that can&#x27;t install multiple versions of the same package, leading to diamond dependency issues. Python is very bad for this.</div><br/><div id="39150336" class="c"><input type="checkbox" id="c-39150336" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150093">parent</a><span>|</span><a href="#39148420">next</a><span>|</span><label class="collapse" for="c-39150336">[-]</label><label class="expand" for="c-39150336">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Software depending on versions of libraries that are newer than the latest version available on the distro you have to use (cough RHEL 8).<p>That is a fair point, but it raises a question: if you <i>absolutely</i> need to use software that is not packaged by your distro of choice and that you cannot package yourself (are you sure you can&#x27;t maintain a &quot;community&quot; package yourself with RHEL?), maybe you don&#x27;t want that distro.<p>Different distros come with different goals. If you take a &quot;super slow but secure&quot; distro, it will be slow and secure. If you take a rolling distro, you get updates very quickly but it has drawbacks. It depends on the use-case, but going for a &quot;slow and secure&quot; distro and then building tooling to work around that choice (&quot;nevermind, I&#x27;ll ship new and less mature software anyway, statically linked&quot;) seems to defeat the purpose of the distro... right?</div><br/><div id="39153652" class="c"><input type="checkbox" id="c-39153652" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39150336">parent</a><span>|</span><a href="#39148420">next</a><span>|</span><label class="collapse" for="c-39153652">[-]</label><label class="expand" for="c-39153652">[1 more]</label></div><br/><div class="children"><div class="content">&gt; maybe you don&#x27;t want that distro<p>Well I definitely don&#x27;t want RHEL 8 but unfortunately I have to use it because some software I use requires it (RHEL 9 doesn&#x27;t have <i>old</i> enough versions of some libraries) or is only certified on it (this is for work).<p>But even if I was using a more modern distro, none of them have <i>all</i> software packaged. And no I obviously don&#x27;t want want to become a packager. Some of the software I use is closed source so that&#x27;s not even an option.<p>The only real option is Docker (or Apptainer&#x2F;Distrobox etc), which sucks.<p>The fundamental model of &quot;we&#x27;ll just ship all software that exists; all software is open source&quot; that most distros try to use is just fundamentally wrong.<p>Snap and Flatpak are trying to fix that but in my experience they aren&#x27;t remotely ready yet.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39148420" class="c"><input type="checkbox" id="c-39148420" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39145431">prev</a><span>|</span><a href="#39143867">next</a><span>|</span><label class="collapse" for="c-39148420">[-]</label><label class="expand" for="c-39148420">[7 more]</label></div><br/><div class="children"><div class="content">Static linked binaries are a generally <i>lot</i> smaller than a dynamically linked library and its dependencies, especially with link-time optimizations and inlining.<p>You wouldn&#x27;t want have 100 tools statically link the entirety of chromium, but for normal C library sizes you don&#x27;t get bloat. The  preference for dynamic libraries in Linux distros is just so they can roll out patch updates in one place instead of rebuilding dependents.</div><br/><div id="39148545" class="c"><input type="checkbox" id="c-39148545" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148420">parent</a><span>|</span><a href="#39143867">next</a><span>|</span><label class="collapse" for="c-39148545">[-]</label><label class="expand" for="c-39148545">[6 more]</label></div><br/><div class="children"><div class="content">But dynamically linked library only needs to be loaded to RAM once whereas with static linking you&#x27;d be loading the same code many times (unless you compile everything to single binary like BusyBox). This also gets you better cache utilization.<p>Also I think inlining would typically increase the total size of output rather than decrease it.</div><br/><div id="39151565" class="c"><input type="checkbox" id="c-39151565" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148545">parent</a><span>|</span><a href="#39148689">next</a><span>|</span><label class="collapse" for="c-39151565">[-]</label><label class="expand" for="c-39151565">[3 more]</label></div><br/><div class="children"><div class="content">Static linking gives you better instruction cache utilization as you are executing local code linearly rather than going through indirection with more boilerplate. This indirection costs a few cycles too.<p>Inlining external code reduces the size not only by saving the call, PLT and and stack dance, but also through specialization (removal of unused conditional, pruning of no longer referenced symbols) as the code is locally optimized. This further reduction in size further improves cache behavior and performance.<p>Duplication can be an issue (not necessarily for performance, but for total binary size), but compilers have heuristics for that. Even just having the symbol local saves some space and call overhead though (no PLT).<p>The case for the shared library having better caching implies multiple processes that are <i>distinct</i> executables (otherwise they share program memory regardless of linkage) trying to hammer it at once, sharing the continued caching, but such scenario is hurt by the call overhead and lower optimization opportunities, negating the result.</div><br/><div id="39151934" class="c"><input type="checkbox" id="c-39151934" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39151565">parent</a><span>|</span><a href="#39152044">next</a><span>|</span><label class="collapse" for="c-39151934">[-]</label><label class="expand" for="c-39151934">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The case for the shared library having better caching implies multiple processes that are distinct executables<p>But this is the most common case for desktops&#x2F;multipurpose systems.<p>On my desktop there are tens or hundreds distinct processes sharing most of their code.</div><br/></div></div><div id="39152044" class="c"><input type="checkbox" id="c-39152044" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39151565">parent</a><span>|</span><a href="#39151934">prev</a><span>|</span><a href="#39148689">next</a><span>|</span><label class="collapse" for="c-39152044">[-]</label><label class="expand" for="c-39152044">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Static linking gives you better instruction cache utilization as you are executing local code linearly rather than going through indirection with more boilerplate.<p>No, it does not, it worsens it.<p>For example, «strlen», if it comes from a dynamic library, will be loaded into the physical memory once and only once, and it will be mapped into each process&#x27;s address space as many times as there are processes. Since «strlen» is a very frequently used function, there is a very high chance that the page will remain resident in memory for a very long time, and since the <i>physical</i> page is resident in memory, there is also a very good chance that the page will remain resident at least in the L2 cache, but – depending on circumstances – in the L1 cache, too. A TLB flush might not even be necessary in specific circumstances, which is a big performance win. It is a 1:N scenario.<p>With the static linking, on the other hand, if there are 10k processes in the system, there will be 10k distinct pages containing «strlen» loaded into memory at 10k random addresses. It is a M:N scenario. Since the <i>physical</i> memory pages are now distinct, the context switching will nearly always require the TLB to be flushed out which is costly or very costly, and more frequent L1&#x2F;L2 cache invalidations due to «strlen» now residing at 10k distinct <i>physical</i> memory addresses.<p>P.S. I am aware that C compilers now inline «strlen» so there is no actual function call, but let&#x27;s pretend that it is not inlined for the sake of the conversation.</div><br/></div></div></div></div><div id="39148689" class="c"><input type="checkbox" id="c-39148689" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148545">parent</a><span>|</span><a href="#39151565">prev</a><span>|</span><a href="#39143867">next</a><span>|</span><label class="collapse" for="c-39148689">[-]</label><label class="expand" for="c-39148689">[2 more]</label></div><br/><div class="children"><div class="content">So you only need to load duplicated code for each different statically linked program. If there are many processes running the same program, they will all share the same physical pages for the code.  So for example, having 100s of &quot;bash&quot; instances running does not use that much memory.<p>You can see this by running &quot;pmap &lt;pid&gt; -XX&quot;  (the output is very wide- probably load it into an editor).  Look at the shared vs. private pages.<p>Also: There is another way to automatically share pages between different programs: de-duplication.  This would require common libraries to be statically linked on page boundaries.  The OS would quickly de-duplicate during loading by hashing the pages.  VMs use this technique to increase effective memory when there are many guest OS running.</div><br/><div id="39148815" class="c"><input type="checkbox" id="c-39148815" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39148689">parent</a><span>|</span><a href="#39143867">next</a><span>|</span><label class="collapse" for="c-39148815">[-]</label><label class="expand" for="c-39148815">[1 more]</label></div><br/><div class="children"><div class="content">Yes but most processes are unique. The only bash process I have running is my interactive shell.</div><br/></div></div></div></div></div></div></div></div><div id="39143867" class="c"><input type="checkbox" id="c-39143867" checked=""/><div class="controls bullet"><span class="by">zshrc</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39148420">prev</a><span>|</span><a href="#39145543">next</a><span>|</span><label class="collapse" for="c-39143867">[-]</label><label class="expand" for="c-39143867">[2 more]</label></div><br/><div class="children"><div class="content">musl is significantly smaller and &quot;less bloat&quot; than glibc, so even with a statically linked program, it still remains small in both system memory and storage.</div><br/><div id="39143881" class="c"><input type="checkbox" id="c-39143881" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39143867">parent</a><span>|</span><a href="#39145543">next</a><span>|</span><label class="collapse" for="c-39143881">[-]</label><label class="expand" for="c-39143881">[1 more]</label></div><br/><div class="children"><div class="content">And using LTO[0] can also help.<p>[0]<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;wiki&#x2F;LinkTimeOptimization" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;wiki&#x2F;LinkTimeOptimization</a></div><br/></div></div></div></div><div id="39145543" class="c"><input type="checkbox" id="c-39145543" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39143867">prev</a><span>|</span><a href="#39149304">next</a><span>|</span><label class="collapse" for="c-39145543">[-]</label><label class="expand" for="c-39145543">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. Bloat is one reason why originally dynamic linking was rolled out but the bigger benefit (to manufacturers) was to be able to update libraries without updating the applications. This has been the source of much trouble (dependency hell) and statically linked binaries suffer none of these issues. It&#x27;s not like every application uses all of every library and an efficient linker is able to see which parts of the library it needs to link and which parts it can safely leave out.</div><br/></div></div><div id="39149304" class="c"><input type="checkbox" id="c-39149304" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39145543">prev</a><span>|</span><a href="#39144107">next</a><span>|</span><label class="collapse" for="c-39149304">[-]</label><label class="expand" for="c-39149304">[3 more]</label></div><br/><div class="children"><div class="content">Once it’s loaded in memory, if  Kernel Samepage Merging is enabled it might not be as bad, but would love to hear of somebody has any thoughts
  <a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;mm&#x2F;ksm.html" rel="nofollow">https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;mm&#x2F;ksm.html</a></div><br/><div id="39149504" class="c"><input type="checkbox" id="c-39149504" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149304">parent</a><span>|</span><a href="#39144107">next</a><span>|</span><label class="collapse" for="c-39149504">[-]</label><label class="expand" for="c-39149504">[2 more]</label></div><br/><div class="children"><div class="content">From the link:<p>&gt; KSM only merges anonymous (private) pages, never pagecache (file) pages.<p>So it wouldn&#x27;t be able to help with static libraries loaded from different executables. (At any rate, they&#x27;d have to be at the same alignment within the page, which is unlikely without some special linker configuration.)</div><br/><div id="39149820" class="c"><input type="checkbox" id="c-39149820" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39149504">parent</a><span>|</span><a href="#39144107">next</a><span>|</span><label class="collapse" for="c-39149820">[-]</label><label class="expand" for="c-39149820">[1 more]</label></div><br/><div class="children"><div class="content">Had completely missed that line — great point!</div><br/></div></div></div></div></div></div><div id="39144107" class="c"><input type="checkbox" id="c-39144107" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39149304">prev</a><span>|</span><a href="#39144311">next</a><span>|</span><label class="collapse" for="c-39144107">[-]</label><label class="expand" for="c-39144107">[2 more]</label></div><br/><div class="children"><div class="content">It would be bloated, but how big of a problem is that these days? A TB of storage is pretty cheap.</div><br/><div id="39144244" class="c"><input type="checkbox" id="c-39144244" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144107">parent</a><span>|</span><a href="#39144311">next</a><span>|</span><label class="collapse" for="c-39144244">[-]</label><label class="expand" for="c-39144244">[1 more]</label></div><br/><div class="children"><div class="content">A TB of memory is not</div><br/></div></div></div></div><div id="39144311" class="c"><input type="checkbox" id="c-39144311" checked=""/><div class="controls bullet"><span class="by">bzzzt</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39144107">prev</a><span>|</span><a href="#39144944">next</a><span>|</span><label class="collapse" for="c-39144311">[-]</label><label class="expand" for="c-39144311">[4 more]</label></div><br/><div class="children"><div class="content">I know lots of compilers&#x2F;linkers don&#x27;t optimize for it but it should be possible to &#x27;tree shake&#x27; libraries so only the parts that are used by an application are included. That would shake off a lot of the &#x27;bloat&#x27;.</div><br/><div id="39144849" class="c"><input type="checkbox" id="c-39144849" checked=""/><div class="controls bullet"><span class="by">volemo</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144311">parent</a><span>|</span><a href="#39144944">next</a><span>|</span><label class="collapse" for="c-39144849">[-]</label><label class="expand" for="c-39144849">[3 more]</label></div><br/><div class="children"><div class="content">Wait, it&#x27;s not being done?</div><br/><div id="39145719" class="c"><input type="checkbox" id="c-39145719" checked=""/><div class="controls bullet"><span class="by">dieortin</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144849">parent</a><span>|</span><a href="#39148381">next</a><span>|</span><label class="collapse" for="c-39145719">[-]</label><label class="expand" for="c-39145719">[1 more]</label></div><br/><div class="children"><div class="content">It is, major compilers do that by default</div><br/></div></div><div id="39148381" class="c"><input type="checkbox" id="c-39148381" checked=""/><div class="controls bullet"><span class="by">Fronzie</span><span>|</span><a href="#39143840">root</a><span>|</span><a href="#39144849">parent</a><span>|</span><a href="#39145719">prev</a><span>|</span><a href="#39144944">next</a><span>|</span><label class="collapse" for="c-39148381">[-]</label><label class="expand" for="c-39148381">[1 more]</label></div><br/><div class="children"><div class="content">As far as I know, even with LTO, it requires -ffunction-sections -fdata-sections in order to strip out unused functions.</div><br/></div></div></div></div></div></div><div id="39144944" class="c"><input type="checkbox" id="c-39144944" checked=""/><div class="controls bullet"><span class="by">Gabrys1</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39144311">prev</a><span>|</span><a href="#39144132">next</a><span>|</span><label class="collapse" for="c-39144944">[-]</label><label class="expand" for="c-39144944">[1 more]</label></div><br/><div class="children"><div class="content">I guess each of the copies of libc can be optimized away and only the functions the specific binary calls will be left (and the compiler should be allowed to optimize past the library boundary), so maybe this balances the issues a bit.<p>Not that I really know anything about it, ask jart</div><br/></div></div><div id="39144132" class="c"><input type="checkbox" id="c-39144132" checked=""/><div class="controls bullet"><span class="by">thanatos519</span><span>|</span><a href="#39143840">parent</a><span>|</span><a href="#39144944">prev</a><span>|</span><a href="#39143551">next</a><span>|</span><label class="collapse" for="c-39144132">[-]</label><label class="expand" for="c-39144132">[1 more]</label></div><br/><div class="children"><div class="content">KSM could help with that: <a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;mm&#x2F;ksm.html" rel="nofollow">https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;mm&#x2F;ksm.html</a><p>... oh wait, the apps have to hint that it&#x27;s possible. Nebbermind.</div><br/></div></div></div></div><div id="39143551" class="c"><input type="checkbox" id="c-39143551" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#39143840">prev</a><span>|</span><a href="#39144428">next</a><span>|</span><label class="collapse" for="c-39143551">[-]</label><label class="expand" for="c-39143551">[7 more]</label></div><br/><div class="children"><div class="content">Interesting, but what is the use case?<p>What is the advantage of using the croc C compiler instead of e.g. TCC?<p>I wasn&#x27;t aware of Netsurf (<a href="https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;);" rel="nofollow">https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;);</a> this is really amazing. But it seems to use Duktape as the JS engine, so performance might be an issue.</div><br/><div id="39144523" class="c"><input type="checkbox" id="c-39144523" checked=""/><div class="controls bullet"><span class="by">helloimhonk</span><span>|</span><a href="#39143551">parent</a><span>|</span><a href="#39149258">next</a><span>|</span><label class="collapse" for="c-39144523">[-]</label><label class="expand" for="c-39144523">[2 more]</label></div><br/><div class="children"><div class="content">cproc supports C11, tcc only goes up to c99. There is also something to be said for cproc using QBE which is slowly growing backends like risc-v etc which tcc doesnt support afaik.</div><br/><div id="39145216" class="c"><input type="checkbox" id="c-39145216" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#39143551">root</a><span>|</span><a href="#39144523">parent</a><span>|</span><a href="#39149258">next</a><span>|</span><label class="collapse" for="c-39145216">[-]</label><label class="expand" for="c-39145216">[1 more]</label></div><br/><div class="children"><div class="content">Ok, thanks, that makes sense. QBE looks interesting, but I&#x27;m missing 32 bit support. So currently I&#x27;m trying to reuse the TCC backend, which is far from trivial.</div><br/></div></div></div></div><div id="39149258" class="c"><input type="checkbox" id="c-39149258" checked=""/><div class="controls bullet"><span class="by">willy_k</span><span>|</span><a href="#39143551">parent</a><span>|</span><a href="#39144523">prev</a><span>|</span><a href="#39150378">next</a><span>|</span><label class="collapse" for="c-39149258">[-]</label><label class="expand" for="c-39149258">[1 more]</label></div><br/><div class="children"><div class="content">Tangential, but the trailing “&#x2F;“ in the URL you gave seems to include the “);” in the hyperlink, giving a “Not Found” error.<p>Working link: <a href="https:&#x2F;&#x2F;www.netsurf-browser.org" rel="nofollow">https:&#x2F;&#x2F;www.netsurf-browser.org</a></div><br/></div></div><div id="39150378" class="c"><input type="checkbox" id="c-39150378" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#39143551">parent</a><span>|</span><a href="#39149258">prev</a><span>|</span><a href="#39144148">next</a><span>|</span><label class="collapse" for="c-39150378">[-]</label><label class="expand" for="c-39150378">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;documentation&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;documentation&#x2F;</a><p>Every single link on that page is dead.<p><a href="https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;about&#x2F;screenshots&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;about&#x2F;screenshots&#x2F;</a><p>Judging by the screenshots, it can render BBC, its own website, and Wikipedia. Well, it might be able to render others, we just can&#x27;t tell from the shots. But we can tell those three websites work with all sorts of different window decorations.</div><br/><div id="39150820" class="c"><input type="checkbox" id="c-39150820" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#39143551">root</a><span>|</span><a href="#39150378">parent</a><span>|</span><a href="#39144148">next</a><span>|</span><label class="collapse" for="c-39150820">[-]</label><label class="expand" for="c-39150820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Every single link on that page is dead</i><p>Unfortunately, as it seems. On the start page they say &quot;Last updated 2 January 2007&quot;. But version 3.11 was released on 28 Dec 2023.</div><br/></div></div></div></div><div id="39144148" class="c"><input type="checkbox" id="c-39144148" checked=""/><div class="controls bullet"><span class="by">cpach</span><span>|</span><a href="#39143551">parent</a><span>|</span><a href="#39150378">prev</a><span>|</span><a href="#39144428">next</a><span>|</span><label class="collapse" for="c-39144148">[-]</label><label class="expand" for="c-39144148">[1 more]</label></div><br/><div class="children"><div class="content">AFAICT it could be useful for embedded devices.</div><br/></div></div></div></div><div id="39144428" class="c"><input type="checkbox" id="c-39144428" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39143551">prev</a><span>|</span><a href="#39143029">next</a><span>|</span><label class="collapse" for="c-39144428">[-]</label><label class="expand" for="c-39144428">[4 more]</label></div><br/><div class="children"><div class="content">Does anyone know how big the base installation is? I couldn&#x27;t find an answer anywhere, and the link to the QEMU image appears to be broken, currently.<p>I&#x27;m curious how it compares to, say, Alpine with a similar set of packages.</div><br/><div id="39148518" class="c"><input type="checkbox" id="c-39148518" checked=""/><div class="controls bullet"><span class="by">jackothy</span><span>|</span><a href="#39144428">parent</a><span>|</span><a href="#39143029">next</a><span>|</span><label class="collapse" for="c-39148518">[-]</label><label class="expand" for="c-39148518">[3 more]</label></div><br/><div class="children"><div class="content">I have an old (2020) .qcow2 lying around that&#x27;s about 360MB</div><br/><div id="39149037" class="c"><input type="checkbox" id="c-39149037" checked=""/><div class="controls bullet"><span class="by">xiconfjs</span><span>|</span><a href="#39144428">root</a><span>|</span><a href="#39148518">parent</a><span>|</span><a href="#39143029">next</a><span>|</span><label class="collapse" for="c-39149037">[-]</label><label class="expand" for="c-39149037">[2 more]</label></div><br/><div class="children"><div class="content">could you please upload it?</div><br/><div id="39149762" class="c"><input type="checkbox" id="c-39149762" checked=""/><div class="controls bullet"><span class="by">elfstead</span><span>|</span><a href="#39144428">root</a><span>|</span><a href="#39149037">parent</a><span>|</span><a href="#39143029">next</a><span>|</span><label class="collapse" for="c-39149762">[-]</label><label class="expand" for="c-39149762">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;elfstead.com&#x2F;archive&#x2F;oasis-qemu.tar.xz" rel="nofollow">https:&#x2F;&#x2F;elfstead.com&#x2F;archive&#x2F;oasis-qemu.tar.xz</a></div><br/></div></div></div></div></div></div></div></div><div id="39143029" class="c"><input type="checkbox" id="c-39143029" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39144428">prev</a><span>|</span><a href="#39150058">next</a><span>|</span><label class="collapse" for="c-39143029">[-]</label><label class="expand" for="c-39143029">[3 more]</label></div><br/><div class="children"><div class="content">michaelforney was also who did the wayland port of st: <a href="https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;st">https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;st</a><p>oasis&#x27;s predecessor would be <a href="https:&#x2F;&#x2F;dl.suckless.org&#x2F;htmlout&#x2F;sta.li" rel="nofollow">https:&#x2F;&#x2F;dl.suckless.org&#x2F;htmlout&#x2F;sta.li</a></div><br/><div id="39143391" class="c"><input type="checkbox" id="c-39143391" checked=""/><div class="controls bullet"><span class="by">sigsev_251</span><span>|</span><a href="#39143029">parent</a><span>|</span><a href="#39150058">next</a><span>|</span><label class="collapse" for="c-39143391">[-]</label><label class="expand" for="c-39143391">[2 more]</label></div><br/><div class="children"><div class="content">Michaelforney has also built croc [1], a qbe based C compiler. Really impressive!<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;cproc">https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;cproc</a></div><br/><div id="39147918" class="c"><input type="checkbox" id="c-39147918" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#39143029">root</a><span>|</span><a href="#39143391">parent</a><span>|</span><a href="#39150058">next</a><span>|</span><label class="collapse" for="c-39147918">[-]</label><label class="expand" for="c-39147918">[1 more]</label></div><br/><div class="children"><div class="content">Not as &quot;impressive&quot; as TCC, I&#x27;d say. Why? TCC has its own backend, and it has the preprocessor built in. (But QBE is indeed impressive.)</div><br/></div></div></div></div></div></div><div id="39150058" class="c"><input type="checkbox" id="c-39150058" checked=""/><div class="controls bullet"><span class="by">ratrocket</span><span>|</span><a href="#39143029">prev</a><span>|</span><a href="#39150413">next</a><span>|</span><label class="collapse" for="c-39150058">[-]</label><label class="expand" for="c-39150058">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a (dead) comment lamenting that you can&#x27;t access Github with javascript turned off.  The Oasis repo seems to be mirrored on sourcehut, though, so if that&#x27;s more acceptable:<p><a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~mcf&#x2F;oasis" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~mcf&#x2F;oasis</a></div><br/></div></div><div id="39150413" class="c"><input type="checkbox" id="c-39150413" checked=""/><div class="controls bullet"><span class="by">lproven</span><span>|</span><a href="#39150058">prev</a><span>|</span><a href="#39143469">next</a><span>|</span><label class="collapse" for="c-39150413">[-]</label><label class="expand" for="c-39150413">[1 more]</label></div><br/><div class="children"><div class="content">Previous discussion (Aug 2022):<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32458744">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32458744</a></div><br/></div></div><div id="39143469" class="c"><input type="checkbox" id="c-39143469" checked=""/><div class="controls bullet"><span class="by">sluongng</span><span>|</span><a href="#39150413">prev</a><span>|</span><a href="#39143224">next</a><span>|</span><label class="collapse" for="c-39143469">[-]</label><label class="expand" for="c-39143469">[37 more]</label></div><br/><div class="children"><div class="content">What is the comparison between using musl and traditional glibc?<p>Is there performance differences between the two?<p>I have been seeing musl used more and more in both Rust and Zig ecosystems lately.</div><br/><div id="39143646" class="c"><input type="checkbox" id="c-39143646" checked=""/><div class="controls bullet"><span class="by">digikata</span><span>|</span><a href="#39143469">parent</a><span>|</span><a href="#39144368">next</a><span>|</span><label class="collapse" for="c-39143646">[-]</label><label class="expand" for="c-39143646">[2 more]</label></div><br/><div class="children"><div class="content">One of the reasons I&#x27;ve switched some builds over to musl over glibc, is that I found that glibc linking is brittle if you&#x27;re going to run a binary over multiple distros in various container environments. Particularly if you want one binary to work on linux across RH and Debian&#x2F;Ubuntu derived distros or even different ages of distro.</div><br/><div id="39144532" class="c"><input type="checkbox" id="c-39144532" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143646">parent</a><span>|</span><a href="#39144368">next</a><span>|</span><label class="collapse" for="c-39144532">[-]</label><label class="expand" for="c-39144532">[1 more]</label></div><br/><div class="children"><div class="content">Linus Torvald agrees with you: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;Pzl1B7nB9Kc?feature=shared&amp;t=261" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;Pzl1B7nB9Kc?feature=shared&amp;t=261</a></div><br/></div></div></div></div><div id="39144368" class="c"><input type="checkbox" id="c-39144368" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39143469">parent</a><span>|</span><a href="#39143646">prev</a><span>|</span><a href="#39144157">next</a><span>|</span><label class="collapse" for="c-39144368">[-]</label><label class="expand" for="c-39144368">[2 more]</label></div><br/><div class="children"><div class="content">The real comparison is: musl does not provide any preprocessor macro to tell you what libc you&#x27;re using.<p>And it has <i>so</i> many weird quirks that you need to work around.<p>***<p>Static linking makes linking more painful, especially regarding global constructors (which are often needed for correctness or performance). This is not a musl-specific issue, but a lot of people are interested in both.<p>Just do your builds on the oldest supported system, and dynamic linking works just fine. You can relative-rpath your non-libc dependencies if they would be a pain to install, though think twice about libstdc++.<p>***<p>The major advantage of MUSL is that if you&#x27;re writing a new OS, it&#x27;s much easier to port.</div><br/><div id="39153492" class="c"><input type="checkbox" id="c-39153492" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144368">parent</a><span>|</span><a href="#39144157">next</a><span>|</span><label class="collapse" for="c-39153492">[-]</label><label class="expand" for="c-39153492">[1 more]</label></div><br/><div class="children"><div class="content">&gt; musl does not provide any preprocessor macro to tell you what libc you&#x27;re using.<p>&gt; And it has so many weird quirks that you need to work around.<p>I was under the impression that musl stuck closely to the standard, and glibc frequently did its own thing, so 1. it&#x27;s not <i>musl</i> that&#x27;s quirky, 2. if you need to detect something, just detect glibc.</div><br/></div></div></div></div><div id="39144157" class="c"><input type="checkbox" id="c-39144157" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39143469">parent</a><span>|</span><a href="#39144368">prev</a><span>|</span><a href="#39144012">next</a><span>|</span><label class="collapse" for="c-39144157">[-]</label><label class="expand" for="c-39144157">[4 more]</label></div><br/><div class="children"><div class="content">Speaking from heavy experimentation and experience, [0] glibc has some more optimized routines but musl has significantly less bloat. If you are haphazardly calling libc functions left and right for everything and have a generally unoptimized code base, your code may fare better better with glibc. But musl’s smaller codebase is a win for faster startup and micro optimizations otherwise - and that’s without lto where it stands to gain more.<p>[0]: <a href="https:&#x2F;&#x2F;neosmart.net&#x2F;blog&#x2F;a-high-performance-cross-platform-tac-rewrite&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neosmart.net&#x2F;blog&#x2F;a-high-performance-cross-platform-...</a><p>Edit:<p>Sorry, the correct link is this one: <a href="https:&#x2F;&#x2F;neosmart.net&#x2F;blog&#x2F;using-simd-acceleration-in-rust-to-create-the-worlds-fastest-tac&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neosmart.net&#x2F;blog&#x2F;using-simd-acceleration-in-rust-to...</a></div><br/><div id="39144210" class="c"><input type="checkbox" id="c-39144210" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144157">parent</a><span>|</span><a href="#39144012">next</a><span>|</span><label class="collapse" for="c-39144210">[-]</label><label class="expand" for="c-39144210">[3 more]</label></div><br/><div class="children"><div class="content">If you want an optimized Musl, try Cosmopolitan in `make toolchain MODE=tinylinux`, since it&#x27;s based on Musl, and its string routines go 2x faster.</div><br/><div id="39144305" class="c"><input type="checkbox" id="c-39144305" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144210">parent</a><span>|</span><a href="#39144012">next</a><span>|</span><label class="collapse" for="c-39144305">[-]</label><label class="expand" for="c-39144305">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think that was around back then but I can add it to the backlog of things to try for next round. Does that play nice with rust? Presumably I’d have to at least build the standard library from scratch (which I’d want to do against musl as a separate benchmark anyway since it’s now a single environment variable away).<p>(Not that the codebase makes much string function usage.)</div><br/><div id="39147957" class="c"><input type="checkbox" id="c-39147957" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144305">parent</a><span>|</span><a href="#39144012">next</a><span>|</span><label class="collapse" for="c-39147957">[-]</label><label class="expand" for="c-39147957">[1 more]</label></div><br/><div class="children"><div class="content">It should if everything is static and you&#x27;re only targeting Linux.</div><br/></div></div></div></div></div></div></div></div><div id="39144012" class="c"><input type="checkbox" id="c-39144012" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#39143469">parent</a><span>|</span><a href="#39144157">prev</a><span>|</span><a href="#39147547">next</a><span>|</span><label class="collapse" for="c-39144012">[-]</label><label class="expand" for="c-39144012">[5 more]</label></div><br/><div class="children"><div class="content">glibc is LGPL. Static linking your application implies some obligation on your part. Musl being MIT is less restrictive.</div><br/><div id="39145526" class="c"><input type="checkbox" id="c-39145526" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144012">parent</a><span>|</span><a href="#39144142">next</a><span>|</span><label class="collapse" for="c-39145526">[-]</label><label class="expand" for="c-39145526">[1 more]</label></div><br/><div class="children"><div class="content">Not very tough obligations, but it can be a practical hassle. This answer describes it quite well I think:<p><a href="https:&#x2F;&#x2F;opensource.stackexchange.com&#x2F;questions&#x2F;13588&#x2F;how-should-i-license-my-software-if-it-links-statically-with-glibc" rel="nofollow">https:&#x2F;&#x2F;opensource.stackexchange.com&#x2F;questions&#x2F;13588&#x2F;how-sho...</a></div><br/></div></div><div id="39144142" class="c"><input type="checkbox" id="c-39144142" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144012">parent</a><span>|</span><a href="#39145526">prev</a><span>|</span><a href="#39147547">next</a><span>|</span><label class="collapse" for="c-39144142">[-]</label><label class="expand" for="c-39144142">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Musl being MIT is less restrictive.<p>It depends who you&#x27;re speaking for</div><br/><div id="39146493" class="c"><input type="checkbox" id="c-39146493" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144142">parent</a><span>|</span><a href="#39147547">next</a><span>|</span><label class="collapse" for="c-39146493">[-]</label><label class="expand" for="c-39146493">[2 more]</label></div><br/><div class="children"><div class="content">No it doesn&#x27;t. The MIT license is objectively less restrictive than the LGPL. Whether it&#x27;s a good or bad thing to be less restrictive is a matter of opinion, but whether or not it is less restrictive is a matter of fact.</div><br/><div id="39148627" class="c"><input type="checkbox" id="c-39148627" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39146493">parent</a><span>|</span><a href="#39147547">next</a><span>|</span><label class="collapse" for="c-39148627">[-]</label><label class="expand" for="c-39148627">[1 more]</label></div><br/><div class="children"><div class="content">Lots of software licensed as MIT is distributed under a proprietary sublicense, which is as restrictive as it gets. That isn&#x27;t the case with GPL licenses.<p>It is a matter of fact that it&#x27;s a matter of perspective.</div><br/></div></div></div></div></div></div></div></div><div id="39147547" class="c"><input type="checkbox" id="c-39147547" checked=""/><div class="controls bullet"><span class="by">joveian</span><span>|</span><a href="#39143469">parent</a><span>|</span><a href="#39144012">prev</a><span>|</span><a href="#39143614">next</a><span>|</span><label class="collapse" for="c-39147547">[-]</label><label class="expand" for="c-39147547">[1 more]</label></div><br/><div class="children"><div class="content">Functional differences described here:<p><a href="https:&#x2F;&#x2F;wiki.musl-libc.org&#x2F;functional-differences-from-glibc.html" rel="nofollow">https:&#x2F;&#x2F;wiki.musl-libc.org&#x2F;functional-differences-from-glibc...</a></div><br/></div></div><div id="39143614" class="c"><input type="checkbox" id="c-39143614" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#39143469">parent</a><span>|</span><a href="#39147547">prev</a><span>|</span><a href="#39143224">next</a><span>|</span><label class="collapse" for="c-39143614">[-]</label><label class="expand" for="c-39143614">[22 more]</label></div><br/><div class="children"><div class="content">&gt;  What is the comparison between using musl and traditional glibc?<p>you get weird bugs and failures that don&#x27;t happen with glibc (like the incomplete dns resolving routines that would fail under some conditions) but you can brag about saving 30-40 mb of disk space.<p>this project seems to be compromising on quality overall, in the name of having smaller size.<p>Even BearSSL, by their own website is beta-quality: &quot;Current version is 0.6. It is now considered beta-quality software&quot; (from <a href="https:&#x2F;&#x2F;bearssl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bearssl.org&#x2F;</a>).</div><br/><div id="39143829" class="c"><input type="checkbox" id="c-39143829" checked=""/><div class="controls bullet"><span class="by">ghotli</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143614">parent</a><span>|</span><a href="#39144147">next</a><span>|</span><label class="collapse" for="c-39143829">[-]</label><label class="expand" for="c-39143829">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;musl.libc.org&#x2F;releases.html" rel="nofollow">https:&#x2F;&#x2F;musl.libc.org&#x2F;releases.html</a><p>I maintain a large codebase, widely deployed, cross compiled to many cpu architecures that&#x27;s built atop musl. You&#x27;re right that historically in the context of people blindly using alpine for their container base that sort of thing might be the case. The newest version of musl solves the thing you&#x27;re describing and in general most of the complaints about malloc perf or otherwise have been addressed. Avoiding musl to me seems like an outdated trope, but there was a time wherein that take was valid indeed.</div><br/><div id="39145374" class="c"><input type="checkbox" id="c-39145374" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143829">parent</a><span>|</span><a href="#39144147">next</a><span>|</span><label class="collapse" for="c-39145374">[-]</label><label class="expand" for="c-39145374">[1 more]</label></div><br/><div class="children"><div class="content">malloc performance is still sub-par IMO. It is not nearly as terrible as it was, but scudo, memalloc, and glibc&#x27;s malloc are better.</div><br/></div></div></div></div><div id="39144147" class="c"><input type="checkbox" id="c-39144147" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143614">parent</a><span>|</span><a href="#39143829">prev</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39144147">[-]</label><label class="expand" for="c-39144147">[13 more]</label></div><br/><div class="children"><div class="content">&gt; incomplete dns resolving routines<p>They eventually did fix this, as of musl 1.2.4.</div><br/><div id="39144439" class="c"><input type="checkbox" id="c-39144439" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144147">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39144439">[-]</label><label class="expand" for="c-39144439">[12 more]</label></div><br/><div class="children"><div class="content">While not an issue for musl-centric distros if they keep updated, note that e.g. Debian stable doesn&#x27;t have that version yet, so good luck testing.</div><br/><div id="39144695" class="c"><input type="checkbox" id="c-39144695" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144439">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39144695">[-]</label><label class="expand" for="c-39144695">[11 more]</label></div><br/><div class="children"><div class="content">At least we have light at the end of the tunnel now. This is a tremendous improvement from the previous status quo of the musl maintainers not even agreeing that it&#x27;s a problem.</div><br/><div id="39145495" class="c"><input type="checkbox" id="c-39145495" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39144695">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39145495">[-]</label><label class="expand" for="c-39145495">[10 more]</label></div><br/><div class="children"><div class="content">This alone “musl maintainers not even agreeing it’s a problem” should be a good reason to avoid musl imho</div><br/><div id="39145519" class="c"><input type="checkbox" id="c-39145519" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39145495">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39145519">[-]</label><label class="expand" for="c-39145519">[9 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a better option for static linking? glibc is religiously against it; they have far worse dogmatic beliefs than this musl DNS thing. I&#x27;d be happy to choose a better alternative if one exists, but if one does not, I have to live with the options at hand. From where I&#x27;m standing, musl seems like the only game in town. uClibc doesn&#x27;t seem like it&#x27;s appropriate for general purpose Linux applications on desktop computers (maybe I&#x27;m wrong?).</div><br/><div id="39151312" class="c"><input type="checkbox" id="c-39151312" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39145519">parent</a><span>|</span><a href="#39146125">next</a><span>|</span><label class="collapse" for="c-39151312">[-]</label><label class="expand" for="c-39151312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; glibc is religiously against it<p>from my understanding glibc is not &quot;religiously&quot; against it, they&#x27;re against it for technical reasons. In the sense, this is not a dogma. It&#x27;s about internal details of their implementations.<p>See: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;57476533&#x2F;why-is-statically-linking-glibc-discouraged" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;57476533&#x2F;why-is-statical...</a></div><br/></div></div><div id="39146125" class="c"><input type="checkbox" id="c-39146125" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39145519">parent</a><span>|</span><a href="#39151312">prev</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39146125">[-]</label><label class="expand" for="c-39146125">[7 more]</label></div><br/><div class="children"><div class="content">Static linking doesn&#x27;t actually solve any problem. Just use dynamic linking with (probably relative) rpath, and compile against a sufficiently old libc.<p>There&#x27;s some common FUD about rpath being insecure, but that only applies if the binary is setuid (or otherwise privileged) <i>and</i> the rpath is writable by someone other than the binary&#x27;s owner (all relative rpaths are writable since you can use symlinks; absolute rpaths are writable if they point to &#x2F;tmp&#x2F; or a similar directory, which used to be common on buildbots).<p>This is really not hard; working around all static linking&#x27;s quirks is harder.</div><br/><div id="39147083" class="c"><input type="checkbox" id="c-39147083" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39146125">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39147083">[-]</label><label class="expand" for="c-39147083">[6 more]</label></div><br/><div class="children"><div class="content">What are the quirks of static linking you need to work around (in general, not for glibc)?</div><br/><div id="39147461" class="c"><input type="checkbox" id="c-39147461" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39147083">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39147461">[-]</label><label class="expand" for="c-39147461">[5 more]</label></div><br/><div class="children"><div class="content">You have to know the internals of your dependencies so you can link them explicitly, recursively. (admittedly, pkg-config helps a ton, but not all libraries ship (good) .pc files)<p>Global constructors no longer reliably fire unless you are <i>extremely</i> careful with your build system, nor do they run in a predictable order (e.g. you can call a library before it is actually initialized, unlike dynamic linking where only preinit - which nobody uses - is weird), nor can you defer them until dlopen time if you want (which is, admittedly, overdone).<p>It&#x27;s possible to link to <i>parts</i> of multiple versions of a library (remember, you have to recurse into your dependencies), as opposed to dynamic libraries where at least you&#x27;re guaranteed all-or-nothing (which is much easier to detect).<p>Linking is slower since it always has to be redone from scratch.<p>Not resilent against system changes. For example, old versions of `bash-static` (grab them from e.g. Debian snapshot and extract them manually; don&#x27;t install them) are no longer runnable on modern systems since certain system files have changed formats, whereas the dynamically-linked `bash` packages still run just fine.<p>It also encourages bad stability habits, leading to the equivalent of NPM hell, which is far worse than DLL hell ever was.<p>You can&#x27;t use LD_PRELOAD or other dynamic interception tools.<p>There are probably more reasons to avoid static linking, but I&#x27;m trying to ignore the handful from the popular lists.</div><br/><div id="39149962" class="c"><input type="checkbox" id="c-39149962" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39147461">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39149962">[-]</label><label class="expand" for="c-39149962">[4 more]</label></div><br/><div class="children"><div class="content">Thanks! Most of those seem like a fair trade-off for portability… for an app.<p>I’m not sure it’s a great idea for an OS as in the OP, but I do like that they claim accurate incremental rebuilds, to ensure everything get updated. Certainly an interesting experiment!<p>Edit: just to clarify, I meant &quot;app&quot; as in &quot;something that isn&#x27;t part of the OS&#x2F;distribution&quot;.</div><br/><div id="39150817" class="c"><input type="checkbox" id="c-39150817" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39149962">parent</a><span>|</span><a href="#39143675">next</a><span>|</span><label class="collapse" for="c-39150817">[-]</label><label class="expand" for="c-39150817">[3 more]</label></div><br/><div class="children"><div class="content">The bash-static example alone is proof that the &quot;usefulness&quot; for apps isn&#x27;t actually there.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39143857" class="c"><input type="checkbox" id="c-39143857" checked=""/><div class="controls bullet"><span class="by">raesene9</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143614">parent</a><span>|</span><a href="#39143675">prev</a><span>|</span><a href="#39145026">next</a><span>|</span><label class="collapse" for="c-39143857">[-]</label><label class="expand" for="c-39143857">[4 more]</label></div><br/><div class="children"><div class="content">A small point on that last bit. The bearssl authors are pretty conservative when it comes to development milestones, I&#x27;d guess that their 0.6 would be pretty solid :)</div><br/><div id="39143966" class="c"><input type="checkbox" id="c-39143966" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143857">parent</a><span>|</span><a href="#39145026">next</a><span>|</span><label class="collapse" for="c-39143966">[-]</label><label class="expand" for="c-39143966">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d guess that their 0.6 would be pretty solid :)<p>Would you accept that kind of reasoning for software running on your pacemaker, or on your insuline pump?<p>I think we should respect the developers here: they&#x27;re not claiming production quality level (they&#x27;re claiming beta-quality level) so it&#x27;s not correct to use that library in any kind of product and claim any kind of production-level quality.</div><br/><div id="39144180" class="c"><input type="checkbox" id="c-39144180" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143966">parent</a><span>|</span><a href="#39144359">next</a><span>|</span><label class="collapse" for="c-39144180">[-]</label><label class="expand" for="c-39144180">[1 more]</label></div><br/><div class="children"><div class="content">I would run away from using glibc on an insulin pump or pacemaker, so I’m not sure what point you’re trying to make.</div><br/></div></div><div id="39144359" class="c"><input type="checkbox" id="c-39144359" checked=""/><div class="controls bullet"><span class="by">foul</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143966">parent</a><span>|</span><a href="#39144180">prev</a><span>|</span><a href="#39145026">next</a><span>|</span><label class="collapse" for="c-39144359">[-]</label><label class="expand" for="c-39144359">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Would you accept that kind of reasoning for software running on your pacemaker, or on your insuline pump?<p>God helps me I wouldn&#x27;t implant anything so fundamental in my body with hard dependencies on encrypted communication to a remote agent elsewhere, no matter the advantage.</div><br/></div></div></div></div></div></div><div id="39145026" class="c"><input type="checkbox" id="c-39145026" checked=""/><div class="controls bullet"><span class="by">fullspectrumdev</span><span>|</span><a href="#39143469">root</a><span>|</span><a href="#39143614">parent</a><span>|</span><a href="#39143857">prev</a><span>|</span><a href="#39143224">next</a><span>|</span><label class="collapse" for="c-39145026">[-]</label><label class="expand" for="c-39145026">[1 more]</label></div><br/><div class="children"><div class="content">30-40mb of disk space is absolutely huge in some environments even today though</div><br/></div></div></div></div></div></div><div id="39143224" class="c"><input type="checkbox" id="c-39143224" checked=""/><div class="controls bullet"><span class="by">eterps</span><span>|</span><a href="#39143469">prev</a><span>|</span><a href="#39143449">next</a><span>|</span><label class="collapse" for="c-39143224">[-]</label><label class="expand" for="c-39143224">[1 more]</label></div><br/><div class="children"><div class="content">Interesting choices, finally something that isn&#x27;t just another Linux distribution.</div><br/></div></div><div id="39143449" class="c"><input type="checkbox" id="c-39143449" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#39143224">prev</a><span>|</span><a href="#39145699">next</a><span>|</span><label class="collapse" for="c-39143449">[-]</label><label class="expand" for="c-39143449">[20 more]</label></div><br/><div class="children"><div class="content">Can someone explain a couple use cases for something like this?</div><br/><div id="39143571" class="c"><input type="checkbox" id="c-39143571" checked=""/><div class="controls bullet"><span class="by">ghotli</span><span>|</span><a href="#39143449">parent</a><span>|</span><a href="#39144729">next</a><span>|</span><label class="collapse" for="c-39143571">[-]</label><label class="expand" for="c-39143571">[8 more]</label></div><br/><div class="children"><div class="content">I routinely get embedded linux devices at $dayjob that need my time and attention and they basically never have the tooling I need to get my job done. I&#x27;m a pro at looking at how Alpine builds a tool and then just making my own statically linked &#x2F; minimal size tool to drop in place on the device. The allure of something like this is that I can just potentially grab a drop-in binary and get on with my day. I simply don&#x27;t attempt to link to libraries already on the device since they&#x27;re all built in wildly different ways, old tools, old compilers.<p>Hopefully that&#x27;s helpful context. Overall since I did linux from scratch half a lifetime ago I&#x27;ve always wondered why something like Oasis hasn&#x27;t gotten more traction. It&#x27;s got some ambitious ideas in the README so maybe others have other nice use-cases atop all that. I just see small, statically linked and think &#x27;oh boy if i never have to build my own tools again for some weird board&#x27;. If so, I&#x27;m here for it.</div><br/><div id="39143746" class="c"><input type="checkbox" id="c-39143746" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39143571">parent</a><span>|</span><a href="#39152693">next</a><span>|</span><label class="collapse" for="c-39143746">[-]</label><label class="expand" for="c-39143746">[6 more]</label></div><br/><div class="children"><div class="content">&gt; grab a drop-in binary<p>This is a cool approach on Docker as well.<p><pre><code>    FROM some:thing AS bins
    FROM debian:latest
    COPY --from=bins &#x2F;bin&#x2F;foo &#x2F;bin&#x2F;</code></pre></div><br/><div id="39143859" class="c"><input type="checkbox" id="c-39143859" checked=""/><div class="controls bullet"><span class="by">ghotli</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39143746">parent</a><span>|</span><a href="#39152693">next</a><span>|</span><label class="collapse" for="c-39143859">[-]</label><label class="expand" for="c-39143859">[5 more]</label></div><br/><div class="children"><div class="content">Agreed, if the binary is statically linked. If you run `file` on the output from that and it shows &#x27;dynamically linked&#x27; then you&#x27;re playing games with porting over libraries, changing the library loading path, or just going full chroot like linux from scratch does with the bootstrapping part of the install. I find static binaries simplest to work with in that context but agreed I use that pattern too with docker and generally build ad-hoc tools within containers like that. If only these devices could run docker but I&#x27;m left to my own tooling to figure out per device.</div><br/><div id="39144169" class="c"><input type="checkbox" id="c-39144169" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39143859">parent</a><span>|</span><a href="#39144133">next</a><span>|</span><label class="collapse" for="c-39144169">[-]</label><label class="expand" for="c-39144169">[3 more]</label></div><br/><div class="children"><div class="content">In a way, that&#x27;s what Nix sets out to do, isolating even dynamically linked libraries: if two derivations depend on the same shared lib derivation then it&#x27;s reused, if not then they don&#x27;t conflict. Each leaf derivation can be handled completely independently of the others, and independently of the original system†.<p>And then when Nix† is not an option at runtime, dockerTools†† can build a Docker image to do the minimisation+isolation.<p>That said, Nix might also be completely overkill in some scenarios where static linking would be just fine and very practical. The practical simplicity of a single binary should not be overlooked.<p>† nixpkgs is sufficient, a full nixos is not needed<p>†† <a href="https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nixpkgs&#x2F;stable&#x2F;#sec-pkgs-dockerTools" rel="nofollow">https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nixpkgs&#x2F;stable&#x2F;#sec-pkgs-dockerTool...</a></div><br/><div id="39145771" class="c"><input type="checkbox" id="c-39145771" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39144169">parent</a><span>|</span><a href="#39144133">next</a><span>|</span><label class="collapse" for="c-39145771">[-]</label><label class="expand" for="c-39145771">[2 more]</label></div><br/><div class="children"><div class="content">So Nix keeps track of different versions of shared libraries?</div><br/><div id="39146627" class="c"><input type="checkbox" id="c-39146627" checked=""/><div class="controls bullet"><span class="by">sporeray</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39145771">parent</a><span>|</span><a href="#39144133">next</a><span>|</span><label class="collapse" for="c-39146627">[-]</label><label class="expand" for="c-39146627">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, each package&#x2F;lib is stored in a unified directory by it&#x27;s hash <a href="https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;nix-store" rel="nofollow">https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;nix-store</a>. Different variation different hash.</div><br/></div></div></div></div></div></div><div id="39144133" class="c"><input type="checkbox" id="c-39144133" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39143859">parent</a><span>|</span><a href="#39144169">prev</a><span>|</span><a href="#39152693">next</a><span>|</span><label class="collapse" for="c-39144133">[-]</label><label class="expand" for="c-39144133">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, dynamically linked binaries don&#x27;t drop in well.</div><br/></div></div></div></div></div></div><div id="39152693" class="c"><input type="checkbox" id="c-39152693" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39143571">parent</a><span>|</span><a href="#39143746">prev</a><span>|</span><a href="#39144729">next</a><span>|</span><label class="collapse" for="c-39152693">[-]</label><label class="expand" for="c-39152693">[1 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t understand.<p>Is oasis the &quot;drop in binary&quot; you would use? Or do you use oasis to build the tool that you would use?<p>&quot;The allure of something like this is I could potentially grab a drop in binary&quot;<p>From where?</div><br/></div></div></div></div><div id="39144729" class="c"><input type="checkbox" id="c-39144729" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39143449">parent</a><span>|</span><a href="#39143571">prev</a><span>|</span><a href="#39144020">next</a><span>|</span><label class="collapse" for="c-39144729">[-]</label><label class="expand" for="c-39144729">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Can someone explain a couple use cases for something like this?<p>At this point, it would be more useful if someone explained a couple of use cases for dynamic linking.</div><br/><div id="39145955" class="c"><input type="checkbox" id="c-39145955" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39144729">parent</a><span>|</span><a href="#39144020">next</a><span>|</span><label class="collapse" for="c-39145955">[-]</label><label class="expand" for="c-39145955">[5 more]</label></div><br/><div class="children"><div class="content">Plugins, unless you want to have one process per plugin.<p>Which in the days of running Kubernetes clusters on laptops maybe isn&#x27;t a big deal.</div><br/><div id="39146563" class="c"><input type="checkbox" id="c-39146563" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39145955">parent</a><span>|</span><a href="#39144020">next</a><span>|</span><label class="collapse" for="c-39146563">[-]</label><label class="expand" for="c-39146563">[4 more]</label></div><br/><div class="children"><div class="content">You can still call dlopen from your static binary, if you really want to.</div><br/><div id="39148036" class="c"><input type="checkbox" id="c-39148036" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39146563">parent</a><span>|</span><a href="#39147521">next</a><span>|</span><label class="collapse" for="c-39148036">[-]</label><label class="expand" for="c-39148036">[2 more]</label></div><br/><div class="children"><div class="content">I tried to do this recently at $DAYJOB, but when you statically link a binary with musl, the dlopen() you get is a no-op:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bpowers&#x2F;musl&#x2F;blob&#x2F;master&#x2F;src&#x2F;ldso&#x2F;dlopen.c">https:&#x2F;&#x2F;github.com&#x2F;bpowers&#x2F;musl&#x2F;blob&#x2F;master&#x2F;src&#x2F;ldso&#x2F;dlopen....</a><p>I tried to hack in a copy of the musl&#x27;s dynamic loader (and also from old uclibc). But it took a few hours and my only result was segfaults.<p>Do you have any pointers on making this work?</div><br/><div id="39150204" class="c"><input type="checkbox" id="c-39150204" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39148036">parent</a><span>|</span><a href="#39147521">next</a><span>|</span><label class="collapse" for="c-39150204">[-]</label><label class="expand" for="c-39150204">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried it with glibc?  It&#x27;s harder to build static binaries with it, but it&#x27;s still possible, and it may work.<p>To debug your problem, do you have a minimal example at your fingertips to try?  Just a &quot;hello world&quot; dynlib that is called from a static program that doesn&#x27;t do anything else.</div><br/></div></div></div></div><div id="39147521" class="c"><input type="checkbox" id="c-39147521" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39146563">parent</a><span>|</span><a href="#39148036">prev</a><span>|</span><a href="#39144020">next</a><span>|</span><label class="collapse" for="c-39147521">[-]</label><label class="expand" for="c-39147521">[1 more]</label></div><br/><div class="children"><div class="content">Sure lets go back to 1980&#x27;s UNIX, it was such a great experience.</div><br/></div></div></div></div></div></div></div></div><div id="39144020" class="c"><input type="checkbox" id="c-39144020" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39143449">parent</a><span>|</span><a href="#39144729">prev</a><span>|</span><a href="#39143528">next</a><span>|</span><label class="collapse" for="c-39144020">[-]</label><label class="expand" for="c-39144020">[4 more]</label></div><br/><div class="children"><div class="content">You miss UNIX developer experience until mid-1980&#x27;s, before shared objects came to be.</div><br/><div id="39147497" class="c"><input type="checkbox" id="c-39147497" checked=""/><div class="controls bullet"><span class="by">mech422</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39144020">parent</a><span>|</span><a href="#39143528">next</a><span>|</span><label class="collapse" for="c-39147497">[-]</label><label class="expand" for="c-39147497">[3 more]</label></div><br/><div class="children"><div class="content">Heh...rebuilding gcc on slackware to enable shared libs was an adventure - but that wasn&#x27;t till the late 90s(??).  I think I spent like a week bootstrapping the new gcc, rebuilding glibc and rebuilding all the stuff I used.</div><br/><div id="39147673" class="c"><input type="checkbox" id="c-39147673" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39147497">parent</a><span>|</span><a href="#39143528">next</a><span>|</span><label class="collapse" for="c-39147673">[-]</label><label class="expand" for="c-39147673">[2 more]</label></div><br/><div class="children"><div class="content">UNIX System V 4.0 was the one that kind of uniformized existing parallel solutions from UNIX variants, alongside ELF in the late 1980&#x27;s.</div><br/><div id="39152610" class="c"><input type="checkbox" id="c-39152610" checked=""/><div class="controls bullet"><span class="by">mech422</span><span>|</span><a href="#39143449">root</a><span>|</span><a href="#39147673">parent</a><span>|</span><a href="#39143528">next</a><span>|</span><label class="collapse" for="c-39152610">[-]</label><label class="expand" for="c-39152610">[1 more]</label></div><br/><div class="children"><div class="content">yeah - I never had access to a &#x27;real&#x27; unix. Closest I came was solaris and maybe Irix. Other then that, it&#x27;s just been Linux.  Keep meaning to give *BSD a try...<p>P.S. - oh! and I had friends that loved HP&#x2F;UX - another one I never got to try</div><br/></div></div></div></div></div></div></div></div><div id="39143528" class="c"><input type="checkbox" id="c-39143528" checked=""/><div class="controls bullet"><span class="by">ekianjo</span><span>|</span><a href="#39143449">parent</a><span>|</span><a href="#39144020">prev</a><span>|</span><a href="#39145699">next</a><span>|</span><label class="collapse" for="c-39143528">[-]</label><label class="expand" for="c-39143528">[1 more]</label></div><br/><div class="children"><div class="content">immutable images</div><br/></div></div></div></div><div id="39145699" class="c"><input type="checkbox" id="c-39145699" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#39143449">prev</a><span>|</span><a href="#39143517">next</a><span>|</span><label class="collapse" for="c-39145699">[-]</label><label class="expand" for="c-39145699">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Fast builds that are 100% reproducible.<p>It&#x27;s unclear to me what &quot;100%&quot; refers to here, but surely it does not include the Linux kernel or drivers? (I&#x27;ve recently read conversations about how difficult this would be.)</div><br/><div id="39145882" class="c"><input type="checkbox" id="c-39145882" checked=""/><div class="controls bullet"><span class="by">azornathogron</span><span>|</span><a href="#39145699">parent</a><span>|</span><a href="#39145803">next</a><span>|</span><label class="collapse" for="c-39145882">[-]</label><label class="expand" for="c-39145882">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no expert, but as an interested amateur I thought the Linux kernel could already be built reproducibly?<p>There is some documentation at least... and I know several Linux distributions have been working on reproducible builds for a long time now - I&#x27;d be surprised if there hasn&#x27;t been good progress on this.<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;kbuild&#x2F;reproducible-builds.html" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;kbuild&#x2F;reproducible-b...</a></div><br/><div id="39148430" class="c"><input type="checkbox" id="c-39148430" checked=""/><div class="controls bullet"><span class="by">dayjaby</span><span>|</span><a href="#39145699">root</a><span>|</span><a href="#39145882">parent</a><span>|</span><a href="#39145803">next</a><span>|</span><label class="collapse" for="c-39148430">[-]</label><label class="expand" for="c-39148430">[1 more]</label></div><br/><div class="children"><div class="content">In container context I&#x27;ve heard a definition of &quot;100% reproducible&quot; that means even file timestamps are 100% the same. Like your entire build is bit-by-bit precisely the same if you didn&#x27;t modify any source.<p>Not sure if that&#x27;s what they mean here.</div><br/></div></div></div></div><div id="39145803" class="c"><input type="checkbox" id="c-39145803" checked=""/><div class="controls bullet"><span class="by">hn_go_brrrrr</span><span>|</span><a href="#39145699">parent</a><span>|</span><a href="#39145882">prev</a><span>|</span><a href="#39143517">next</a><span>|</span><label class="collapse" for="c-39145803">[-]</label><label class="expand" for="c-39145803">[2 more]</label></div><br/><div class="children"><div class="content">Got a link? Sounds interesting.</div><br/><div id="39151711" class="c"><input type="checkbox" id="c-39151711" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#39145699">root</a><span>|</span><a href="#39145803">parent</a><span>|</span><a href="#39143517">next</a><span>|</span><label class="collapse" for="c-39151711">[-]</label><label class="expand" for="c-39151711">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a link to a recent HN discussion:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38852616">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38852616</a><p>TLDR: Linux kernel doesn&#x27;t have a stable binary kernel interface. And they don&#x27;t want one.<p>Given this, the definition of &quot;reproducible build&quot; needs, well, a refined definition, if it includes the Linux kernel.<p>[1] <a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;process&#x2F;stable-api-nonsense.rst" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;process&#x2F;stable-api-...</a></div><br/></div></div></div></div></div></div><div id="39143517" class="c"><input type="checkbox" id="c-39143517" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#39145699">prev</a><span>|</span><a href="#39149301">next</a><span>|</span><label class="collapse" for="c-39143517">[-]</label><label class="expand" for="c-39143517">[4 more]</label></div><br/><div class="children"><div class="content">There’s also the “suckless” sta.li</div><br/><div id="39144806" class="c"><input type="checkbox" id="c-39144806" checked=""/><div class="controls bullet"><span class="by">ratrocket</span><span>|</span><a href="#39143517">parent</a><span>|</span><a href="#39149301">next</a><span>|</span><label class="collapse" for="c-39144806">[-]</label><label class="expand" for="c-39144806">[3 more]</label></div><br/><div class="children"><div class="content">A comment up-thread (currently) says&#x2F;implies Oasis is a successor to sta.li by the same person.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39143029">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39143029</a><p>I also thought sta.li when I saw this was about a statically linked linux system...</div><br/><div id="39148531" class="c"><input type="checkbox" id="c-39148531" checked=""/><div class="controls bullet"><span class="by">lubutu</span><span>|</span><a href="#39143517">root</a><span>|</span><a href="#39144806">parent</a><span>|</span><a href="#39149301">next</a><span>|</span><label class="collapse" for="c-39148531">[-]</label><label class="expand" for="c-39148531">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not by the same person — sta.li was by Anselm R Garbe. It&#x27;s more like a spiritual successor.</div><br/><div id="39150032" class="c"><input type="checkbox" id="c-39150032" checked=""/><div class="controls bullet"><span class="by">ratrocket</span><span>|</span><a href="#39143517">root</a><span>|</span><a href="#39148531">parent</a><span>|</span><a href="#39149301">next</a><span>|</span><label class="collapse" for="c-39150032">[-]</label><label class="expand" for="c-39150032">[1 more]</label></div><br/><div class="children"><div class="content">Ah, thank you for the clarification.  I read the linked to (by me) comment too quickly and&#x2F;or without thinking enough!  Cheers!</div><br/></div></div></div></div></div></div></div></div><div id="39149301" class="c"><input type="checkbox" id="c-39149301" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#39143517">prev</a><span>|</span><a href="#39146097">next</a><span>|</span><label class="collapse" for="c-39149301">[-]</label><label class="expand" for="c-39149301">[1 more]</label></div><br/><div class="children"><div class="content">How big is it?<p>I could imagine there were unexpected efficiencies.  Although dynamic libraries should be able to share an address space, I think with static libraries, the linked might strip out unused routines.<p>also, it might be faster</div><br/></div></div><div id="39146097" class="c"><input type="checkbox" id="c-39146097" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#39149301">prev</a><span>|</span><a href="#39148140">next</a><span>|</span><label class="collapse" for="c-39146097">[-]</label><label class="expand" for="c-39146097">[2 more]</label></div><br/><div class="children"><div class="content">BearSSL development’s seems to have stopped and it’s lacking TLS1.3. Are there promising alternatives?</div><br/><div id="39146436" class="c"><input type="checkbox" id="c-39146436" checked=""/><div class="controls bullet"><span class="by">asmvolatile</span><span>|</span><a href="#39146097">parent</a><span>|</span><a href="#39148140">next</a><span>|</span><label class="collapse" for="c-39146436">[-]</label><label class="expand" for="c-39146436">[1 more]</label></div><br/><div class="children"><div class="content">wolfSSL. Open source, widely used, flexible licensing model, TLS + DTLS 1.3 support, support for all modern ciphers and protocol extensions, extremely tuneable for performance&#x2F;size, FIPS module, excellent customer support, the list goes on....</div><br/></div></div></div></div><div id="39148140" class="c"><input type="checkbox" id="c-39148140" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#39146097">prev</a><span>|</span><a href="#39152913">next</a><span>|</span><label class="collapse" for="c-39148140">[-]</label><label class="expand" for="c-39148140">[4 more]</label></div><br/><div class="children"><div class="content">For a real statically-linked linux system, the main issue is GPU support: you must relink all apps _really using_ a GPU, that to include the required GPU drivers.<p>With sound, alsa, it is fine since there is IPC&#x2F;shared-memory based mixing that whatever the playback&#x2F;capture devices [dmix&#x2F;dsnoop]. Static linking is reasonable. (pulseaudio[012] IPC interfaces are bloaty kludges, hardly stable in time, 0..1..2.., not to be trusted compared to the hardcore stability of alsa one able to do a beyond good enough job *and* _real_ in-process low latency hardware access at the same time).<p>x11 and wayland are IPC based, then no issue here neither.<p>But for the GPU, we would need a wayland vulkan3D-inspired set of IPC&#x2F;shared-memory interfaces (with a 3D enabled wayland compositor). For compute, the interfaces would be de-coupled from the wayland compositor (shared dma-buffers).<p>The good part of this would be to free our system interfaces from the ultra complex ELF (one could choose an excrutiatingly simple executable file format, aka a modern executable file format, but will need compilers&#x2F;linkers support to help legacy support).<p>There is a middle ground though: everything statically linked, except the apps requiring the GPU driver (for that ELF is grotesquely overkill), still provided as a shared library.</div><br/><div id="39148907" class="c"><input type="checkbox" id="c-39148907" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#39148140">parent</a><span>|</span><a href="#39148463">next</a><span>|</span><label class="collapse" for="c-39148907">[-]</label><label class="expand" for="c-39148907">[1 more]</label></div><br/><div class="children"><div class="content">I ponder which kind of malaise would push one to dismiss ELF as &quot;ultra complex&quot; and at the same time propose pervasive IPC through the entire system including Vulkan calls through IPC.</div><br/></div></div><div id="39148463" class="c"><input type="checkbox" id="c-39148463" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#39148140">parent</a><span>|</span><a href="#39148907">prev</a><span>|</span><a href="#39152913">next</a><span>|</span><label class="collapse" for="c-39148463">[-]</label><label class="expand" for="c-39148463">[2 more]</label></div><br/><div class="children"><div class="content">To be fair ELF is complex mostly because of relocations, which are not purely to support shared libraries but also the nowadays ubiquitous PIE. But GPU drivers is a good point; I don&#x27;t believe you can even statically link them today, you would only be statically linking a shim that tries to find the real driver at runtime.</div><br/><div id="39148911" class="c"><input type="checkbox" id="c-39148911" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#39148140">root</a><span>|</span><a href="#39148463">parent</a><span>|</span><a href="#39152913">next</a><span>|</span><label class="collapse" for="c-39148911">[-]</label><label class="expand" for="c-39148911">[1 more]</label></div><br/><div class="children"><div class="content">I am exploring an executable file format of my own (excrutiatingly simple, basically userland syscalls) which is only PIE, and until now, the main real &quot;issue&quot; (not really) is actually the lack of support from compilers for static relative global data init (handled by ELF... which is not there anymore).<p>About the shared libs, well, they are the utility shared libs, and the system interface shared libs. With a mostly statically linked elf&#x2F;linux distro, all the utility libs would be statically linked, and the system interface shared libs would be statically linked if they have an IPC&#x2F;shared-mem interface. In the end, only the GPU driver is an issue, namely would stay a shared libs.</div><br/></div></div></div></div></div></div><div id="39152913" class="c"><input type="checkbox" id="c-39152913" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#39148140">prev</a><span>|</span><a href="#39144095">next</a><span>|</span><label class="collapse" for="c-39152913">[-]</label><label class="expand" for="c-39152913">[1 more]</label></div><br/><div class="children"><div class="content">Somehow this reminds me of Gentoo.</div><br/></div></div><div id="39144095" class="c"><input type="checkbox" id="c-39144095" checked=""/><div class="controls bullet"><span class="by">lordwiz</span><span>|</span><a href="#39152913">prev</a><span>|</span><a href="#39148669">next</a><span>|</span><label class="collapse" for="c-39144095">[-]</label><label class="expand" for="c-39144095">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, Like how its focused on making it lean by having less bloated versions of the tools</div><br/></div></div><div id="39143133" class="c"><input type="checkbox" id="c-39143133" checked=""/><div class="controls bullet"><span class="by">hkt</span><span>|</span><a href="#39148669">prev</a><span>|</span><a href="#39149389">next</a><span>|</span><label class="collapse" for="c-39143133">[-]</label><label class="expand" for="c-39143133">[1 more]</label></div><br/><div class="children"><div class="content">This is very very cool. I love the bloat free nature of the thing, especially velox (the WM). Samurai (build system) also looks pretty interesting. I&#x27;ve not managed to work out quite how samurai works, or truthfully, why it differs from ninja, but this project is exactly the kind of brain food I intend on learning a lot from.<p>Many, many props to Michael Forney.</div><br/></div></div><div id="39149389" class="c"><input type="checkbox" id="c-39149389" checked=""/><div class="controls bullet"><span class="by">alexnewman</span><span>|</span><a href="#39143133">prev</a><span>|</span><a href="#39144036">next</a><span>|</span><label class="collapse" for="c-39149389">[-]</label><label class="expand" for="c-39149389">[1 more]</label></div><br/><div class="children"><div class="content">Now I just need them to switch to GitHub actions for the ci&#x2F;cd</div><br/></div></div><div id="39144036" class="c"><input type="checkbox" id="c-39144036" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#39149389">prev</a><span>|</span><a href="#39147929">next</a><span>|</span><label class="collapse" for="c-39144036">[-]</label><label class="expand" for="c-39144036">[1 more]</label></div><br/><div class="children"><div class="content">Anyone have a link to the QEMU tarball in the README? It is hosted on a private server and it looks like it&#x27;s been HN hugged</div><br/></div></div><div id="39147929" class="c"><input type="checkbox" id="c-39147929" checked=""/><div class="controls bullet"><span class="by">jollyllama</span><span>|</span><a href="#39144036">prev</a><span>|</span><a href="#39143880">next</a><span>|</span><label class="collapse" for="c-39147929">[-]</label><label class="expand" for="c-39147929">[3 more]</label></div><br/><div class="children"><div class="content">Anyway, here&#x27;s wonder -Wall</div><br/><div id="39148291" class="c"><input type="checkbox" id="c-39148291" checked=""/><div class="controls bullet"><span class="by">notnmeyer</span><span>|</span><a href="#39147929">parent</a><span>|</span><a href="#39149874">next</a><span>|</span><label class="collapse" for="c-39148291">[-]</label><label class="expand" for="c-39148291">[1 more]</label></div><br/><div class="children"><div class="content">this is funnier than it has any right to be</div><br/></div></div></div></div><div id="39143880" class="c"><input type="checkbox" id="c-39143880" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#39147929">prev</a><span>|</span><a href="#39145789">next</a><span>|</span><label class="collapse" for="c-39143880">[-]</label><label class="expand" for="c-39143880">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve added links to the below quote:<p>&gt;&quot;oasis uses <i>smaller and simpler</i> implementations of libraries and tools whenever possible:<p>musl instead of glibc (<a href="https:&#x2F;&#x2F;www.musl-libc.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.musl-libc.org&#x2F;</a>)<p>sbase instead of coreutils (<a href="https:&#x2F;&#x2F;git.suckless.org&#x2F;sbase&#x2F;file&#x2F;README.html" rel="nofollow">https:&#x2F;&#x2F;git.suckless.org&#x2F;sbase&#x2F;file&#x2F;README.html</a>)<p>ubase instead of util-linux (<a href="https:&#x2F;&#x2F;git.suckless.org&#x2F;ubase&#x2F;file&#x2F;README.html" rel="nofollow">https:&#x2F;&#x2F;git.suckless.org&#x2F;ubase&#x2F;file&#x2F;README.html</a>)<p>pigz instead of gzip (<a href="https:&#x2F;&#x2F;zlib.net&#x2F;pigz&#x2F;" rel="nofollow">https:&#x2F;&#x2F;zlib.net&#x2F;pigz&#x2F;</a>)<p>mandoc instead of man-db (<a href="https:&#x2F;&#x2F;mandoc.bsd.lv&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mandoc.bsd.lv&#x2F;</a>)<p>bearssl instead of openssl (<a href="https:&#x2F;&#x2F;bearssl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bearssl.org&#x2F;</a>)<p>oksh instead of bash (<a href="https:&#x2F;&#x2F;github.com&#x2F;ibara&#x2F;oksh">https:&#x2F;&#x2F;github.com&#x2F;ibara&#x2F;oksh</a>)<p>sdhcp instead of dhclient or dhcpcd (<a href="https:&#x2F;&#x2F;core.suckless.org&#x2F;sdhcp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;core.suckless.org&#x2F;sdhcp&#x2F;</a>)<p>vis instead of vim or emacs (<a href="https:&#x2F;&#x2F;github.com&#x2F;martanne&#x2F;vis">https:&#x2F;&#x2F;github.com&#x2F;martanne&#x2F;vis</a>)<p>byacc instead of bison (<a href="https:&#x2F;&#x2F;invisible-island.net&#x2F;byacc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;invisible-island.net&#x2F;byacc&#x2F;</a>)<p>perp and sinit instead of sysvinit or system 44 (<a href="http:&#x2F;&#x2F;b0llix.net&#x2F;perp&#x2F;" rel="nofollow">http:&#x2F;&#x2F;b0llix.net&#x2F;perp&#x2F;</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;wereHamster&#x2F;perp">https:&#x2F;&#x2F;github.com&#x2F;wereHamster&#x2F;perp</a> <a href="https:&#x2F;&#x2F;troubleshooters.com&#x2F;linux&#x2F;diy&#x2F;suckless_init_on_plop.htm" rel="nofollow">https:&#x2F;&#x2F;troubleshooters.com&#x2F;linux&#x2F;diy&#x2F;suckless_init_on_plop....</a>)<p>netsurf instead of chromium or firefox (<a href="https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.netsurf-browser.org&#x2F;</a>)<p>samurai instead of ninja (<a href="https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;samurai">https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;samurai</a>)<p>velox instead of Xorg (<a href="https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;velox">https:&#x2F;&#x2F;github.com&#x2F;michaelforney&#x2F;velox</a>)<p>netbsd-curses instead of ncurses (<a href="https:&#x2F;&#x2F;github.com&#x2F;sabotage-linux&#x2F;netbsd-curses">https:&#x2F;&#x2F;github.com&#x2F;sabotage-linux&#x2F;netbsd-curses</a>)&quot;<p>(Oh, and not to quote Dwayne &quot;The Rock&quot; Johnson&#x27;s character &quot;Maui&quot; from Disney&#x27;s Moana or anything -- but <i>&quot;You&#x27;re welcome!&quot;</i> &lt;g&gt; :-) &lt;g&gt;)</div><br/></div></div></div></div></div></div></div></body></html>