<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719306050237" as="style"/><link rel="stylesheet" href="styles.css?v=1719306050237"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://holtwick.de/en/blog/localfirst-resilient-sync">Resilient Sync for Local First</a> <span class="domain">(<a href="https://holtwick.de">holtwick.de</a>)</span></div><div class="subtext"><span>ingve</span> | <span>12 comments</span></div><br/><div><div id="40785258" class="c"><input type="checkbox" id="c-40785258" checked=""/><div class="controls bullet"><span class="by">ergl</span><span>|</span><a href="#40784693">next</a><span>|</span><label class="collapse" for="c-40785258">[-]</label><label class="expand" for="c-40785258">[2 more]</label></div><br/><div class="children"><div class="content">The ideas described here are very similar to what SSB (<a href="https:&#x2F;&#x2F;ssbc.github.io&#x2F;docs&#x2F;ssb&#x2F;faq.html" rel="nofollow">https:&#x2F;&#x2F;ssbc.github.io&#x2F;docs&#x2F;ssb&#x2F;faq.html</a>) implemented.<p>The main problems with having a log is that it grows with every single change (how granular are your changes? with CRDTs, any mutation, no matter how small, is a change). Questions of data retention (is your protocol tolerant to missing log entries?) or data rewriting (if your log is a merkle tree, rewriting something in the past means rewriting all subsequent entries) are also open.<p>The post also mentions that the log entries could be CRDTs. But if that&#x27;s so, then you don&#x27;t need a log at all, since all the information you need to compute the minimal delta to sync between peers is inside the CRDT itself. For a good overview of how this could be done, see (specifically the &quot;Calculating Diffs&quot; section): <a href="https:&#x2F;&#x2F;ditto.live&#x2F;blog&#x2F;dittos-delta-state-crdts" rel="nofollow">https:&#x2F;&#x2F;ditto.live&#x2F;blog&#x2F;dittos-delta-state-crdts</a> (disclaimer: I work at ditto)</div><br/><div id="40785551" class="c"><input type="checkbox" id="c-40785551" checked=""/><div class="controls bullet"><span class="by">holtwick</span><span>|</span><a href="#40785258">parent</a><span>|</span><a href="#40784693">next</a><span>|</span><label class="collapse" for="c-40785551">[-]</label><label class="expand" for="c-40785551">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the detailed feedback.<p>The growth of the log is indeed a weak point that could be improved by regularly merging entries. Missing entries are easily recognizable because a consecutive index is used. The checksums on the previous entry should improve data consistency.<p>The point that CRDTs themselves already contain all the information required for an update is absolutely correct. I have been working on this protocol for some time and one objective was the reproducibility of the individual changes fro accountability reasons. But this may not be necessary for all applications and could possibly be achieved in other ways. Thank you for pointing this out, I will reconsider the concept in this respect!</div><br/></div></div></div></div><div id="40784693" class="c"><input type="checkbox" id="c-40784693" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40785258">prev</a><span>|</span><label class="collapse" for="c-40784693">[-]</label><label class="expand" for="c-40784693">[9 more]</label></div><br/><div class="children"><div class="content">The challenge of course is that if your write depends on a previous read, offline&#x2F;online sync can easily in the wrong sync state once you come back online (in the general case). Even CRDTs are not immune from this - for example your offline document copy says step 1 is delete line 3 so you delete it but then you sync and step 1 was corrected to be “delete line 4” your deletion of line 3 is now incorrect even though the merged result is “valid”. We see this everyday in code development - they’re called merge conflicts.</div><br/><div id="40785688" class="c"><input type="checkbox" id="c-40785688" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#40784693">parent</a><span>|</span><a href="#40785116">next</a><span>|</span><label class="collapse" for="c-40785688">[-]</label><label class="expand" for="c-40785688">[1 more]</label></div><br/><div class="children"><div class="content">Under what circumstances would a past entry be corrected? Doesn&#x27;t CRDT require an immutable stream of operations?</div><br/></div></div><div id="40785116" class="c"><input type="checkbox" id="c-40785116" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#40784693">parent</a><span>|</span><a href="#40785688">prev</a><span>|</span><label class="collapse" for="c-40785116">[-]</label><label class="expand" for="c-40785116">[7 more]</label></div><br/><div class="children"><div class="content">This is exactly the kind of scenario CRDTs rectify.</div><br/><div id="40785144" class="c"><input type="checkbox" id="c-40785144" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#40784693">root</a><span>|</span><a href="#40785116">parent</a><span>|</span><a href="#40785645">next</a><span>|</span><label class="collapse" for="c-40785144">[-]</label><label class="expand" for="c-40785144">[3 more]</label></div><br/><div class="children"><div class="content">CRDT&#x27;s largely can&#x27;t rectify merge conflicts... what CRDT&#x27;s can do is make your merges convergent. If I auto-merged your Git code using a blunt policy I don&#x27;t know if you&#x27;d reach for &quot;correct&quot; as your first description as opposed to &quot;convergent&quot;.<p>The longer you&#x27;re offline the more you have to explain to your users the circumstances where they might need to do manual data cleanup or expect creative merging policy. No matter what tech you&#x27;re using.</div><br/><div id="40786070" class="c"><input type="checkbox" id="c-40786070" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#40784693">root</a><span>|</span><a href="#40785144">parent</a><span>|</span><a href="#40785465">next</a><span>|</span><label class="collapse" for="c-40786070">[-]</label><label class="expand" for="c-40786070">[1 more]</label></div><br/><div class="children"><div class="content">CRDTs solve merge conflicts by construction, because they necessarily don&#x27;t permit merge conflicts in the first place.</div><br/></div></div><div id="40785465" class="c"><input type="checkbox" id="c-40785465" checked=""/><div class="controls bullet"><span class="by">ErikBjare</span><span>|</span><a href="#40784693">root</a><span>|</span><a href="#40785144">parent</a><span>|</span><a href="#40786070">prev</a><span>|</span><a href="#40785645">next</a><span>|</span><label class="collapse" for="c-40785465">[-]</label><label class="expand" for="c-40785465">[1 more]</label></div><br/><div class="children"><div class="content">This is true if you&#x27;re working with documents edited by different devices, but many CRDTs do not and can indeed be not only &quot;convergent&quot; but also &quot;correct&quot;.<p>How SSB works is a good example.</div><br/></div></div></div></div><div id="40785645" class="c"><input type="checkbox" id="c-40785645" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#40784693">root</a><span>|</span><a href="#40785116">parent</a><span>|</span><a href="#40785144">prev</a><span>|</span><label class="collapse" for="c-40785645">[-]</label><label class="expand" for="c-40785645">[3 more]</label></div><br/><div class="children"><div class="content">No, they don&#x27;t, unfortunately. I feel like the term CRDT leads to misunderstandings like this. CRDTs are more like packaging and abstractions on top of various strategies for building multi-user, local-first UX, they let end users program against recognisable data structures like strings, lists and dictionaries. How they handle conflicts is implementation dependant and isn&#x27;t anything new, many will fall back to LWW for example.</div><br/><div id="40785846" class="c"><input type="checkbox" id="c-40785846" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#40784693">root</a><span>|</span><a href="#40785645">parent</a><span>|</span><label class="collapse" for="c-40785846">[-]</label><label class="expand" for="c-40785846">[2 more]</label></div><br/><div class="children"><div class="content">The specific case of an edit to a line being applied to a different line than what it was intended for because a previous change deleted said line is exactly what CRDTs rectify. I&#x27;m not referring to merge conflicts per say, or that the final document will make human sense. But CRDTs will prevent changesets from different participats from being applied <i>in the worst possible way</i>. And there will be no data loss.</div><br/><div id="40785950" class="c"><input type="checkbox" id="c-40785950" checked=""/><div class="controls bullet"><span class="by">holtwick</span><span>|</span><a href="#40784693">root</a><span>|</span><a href="#40785846">parent</a><span>|</span><label class="collapse" for="c-40785950">[-]</label><label class="expand" for="c-40785950">[1 more]</label></div><br/><div class="children"><div class="content">For certain scenarios there will be conflicts, take a boolean value. Client A sets it and client B unsets it. There can only be one winner.<p>But that might be a benefit from the proposed log sync, because these conflicting situations can be shown and marked for human review in the UI. Each step of change is well documented and the history can fully be reviewed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>