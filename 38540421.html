<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701853256376" as="style"/><link rel="stylesheet" href="styles.css?v=1701853256376"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://sqlite.org/forum/forumpost/fa6f64e3dc1a5d97">JSONB has landed</a> <span class="domain">(<a href="https://sqlite.org">sqlite.org</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>72 comments</span></div><br/><div><div id="38540754" class="c"><input type="checkbox" id="c-38540754" checked=""/><div class="controls bullet"><span class="by">luhn</span><span>|</span><a href="#38540685">next</a><span>|</span><label class="collapse" for="c-38540754">[-]</label><label class="expand" for="c-38540754">[19 more]</label></div><br/><div class="children"><div class="content">Lots of confusion on what JSONB is.<p>To your application, using JSONB looks very similar to the JSON datatype.  You still read and write JSON strings—Your application will never see the raw JSONB content.  The same SQL functions are available, with a different prefix (jsonb_).  Very little changes from the application&#x27;s view.<p>The difference is that the JSON datatype is stored to disk as JSON, whereas the JSONB is stored in a special binary format.  With the JSON datatype, the JSON must be parsed in full to perform any operation against the column. With the JSONB datatype, operations can be performed directly against the on-disk format, skipping the parsing step entirely.<p>If you&#x27;re just using SQLite to write and read full JSON blobs, the JSON datatype will be the best pick.  If you&#x27;re querying or manipulating the data using SQL, JSONB will be the best pick.</div><br/><div id="38541783" class="c"><input type="checkbox" id="c-38541783" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#38540754">parent</a><span>|</span><a href="#38540861">next</a><span>|</span><label class="collapse" for="c-38541783">[-]</label><label class="expand" for="c-38541783">[1 more]</label></div><br/><div class="children"><div class="content">If my application never sees a difference top JSON, everything is compatible and all there is are perf improvements, why ist there a new set of functions top interact with it (jsonb_*)?<p>It seems that the JSON type is even able to contain JSONB.</div><br/></div></div><div id="38540861" class="c"><input type="checkbox" id="c-38540861" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#38540754">parent</a><span>|</span><a href="#38541783">prev</a><span>|</span><a href="#38540685">next</a><span>|</span><label class="collapse" for="c-38540861">[-]</label><label class="expand" for="c-38540861">[17 more]</label></div><br/><div class="children"><div class="content">Is there any downside to storing JSON-B even if you’re not planning to query it? For example, size on disk, read&#x2F;write performance?</div><br/><div id="38540917" class="c"><input type="checkbox" id="c-38540917" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540861">parent</a><span>|</span><a href="#38540916">next</a><span>|</span><label class="collapse" for="c-38540917">[-]</label><label class="expand" for="c-38540917">[8 more]</label></div><br/><div class="children"><div class="content">There’s processing to be done with JSONB on every read&#x2F;write, which is wasted if you’re always reading&#x2F;writing the full blob.</div><br/><div id="38541224" class="c"><input type="checkbox" id="c-38541224" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540917">parent</a><span>|</span><a href="#38540916">next</a><span>|</span><label class="collapse" for="c-38541224">[-]</label><label class="expand" for="c-38541224">[7 more]</label></div><br/><div class="children"><div class="content">Which occurs with JSON as well (SQLite doesn&#x27;t have a dedicated JSON nor JSONB type). The only actual cost would be the conversion between JSONB and JSON.</div><br/><div id="38541357" class="c"><input type="checkbox" id="c-38541357" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541224">parent</a><span>|</span><a href="#38540916">next</a><span>|</span><label class="collapse" for="c-38541357">[-]</label><label class="expand" for="c-38541357">[6 more]</label></div><br/><div class="children"><div class="content">No, SQLite&#x27;s &quot;JSON&quot; is just TEXT, there&#x27;s no overhead with reading&#x2F;writing a string.</div><br/><div id="38541453" class="c"><input type="checkbox" id="c-38541453" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541357">parent</a><span>|</span><a href="#38540916">next</a><span>|</span><label class="collapse" for="c-38541453">[-]</label><label class="expand" for="c-38541453">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I said I think? &quot;JSON&quot; is a TEXT that is handled as a JSON string by `json_*` functions, while &quot;JSONB&quot; is a BLOB that is handled as an internal format by `jsonb_*` functions. You generally don&#x27;t want JSONB in the application side though, so you do need a conversion for that.</div><br/><div id="38541603" class="c"><input type="checkbox" id="c-38541603" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541453">parent</a><span>|</span><a href="#38541494">next</a><span>|</span><label class="collapse" for="c-38541603">[-]</label><label class="expand" for="c-38541603">[2 more]</label></div><br/><div class="children"><div class="content">Yes,  but when you use the BLOB with jsonb functions,  your application demands go from:<p>Read JSON from TEXT column.<p>Parse JSON into Internal Binary Format.<p>Run json_*() function on this format, which will Serialize Internal Binary Format to JSON as output.<p>To:<p>Read JSONB from BLOB column.<p>Run json_*() function on Internal Binary Format,  which will serialize the Internal Binary Format to JSON as output.<p>Because:<p>The json_* and jsonb_* all accept _either_ JSON or JSONB as their input.  The difference is jsonb_* functions also produces it as output.  So even in the above case,  if your function output is just being used to feed back into another table as a BLOB,  then you can use the jsonb_* version of the function and skip the serialization step entirely.</div><br/><div id="38541615" class="c"><input type="checkbox" id="c-38541615" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541603">parent</a><span>|</span><a href="#38541494">next</a><span>|</span><label class="collapse" for="c-38541615">[-]</label><label class="expand" for="c-38541615">[1 more]</label></div><br/><div class="children"><div class="content">Oh, you are right! I later looked at the draft documentation and realized that `json(b)_` only determines the output type. That said, it is still true that you need one more function call `json(...)` to retrieve a textual form of JSON which you do often need instead of JSONB.</div><br/></div></div></div></div><div id="38541494" class="c"><input type="checkbox" id="c-38541494" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541453">parent</a><span>|</span><a href="#38541603">prev</a><span>|</span><a href="#38540916">next</a><span>|</span><label class="collapse" for="c-38541494">[-]</label><label class="expand" for="c-38541494">[2 more]</label></div><br/><div class="children"><div class="content">There’s no point using json_* functions if you’re always reading&#x2F;writing the full blob.</div><br/><div id="38541547" class="c"><input type="checkbox" id="c-38541547" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541494">parent</a><span>|</span><a href="#38540916">next</a><span>|</span><label class="collapse" for="c-38541547">[-]</label><label class="expand" for="c-38541547">[1 more]</label></div><br/><div class="children"><div class="content">Of course (and I never said that), but if you need to store a JSON value in the DB and use a JSONB-encoded BLOB as an optimization, you eventually read it back to a textual JSON. It&#x27;s just like having a UNIX timestamp in your DB and converting back to a parsed date and time for application uses, except that applications may handle a UNIX timestamp directly and can&#x27;t handle JSONB at all.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38540916" class="c"><input type="checkbox" id="c-38540916" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540861">parent</a><span>|</span><a href="#38540917">prev</a><span>|</span><a href="#38540685">next</a><span>|</span><label class="collapse" for="c-38540916">[-]</label><label class="expand" for="c-38540916">[8 more]</label></div><br/><div class="children"><div class="content">If the order of items in the JSON blob matters then JSONB probably wouldn&#x27;t preserve the order.</div><br/><div id="38540923" class="c"><input type="checkbox" id="c-38540923" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540916">parent</a><span>|</span><a href="#38540685">next</a><span>|</span><label class="collapse" for="c-38540923">[-]</label><label class="expand" for="c-38540923">[7 more]</label></div><br/><div class="children"><div class="content">JSON is unordered. Nothing in your code should assume otherwise.<p>&quot;An object is an unordered collection of zero or more name&#x2F;value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.&quot;</div><br/><div id="38541086" class="c"><input type="checkbox" id="c-38541086" checked=""/><div class="controls bullet"><span class="by">hakunin</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540923">parent</a><span>|</span><a href="#38541092">next</a><span>|</span><label class="collapse" for="c-38541086">[-]</label><label class="expand" for="c-38541086">[1 more]</label></div><br/><div class="children"><div class="content">That’s exactly the kind of difference between json and jsonb that you gotta keep in mind. Object properties are unordered, but a json string is very much ordered. It’s the same sequence of characters and lines each time, unless you parse it and dump it again. So if you want to preserve an unmodified original json string for some (e.g. cosmetic) reasons, you probably want json.</div><br/></div></div><div id="38541092" class="c"><input type="checkbox" id="c-38541092" checked=""/><div class="controls bullet"><span class="by">cdogl</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540923">parent</a><span>|</span><a href="#38541086">prev</a><span>|</span><a href="#38541280">next</a><span>|</span><label class="collapse" for="c-38541092">[-]</label><label class="expand" for="c-38541092">[1 more]</label></div><br/><div class="children"><div class="content">The same goes for maps in Go, which now explicitly randomizes map iteration with the range keyword to prevent developers from relying on a particular ordering. Neat trick.</div><br/></div></div><div id="38541280" class="c"><input type="checkbox" id="c-38541280" checked=""/><div class="controls bullet"><span class="by">plq</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540923">parent</a><span>|</span><a href="#38541092">prev</a><span>|</span><a href="#38541172">next</a><span>|</span><label class="collapse" for="c-38541280">[-]</label><label class="expand" for="c-38541280">[2 more]</label></div><br/><div class="children"><div class="content">You make it sound like it&#x27;s one of the laws of physics.<p>ON part of JSON doesn&#x27;t know about objects. When serialized, object entries are just an array of key-value pairs with a weird syntax and a well-defined order. That&#x27;s true for any serialization format actually.<p>It&#x27;s the JS part of JSON that imposes non-duplicate keys with undefined order constraint.<p>You are the engineer, you can decide how you use your tools depending on your use case. Unless eg. you need interop with the rest of the world, it&#x27;s your JSON, (mis)treat it to your heart&#x27;s content.</div><br/><div id="38541334" class="c"><input type="checkbox" id="c-38541334" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38541280">parent</a><span>|</span><a href="#38541172">next</a><span>|</span><label class="collapse" for="c-38541334">[-]</label><label class="expand" for="c-38541334">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You make it sound like it&#x27;s one of the laws of physics.<p>The text I quoted is from the RFC. json.org and ECMA-404 both agree. You are welcome to do whatever you want, but then it isn&#x27;t JSON anymore.</div><br/></div></div></div></div><div id="38541174" class="c"><input type="checkbox" id="c-38541174" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#38540754">root</a><span>|</span><a href="#38540923">parent</a><span>|</span><a href="#38541172">prev</a><span>|</span><a href="#38540685">next</a><span>|</span><label class="collapse" for="c-38541174">[-]</label><label class="expand" for="c-38541174">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, but people might still assume it. If you serialise a Map in Java, some Map implementations will maintain insertion order for example.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38540685" class="c"><input type="checkbox" id="c-38540685" checked=""/><div class="controls bullet"><span class="by">lake-view</span><span>|</span><a href="#38540754">prev</a><span>|</span><a href="#38540822">next</a><span>|</span><label class="collapse" for="c-38540685">[-]</label><label class="expand" for="c-38540685">[8 more]</label></div><br/><div class="children"><div class="content">Because it seems to not be common knowledge on this thread: JSONB is a format offered by Postgres for a while now, and is recommended over plain JSON primarily for improved read performance.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-json.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-json.html</a></div><br/><div id="38540789" class="c"><input type="checkbox" id="c-38540789" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38540685">parent</a><span>|</span><a href="#38540812">next</a><span>|</span><label class="collapse" for="c-38540789">[-]</label><label class="expand" for="c-38540789">[3 more]</label></div><br/><div class="children"><div class="content">Postgres&#x27;s JSONB uses native numbers, which is faster but coerces values. It also removes duplicate keys but you shouldn&#x27;t use those anyway.<p>Sqlite&#x27;s JSONB keeps numbers as strings, which is slower but preserves your weird JSON (since there&#x27;s no such thing as standard JSON). I&#x27;m not sure about duplicate keys.</div><br/><div id="38541291" class="c"><input type="checkbox" id="c-38541291" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#38540685">root</a><span>|</span><a href="#38540789">parent</a><span>|</span><a href="#38541260">next</a><span>|</span><label class="collapse" for="c-38541291">[-]</label><label class="expand" for="c-38541291">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>since there&#x27;s no such thing as standard JSON</i><p>I-JSON is the most sensible JSON profile I know of: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc7493" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc7493</a>. It says: UTF-8 only, prefer not to use numbers beyond IEEE 754-2008 binary64 precision, no duplicate keys, and a couple more things.</div><br/></div></div><div id="38541260" class="c"><input type="checkbox" id="c-38541260" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540685">root</a><span>|</span><a href="#38540789">parent</a><span>|</span><a href="#38541291">prev</a><span>|</span><a href="#38540812">next</a><span>|</span><label class="collapse" for="c-38541260">[-]</label><label class="expand" for="c-38541260">[1 more]</label></div><br/><div class="children"><div class="content">SQLite&#x27;s approach is faster if you are not frequently extracting numerical values out of JSONB. It also makes much easier to convert JSONB back to JSON. I think SQLite JSONB reserved enough space to define a native number type (among others) if this assumption turned out to be false.</div><br/></div></div></div></div><div id="38540812" class="c"><input type="checkbox" id="c-38540812" checked=""/><div class="controls bullet"><span class="by">M4v3R</span><span>|</span><a href="#38540685">parent</a><span>|</span><a href="#38540789">prev</a><span>|</span><a href="#38540710">next</a><span>|</span><label class="collapse" for="c-38540812">[-]</label><label class="expand" for="c-38540812">[3 more]</label></div><br/><div class="children"><div class="content">I don’t know about Sqlite’s implementation but in Postgres JSONB is not 100% transparent to the application. One caveat I’ve encountered while working on an application that stored large JSON objects in Postgres initially as JSONB is that it doesn’t preserve object key order, i.e. the order of keys in an object when you store it will not match the order of keys when you retrieve said object. While for most applications this is not an issue the one I was working on actually did rely on the order of keys (which I am aware is a bad practice but this is how the system was designed) and suddenly we noticed that the app started misbehaving. Changing the column type from JSONB to JSON fixed the problem.</div><br/><div id="38540841" class="c"><input type="checkbox" id="c-38540841" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#38540685">root</a><span>|</span><a href="#38540812">parent</a><span>|</span><a href="#38540963">next</a><span>|</span><label class="collapse" for="c-38540841">[-]</label><label class="expand" for="c-38540841">[1 more]</label></div><br/><div class="children"><div class="content">Given that the order of the keys is specified as having no significance in regular JSON[1], this is out-of-spec usage.<p>If key order has to be preserved then a blob type would be a better fit, then you&#x27;re guaranteed to get back what you wrote.<p>For example, SQLite says it stores JSON as regular text but MySQL converts it to an internal representation[2], so if you migrate you might be in trouble.<p>[1]: <a href="https:&#x2F;&#x2F;ecma-international.org&#x2F;publications-and-standards&#x2F;standards&#x2F;ecma-404&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ecma-international.org&#x2F;publications-and-standards&#x2F;st...</a><p>[2]: <a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;json.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;json.html</a></div><br/></div></div><div id="38540963" class="c"><input type="checkbox" id="c-38540963" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38540685">root</a><span>|</span><a href="#38540812">parent</a><span>|</span><a href="#38540841">prev</a><span>|</span><a href="#38540710">next</a><span>|</span><label class="collapse" for="c-38540963">[-]</label><label class="expand" for="c-38540963">[1 more]</label></div><br/><div class="children"><div class="content">I suppose it is what it is, but if ordering matters, it is only JSON-like in appearance. json.org says:<p>&gt;An object is an unordered set of name&#x2F;value pairs.</div><br/></div></div></div></div><div id="38540710" class="c"><input type="checkbox" id="c-38540710" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#38540685">parent</a><span>|</span><a href="#38540812">prev</a><span>|</span><a href="#38540822">next</a><span>|</span><label class="collapse" for="c-38540710">[-]</label><label class="expand" for="c-38540710">[1 more]</label></div><br/><div class="children"><div class="content">That JSONB is different from SQLite&#x27;s JSONB, though.</div><br/></div></div></div></div><div id="38540822" class="c"><input type="checkbox" id="c-38540822" checked=""/><div class="controls bullet"><span class="by">breadchris</span><span>|</span><a href="#38540685">prev</a><span>|</span><a href="#38541048">next</a><span>|</span><label class="collapse" for="c-38540822">[-]</label><label class="expand" for="c-38540822">[4 more]</label></div><br/><div class="children"><div class="content">I didnt understand the purposes of document stores until the past couple of years and they are fabulous for building POCs. Enhanced JSON support will help a lot for making sqlite a suitable document store.<p>I get full type support by serializing and deserializing protobuf messages from a db column and not making this column JSONB means i can filter this column too, instead of having to flatten the searchable data to other columns.</div><br/><div id="38540914" class="c"><input type="checkbox" id="c-38540914" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#38540822">parent</a><span>|</span><a href="#38541048">next</a><span>|</span><label class="collapse" for="c-38540914">[-]</label><label class="expand" for="c-38540914">[3 more]</label></div><br/><div class="children"><div class="content">Yeah as long as you&#x27;re reading and writing to the database with the same language, and that language has good type safety the benefits of your database schema effectively being defined by the same types as the rest of your code is pretty nice for a lot of use cases.<p>You just have to be vigilant about correctly migrating existing data to the current shape if you ever make breaking changes to types.</div><br/><div id="38541537" class="c"><input type="checkbox" id="c-38541537" checked=""/><div class="controls bullet"><span class="by">BozeWolf</span><span>|</span><a href="#38540822">root</a><span>|</span><a href="#38540914">parent</a><span>|</span><a href="#38541048">next</a><span>|</span><label class="collapse" for="c-38541537">[-]</label><label class="expand" for="c-38541537">[2 more]</label></div><br/><div class="children"><div class="content">This. Would be nice if there was a framework (in go, or python pydantic) which would help me migrate data made with old structs to new structs. And also deal with the transaction.<p>For now i use sqlite to deal with transactions and only make backward compatible updates to structs. Brittle, but it is a toy app anyways.<p>(Normally use django to deal with models and migrations, but wanted to do something different)</div><br/><div id="38541749" class="c"><input type="checkbox" id="c-38541749" checked=""/><div class="controls bullet"><span class="by">buzziebee</span><span>|</span><a href="#38540822">root</a><span>|</span><a href="#38541537">parent</a><span>|</span><a href="#38541048">next</a><span>|</span><label class="collapse" for="c-38541749">[-]</label><label class="expand" for="c-38541749">[1 more]</label></div><br/><div class="children"><div class="content">Yeah migrations are the biggest issue for me. I really don&#x27;t like not knowing what the actual shape of the document will be. Missing transactions, and not great relationship performance makes modelling some systems more hassle than it&#x27;s worth.<p>I gave it a good go to use mongo and firestore for a few projects, but after a year or two of experimenting I&#x27;ll be sticking to SQL based DBs unless there are super clear and obvious benefits to using a document based model.</div><br/></div></div></div></div></div></div></div></div><div id="38541048" class="c"><input type="checkbox" id="c-38541048" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#38540822">prev</a><span>|</span><a href="#38540623">next</a><span>|</span><label class="collapse" for="c-38541048">[-]</label><label class="expand" for="c-38541048">[3 more]</label></div><br/><div class="children"><div class="content">Despite internal format I see immediate external usage in applications. For example batch insertions in Python. Per row insert call has noticeable overhead. And JSONB could bring performance back with CTE:<p><pre><code>    CREATE TABLE data(id, name, age);

    WITH ins AS (
        SELECT c1.value, c2.value, c3.value
        FROM json_each(&#x27;[&quot;some&quot;, &quot;uuid&quot;, &quot;key&quot;]&#x27;) c1
        INNER JOIN json_each(&#x27;[&quot;joe&quot;, &quot;sam&quot;, &quot;phil&quot;]&#x27;) c2 USING (id)
        INNER JOIN json_each(&#x27;[10, 20, 30]&#x27;) c3 USING (id)
    )
    INSERT INTO data (id, name, age)
    SELECT * FROM ins
</code></pre>
Each json_each could accept a bind parameter with JSONB BLOB from an app.</div><br/><div id="38541299" class="c"><input type="checkbox" id="c-38541299" checked=""/><div class="controls bullet"><span class="by">matharmin</span><span>|</span><a href="#38541048">parent</a><span>|</span><a href="#38540623">next</a><span>|</span><label class="collapse" for="c-38541299">[-]</label><label class="expand" for="c-38541299">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need JSONB for this - doing this with plain JSON is simpler and already faster than individual inserts for most bindings in my experience.<p>I typically do bulk inserts using a single JSON argument like this:<p><pre><code>    WITH ins AS (SELECT e.value -&gt;&gt; &#x27;id&#x27;, e.value -&gt;&gt; &#x27;name&#x27;, e.value -&gt;&gt; &#x27;age&#x27; FROM json_each(?) e)
    INSERT INTO data (id, name, age)
    SELECT * FROM ins
</code></pre>
The same approach can be used for bulk updates and deletes as well.</div><br/><div id="38541376" class="c"><input type="checkbox" id="c-38541376" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#38541048">root</a><span>|</span><a href="#38541299">parent</a><span>|</span><a href="#38540623">next</a><span>|</span><label class="collapse" for="c-38541376">[-]</label><label class="expand" for="c-38541376">[1 more]</label></div><br/><div class="children"><div class="content">I have quite wide records (over 50 fields) and -&gt;&gt; performs not well with text keys. I did not try it with array indexing though:<p><pre><code>    WITH ins AS (
        SELECT value -&gt;&gt; 0, value -&gt;&gt; 1, value -&gt;&gt; 2
        FROM json_each(&#x27;[[&quot;some&quot;, &quot;joe&quot;, 10], [&quot;uuid&quot;, &quot;sam&quot;, 20], [&quot;key&quot;, &quot;phil&quot;, 30]]&#x27;)
    )
    INSERT INTO data (id, name, value)
    SELECT * FROM ins</code></pre></div><br/></div></div></div></div></div></div><div id="38540623" class="c"><input type="checkbox" id="c-38540623" checked=""/><div class="controls bullet"><span class="by">evanjrowley</span><span>|</span><a href="#38541048">prev</a><span>|</span><a href="#38541365">next</a><span>|</span><label class="collapse" for="c-38540623">[-]</label><label class="expand" for="c-38540623">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m familiar with MongoDB&#x27;s BSON, but not JSONB. Here is an article I found that talks about the differences: <a href="https:&#x2F;&#x2F;blog.ferretdb.io&#x2F;pjson-how-to-store-bson-in-jsonb&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.ferretdb.io&#x2F;pjson-how-to-store-bson-in-jsonb&#x2F;</a></div><br/></div></div><div id="38541365" class="c"><input type="checkbox" id="c-38541365" checked=""/><div class="controls bullet"><span class="by">radarsat1</span><span>|</span><a href="#38540623">prev</a><span>|</span><a href="#38540634">next</a><span>|</span><label class="collapse" for="c-38541365">[-]</label><label class="expand" for="c-38541365">[1 more]</label></div><br/><div class="children"><div class="content">I have some cases where sometimes I want to store a vector of floats along with a data item.  I usually don&#x27;t need to match against the column, just store it.  I know I could use BLOB but often I just use JSON for this kind of thing so that I don&#x27;t have to deal with data types and conversion.  It&#x27;s wasteful and imprecise though due to the string conversion.  Is JSONB a good middle ground option for these cases?<p>Edit: Sorry, just saw the comment below by o11c,<p>&gt; Sqlite&#x27;s JSONB keeps numbers as strings<p>which means the answer to my question is basically &quot;no&quot;.</div><br/></div></div><div id="38540634" class="c"><input type="checkbox" id="c-38540634" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#38541365">prev</a><span>|</span><a href="#38540436">next</a><span>|</span><label class="collapse" for="c-38540634">[-]</label><label class="expand" for="c-38540634">[3 more]</label></div><br/><div class="children"><div class="content">Next step is to go full Ouroboros and have embedded SQLite DBs as records.</div><br/><div id="38540651" class="c"><input type="checkbox" id="c-38540651" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#38540634">parent</a><span>|</span><a href="#38540643">prev</a><span>|</span><a href="#38540436">next</a><span>|</span><label class="collapse" for="c-38540651">[-]</label><label class="expand" for="c-38540651">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Next step is to go full Ouroboros<p>That was the previous step. Binary BLOBs have been supported in SQLite for some time.</div><br/></div></div></div></div><div id="38540436" class="c"><input type="checkbox" id="c-38540436" checked=""/><div class="controls bullet"><span class="by">nalgeon</span><span>|</span><a href="#38540634">prev</a><span>|</span><a href="#38541583">next</a><span>|</span><label class="collapse" for="c-38540436">[-]</label><label class="expand" for="c-38540436">[1 more]</label></div><br/><div class="children"><div class="content">You can try JSONB in the pre-release snapshot [1] or live in the playground [2].<p>[1]: <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;download.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;sqlite.org&#x2F;download.html</a><p>[2]: <a href="https:&#x2F;&#x2F;codapi.org&#x2F;sqlite" rel="nofollow noreferrer">https:&#x2F;&#x2F;codapi.org&#x2F;sqlite</a></div><br/></div></div><div id="38541583" class="c"><input type="checkbox" id="c-38541583" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#38540436">prev</a><span>|</span><a href="#38540616">next</a><span>|</span><label class="collapse" for="c-38541583">[-]</label><label class="expand" for="c-38541583">[1 more]</label></div><br/><div class="children"><div class="content">So what will JSONB look like in a standalone DB browser (DBeaver, etc.) ?</div><br/></div></div><div id="38540616" class="c"><input type="checkbox" id="c-38540616" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#38541583">prev</a><span>|</span><a href="#38540596">next</a><span>|</span><label class="collapse" for="c-38540616">[-]</label><label class="expand" for="c-38540616">[10 more]</label></div><br/><div class="children"><div class="content">Hm I googled and found this draft of the encoding - <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;draft&#x2F;jsonb.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;sqlite.org&#x2F;draft&#x2F;jsonb.html</a><p>It feels like it would be better to use a known binary encoding.  I thought the MessagePack data model corresponded pretty much exactly to JSON ?<p>Edit: someone else mentioned BSON - <a href="https:&#x2F;&#x2F;bsonspec.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bsonspec.org&#x2F;</a><p>To be honest the wins (in this draft) don&#x27;t seem that compelling<p><i>The advantage of JSONB over ordinary text RFC 8259 JSON is that JSONB is both slightly smaller (by between 5% and 10% in most cases) and can be processed in less than half the number of CPU cycles.</i><p>JSON has been optimized to death; it seems like you could get the 2x gain and avoid a new format with normal optimization, or perhaps compile-time options for  SIMD JSON techniques<p>---<p>And this seems likely to confuse:<p><i>The &quot;JSONB&quot; name is inspired by PostgreSQL, but the on-disk format for SQLite&#x27;s JSONB is not the same as PostgreSQL&#x27;s. The two formats have the same name, but they have wildly different internal representations and are not in any way binary compatible. </i><p>---<p>Any time data is serialized, SOMEBODY is going to read it.  With something as popular as sqlite, that&#x27;s true 10x over.<p>So to me, this seems suboptimal on 2 fronts.</div><br/><div id="38540711" class="c"><input type="checkbox" id="c-38540711" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38540616">parent</a><span>|</span><a href="#38541026">next</a><span>|</span><label class="collapse" for="c-38540711">[-]</label><label class="expand" for="c-38540711">[1 more]</label></div><br/><div class="children"><div class="content">SQLite says you should not attempt to access it: <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;draft&#x2F;jsonb.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;sqlite.org&#x2F;draft&#x2F;jsonb.html</a><p>&gt; JSONB is not intended as an external format to be used by applications. JSONB is designed for internal use by SQLite only. Programmers do not need to understand the JSONB format in order to use it effectively. Applications should access JSONB only through the JSON SQL functions, not by looking at individual bytes of the BLOB.<p>&gt; However, JSONB is intended to be portable and backwards compatible for all future versions of SQLite. In other words, you should not have to export and reimport your SQLite database files when you upgrade to a newer SQLite version. For that reason, the JSONB format needs to be well-defined.<p>If SQLite intends to own the format forever, I can believe that their requirements are such that leaning on an existing implementation is not worth the savings to implement.</div><br/></div></div><div id="38541026" class="c"><input type="checkbox" id="c-38541026" checked=""/><div class="controls bullet"><span class="by">jomohke</span><span>|</span><a href="#38540616">parent</a><span>|</span><a href="#38540711">prev</a><span>|</span><a href="#38540707">next</a><span>|</span><label class="collapse" for="c-38541026">[-]</label><label class="expand" for="c-38541026">[1 more]</label></div><br/><div class="children"><div class="content">Re-using standards is a great idea, and should remain people&#x27;s default, but I don&#x27;t see the benefit here.<p>What&#x27;s the advantage of re-using a format?<p>Ecosystem? That won&#x27;t help SQLite here, who don&#x27;t have dependencies.<p>Keep in mind that anyone trying to write a parser for this is also writing a parser for the entire SQLite file format (the only way to access bytes). And it&#x27;s a spec simple enough to fit on one monitor.<p>Design?<p>BSON (and others?) seem to have different goals.<p>SQLite&#x27;s format seems to minimise conversion&#x2F;parsing (eg. it has multiple TEXT types depending on how much escaping is needed; BSON has one fully-parsed UTF-8 string type). BSON is more complex: includes many types not supported by json (dates, regexs, uuids...) and has a bunch of deprecated features already.<p>SQLite&#x27;s on disk-format is something they intend to support &quot;forever&quot;, and as with the rest of SQLite, they enjoy pragmatic simplicity.</div><br/></div></div><div id="38540707" class="c"><input type="checkbox" id="c-38540707" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38540616">parent</a><span>|</span><a href="#38541026">prev</a><span>|</span><a href="#38540657">next</a><span>|</span><label class="collapse" for="c-38540707">[-]</label><label class="expand" for="c-38540707">[3 more]</label></div><br/><div class="children"><div class="content">&gt; JSON has been optimized to death; it seems like you could get the 2x gain and avoid a new format with normal optimization<p>Either I&#x27;m experiencing a reading comprehension mishap or this is self contradictory.  Where is a &quot;2x gain&quot; supposed to come from through &quot;normal optimization&quot; from after something has already been optimized &quot;to death?&quot;<p>&gt; SIMD JSON techniques<p>Which are infeasible in key SQLite use cases.</div><br/><div id="38540842" class="c"><input type="checkbox" id="c-38540842" checked=""/><div class="controls bullet"><span class="by">brazzy</span><span>|</span><a href="#38540616">root</a><span>|</span><a href="#38540707">parent</a><span>|</span><a href="#38540657">next</a><span>|</span><label class="collapse" for="c-38540842">[-]</label><label class="expand" for="c-38540842">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Credit to SQLite developers for adopting an extant binary JSON format, as opposed to inventing yet another one.<p>The comment you are replying to cites a statement saying explicitly that they are <i>not</i> adopting the Postgres JSONB binary format, only the name and the abstract concept. The API is not compatible with Postgres either.</div><br/><div id="38540860" class="c"><input type="checkbox" id="c-38540860" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38540616">root</a><span>|</span><a href="#38540842">parent</a><span>|</span><a href="#38540657">next</a><span>|</span><label class="collapse" for="c-38540860">[-]</label><label class="expand" for="c-38540860">[1 more]</label></div><br/><div class="children"><div class="content">I noted that and removed that bit prior to your reply.<p>Points off for a.) inventing yet another binary JSON and&#x2F;or b.) using the same name as an existing binary JSON.</div><br/></div></div></div></div></div></div><div id="38540657" class="c"><input type="checkbox" id="c-38540657" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540616">parent</a><span>|</span><a href="#38540707">prev</a><span>|</span><a href="#38540654">next</a><span>|</span><label class="collapse" for="c-38540657">[-]</label><label class="expand" for="c-38540657">[1 more]</label></div><br/><div class="children"><div class="content">It takes a lot of complex code to optimize a JSON parser. You don&#x27;t need to optimize that hard to make an equally performant parser for binary serialization formats, and given SQLite&#x27;s JSONB is purely an internal optimization, it doesn&#x27;t have to be a well-known <i>interchange</i> format (which has much more concerns than SQLite).<p>&gt; Any time data is serialized, SOMEBODY is going to read it. With something as popular as sqlite, that&#x27;s true 10x over.<p>And this statement is equally true for the SQLite format itself. That doesn&#x27;t mean that the SQLite format should be replaced with something more standard, of course.</div><br/></div></div><div id="38540654" class="c"><input type="checkbox" id="c-38540654" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#38540616">parent</a><span>|</span><a href="#38540657">prev</a><span>|</span><a href="#38540596">next</a><span>|</span><label class="collapse" for="c-38540654">[-]</label><label class="expand" for="c-38540654">[3 more]</label></div><br/><div class="children"><div class="content">I thought the point was that the DB could reach into JSONB for you (potentially indexed as well) instead of having to deserialize outside. So the exact serialization isn&#x27;t maybe as interesting as the direct queryability.</div><br/><div id="38540687" class="c"><input type="checkbox" id="c-38540687" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38540616">root</a><span>|</span><a href="#38540654">parent</a><span>|</span><a href="#38540596">next</a><span>|</span><label class="collapse" for="c-38540687">[-]</label><label class="expand" for="c-38540687">[2 more]</label></div><br/><div class="children"><div class="content">Does SQLite make any promises on the internal implementation? I assumed that the only guarantee was at the SQL interface.</div><br/><div id="38540811" class="c"><input type="checkbox" id="c-38540811" checked=""/><div class="controls bullet"><span class="by">banana_giraffe</span><span>|</span><a href="#38540616">root</a><span>|</span><a href="#38540687">parent</a><span>|</span><a href="#38540596">next</a><span>|</span><label class="collapse" for="c-38540811">[-]</label><label class="expand" for="c-38540811">[1 more]</label></div><br/><div class="children"><div class="content">They do promise it&#x27;ll be a stable format:<p>&gt; The JSONB format is not intended as an interchange format. Nevertheless, JSONB is stored in database files which are intended to be readable and writable for many decades into the future. To that end, the JSONB format is well-defined and stable. The separate SQLite JSONB format document provides details of the JSONB format for the curious reader.<p>And indeed the functions jsonb() and json() will let you convert to and from jsonb.</div><br/></div></div></div></div></div></div></div></div><div id="38540596" class="c"><input type="checkbox" id="c-38540596" checked=""/><div class="controls bullet"><span class="by">array-species</span><span>|</span><a href="#38540616">prev</a><span>|</span><a href="#38540726">next</a><span>|</span><label class="collapse" for="c-38540596">[-]</label><label class="expand" for="c-38540596">[2 more]</label></div><br/><div class="children"><div class="content">Interested to know what the Deno JavaScript&#x2F;TypeScript project thinks of this addition given it has already has a key value store backed by the database and JSON is JavaScript friendly.</div><br/><div id="38540717" class="c"><input type="checkbox" id="c-38540717" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#38540596">parent</a><span>|</span><a href="#38540726">next</a><span>|</span><label class="collapse" for="c-38540717">[-]</label><label class="expand" for="c-38540717">[1 more]</label></div><br/><div class="children"><div class="content">While this will be good for SQLite queries that look into JSON data I’m not sure it really changes much for Deno. V8’s JSON parser is very highly optimised so it may be tricky to make a faster SQLite JSONB parser.</div><br/></div></div></div></div><div id="38540726" class="c"><input type="checkbox" id="c-38540726" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38540596">prev</a><span>|</span><a href="#38540627">next</a><span>|</span><label class="collapse" for="c-38540726">[-]</label><label class="expand" for="c-38540726">[6 more]</label></div><br/><div class="children"><div class="content">Is this just a data type, or did SQLite put in a JSON interpreter?</div><br/><div id="38540741" class="c"><input type="checkbox" id="c-38540741" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38540726">parent</a><span>|</span><a href="#38541037">next</a><span>|</span><label class="collapse" for="c-38540741">[-]</label><label class="expand" for="c-38540741">[2 more]</label></div><br/><div class="children"><div class="content">What do you mean by a JSON interpreter? I think SQLite already has a full implementation of JSON including tree walkers, and this internal format (that is externally just another BLOB) makes them more efficient.</div><br/><div id="38541187" class="c"><input type="checkbox" id="c-38541187" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38540726">root</a><span>|</span><a href="#38540741">parent</a><span>|</span><a href="#38541037">next</a><span>|</span><label class="collapse" for="c-38541187">[-]</label><label class="expand" for="c-38541187">[1 more]</label></div><br/><div class="children"><div class="content">Oh, sorry, I was thinking that someone had put a Javascript interpreter in the database itself. Fortunately, no.</div><br/></div></div></div></div><div id="38541037" class="c"><input type="checkbox" id="c-38541037" checked=""/><div class="controls bullet"><span class="by">HDThoreaun</span><span>|</span><a href="#38540726">parent</a><span>|</span><a href="#38540741">prev</a><span>|</span><a href="#38541205">next</a><span>|</span><label class="collapse" for="c-38541037">[-]</label><label class="expand" for="c-38541037">[1 more]</label></div><br/><div class="children"><div class="content">You mean a JSON parser? I don&#x27;t think you can execute anything with json.</div><br/></div></div><div id="38541205" class="c"><input type="checkbox" id="c-38541205" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#38540726">parent</a><span>|</span><a href="#38541037">prev</a><span>|</span><a href="#38540982">next</a><span>|</span><label class="collapse" for="c-38541205">[-]</label><label class="expand" for="c-38541205">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure SQLite comes with a JSON parser. JSON is a very simple format for which it is easy to write a parser for...</div><br/></div></div><div id="38540982" class="c"><input type="checkbox" id="c-38540982" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#38540726">parent</a><span>|</span><a href="#38541205">prev</a><span>|</span><a href="#38540627">next</a><span>|</span><label class="collapse" for="c-38540982">[-]</label><label class="expand" for="c-38540982">[1 more]</label></div><br/><div class="children"><div class="content">SQLite has had pretty decent support for JSON for a while now:<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;json1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;sqlite.org&#x2F;json1.html</a></div><br/></div></div></div></div><div id="38540642" class="c"><input type="checkbox" id="c-38540642" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38540627">prev</a><span>|</span><a href="#38540718">next</a><span>|</span><label class="collapse" for="c-38540642">[-]</label><label class="expand" for="c-38540642">[9 more]</label></div><br/><div class="children"><div class="content">There&#x27;s all the rest of open source, and then there&#x27;s SQLite. A public domain software that doesn&#x27;t accept contributions from outsiders, and that happens to run much of the world.<p>And it just keeps getting better and better and better, and faster and faster and faster.<p>I don&#x27;t know <i>how</i> these guys manage to succeed where almost all other projects fail, but I hope they keep going.</div><br/><div id="38541017" class="c"><input type="checkbox" id="c-38541017" checked=""/><div class="controls bullet"><span class="by">LVB</span><span>|</span><a href="#38540642">parent</a><span>|</span><a href="#38540804">next</a><span>|</span><label class="collapse" for="c-38541017">[-]</label><label class="expand" for="c-38541017">[2 more]</label></div><br/><div class="children"><div class="content">The patterns I&#x27;ve noticed, watching it evolve for nearly 20 years are:<p>- They draft behind others, and I mean this in a good way. They seem to eschew trailblazing new features, but keep a close eye on alternatives (esp. Postgres) and how use cases are emerging. When a sufficiently interesting concept has stabilized, they bring it to SQLite.<p>- Closely related to this, they seem to stay clear of technical and community distractions. They have their plans and execute.<p>- I don&#x27;t know if D. Richard Hipp is considered a BDFL, but that&#x27;s my impression and he seems good at it.</div><br/><div id="38541741" class="c"><input type="checkbox" id="c-38541741" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#38540642">root</a><span>|</span><a href="#38541017">parent</a><span>|</span><a href="#38540804">next</a><span>|</span><label class="collapse" for="c-38541741">[-]</label><label class="expand" for="c-38541741">[1 more]</label></div><br/><div class="children"><div class="content">When put this way, it reminds me how Apple generally chooses to add features to the iPhone. They wait for use cases to be proven, usually by Samsung, and then add a very polished version to the phone.</div><br/></div></div></div></div><div id="38540804" class="c"><input type="checkbox" id="c-38540804" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38540642">parent</a><span>|</span><a href="#38541017">prev</a><span>|</span><a href="#38541327">next</a><span>|</span><label class="collapse" for="c-38540804">[-]</label><label class="expand" for="c-38540804">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you gotta keep the riff raff out in order to march forwards with your vision. Too many cooks in the kitchen can be deadly.</div><br/></div></div><div id="38541327" class="c"><input type="checkbox" id="c-38541327" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#38540642">parent</a><span>|</span><a href="#38540804">prev</a><span>|</span><a href="#38540884">next</a><span>|</span><label class="collapse" for="c-38541327">[-]</label><label class="expand" for="c-38541327">[1 more]</label></div><br/><div class="children"><div class="content">Can anyone comment on the characteristics of the source code?  Is the sqlite source worth reading for someone who is well-versed in C and x86 assembly, and has a rudimentary knowledge of databases?</div><br/></div></div><div id="38540884" class="c"><input type="checkbox" id="c-38540884" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38540642">parent</a><span>|</span><a href="#38541327">prev</a><span>|</span><a href="#38540693">next</a><span>|</span><label class="collapse" for="c-38540884">[-]</label><label class="expand" for="c-38540884">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s perhaps the best example of the cathedral model of open source.</div><br/><div id="38541259" class="c"><input type="checkbox" id="c-38541259" checked=""/><div class="controls bullet"><span class="by">zertrin</span><span>|</span><a href="#38540642">root</a><span>|</span><a href="#38540884">parent</a><span>|</span><a href="#38540693">next</a><span>|</span><label class="collapse" for="c-38541259">[-]</label><label class="expand" for="c-38541259">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, learned about it while reading the documentation of Fossil (from the same SQLite people). Their approach certainly has its own merits (and drawbacks).<p>Just wondering how they will transition once the original few people at the top of the hierarchy need to retire, eventually it will happen.<p>I guess they need to find younger trusted committers with the same dedication and spirit. That&#x27;s not necessarily easy. But for a piece of software as important as SQLite, I have a feeling they will find those.</div><br/><div id="38541329" class="c"><input type="checkbox" id="c-38541329" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#38540642">root</a><span>|</span><a href="#38541259">parent</a><span>|</span><a href="#38540693">next</a><span>|</span><label class="collapse" for="c-38541329">[-]</label><label class="expand" for="c-38541329">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Just wondering how they will transition once the original few people at the top of the hierarchy need to retire, eventually it will happen.<p>I had always viewed this as a &quot;future worry&quot;, and then Bram Moolenaar passed away :(</div><br/></div></div></div></div></div></div></div></div><div id="38540718" class="c"><input type="checkbox" id="c-38540718" checked=""/><div class="controls bullet"><span class="by">downrightmike</span><span>|</span><a href="#38540642">prev</a><span>|</span><label class="collapse" for="c-38540718">[-]</label><label class="expand" for="c-38540718">[2 more]</label></div><br/><div class="children"><div class="content">Is it an excellent and unchecked attack surface like JSON is in MSSQL? Postgres is also known for SQL injection. And if this is based off of that...<p><a href="https:&#x2F;&#x2F;www.imperva.com&#x2F;blog&#x2F;abusing-json-based-sql&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.imperva.com&#x2F;blog&#x2F;abusing-json-based-sql&#x2F;</a></div><br/><div id="38540810" class="c"><input type="checkbox" id="c-38540810" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#38540718">parent</a><span>|</span><label class="collapse" for="c-38540810">[-]</label><label class="expand" for="c-38540810">[1 more]</label></div><br/><div class="children"><div class="content">This blog post is about using these operators to bypass WAFs. You don&#x27;t need JSON operators for that. You can substitute `1==1` with `2==2`, or `1!=1`, or `true`, or a million other approaches. There are an infinite number of such strings.<p>This is a problem with WAFs, not databases. Postgres and SQL Server both provide prepared statements as an alternative to string concatenation, which addresses SQL injection. (Though some people may be stuck with legacy or vendor-contolled systems that they can&#x27;t fix, and so WAFs are their only option.)</div><br/></div></div></div></div></div></div></div></div></div></body></html>