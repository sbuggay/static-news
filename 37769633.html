<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696496489533" as="style"/><link rel="stylesheet" href="styles.css?v=1696496489533"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/cvilsmeier/sqinn-go">Show HN: Sqinn-Go is a Golang library for accessing SQLite databases in pure Go</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>cvilsmeier</span> | <span>46 comments</span></div><br/><div><div id="37775608" class="c"><input type="checkbox" id="c-37775608" checked=""/><div class="controls bullet"><span class="by">tw1984</span><span>|</span><a href="#37774349">next</a><span>|</span><label class="collapse" for="c-37775608">[-]</label><label class="expand" for="c-37775608">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty much a os&#x2F;exec + stdin&#x2F;stdout redirection library.<p>I&#x27;ve been using cgo for accessing sqlite for ages, never ever had any trouble. cgo is not remotely as bad as what people might believe. give cgo a go, and you will realize that it saves your time, let you focus on your projects rather than non-senses like how to use stdin&#x2F;stdout redirection to bypass cgo.</div><br/></div></div><div id="37774349" class="c"><input type="checkbox" id="c-37774349" checked=""/><div class="controls bullet"><span class="by">twodave</span><span>|</span><a href="#37775608">prev</a><span>|</span><a href="#37774646">next</a><span>|</span><label class="collapse" for="c-37774349">[-]</label><label class="expand" for="c-37774349">[1 more]</label></div><br/><div class="children"><div class="content">Nice work! It&#x27;s fun to see other people hacking away at Golang projects. I&#x27;ve been contemplating how to write tests for my own project, and this has given me some ideas.</div><br/></div></div><div id="37774646" class="c"><input type="checkbox" id="c-37774646" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37774349">prev</a><span>|</span><a href="#37770454">next</a><span>|</span><label class="collapse" for="c-37774646">[-]</label><label class="expand" for="c-37774646">[1 more]</label></div><br/><div class="children"><div class="content">Why create a HN today, just to post some code you haven&#x27;t touched in two years?</div><br/></div></div><div id="37770454" class="c"><input type="checkbox" id="c-37770454" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#37774646">prev</a><span>|</span><a href="#37770486">next</a><span>|</span><label class="collapse" for="c-37770454">[-]</label><label class="expand" for="c-37770454">[38 more]</label></div><br/><div class="children"><div class="content">If you <i>really</i> want to use SQLite without anything that isn&#x27;t Go (since this project involves forking and communicating with a non-Go SQLite in a separate process over pipes), there&#x27;s a Go translation of SQLite&#x27;s C source. :)<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;sqlite" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;sqlite</a><p><a href="https:&#x2F;&#x2F;datastation.multiprocess.io&#x2F;blog&#x2F;2022-05-12-sqlite-in-go-with-and-without-cgo.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;datastation.multiprocess.io&#x2F;blog&#x2F;2022-05-12-sqlite-i...</a></div><br/><div id="37776318" class="c"><input type="checkbox" id="c-37776318" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#37770454">parent</a><span>|</span><a href="#37770660">next</a><span>|</span><label class="collapse" for="c-37776318">[-]</label><label class="expand" for="c-37776318">[1 more]</label></div><br/><div class="children"><div class="content">This is so cool... I see it has FTS5 support too. Now is the time to rewrite some of my apps into independent binaries</div><br/></div></div><div id="37770660" class="c"><input type="checkbox" id="c-37770660" checked=""/><div class="controls bullet"><span class="by">scosman</span><span>|</span><a href="#37770454">parent</a><span>|</span><a href="#37776318">prev</a><span>|</span><a href="#37772231">next</a><span>|</span><label class="collapse" for="c-37770660">[-]</label><label class="expand" for="c-37770660">[25 more]</label></div><br/><div class="children"><div class="content">What’s the case against cgo for SQLite? Just the usual cgo performance overhead?<p>It seems like a pretty good cgo use case: a decent amount of work, which is typically slow enough that cgo overhead isn’t perf critical (because DB usually means disk reads), a super robust and well tested C library with a super well maintained cgo wrapper (mattn).</div><br/><div id="37770925" class="c"><input type="checkbox" id="c-37770925" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770660">parent</a><span>|</span><a href="#37770757">next</a><span>|</span><label class="collapse" for="c-37770925">[-]</label><label class="expand" for="c-37770925">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Just the usual cgo performance overhead?<p>No, the performance is certainly orders of magnitude faster than serializing over std streams on a subprocess (c ffi calls in cgo are 10s of nanoseconds).<p>But one of the big draws of golang is the write-once-compile-anywhere toolchain and calls cgo makes that harder.</div><br/><div id="37771013" class="c"><input type="checkbox" id="c-37771013" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770925">parent</a><span>|</span><a href="#37771073">next</a><span>|</span><label class="collapse" for="c-37771013">[-]</label><label class="expand" for="c-37771013">[5 more]</label></div><br/><div class="children"><div class="content">To be a bit more specific here: pure Go binaries are trivial to cross-compile and they Just Work™ basically all the time.  `GOOS=&quot;darwin&quot; GOARCH=&quot;arm64&quot; go build .` and you&#x27;re done.  Just iterate over the combinations you care about, they&#x27;ll all work.<p>As soon as you <i>or a library</i> touches cgo, you have to deal with finding and setting up C cross-compilation tooling for your target(s), dynamic linking details, <i>tons</i> of stuff that may have nothing to do with your code or be an area you&#x27;re an expert in as a Go developer.</div><br/><div id="37772155" class="c"><input type="checkbox" id="c-37772155" checked=""/><div class="controls bullet"><span class="by">irusensei</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771013">parent</a><span>|</span><a href="#37771073">next</a><span>|</span><label class="collapse" for="c-37772155">[-]</label><label class="expand" for="c-37772155">[4 more]</label></div><br/><div class="children"><div class="content">Golang works on Plan9. It can even bootstrap itself. A few months ago I was trying to setup some server software on 9Front for giggles and while most stuff worked I couldn&#x27;t past the Sqlite CGO dependencies.</div><br/><div id="37772595" class="c"><input type="checkbox" id="c-37772595" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772155">parent</a><span>|</span><a href="#37771073">next</a><span>|</span><label class="collapse" for="c-37772595">[-]</label><label class="expand" for="c-37772595">[3 more]</label></div><br/><div class="children"><div class="content">If you still have that itch to scratch, you can try:
<a href="https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;go-sqlite3">https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;go-sqlite3</a><p>You&#x27;ll need to use the sqlite3_nolock build tag; concurrent writes will quickly corrupt your database. SetMaxOpenConns(1) is your friend.<p>But it should work. I&#x27;m interested if it doesn&#x27;t. Feedback appreciated.</div><br/><div id="37773868" class="c"><input type="checkbox" id="c-37773868" checked=""/><div class="controls bullet"><span class="by">llimllib</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772595">parent</a><span>|</span><a href="#37771073">next</a><span>|</span><label class="collapse" for="c-37773868">[-]</label><label class="expand" for="c-37773868">[2 more]</label></div><br/><div class="children"><div class="content">Very neat! Any idea how its performance compares to the modernc port?</div><br/><div id="37775646" class="c"><input type="checkbox" id="c-37775646" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37773868">parent</a><span>|</span><a href="#37771073">next</a><span>|</span><label class="collapse" for="c-37775646">[-]</label><label class="expand" for="c-37775646">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s slower. But wazero is developing an optimizing compiler for amd64&#x2F;arm64 (the current one is very naive) which I hope will close the gap on those platforms.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37771073" class="c"><input type="checkbox" id="c-37771073" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770925">parent</a><span>|</span><a href="#37771013">prev</a><span>|</span><a href="#37770757">next</a><span>|</span><label class="collapse" for="c-37771073">[-]</label><label class="expand" for="c-37771073">[7 more]</label></div><br/><div class="children"><div class="content">But compiling the non-go assistant process is not going to be any easier than cgo, right?</div><br/><div id="37774355" class="c"><input type="checkbox" id="c-37774355" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771073">parent</a><span>|</span><a href="#37771362">next</a><span>|</span><label class="collapse" for="c-37774355">[-]</label><label class="expand" for="c-37774355">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so.<p>The main go compilation must work in all sorts of environments: dev computers, CI runners.. it should be quick and automated to keep development fast. It should be easy, so everyone on your team can do this.<p>The assistant process is basically built once and then never changes, you just need to keep a binary somewhere (and they seem to be &lt;1MB so you can check them into git directly). So a single person somewhere has to figure how to do a C build once, and everyone else can benefit. Have your someone ssh into CI runner directly and install gcc. Spend a day installing compiler and messing with Makefiles on exotic OS. You only do it once and you are good forever (or until you want to bump sqlite version)</div><br/></div></div><div id="37771362" class="c"><input type="checkbox" id="c-37771362" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771073">parent</a><span>|</span><a href="#37774355">prev</a><span>|</span><a href="#37771300">next</a><span>|</span><label class="collapse" for="c-37771362">[-]</label><label class="expand" for="c-37771362">[2 more]</label></div><br/><div class="children"><div class="content">Well its a different access pattern. As the underlying library points out:<p>&gt; It is used in programming environments that do not allow calling C API functions.<p>Also I guess which one is easier will be subjective. The steps are sorta similar:<p>Step 1) install sqlite or squinn on the base system (the latter might be harder)<p>Step 2) if sqllite use cgo, if squinn just use go (the former might be harder but more performant)</div><br/><div id="37774261" class="c"><input type="checkbox" id="c-37774261" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771362">parent</a><span>|</span><a href="#37771300">next</a><span>|</span><label class="collapse" for="c-37774261">[-]</label><label class="expand" for="c-37774261">[1 more]</label></div><br/><div class="children"><div class="content">Which programming environments that do not allow calling C API functions also let you build&#x2F;ship arbitrary C executables, though? (Genuinely curious what scenarios this unlocks.)</div><br/></div></div></div></div><div id="37771300" class="c"><input type="checkbox" id="c-37771300" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771073">parent</a><span>|</span><a href="#37771362">prev</a><span>|</span><a href="#37770757">next</a><span>|</span><label class="collapse" for="c-37771300">[-]</label><label class="expand" for="c-37771300">[3 more]</label></div><br/><div class="children"><div class="content">In the mentioned <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;sqlite" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;sqlite</a> there would not be any assistant process, right?</div><br/><div id="37771656" class="c"><input type="checkbox" id="c-37771656" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771300">parent</a><span>|</span><a href="#37770757">next</a><span>|</span><label class="collapse" for="c-37771656">[-]</label><label class="expand" for="c-37771656">[2 more]</label></div><br/><div class="children"><div class="content">No, but that has the disadvantage of being C compiled into Go, then being compiled into native executable.<p>I&#x27;m actually surprised by how readable this came out; props to the Go-&gt;C compiler author. But you can guess that pushing this sort of thing through the Go compiler is going to cause some slowdowns due to sheer paradigm mismatch: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;sqlite&#x2F;-&#x2F;blob&#x2F;master&#x2F;lib&#x2F;sqlite_linux_riscv64.go?ref_type=heads#L13192" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;sqlite&#x2F;-&#x2F;blob&#x2F;master&#x2F;lib&#x2F;sqlite_lin...</a></div><br/><div id="37772005" class="c"><input type="checkbox" id="c-37772005" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771656">parent</a><span>|</span><a href="#37770757">next</a><span>|</span><label class="collapse" for="c-37772005">[-]</label><label class="expand" for="c-37772005">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think the paradigm is particularly mismatched, right? If you translate C to Go, it would be pretty much best case for Go (neither language likes lots of small allocations). But Go lacks a lot of optimizations that most C compilers support, like return value optimization, aggressive inlining, etc. C also has lighter-weight function calls and so on that you pay for in Go.<p>Maybe this is what you mean by paradigm mismatch, but usually I would think of something like translating an allocation-heavy Java app into Go as paradigm mismatch.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37770757" class="c"><input type="checkbox" id="c-37770757" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770660">parent</a><span>|</span><a href="#37770925">prev</a><span>|</span><a href="#37771545">next</a><span>|</span><label class="collapse" for="c-37770757">[-]</label><label class="expand" for="c-37770757">[6 more]</label></div><br/><div class="children"><div class="content">mattn&#x27;s sqlite3 is probably the most ideal use case for cgo imaginable. But it can still be annoying to set up cgo to build across many platforms.<p>I think Go should just pull a Zig and just embed a full blown C compiler into go build.</div><br/><div id="37774742" class="c"><input type="checkbox" id="c-37774742" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770757">parent</a><span>|</span><a href="#37772274">next</a><span>|</span><label class="collapse" for="c-37774742">[-]</label><label class="expand" for="c-37774742">[2 more]</label></div><br/><div class="children"><div class="content">Pulling a zig isn&#x27;t going to solve all problems, as the zig cross compiler itself runs into problems fairly often. I already use CC=&#x27;zig cc -target x86_64-linux-musl&#x27; (or whatever the target is) with cgo to cross-compile mattn&#x2F;go-sqlite3, and relatively recently it simply stopped working[1] and a workaround had to do be added to about every single project of mine using SQLite through cgo.<p>I also once tried to figure out a way to cross compile mattn&#x2F;go-sqlite3 to 32bit Windows with zig, and failed.<p>The best way to make cross compiling painless is to not use cgo at all. Which is why I use modernc&#x2F;sqlite whenever possible now.<p>Btw, bundling a C compiler is also much harder when you don&#x27;t build on top of LLVM.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;mattn&#x2F;go-sqlite3&#x2F;issues&#x2F;1164">https:&#x2F;&#x2F;github.com&#x2F;mattn&#x2F;go-sqlite3&#x2F;issues&#x2F;1164</a></div><br/><div id="37775725" class="c"><input type="checkbox" id="c-37775725" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37774742">parent</a><span>|</span><a href="#37772274">next</a><span>|</span><label class="collapse" for="c-37775725">[-]</label><label class="expand" for="c-37775725">[1 more]</label></div><br/><div class="children"><div class="content">I’m going to add a counter argument to all the cgo views raised:<p>Personally I’ve had much more portability problems with a lot of the native Go ports of sqlite than I have with mattn’s cgo library.<p>I author a shell that targets most of the architectures and platforms supported by Go. At the request of some users, I added support for a Go native library because they didn’t want to install a C compilers as well as a Go compiler. I tried a few different sqlite ports (though off hand cannot recall which ones) and they all had massive limitations, like only compiling on Windows and Linux (in one example).<p>In the end, I gave up and reverted back to the cgo version with the option for other libraries hidden behind a compiler flag.<p>I found my build pipeline manages just fine with cross compiling and haven’t had any complaints (thus far) with the binaries bar one individual running an ancient version of CentOS.<p>Maybe I’ve been trying the wrong sqlite ports. But here lies the problem: with cgo I know I’m getting a stable, tested, library. With other ports it’s entirely a lottery with regards to how well maintained and tested it might be. For personal projects that’s a fine risk to take but for any larger open source (or even commercial) projects, that additional uncertainty is a risk that distracts me and the other contributors from working on the core part of the project. And thus defeats the connivance of using 3rd party libraries.</div><br/></div></div></div></div><div id="37772274" class="c"><input type="checkbox" id="c-37772274" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770757">parent</a><span>|</span><a href="#37774742">prev</a><span>|</span><a href="#37771470">next</a><span>|</span><label class="collapse" for="c-37772274">[-]</label><label class="expand" for="c-37772274">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, once I was on windows and couldn&#x27;t get cgo sqlite working on a variety of mingw and alike compilers... felt like 90s.<p>Using this cznic&#x27;s pure-Go sqlite saved the day.</div><br/></div></div><div id="37771470" class="c"><input type="checkbox" id="c-37771470" checked=""/><div class="controls bullet"><span class="by">scosman</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770757">parent</a><span>|</span><a href="#37772274">prev</a><span>|</span><a href="#37772841">next</a><span>|</span><label class="collapse" for="c-37771470">[-]</label><label class="expand" for="c-37771470">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Good to know I didn’t miss a trade off in the mix.<p>If I’m choosing to use a C framework (SQLite) I’m okay signing up for the environment costs. Prefer that over abstractions in an intermediate layer that might not be maintained in a few years.</div><br/></div></div><div id="37772841" class="c"><input type="checkbox" id="c-37772841" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770757">parent</a><span>|</span><a href="#37771470">prev</a><span>|</span><a href="#37771545">next</a><span>|</span><label class="collapse" for="c-37772841">[-]</label><label class="expand" for="c-37772841">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t it? Isn&#x27;t that what 5c, 6c, and 8c were.</div><br/></div></div></div></div><div id="37771545" class="c"><input type="checkbox" id="c-37771545" checked=""/><div class="controls bullet"><span class="by">cvilsmeier</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770660">parent</a><span>|</span><a href="#37770757">prev</a><span>|</span><a href="#37770678">next</a><span>|</span><label class="collapse" for="c-37771545">[-]</label><label class="expand" for="c-37771545">[2 more]</label></div><br/><div class="children"><div class="content">Sqinn author here. Nothing against CGO, but I develop&#x2F;deploy on Win&#x2F;Linux, and cross-compiling CGO is very painful. Regarding performance: To my own surprise, Sqinn out-performs mattn (and others) for normal workloads, see <a href="https:&#x2F;&#x2F;github.com&#x2F;cvilsmeier&#x2F;sqinn-go-bench">https:&#x2F;&#x2F;github.com&#x2F;cvilsmeier&#x2F;sqinn-go-bench</a></div><br/><div id="37771592" class="c"><input type="checkbox" id="c-37771592" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37771545">parent</a><span>|</span><a href="#37770678">next</a><span>|</span><label class="collapse" for="c-37771592">[-]</label><label class="expand" for="c-37771592">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a somewhat unfair (though who cares if it&#x27;s unfair) comparison because you aren&#x27;t using the database&#x2F;sql interface and mattn does.<p>If you drop that interface, you get much better performance.<p>See: <a href="https:&#x2F;&#x2F;github.com&#x2F;eatonphil&#x2F;gosqlite">https:&#x2F;&#x2F;github.com&#x2F;eatonphil&#x2F;gosqlite</a> for example.<p>Edit: Nevermind, you did include crawshaw (which doesn&#x27;t use database&#x2F;sql) in your benchmark!</div><br/></div></div></div></div><div id="37770678" class="c"><input type="checkbox" id="c-37770678" checked=""/><div class="controls bullet"><span class="by">llimllib</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770660">parent</a><span>|</span><a href="#37771545">prev</a><span>|</span><a href="#37772231">next</a><span>|</span><label class="collapse" for="c-37770678">[-]</label><label class="expand" for="c-37770678">[3 more]</label></div><br/><div class="children"><div class="content">the other pain point I know of is that it&#x27;s hard to cross-compile. You can do it with zig[1], but it&#x27;s still not pleasant.<p>1: <a href="https:&#x2F;&#x2F;zig.news&#x2F;kristoff&#x2F;building-sqlite-with-cgo-for-every-os-4cic" rel="nofollow noreferrer">https:&#x2F;&#x2F;zig.news&#x2F;kristoff&#x2F;building-sqlite-with-cgo-for-every...</a></div><br/><div id="37770921" class="c"><input type="checkbox" id="c-37770921" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770678">parent</a><span>|</span><a href="#37771492">next</a><span>|</span><label class="collapse" for="c-37770921">[-]</label><label class="expand" for="c-37770921">[1 more]</label></div><br/><div class="children"><div class="content">Or with musl-cross:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;homebrew-musl-cross">https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;homebrew-musl-cross</a><p>It works pretty well! It&#x27;s a thing you might keep in your back pocket to test builds from your ARM dev machine on a dev host, and then let the CI&#x2F;CD system build the real version later.</div><br/></div></div><div id="37771492" class="c"><input type="checkbox" id="c-37771492" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37770678">parent</a><span>|</span><a href="#37770921">prev</a><span>|</span><a href="#37772231">next</a><span>|</span><label class="collapse" for="c-37771492">[-]</label><label class="expand" for="c-37771492">[1 more]</label></div><br/><div class="children"><div class="content">And Zig only covers a pretty limited range of platforms to start with.</div><br/></div></div></div></div></div></div><div id="37772231" class="c"><input type="checkbox" id="c-37772231" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#37770454">parent</a><span>|</span><a href="#37770660">prev</a><span>|</span><a href="#37772492">next</a><span>|</span><label class="collapse" for="c-37772231">[-]</label><label class="expand" for="c-37772231">[1 more]</label></div><br/><div class="children"><div class="content">Yep, confirming that cznic&#x27;s pure-Go modernc.org&#x2F;sqlite works great.</div><br/></div></div><div id="37772492" class="c"><input type="checkbox" id="c-37772492" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37770454">parent</a><span>|</span><a href="#37772231">prev</a><span>|</span><a href="#37771844">next</a><span>|</span><label class="collapse" for="c-37772492">[-]</label><label class="expand" for="c-37772492">[8 more]</label></div><br/><div class="children"><div class="content">The logic of easy cross compiles doesn&#x27;t really hold up for go translated SQLite. It depends on a huge pile of per platform support code, of varying quality. If you&#x27;re only going to target known working platforms, may as well use cgo and a known working cross compiler.</div><br/><div id="37772627" class="c"><input type="checkbox" id="c-37772627" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772492">parent</a><span>|</span><a href="#37772903">next</a><span>|</span><label class="collapse" for="c-37772627">[-]</label><label class="expand" for="c-37772627">[3 more]</label></div><br/><div class="children"><div class="content">Does compiling to WASM, using a cgo free WASM runtime, and replacing the OS layer (VFS) with portable Go code count?<p>That&#x27;s the elevator pitch (so far) for:
<a href="https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;go-sqlite3&#x2F;tree&#x2F;main">https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;go-sqlite3&#x2F;tree&#x2F;main</a></div><br/><div id="37772764" class="c"><input type="checkbox" id="c-37772764" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772627">parent</a><span>|</span><a href="#37772903">next</a><span>|</span><label class="collapse" for="c-37772764">[-]</label><label class="expand" for="c-37772764">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s cool. :) although probably a bit slower running through an interpreter.<p>Modernc&#x2F;libc takes a rather different approach. It&#x27;s got some pretty funny files in it. <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;libc&#x2F;-&#x2F;blob&#x2F;master&#x2F;musl_openbsd_arm64.go?ref_type=heads" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;libc&#x2F;-&#x2F;blob&#x2F;master&#x2F;musl_openbsd_arm...</a></div><br/><div id="37772805" class="c"><input type="checkbox" id="c-37772805" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772764">parent</a><span>|</span><a href="#37772903">next</a><span>|</span><label class="collapse" for="c-37772805">[-]</label><label class="expand" for="c-37772805">[1 more]</label></div><br/><div class="children"><div class="content">It <i>is</i> slower.<p>The WASM runtime <a href="https:&#x2F;&#x2F;wazero.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;wazero.io</a> has a compiler on amd64 and arm64 (on Linux, macOS, Windows, and FreeBSD), but the current compiler while very fast (at compiling), is very naive (generates less than optimal code).<p>An optimizing compiler is currently being developed, and should be released in the coming months. I&#x27;m optimistic that this compiler <i>will</i> cover the performance gap between WASM and modernc.</div><br/></div></div></div></div></div></div><div id="37772903" class="c"><input type="checkbox" id="c-37772903" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772492">parent</a><span>|</span><a href="#37772627">prev</a><span>|</span><a href="#37771844">next</a><span>|</span><label class="collapse" for="c-37772903">[-]</label><label class="expand" for="c-37772903">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think cznic&#x27;s argument is about cross compiling but just being able to avoid cgo. Since some people really don&#x27;t like cgo.</div><br/><div id="37775643" class="c"><input type="checkbox" id="c-37775643" checked=""/><div class="controls bullet"><span class="by">tw1984</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772903">parent</a><span>|</span><a href="#37772987">next</a><span>|</span><label class="collapse" for="c-37775643">[-]</label><label class="expand" for="c-37775643">[1 more]</label></div><br/><div class="children"><div class="content">when there is no logic behind such &quot;dislike&quot;.<p>people are into programming because things can be reasoned, there is logic behind everything. yet there are non-senses that just try to waste people&#x27;s time &amp; energy by introducing some of their personal briefs backed by no logic into the whole thing.<p>cross-compiling regular c projects like sqlite should never be an excuse, I don&#x27;t believe there is anything that can&#x27;t be scripted when it come to cross-compiling sqlite.</div><br/></div></div><div id="37772987" class="c"><input type="checkbox" id="c-37772987" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772903">parent</a><span>|</span><a href="#37775643">prev</a><span>|</span><a href="#37771844">next</a><span>|</span><label class="collapse" for="c-37772987">[-]</label><label class="expand" for="c-37772987">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I understand what the argument for that is, because I&#x27;ve only ever heard it articulated as &quot;cgo isn&#x27;t go&quot; which doesn&#x27;t really convey much information.<p>Is this go? <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;libc&#x2F;-&#x2F;blob&#x2F;master&#x2F;libc_openbsd.go?ref_type=heads#L1014" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;cznic&#x2F;libc&#x2F;-&#x2F;blob&#x2F;master&#x2F;libc_openbsd.go?...</a><p>I mean technically I suppose it is code that conforms to the go language grammar, but I&#x27;m not sure why a language purist would accept this.</div><br/><div id="37774204" class="c"><input type="checkbox" id="c-37774204" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#37770454">root</a><span>|</span><a href="#37772987">parent</a><span>|</span><a href="#37771844">next</a><span>|</span><label class="collapse" for="c-37774204">[-]</label><label class="expand" for="c-37774204">[1 more]</label></div><br/><div class="children"><div class="content">&quot;cgo isn&#x27;t go&quot; is repeated as a point of religion by some.<p>That said, I have a bunch of QEMU VMs just to compile cgo to platforms like OpenBSD, illumos, macOS, Windows, etc.<p>OpenBSD and such aren&#x27;t <i>that</i> much of a hassle because it performs pretty well and these systems do what I tell them to do, unlike macOS and especially Windows, which are much more annoying and slower because they seem to spend most of their time running searching indexers, virus scanners, updaters, and who knows what, and then maybe perhaps, if the laptop is held at the right angle, and if it so behoves, also decides to spend some CPU cycles to my compiler.<p>Either way, the pain is real, at least for me. Although, yeah, that obviously isn&#x27;t a solution.<p>In general I&#x27;m wary of write&#x2F;translate from langX to langY. At a previous job another team was rewriting ColdFusion code to Go. &quot;ColdFusion with Go syntax&quot; was certainly a creative and novel use of the Go language. Translating from one language to another always seems hard because your brain gets &quot;primed&quot; by the source language, or something, and not all concepts necessarily map all that well in the first place – I have the same translating text, which I&#x27;ve generally found surprisingly hard.</div><br/></div></div></div></div></div></div></div></div><div id="37771844" class="c"><input type="checkbox" id="c-37771844" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#37770454">parent</a><span>|</span><a href="#37772492">prev</a><span>|</span><a href="#37772860">next</a><span>|</span><label class="collapse" for="c-37771844">[-]</label><label class="expand" for="c-37771844">[1 more]</label></div><br/><div class="children"><div class="content">Would it be possible to link a pure go codebase to pre-compiled sqlite binaries and not need to worry about cgo when cross compiling?</div><br/></div></div></div></div><div id="37770486" class="c"><input type="checkbox" id="c-37770486" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37770454">prev</a><span>|</span><label class="collapse" for="c-37770486">[-]</label><label class="expand" for="c-37770486">[4 more]</label></div><br/><div class="children"><div class="content">It’s not 100% Go, though. It forks a process that manages the sqlite file. Since the communication with it is written in go, it avoids using cgo.</div><br/><div id="37775444" class="c"><input type="checkbox" id="c-37775444" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#37770486">parent</a><span>|</span><a href="#37772864">next</a><span>|</span><label class="collapse" for="c-37775444">[-]</label><label class="expand" for="c-37775444">[2 more]</label></div><br/><div class="children"><div class="content">Wow, that sounds incredibly inefficient!</div><br/><div id="37775744" class="c"><input type="checkbox" id="c-37775744" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37770486">root</a><span>|</span><a href="#37775444">parent</a><span>|</span><a href="#37772864">next</a><span>|</span><label class="collapse" for="c-37775744">[-]</label><label class="expand" for="c-37775744">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to run the database in a background process, you may as well run MySQL or one of its derivatives, or Postgres. More concurrency.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>