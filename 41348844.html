<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724662868663" as="style"/><link rel="stylesheet" href="styles.css?v=1724662868663"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://qsantos.fr/2024/08/25/linux-pipes-are-slow/">Linux Pipes Are Slow</a> <span class="domain">(<a href="https://qsantos.fr">qsantos.fr</a>)</span></div><div class="subtext"><span>qsantos</span> | <span>56 comments</span></div><br/><div><div id="41352339" class="c"><input type="checkbox" id="c-41352339" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#41352372">next</a><span>|</span><label class="collapse" for="c-41352339">[-]</label><label class="expand" for="c-41352339">[6 more]</label></div><br/><div class="children"><div class="content">One of my sideprojects is intended to address this: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;976836&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;976836&#x2F;</a><p>The idea is a syscall for getting a ringbuffer for any supported file descriptor, including pipes - and for pipes, if both ends support using the ringbuffer they&#x27;ll map the same ringbuffer: zero copy IO, potentially without calling into the kernel at all.<p>Would love to find collaborators for this one :)</div><br/><div id="41352565" class="c"><input type="checkbox" id="c-41352565" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41352339">parent</a><span>|</span><a href="#41352372">next</a><span>|</span><label class="collapse" for="c-41352565">[-]</label><label class="expand" for="c-41352565">[5 more]</label></div><br/><div class="children"><div class="content">Buffering is there for a reason and this approach will lead to weird failure modes and fragility in scripts. The core issue is that any stream producer might go slower than any given consumer. Even a momentary hiccup will totally mess up the pipe unless there is adequate buffering, and the amount needed is system-dependent.</div><br/><div id="41352730" class="c"><input type="checkbox" id="c-41352730" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#41352339">root</a><span>|</span><a href="#41352565">parent</a><span>|</span><a href="#41352714">next</a><span>|</span><label class="collapse" for="c-41352730">[-]</label><label class="expand" for="c-41352730">[1 more]</label></div><br/><div class="children"><div class="content">I think the OP&#x27;s proposal has buffering.<p>It is different from a pipe - instead of using read&#x2F;write to copy data from&#x2F;to a kernel buffer, it gives user space a mapped buffer object and they need to take care to use it properly (using atomic operations on the head&#x2F;tail and such).<p>If you own the code for the reader and writer, it&#x27;s like using shared memory for a buffer. The proposal is about standardizing an interface.</div><br/></div></div><div id="41352714" class="c"><input type="checkbox" id="c-41352714" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41352339">root</a><span>|</span><a href="#41352565">parent</a><span>|</span><a href="#41352730">prev</a><span>|</span><a href="#41352706">next</a><span>|</span><label class="collapse" for="c-41352714">[-]</label><label class="expand" for="c-41352714">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I misunderstand, but if the ring buffer is full isn&#x27;t it ok for the sender to just block?</div><br/><div id="41354976" class="c"><input type="checkbox" id="c-41354976" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41352339">root</a><span>|</span><a href="#41352714">parent</a><span>|</span><a href="#41352706">next</a><span>|</span><label class="collapse" for="c-41354976">[-]</label><label class="expand" for="c-41354976">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and if the ring buffer is empty it&#x27;s okay for the receiver to just block... exactly as happens today with pipes</div><br/></div></div></div></div><div id="41352706" class="c"><input type="checkbox" id="c-41352706" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41352339">root</a><span>|</span><a href="#41352565">parent</a><span>|</span><a href="#41352714">prev</a><span>|</span><a href="#41352372">next</a><span>|</span><label class="collapse" for="c-41352706">[-]</label><label class="expand" for="c-41352706">[1 more]</label></div><br/><div class="children"><div class="content">What makes this any different than other buffer implementations that have a max size? Buffer fills, writes block. What failure mode are you worried about that can&#x27;t occur with pipes which are also
bounded?</div><br/></div></div></div></div></div></div><div id="41352372" class="c"><input type="checkbox" id="c-41352372" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#41352339">prev</a><span>|</span><a href="#41352480">next</a><span>|</span><label class="collapse" for="c-41352372">[-]</label><label class="expand" for="c-41352372">[12 more]</label></div><br/><div class="children"><div class="content">Calling Linux pipes &quot;slow&quot; is like calling a Toyota Corolla &quot;slow&quot;. It&#x27;s fast enough for all but the most extreme use cases. Are you racing cars? In a sport where speed is more important than technique? Then get a faster car. Otherwise stick to the Corolla.</div><br/><div id="41354575" class="c"><input type="checkbox" id="c-41354575" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#41352372">parent</a><span>|</span><a href="#41354374">next</a><span>|</span><label class="collapse" for="c-41354575">[-]</label><label class="expand" for="c-41354575">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. In the author&#x27;s case, the slow pipe is moving data at 17 GB&#x2F;s which is over 130 gbps.<p>I&#x27;ve used pipes for a lot of stuff over 10+ years, and never noticed being limited by the speed of the pipe, I&#x27;m almost certain to be limited by tar, gzip, find, grep, nc ... (even though these also tend to be pretty fast for what they do).</div><br/></div></div><div id="41354374" class="c"><input type="checkbox" id="c-41354374" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41352372">parent</a><span>|</span><a href="#41354575">prev</a><span>|</span><a href="#41353290">next</a><span>|</span><label class="collapse" for="c-41354374">[-]</label><label class="expand" for="c-41354374">[1 more]</label></div><br/><div class="children"><div class="content">This isn’t code in some project that will run only a few billion times in its lifetime; it is used frequently on millions, if not billions, of computers.<p>Because of that, it is economical to spend lots of time optimizing it, even if it only makes the code marginally more efficient.</div><br/></div></div><div id="41353290" class="c"><input type="checkbox" id="c-41353290" checked=""/><div class="controls bullet"><span class="by">AkBKukU</span><span>|</span><a href="#41352372">parent</a><span>|</span><a href="#41354374">prev</a><span>|</span><a href="#41354553">next</a><span>|</span><label class="collapse" for="c-41353290">[-]</label><label class="expand" for="c-41353290">[7 more]</label></div><br/><div class="children"><div class="content">I have a project that uses a proprietary SDK for decoding raw video. I output the decoded data as pure RGBA in a way FFMpeg can read through a pipe to re-encode the video to a standard codec. FFMpeg can&#x27;t include the Non-Free SDK in their source, and it would be wildly impracticable to store the pure RGBA in a file. So pipes are the only way to do it, there are valid reasons to use high throughput pipes.</div><br/><div id="41354673" class="c"><input type="checkbox" id="c-41354673" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41353290">parent</a><span>|</span><a href="#41353888">next</a><span>|</span><label class="collapse" for="c-41354673">[-]</label><label class="expand" for="c-41354673">[1 more]</label></div><br/><div class="children"><div class="content">What percentage of CPU time is used by the pipe in this scenario? If pipes were 10x faster, would you really notice any difference in wall-clock-time or overall-cpu-usage, while this decoding SDK is generating the raw data and ffmpeg is processing it? Are these video processing steps anywhere near memory copy speeds?</div><br/></div></div><div id="41353888" class="c"><input type="checkbox" id="c-41353888" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41353290">parent</a><span>|</span><a href="#41354673">prev</a><span>|</span><a href="#41353813">next</a><span>|</span><label class="collapse" for="c-41353888">[-]</label><label class="expand" for="c-41353888">[1 more]</label></div><br/><div class="children"><div class="content">Why not just store the output of the proprietary codec in an AVFrame that you&#x27;d pass to libavcodec in your own code?</div><br/></div></div><div id="41353813" class="c"><input type="checkbox" id="c-41353813" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41353290">parent</a><span>|</span><a href="#41353888">prev</a><span>|</span><a href="#41353379">next</a><span>|</span><label class="collapse" for="c-41353813">[-]</label><label class="expand" for="c-41353813">[1 more]</label></div><br/><div class="children"><div class="content"><i>So pipes are the only way to do it</i><p>Lets not get carried away. You can use ffmpeg as a library and encode buffers in a few dozen lines of C++.</div><br/></div></div><div id="41353379" class="c"><input type="checkbox" id="c-41353379" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41353290">parent</a><span>|</span><a href="#41353813">prev</a><span>|</span><a href="#41354553">next</a><span>|</span><label class="collapse" for="c-41353379">[-]</label><label class="expand" for="c-41353379">[3 more]</label></div><br/><div class="children"><div class="content">What about domain sockets?<p>It&#x27;s clumsier, to be sure, but if performance is your goal, the socket should be faster.</div><br/><div id="41353424" class="c"><input type="checkbox" id="c-41353424" checked=""/><div class="controls bullet"><span class="by">AkBKukU</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41353379">parent</a><span>|</span><a href="#41355211">next</a><span>|</span><label class="collapse" for="c-41353424">[-]</label><label class="expand" for="c-41353424">[1 more]</label></div><br/><div class="children"><div class="content">It looks like FFmpeg does support reading from sockets natively[1], I didn&#x27;t know that. That might be a better solution in this case, I&#x27;ll have to look into some C code for writing my output to a socket to try that some time.<p>[1] <a href="https:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-protocols.html#unix" rel="nofollow">https:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-protocols.html#unix</a></div><br/></div></div><div id="41355211" class="c"><input type="checkbox" id="c-41355211" checked=""/><div class="controls bullet"><span class="by">ptx</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41353379">parent</a><span>|</span><a href="#41353424">prev</a><span>|</span><a href="#41354553">next</a><span>|</span><label class="collapse" for="c-41355211">[-]</label><label class="expand" for="c-41355211">[1 more]</label></div><br/><div class="children"><div class="content">Why should sockets be faster?</div><br/></div></div></div></div></div></div><div id="41354553" class="c"><input type="checkbox" id="c-41354553" checked=""/><div class="controls bullet"><span class="by">Ultimatt</span><span>|</span><a href="#41352372">parent</a><span>|</span><a href="#41353290">prev</a><span>|</span><a href="#41352480">next</a><span>|</span><label class="collapse" for="c-41354553">[-]</label><label class="expand" for="c-41354553">[2 more]</label></div><br/><div class="children"><div class="content">A better analogy is its like a society that uses steam trains attempting to industrially compete with a society that uses bullet trains (literally similar by factor of improvement). The UK built its last steam train for national use in 1960, four years later the Shinkansen was in use in Japan. Which of those two nations has a strong international industrial base in 2024?</div><br/><div id="41354807" class="c"><input type="checkbox" id="c-41354807" checked=""/><div class="controls bullet"><span class="by">billfruit</span><span>|</span><a href="#41352372">root</a><span>|</span><a href="#41354553">parent</a><span>|</span><a href="#41352480">next</a><span>|</span><label class="collapse" for="c-41354807">[-]</label><label class="expand" for="c-41354807">[1 more]</label></div><br/><div class="children"><div class="content">Well the Mallard&#x27;s top speed was very close to the first generation Shikansen 0 trains.</div><br/></div></div></div></div></div></div><div id="41352480" class="c"><input type="checkbox" id="c-41352480" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41352372">prev</a><span>|</span><a href="#41352285">next</a><span>|</span><label class="collapse" for="c-41352480">[-]</label><label class="expand" for="c-41352480">[8 more]</label></div><br/><div class="children"><div class="content">This is a side note to the main point being made, but on modern CPUs, &quot;rep movsb&quot; is just as fast as the fastest vectorized version, because the CPU knows to accelerate it. The name of the kernel function &quot;copy_user_enhanced_fast_string&quot; hints at this: the CPU features are ERMS (&quot;Enhanced Repeat Move String&quot;, which makes &quot;rep movsb&quot; faster for anything above a certain length threshold) and FSRM (&quot;Fast Short Repeat Move String&quot;, which makes &quot;rep movsb&quot; faster for shorter moves too).</div><br/><div id="41352733" class="c"><input type="checkbox" id="c-41352733" checked=""/><div class="controls bullet"><span class="by">Lockal</span><span>|</span><a href="#41352480">parent</a><span>|</span><a href="#41352794">next</a><span>|</span><label class="collapse" for="c-41352733">[-]</label><label class="expand" for="c-41352733">[4 more]</label></div><br/><div class="children"><div class="content">This is not the full truth, &quot;rep movsb&quot; is fast until another threshold, after which either normal or non-temporal store is faster.<p>All thresholds are described in <a href="https:&#x2F;&#x2F;codebrowser.dev&#x2F;glibc&#x2F;glibc&#x2F;sysdeps&#x2F;x86_64&#x2F;multiarch&#x2F;memmove-vec-unaligned-erms.S.html#19" rel="nofollow">https:&#x2F;&#x2F;codebrowser.dev&#x2F;glibc&#x2F;glibc&#x2F;sysdeps&#x2F;x86_64&#x2F;multiarch...</a><p>And they are not final, i. e. Noah Goldstein still updates them every year.</div><br/><div id="41354333" class="c"><input type="checkbox" id="c-41354333" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41352480">root</a><span>|</span><a href="#41352733">parent</a><span>|</span><a href="#41353190">next</a><span>|</span><label class="collapse" for="c-41354333">[-]</label><label class="expand" for="c-41354333">[2 more]</label></div><br/><div class="children"><div class="content">It depends on the CPU. There is no good reason for &quot;rep movsb&quot; to be slower at any big enough data size.<p>On a Zen 3 CPU, &quot;rep movsb&quot; becomes faster than or the same as anything else above a length slightly greater than 2 kB.<p>However there is a range of multi-megabyte lengths, which correspond roughly with sizes below the L3 cache but exceeding the L2 cache, where for some weird reason &quot;rep movsb&quot; becomes slower than SIMD non-temporal stores.<p>At lengths exceeding the L3 size, &quot;rep movsb&quot; becomes again the fastest copy method.<p>The Intel CPUs have different behaviors.</div><br/></div></div><div id="41353190" class="c"><input type="checkbox" id="c-41353190" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41352480">root</a><span>|</span><a href="#41352733">parent</a><span>|</span><a href="#41354333">prev</a><span>|</span><a href="#41352794">next</a><span>|</span><label class="collapse" for="c-41353190">[-]</label><label class="expand" for="c-41353190">[1 more]</label></div><br/><div class="children"><div class="content">Which is these is &quot;faster&quot; depends greatly on whether you have the very rare memcpy-only workload, or if your program actually does something useful. Many people believe, often with good evidence, that the most important thing is for memcpy to occupy as few instruction cache lines as is practical, instead of being something that branches all over kilobytes of machine code. For comparison, see the x86 implementations in LLVM libc.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;main&#x2F;libc&#x2F;src&#x2F;string&#x2F;memory_utils&#x2F;x86_64&#x2F;inline_memcpy.h#L158">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;main&#x2F;libc&#x2F;src&#x2F;stri...</a></div><br/></div></div></div></div><div id="41352794" class="c"><input type="checkbox" id="c-41352794" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#41352480">parent</a><span>|</span><a href="#41352733">prev</a><span>|</span><a href="#41352607">next</a><span>|</span><label class="collapse" for="c-41352794">[-]</label><label class="expand" for="c-41352794">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still waiting for rep movsb and rep stosb to be fast enough to delete my simple C loop versions, for short memcpys.</div><br/><div id="41354415" class="c"><input type="checkbox" id="c-41354415" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41352480">root</a><span>|</span><a href="#41352794">parent</a><span>|</span><a href="#41352607">next</a><span>|</span><label class="collapse" for="c-41354415">[-]</label><label class="expand" for="c-41354415">[1 more]</label></div><br/><div class="children"><div class="content">It is likely that on recent CPUs they are always faster than C loop versions.<p>On my Zen 3 CPU, for lengths of 2 kB or smaller it is possible to copy faster than with &quot;rep movsb&quot;, but by using SIMD instructions (or equivalently the builtin &quot;memcpy&quot; provided by most C compilers), not with a C loop (unless the compiler recognizes the C loop and replaces it with the builtin memcpy, which is what some compilers will do at high optimization levels).</div><br/></div></div></div></div><div id="41352607" class="c"><input type="checkbox" id="c-41352607" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41352480">parent</a><span>|</span><a href="#41352794">prev</a><span>|</span><a href="#41352285">next</a><span>|</span><label class="collapse" for="c-41352607">[-]</label><label class="expand" for="c-41352607">[1 more]</label></div><br/><div class="children"><div class="content">Also worth noting that Linux has changed the way it uses ERMS and FSRM in x86 copy multiple times since kernel 6.1 used in the article. As a data-dote, my machine that has FSRM and ERMS — surprisingly, the latter is not implied by the former — hits 17GB&#x2F;s using plain old pipes and a 32KiB buffer on Linux 6.8</div><br/></div></div></div></div><div id="41352285" class="c"><input type="checkbox" id="c-41352285" checked=""/><div class="controls bullet"><span class="by">RevEng</span><span>|</span><a href="#41352480">prev</a><span>|</span><a href="#41351900">next</a><span>|</span><label class="collapse" for="c-41352285">[-]</label><label class="expand" for="c-41352285">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t quite grasp why the original splice has to be so slow. They pointed out what made it slower than vmsplice - in particular allocating buffers and using scalar instructions - but why is this necessary? Why couldn&#x27;t splice just be reimplemented as vmsplice? I&#x27;m sure there is a good reason, but I&#x27;ve missed it.</div><br/><div id="41353314" class="c"><input type="checkbox" id="c-41353314" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41352285">parent</a><span>|</span><a href="#41351900">next</a><span>|</span><label class="collapse" for="c-41353314">[-]</label><label class="expand" for="c-41353314">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why couldn&#x27;t splice just be reimplemented as vmsplice?<p>A possible answer that&#x27;s currently just below your comment:  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41351870">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41351870</a><p>&gt; vmslice doesn&#x27;t work with every type of file descriptor.</div><br/></div></div></div></div><div id="41351900" class="c"><input type="checkbox" id="c-41351900" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#41352285">prev</a><span>|</span><a href="#41355016">next</a><span>|</span><label class="collapse" for="c-41351900">[-]</label><label class="expand" for="c-41351900">[6 more]</label></div><br/><div class="children"><div class="content">Just about every form of IPC is &quot;slow&quot;. You have decided to pay a performance cost for safety.</div><br/><div id="41353203" class="c"><input type="checkbox" id="c-41353203" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41351900">parent</a><span>|</span><a href="#41353840">next</a><span>|</span><label class="collapse" for="c-41353203">[-]</label><label class="expand" for="c-41353203">[3 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t have to pay that much. Pipes give you almost nothing, so they should cost almost nothing.<p>Specifically, there aren&#x27;t many reasons for your fastest IPC to be slower than a long function call.</div><br/><div id="41353633" class="c"><input type="checkbox" id="c-41353633" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#41351900">root</a><span>|</span><a href="#41353203">parent</a><span>|</span><a href="#41353840">next</a><span>|</span><label class="collapse" for="c-41353633">[-]</label><label class="expand" for="c-41353633">[2 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t think pipes offer much, don&#x27;t use them.<p>Saying &quot;long function call&quot; doesn&#x27;t mean much since a function can take infinitely long.</div><br/><div id="41353742" class="c"><input type="checkbox" id="c-41353742" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41351900">root</a><span>|</span><a href="#41353633">parent</a><span>|</span><a href="#41353840">next</a><span>|</span><label class="collapse" for="c-41353742">[-]</label><label class="expand" for="c-41353742">[1 more]</label></div><br/><div class="children"><div class="content">A long distance function call, that invalidates everything on your cache.</div><br/></div></div></div></div></div></div><div id="41353840" class="c"><input type="checkbox" id="c-41353840" checked=""/><div class="controls bullet"><span class="by">brigade</span><span>|</span><a href="#41351900">parent</a><span>|</span><a href="#41353203">prev</a><span>|</span><a href="#41355016">next</a><span>|</span><label class="collapse" for="c-41353840">[-]</label><label class="expand" for="c-41353840">[2 more]</label></div><br/><div class="children"><div class="content">Pipes don’t exist for safety, they exist as an optimization to pass data between existing programs.</div><br/><div id="41353914" class="c"><input type="checkbox" id="c-41353914" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41351900">root</a><span>|</span><a href="#41353840">parent</a><span>|</span><a href="#41355016">next</a><span>|</span><label class="collapse" for="c-41353914">[-]</label><label class="expand" for="c-41353914">[1 more]</label></div><br/><div class="children"><div class="content"><i>NOT</i> writing and reading to and from a file stored on a drive is not, in this context, an optimization, but a significantly freeing conceptual shift that completely transforms how a class of users conducts themselves when using the computer.</div><br/></div></div></div></div></div></div><div id="41355016" class="c"><input type="checkbox" id="c-41355016" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#41351900">prev</a><span>|</span><a href="#41354654">next</a><span>|</span><label class="collapse" for="c-41355016">[-]</label><label class="expand" for="c-41355016">[2 more]</label></div><br/><div class="children"><div class="content">Haha. When I read the title I smiled. Linux pipes slow? Moook.. Now try Cygwin pipes. Thats what I call slow!<p>Anyway, nice article, its good to know whats going on under the hood.</div><br/><div id="41355139" class="c"><input type="checkbox" id="c-41355139" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#41355016">parent</a><span>|</span><a href="#41354654">next</a><span>|</span><label class="collapse" for="c-41355139">[-]</label><label class="expand" for="c-41355139">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d assumed Cygwin pipes are just Windows pipes, is that not the case?</div><br/></div></div></div></div><div id="41354654" class="c"><input type="checkbox" id="c-41354654" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#41355016">prev</a><span>|</span><a href="#41354058">next</a><span>|</span><label class="collapse" for="c-41354654">[-]</label><label class="expand" for="c-41354654">[1 more]</label></div><br/><div class="children"><div class="content">I am again getting the hug of death of Hacker News. The situation is better than the last time thanks to caching WordPress pages, but loading the page can still take a few seconds, so bear with me!</div><br/></div></div><div id="41354058" class="c"><input type="checkbox" id="c-41354058" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#41354654">prev</a><span>|</span><a href="#41354513">next</a><span>|</span><label class="collapse" for="c-41354058">[-]</label><label class="expand" for="c-41354058">[2 more]</label></div><br/><div class="children"><div class="content">How do you gather profiling information for kernel function calls from a user program?</div><br/><div id="41354428" class="c"><input type="checkbox" id="c-41354428" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#41354058">parent</a><span>|</span><a href="#41354513">next</a><span>|</span><label class="collapse" for="c-41354428">[-]</label><label class="expand" for="c-41354428">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll write an article on the flamegraphs specifically, but to get the data, just follow Julia&#x27;s article!<p><a href="https:&#x2F;&#x2F;jvns.ca&#x2F;blog&#x2F;2017&#x2F;03&#x2F;19&#x2F;getting-started-with-ftrace&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jvns.ca&#x2F;blog&#x2F;2017&#x2F;03&#x2F;19&#x2F;getting-started-with-ftrace&#x2F;</a></div><br/></div></div></div></div><div id="41354513" class="c"><input type="checkbox" id="c-41354513" checked=""/><div class="controls bullet"><span class="by">cowsaymoo</span><span>|</span><a href="#41354058">prev</a><span>|</span><a href="#41352065">next</a><span>|</span><label class="collapse" for="c-41354513">[-]</label><label class="expand" for="c-41354513">[1 more]</label></div><br/><div class="children"><div class="content">What is the library used to profile the program?</div><br/></div></div><div id="41352065" class="c"><input type="checkbox" id="c-41352065" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41354513">prev</a><span>|</span><a href="#41351520">next</a><span>|</span><label class="collapse" for="c-41352065">[-]</label><label class="expand" for="c-41352065">[1 more]</label></div><br/><div class="children"><div class="content">So is Python, but I&#x27;m still gonna use it lol</div><br/></div></div><div id="41351520" class="c"><input type="checkbox" id="c-41351520" checked=""/><div class="controls bullet"><span class="by">jheriko</span><span>|</span><a href="#41352065">prev</a><span>|</span><label class="collapse" for="c-41351520">[-]</label><label class="expand" for="c-41351520">[14 more]</label></div><br/><div class="children"><div class="content">just never use pipes. they are some weird archaism that need to die :P<p>the only time ive used them is external constraints. they are just not useful.</div><br/><div id="41351870" class="c"><input type="checkbox" id="c-41351870" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41351520">parent</a><span>|</span><a href="#41351875">next</a><span>|</span><label class="collapse" for="c-41351870">[-]</label><label class="expand" for="c-41351870">[2 more]</label></div><br/><div class="children"><div class="content">&gt; just never use pipes.<p>vmslice doesn&#x27;t work with every type of file descriptor.  eschewing some technology entirely because it seems archaic or because it makes writing &quot;the fastest X software&quot; seem harder is just sloppy engineering.<p>&gt; they are just not useful.<p>Then you have not written enough software yet to discover how they are useful.</div><br/><div id="41352524" class="c"><input type="checkbox" id="c-41352524" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41351870">parent</a><span>|</span><a href="#41351875">next</a><span>|</span><label class="collapse" for="c-41352524">[-]</label><label class="expand" for="c-41352524">[1 more]</label></div><br/><div class="children"><div class="content">Most importantly the fast fizbuz toy vmsplices into &#x2F;dev&#x2F;null.<p>Nothing ever touches those pages on the consumer side and they can be refused immediately.<p>If you actually want a functional program using vmsplice, with a real consumer, things get hairy very quickly.</div><br/></div></div></div></div><div id="41351875" class="c"><input type="checkbox" id="c-41351875" checked=""/><div class="controls bullet"><span class="by">w0m</span><span>|</span><a href="#41351520">parent</a><span>|</span><a href="#41351870">prev</a><span>|</span><a href="#41353953">next</a><span>|</span><label class="collapse" for="c-41351875">[-]</label><label class="expand" for="c-41351875">[1 more]</label></div><br/><div class="children"><div class="content">You can replace a 10k line python or shell script with a single creative line of  pipes&#x2F;xargs&#x2F;etc on the cli.<p>It&#x27;s incredibly valuable on the day to day.</div><br/></div></div><div id="41353953" class="c"><input type="checkbox" id="c-41353953" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41351520">parent</a><span>|</span><a href="#41351875">prev</a><span>|</span><a href="#41352217">next</a><span>|</span><label class="collapse" for="c-41353953">[-]</label><label class="expand" for="c-41353953">[4 more]</label></div><br/><div class="children"><div class="content">I agree with this but with a much more nuanced take: avoid pipes if either reader or writer expects to do async i&#x2F;o and you don&#x27;t own both the reader and writer.<p>In fact if you ever set O_NONBLOCK on a pipe you need to be damn sure both the reader and writer expect non-blocking i&#x2F;o because you&#x27;ll get heisenbugs under heavy i&#x2F;o when either the reader&#x2F;writer outpace each other and one expects blocking i&#x2F;o. When&#x27;s the last time you checked the error code of `printf` and put it in a retry loop?</div><br/><div id="41354310" class="c"><input type="checkbox" id="c-41354310" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41353953">parent</a><span>|</span><a href="#41352217">next</a><span>|</span><label class="collapse" for="c-41354310">[-]</label><label class="expand" for="c-41354310">[3 more]</label></div><br/><div class="children"><div class="content">Genuine question: why does printf need a retry loop when using pipes?</div><br/><div id="41354640" class="c"><input type="checkbox" id="c-41354640" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41354310">parent</a><span>|</span><a href="#41352217">next</a><span>|</span><label class="collapse" for="c-41354640">[-]</label><label class="expand" for="c-41354640">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t that&#x27;s why no one does it.<p>But for pipes what it means is that if whoever is reading or writing the pipe expects non blocking semantics, the other end needs to agree. And if they don&#x27;t you&#x27;ll eventually get an error because the reader or writer outpaced the other, and almost no program handles errors for stdin or stdout.</div><br/><div id="41355003" class="c"><input type="checkbox" id="c-41355003" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41354640">parent</a><span>|</span><a href="#41352217">next</a><span>|</span><label class="collapse" for="c-41355003">[-]</label><label class="expand" for="c-41355003">[1 more]</label></div><br/><div class="children"><div class="content">But even writing to a file doesn&#x27;t guarantee non-blocking semantics. I still don&#x27;t get what is special about pipes.</div><br/></div></div></div></div></div></div></div></div><div id="41352217" class="c"><input type="checkbox" id="c-41352217" checked=""/><div class="controls bullet"><span class="by">hagbard_c</span><span>|</span><a href="#41351520">parent</a><span>|</span><a href="#41353953">prev</a><span>|</span><a href="#41351642">next</a><span>|</span><label class="collapse" for="c-41352217">[-]</label><label class="expand" for="c-41352217">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like telling a builder never to use nails but turn to adhesives instead. He will look at his hammer and his nails as well as a stack of 2x4s, grin and in no time slap together a box into which he will stuff you with a bottle of glue with the advice to now go and play while the grown-ups take care of business.<p>Sure, you could build that box with glue and clamps and ample time, sure it would look neater and weigh less than the version that&#x27;s currently holding you imprisoned and if done right it will even be stronger but it takes more time and effort as well as those glue clamps and other specialised tools to create perfect matching surfaces while the builder just wielded that hammer and those nails and now is building yet another utilitarian piece of work with the same hammer and nails.<p>Sometimes all you need is a hammer and some nails. Or pipes.</div><br/></div></div><div id="41351642" class="c"><input type="checkbox" id="c-41351642" checked=""/><div class="controls bullet"><span class="by">henearkr</span><span>|</span><a href="#41351520">parent</a><span>|</span><a href="#41352217">prev</a><span>|</span><label class="collapse" for="c-41351642">[-]</label><label class="expand" for="c-41351642">[5 more]</label></div><br/><div class="children"><div class="content">Pipes are extremely useful. But I guess it just depends on your use case. I do a lot of scripting.<p>If you dislike their (relative) slowness, it&#x27;s open source, you can participate in making them faster.<p>And I&#x27;m sure that after this HN post we&#x27;ll see some patches and merge requests.</div><br/><div id="41351849" class="c"><input type="checkbox" id="c-41351849" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41351642">parent</a><span>|</span><a href="#41351793">next</a><span>|</span><label class="collapse" for="c-41351849">[-]</label><label class="expand" for="c-41351849">[3 more]</label></div><br/><div class="children"><div class="content">The very thing that makes pipes useful is what also makes them slow. I don&#x27;t think there is much we can do to fix that without breaking POSIX compatibility entirely.<p>Personally I think there&#x27;s much worse ugliness in POSIX than pipes. For example, I&#x27;ve just spent the last couple of days debugging a number of bugs in a shell&#x27;s job control code (`fg`, `bg`, `jobs`, etc).<p>But despite its warts, I&#x27;m still grateful we have something like POSIX to build against.</div><br/><div id="41353311" class="c"><input type="checkbox" id="c-41353311" checked=""/><div class="controls bullet"><span class="by">effie</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41351849">parent</a><span>|</span><a href="#41351793">next</a><span>|</span><label class="collapse" for="c-41353311">[-]</label><label class="expand" for="c-41353311">[2 more]</label></div><br/><div class="children"><div class="content">What possible bugs can there be in those? They are quite simple to use and work as expected.</div><br/><div id="41354753" class="c"><input type="checkbox" id="c-41354753" checked=""/><div class="controls bullet"><span class="by">khafra</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41353311">parent</a><span>|</span><a href="#41351793">next</a><span>|</span><label class="collapse" for="c-41354753">[-]</label><label class="expand" for="c-41354753">[1 more]</label></div><br/><div class="children"><div class="content">They work as expected on Redhat and Debian. &quot;POSIX&quot; leaves open a lot of possibility for less-well-tested systems. They could be writing shellscripts on Minix or HelenOS.</div><br/></div></div></div></div></div></div><div id="41351793" class="c"><input type="checkbox" id="c-41351793" checked=""/><div class="controls bullet"><span class="by">noloblo</span><span>|</span><a href="#41351520">root</a><span>|</span><a href="#41351642">parent</a><span>|</span><a href="#41351849">prev</a><span>|</span><label class="collapse" for="c-41351793">[-]</label><label class="expand" for="c-41351793">[1 more]</label></div><br/><div class="children"><div class="content">+1 yes pipes are what shell scripting quite useful and allow for easy composition of the different unix shell utilities</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>