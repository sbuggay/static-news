<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735290050552" as="style"/><link rel="stylesheet" href="styles.css?v=1735290050552"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://minds.md/zakirullin/cognitive">Cognitive load is what matters</a> <span class="domain">(<a href="https://minds.md">minds.md</a>)</span></div><div class="subtext"><span>zdw</span> | <span>550 comments</span></div><br/><div><div id="42511276" class="c"><input type="checkbox" id="c-42511276" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42511276">[-]</label><label class="expand" for="c-42511276">[170 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking about the notion of &quot;reasoning locally&quot; recently. Enabling local reasoning is the only way to scale software development past some number of lines or complexity. When reasoning locally, one only needs to understand a small subset, hundreds of lines, to safely make changes in programs comprising millions.<p>I find types helps massively with this. A function with well-constrained inputs and outputs is easy to reason about. One does not have to look at other code to do it. However, programs that leverage types effectively are sometimes construed as having high cognitive load, when it in fact they have low load. For example a type like `Option&lt;HashSet&lt;UserId&gt;&gt;` carries a lot of information(has low load): we might not have a set of user ids, but if we do they are unique.<p>The discourse around small functions and the clean code guidelines is fascinating. The complaint is usually, as in this post, that having to go read all the small functions adds cognitive load and makes reading the code harder. Proponents of small functions argue that you don&#x27;t have to read more than the signature and name of a function to understand what it does; it&#x27;s obvious what a function called last that takes a list and returns an optional value does. If someone feels compelled to read every function either the functions are poor abstractions or the reader has trust issues, which may be warranted. Of course, all abstractions are leaky, but perhaps some initial trust in `last` is warranted.</div><br/><div id="42511509" class="c"><input type="checkbox" id="c-42511509" checked=""/><div class="controls bullet"><span class="by">0xFACEFEED</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512310">next</a><span>|</span><label class="collapse" for="c-42511509">[-]</label><label class="expand" for="c-42511509">[96 more]</label></div><br/><div class="children"><div class="content">&gt; A function with well-constrained inputs and outputs is easy to reason about.<p>It&#x27;s quite easy to imagine a well factored codebase where all things are neatly separated. If you&#x27;ve written something a thousand times, like user authentication, then you can plan out exactly how you want to separate everything. But user authentication isn&#x27;t where things get messy.<p>The messy stuff is where the real world concepts need to be transformed into code. Where just the <i>concepts</i> need to be whiteboarded and explained because they&#x27;re unintuitive and confusing. Then these unintuitive and confusing concepts need to somehow described to the computer.<p>Oh, and it needs to be fast. So not only do you need to model an unintuitive and confusing concept - you also need to write it in a convoluted way because, for various annoying reasons, that&#x27;s what performs best on the computer.<p>Oh, and in 6 months the unintuitive and confusing concept needs to be completely changed into - surprise, surprise - a completely different but equally unintuitive and confusing concept.<p>Oh, and you can&#x27;t rewrite everything because there isn&#x27;t enough time or budget to do that. You have to minimally change the current uintuitive and confusing thing so that it works like the new unintuitive and confusing thing is supposed to work.<p>Oh, and the original author doesn&#x27;t work here anymore so no one&#x27;s here to explain the original code&#x27;s intent.</div><br/><div id="42512497" class="c"><input type="checkbox" id="c-42512497" checked=""/><div class="controls bullet"><span class="by">justinram11</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42512497">[-]</label><label class="expand" for="c-42512497">[63 more]</label></div><br/><div class="children"><div class="content">&gt; Oh, and the original author doesn&#x27;t work here anymore so no one&#x27;s here to explain the original code&#x27;s intent.<p>To be fair, even if I still work there I don&#x27;t know that I&#x27;m going to be of much help 6 months later other than a &quot;oh yeah, I remember that had some weird business requirements&quot;</div><br/><div id="42512674" class="c"><input type="checkbox" id="c-42512674" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512497">parent</a><span>|</span><a href="#42512672">next</a><span>|</span><label class="collapse" for="c-42512674">[-]</label><label class="expand" for="c-42512674">[43 more]</label></div><br/><div class="children"><div class="content">Might I recommend writing those weird business requirements down as comments instead of just hoping someone will guess them six months down the line?</div><br/><div id="42513642" class="c"><input type="checkbox" id="c-42513642" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513765">next</a><span>|</span><label class="collapse" for="c-42513642">[-]</label><label class="expand" for="c-42513642">[32 more]</label></div><br/><div class="children"><div class="content">So even if comments are flawlessly updated they are not a silver bullet. Not everyone are good at explaining confusing concepts in plain English so worst case you have confusing code and a comment that is 90% accurate but describe one detail in a way that doesn&#x27;t really match what the code says.  This will make you question if you have understood what the code does and it will take time and effort to convince yourself that code is in fact deterministic and unsurprising.<p>(but most often the comment is is just not updated or updated along with the code but without full understanding, which is what caused the bug that is the reason you are looking at the code in question)</div><br/><div id="42514911" class="c"><input type="checkbox" id="c-42514911" checked=""/><div class="controls bullet"><span class="by">michaelcampbell</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513642">parent</a><span>|</span><a href="#42513738">next</a><span>|</span><label class="collapse" for="c-42514911">[-]</label><label class="expand" for="c-42514911">[13 more]</label></div><br/><div class="children"><div class="content">&gt; So even if comments are flawlessly updated they are not a silver bullet.<p>This &quot;has to be perfect in perpetuity or it is of no value&quot; mentality I don&#x27;t find helpful.<p>Be kind to FutureDev.  Comment the weird &quot;why&quot;s.  If you need to change it later, adjust the comment.</div><br/><div id="42515554" class="c"><input type="checkbox" id="c-42515554" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514911">parent</a><span>|</span><a href="#42517192">next</a><span>|</span><label class="collapse" for="c-42515554">[-]</label><label class="expand" for="c-42515554">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think comments need to be perfect to have value. My point was that if a certain piece of code is solving a particularly confusing problem in the domain, explaining it in a comment doesn&#x27;t _necessarily_ mean the code will be less confusing to future dev if the current developer is not able to capture the issue in plain English. Future dev would be happier I think with putting more effort into refactoring and making the code more readable and clear. When that fails, a &quot;here be dragons&quot; comment is valuable.</div><br/><div id="42515740" class="c"><input type="checkbox" id="c-42515740" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515554">parent</a><span>|</span><a href="#42517192">next</a><span>|</span><label class="collapse" for="c-42515740">[-]</label><label class="expand" for="c-42515740">[4 more]</label></div><br/><div class="children"><div class="content">They can write a very long comment explaining why it is confusing them in X, Y, Z vague ways. Or even multilingual comments if they have better writing skills in another lanaguage.<p>And even if they don’t know themselves why they are confused, they can still describe how they are confused.</div><br/><div id="42516423" class="c"><input type="checkbox" id="c-42516423" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515740">parent</a><span>|</span><a href="#42516923">next</a><span>|</span><label class="collapse" for="c-42516423">[-]</label><label class="expand" for="c-42516423">[1 more]</label></div><br/><div class="children"><div class="content">And any attempt whatsoever is <i>some</i> improvement over doing nothing and wishing luck to the next guy.</div><br/></div></div><div id="42516923" class="c"><input type="checkbox" id="c-42516923" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515740">parent</a><span>|</span><a href="#42516423">prev</a><span>|</span><a href="#42516227">next</a><span>|</span><label class="collapse" for="c-42516923">[-]</label><label class="expand" for="c-42516923">[1 more]</label></div><br/><div class="children"><div class="content">And that time spent writing a small paper in one&#x27;s native language would be better spent trying to make the code speak for itself. Maybe get some help, pair up and tackle the complexity. And when both&#x2F;all involved is like, we can&#x27;t make this any clearer and it&#x27;s still confusing af. _Then_ it&#x27;s time to write that lengthy comment for future poor maintainers.</div><br/></div></div></div></div></div></div><div id="42517192" class="c"><input type="checkbox" id="c-42517192" checked=""/><div class="controls bullet"><span class="by">chairmansteve</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514911">parent</a><span>|</span><a href="#42515554">prev</a><span>|</span><a href="#42515392">next</a><span>|</span><label class="collapse" for="c-42517192">[-]</label><label class="expand" for="c-42517192">[6 more]</label></div><br/><div class="children"><div class="content">Thing is, good documentation has to be part of the company&#x27;s process. eg, a QA engineer would have to be responsible for checking the documentation and certifying it. Costs money and time.<p>You can&#x27;t expect developers, already working 60 hour weeks to meet impossible deadlines, to spend another 15 hours altruistically documenting their code.</div><br/><div id="42519157" class="c"><input type="checkbox" id="c-42519157" checked=""/><div class="controls bullet"><span class="by">ropable</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42517192">parent</a><span>|</span><a href="#42519142">next</a><span>|</span><label class="collapse" for="c-42519157">[-]</label><label class="expand" for="c-42519157">[2 more]</label></div><br/><div class="children"><div class="content">Any documentation at all &gt; no documentation, 99 times out of 100. And requiring your people to work 60 hours&#x2F;week is symptomatic of larger problems.</div><br/><div id="42520153" class="c"><input type="checkbox" id="c-42520153" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42519157">parent</a><span>|</span><a href="#42519142">next</a><span>|</span><label class="collapse" for="c-42520153">[-]</label><label class="expand" for="c-42520153">[1 more]</label></div><br/><div class="children"><div class="content">How about old, out of date documentation that is actively misleading? Because that’s mostly what I run into, and it’s decidedly worse that no documentation.<p>Give me readable code over crappy documentation any day. In an ideal world the docs would be correct all of the time, apparently I don’t live in that world, and I’ve grown tired of listening to those who claim we just need to try harder.</div><br/></div></div></div></div><div id="42519142" class="c"><input type="checkbox" id="c-42519142" checked=""/><div class="controls bullet"><span class="by">yearolinuxdsktp</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42517192">parent</a><span>|</span><a href="#42519157">prev</a><span>|</span><a href="#42517698">next</a><span>|</span><label class="collapse" for="c-42519142">[-]</label><label class="expand" for="c-42519142">[1 more]</label></div><br/><div class="children"><div class="content">Every line of documentation is a line of code and is a liability as it will rot if not maintained. That’s why you should be writing self documenting code as much as possible that’s obviates the need for documentation. But unlike code, stale&#x2F;wrong doc will not break tests.<p>Spending 15 hours documenting the code is something no leader should be asking of engineering to do. You should not need to do it. Go back and write better code, one That’s more clear at a glance, easily readable, uses small functions written at a comparable level of abstraction, uses clear, semantically meaningful names.<p>Before you write a line of documentation, you should ask yourself whether the weird thing you were about to document can be expressed directly in the name of the method of the variable instead. Only once you have exhausted all the options for expressing the concept in  code, then, only then, are you allowed to add the line of the documentation regarding it.</div><br/></div></div><div id="42517698" class="c"><input type="checkbox" id="c-42517698" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42517192">parent</a><span>|</span><a href="#42519142">prev</a><span>|</span><a href="#42518944">next</a><span>|</span><label class="collapse" for="c-42517698">[-]</label><label class="expand" for="c-42517698">[1 more]</label></div><br/><div class="children"><div class="content">Or you know, work the devs 40 hour weeks and make sure documentation is valued. Everything costs one way or another, it&#x27;s all trade-off turtles all the way down.</div><br/></div></div><div id="42518944" class="c"><input type="checkbox" id="c-42518944" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42517192">parent</a><span>|</span><a href="#42517698">prev</a><span>|</span><a href="#42515392">next</a><span>|</span><label class="collapse" for="c-42518944">[-]</label><label class="expand" for="c-42518944">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t let perfect be the enemy of good.<p>&quot;We don&#x27;t write any documentation because we can&#x27;t afford a dedicated QA process to certify it&quot; &lt;- that&#x27;s dumb.</div><br/></div></div></div></div><div id="42515392" class="c"><input type="checkbox" id="c-42515392" checked=""/><div class="controls bullet"><span class="by">bccdee</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514911">parent</a><span>|</span><a href="#42517192">prev</a><span>|</span><a href="#42513738">next</a><span>|</span><label class="collapse" for="c-42515392">[-]</label><label class="expand" for="c-42515392">[1 more]</label></div><br/><div class="children"><div class="content">Yeah: &quot;what if this code becomes tech debt later&quot; applies to everything, not just comments. It&#x27;s a tradeoff.<p>The best thing you can do to avoid creating debt for later maintainers is to write code that&#x27;s easy to delete, and adding comments helps with that.</div><br/></div></div></div></div><div id="42513738" class="c"><input type="checkbox" id="c-42513738" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513642">parent</a><span>|</span><a href="#42514911">prev</a><span>|</span><a href="#42515465">next</a><span>|</span><label class="collapse" for="c-42513738">[-]</label><label class="expand" for="c-42513738">[10 more]</label></div><br/><div class="children"><div class="content">An outdated comment is still a datapoint! Including if the comment was wrong when it was first written!<p>We live in a world with version history, repositories with change requests, communications… code comments are a part of that ecosystem.<p>A comment that is outright incorrect at inception is still valuable even if it is at least an attempt by the writer to describe their internal understanding of things.</div><br/><div id="42514495" class="c"><input type="checkbox" id="c-42514495" checked=""/><div class="controls bullet"><span class="by">more-coffee</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513738">parent</a><span>|</span><a href="#42514740">next</a><span>|</span><label class="collapse" for="c-42514495">[-]</label><label class="expand" for="c-42514495">[3 more]</label></div><br/><div class="children"><div class="content">This. I have argued with plenty of developers on why comments are useful, and the counter arguments are always the same.<p>I believe it boils down to a lack of foresight. At some point in time, someone is going to revisit your code, and even just a small `&#x2F;&#x2F; Sorry this is awful, we have to X but this was difficult because of Y` will go a long way.<p>While I (try to) have very fluid opinions in all aspects of programming, the usefulness of comments is not something I (think!) I&#x27;ll ever budge on. :)</div><br/><div id="42515255" class="c"><input type="checkbox" id="c-42515255" checked=""/><div class="controls bullet"><span class="by">temporallobe</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514495">parent</a><span>|</span><a href="#42514740">next</a><span>|</span><label class="collapse" for="c-42515255">[-]</label><label class="expand" for="c-42515255">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &#x2F;&#x2F; Sorry this is awful, we have to X but this was difficult because of Y<p>You don’t know how many times I’ve seen this with a cute little GitLens inline message of “Brian Smith, 10 years ago”. If Brian couldn’t figure it out 10 years ago, I’m not likely going to attempt it either, especially if it has been working for 10 years.</div><br/><div id="42515372" class="c"><input type="checkbox" id="c-42515372" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515255">parent</a><span>|</span><a href="#42514740">next</a><span>|</span><label class="collapse" for="c-42515372">[-]</label><label class="expand" for="c-42515372">[1 more]</label></div><br/><div class="children"><div class="content">But knowing what Brian was considering at the time is useful, both due avoiding redoing that and for realising that some constraints may have been lifted.</div><br/></div></div></div></div></div></div><div id="42514740" class="c"><input type="checkbox" id="c-42514740" checked=""/><div class="controls bullet"><span class="by">xnx</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513738">parent</a><span>|</span><a href="#42514495">prev</a><span>|</span><a href="#42516008">next</a><span>|</span><label class="collapse" for="c-42514740">[-]</label><label class="expand" for="c-42514740">[1 more]</label></div><br/><div class="children"><div class="content">We should call them code clues</div><br/></div></div><div id="42516008" class="c"><input type="checkbox" id="c-42516008" checked=""/><div class="controls bullet"><span class="by">buttercraft</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513738">parent</a><span>|</span><a href="#42514740">prev</a><span>|</span><a href="#42515209">next</a><span>|</span><label class="collapse" for="c-42516008">[-]</label><label class="expand" for="c-42516008">[3 more]</label></div><br/><div class="children"><div class="content">What if you don&#x27;t know that the comment is wrong?</div><br/><div id="42516754" class="c"><input type="checkbox" id="c-42516754" checked=""/><div class="controls bullet"><span class="by">lexicality</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516008">parent</a><span>|</span><a href="#42518394">next</a><span>|</span><label class="collapse" for="c-42516754">[-]</label><label class="expand" for="c-42516754">[1 more]</label></div><br/><div class="children"><div class="content">IMO the only thing you can assume is that the person who wrote the comment wasn&#x27;t actively trying to deceive you. You should treat all documentation, comments, function names, commit messages etc with a healthy dose of scepticism because no one truly has a strong grip on reality.</div><br/></div></div><div id="42518394" class="c"><input type="checkbox" id="c-42518394" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516008">parent</a><span>|</span><a href="#42516754">prev</a><span>|</span><a href="#42515209">next</a><span>|</span><label class="collapse" for="c-42518394">[-]</label><label class="expand" for="c-42518394">[1 more]</label></div><br/><div class="children"><div class="content">Right, unlike code (which does what it does, even if that isn&#x27;t what the writer meant) there&#x27;s no real feedback loop for comments. Still worth internalizing the info based on that IMO.<p>&quot;This does X&quot; as a comment when it in fact does Y in condition Z means that the probability you are looking at a bug goes up a bit! Without the comment you might not be able to identify that Y is not intentional.<p>Maybe Y is intentional! In which case the comment that &quot;this is intentional&quot; is helpful. Perhaps the intentionality is also incorrect, and that&#x27;s yet another data point!<p>Fairly rare for there to be negative value in comments.</div><br/></div></div></div></div><div id="42515209" class="c"><input type="checkbox" id="c-42515209" checked=""/><div class="controls bullet"><span class="by">temporallobe</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513738">parent</a><span>|</span><a href="#42516008">prev</a><span>|</span><a href="#42515465">next</a><span>|</span><label class="collapse" for="c-42515209">[-]</label><label class="expand" for="c-42515209">[2 more]</label></div><br/><div class="children"><div class="content">It just occurred to me that perhaps this is where AI might prove useful. Functions could have some kind of annotation that triggers AI
to analyze the function and explain it plain language when you do something like hover over the function name in the IDE, or, you can have a prompt where you can interact with that piece of code and ask it questions. Obviously  this would mean developer-written comments would be less likely to make it into the commit history, but it might be better than nothing, especially in older codebases where the original developer(s) are long gone. Maybe this already exists, but I’m too lazy to research that right now.</div><br/><div id="42515348" class="c"><input type="checkbox" id="c-42515348" checked=""/><div class="controls bullet"><span class="by">bccdee</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515209">parent</a><span>|</span><a href="#42515465">next</a><span>|</span><label class="collapse" for="c-42515348">[-]</label><label class="expand" for="c-42515348">[1 more]</label></div><br/><div class="children"><div class="content">But then could you trust it not to hallucinate functionality that doesn&#x27;t exist? Seems as risky as out-of-date comments, if not more<p>What I&#x27;d really like is an AI linter than noticed if you&#x27;ve changed some functionality referenced in a comment without updating that comment. Then, the worst-case scenario is that it doesn&#x27;t notice, and we&#x27;re back where we started.</div><br/></div></div></div></div></div></div><div id="42515465" class="c"><input type="checkbox" id="c-42515465" checked=""/><div class="controls bullet"><span class="by">Zondartul</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513642">parent</a><span>|</span><a href="#42513738">prev</a><span>|</span><a href="#42516233">next</a><span>|</span><label class="collapse" for="c-42515465">[-]</label><label class="expand" for="c-42515465">[1 more]</label></div><br/><div class="children"><div class="content">Comments that explain the intent, rather than implementation, are the more useful kind. And when intent doesn&#x27;t match the actual code, that&#x27;s a good hint - it might be why the code doesn&#x27;t work.</div><br/></div></div><div id="42516233" class="c"><input type="checkbox" id="c-42516233" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513642">parent</a><span>|</span><a href="#42515465">prev</a><span>|</span><a href="#42513765">next</a><span>|</span><label class="collapse" for="c-42516233">[-]</label><label class="expand" for="c-42516233">[7 more]</label></div><br/><div class="children"><div class="content">If a developer can’t write intelligible comments or straightforward code, then I’d argue they should find another job.</div><br/><div id="42516280" class="c"><input type="checkbox" id="c-42516280" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516233">parent</a><span>|</span><a href="#42516301">next</a><span>|</span><label class="collapse" for="c-42516280">[-]</label><label class="expand" for="c-42516280">[4 more]</label></div><br/><div class="children"><div class="content">I mean it&#x27;s easy to say silly things like this, but in reality most developers suck in one way or another.<p>In addition companies don&#x27;t seem to give a shit about straightforward code, they want LOC per day and the cheapest price possible which leads to tons of crap code.</div><br/><div id="42516488" class="c"><input type="checkbox" id="c-42516488" checked=""/><div class="controls bullet"><span class="by">hallway_monitor</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516280">parent</a><span>|</span><a href="#42516857">next</a><span>|</span><label class="collapse" for="c-42516488">[-]</label><label class="expand" for="c-42516488">[2 more]</label></div><br/><div class="children"><div class="content">Each person has their own strengths, but a worthwhile team member should be able to meet minimum requirements of readability and comments. This can be enforced through team agreements and peer review.<p>Your second point is really the crux of business in a lot of ways. The balance of quality versus quantity. Cost versus value. Long-term versus short term gains. I’m sure there are situations where ruthlessly prioritizing short term profit through low cost code is indeed the optimal solution. For those of us who love to craft high-quality code, the trick is finding the companies where it is understood and agreed that long-term value from high-quality code is worth the upfront investment and, more importantly, where they have the cash to make that investment.</div><br/><div id="42516915" class="c"><input type="checkbox" id="c-42516915" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516488">parent</a><span>|</span><a href="#42516857">next</a><span>|</span><label class="collapse" for="c-42516915">[-]</label><label class="expand" for="c-42516915">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I’m sure there are situations where ruthlessly prioritizing short term profit through low cost code is indeed the optimal solution<p>This is mostly how large publicly traded corps work, unless they are ran by programmers that want great applications or are required by law, they tend to write a lot of crap.</div><br/></div></div></div></div><div id="42516857" class="c"><input type="checkbox" id="c-42516857" checked=""/><div class="controls bullet"><span class="by">mlloyd</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516280">parent</a><span>|</span><a href="#42516488">prev</a><span>|</span><a href="#42516301">next</a><span>|</span><label class="collapse" for="c-42516857">[-]</label><label class="expand" for="c-42516857">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In addition companies don&#x27;t seem to give a shit about straightforward code, they want LOC per day and the cheapest price possible which leads to tons of crap code.<p>Companies don&#x27;t care about LOC, they care about solving problems. 30 LOC or 30k LOC doesn&#x27;t matter much MOST of the time. They&#x27;re just after a solution that puts the problem to rest.</div><br/></div></div></div></div><div id="42516301" class="c"><input type="checkbox" id="c-42516301" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516233">parent</a><span>|</span><a href="#42516280">prev</a><span>|</span><a href="#42513765">next</a><span>|</span><label class="collapse" for="c-42516301">[-]</label><label class="expand" for="c-42516301">[2 more]</label></div><br/><div class="children"><div class="content">If a delivery company has four different definitions of a customer’s first order, and the resulting code has contents that are hard to parse - does the Blake lie with the developer, or the requirements?</div><br/><div id="42516544" class="c"><input type="checkbox" id="c-42516544" checked=""/><div class="controls bullet"><span class="by">TrololoTroll</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516301">parent</a><span>|</span><a href="#42513765">next</a><span>|</span><label class="collapse" for="c-42516544">[-]</label><label class="expand" for="c-42516544">[1 more]</label></div><br/><div class="children"><div class="content">If the developer had time to do it, with him. Otherwise with the company<p>I&#x27;m sure there&#x27;s some abysmal shit that&#x27;s extremely hard to properly abstract. Usually the dev just sucks or they didn&#x27;t have time to make the code not suck</div><br/></div></div></div></div></div></div></div></div><div id="42513765" class="c"><input type="checkbox" id="c-42513765" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513642">prev</a><span>|</span><a href="#42513646">next</a><span>|</span><label class="collapse" for="c-42513765">[-]</label><label class="expand" for="c-42513765">[1 more]</label></div><br/><div class="children"><div class="content">Business requirements deviate from code almost immediately. Serving several clients with customisation adds even more strain on the process. Eventually you want to map paragraphs of business req to code which is not a 1:1 mapping.<p>Aging codebase and the ongoing operations make it even harder to maintain consistently. eventually people surrender.</div><br/></div></div><div id="42513646" class="c"><input type="checkbox" id="c-42513646" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513765">prev</a><span>|</span><a href="#42514955">next</a><span>|</span><label class="collapse" for="c-42513646">[-]</label><label class="expand" for="c-42513646">[3 more]</label></div><br/><div class="children"><div class="content">Then in 3 months someone in between came changing the code slightly that makes comment obsolete but doesn’t update the comment. Making all worse not better.<p>Issue trackers are much better because then in git you can find tickets attached to the change.<p>No ticket explaining why - no code change.<p>Why not in repo? because business people write tickets not devs. Then tickets are passed to QA who also does read the code but also need that information.</div><br/><div id="42516410" class="c"><input type="checkbox" id="c-42516410" checked=""/><div class="controls bullet"><span class="by">jounker</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513646">parent</a><span>|</span><a href="#42514955">next</a><span>|</span><label class="collapse" for="c-42516410">[-]</label><label class="expand" for="c-42516410">[2 more]</label></div><br/><div class="children"><div class="content">Why did the reviewer approve the change if the developer didn’t update the comment?<p>It sounds like people are failing at their jobs.</div><br/><div id="42517339" class="c"><input type="checkbox" id="c-42517339" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516410">parent</a><span>|</span><a href="#42514955">next</a><span>|</span><label class="collapse" for="c-42517339">[-]</label><label class="expand" for="c-42517339">[1 more]</label></div><br/><div class="children"><div class="content">Oh that is one of my pet peeves.<p>&quot;If only people would do their jobs properly&quot;.<p>So we just fire all the employees and hire better ones only because someone did not pay attention to the comment.<p>Of course it is an exaggeration - but also in the same line people who think &quot;others are failing at their jobs&quot; - should pick up and do all the work there is to be done and see how long they go until they miss something or make a mistake.<p>Solution should be systematic to prevent people from failing and not expecting &quot;someone doing their job properly&quot;.<p>Not having comments as something that needs a review reduces workload on everyone involved.<p>Besides, interfaces for PRs they clearly mark what changed - they don&#x27;t point what hasn&#x27;t been changed. So naturally people review what has changed. You still get the context of course and can see couple lines above and below... But still I blame the tool not people.</div><br/></div></div></div></div></div></div><div id="42514955" class="c"><input type="checkbox" id="c-42514955" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513646">prev</a><span>|</span><a href="#42514313">next</a><span>|</span><label class="collapse" for="c-42514955">[-]</label><label class="expand" for="c-42514955">[4 more]</label></div><br/><div class="children"><div class="content">Requirements should be in the JIRA. JIRA number should be in the commit message.<p>You do git blame and you see why each line is what it is.<p>Comments are nice too, but they tend to lie the older they are. Git blame never lies.</div><br/><div id="42515089" class="c"><input type="checkbox" id="c-42515089" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514955">parent</a><span>|</span><a href="#42515806">next</a><span>|</span><label class="collapse" for="c-42515089">[-]</label><label class="expand" for="c-42515089">[2 more]</label></div><br/><div class="children"><div class="content">A code tends to be reused. When it happens jira is not likely to travel alongside the code. All &#x27;older&#x27; jira tickets are useless broken links. All you have in practice is jira name. It usually happen with &#x27;internal documentation&#x27; links as well.<p>Git blame often lies when big merge was squashed. I mostly had these in Perforce so I might be wrong. Also when code travels between source version control servers and different source version control software it also loses information.<p>I would say in my gamedev practical experience the best comments I saw  are
TODO implement me and (unit) test code that still runs. First clearly states that you have reached outside of what was planned before and 2nd allows you to inspect what code meant to do.</div><br/><div id="42516445" class="c"><input type="checkbox" id="c-42516445" checked=""/><div class="controls bullet"><span class="by">jounker</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515089">parent</a><span>|</span><a href="#42515806">next</a><span>|</span><label class="collapse" for="c-42516445">[-]</label><label class="expand" for="c-42516445">[1 more]</label></div><br/><div class="children"><div class="content">One of my favorite conventions is ‘TODO(username): some comment’. This lets attribution survive merges and commits and lets you search for all of someone’s comments using a grep.</div><br/></div></div></div></div><div id="42515806" class="c"><input type="checkbox" id="c-42515806" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514955">parent</a><span>|</span><a href="#42515089">prev</a><span>|</span><a href="#42514313">next</a><span>|</span><label class="collapse" for="c-42515806">[-]</label><label class="expand" for="c-42515806">[1 more]</label></div><br/><div class="children"><div class="content">Jira entries get wiped arbitrarily. Git blame may not lie, but it doesn&#x27;t survive larger organizational &quot;refactoring&quot; around team or company mergers. Or refactoring code <i>out</i> into separate project&#x2F;library. Hell, often enough it doesn&#x27;t survive commits that rename bunch of files and move other stuff around.</div><br/></div></div></div></div><div id="42514313" class="c"><input type="checkbox" id="c-42514313" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42514955">prev</a><span>|</span><a href="#42512672">next</a><span>|</span><label class="collapse" for="c-42514313">[-]</label><label class="expand" for="c-42514313">[2 more]</label></div><br/><div class="children"><div class="content">Comments are decent but flawed. Being a type proponent I think the best strategy is lifting business requirements into the type system, encoding the invariants in a way that the compiler can check.</div><br/><div id="42515385" class="c"><input type="checkbox" id="c-42515385" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514313">parent</a><span>|</span><a href="#42512672">next</a><span>|</span><label class="collapse" for="c-42515385">[-]</label><label class="expand" for="c-42515385">[1 more]</label></div><br/><div class="children"><div class="content">Comments should describe what the type system can&#x27;t. Connect, pitfalls, workarounds for bugs in other code, etc.</div><br/></div></div></div></div></div></div><div id="42512672" class="c"><input type="checkbox" id="c-42512672" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512497">parent</a><span>|</span><a href="#42512674">prev</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42512672">[-]</label><label class="expand" for="c-42512672">[19 more]</label></div><br/><div class="children"><div class="content">Thank god we’re held to such low standards. Every time I’ve worked in a field like pharmaceuticals or manufacturing, the documentation burden felt overwhelming by comparison and a shrug six months later would never fly.</div><br/><div id="42512923" class="c"><input type="checkbox" id="c-42512923" checked=""/><div class="controls bullet"><span class="by">mnau</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512672">parent</a><span>|</span><a href="#42516147">next</a><span>|</span><label class="collapse" for="c-42512923">[-]</label><label class="expand" for="c-42512923">[10 more]</label></div><br/><div class="children"><div class="content">We are not engineers. We are craftsmen, instead of working with wood, we work with code. What most customers want is an equivalent of &quot;I need a chair, it should look roughly like this.&quot;<p>If they want blueprints and documentation (e.g. maximum possible load and other limits), we can supply (and do supply, e.g. in pharma or medicine), but it will cost them quite a lot more. By the order of magnitude. Most customers prefer cobbled up solution that is cheap and works. That&#x27;s on them.<p>Edit: It is called waterfall. There is nothing inherently wrong with it, except customers didn&#x27;t like the time it took to implement a change. And they want changes all the time.</div><br/><div id="42514072" class="c"><input type="checkbox" id="c-42514072" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512923">parent</a><span>|</span><a href="#42516147">next</a><span>|</span><label class="collapse" for="c-42514072">[-]</label><label class="expand" for="c-42514072">[9 more]</label></div><br/><div class="children"><div class="content">&gt; We are not engineers. We are craftsmen<p>Same difference. Both appellations invoke some sort of idealized professional standards and the conversation is about failing these standards not upholding them. We&#x27;re clearly very short of deserving a title that carries any sort of professional pride in it. We are making a huge mess of the world building systems that hijack attention for profit and generate numerous opportunities for bad agents in the form of security shortfalls or opportunities to exploit people using machines and code.<p>If we had any sort of pride of craft or professional standards we wouldn&#x27;t be pumping out the bug ridden mess that software&#x27;s become and trying to figure out why in this conversation.</div><br/><div id="42514394" class="c"><input type="checkbox" id="c-42514394" checked=""/><div class="controls bullet"><span class="by">alternatex</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514072">parent</a><span>|</span><a href="#42515416">next</a><span>|</span><label class="collapse" for="c-42514394">[-]</label><label class="expand" for="c-42514394">[4 more]</label></div><br/><div class="children"><div class="content">That is quite a cynical take. A lot of us take pride in our work and actively avoid companies that produce software that is detrimental to society.</div><br/><div id="42514420" class="c"><input type="checkbox" id="c-42514420" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514394">parent</a><span>|</span><a href="#42515416">next</a><span>|</span><label class="collapse" for="c-42514420">[-]</label><label class="expand" for="c-42514420">[3 more]</label></div><br/><div class="children"><div class="content">It is cynical but it is also a generalization better supported by the evidence than &quot;we&#x27;re craftsmen&quot; or &quot;we&#x27;re engineers&quot;.<p>If you can say &quot;I&#x27;m a craftsman&quot; or &quot;I&#x27;m an engineer&quot; all the power to you. Sadly I don&#x27;t think we can say that in the collective form.</div><br/><div id="42516653" class="c"><input type="checkbox" id="c-42516653" checked=""/><div class="controls bullet"><span class="by">nyarlathotep_</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514420">parent</a><span>|</span><a href="#42515416">next</a><span>|</span><label class="collapse" for="c-42516653">[-]</label><label class="expand" for="c-42516653">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you can say &quot;I&#x27;m a craftsman&quot; or &quot;I&#x27;m an engineer&quot; all the power to you. Sadly I don&#x27;t think we can say that in the collective form.<p>My cynicism of the software &quot;profession&quot; is entirely a function of experience, and these titles are the (very rare) exception.<p>The norm is low-quality, low complexity disposable code.</div><br/><div id="42518947" class="c"><input type="checkbox" id="c-42518947" checked=""/><div class="controls bullet"><span class="by">computerdork</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516653">parent</a><span>|</span><a href="#42515416">next</a><span>|</span><label class="collapse" for="c-42518947">[-]</label><label class="expand" for="c-42518947">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, thinking back, think most companies I worked (from the small to the very large tech companies) had on average pretty good code and automated tests, pretty good processes, pretty good cultures and pretty good architectures. Some were very weak with one aspect, but made up for it others. But maybe I got lucky?</div><br/></div></div></div></div></div></div></div></div><div id="42515416" class="c"><input type="checkbox" id="c-42515416" checked=""/><div class="controls bullet"><span class="by">mnau</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514072">parent</a><span>|</span><a href="#42514394">prev</a><span>|</span><a href="#42516147">next</a><span>|</span><label class="collapse" for="c-42515416">[-]</label><label class="expand" for="c-42515416">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Both appellations invoke some sort of idealized professional standards<p>The key point of the comment was that engineers do have standards, both from professional bodies and often legislative ones. Craftsmen do not have such standards (most of them, at least where I am from). Joiners definitely don&#x27;t.<p>Edit: I would also disagree with &quot;pumping out bug ridden mess that software&#x27;s become.&quot;<p>We are miles ahead in security of any other industry. Physical locks have been broken for decades and nobody cares. Windows are breakable by a rock or a hammer and nobody cares.<p>In terms of bugs, that is extraordinary low as well. In pretty much any other industry, it would be considered a user error, e.g. do not put mud as a detergent into the washing machine.<p>Whole process is getting better each year. Version control wasn&#x27;t common in 2000s (I think Linux didn&#x27;t use version control until 2002).  CI&#x2F;CD. Security analyzers. Memory managed&#x2F;safe languages. Automatic testing. Refactoring tools.<p>We somehow make hundreds of millions of lines of code work together. I seriously doubt there is any industry that can do that at our price point.</div><br/><div id="42516393" class="c"><input type="checkbox" id="c-42516393" checked=""/><div class="controls bullet"><span class="by">generic92034</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515416">parent</a><span>|</span><a href="#42516147">next</a><span>|</span><label class="collapse" for="c-42516393">[-]</label><label class="expand" for="c-42516393">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We are miles ahead in security of any other industry. Physical locks have been broken for decades and nobody cares. Windows are breakable by a rock or a hammer and nobody cares.<p>That is not such a great analogy, in my opinion. If burglars could remotely break into many houses in parallel while being mostly non-trackable and staying in the safety of their own home, things would look differently on the doors and windows front.</div><br/><div id="42516830" class="c"><input type="checkbox" id="c-42516830" checked=""/><div class="controls bullet"><span class="by">mnau</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516393">parent</a><span>|</span><a href="#42516147">next</a><span>|</span><label class="collapse" for="c-42516830">[-]</label><label class="expand" for="c-42516830">[2 more]</label></div><br/><div class="children"><div class="content">The reason why car keys are using chips is because physical safety sucks so much in comparison with digital.<p>The fact is we are better at it because of failure of state to establish the safe environment. Generally protection and safe environment is one of reason for paying taxes.</div><br/><div id="42518673" class="c"><input type="checkbox" id="c-42518673" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516830">parent</a><span>|</span><a href="#42516147">next</a><span>|</span><label class="collapse" for="c-42518673">[-]</label><label class="expand" for="c-42518673">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The reason why car keys are using chips is because physical safety sucks so much in comparison with digital.<p>Not the reason. There is no safe lock, chip or not. You can only make it more inconvenient then the next car to break in.<p>&gt; The fact is we are better at it because of failure of state to establish the safe environment. Generally protection and safe environment is one of reason for paying taxes.<p>Exactly backwards. The only real safety is being in a hi-sec zone protected by social convention and State retribution. The best existing lock in a place where bad actors have latitude won&#x27;t protect you, and in a safe space you barely need locks at all.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42516147" class="c"><input type="checkbox" id="c-42516147" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512672">parent</a><span>|</span><a href="#42512923">prev</a><span>|</span><a href="#42512817">next</a><span>|</span><label class="collapse" for="c-42516147">[-]</label><label class="expand" for="c-42516147">[1 more]</label></div><br/><div class="children"><div class="content">OTOH, the level of documentation you get for free from source control would be a godsend in other contexts: the majority of the documentation you see in other processes is just to get an idea of what changed when and why.</div><br/></div></div><div id="42512817" class="c"><input type="checkbox" id="c-42512817" checked=""/><div class="controls bullet"><span class="by">Yiin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512672">parent</a><span>|</span><a href="#42516147">prev</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42512817">[-]</label><label class="expand" for="c-42512817">[7 more]</label></div><br/><div class="children"><div class="content">there is difference between building a dashboard for internal systems and tech that if failed can kill people</div><br/><div id="42512847" class="c"><input type="checkbox" id="c-42512847" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512817">parent</a><span>|</span><a href="#42513282">next</a><span>|</span><label class="collapse" for="c-42512847">[-]</label><label class="expand" for="c-42512847">[1 more]</label></div><br/><div class="children"><div class="content">Most software work in pharma and manufacturing is still CRUD, they just have cultures of rigorous documentation that permeates the industry even when it&#x27;s low value. Documenting every little change made sense when I was programming the robotics for a genetic diagnostics pipeline, not so much when I had to write a one pager justifying a one line fix to the parser for the configuration format or updating some LIMS dependency to fix a vulnerability in an internal tool that&#x27;s not even open to the internet.</div><br/></div></div><div id="42513282" class="c"><input type="checkbox" id="c-42513282" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512817">parent</a><span>|</span><a href="#42512847">prev</a><span>|</span><a href="#42513770">next</a><span>|</span><label class="collapse" for="c-42513282">[-]</label><label class="expand" for="c-42513282">[4 more]</label></div><br/><div class="children"><div class="content">Well, a hand watch or a chair cannot kill people, but the manufacturing documentation for them will be very precise.<p>Software development is not engineering because it is still relatively young and immature field. There is a joke where a mathematician, a physicist and a engineer are given a little red rubber ball and asked to find its volume. The mathematician measures the diameter and computes, the physicist immerses the ball into water and sees how much was displaced, and an the engineer looks it up in his &quot;Little red rubber balls&quot; reference.<p>Software development does not yet have anything that may even potentially grow into such a reference. If we decide to write it we would not even know where to start. We have mathematicians who write computer science papers; or physicists who test programs; standup comedians, philosophers, everyone. But not engineers.</div><br/><div id="42513952" class="c"><input type="checkbox" id="c-42513952" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513282">parent</a><span>|</span><a href="#42514246">next</a><span>|</span><label class="collapse" for="c-42513952">[-]</label><label class="expand" for="c-42513952">[2 more]</label></div><br/><div class="children"><div class="content">Difference is that code is the documentation and design.<p>That is problem where people don’t understand that point.<p>Runtime and running application is the chair. Code is design how to make “chair” run on computer.<p>I say in software development we are years ahead when it comes to handling complexity of documentation with GIT and CI&#x2F;CD practices, code reviews and QA coverage with unit testing of the designs and general testing.<p>So I do not agree that software development is immature field. There are immature projects and companies cut corners much more than on physical products because it is much easier to fix software later.<p>But in terms of practices we are way ahead.</div><br/><div id="42518228" class="c"><input type="checkbox" id="c-42518228" checked=""/><div class="controls bullet"><span class="by">dambi0</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513952">parent</a><span>|</span><a href="#42514246">next</a><span>|</span><label class="collapse" for="c-42518228">[-]</label><label class="expand" for="c-42518228">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t this similar to saying the valves and vessels of a chemical processing system is the design and documentation of the overall process?<p>I know that it’s frequently reposted but Peter Naur’s Programming as Theory Building is always worth a reread.<p>The code doesn’t tell us why decisions were made, what constraints were considered  or what things were ruled out</div><br/></div></div></div></div></div></div><div id="42513770" class="c"><input type="checkbox" id="c-42513770" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512817">parent</a><span>|</span><a href="#42513282">prev</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42513770">[-]</label><label class="expand" for="c-42513770">[1 more]</label></div><br/><div class="children"><div class="content">The word code comes from Latin coudex which seems mean - to hack a tree. Are we then not mere lumberjacks with the beards and beer and all :)))</div><br/></div></div></div></div></div></div></div></div><div id="42511720" class="c"><input type="checkbox" id="c-42511720" checked=""/><div class="controls bullet"><span class="by">mgkimsal</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42512497">prev</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42511720">[-]</label><label class="expand" for="c-42511720">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Oh, and in 6 months the unintuitive and confusing concept needs to be completely changed into - surprise, surprise - a completely different but equally unintuitive and confusing concept.<p>But you have to keep the old way of working exactly the same, and the data can&#x27;t change, but also needs to work in the new version as well.  Actually show someone there&#x27;s two modes, and offer to migrate their data to version 2?  No way - that&#x27;s confusing!  Show different UI in different areas with the same data that behaves differently based on ... undisclosed-to-the-user criteria.  That will be far less confusing.</div><br/><div id="42511743" class="c"><input type="checkbox" id="c-42511743" checked=""/><div class="controls bullet"><span class="by">terribleperson</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511720">parent</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42511743">[-]</label><label class="expand" for="c-42511743">[12 more]</label></div><br/><div class="children"><div class="content">As a user &#x27;intuitive&#x27; UIs that hide a bunch of undisclosed but relevant complexity send me into a frothing rage.</div><br/><div id="42513459" class="c"><input type="checkbox" id="c-42513459" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511743">parent</a><span>|</span><a href="#42512206">next</a><span>|</span><label class="collapse" for="c-42513459">[-]</label><label class="expand" for="c-42513459">[9 more]</label></div><br/><div class="children"><div class="content">In many problem spaces, software developers are only happy with interfaces made for software developers. This article diving into the layers of complex logic we can reason about at once perfectly demonstrates why. Developers ‘get’ that complexity, because it’s our job, and think about GUIs as thin convenience wrappers for the program underneath. To most users, the GUI <i>is</i> the software, and they consider applications like appliances for solving specific problems. You aren’t <i>using the refrigerator,</i> you’re <i>getting food</i>. You’re <i>cooking</i>, not <i>using the stove.</i> The fewer things they have to do or think about to solve their problem to their satisfaction, the better. They don’t give a flying fuck about <i>how</i> software does something, probably wouldn’t bother figuring out how to adjust it if they could, and the longer it takes them to figure out how to apply their existing mental models UI idioms to the screen they’re looking at, the more frustrated they get. Software developers know what’s going on behind the scenes so seeing all of the controls and adjustments and statuses and data helps developers orient themselves save figure out what they’re doing. Seeing all that stuff is often a huge hindrance to users that just have a problem they need to solve, and have a much more limited set of mental models and usage idioms they need to use figuring how which of those buttons to press and parameters to adjust. That’s the primary reason FOSS has so few non-technical users.<p>The problem comes in when people that aren’t UI designers want to make something “look designed” so they start ripping stuff out and moving it around without understanding how it works affect different types of users. I don’t hear too many developers complain about the interface for iMessage for example despite having a fraction of the controls visible at any given time, because it effectively solves their problem, and does so easier than with a visible toggle for read receipts, SMS&#x2F;iMessages, text size, etc etc etc. It doesn’t merely look designed, it it’s designed for optimal usability.<p>Developers often see an interface that doesn’t work well for developers usage style, assume that means it doesn’t work well, and then complain about it among other developers creating an echo chamber. Developers being frustrated with an interface is an important data point that shouldn’t be ignored, but our perspectives and preferences aren’t nearly as generalizable some might think.</div><br/><div id="42513927" class="c"><input type="checkbox" id="c-42513927" checked=""/><div class="controls bullet"><span class="by">terribleperson</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513459">parent</a><span>|</span><a href="#42514107">next</a><span>|</span><label class="collapse" for="c-42513927">[-]</label><label class="expand" for="c-42513927">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not particularly bothered by non-developer UI. I&#x27;m bothered by the incessant application of mobile UI idioms to desktop programs (remember when all windows programs looked somewhat similar?), by UI churn with no purpose, by software that puts functionality five clicks deep for no reason other than to keep the ui &#x27;minimal&#x27;, by the use of unclear icons when there&#x27;s room for text (worse, when it&#x27;s one of the bare handful of things with a universally-understood icon and they decided to invent their own), by UIs that just plain don&#x27;t present important information for fear of making things &#x27;busy&#x27;. There&#x27;s a lot to get mad about when it comes to modern UIs without needing to approach it from a software developer usage style perspective.</div><br/><div id="42516629" class="c"><input type="checkbox" id="c-42516629" checked=""/><div class="controls bullet"><span class="by">suzzer99</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513927">parent</a><span>|</span><a href="#42516132">next</a><span>|</span><label class="collapse" for="c-42516629">[-]</label><label class="expand" for="c-42516629">[1 more]</label></div><br/><div class="children"><div class="content">+1 to all this. And when did it become cool to have icons that provide no feedback they&#x27;ve been clicked, combined with no loading state? I&#x27;m always clicking stuff twice now because I&#x27;m not sure I even clicked it the first time.</div><br/></div></div><div id="42516132" class="c"><input type="checkbox" id="c-42516132" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513927">parent</a><span>|</span><a href="#42516629">prev</a><span>|</span><a href="#42514117">next</a><span>|</span><label class="collapse" for="c-42516132">[-]</label><label class="expand" for="c-42516132">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re making a lot of assumptions about who&#x27;s doing what, what problems they&#x27;re trying to solve by doing it, and why. The discipline of UI design is figuring out how people can solve their problems easily and effectively. If you have advanced users that need to make five mouse clicks to perform an essential function, that&#x27;s a <i>bad design</i> and the chance of that being a UI design decision is just about zero. Same thing with icons. UI design, fundamentally, is a medium of communication: do you think it&#x27;s more likely a UI designer-- a professional and likely educated interactivity communicator-- chose those icons, or a developer or project manager grabbing a sexy looking UI mockup on dribble and trying to smash their use case into it?<p>Minimalism isn&#x27;t a goal-- it&#x27;s a tool to make a better interface and can easily be overused. The people that think minimalism is a goal and will chop out essential features to make something &quot;look designed&quot; are almost always developers. Same thing with unclear icons. As someone with a design degree that&#x27;s done UI design but worked as a back-end developer for a decade before that, and worked as a UNIX admin off and on for a decade before that, I am very familiar with the technical perspective on design and it&#x27;s various echo-chamber-reinforced follies.<p>It&#x27;s not like all UI designers are incredibly qualified or don&#x27;t underestimate the importance of some particular function within some subset of users, and some people that hire designers don&#x27;t realize that a graphic designer isn&#x27;t a UI designer and shouldn&#x27;t be expected to work as one. But 700 times out of 1000, that&#x27;s something dev said &quot;this is too annoying to implement&quot; or some project manager dropped it from the timeline. Maybe 250 of those remaining times, the project manager says &quot;we don&#x27;t need designers for this next set of features, right? Dev can just make it look like the other parts of the project?&quot;<p>Developers read an edward tufte book, think they&#x27;re experts, and come up with all sorts of folk explanations about what&#x27;s happening with a design and why people are doing it, then talk about it in venues like this with a million other developers agreeing with them. That does a whole lot more damage to UIs in the wild than bad design decisions made by designers.</div><br/><div id="42517960" class="c"><input type="checkbox" id="c-42517960" checked=""/><div class="controls bullet"><span class="by">terribleperson</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516132">parent</a><span>|</span><a href="#42514117">next</a><span>|</span><label class="collapse" for="c-42517960">[-]</label><label class="expand" for="c-42517960">[1 more]</label></div><br/><div class="children"><div class="content">You seem to think I&#x27;m attacking UI designers. I&#x27;m not. I think software would be a lot better with professional UI designers designing UIs.<p>edit: I <i>am</i> making a lot of assumptions. I&#x27;m assuming that most UIs aren&#x27;t really designed, or are &#x27;designed&#x27; from above with directions that are primarily concerned about aesthetics.</div><br/></div></div></div></div><div id="42514117" class="c"><input type="checkbox" id="c-42514117" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513927">parent</a><span>|</span><a href="#42516132">prev</a><span>|</span><a href="#42514107">next</a><span>|</span><label class="collapse" for="c-42514117">[-]</label><label class="expand" for="c-42514117">[1 more]</label></div><br/><div class="children"><div class="content">I think a lot of this is bike shedding. Changing the interface design is easy. Understanding usability and building usable systems is hard.</div><br/></div></div></div></div><div id="42514107" class="c"><input type="checkbox" id="c-42514107" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513459">parent</a><span>|</span><a href="#42513927">prev</a><span>|</span><a href="#42512206">next</a><span>|</span><label class="collapse" for="c-42514107">[-]</label><label class="expand" for="c-42514107">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That’s the primary reason FOSS has so few non-technical users.<p>Yeah, citation needed. If your argument that &#x27;non-technical users&#x27; (whatever that is - being technical is not restricted to understanding computers and software deeply) don&#x27;t use software that exposes a lot of data on its internals as exemplified by FOSS having few &#x27;non-technical users&#x27; meaning people who are not software developers, this is just false. There are entire fields where FOSS software is huge. GIS comes to mind.</div><br/><div id="42515829" class="c"><input type="checkbox" id="c-42515829" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514107">parent</a><span>|</span><a href="#42512206">next</a><span>|</span><label class="collapse" for="c-42515829">[-]</label><label class="expand" for="c-42515829">[2 more]</label></div><br/><div class="children"><div class="content">Normally in this rant I specifically note that non-software technical people are still technical. For genuinely non-technical software, what are the most popular end-user facing FOSS-developed applications? Firefox, signal, blender, Inkscape, Krita maybe… most of those are backed by foundations that pay designers and in Mozilla’s case, actually do a ton of open usability research. I don’t believe Inkscape does but they do put a ton of effort into thinking about things from the user workflow perspective and definitely do not present all of the functionality to the user all at once. Blender, at first, just made memorize a shitload of shortcuts but they’ve done a ton of work figuring out what users need to see in which tasks in different workflows and have a ton of different purpose-built views. For decades, Gimp treated design, workflow and UI changes like any other feature and they ended up with a cobbled-together ham fisted interface used almost exclusively by developers. You’ll have a hard time finding a professional photographer that hasn’t tried gimp and an even harder time finding one that still uses it because of the confusing, unfocused interface. When mastodon stood a real chance of being what Bluesky is becoming, I was jumping up and down flailing my arms trying to get people to work on polishing the user flow and figure out how to communicate what they needed to know concisely. Dismissal dismissal dismissal. “I taught my grandmother how federation works! They just need to read the documentation! Once they start using it they’ll figure it out!” Well, they started using it, didn’t have that gifted grandmother-teaching developer to explain it to them, and they almost all left immediately afterwards.<p>Just like human factors engineering, UI design is a unique discipline that many in the engineering field think they can intuit their way through. They’re wrong and if you look beyond technical people, it’s completely obvious.</div><br/><div id="42516641" class="c"><input type="checkbox" id="c-42516641" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515829">parent</a><span>|</span><a href="#42512206">next</a><span>|</span><label class="collapse" for="c-42516641">[-]</label><label class="expand" for="c-42516641">[1 more]</label></div><br/><div class="children"><div class="content">Worth noting that Gimp just made a separate UI design repo and seem to be doing a great job at confronting this systemic problem in the project.</div><br/></div></div></div></div></div></div></div></div><div id="42512206" class="c"><input type="checkbox" id="c-42512206" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511743">parent</a><span>|</span><a href="#42513459">prev</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42512206">[-]</label><label class="expand" for="c-42512206">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m trying to learn acceptance: how not to get so angry at despicable UIs.<p>Although I admit I&#x27;m kinda failing. My minor successes have been by avoiding software: e.g. giving up programming (broken tools and broken targets were a major frustration) and getting rid of Windows.</div><br/><div id="42512322" class="c"><input type="checkbox" id="c-42512322" checked=""/><div class="controls bullet"><span class="by">shnock</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512206">parent</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42512322">[-]</label><label class="expand" for="c-42512322">[1 more]</label></div><br/><div class="children"><div class="content">Having given up programming, what do you do now?</div><br/></div></div></div></div></div></div></div></div><div id="42513488" class="c"><input type="checkbox" id="c-42513488" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511720">prev</a><span>|</span><a href="#42512727">next</a><span>|</span><label class="collapse" for="c-42513488">[-]</label><label class="expand" for="c-42513488">[2 more]</label></div><br/><div class="children"><div class="content">IMO the fact that code tends to become hard over time in the real world, is even more reason to lower cognitive load. Because cognitive load is related to complexity. Things like inheritance make it far too easy to end up with spaghetti. So if it&#x27;s not providing significant benefit, god damn don&#x27;t do it in the first place (like the article mentions).</div><br/><div id="42514561" class="c"><input type="checkbox" id="c-42514561" checked=""/><div class="controls bullet"><span class="by">Simon_O_Rourke</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513488">parent</a><span>|</span><a href="#42512727">next</a><span>|</span><label class="collapse" for="c-42514561">[-]</label><label class="expand" for="c-42514561">[1 more]</label></div><br/><div class="children"><div class="content">That depends on who thinks it&#x27;s going to be a significant benefit - far far too many times I&#x27;ve had non-technical product managers yelling about some patch or feature or whatever with a &quot;just get it done&quot; attitude. Couple that with some junior engineering manager unwilling to push back, with an equally junior dev team and you&#x27;ll end up with the nasty spaghetti code that only grows.</div><br/></div></div></div></div><div id="42512727" class="c"><input type="checkbox" id="c-42512727" checked=""/><div class="controls bullet"><span class="by">dogcomplex</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42513488">prev</a><span>|</span><a href="#42513515">next</a><span>|</span><label class="collapse" for="c-42512727">[-]</label><label class="expand" for="c-42512727">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a bunch of excellent excuses why code is not typically well factored.  But that all just seems to make it more evident that the ideal format should be more well-factored.</div><br/></div></div><div id="42513515" class="c"><input type="checkbox" id="c-42513515" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42512727">prev</a><span>|</span><a href="#42519092">next</a><span>|</span><label class="collapse" for="c-42513515">[-]</label><label class="expand" for="c-42513515">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Where just the concepts need to be whiteboarded and explained because they&#x27;re unintuitive and confusing.<p>they&#x27;re intuitive to somebody - just not the software engineer. This simply means there&#x27;s some domain expertise which isn&#x27;t available to the engineer.</div><br/><div id="42516202" class="c"><input type="checkbox" id="c-42516202" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513515">parent</a><span>|</span><a href="#42519092">next</a><span>|</span><label class="collapse" for="c-42516202">[-]</label><label class="expand" for="c-42516202">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. There are a lot of domains where you&#x27;re digitizing decades of cobbled together non-computer systems, such as law, administration, or accounting. There&#x27;s a very good chance that no single human understands those systems either, and that trying to model them will inevitably end up with obscure code that no one will ever understand either. Especially as legislation and accounting practices accrete in the future, with special cases for every single decision.</div><br/></div></div></div></div><div id="42519092" class="c"><input type="checkbox" id="c-42519092" checked=""/><div class="controls bullet"><span class="by">yearolinuxdsktp</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42513515">prev</a><span>|</span><a href="#42515444">next</a><span>|</span><label class="collapse" for="c-42519092">[-]</label><label class="expand" for="c-42519092">[1 more]</label></div><br/><div class="children"><div class="content">Nothing about computers is intuitive. Not even using a mouse.<p>A late-breaking change is a business advantage—-learn how to roll with them.</div><br/></div></div><div id="42515444" class="c"><input type="checkbox" id="c-42515444" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42519092">prev</a><span>|</span><a href="#42511677">next</a><span>|</span><label class="collapse" for="c-42515444">[-]</label><label class="expand" for="c-42515444">[4 more]</label></div><br/><div class="children"><div class="content">Oh, and there&#x27;s massive use of aspect-oriented programming, the least local paradigm ever!</div><br/><div id="42516746" class="c"><input type="checkbox" id="c-42516746" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515444">parent</a><span>|</span><a href="#42511677">next</a><span>|</span><label class="collapse" for="c-42516746">[-]</label><label class="expand" for="c-42516746">[3 more]</label></div><br/><div class="children"><div class="content">I have never actually seen aspect-oriented programming used in the wild. Out of curiosity, in what context are you seeing AOP used?</div><br/><div id="42518977" class="c"><input type="checkbox" id="c-42518977" checked=""/><div class="controls bullet"><span class="by">computerdork</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516746">parent</a><span>|</span><a href="#42516972">next</a><span>|</span><label class="collapse" for="c-42518977">[-]</label><label class="expand" for="c-42518977">[1 more]</label></div><br/><div class="children"><div class="content">Also good for having default activities performed on object or subsystem. For instance, by default, always having an object have security checks to make sure it  has permission to perform the tasks it should be (have seen this, and sounds like a good idea at least). And also, to have some basic logging performed to show when you&#x27;ve entered and left function calls. 
It&#x27;s easy to forget to add these to a function, especially with large codebase with lots of developers</div><br/></div></div><div id="42516972" class="c"><input type="checkbox" id="c-42516972" checked=""/><div class="controls bullet"><span class="by">looperhacks</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42516746">parent</a><span>|</span><a href="#42518977">prev</a><span>|</span><a href="#42511677">next</a><span>|</span><label class="collapse" for="c-42516972">[-]</label><label class="expand" for="c-42516972">[1 more]</label></div><br/><div class="children"><div class="content">We use it to automatically instrument code for tracing. Stuff like this is IMO the only acceptable use to reduce boiler-plate but quickly becomes terrible if you don&#x27;t pay attention.</div><br/></div></div></div></div></div></div><div id="42511677" class="c"><input type="checkbox" id="c-42511677" checked=""/><div class="controls bullet"><span class="by">ilvez</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42515444">prev</a><span>|</span><a href="#42517133">next</a><span>|</span><label class="collapse" for="c-42511677">[-]</label><label class="expand" for="c-42511677">[1 more]</label></div><br/><div class="children"><div class="content">Plus to everything said. It&#x27;s an everyday life of &quot;maintainer&quot;, picking the next battle to pick the best way to avoid sinking deeper and defending the story that exactly &quot;this&quot; is the next refactoring project. All that while balancing different factors as you mention to actually believe oneself, because there are countless of paths..</div><br/></div></div><div id="42517133" class="c"><input type="checkbox" id="c-42517133" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511677">prev</a><span>|</span><a href="#42511557">next</a><span>|</span><label class="collapse" for="c-42517133">[-]</label><label class="expand" for="c-42517133">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, the more convoluted code is more likely to have performance issues.</div><br/></div></div><div id="42511557" class="c"><input type="checkbox" id="c-42511557" checked=""/><div class="controls bullet"><span class="by">haliskerbas</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42517133">prev</a><span>|</span><a href="#42515570">next</a><span>|</span><label class="collapse" for="c-42511557">[-]</label><label class="expand" for="c-42511557">[1 more]</label></div><br/><div class="children"><div class="content">This puts things really well. I’ll add into it that between the first white boarding session and the first working MVP there’ll be plenty of stakeholders who change their mind, find new info, or ask for updates that may break the original plan</div><br/></div></div><div id="42515570" class="c"><input type="checkbox" id="c-42515570" checked=""/><div class="controls bullet"><span class="by">SkyBelow</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511557">prev</a><span>|</span><a href="#42511926">next</a><span>|</span><label class="collapse" for="c-42515570">[-]</label><label class="expand" for="c-42515570">[2 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s quite easy to imagine a well factored codebase where all things are neatly separated.<p>If one is always implementing new code bases that they keep well factored, they should count their blessings.  I think being informed about cognitive load in code bases is still very important for all the times we aren&#x27;t so blessed.  I&#x27;ve inherited applications that use global scope and it is a nightmare to reason though.  Where possible I improve it and reduce global scope, but that is not always an option and is only possible after I have reasoned enough about the global scope to feel I can isolate it.  As such, letting others know of the costs is helpful to both reduce it from happening and to convince stakeholders of the importance of fixing it after it has happened and accounting for the extra costs it causes until it is fixed.<p>&gt;The messy stuff is where the real world concepts need to be transformed into code.<p>I also agree this can be a messy place, and on a new project, it is messy even when the code is clean because there is effectively a business logic&#x2F;process code base you are inheriting and turning into an application.  I think many of the lessons carry over well as I have seen an issue with global scope in business processes that cause many of the same issues as in code bases.  When very different business processes end up converging into one before splitting again, there is often extra cognitive load created in trying to combine them.  A single instance really isn&#x27;t bad, much like how a single global variable isn&#x27;t bad, but this is an anti-pattern that is used over and over again.<p>One helpful tool is working ones way up to the point of having enough political power and earned enough respect for their designs to have suggestions of refactoring business processes be taken into serious consideration (one also has to have enough business acumen to know when such a suggestion is reasonable).<p>&gt;the original author doesn&#x27;t work here anymore so no one&#x27;s here to explain the original code&#x27;s intent.<p>I fight for comments that tell me why a certain decision is made in the code.  The code tells me what it is doing, and domain knowledge will tell most of why it is doing the things expected, but anytime the code deviates from doing what one would normally expect to be done in the domain, telling me why it deviated from expected behavior is very important for when someone is back here reading it 5+ years later when no one is left from the original project.  Some will suggest putting it in documentation, but I find that the only documentation with any chance of being maintained or even kept is the documentation built into the code.</div><br/><div id="42516240" class="c"><input type="checkbox" id="c-42516240" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515570">parent</a><span>|</span><a href="#42511926">next</a><span>|</span><label class="collapse" for="c-42516240">[-]</label><label class="expand" for="c-42516240">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;why&quot; is the hardest part. You are writing to a future version of most probably a different person with a different background. Writing all is as wrong as writing nothing. You have to anticipate the questions of the future. That takes experience and having been in different shoes, &quot;on the receiving side&quot; of such a comment. Typically developers brag what they did, not why, especially the ones who think they are good...</div><br/></div></div></div></div><div id="42511926" class="c"><input type="checkbox" id="c-42511926" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42515570">prev</a><span>|</span><a href="#42513723">next</a><span>|</span><label class="collapse" for="c-42511926">[-]</label><label class="expand" for="c-42511926">[1 more]</label></div><br/><div class="children"><div class="content">It can be done. Sometimes.<p>I am so proud and happy, when I can make a seemingly complicated change quickly, because the architecture was well designed and everthing neatly seperated.<p>Most of the time though, it is exactly like you described. Or randalls good code comic:<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;844&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;844&#x2F;</a><p>Allmost too painful to be funny, when you know the pain is avoidable in theory.<p>Still, it should not be an excuse to be lazy and just write bad code by default. Developing the habit of making everything as clean, structured and clear as possible allways pays of. Especially if that code, that was supposed to be a quick and dirty throw away code experiment somehow ended up being used and 2 years later you suddenly need to debug it.
(I just experienced that joy)</div><br/></div></div><div id="42513723" class="c"><input type="checkbox" id="c-42513723" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511926">prev</a><span>|</span><a href="#42514036">next</a><span>|</span><label class="collapse" for="c-42513723">[-]</label><label class="expand" for="c-42513723">[2 more]</label></div><br/><div class="children"><div class="content">I mean really nobody wants an app that is slow, hard to refactor, with confusing business logic etc. Everyone wants good proporties.<p>So then you get into what you’re good at. Maybe you’re good at modeling business logic (even confusing ones!). Maybe you’re good at writing code that is easy to refactor.<p>Maybe you’re good at getting stuff right the first time. Maybe you’re good at quickly fixing issues.<p>You can lean into what you’re good at to get the most bang for your buck. But you probably still have some sort of minimum standards for the whole thing. Just gotta decide what that looks like.</div><br/><div id="42515411" class="c"><input type="checkbox" id="c-42515411" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513723">parent</a><span>|</span><a href="#42514036">next</a><span>|</span><label class="collapse" for="c-42515411">[-]</label><label class="expand" for="c-42515411">[1 more]</label></div><br/><div class="children"><div class="content">Some people are proud of making complex code. And too many people admire those who write complex code.</div><br/></div></div></div></div><div id="42514036" class="c"><input type="checkbox" id="c-42514036" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42513723">prev</a><span>|</span><a href="#42512310">next</a><span>|</span><label class="collapse" for="c-42514036">[-]</label><label class="expand" for="c-42514036">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you also need to write it in a convoluted way because, for various annoying reasons, that&#x27;s what performs best on the computer.<p>That&#x27;s nothing to do with hardware. The various annoying reasons are not set in stone or laws of physics. They are merely the path dependency of decades of prioritizing shipping soon because money.</div><br/></div></div></div></div><div id="42512310" class="c"><input type="checkbox" id="c-42512310" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511509">prev</a><span>|</span><a href="#42516311">next</a><span>|</span><label class="collapse" for="c-42512310">[-]</label><label class="expand" for="c-42512310">[9 more]</label></div><br/><div class="children"><div class="content">&gt; If someone feels compelled to read every function either the functions are poor abstractions or the reader has trust issues, which may be warranted.<p>I joined a company with great code and architecture for 3 months last year. They deal with remittances and payments.<p>Their architecture leads are very clued up, and I observed that they spent a lot of quality time figuring out their architecture and improvements, continuously. They&#x27;d do a lot of refactors for all the various teams, and the cadence of feature development and release was quite impressive.<p>In that period though, I and another long-standing colleague made a few errors that cost the company a lot of money, like an automated system duplicating payments to users for a few hours until we noticed it.<p>Part of their architectural decision was to use small functions to encapsulate logic, and great care and code review was put into naming functions appropriately (though they were comment averse).<p>The mistakes we committed, were because we trusted that those functions did what they said they did correctly. After all, they&#x27;ve also been unit tested, and there&#x27;s also integration tests.<p>If it weren&#x27;t for the fortitude of the project manager (great guy hey) in firmly believing in collective responsibility if there&#x27;s no malice, I&#x27;d probably have been fired after a few weeks (I left for a higher offer elsewhere).<p>---<p>So the part about trust issues resonates well with me. As a team we made the decision that we shouldn&#x27;t always trust existing code, and the weeks thereafter had much higher cognitive load.</div><br/><div id="42512869" class="c"><input type="checkbox" id="c-42512869" checked=""/><div class="controls bullet"><span class="by">avg_dev</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512310">parent</a><span>|</span><a href="#42516076">next</a><span>|</span><label class="collapse" for="c-42512869">[-]</label><label class="expand" for="c-42512869">[5 more]</label></div><br/><div class="children"><div class="content">That sounds like a very difficult situation. Would you be willing to elaborate on what kinds of bugs lay in the pre-existing functions? Was some sort of operation that was supposed to be idempotent (“if you call it with these unique parameters over and over, it will be the same as if you only called it once”) not so? I am trying to imagine what went wrong here. A tough situation, must have been quite painful. How serious were the consequences? If you don’t feel comfortable answering that is okay.</div><br/><div id="42513361" class="c"><input type="checkbox" id="c-42513361" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512869">parent</a><span>|</span><a href="#42516076">next</a><span>|</span><label class="collapse" for="c-42513361">[-]</label><label class="expand" for="c-42513361">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember the exact detail, but one instance was a function checking whether a user should be paid based on some conditions. It checked the db, and I think because the codebase and db move fast, there was a new enum added a few months prior which was triggered by our transaction type.<p>So that helped function didn&#x27;t account for the new enum, and we ended up sending &gt;2 payments to users, in some cases I think over 10 to one user.<p>The issue was brought to customer support&#x27;s attention, else we might have only noticed it at the end of the week, which I think would have led to severe consequences.<p>The consequences never reached us because our PM dealt with them. I suppose in all the financial loss instances, the business absorbed the losses.</div><br/><div id="42515109" class="c"><input type="checkbox" id="c-42515109" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513361">parent</a><span>|</span><a href="#42516076">next</a><span>|</span><label class="collapse" for="c-42515109">[-]</label><label class="expand" for="c-42515109">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So that helped function didn&#x27;t account for the new enum<p>This is where Scala&#x2F;Rust&#x27;s enforcement of having to handle all arms of a match clause help catch such issues - if you are matching against the enum, you won&#x27;t even be able to compile if you don&#x27;t handle all the arms.</div><br/><div id="42515334" class="c"><input type="checkbox" id="c-42515334" checked=""/><div class="controls bullet"><span class="by">matt_kantor</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515109">parent</a><span>|</span><a href="#42516076">next</a><span>|</span><label class="collapse" for="c-42515334">[-]</label><label class="expand" for="c-42515334">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like the source of truth for the enum members may have been in the database.<p>(But yes, exhaustiveness checking for sum types is a great feature.)</div><br/><div id="42515675" class="c"><input type="checkbox" id="c-42515675" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515334">parent</a><span>|</span><a href="#42516076">next</a><span>|</span><label class="collapse" for="c-42515675">[-]</label><label class="expand" for="c-42515675">[1 more]</label></div><br/><div class="children"><div class="content">The only db work I&#x27;ve done in rust required a recompile if the db schema changed, or even the specific queries your program used, because the rust types got generated from the schema. So in those cases the db change would have driven a rust type change and rust would have verified exhaustive handling.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42516076" class="c"><input type="checkbox" id="c-42516076" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512310">parent</a><span>|</span><a href="#42512869">prev</a><span>|</span><a href="#42515977">next</a><span>|</span><label class="collapse" for="c-42516076">[-]</label><label class="expand" for="c-42516076">[1 more]</label></div><br/><div class="children"><div class="content">Functions generally need to be documented, especially if there are any gotchas not obvious from the function signature. And one should always read the documentation. Good names are for discovery and recollection, and for the call-site code to be more intelligible, but they don’t replace having a specification of the function’s interface contract, and client code properly taking it into account.</div><br/></div></div><div id="42515977" class="c"><input type="checkbox" id="c-42515977" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512310">parent</a><span>|</span><a href="#42516076">prev</a><span>|</span><a href="#42515646">next</a><span>|</span><label class="collapse" for="c-42515977">[-]</label><label class="expand" for="c-42515977">[1 more]</label></div><br/><div class="children"><div class="content">Function names aren&#x27;t wholly distinct from comments. They suffer from the same problems as comments - they can go stale and no longer reflect the code they&#x27;re naming.</div><br/></div></div><div id="42515646" class="c"><input type="checkbox" id="c-42515646" checked=""/><div class="controls bullet"><span class="by">SkyBelow</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512310">parent</a><span>|</span><a href="#42515977">prev</a><span>|</span><a href="#42516311">next</a><span>|</span><label class="collapse" for="c-42515646">[-]</label><label class="expand" for="c-42515646">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The mistakes we committed, were because we trusted that those functions did what they said they did correctly. After all, they&#x27;ve also been unit tested, and there&#x27;s also integration tests.<p>As it is stated, I don&#x27;t see where it is your mistake.  You should be able to trust things do what they say, and there should be integration testing that happens which adds the appropriate amount of distrust and verification.  Even with adequate unit testing, you normally inject the dependencies so it wouldn&#x27;t be caught.<p>This seems an issue caused by two problems, inadequate integration testing and bugs in the original function, neither of which are your fault.<p>Building a sixth sense of when to distrust certain code is something you see from more experienced developers at a company, but you were new so there is no reason to expect you to have it (and the system for making code changes shouldn&#x27;t depend upon such intuition anyways).</div><br/></div></div></div></div><div id="42516311" class="c"><input type="checkbox" id="c-42516311" checked=""/><div class="controls bullet"><span class="by">cle</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512310">prev</a><span>|</span><a href="#42511578">next</a><span>|</span><label class="collapse" for="c-42516311">[-]</label><label class="expand" for="c-42516311">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find types helps massively with this. A function with well-constrained inputs and outputs is easy to reason about. One does not have to look at other code to do it. However, programs that leverage types effectively are sometimes construed as having high cognitive load, when it in fact they have low load. For example a type like `Option&lt;HashSet&lt;UserId&gt;&gt;` carries a lot of information(has low load): we might not have a set of user ids, but if we do they are unique.<p>They sometimes help. But I think it&#x27;s deeper than this. A function with inputs and outputs that are well-constrained with very abstract, complex types is still hard to reason about, unless you&#x27;re used to those abstractions.<p>I think it&#x27;s more accurate to say that something is &quot;easy to reason about&quot; if its level of abstraction &quot;closely matches&quot; the level of abstraction your brain is comfortable with &#x2F; used to. This can vary dramatically between people, depending on their background, experience, culture, etc.<p>I could describe the Option&lt;HashSet&lt;UserId&gt;&gt; type in terms of functors and applicatives and monads, and though it would describe exactly the same set of valid values, it has a much higher cognitive load for most people.<p>&gt; However, programs that leverage types effectively are sometimes construed as having high cognitive load, when it in fact they have low load.<p>Cognitive load is an individual experience. If someone &quot;construes&quot; something as having high cognitive load, then it does! (For them). We should be writing programs that minimize cognitive load <i>for the set of programmers who we want to be able to interact w&#x2F; the code</i>. That means the abstractions need to sufficiently match what they are comfortable with.<p>It&#x27;s also fine to say &quot;sorry, this code was not intended to have low cognitive load <i>for you</i>&quot;.</div><br/></div></div><div id="42511578" class="c"><input type="checkbox" id="c-42511578" checked=""/><div class="controls bullet"><span class="by">motorest</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42516311">prev</a><span>|</span><a href="#42511630">next</a><span>|</span><label class="collapse" for="c-42511578">[-]</label><label class="expand" for="c-42511578">[29 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been thinking about the notion of &quot;reasoning locally&quot; recently. Enabling local reasoning is the only way to scale software development past some number of lines or complexity. When reasoning locally, one only needs to understand a small subset, hundreds of lines, to safely make changes in programs comprising millions.<p>That was supposedly the main trait of object-oriented programming. Personally that was how it was taught to me: the whole point of encapsulation and information hiding is to ensure developers can &quot;reason locally&quot;, and thus be able to develop more complex projects by containing complexity to specific units of execution.<p>Half of SOLID principles also push for that. The main benefit of Liskov&#x27;s substitution principle is ensure developers don&#x27;t need to dig into each and every concrete implementation to be able to reason locally about the code.<p>On top of that, there are a multitude of principles and rules of thumb that also enforce that trait. For example, declaring variables right before they are used the first time. Don&#x27;t Repeat Yourself to avoid parsing multiple implementations of the same routine. Write Everything Twice to avoid premature abstractions and tightly coupling units of execution that are actually completely independent, etc etc etc.<p>Heck, even modularity, layered software architectures, and even microservices are used to allow developers to reason locally.<p>In fact, is there any software engineering principle that isn&#x27;t pushing for limiting complexity and allowing developers to reason locally?</div><br/><div id="42514437" class="c"><input type="checkbox" id="c-42514437" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511953">next</a><span>|</span><label class="collapse" for="c-42514437">[-]</label><label class="expand" for="c-42514437">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In fact, is there any software engineering principle that isn&#x27;t pushing for limiting complexity and allowing developers to reason locally?<p>Both DRY and SOLID lead to codebases that can be worse in this respect.<p>DRY and SRP limit what will be done in a single method or class, meaning that both the logic will eventually be strewn across the codebase, as well as any changes to that will need to take all of the pieces using the extracted logic into account. Sometimes it makes sense to have something like common services, helper and utility classes, but those can be in direct opposition to local reasoning for any non-trivial logic.<p>Same for polymorphism and inheritance in general, where you suddenly have to consider a whole class structure (and any logic that might be buried in there) vs the immediate bits of code that you’re working with.<p>Those might be considered decent enough practices to at least consider, but in practice they will lead to a lot of jumping around the codebase, same for any levels of abstraction (resource&#x2F;controller, service, mappers, Dto&#x2F;repository, …) and design patterns.</div><br/><div id="42515517" class="c"><input type="checkbox" id="c-42515517" checked=""/><div class="controls bullet"><span class="by">bccdee</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514437">parent</a><span>|</span><a href="#42511953">next</a><span>|</span><label class="collapse" for="c-42515517">[-]</label><label class="expand" for="c-42515517">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I think that, though experienced programmers tend to understand what makes code good, they&#x27;re often bad at expressing it, so they end up making simplified and misleading &quot;rules&quot; like SRP. Some rules are better than others, but there&#x27;s no substitute for reading a lot of code and learning to recognize legibility.</div><br/><div id="42515662" class="c"><input type="checkbox" id="c-42515662" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515517">parent</a><span>|</span><a href="#42511953">next</a><span>|</span><label class="collapse" for="c-42515662">[-]</label><label class="expand" for="c-42515662">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah I think that, though experienced programmers tend to understand what makes code good, they&#x27;re often bad at expressing it, so they end up making simplified and misleading &quot;rules&quot; like SRP.<p>I mean, I&#x27;m not saying that those approaches are always wholly bad from an organizational standpoint either, just that there are tradeoffs and whatnot.<p>&gt; Some rules are better than others, but there&#x27;s no substitute for reading a lot of code and learning to recognize legibility.<p>This feels very true though!</div><br/></div></div></div></div></div></div><div id="42511953" class="c"><input type="checkbox" id="c-42511953" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42514437">prev</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42511953">[-]</label><label class="expand" for="c-42511953">[17 more]</label></div><br/><div class="children"><div class="content">Encapsulation is the good part of object-oriented programming for precisely this reason, and most serious software development relies heavily on encapsulation. What&#x27;s bad about OOP is inheritance.<p>Microservices (in the sense of small services) are interesting because they are good at providing independent failure domains, but add the complexity of network calls to what would otherwise be a simple function call. I think the correct size of service is the largest you can get away with that fits into your available hardware and doesn&#x27;t compromise on resilience. Within a service, use things like encapsulation.</div><br/><div id="42512413" class="c"><input type="checkbox" id="c-42512413" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511953">parent</a><span>|</span><a href="#42512143">next</a><span>|</span><label class="collapse" for="c-42512413">[-]</label><label class="expand" for="c-42512413">[10 more]</label></div><br/><div class="children"><div class="content">Inheritance is everyone&#x27;s favorite whipping boy, but I&#x27;ve still never been in a codebase and felt like the existing inheritance was seriously hindering my ability to reason about it or contribute to it, and I find it productive to use on my own. It makes intuitive sense and aids understanding and modularity&#x2F;code resuse when used appropriately. Even really deep inheritance hierarchies where reasonable have never bothered me. I&#x27;ve been in the industry for at least 8 years and a volunteer for longer than that, and I&#x27;m currently in a role where I&#x27;m one of the most trusted &quot;architects&quot; on the team, so I feel like I should &quot;get it&quot; by now if it&#x27;s really that bad. I understand the arguments against inheritance in the abstract but I simply can&#x27;t bring myself to agree or even really empathize with them. Honestly, I find the whole anti-inheritance zeitgeist as silly and impotent as the movement to replace pi with tau, it&#x27;s simply a non-issue that&#x27;s unlikely to be on your mind if you&#x27;re actually getting work done IMHO.</div><br/><div id="42513466" class="c"><input type="checkbox" id="c-42513466" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42513996">next</a><span>|</span><label class="collapse" for="c-42513466">[-]</label><label class="expand" for="c-42513466">[1 more]</label></div><br/><div class="children"><div class="content">The problem of inheritance is that it should be an internal mechanism of code reuse, yet it is made public in a declarative form that implies a single pattern of such reuse. It works more or less but it also regularly runs into limitations imposed by that declarativeness.<p>For example, assume I want to write emulators for old computer architectures. Clearly there will be lots of places where I will be able to reuse the same code in different virtual CPUs. But can I somehow express all these patterns of reuse with inheritance? Will it be clearer to invent some generic CPU traits and make a specific CPU to inherit several such traits? It sounds very unlikely. It probably will be much simpler to just extract common code into subroutines and call them as necessary without trying to build a hierarchy of classes.<p>Or lets take, for example, search trees. Assume I want to have a library of such trees for research or pedagogic purposes. There are lots of mechanisms: AVL trees, 2-3, 2-3-4, red-black, B-Trees and so on. Again there will be places where I can reuse the same code for different trees. But can I really express all this as a neat hierarchy of tree classes?</div><br/></div></div><div id="42513996" class="c"><input type="checkbox" id="c-42513996" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42513466">prev</a><span>|</span><a href="#42512562">next</a><span>|</span><label class="collapse" for="c-42513996">[-]</label><label class="expand" for="c-42513996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [...] it&#x27;s simply a non-issue that&#x27;s unlikely to be on your mind if you&#x27;re actually getting work done IMHO.<p>Part of why I get (more) work done is that I don&#x27;t bother with the near-useless taxonomical exercises that inheritance invites, and I understand that there are ways of writing functions for &quot;all of these things, but no others&quot; that are simpler to understand, maintain and implement.<p>The amount of times you actually need an open set of things (i.e. what you get with inheritance) is so laughably low it&#x27;s a wonder inheritance ever became a thing. A closed set is way more likely to be what you want and is trivially represented as a tagged union. It just so happens that C++ (and Java) historically has had absolutely awful support for tagged unions so people have made do with inheritance even though it doesn&#x27;t do the right thing. Some people have then taken this to mean that&#x27;s what they ought to be using.<p>&gt; I&#x27;ve been in the industry for at least 8 years and a volunteer for longer than that, and I&#x27;m currently in a role where I&#x27;m one of the most trusted &quot;architects&quot; on the team, so I feel like I should &quot;get it&quot; by now if it&#x27;s really that bad.<p>I don&#x27;t think that&#x27;s really how it works. There are plenty of people who have tons of work experience but they&#x27;ve got bad ideas and are bad at what they do. You don&#x27;t automatically just gain wisdom and there are lots of scenarios where you end up reinforcing bad ideas, behavior and habits. It&#x27;s also very easy to get caught up in a collective of poorly thought out ideas in aggregate: Most of modern C++ is a great example of the kind of thinking that will absolutely drag maintainability, readability and performance down, but most of the ideas can absolutely sound good on their own, especially if you don&#x27;t consider the type of architecture they&#x27;ll cause.</div><br/></div></div><div id="42512562" class="c"><input type="checkbox" id="c-42512562" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42513996">prev</a><span>|</span><a href="#42515636">next</a><span>|</span><label class="collapse" for="c-42512562">[-]</label><label class="expand" for="c-42512562">[2 more]</label></div><br/><div class="children"><div class="content">So you&#x27;ve never worked on a code base with a 3-level+ deep inheritance tree and classes accessing their grandparent&#x27;s protected member variables and violating every single invariant possible?</div><br/><div id="42513232" class="c"><input type="checkbox" id="c-42513232" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512562">parent</a><span>|</span><a href="#42515636">next</a><span>|</span><label class="collapse" for="c-42513232">[-]</label><label class="expand" for="c-42513232">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 3-level+ deep inheritance tree and classes accessing their grandparent&#x27;s protected member variables<p>Yes, I have. Per MSDN, a protected member is accessible within its class and by derived class instances - that&#x27;s the point. Works fine in the game I work on.<p>&gt; violating every single invariant possible<p>Sure, sometimes, but I see that happen without class inheritance just as often.</div><br/></div></div></div></div><div id="42515636" class="c"><input type="checkbox" id="c-42515636" checked=""/><div class="controls bullet"><span class="by">bccdee</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42512562">prev</a><span>|</span><a href="#42512629">next</a><span>|</span><label class="collapse" for="c-42515636">[-]</label><label class="expand" for="c-42515636">[1 more]</label></div><br/><div class="children"><div class="content">The difference between inheritance and composition as tools for code reuse is that, in composition, the interface across which the reused code is accessed is strictly defined and explicit. In inheritance it is weakly defined and implicit; subclasses are tightly coupled to their parents, and the resulting code is not modular.</div><br/></div></div><div id="42512629" class="c"><input type="checkbox" id="c-42512629" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42515636">prev</a><span>|</span><a href="#42516293">next</a><span>|</span><label class="collapse" for="c-42512629">[-]</label><label class="expand" for="c-42512629">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad it&#x27;s been useful to you!<p>I can only share my own experience here. I&#x27;m thinking of a very specific ~20k LoC part of a large developer infrastructure service. This was really interesting because it was:<p>* inherently complex: with a number of state manipulation algorithms, ranging from &quot;call this series of external services&quot; to &quot;carefully written mutable DFS variant with rigorous error handling and worst-case bounds analysis&quot;.<p>* quite polymorphic by necessity, with several backends and even more frontends<p>* (edit: added because it&#x27;s important) a <i>textbook</i> case of where inheritance should work: not artificial or forced at all, perfect Liskov is-a substitution<p>* very thick interfaces involved: a number of different options and arguments that weren&#x27;t possible to simplify, and several calls back and forth between components<p>* changing quite often as needs changed, at least 3-4 times a week and often much more<p>* and like a lot of dev infrastructure, absolutely critical: unimaginable to have the rest of engineering function without it<p>A number of developers contributed to this part of the code, from many different teams and at all experience levels.<p>This is a perfect storm for code that is going to get messy, unless strict discipline is enforced. I think situations like these are a good stress test for development &quot;paradigms&quot;.<p>With polymorphic inheritance, over time, a spaghetti structure developed. Parent functions started calling child functions, and child functions started calling parent ones, based on whatever was convenient in the moment. Some functions were designed to be overridden and some were not. Any kind of documentation about code contracts would quickly fall out of date. As this got worse, refactoring became basically impossible over time. Every change became harder and harder to make. I tried my best to improve the code, but spent so much time just trying to understand which way the calls were supposed to go.<p>This experience radicalized me against class-based inheritance. It felt that the easy path, the series of local decisions individual developers made to get their jobs done, led to code that was incredibly difficult to understand -- global deterioration. Each individual parent-to-child and child-to-parent call made sense in the moment, but the cumulative effect was a maintenance nightmare.<p>One of the reasons I like Rust is that trait&#x2F;typeclass-based polymorphism makes this much less of a problem. The contracts between components are quite clear since they&#x27;re mediated by traits. Rather than relying on inheritance for polymorphism, you write code that&#x27;s generic over a trait. You cannot easily make upcalls from the trait impl to the parent -- you must go through a API designed for this (say, a context argument provided to you). Some changes that are easy to do with an inheritance model become harder with traits, but that&#x27;s <i>fine</i> -- code evolving towards a series of messy interleaved callbacks is bad, and making you do a refactor now is better in the long run. It is <i>possible</i> to write spaghetti code if you push really hard (mixing required and provided methods) but the easy path is to refactor the code.<p>(I think more restricted forms of inheritance might work, particularly ones that make upcalls difficult to do -- but only if tooling firmly enforces discipline. As it stands though, class-based inheritance just has too many degrees of freedom to work well under sustained pressure. I think more restricted kinds of polymorphism work better.)</div><br/><div id="42515023" class="c"><input type="checkbox" id="c-42515023" checked=""/><div class="controls bullet"><span class="by">Fluorescence</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512629">parent</a><span>|</span><a href="#42516293">next</a><span>|</span><label class="collapse" for="c-42515023">[-]</label><label class="expand" for="c-42515023">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This experience radicalized me against ...<p>My problem with OO bashing is not that it isn&#x27;t deserved but seems in denial about pathological abstraction in other paradigms.<p>Functional programming quickly goes up it&#x27;s own bum with ever more subtle function composition, functor this, monoidal that, effect systems. I see the invention of inheritance type layering just in adhoc lazy evaluated doom pyramids.<p>Rich type systems spiral into astronautics. I can barely find the code in some defacto standard crates instead it&#x27;s deeply nested generics... generic traits that take generic traits implemented by generic structs called by generic functions. It&#x27;s an alphabet soup of S, V, F, E. Is that Q about error handling, or an execution model or data types? Who knows! Only the intrepid soul that chases the tail of every magic letter can tell you.<p>I wish there were a panacea but I just see human horrors whether in dynamically-typed monkey-patch chaos or the trendiest esoterica. Hell I&#x27;ve seen a clean-room invention of OO in an ancient Fortran codebase by an elderly academic unaware it was a thing. He was very excited to talk about his phylogenetic tree, it&#x27;s species and shared genes.<p>The layering the author gives as &quot;bad OO&quot; admin&#x2F;user&#x2F;guest&#x2F;base will exist in the other styles with pros&#x2F;cons. At least the OO separates each auth level and shows the relationship between them which can be a blessed relief compared to whatever impenetrable soup someone will cook up in another style.</div><br/><div id="42517494" class="c"><input type="checkbox" id="c-42517494" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515023">parent</a><span>|</span><a href="#42516293">next</a><span>|</span><label class="collapse" for="c-42517494">[-]</label><label class="expand" for="c-42517494">[1 more]</label></div><br/><div class="children"><div class="content">The difference, I think, is that much of that is not the easy path. Being able to make parent-child-parent-child calls is the thing that distinguishes inheritance from other kinds of polymorphism, and it leads to really bad code. No other kind of polymorphism has this upcall-downcall-upcall-downcall pattern baked into its structure.<p>The case I&#x27;m talking about is a perfect fit for inheritance. If not there, then where?</div><br/></div></div></div></div></div></div><div id="42516293" class="c"><input type="checkbox" id="c-42516293" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42512629">prev</a><span>|</span><a href="#42512143">next</a><span>|</span><label class="collapse" for="c-42516293">[-]</label><label class="expand" for="c-42516293">[1 more]</label></div><br/><div class="children"><div class="content">If you are reading a deep * wide inheritance hierarchy with override methods. You will have to navigate through several files to understand where the overrides occurred. Basically multiply the number of potential implementations by inheritance depth * inheritance width.<p>You may not be bitten by such an issue in application code. But I&#x27;ve seen it in library code. Particularly from Google, AWS, various Auth libraries, etc. Due to having to interop with multiple apis or configuration.</div><br/></div></div></div></div><div id="42512143" class="c"><input type="checkbox" id="c-42512143" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511953">parent</a><span>|</span><a href="#42512413">prev</a><span>|</span><a href="#42514577">next</a><span>|</span><label class="collapse" for="c-42512143">[-]</label><label class="expand" for="c-42512143">[5 more]</label></div><br/><div class="children"><div class="content">Encapsulation arguably isn’t a good part, either. It encourages complex state and as a result makes testing difficult. I feel like stateless or low-state has won out.</div><br/><div id="42514168" class="c"><input type="checkbox" id="c-42514168" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512143">parent</a><span>|</span><a href="#42512397">next</a><span>|</span><label class="collapse" for="c-42514168">[-]</label><label class="expand" for="c-42514168">[1 more]</label></div><br/><div class="children"><div class="content">Encapsulation can be done even in Haskell which avoids mutable state by using modules that don&#x27;t export their internals, smart constructors etc. instead. You can e.g. encapsulate the logic for dealing with redis in a module and never expose the underlying connection logic to the rest of the codebase.</div><br/></div></div><div id="42512397" class="c"><input type="checkbox" id="c-42512397" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512143">parent</a><span>|</span><a href="#42514168">prev</a><span>|</span><a href="#42514577">next</a><span>|</span><label class="collapse" for="c-42512397">[-]</label><label class="expand" for="c-42512397">[3 more]</label></div><br/><div class="children"><div class="content">Hmm, to me encapsulation means a scheme where the set of valid states is a subset of all representable states. It&#x27;s kind of a weakening of &quot;making invalid states unrepresentable&quot;, but is often more practical.<p>Not all strings are valid identifiers, for example, it&#x27;s hard to represent &quot;the set of all valid identifiers&quot; directly into the type system. So encapsulation is a good way to ensure that a particular identifier you&#x27;re working with is valid -- helping scale local reasoning (code to validate identifiers) up into global correctness.<p>This is a pretty FP and&#x2F;or Rust way to look at things, but I think it&#x27;s the essence of what makes encapsulation valuable.</div><br/><div id="42512492" class="c"><input type="checkbox" id="c-42512492" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512397">parent</a><span>|</span><a href="#42514577">next</a><span>|</span><label class="collapse" for="c-42512492">[-]</label><label class="expand" for="c-42512492">[2 more]</label></div><br/><div class="children"><div class="content">What you’re talking about is good design but has nothing to do with encapsulation. From Wikipedia:<p>&gt; In software systems, encapsulation refers to the bundling of data with the mechanisms or methods that operate on the data. It may also refer to the limiting of direct access to some of that data, such as an object&#x27;s components. Essentially, encapsulation prevents external code from being concerned with the internal workings of an object.<p>You could use encapsulation to enforce only valid states, but there are many ways to do that.</div><br/><div id="42512758" class="c"><input type="checkbox" id="c-42512758" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512492">parent</a><span>|</span><a href="#42514577">next</a><span>|</span><label class="collapse" for="c-42512758">[-]</label><label class="expand" for="c-42512758">[1 more]</label></div><br/><div class="children"><div class="content">Well whatever that is, that&#x27;s what I like :)</div><br/></div></div></div></div></div></div></div></div><div id="42514577" class="c"><input type="checkbox" id="c-42514577" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511953">parent</a><span>|</span><a href="#42512143">prev</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42514577">[-]</label><label class="expand" for="c-42514577">[1 more]</label></div><br/><div class="children"><div class="content">Not only network calls, but also parallelism, when that microservice does some processing on its own, or are called from a different microservice as well.<p>Add to it a database with all the different kinds of transaction semantics and you have a system that is way above the skillset of the average developer.</div><br/></div></div></div></div><div id="42511616" class="c"><input type="checkbox" id="c-42511616" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511953">prev</a><span>|</span><a href="#42511776">next</a><span>|</span><label class="collapse" for="c-42511616">[-]</label><label class="expand" for="c-42511616">[3 more]</label></div><br/><div class="children"><div class="content">In theory, you could design a parallel set of software engineering best practices which emphasize long-term memory of the codebase over short-term ability to leaf through and understand it. I guess that would be &quot;reasoning nonlocally&quot; in a useful sense.<p>In practice I think the only time this would be seen as a potentially good thing by most devs is if it was happening in heavily optimized code.</div><br/><div id="42514319" class="c"><input type="checkbox" id="c-42514319" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511616">parent</a><span>|</span><a href="#42511776">next</a><span>|</span><label class="collapse" for="c-42514319">[-]</label><label class="expand" for="c-42514319">[2 more]</label></div><br/><div class="children"><div class="content">An interesting point. Would there be any benefits to this non-local reasoning?</div><br/><div id="42514374" class="c"><input type="checkbox" id="c-42514374" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514319">parent</a><span>|</span><a href="#42511776">next</a><span>|</span><label class="collapse" for="c-42514374">[-]</label><label class="expand" for="c-42514374">[1 more]</label></div><br/><div class="children"><div class="content">Not unless you own and run the business, I suspect. You probably buy yourself a much higher absolute threshold of complexity you can comfortably handle in the codebase, but it&#x27;s not exactly like software developers are known to take kindly to being handed an Anki deck of design decisions, critical functions, etc. and being told &quot;please run this deck for 3 weeks and then we&#x27;ll get started&quot;.<p>I suspect it&#x27;s much more common that codebases evolve towards <i>requiring</i> this nonlocal reasoning over time than being intentionally designed with it in mind.</div><br/></div></div></div></div></div></div><div id="42511776" class="c"><input type="checkbox" id="c-42511776" checked=""/><div class="controls bullet"><span class="by">708145_</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511616">prev</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42511776">[-]</label><label class="expand" for="c-42511776">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The main benefit of Liskov&#x27;s substitution principle is ensure developers don&#x27;t need to dig into each and every concrete implementation to be able to reason locally about the code.<p>Yeah, but doesn&#x27;t help in this context (enable local reasoning) if the objects passed around have too much magic or are mutated all over the place. The enterprise OOP from 2010s was a clusterfuck full of unexpected side effects.</div><br/><div id="42511863" class="c"><input type="checkbox" id="c-42511863" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511776">parent</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42511863">[-]</label><label class="expand" for="c-42511863">[3 more]</label></div><br/><div class="children"><div class="content">I suspect that enterprise anything is going to be a hot mess, just because enterprises can&#x27;t hire many of the best people. Probably the problem we should address as an industry is: how to produce software with mostly low wattage people.</div><br/><div id="42512068" class="c"><input type="checkbox" id="c-42512068" checked=""/><div class="controls bullet"><span class="by">brokencode</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511863">parent</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42512068">[-]</label><label class="expand" for="c-42512068">[2 more]</label></div><br/><div class="children"><div class="content">The eventual solution will probably be to replace the low wattage people with high wattage machines.</div><br/><div id="42514603" class="c"><input type="checkbox" id="c-42514603" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512068">parent</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42514603">[-]</label><label class="expand" for="c-42514603">[1 more]</label></div><br/><div class="children"><div class="content">Sure, once they can solve advent of code problems on the second week..</div><br/></div></div></div></div></div></div></div></div><div id="42512698" class="c"><input type="checkbox" id="c-42512698" checked=""/><div class="controls bullet"><span class="by">6510</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511776">prev</a><span>|</span><a href="#42511630">next</a><span>|</span><label class="collapse" for="c-42512698">[-]</label><label class="expand" for="c-42512698">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity I sometimes rewrite things as spaghetti (if functions are short and aren&#x27;t called frequently) or using globals (if multiple functions have to many params) it usually doesn&#x27;t look better and when it does it usually doesn&#x27;t stay that way for very long. In the very few remaining cases I&#x27;m quite happy with it. It does help me think about what is going on.</div><br/></div></div></div></div><div id="42511630" class="c"><input type="checkbox" id="c-42511630" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511578">prev</a><span>|</span><a href="#42512571">next</a><span>|</span><label class="collapse" for="c-42511630">[-]</label><label class="expand" for="c-42511630">[1 more]</label></div><br/><div class="children"><div class="content">100% agree and this not only concerns readability. The concept of &quot;locality&quot; turns out to be a fairly universal concept, which applies to human processes just as much as technical ones. Side-effects are the root of all evil.<p>You don&#x27;t see a waiter taking orders from 1 person on a table, but rather go to a table and get orders from everybody sitting there.<p>And as for large methods, I find that they can be broken into smaller once just fine as long as you keep them side-effect free. Give them a clear name, a clear return value and now you have a good model for the underlying problem you are solving. Looking up the actual definition is just looking at implementation details.</div><br/></div></div><div id="42512571" class="c"><input type="checkbox" id="c-42512571" checked=""/><div class="controls bullet"><span class="by">jreback</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511630">prev</a><span>|</span><a href="#42517366">next</a><span>|</span><label class="collapse" for="c-42512571">[-]</label><label class="expand" for="c-42512571">[3 more]</label></div><br/><div class="children"><div class="content">Re: trust issues...I&#x27;d argue this is the purpose of automated tests. I think tests are too often left out of architectural discussions as if they are some additional artifact that gets created separately from the running software. The core &#x2F; foundational &#x2F; heavily reused parts of the architecture should have the most tests and ensure the consumers of those parts has no trust issues!</div><br/><div id="42513959" class="c"><input type="checkbox" id="c-42513959" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512571">parent</a><span>|</span><a href="#42517366">next</a><span>|</span><label class="collapse" for="c-42513959">[-]</label><label class="expand" for="c-42513959">[2 more]</label></div><br/><div class="children"><div class="content">Tests are good but moving left by lifting invariants into the type system is better.<p>Compare<p><pre><code>   fn send_email(addr: &amp;str, subject: &amp;str, body: &amp;str) -&gt; Result&lt;()&gt;
</code></pre>
to<p><pre><code>    fn send_email(add: &amp;EmailAddr, subject: &amp;str, body: &amp;str) -&gt; Result&lt;()&gt;
</code></pre>
In the second case, the edge cases of an empty or invalid email address don&#x27;t need to be tested, they are statically impossible.</div><br/><div id="42515746" class="c"><input type="checkbox" id="c-42515746" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513959">parent</a><span>|</span><a href="#42517366">next</a><span>|</span><label class="collapse" for="c-42515746">[-]</label><label class="expand" for="c-42515746">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the small concrete example. I try to explain this a lot. It also makes coverage really easy to get with fewer tests.</div><br/></div></div></div></div></div></div><div id="42517366" class="c"><input type="checkbox" id="c-42517366" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512571">prev</a><span>|</span><a href="#42512568">next</a><span>|</span><label class="collapse" for="c-42517366">[-]</label><label class="expand" for="c-42517366">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Proponents of small functions argue that you don&#x27;t have to read more than the signature and name of a function to understand what it does; it&#x27;s obvious what a function called last that takes a list and returns an optional value does.<p>I used to be one of those proponents, and have done a 180.<p>The problems are:<p>1. The names are never as self-evident as you think, even if you take great care with them.<p>2. Simply having so many names is an impediment in itself.<p>The better way:<p>Only break things up when you need to do.  This means the &quot;pieces&quot; of the system correspond to the things you care about and are likely to change.  You&#x27;ll know  where to look.<p>When you actually need an abstraction to share code between parts of the system, create it then.</div><br/></div></div><div id="42512568" class="c"><input type="checkbox" id="c-42512568" checked=""/><div class="controls bullet"><span class="by">casenmgreen</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42517366">prev</a><span>|</span><a href="#42517390">next</a><span>|</span><label class="collapse" for="c-42512568">[-]</label><label class="expand" for="c-42512568">[4 more]</label></div><br/><div class="children"><div class="content">I may be wrong, but my view of software is : you have functions, and you have the order in which functions are called.  Any given function is straightforward enough, if you define its function clearly and keep it small enough - both of which can reasonably be done.  Then we have the problem, which is the main problem, of the order in which functions are called.  For this, I use a state machine.  Write out the state machine, in full, in text, and then implement it directly, one function per state, one function per state transition.<p>The SM design doc is the documentation of the order of function calling, it is exhaustive and correct, and allows for straightforward changes in future (at least, as straightforward as possible - it is always a challenge to make changes).</div><br/><div id="42514396" class="c"><input type="checkbox" id="c-42514396" checked=""/><div class="controls bullet"><span class="by">euph0ria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512568">parent</a><span>|</span><a href="#42517390">next</a><span>|</span><label class="collapse" for="c-42514396">[-]</label><label class="expand" for="c-42514396">[3 more]</label></div><br/><div class="children"><div class="content">Would love to understand this better. Is there any example you could point to?</div><br/><div id="42514816" class="c"><input type="checkbox" id="c-42514816" checked=""/><div class="controls bullet"><span class="by">casenmgreen</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514396">parent</a><span>|</span><a href="#42517390">next</a><span>|</span><label class="collapse" for="c-42514816">[-]</label><label class="expand" for="c-42514816">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    init -&gt; success -&gt; red
    init -&gt; failure -&gt; cleanup

    red -&gt; success -&gt; red_yellow
    red -&gt; failure -&gt; cleanup

    red_yellow -&gt; success -&gt; green
    red_yellow -&gt; failure -&gt; cleanup

    green -&gt; success -&gt; yellow
    green -&gt; failure -&gt; cleanup

    yellow -&gt; success -&gt; red
    yellow -&gt; failure -&gt; cleanup

    cleanup -&gt; done -&gt; finish
</code></pre>
init&#x2F;red&#x2F;etc are states.<p>success&#x2F;failure&#x2F;etc are events.<p>Each state is a function.  The function red() for example, waits for 20 seconds,  then returns success (assuming nothing went wrong).<p>To start the state machine, initializes state to &quot;init&quot;, and enter a loop, in the loop you call the function for the current state (which makes that state actually happen and do whatever it does), and that function returns its event for whatever happen when it was run, and you then call a second function, which updates state based on the event which just occurred.  Keep doing that, until you hit state &quot;finish&quot;, then you&#x27;re done.</div><br/><div id="42518879" class="c"><input type="checkbox" id="c-42518879" checked=""/><div class="controls bullet"><span class="by">euph0ria</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514816">parent</a><span>|</span><a href="#42517390">next</a><span>|</span><label class="collapse" for="c-42518879">[-]</label><label class="expand" for="c-42518879">[1 more]</label></div><br/><div class="children"><div class="content">Got it, thanks. But it seemed from your original post that you tend to write state machines a lot more than the usual engineer does, would that be correct? Would you use this in a crud rest API for example?</div><br/></div></div></div></div></div></div></div></div><div id="42517390" class="c"><input type="checkbox" id="c-42517390" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512568">prev</a><span>|</span><a href="#42515598">next</a><span>|</span><label class="collapse" for="c-42517390">[-]</label><label class="expand" for="c-42517390">[1 more]</label></div><br/><div class="children"><div class="content">Types are somewhat a different dimension. Sort of the classic 1 dimensional argument about a 2 dimensional problem domain. Which quadrant you’re talking about alters whether the arguments support reality or argue with it.<p>If understanding a block of code requires knowing a concept that the team feels everyone should know anyway, then it’s not such an imposition. If the code invites you to learn that concept, so much the better. The code is “discoverable” - it invites you to learn more. If the concept is incidental to the problem and&#x2F;or the team is objectively wrong in their opinion, then you have tribal knowledge that is encroaching on the problem at hand. And whether it’s discoverable or not is neither here nor there. Because understanding the code requires knowing lots of other things, which means either memorization, or juggling more concepts than comfortably fit in short term memory - cognitive overload.<p>You know you’ve blown past this point when you finally trace the source of a bad piece of data but cannot remember why you were looking for it in the first place.<p>I’m hoping the problem of cognitive load gets more attention in the near future. We are overdue. But aside from people YouTubing code reviews, I’m still unclear what sorts of actionable metrics or feedback will win out in this arena. Maybe expanding code complexity to encompass the complexity of acquiring the values used in the code, not just the local data flow.</div><br/></div></div><div id="42515598" class="c"><input type="checkbox" id="c-42515598" checked=""/><div class="controls bullet"><span class="by">blago</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42517390">prev</a><span>|</span><a href="#42513498">next</a><span>|</span><label class="collapse" for="c-42515598">[-]</label><label class="expand" for="c-42515598">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Proponents of small functions argue that you don&#x27;t have to read more than the signature and name of a function to understand what it does;<p>Although this is often the case, the style of the program can change things significantly. Here are a few, not so uncommon, examples where it starts to break down:<p>1. When you’re crafting algorithms, you might try to keep code blocks brief, but coming up with precise, descriptive names for each 50-line snippet can be hard. Especially if the average developer might not even fully understand the textbook chapter behind it.<p>2. At some point you have to build higher than &quot;removeLastElementFromArray&quot;-type of functions. You are not going to get very far skimming domain-specific function names if don’t have any background in that area.<p>More examples exist, but these two illustrate the point.</div><br/><div id="42515844" class="c"><input type="checkbox" id="c-42515844" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515598">parent</a><span>|</span><a href="#42513498">next</a><span>|</span><label class="collapse" for="c-42515844">[-]</label><label class="expand" for="c-42515844">[1 more]</label></div><br/><div class="children"><div class="content">Both examples stem from not understanding the problem well enough I think. My best work is done when I first write a throwaway spaghetti solution to the problem. Only through this endeavour do I understand the problem well enough to effectively decompose the solution.</div><br/></div></div></div></div><div id="42513498" class="c"><input type="checkbox" id="c-42513498" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42515598">prev</a><span>|</span><a href="#42515019">next</a><span>|</span><label class="collapse" for="c-42513498">[-]</label><label class="expand" for="c-42513498">[1 more]</label></div><br/><div class="children"><div class="content">In regards to small functions, I think an important - but not often mentioned - aspect is shared assumptions. You can have many small functions with garbage abstractions that each implictly rely on the behaviour of each other - therefore the cognitive load is high. Or, you can have many small functions which are truly well-contained, in which case you may well need not read the implementation. Far too much code falls into the former scenario, IMO.</div><br/></div></div><div id="42515019" class="c"><input type="checkbox" id="c-42515019" checked=""/><div class="controls bullet"><span class="by">konschubert</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42513498">prev</a><span>|</span><a href="#42511974">next</a><span>|</span><label class="collapse" for="c-42515019">[-]</label><label class="expand" for="c-42515019">[1 more]</label></div><br/><div class="children"><div class="content">The first step for allowing local reasoning is to break your product  into independent subdomains that are as independent as possible.<p>For a software company, this means crafting the product ownership of your team such that the teams can act as independently as possible.<p>This is where most companies already fail.<p>Once this has been achieved, you can follow this pattern on smaller and smaller scales down to individual functions in your code.</div><br/></div></div><div id="42511974" class="c"><input type="checkbox" id="c-42511974" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42515019">prev</a><span>|</span><a href="#42515559">next</a><span>|</span><label class="collapse" for="c-42511974">[-]</label><label class="expand" for="c-42511974">[1 more]</label></div><br/><div class="children"><div class="content">This is absolutely the right way to think about things.<p>I like thinking about local reasoning in terms of (borrowing from Ed Page) &quot;units of controversy&quot;. For example, I like using newtypes for identifiers, because &quot;what strings are permitted to be identifiers&quot; is a unit of controversy.</div><br/></div></div><div id="42515559" class="c"><input type="checkbox" id="c-42515559" checked=""/><div class="controls bullet"><span class="by">tdiff</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511974">prev</a><span>|</span><a href="#42516108">next</a><span>|</span><label class="collapse" for="c-42515559">[-]</label><label class="expand" for="c-42515559">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Proponents of small functions argue that you don&#x27;t have to read more than the signature and name of a function to understand what it does; it&#x27;s obvious what a function called last that takes a list and returns an optional value does.<p>It&#x27;s also interesting that in comment to the same article many people argue against PR process. I hardly see how else that level of discipline required not to undermine trust in names of small methods can be maintained for any team with more than 3 developers.</div><br/></div></div><div id="42516108" class="c"><input type="checkbox" id="c-42516108" checked=""/><div class="controls bullet"><span class="by">meehai</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42515559">prev</a><span>|</span><a href="#42513570">next</a><span>|</span><label class="collapse" for="c-42516108">[-]</label><label class="expand" for="c-42516108">[1 more]</label></div><br/><div class="children"><div class="content">At work we have a pretty big Python monorepo. The way we scale it is by having many standalone CLI mini apps ( about 80) atm with most of them outputting json&#x2F;parquet in GCS or bigquery tables. Inputs are the same.<p>I insisted a lot on this unix (ish as it&#x27;s not pipes) philosophy. It paid off so far.<p>We can test each cli app as well as make broader integration tests.</div><br/></div></div><div id="42513570" class="c"><input type="checkbox" id="c-42513570" checked=""/><div class="controls bullet"><span class="by">holri</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42516108">prev</a><span>|</span><a href="#42515436">next</a><span>|</span><label class="collapse" for="c-42513570">[-]</label><label class="expand" for="c-42513570">[10 more]</label></div><br/><div class="children"><div class="content">I do not agree that typing leads to less cognitive load.
Typing often leads to more and more complicated code.
Dynamically typed code is often shorter and more compact.
If dynamically typed code is well written, its function, inputs and outputs are clear and obvious.
Clear and easy to understand code is not primarily a matter of typed or not typed code, it is a matter of a great programmer or a poor one.</div><br/><div id="42514520" class="c"><input type="checkbox" id="c-42514520" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513570">parent</a><span>|</span><a href="#42514346">next</a><span>|</span><label class="collapse" for="c-42514520">[-]</label><label class="expand" for="c-42514520">[5 more]</label></div><br/><div class="children"><div class="content">There is a function. It takes in 4 parameters. One of them is called ID<p>Is ID a string, a number, a GUID? Better check the usage within the function.<p>Oh, the declaration is `id: number`<p>Mystery solved.<p>Even better if the language supports subtyping so it is something like id: userID and userID is a subtype of number.</div><br/><div id="42515021" class="c"><input type="checkbox" id="c-42515021" checked=""/><div class="controls bullet"><span class="by">holri</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514520">parent</a><span>|</span><a href="#42514346">next</a><span>|</span><label class="collapse" for="c-42515021">[-]</label><label class="expand" for="c-42515021">[4 more]</label></div><br/><div class="children"><div class="content">In a dynamically duck typed language it should not matter if an ID is a string, a number or a GUID. The code should work with all of them. The semantically important thing is that this is an identifier. No String, number or GUI data type expresses this true meaning of the value.</div><br/><div id="42515948" class="c"><input type="checkbox" id="c-42515948" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515021">parent</a><span>|</span><a href="#42520171">next</a><span>|</span><label class="collapse" for="c-42515948">[-]</label><label class="expand" for="c-42515948">[2 more]</label></div><br/><div class="children"><div class="content">It matters a lot even in a duck typed language.<p>If there are multiple types of user IDs, I don&#x27;t want to pass the wrong one into a DB call.<p>This is often the case when dealing with systems that have internal IDs vs publicly exposed IDs. A good type system can correctly model which I have a hold of.<p>For complex objects proper typing is even more important. &quot;What fields exist on this object? I better check the code and see what gets accessed!&quot;<p>Even worse are functions where fields get added (or removed!) to an object as the object gets processed.<p>Absolute nightmare. The concept of data being a black box is stupid, the entire point of data is that at some point I&#x27;ll need to actually use it, which is a pain in the ass to do if no one ever defines what the hell fields are supposed to be laying around.</div><br/><div id="42516231" class="c"><input type="checkbox" id="c-42516231" checked=""/><div class="controls bullet"><span class="by">holri</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515948">parent</a><span>|</span><a href="#42520171">next</a><span>|</span><label class="collapse" for="c-42516231">[-]</label><label class="expand" for="c-42516231">[1 more]</label></div><br/><div class="children"><div class="content">By naming the variable ID it is crystal clear what the value is.
Most of the time an explicit type only adds cognitive load to the reader, and limits the universality of the code. At an high abstraction level, most of the time a type is from a program logic point of view an irrelevant machine implementation detail. If a specific duck is required it is explicitly tested. This makes code very clear when the duck type is important and when not.</div><br/></div></div></div></div><div id="42520171" class="c"><input type="checkbox" id="c-42520171" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515021">parent</a><span>|</span><a href="#42515948">prev</a><span>|</span><a href="#42514346">next</a><span>|</span><label class="collapse" for="c-42520171">[-]</label><label class="expand" for="c-42520171">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how you get a stray string in a column of integers.</div><br/></div></div></div></div></div></div><div id="42514346" class="c"><input type="checkbox" id="c-42514346" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513570">parent</a><span>|</span><a href="#42514520">prev</a><span>|</span><a href="#42513619">next</a><span>|</span><label class="collapse" for="c-42514346">[-]</label><label class="expand" for="c-42514346">[1 more]</label></div><br/><div class="children"><div class="content">Statically typed code definitely requires more effort to read, but this is not cognitive load. Cognitive load is about how much working memory is required. Statically typed code requires less cognitive load because some of the remembering is outsourced to the source code.<p>Statically typed code can lead to more complicated code; it can also accurately reflect the complexity inherent in the problem.</div><br/></div></div><div id="42513619" class="c"><input type="checkbox" id="c-42513619" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513570">parent</a><span>|</span><a href="#42514346">prev</a><span>|</span><a href="#42515436">next</a><span>|</span><label class="collapse" for="c-42513619">[-]</label><label class="expand" for="c-42513619">[3 more]</label></div><br/><div class="children"><div class="content">This is true at smaller scales and flips over on larger scales (larger codebase, dependencies, team&#x2F;teams sizes).</div><br/><div id="42514214" class="c"><input type="checkbox" id="c-42514214" checked=""/><div class="controls bullet"><span class="by">holri</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513619">parent</a><span>|</span><a href="#42515436">next</a><span>|</span><label class="collapse" for="c-42514214">[-]</label><label class="expand" for="c-42514214">[2 more]</label></div><br/><div class="children"><div class="content">A function is clear or not. I fail to see how the scale of the code, team, dependence is a factor in that.</div><br/><div id="42514907" class="c"><input type="checkbox" id="c-42514907" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514214">parent</a><span>|</span><a href="#42515436">next</a><span>|</span><label class="collapse" for="c-42514907">[-]</label><label class="expand" for="c-42514907">[1 more]</label></div><br/><div class="children"><div class="content">I split local reasoning into horizontal or vertical.<p>Vertical reasoning is reasoning inside a module or function. Here information hiding and clear interfaces help.<p>Horizontal reasoning is reasoning across the codebase in a limited context; adding a new parameter to a public function is a good example. The compiler helps you find and fix all the use sites, and with good ability to reason vertically at each site, even a change like this is simple.</div><br/></div></div></div></div></div></div></div></div><div id="42515436" class="c"><input type="checkbox" id="c-42515436" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42513570">prev</a><span>|</span><a href="#42514800">next</a><span>|</span><label class="collapse" for="c-42515436">[-]</label><label class="expand" for="c-42515436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If someone feels compelled to read every function either the functions are poor abstractions or the reader has trust issues, which may be warranted.<p>Or it&#x27;s open source and the authors were very much into Use The Source, Luke!</div><br/></div></div><div id="42514800" class="c"><input type="checkbox" id="c-42514800" checked=""/><div class="controls bullet"><span class="by">movpasd</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42515436">prev</a><span>|</span><a href="#42516700">next</a><span>|</span><label class="collapse" for="c-42514800">[-]</label><label class="expand" for="c-42514800">[1 more]</label></div><br/><div class="children"><div class="content">I feel that one big way in which engineers talk past each other is in assuming that code quality is an inherent property of the code itself. The code is meaningless without human (and computer) interpretation. Therefore, the quality of code is a function of the relationship between that code and its social context.<p>Cognitive load is contextual. `Option&lt;HashSet&lt;UserId&gt;&gt;` is readable to someone knowledgeable in the language (`Option`, `HashSet`) and in the system (meaning of `UserId` -- the name suggests it&#x27;s an integer or GUID newtype, but do we know that for sure? Perhaps it borrows conventions from a legacy system and so has more string-like semantics? Maybe users belong to groups, and the group ID is considered part of the user ID -- or perhaps to uniquely identify a user, you need both the group and user IDs together?).<p>What is the cognitive load of `Callable[[LogRecord, SystemDesc], int]`? Perhaps in context, `SystemDesc` is very obvious, or perhaps not. With surrounding documentation, maybe it is clear what the `int` is supposed to mean, or maybe it would be best served wrapped in a newtype. Maybe your function takes ten different `Callable`s and it would be better pulled out into an polymorphic type. But maybe your language makes that awkward or difficult. Or maybe your function is a library export, or even if it isn&#x27;t, it&#x27;s used in too many places to make refactoring worthwhile right now.<p>I also quite like newtypes for indicating pragmatics, but it is also a contextually-dependent trade-off. You may make calls to your module more obvious to read, but you also expand the module&#x27;s surface area. That means more things for people writing client code to understand, and more points of failure in case of changes (coupling). In the end, it seems to me that it is less important whether you use a newtype or not, and more important to be consistent.<p>In fact, this very trade-off -- readability versus surface area -- is at the heart of the &quot;small vs large functions&quot; debate. More smaller functions, and you push your complexity out into the interfaces and relationships between functions. Fewer large functions, and the complexity is internalised inside the functions.<p>To me, function size is less the deciding factor [0], but rather whether your interfaces are real, _conceptually_ clean joints of your solution. We have to think at a system level. Interfaces hide complexity, but only if the system as a whole ends up easier to reason about and easier to change. You pay a cost for both interface (surface area) and implementation (volume). There should be a happy middle.<p>---<p>[0] Also because size is often a deceptively poor indicator of implementation complexity in the first place, especially when mathematical expressions are involved. Mathematical expressions are fantastic exactly because they syntactically condense complexity, but it means very little syntactic redundancy, and so they seem to be magnets for typos and oversights.</div><br/></div></div><div id="42516700" class="c"><input type="checkbox" id="c-42516700" checked=""/><div class="controls bullet"><span class="by">mithametacs</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42514800">prev</a><span>|</span><a href="#42514897">next</a><span>|</span><label class="collapse" for="c-42516700">[-]</label><label class="expand" for="c-42516700">[1 more]</label></div><br/><div class="children"><div class="content">Not everything is a functional program though and side effects are important.  Types can’t* represent this.<p>*Not for practical programs</div><br/></div></div><div id="42514897" class="c"><input type="checkbox" id="c-42514897" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42516700">prev</a><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42514897">[-]</label><label class="expand" for="c-42514897">[4 more]</label></div><br/><div class="children"><div class="content">&gt;I&#x27;ve been thinking about the notion of &quot;reasoning locally&quot; recently. Enabling local reasoning is the only way to scale software development past some number of lines or complexity. When reasoning locally, one only needs to understand a small subset, hundreds of lines, to safely make changes in programs comprising millions.<p>Have you never heard of the word of our lord and saviour oop, or functions? It&#x27;s called encapsulation.<p>You might have learned it through prog langs as it is an embedded ideal</div><br/><div id="42514927" class="c"><input type="checkbox" id="c-42514927" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514897">parent</a><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42514927">[-]</label><label class="expand" for="c-42514927">[3 more]</label></div><br/><div class="children"><div class="content">As another sibling comment pointed out there are many tools that enable local reasoning, encapsulation is one such tool.<p>I&#x27;m not claiming the idea is novel, just that I haven&#x27;t encountered a name for it before.</div><br/><div id="42515080" class="c"><input type="checkbox" id="c-42515080" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42514927">parent</a><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42515080">[-]</label><label class="expand" for="c-42515080">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying that encapsulation is a tool for local reasoning, I&#x27;m saying they are the same concept.<p>How is the concept of local reasoning distinct from that of encapsulation?</div><br/><div id="42515799" class="c"><input type="checkbox" id="c-42515799" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42515080">parent</a><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42515799">[-]</label><label class="expand" for="c-42515799">[1 more]</label></div><br/><div class="children"><div class="content">I think most of us associate the word encapsulation with OOP nightmare code that spread mutable state across many small classes that often inherited from one another and hid the wrong state. Stateless and low state are the reaction to that. If you expand the term to include those aids to local reasoning then many more might agree with you.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42510866" class="c"><input type="checkbox" id="c-42510866" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#42511276">prev</a><span>|</span><a href="#42512063">next</a><span>|</span><label class="collapse" for="c-42510866">[-]</label><label class="expand" for="c-42510866">[120 more]</label></div><br/><div class="children"><div class="content">&gt; Mantras like &quot;methods should be shorter than 15 lines of code&quot; or &quot;classes should be small&quot; turned out to be somewhat wrong.<p>These hard rules may be useful when trying to instill good habits in juniors, but they become counterproductive when you start constraining experienced developers with arbitrary limits.<p>It’s really bad when you join a team that enforces rules like this. It almost always comes from a lead or manager who reads too many business books and then cargo cults those books on to the team.</div><br/><div id="42510935" class="c"><input type="checkbox" id="c-42510935" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42512167">next</a><span>|</span><label class="collapse" for="c-42510935">[-]</label><label class="expand" for="c-42510935">[103 more]</label></div><br/><div class="children"><div class="content">This is the bane of my existence at the moment after ~20 years into my career, and it frustrates me when I run into these situations when trying to get certain people to review pull requests (because I&#x27;m being kind, and adhering to a process, and there is really valuable feedback at times). But on the whole it&#x27;s like being dragged back down to working at a snails pace.<p>- Can&#x27;t refactor code because it changes too many files and too many lines.<p>- Can&#x27;t commit large chunks of well tested code that &#x27;Does feature X&#x27;, because... too many files and too many lines.<p>- Have to split everything down into a long sequence of consecutive pull requests that become a process nightmare in its own right<p>- The documentation comments gets nitpicked to death with mostly useless comments about not having periods at the ends of lines<p>- End up having to explain every little detail throughout the function as if I&#x27;m trying to produce a lecture, things like `&#x2F;* loop until not valid *&#x2F; while (!valid) {...` seemed to be what they wanted, but to me it made no sense what so ever to even have that comment<p>This can turn a ~50 line function into a 3 day process, a couple of hundred lines into a multi-week process, and a thousand or two line refactor (while retaining full test coverage) into a multi-month process.<p>At one point I just downed tools and quit the company, the absurdity of it all completely drained my motivation, killed progress &amp; flow and lead to features not being shipped.<p>Meanwhile with projects I&#x27;m managing I have a fairly good handle on &#x27;ok this code isnt the best, but it does work, it is fairly well tested, and it will be shipped as the beta&#x27;, so as to not be obstinate.</div><br/><div id="42512575" class="c"><input type="checkbox" id="c-42512575" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512773">next</a><span>|</span><label class="collapse" for="c-42512575">[-]</label><label class="expand" for="c-42512575">[33 more]</label></div><br/><div class="children"><div class="content">After 20 years of doing this, I’m convinced that required PR reviews aren’t worth the cost.<p>In the thousands of pull requests I’ve merged across many companies, I have never once had a reviewer catch a major bug (a bug that is severe enough that if discovered after hours, would require an oncall engineer to push a hot fix rather than wait for the normal deployment process to fix it).<p>I’ve pushed a few major bugs to production, but I’ve never had a PR reviewer catch one.<p>I’ve had reviewers make excellent suggestions, but it’s almost never anything that really matters. Certainly not worth all the time I’ve spent on the process.<p>That being said, I’m certainly not against collaboration, but I think required PR reviews aren’t the way to do it.</div><br/><div id="42513303" class="c"><input type="checkbox" id="c-42513303" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42512907">next</a><span>|</span><label class="collapse" for="c-42513303">[-]</label><label class="expand" for="c-42513303">[10 more]</label></div><br/><div class="children"><div class="content">The point of code reviews isn’t to catch bugs. It’s for someone else on the team to read your code and make sure they can understand it. If no one else on your team can understand your code, you shouldn’t be committing it to the repository.</div><br/><div id="42516119" class="c"><input type="checkbox" id="c-42516119" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42513303">parent</a><span>|</span><a href="#42515904">next</a><span>|</span><label class="collapse" for="c-42516119">[-]</label><label class="expand" for="c-42516119">[1 more]</label></div><br/><div class="children"><div class="content">Maybe. But then, sure, I can <i>understand</i> the code you wrote - on a syntactic&#x2F;operational level. This adds Foos to bar instead of baz, and makes Quux do extra Frob() call. Whatever, that&#x27;s stupid stuff <i>below junior level</i>. What would actually matter is for me to understand <i>why</i> you&#x27;re doing this, what it all <i>means</i>. Which I won&#x27;t, because you&#x27;re doing some code for symbolic transformation of equations for optimizing some process, and I&#x27;m doing data exchange between our backend and a million one-off proprietary industrial formats, and we only see each other on a team call once a week.<p>I&#x27;m exaggerating, but only a little. Point is, in a <i>deep</i> project you may have domain-specialized parts, and those specialties don&#x27;t overlap well. Like, ideally I&#x27;d take you aside for an hour to explain the 101 of the math you&#x27;re doing and the context surrounding the change, but if neither you nor me have the time, that PR is getting a +2 from me on the &quot;no stupid shit being done, looks legit code-wise; assuming you know your domain and this makes sense&quot; basis.</div><br/></div></div><div id="42515904" class="c"><input type="checkbox" id="c-42515904" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42513303">parent</a><span>|</span><a href="#42516119">prev</a><span>|</span><a href="#42518051">next</a><span>|</span><label class="collapse" for="c-42515904">[-]</label><label class="expand" for="c-42515904">[4 more]</label></div><br/><div class="children"><div class="content">HN moment. I’ve never seen in practice that someone says ”I don’t understand it” and the author says ”good point, I will simplify it”.<p>Rather, the opposite. I often saw people make unnecessary complex or large PRs that were too much workload to review, leading the reviewer to approve, on the grounds of ”seems like you know what you’re doing and tbh I don’t have half a day to review this properly”.<p>Code review is a ritual. If you ask why we have it people will give you hypothetical answers more often than concrete examples. Personally I’m a proponent of opt-in CRs, ie ask for a second pair of eyes when your spidey senses tell you.</div><br/><div id="42518899" class="c"><input type="checkbox" id="c-42518899" checked=""/><div class="controls bullet"><span class="by">throw-qqqqq</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42515904">parent</a><span>|</span><a href="#42519034">next</a><span>|</span><label class="collapse" for="c-42518899">[-]</label><label class="expand" for="c-42518899">[1 more]</label></div><br/><div class="children"><div class="content">Our juniors write horribly complex code that senior devs have to ask to simplify. This happens all the time. And the juniors simplify and thank us for teaching and mentoring. It’s a big reason we do reviews. So we can control how dirty the code is before merging and so we can grow each other with constructive feedback. Sometimes it’s also just “LGTM” if nothing smells.<p>90% of comments in my team’s PRs come with suggestions that can be applied with a click (we use GitLab). It requires almost no effort to apply suggestions and it’s often not much extra work for reviewers to explain and suggest a concrete change.<p>I agree that reviews should be used pragmatically.</div><br/></div></div><div id="42519034" class="c"><input type="checkbox" id="c-42519034" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42515904">parent</a><span>|</span><a href="#42518899">prev</a><span>|</span><a href="#42516158">next</a><span>|</span><label class="collapse" for="c-42519034">[-]</label><label class="expand" for="c-42519034">[1 more]</label></div><br/><div class="children"><div class="content">Get (or create) better colleagues. It&#x27;s usually pretty easy to identify if people are approving pull requests that they don&#x27;t understand. Pull them aside and have a professional talk about what a pull request review is. People want to do good, but you have to make it clear that you value their opinion.<p>If you treat the people around you as valuable collaborators instead of pawns to be played to fulfill your processes, your appreciation for reviews will transform. Remember that it&#x27;s their work too.</div><br/></div></div><div id="42516158" class="c"><input type="checkbox" id="c-42516158" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42515904">parent</a><span>|</span><a href="#42519034">prev</a><span>|</span><a href="#42518051">next</a><span>|</span><label class="collapse" for="c-42516158">[-]</label><label class="expand" for="c-42516158">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I often saw people make unnecessary complex or large PRs that were too much workload to review, leading the reviewer to approve, on the grounds of ”seems like you know what you’re doing and tbh I don’t have half a day to review this properly”<p>That just seems like company wide apathy to me. Obviously you have to make an effort to read the code, but there are lots of ways developers can overcomplicate things because they were excited to try a pattern or clever solution. It doesn&#x27;t make them bad devs, it&#x27;s just an easy trap to fall into.<p>These should not pass a code review just because the code &quot;works.&quot; It&#x27;s totally acceptable to say &quot;we&#x27;re not gonna understand this in 3 months the way it&#x27;s written, we need to make this simpler&quot; and give some suggestions. And usually (if you&#x27;re working with people that care about the workload they make for others) they will stop after a few reviews that point this out.<p>We&#x27;ve done this at our company and it&#x27;s helped us immensely. Recognizing whether the code is unnecessarily complex or the problem is inherently complex is part of it, though.</div><br/></div></div></div></div><div id="42518051" class="c"><input type="checkbox" id="c-42518051" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42513303">parent</a><span>|</span><a href="#42515904">prev</a><span>|</span><a href="#42515458">next</a><span>|</span><label class="collapse" for="c-42518051">[-]</label><label class="expand" for="c-42518051">[1 more]</label></div><br/><div class="children"><div class="content">I watched pre merge code reviews become a requirement in the industry and catching bugs was almost always the #1 reason given.<p>The times I&#x27;ve seen a 2nd set of eyes really help with the understandability of code, it was almost always collaboration before or while the code was being written.<p>I would estimate something like 1 out of 100 PR reviews I&#x27;ve seen in my life were really focussed on improving understandability.</div><br/></div></div><div id="42515458" class="c"><input type="checkbox" id="c-42515458" checked=""/><div class="controls bullet"><span class="by">deeviant</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42513303">parent</a><span>|</span><a href="#42518051">prev</a><span>|</span><a href="#42512907">next</a><span>|</span><label class="collapse" for="c-42515458">[-]</label><label class="expand" for="c-42515458">[3 more]</label></div><br/><div class="children"><div class="content">I feel if you ask 5 people what &quot;the point&quot; of codes review is, you&#x27;d get 6 different answers.</div><br/><div id="42516640" class="c"><input type="checkbox" id="c-42516640" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42515458">parent</a><span>|</span><a href="#42516411">next</a><span>|</span><label class="collapse" for="c-42516640">[-]</label><label class="expand" for="c-42516640">[1 more]</label></div><br/><div class="children"><div class="content">And a 7th complaining about the formatting of the question.</div><br/></div></div></div></div></div></div><div id="42512907" class="c"><input type="checkbox" id="c-42512907" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42513303">prev</a><span>|</span><a href="#42516856">next</a><span>|</span><label class="collapse" for="c-42512907">[-]</label><label class="expand" for="c-42512907">[5 more]</label></div><br/><div class="children"><div class="content">Wow someone who finally has this same unpopular opinion as I do. I&#x27;m a huge fan of review-optional PRs. Let it be up to the author to make that call and if it were really important to enforce it would be more foolproof to do so with automation.<p>Unfortunately every time I&#x27;ve proposed this it&#x27;s received like it&#x27;s sacrilegious but nobody could tell me why PR reviews are really necessary to be required.<p>The most ironic part is that I once caught a production-breaking bug in a PR while at FAANG and the author pushed back. Ultimately I decided it wasn&#x27;t worth the argument and just let it go through. Unsurprisingly, it broke production but we fixed it very quickly after we were all finally aligned that it was actually a problem.</div><br/><div id="42518015" class="c"><input type="checkbox" id="c-42518015" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512907">parent</a><span>|</span><a href="#42518207">next</a><span>|</span><label class="collapse" for="c-42518015">[-]</label><label class="expand" for="c-42518015">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Unfortunately every time I&#x27;ve proposed this it&#x27;s received like it&#x27;s sacrilegious but nobody could tell me why PR reviews are really necessary to be required.<p>Obvious signs of cargoculting in my opinion.</div><br/></div></div><div id="42518207" class="c"><input type="checkbox" id="c-42518207" checked=""/><div class="controls bullet"><span class="by">mattmanser</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512907">parent</a><span>|</span><a href="#42518015">prev</a><span>|</span><a href="#42516856">next</a><span>|</span><label class="collapse" for="c-42518207">[-]</label><label class="expand" for="c-42518207">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll bite.<p>To catch stupid mistakes  like an extra file, an accidental debug flag, a missing compiler hint that has to be added to migration scripts etc.<p>To ensure someone who doesn&#x27;t quite understand the difference between dev and production build pipelines doesn&#x27;t break it.<p>To ensure a certain direction is being followed when numerous contractors are working on the code. For example a vague consistency in API designs, API param names, ordering, etc.<p>To check obvious misunderstandings by juniors and new hires.<p>To nix architect astronauts before their &#x27;elegant&#x27; solution for saving a string to a database in 500 lines gets added.<p>To check the code is actually trying to solve the ticket instead of a wrong interpretation of the ticket.<p>To get introduced to parts of the codebase you haven&#x27;t worked on much.<p>But as with anything you get from it what you put in.</div><br/><div id="42519543" class="c"><input type="checkbox" id="c-42519543" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42518207">parent</a><span>|</span><a href="#42516856">next</a><span>|</span><label class="collapse" for="c-42519543">[-]</label><label class="expand" for="c-42519543">[1 more]</label></div><br/><div class="children"><div class="content">None of those are good reasons why PR reviews are necessary. They are examples of things that it&#x27;s theoretically possible a PR review might catch. But there&#x27;s no information there about how likely those things are to be caught.<p>Without that absolutely critical information, no cost benefit analysis is possible.<p>In my experience across many companies, PR reviews <i>almost never</i> catch any of those bugs or bring any of those benefits.</div><br/></div></div></div></div></div></div><div id="42516856" class="c"><input type="checkbox" id="c-42516856" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42512907">prev</a><span>|</span><a href="#42516637">next</a><span>|</span><label class="collapse" for="c-42516856">[-]</label><label class="expand" for="c-42516856">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you. If you give each dev a kind of sand-box to &quot;own&quot; within a project they&#x27;ll learn to find their own bugs, write both simple and robust code, lots of param checking — grow as an engineer that way.</div><br/></div></div><div id="42516637" class="c"><input type="checkbox" id="c-42516637" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42516856">prev</a><span>|</span><a href="#42514080">next</a><span>|</span><label class="collapse" for="c-42516637">[-]</label><label class="expand" for="c-42516637">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have never once had a reviewer catch a major bug<p>Just in 2024, I&#x27;ve had three or four caught[0] (and caught a couple myself on the project I have to PR review myself because no-one else understands&#x2F;wants to touch that system.)  I&#x27;ve also caught a couple that would have required a hotfix[1] without being a five-alarm alert &quot;things are down&quot;.<p>[0] including some subtle concurrency bugs<p>[1] e.g. reporting systems for moderation and support</div><br/></div></div><div id="42514080" class="c"><input type="checkbox" id="c-42514080" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42516637">prev</a><span>|</span><a href="#42514088">next</a><span>|</span><label class="collapse" for="c-42514080">[-]</label><label class="expand" for="c-42514080">[7 more]</label></div><br/><div class="children"><div class="content">Unfortunately for compliance reasons PRs are required.<p>Funny part is that not even in highly regulated markets.<p>ISO270001 or SOC2 are pretty much something every software company will have to do.</div><br/><div id="42517967" class="c"><input type="checkbox" id="c-42517967" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42514080">parent</a><span>|</span><a href="#42516585">next</a><span>|</span><label class="collapse" for="c-42517967">[-]</label><label class="expand" for="c-42517967">[3 more]</label></div><br/><div class="children"><div class="content">SOC2 doesn&#x27;t require code reviews. SOC2 is just a certification that you are following your own internal controls. There&#x27;s nothing that says required PR reviews have to be one of your internal controls. That&#x27;s just a common control that companies use.</div><br/><div id="42518285" class="c"><input type="checkbox" id="c-42518285" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517967">parent</a><span>|</span><a href="#42516585">next</a><span>|</span><label class="collapse" for="c-42518285">[-]</label><label class="expand" for="c-42518285">[2 more]</label></div><br/><div class="children"><div class="content">I would argue that &quot;common control that companies use&quot; falls under &quot;industry standard&quot; and I would say it would make it harder to pass certification without PR reviews documented on GitHub or something alike. So it does not require but everyone expects you to do so :)</div><br/><div id="42519606" class="c"><input type="checkbox" id="c-42519606" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42518285">parent</a><span>|</span><a href="#42516585">next</a><span>|</span><label class="collapse" for="c-42519606">[-]</label><label class="expand" for="c-42519606">[1 more]</label></div><br/><div class="children"><div class="content">The reason that this is common is that a company hires a SOC2 consultant who tells them that PR reviews are required despite that fact that this is a complete fabrication.<p>Locking yourself into an enormously expensive process with no evidence of its efficacy just because you don&#x27;t want read up on the process yourself or push back on a misinformed auditor is a terrible business decision.</div><br/></div></div></div></div></div></div><div id="42516585" class="c"><input type="checkbox" id="c-42516585" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42514080">parent</a><span>|</span><a href="#42517967">prev</a><span>|</span><a href="#42516467">next</a><span>|</span><label class="collapse" for="c-42516585">[-]</label><label class="expand" for="c-42516585">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is why we have required PR reviews at my company. It is to meet compliance controls.<p>We recently talked about not requiring reviews for people in L5 and above levels but ultimately got shut down due to compliance.</div><br/></div></div><div id="42516467" class="c"><input type="checkbox" id="c-42516467" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42514080">parent</a><span>|</span><a href="#42516585">prev</a><span>|</span><a href="#42514088">next</a><span>|</span><label class="collapse" for="c-42516467">[-]</label><label class="expand" for="c-42516467">[2 more]</label></div><br/><div class="children"><div class="content">Curious because I am not familiar: are PRs required or are PR <i>reviews</i> required?</div><br/><div id="42517222" class="c"><input type="checkbox" id="c-42517222" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42516467">parent</a><span>|</span><a href="#42514088">next</a><span>|</span><label class="collapse" for="c-42517222">[-]</label><label class="expand" for="c-42517222">[1 more]</label></div><br/><div class="children"><div class="content">Well &quot;Peer Review&quot; or &quot;Code Review&quot; is required - pull requests are easiest way to have it all documented with current state of art tooling. Otherwise you have to come up with some other way to document that for purpose of the audit.</div><br/></div></div></div></div></div></div><div id="42514088" class="c"><input type="checkbox" id="c-42514088" checked=""/><div class="controls bullet"><span class="by">tdrz</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42514080">prev</a><span>|</span><a href="#42517894">next</a><span>|</span><label class="collapse" for="c-42514088">[-]</label><label class="expand" for="c-42514088">[3 more]</label></div><br/><div class="children"><div class="content">The fact that there is a PR review process in place, makes commiters try harder. And that&#x27;s good!</div><br/><div id="42514141" class="c"><input type="checkbox" id="c-42514141" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42514088">parent</a><span>|</span><a href="#42517894">next</a><span>|</span><label class="collapse" for="c-42514141">[-]</label><label class="expand" for="c-42514141">[2 more]</label></div><br/><div class="children"><div class="content">Or try less because they have to spend time doing pr reviews</div><br/><div id="42515149" class="c"><input type="checkbox" id="c-42515149" checked=""/><div class="controls bullet"><span class="by">queuep</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42514141">parent</a><span>|</span><a href="#42517894">next</a><span>|</span><label class="collapse" for="c-42515149">[-]</label><label class="expand" for="c-42515149">[1 more]</label></div><br/><div class="children"><div class="content">Yes, same for QA sometimes.. dev sets bar lower as the QA can test it. Just makes a bunch of back and forth. And when stuff breaks nobody feels responsible.</div><br/></div></div></div></div></div></div><div id="42517894" class="c"><input type="checkbox" id="c-42517894" checked=""/><div class="controls bullet"><span class="by">jasonlotito</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42514088">prev</a><span>|</span><a href="#42515097">next</a><span>|</span><label class="collapse" for="c-42517894">[-]</label><label class="expand" for="c-42517894">[3 more]</label></div><br/><div class="children"><div class="content">Allowing anyone to promote anything to production without any other eyes on it is problematic. Not realizing this is extremely telling.<p>The presumed claim that no one at the company benefited from a second set of eyes is amazing, too.</div><br/><div id="42518118" class="c"><input type="checkbox" id="c-42518118" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517894">parent</a><span>|</span><a href="#42518173">next</a><span>|</span><label class="collapse" for="c-42518118">[-]</label><label class="expand" for="c-42518118">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Allowing anyone to promote anything to production without any other eyes on it is problematic.<p>In my experience the people who are promoting things to production that shouldn&#x27;t be will find a way to do it. They&#x27;ll either wear down the people who want to stop it, or they&#x27;ll find someone else to approve it who doesn&#x27;t know why it shouldn&#x27;t be approved or doesn&#x27;t care.<p>My hypothesis is that requiring any 2nd random engineer in the company to approve production code doesn&#x27;t provide enough value to justify the cost.<p>There may be other controls that are worth the cost.<p>However, our industry has been shipping software for a long time without this requirement, and I&#x27;ve seen no evidence that the practice has saved money, reduced the number of bugs, or improved software quality by any other metric. I think it&#x27;s time we examine the practice instead of taking it on faith that it&#x27;s a net benefit.<p>&gt;Not realizing this is extremely telling.<p>Nice way of saying, I don&#x27;t agree with you so I must be an idiot.</div><br/></div></div><div id="42518173" class="c"><input type="checkbox" id="c-42518173" checked=""/><div class="controls bullet"><span class="by">jvans</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517894">parent</a><span>|</span><a href="#42518118">prev</a><span>|</span><a href="#42515097">next</a><span>|</span><label class="collapse" for="c-42518173">[-]</label><label class="expand" for="c-42518173">[1 more]</label></div><br/><div class="children"><div class="content">but there isn&#x27;t actually a second set of eyes because the second set of eyes you&#x27;re thinking about is complaining about formatting or slamming the approve button without actually looking</div><br/></div></div></div></div><div id="42515097" class="c"><input type="checkbox" id="c-42515097" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42517894">prev</a><span>|</span><a href="#42512773">next</a><span>|</span><label class="collapse" for="c-42515097">[-]</label><label class="expand" for="c-42515097">[2 more]</label></div><br/><div class="children"><div class="content">Required PR reviews means that if someone steals your credentials, or kidnaps your child, you can&#x27;t get something into production that steals all the money without someone else somewhere else having to push a button also.<p>It&#x27;s the two-person rule, the two nuclear keyswitches.</div><br/><div id="42518000" class="c"><input type="checkbox" id="c-42518000" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42515097">parent</a><span>|</span><a href="#42512773">next</a><span>|</span><label class="collapse" for="c-42518000">[-]</label><label class="expand" for="c-42518000">[1 more]</label></div><br/><div class="children"><div class="content">This is definitely not why PR reviews are required. Most companies don&#x27;t really know why they require them, but I&#x27;ve definitely never heard one say it was because they were afraid of malicious code from stolen credentials.<p>There&#x27;s so many other ways you can inject malicious code with stolen credentials that doesn&#x27;t require a PR in every production environment I&#x27;ve ever worked in. There&#x27;s much lower hanging fruit that leaves far fewer footprints.</div><br/></div></div></div></div></div></div><div id="42512773" class="c"><input type="checkbox" id="c-42512773" checked=""/><div class="controls bullet"><span class="by">charlie0</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512575">prev</a><span>|</span><a href="#42511011">next</a><span>|</span><label class="collapse" for="c-42512773">[-]</label><label class="expand" for="c-42512773">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m one of the rare individuals who really tries to review code and leave helpful comments. I&#x27;ve been on the receiving end of really big PRs and can say I understand why you&#x27;re being told to break things up into smaller chunks.<p>Most of the devs who submit large PRs just don&#x27;t have a good grasp of organizing things well enough. I&#x27;ve seen this over and over again and it&#x27;s due to not spending enough time planning out a feature. There will be exceptions to this, but when devs keep doing it over and over, it&#x27;s the reviewer&#x27;s job to reject it and send it back with helpful feedback.<p>I also understand most people don&#x27;t like the friction this can create and so you end you with 80% of PRs being rubber stamped and bugs getting into production because the reviewers just give up on trying to make people better devs.</div><br/><div id="42515104" class="c"><input type="checkbox" id="c-42515104" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512773">parent</a><span>|</span><a href="#42511011">next</a><span>|</span><label class="collapse" for="c-42515104">[-]</label><label class="expand" for="c-42515104">[2 more]</label></div><br/><div class="children"><div class="content">The reviewer&#x27;s job is primarily to ensure business continuity, and only marginally to make people better devs.</div><br/><div id="42516460" class="c"><input type="checkbox" id="c-42516460" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42515104">parent</a><span>|</span><a href="#42511011">next</a><span>|</span><label class="collapse" for="c-42516460">[-]</label><label class="expand" for="c-42516460">[1 more]</label></div><br/><div class="children"><div class="content">When I review code I never think I am there to make people better devs.<p>I’m reviewing the code because I don’t want shit code merged into the code base I am responsible for operating. I’m going to be the one debugging that. Don’t just merge shit you feel like merging.</div><br/></div></div></div></div></div></div><div id="42511011" class="c"><input type="checkbox" id="c-42511011" checked=""/><div class="controls bullet"><span class="by">NotBoolean</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512773">prev</a><span>|</span><a href="#42511471">next</a><span>|</span><label class="collapse" for="c-42511011">[-]</label><label class="expand" for="c-42511011">[32 more]</label></div><br/><div class="children"><div class="content">I don’t have your experience but I personally think some of this feedback can be warranted.<p>&gt; Can&#x27;t refactor code because it changes too many files and too many lines.<p>This really depends on the change. If you are just doing a mass rename like updating a function signature, fair enough but if you changing a lot of code it’s very hard to review it. Lots of cognitive load on the reviewer who might not have the same understanding of codebase as you.<p>&gt; Can&#x27;t commit large chunks of well tested code that &#x27;Does feature X&#x27;, because... too many files and too many lines.<p>Same as the above, reviewing is hard and more code means people get lazy and bored. Just because the code is tested doesn’t mean it’s correct, just means it passes tests.<p>&gt; Have to split everything down into a long sequence of consecutive pull requests that become a process nightmare in its own right<p>This is planning issue, if you correctly size tickets you aren’t going to end up in messy situations as often.<p>&gt; The documentation comments gets nitpicked to death with mostly useless comments about not having periods at the ends of lines<p>Having correctly written documentation is important. It can live a long time and if you don’t keep an eye on it can becomes a mess. Ideally you should review it before you submitting it to avoid these issues.<p>&gt; End up having to explain every little detail throughout the function as if I&#x27;m trying to produce a lecture, things like `&#x2F;* loop until not valid *&#x2F; while (!valid) {...` seemed to be what they wanted, but to me it made no sense what so ever to even have that comment<p>I definitely agree with this one. Superfluous comments are a waste of time.<p>Obviously this is just my option and you can take things too far but I do think that making code reviewable (by making it small) goes a long way. No one wants to review 1000s lines of code at once. It’s too much to process and people will do a worse job.<p>Happy to hear your thoughts.</div><br/><div id="42511206" class="c"><input type="checkbox" id="c-42511206" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511056">next</a><span>|</span><label class="collapse" for="c-42511206">[-]</label><label class="expand" for="c-42511206">[21 more]</label></div><br/><div class="children"><div class="content">&gt; This is planning issue, if you correctly size tickets you aren’t going to end up in messy situations as often.<p>No, it’s “this refactor looks very different to the original code because the original code thought it was doing two different things and it’s only by stepping through it with real customer data that you realized with the right inputs (not documented) it could do a third thing (not documented) that had very important “side effects” and was a no-op in the original code flow. Yea, it touches a lot of files. Ok, yea, I can break it up step by step, and wait a few days between approval for each of them so that you never have to actually understand what just happened”.</div><br/><div id="42511644" class="c"><input type="checkbox" id="c-42511644" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511206">parent</a><span>|</span><a href="#42512455">next</a><span>|</span><label class="collapse" for="c-42511644">[-]</label><label class="expand" for="c-42511644">[13 more]</label></div><br/><div class="children"><div class="content">so, it&#x27;s not just a refactoring then; it&#x27;s also bug fixes + refactoring. In my experience, those are the worst PRs to review. Either just fix the bugs, or just refactor it. Don&#x27;t do both because now I have to spend more time checking the bugs you claim to fix AND your refactoring for new bugs.</div><br/><div id="42511759" class="c"><input type="checkbox" id="c-42511759" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511644">parent</a><span>|</span><a href="#42519281">next</a><span>|</span><label class="collapse" for="c-42511759">[-]</label><label class="expand" for="c-42511759">[11 more]</label></div><br/><div class="children"><div class="content">There are certainly classes of bugs for which refactoring is the path of lowest resistance</div><br/><div id="42512215" class="c"><input type="checkbox" id="c-42512215" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511759">parent</a><span>|</span><a href="#42512139">next</a><span>|</span><label class="collapse" for="c-42512215">[-]</label><label class="expand" for="c-42512215">[2 more]</label></div><br/><div class="children"><div class="content">The most common IME are bugs that come from some wrong conceptual understanding underpinning the code. Rewriting the code with a correct conceptual understanding automatically fixes the bugs.</div><br/><div id="42512476" class="c"><input type="checkbox" id="c-42512476" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512215">parent</a><span>|</span><a href="#42512139">next</a><span>|</span><label class="collapse" for="c-42512476">[-]</label><label class="expand" for="c-42512476">[1 more]</label></div><br/><div class="children"><div class="content">The classic example of this is concurrency errors or data corruption related to multiple non-atomic writes.</div><br/></div></div></div></div><div id="42512139" class="c"><input type="checkbox" id="c-42512139" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511759">parent</a><span>|</span><a href="#42512215">prev</a><span>|</span><a href="#42519281">next</a><span>|</span><label class="collapse" for="c-42512139">[-]</label><label class="expand" for="c-42512139">[8 more]</label></div><br/><div class="children"><div class="content">And there are multi-PR processes that can be followed to most successfully convert those changes in a comprehensible way.<p>It&#x27;ll often include extra scaffolding and &#x2F; or extra classes and then renaming those classes to match the old classes&#x27; name after you&#x27;re done, to reduce future cognitive load.</div><br/><div id="42516120" class="c"><input type="checkbox" id="c-42516120" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512139">parent</a><span>|</span><a href="#42519281">next</a><span>|</span><label class="collapse" for="c-42516120">[-]</label><label class="expand" for="c-42516120">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m unconvinced that adding extra code churn in order to split up a refactor that fixes bugs into a bugfix and a refactor is worthwhile</div><br/><div id="42517076" class="c"><input type="checkbox" id="c-42517076" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42516120">parent</a><span>|</span><a href="#42519281">next</a><span>|</span><label class="collapse" for="c-42517076">[-]</label><label class="expand" for="c-42517076">[6 more]</label></div><br/><div class="children"><div class="content">One metric I like to give my team is to have any new PR start a review in less than 15 minutes and be completed within 15 minutes. So, the longest you should wait is about 30 minutes for a review. That means teams either go &quot;fuck it&quot; and rubber stamp massive PRs -- which is a whole different issue -- or they take it seriously and keep PRs small to get their PRs reviewed in less than 30 minutes.<p>In most cases where I see responses like this, they&#x27;re not surprised to wait hours or days for a PR review. In that case, it makes sense to go big, otherwise you&#x27;ll never get anything done. If you only have to wait half an hour, max, for a PR review; the extra code churn is 1000% worth it.</div><br/><div id="42517322" class="c"><input type="checkbox" id="c-42517322" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517076">parent</a><span>|</span><a href="#42517826">next</a><span>|</span><label class="collapse" for="c-42517322">[-]</label><label class="expand" for="c-42517322">[2 more]</label></div><br/><div class="children"><div class="content">This is where my stance is.<p>As a developer, I want my PRs to actually be reviewed by my coworkers and to have issues caught as a second layer of defense, etc.<p>As a reviewer, I effectively stopped approving things I couldn&#x27;t give at least a cursory, reasonable glance (and tried to encourage others to follow suit because if we&#x27;re not reviewing things, why not just push directly to main).<p>As a consequence, I have:<p><pre><code>  * tried to review most things within like half an hour of their announcement
    in the shared MR channel

  * requested a pair programming session and offered to do a pair programming
    session for any large and semi-or-fully automated refactoring session,
    like running a linter or doing a multi-file variable rename
    (the pair programmer immediately comments on and approves the MR when it
    appears)

  * tried to limit my PRs to approximately 400 lines (not a rigid rule)
</code></pre>
There were some specific instances of people not liking the &quot;you must pair program if you&#x27;re going to touch 400 files in one PR&quot; requirement; but otherwise, I would like to think those on my team liked the more regular PRs, more people doing the PRs, etc, that resulted from this and some healthy culture changes.<p>I would also like to feel like the more junior devs were more willing to say anything at all in the PRs because they could follow the change.</div><br/><div id="42517422" class="c"><input type="checkbox" id="c-42517422" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517322">parent</a><span>|</span><a href="#42517826">next</a><span>|</span><label class="collapse" for="c-42517422">[-]</label><label class="expand" for="c-42517422">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen this and variations done by teams to implement the metric. Usually, the “biggest” friction comes from “how do we know a PR needs to be reviewed within the time frame?” To which I always want to answer: “you have a mouth, put noises through it.” Sigh, sometimes I miss the military… anyway, toxic behavior aside, this is usually the biggest thing. I have to remind them that they go get coffee or smoke at least every hour, but rarely at the same time; so maybe then might be a good time to just do a quick check for an open PR. Or turn on notifications. Or if it’s urgent, mention it in the dev team channel.<p>But yeah, it’s hard to get the culture rolling if it isn’t already in place nor has anyone in the company worked with a culture like that.</div><br/></div></div></div></div><div id="42517826" class="c"><input type="checkbox" id="c-42517826" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517076">parent</a><span>|</span><a href="#42517322">prev</a><span>|</span><a href="#42519281">next</a><span>|</span><label class="collapse" for="c-42517826">[-]</label><label class="expand" for="c-42517826">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m all for low-latency reviews, but this target seems crazy: a perfect recipe for a lot of apparent activity for little actual progress. Maybe it depends on the project, but for a lot of projects 15 minutes of review time means you basically are only going to accept trivial changes.</div><br/><div id="42517929" class="c"><input type="checkbox" id="c-42517929" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517826">parent</a><span>|</span><a href="#42518187">next</a><span>|</span><label class="collapse" for="c-42517929">[-]</label><label class="expand" for="c-42517929">[1 more]</label></div><br/><div class="children"><div class="content">As it turns out, most of the work that most developers do is updating or enhancing CRUD apps. There&#x27;s already a plan and an intent that just needs to be typed out.<p>I&#x27;ve found 15-30 minutes to be plenty of time to review about a day&#x27;s worth of code. It&#x27;s enough time to process what the code is doing and iterate over the tests, in general.<p>Here&#x27;s a scary thought: if something small takes 15-30 minutes to appropriately process ... how much longer do *large* changes take? Can someone keep all that in their mind that whole time to comprehend and process a huge change?<p>And a better question, will they?</div><br/></div></div><div id="42518187" class="c"><input type="checkbox" id="c-42518187" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517826">parent</a><span>|</span><a href="#42517929">prev</a><span>|</span><a href="#42519281">next</a><span>|</span><label class="collapse" for="c-42518187">[-]</label><label class="expand" for="c-42518187">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 15 minutes of review time means you basically are only going to accept trivial changes.<p>Um, yes. This is 100% the point. There is no amount of refactoring, bug fixing, or features that cannot be expressed as a chain of trivial changes.<p>What you usually see happen is that instead of spending a week experimenting with 15 different refactors, is that an engineer opens a PR with what they think they&#x27;re going to try first. Other engineers point out how they had tried that before and it didn&#x27;t work; but maybe this other way will. So, they end up &quot;working together&quot; on the refactor instead of one developer getting lost in the sauce for a week seeing what sticks to a wall.<p>In essence, about the same amount of time is spent; but the code is higher quality and no architecture reviews during code reviews (which is another rule that should exist on a team -- architecture reviews should happen before a single line of code is touched).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42519281" class="c"><input type="checkbox" id="c-42519281" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511644">parent</a><span>|</span><a href="#42511759">prev</a><span>|</span><a href="#42512455">next</a><span>|</span><label class="collapse" for="c-42519281">[-]</label><label class="expand" for="c-42519281">[1 more]</label></div><br/><div class="children"><div class="content">No, I very deliberately did not describe any bug fixes.</div><br/></div></div></div></div><div id="42512455" class="c"><input type="checkbox" id="c-42512455" checked=""/><div class="controls bullet"><span class="by">justatdotin</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511206">parent</a><span>|</span><a href="#42511644">prev</a><span>|</span><a href="#42511383">next</a><span>|</span><label class="collapse" for="c-42512455">[-]</label><label class="expand" for="c-42512455">[2 more]</label></div><br/><div class="children"><div class="content">&gt; only by stepping through it with real customer data that you realized with the right inputs (not documented) it could do a third thing (not documented) that had very important “side effects” and was a no-op in the original code flow<p>sounds like the &#x27;nightmare&#x27; was already there, not in the refactor. First step should be some tests to confirm the undocumented behaviour.<p>Some of your complaints seem to be about peer review (&#x27;approval&#x27;). I found my work life improved a lot once I embraced async review as a feature, not a bug.<p>As for &#x27;break it up step by step&#x27; - I know how much I appreciate reviewing a feature that is well presented in this way, and so I&#x27;ve got good at rearranging my work (when necessary) to facilitate smooth reviews.</div><br/><div id="42519262" class="c"><input type="checkbox" id="c-42519262" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512455">parent</a><span>|</span><a href="#42511383">next</a><span>|</span><label class="collapse" for="c-42519262">[-]</label><label class="expand" for="c-42519262">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sounds like the &#x27;nightmare&#x27; was already there, not in the refactor<p>I admit that I am pretty allergic to people who avoid working with imperfect code.</div><br/></div></div></div></div><div id="42511383" class="c"><input type="checkbox" id="c-42511383" checked=""/><div class="controls bullet"><span class="by">grey-area</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511206">parent</a><span>|</span><a href="#42512455">prev</a><span>|</span><a href="#42511417">next</a><span>|</span><label class="collapse" for="c-42511383">[-]</label><label class="expand" for="c-42511383">[4 more]</label></div><br/><div class="children"><div class="content">The way I normally approach this is one big pr for context and then break it into lots of small ones for review.</div><br/><div id="42511852" class="c"><input type="checkbox" id="c-42511852" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511383">parent</a><span>|</span><a href="#42511832">next</a><span>|</span><label class="collapse" for="c-42511852">[-]</label><label class="expand" for="c-42511852">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found processes like this to work better, too. Basically, the one big pr is like building a prototype to throw away. And the benefit is it has to get thrown away because the PR will never pass review.</div><br/></div></div><div id="42511832" class="c"><input type="checkbox" id="c-42511832" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511383">parent</a><span>|</span><a href="#42511852">prev</a><span>|</span><a href="#42511417">next</a><span>|</span><label class="collapse" for="c-42511832">[-]</label><label class="expand" for="c-42511832">[2 more]</label></div><br/><div class="children"><div class="content">A PR with self-contained smaller commits would be possible as well.</div><br/><div id="42512148" class="c"><input type="checkbox" id="c-42512148" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511832">parent</a><span>|</span><a href="#42511417">next</a><span>|</span><label class="collapse" for="c-42512148">[-]</label><label class="expand" for="c-42512148">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though it does depend on how good the commenting system is; and, for something like that, you&#x27;re still probably going to want a meeting to walk people through such a huge change.<p>And you&#x27;d better hope you&#x27;re not squashing that monstrous thing when you&#x27;re done.</div><br/></div></div></div></div></div></div></div></div><div id="42511056" class="c"><input type="checkbox" id="c-42511056" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511206">prev</a><span>|</span><a href="#42511300">next</a><span>|</span><label class="collapse" for="c-42511056">[-]</label><label class="expand" for="c-42511056">[7 more]</label></div><br/><div class="children"><div class="content">I do object to the notion of something being a planning issue when you&#x27;re talking about a days worth of work.<p>Implement X, needs Y and Z, ok that was straightforward, also discovered U and V on the way and sorted that out, here&#x27;s a pull request that neatly wraps it up.<p>Which subsequently gets turned into a multi-week process, going back &amp; forth almost every day, meaning I can&#x27;t move on to the next thing, meanwhile I&#x27;m looking at the cumulative hourly wages of everybody involved and the cost is... shocking.<p>Death by process IHMO.</div><br/><div id="42511222" class="c"><input type="checkbox" id="c-42511222" checked=""/><div class="controls bullet"><span class="by">bspammer</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511056">parent</a><span>|</span><a href="#42512490">next</a><span>|</span><label class="collapse" for="c-42511222">[-]</label><label class="expand" for="c-42511222">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Implement X, needs Y and Z, ok that was straightforward, also discovered U and V on the way and sorted that out, here&#x27;s a pull request that neatly wraps it up<p>This sounds very difficult to review to be honest. At a minimum unrelated changes should be in their own pull request (U and V in your example).</div><br/><div id="42512557" class="c"><input type="checkbox" id="c-42512557" checked=""/><div class="controls bullet"><span class="by">tacitusarc</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511222">parent</a><span>|</span><a href="#42512114">next</a><span>|</span><label class="collapse" for="c-42512557">[-]</label><label class="expand" for="c-42512557">[2 more]</label></div><br/><div class="children"><div class="content">I work as a tech lead, so I get a lot of leeway in setting process. For small PRs, we use the normal “leave comments, resolve comments” approach. For large PRs, we schedule 30m  meetings, where the submitter can explain the changes and answer questions, and record any feedback. This ensures everyone is on the same page with the changes, gives folks a chance to rapidly gather feedback, and helps familiarize devs who do not work in that area with what is going on. If the meeting is insufficient to feel like everyone is on the same page and approves the changes, we schedule another one.<p>These are some of the best meetings we have. They are targeted, educational, and ensure we don’t have long delays waiting for code to go in. Instead of requiring every PR to be small, which has a high cost, I recommend doing this for large&#x2F;complex projects.<p>One additional thing to note on small PRs: often, they require significant context, which could take hours or even days, to be built up repeatedly. Contrast that with being able to establish context, and then solve several large problems all at once. The latter is more efficient, so if it can be enabled without negative side effects, it is really valuable.<p>I want my team to be productive, and I want to empower them to improve the codebase whenever they see an opportunity, even if it is not related to their immediate task.</div><br/><div id="42512610" class="c"><input type="checkbox" id="c-42512610" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512557">parent</a><span>|</span><a href="#42512114">next</a><span>|</span><label class="collapse" for="c-42512610">[-]</label><label class="expand" for="c-42512610">[1 more]</label></div><br/><div class="children"><div class="content">One minor piece of insight from me is about release management vs pull-requests.<p>As you say it&#x27;s much easier to schedule a 30 minute meeting, then we can - with context - resolve any immediate nitpicks you have, but we can also structure bigger things.<p>&#x27;Would this block a release?&#x27;<p>&#x27;Can we just get this done in the PR and merge it&#x27;<p>&#x27;Ok, so when it&#x27;s done... what is the most important thing that we need to document?&#x27;<p>Where the fact that even after it&#x27;s merged, it&#x27;s going to sit in the repo for a while until we decide to hit the &#x27;release&#x27; button&#x27;, this lets people defer stuff to work on next and defines a clear line of &#x27;good enough&#x27;</div><br/></div></div></div></div><div id="42512114" class="c"><input type="checkbox" id="c-42512114" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511222">parent</a><span>|</span><a href="#42512557">prev</a><span>|</span><a href="#42511366">next</a><span>|</span><label class="collapse" for="c-42512114">[-]</label><label class="expand" for="c-42512114">[1 more]</label></div><br/><div class="children"><div class="content">How do you rework a core process, then? If you rework a major unit that touches just about everything... Sharding something like that can break the actual improvement it is trying to deliver.<p>Like... Increase the performance of a central VM. You&#x27;ll touch every part of the code, but probably also build a new compiler analysis system. The system is seperate to existing code, but useless without the core changes. Seperating the two can ruin the optimisation meant to be delivered, because the context is no longer front and center. Allowing more quibling to degrade the changes.</div><br/></div></div><div id="42511366" class="c"><input type="checkbox" id="c-42511366" checked=""/><div class="controls bullet"><span class="by">pbh101</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511222">parent</a><span>|</span><a href="#42512114">prev</a><span>|</span><a href="#42512490">next</a><span>|</span><label class="collapse" for="c-42511366">[-]</label><label class="expand" for="c-42511366">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Another item here that is contextual: what is the cost of a bug? Does it cost millions, do we find that out immediately, or does it take months? Or does it not really matter, and when we’ll find the big it will be cheap?  The OP joining a new company might not have the context that existing employees have about why we’re being cautious&#x2F;clear about what we’re changing as opposed to smuggling in refactors in the same PR as a feature change.<p>I’m going to be the guy that is asking for a refactor to be in a separate commit&#x2F;PR from the feature and clearly marked.<p>It doesn’t justify everything else he mentioned (especially the comments piece) but once you get used to this it doesn’t need to extend timelines.</div><br/></div></div></div></div><div id="42512490" class="c"><input type="checkbox" id="c-42512490" checked=""/><div class="controls bullet"><span class="by">justatdotin</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511056">parent</a><span>|</span><a href="#42511222">prev</a><span>|</span><a href="#42511300">next</a><span>|</span><label class="collapse" for="c-42512490">[-]</label><label class="expand" for="c-42512490">[1 more]</label></div><br/><div class="children"><div class="content">Yes, wrapping other discoveries into your feature work is a planning issue that might impact on the review burden.</div><br/></div></div></div></div><div id="42511300" class="c"><input type="checkbox" id="c-42511300" checked=""/><div class="controls bullet"><span class="by">callc</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511056">prev</a><span>|</span><a href="#42512316">next</a><span>|</span><label class="collapse" for="c-42511300">[-]</label><label class="expand" for="c-42511300">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is planning issue, if you correctly size tickets you aren’t going to end up in messy situations as often.<p>I think the underlying issue is what is an appropriate “unit of work”. Parent commenter may want to ship a complete&#x2F;entire feature in one MR. Ticketing obsessed people will have some other metric. Merge process may be broken in this aspect. I would rather explain to reviewer to bring them up to speed on the changes to make their cognitive load easier</div><br/><div id="42511708" class="c"><input type="checkbox" id="c-42511708" checked=""/><div class="controls bullet"><span class="by">gjadi</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511300">parent</a><span>|</span><a href="#42512316">next</a><span>|</span><label class="collapse" for="c-42511708">[-]</label><label class="expand" for="c-42511708">[1 more]</label></div><br/><div class="children"><div class="content">This. The solution to long and multiple reviews to MR is single pair review session where most of the big picture aspects can be addressed immediately and verbally discussed and challenged.<p>IMHO it is the same as chat. If talking about an issue over mail or chat takes more than 3-5 messages, trigger a call to solve it face to face.</div><br/></div></div></div></div><div id="42512316" class="c"><input type="checkbox" id="c-42512316" checked=""/><div class="controls bullet"><span class="by">8note</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511300">prev</a><span>|</span><a href="#42511471">next</a><span>|</span><label class="collapse" for="c-42512316">[-]</label><label class="expand" for="c-42512316">[1 more]</label></div><br/><div class="children"><div class="content">code reviews that are too small, i think are worse than ones that are too big, and let through more bugs.<p>10 different reviewers can each look at a 100 lin change out of the 1000 line total change, but each miss how the changes work together.<p>theyre all lying by approving, since they dont have the right context to approve</div><br/></div></div></div></div><div id="42511471" class="c"><input type="checkbox" id="c-42511471" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511011">prev</a><span>|</span><a href="#42511286">next</a><span>|</span><label class="collapse" for="c-42511471">[-]</label><label class="expand" for="c-42511471">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The documentation comments gets nitpicked to death with mostly useless comments about not having periods at the ends of lines
&gt; End up having to explain every little detail throughout the function<p>For these cases I like to use the ‘suggest an edit’ feature on gitlab&#x2F;github. Can have the change queued up in the comments and batch commit together, and takes almost no additional time&#x2F;effort for the author. I typically add these suggestion comments and give an approve at the same time for small nitpicks, so no slow down in the PR process.</div><br/><div id="42511827" class="c"><input type="checkbox" id="c-42511827" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511471">parent</a><span>|</span><a href="#42511286">next</a><span>|</span><label class="collapse" for="c-42511827">[-]</label><label class="expand" for="c-42511827">[2 more]</label></div><br/><div class="children"><div class="content">I good process would be to just push the proposal to the branch in review.</div><br/><div id="42512293" class="c"><input type="checkbox" id="c-42512293" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511827">parent</a><span>|</span><a href="#42511286">next</a><span>|</span><label class="collapse" for="c-42512293">[-]</label><label class="expand" for="c-42512293">[1 more]</label></div><br/><div class="children"><div class="content">I still want to let the author have the final say on if they decide to accept or reject the change, or modify it further. Editing the branch directly might cause some rebasing&#x2F;merge conflicts if they’re addressing other peoples comments too, so I don&#x27;t typically edit their working branch directly unless they ask me to.</div><br/></div></div></div></div></div></div><div id="42511286" class="c"><input type="checkbox" id="c-42511286" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511471">prev</a><span>|</span><a href="#42511212">next</a><span>|</span><label class="collapse" for="c-42511286">[-]</label><label class="expand" for="c-42511286">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, cognitive load is not the only thing that matters. Non-cognitive toil is also a problem and often enough it doesn&#x27;t get sufficient attention even when things get really bad.<p>We do need better code review tools though. We also need to approach that process as a mechanism of effectively building good shared understanding about the (new) code, not just &quot;code review&quot;.</div><br/></div></div><div id="42511212" class="c"><input type="checkbox" id="c-42511212" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511286">prev</a><span>|</span><a href="#42514743">next</a><span>|</span><label class="collapse" for="c-42511212">[-]</label><label class="expand" for="c-42511212">[4 more]</label></div><br/><div class="children"><div class="content">I am trying my best to build in an <i>inordinate</i> amount of upfront linting and automated checks just to avoid such things - and then I still need to do a roadshow, or lots of explanations- but that’s probably good.<p>But the good idea is to say “we all have the same brutal linting standards (including full stops in docs!) - so hopefully the human linger will actually start reading the code for what it is, not what it says”</div><br/><div id="42511364" class="c"><input type="checkbox" id="c-42511364" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511212">parent</a><span>|</span><a href="#42512516">next</a><span>|</span><label class="collapse" for="c-42511364">[-]</label><label class="expand" for="c-42511364">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also a fan of linting everything. Custom linter rules ftw.<p>This and documenting non-lintable standards so that people are on the same page (&quot;we do controllers like this&quot;).<p>This is how I like to build and run my teams. This makes juniors so much more confident because they can ship stuff from the get go without going through a lengthy nitpicky brutal review process. And more senior devs need to actually look at code and business rules rather than nitpicking silly shit.</div><br/><div id="42512182" class="c"><input type="checkbox" id="c-42512182" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511364">parent</a><span>|</span><a href="#42512516">next</a><span>|</span><label class="collapse" for="c-42512182">[-]</label><label class="expand" for="c-42512182">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This makes juniors so much more confident because they can ship stuff from the get go without going through a lengthy nitpicky brutal review process.<p>I had not considered that linters could greatly help new developers in this way, especially if you make it a one-button linting process for all established development environments.<p>Thanks for the insight! I will use this for the future.</div><br/></div></div></div></div><div id="42512516" class="c"><input type="checkbox" id="c-42512516" checked=""/><div class="controls bullet"><span class="by">justatdotin</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511212">parent</a><span>|</span><a href="#42511364">prev</a><span>|</span><a href="#42514743">next</a><span>|</span><label class="collapse" for="c-42512516">[-]</label><label class="expand" for="c-42512516">[1 more]</label></div><br/><div class="children"><div class="content">if a colleague wants to argue over placement of a curly boy, I&#x27;ll fight to the death.<p>if it&#x27;s a linter, I shrug and move on.</div><br/></div></div></div></div><div id="42514743" class="c"><input type="checkbox" id="c-42514743" checked=""/><div class="controls bullet"><span class="by">tdiff</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511212">prev</a><span>|</span><a href="#42511510">next</a><span>|</span><label class="collapse" for="c-42514743">[-]</label><label class="expand" for="c-42514743">[1 more]</label></div><br/><div class="children"><div class="content">As a reviewer I&#x27;ve seen numerous examples of PRs that were basically out of sync with the rest of the project, did not solve the problem they were supposed to solve, or added buggy or unmaintainable code.<p>Arguments like &quot;but it works in majority of cases&quot; are a way to delegate fixing issues to somebody else later. Unless noone will be using that code at all, in which case it should not be merged either.</div><br/></div></div><div id="42511510" class="c"><input type="checkbox" id="c-42511510" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42514743">prev</a><span>|</span><a href="#42511395">next</a><span>|</span><label class="collapse" for="c-42511510">[-]</label><label class="expand" for="c-42511510">[8 more]</label></div><br/><div class="children"><div class="content">I’m 15 years in and I feel basically the same. I end up making a feature or change, then going back and trying to split it into chunks that are digestible to my colleagues. I’ve got thousands of lines of staged changes that I’m waiting to drip out to people at a digestible pace.<p>I yearn for the early stage startup where every commit is a big change and my colleagues are used to reviewing this, and I can execute at my actual pace.<p>It’s really changed the way I think about software in general, I’ve come around to Rich Hickey’s radically simple language Clojure, because types bloat the refactors I’m doing.<p>I’d love to have more of you where I work, is there some way I can see your work and send some job descriptions and see if you’re interested?</div><br/><div id="42511620" class="c"><input type="checkbox" id="c-42511620" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511510">parent</a><span>|</span><a href="#42511851">next</a><span>|</span><label class="collapse" for="c-42511620">[-]</label><label class="expand" for="c-42511620">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I end up making a feature or change, then going back and trying to split it into chunks that are digestible to my colleagues.<p>If you are doing this AFTER you&#x27;ve written the code, it is probably way easier to do it as you go. It&#x27;s one thing if you have no idea what the code will look like from the beginning -- just go ahead and open the big PR and EXPLAIN WHY. I know that I&#x27;m more than happy to review a big PR if I understand why it has to be big.<p>I will be annoyed if I see a PR that is a mix of refactoring, bug fixes, and new features. You can (and should) have done those all as separate PRs (and tickets). If you need to refactor something, refactor it, and open a PR. It doesn&#x27;t take that long and there&#x27;s no need to wait until your huge PR is ready.</div><br/><div id="42511737" class="c"><input type="checkbox" id="c-42511737" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511620">parent</a><span>|</span><a href="#42512001">next</a><span>|</span><label class="collapse" for="c-42511737">[-]</label><label class="expand" for="c-42511737">[2 more]</label></div><br/><div class="children"><div class="content">Solving creative problems is often iterative, and one things I&#x27;m very concerned about when doing engineering management is maintaining momentum and flow. Looking at latency hierarchies is a really good example, you have registers, then cache, then memory, SSD, network etc. and consulting with another human asynchronously is like sending a message to Jupiter (in the best case).<p>So, with an iterative process, the more times you introduce (at best) hour long delays, you end up sitting on your arse twiddling your thumbs doing nothing, until the response comes back.<p>The concept of making PRs as you go fails to capture one of the aspects of low-latency problem solving, which is that you catch a problem, you correct it and you <i>revise it</i> locally, without exiting that loop. Which is problematic because not only have you put yourself in a situation where you&#x27;re waiting for a response, but you&#x27;ve stopped half-way through an unfinished idea.<p>This comes back to &#x27;is it done&#x27;, a gut feel that it&#x27;s an appropriate time to break the loop and incur the latency cost, which for every developer will be different and is something that I have grown to deeply trust and and adjust to for everybody I work with.<p>What I&#x27;m getting at is the iterative problem solving process often can&#x27;t be neatly dissected into discrete units while it&#x27;s happening, and after we&#x27;ve reached the &#x27;doneness&#x27; point it takes much more work to undo part of your work and re-do it than it took to do originally, so not only do you have the async overhead of every interaction, but you have the cognitive burden of untangling what was previously a cohesive unit of thought - which again is another big time killer</div><br/><div id="42513572" class="c"><input type="checkbox" id="c-42513572" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511737">parent</a><span>|</span><a href="#42512001">next</a><span>|</span><label class="collapse" for="c-42513572">[-]</label><label class="expand" for="c-42513572">[1 more]</label></div><br/><div class="children"><div class="content">What I mean is, you make your commit, cherry pick it over to the main branch, and open a draft pr. It doesn&#x27;t break your flow, it doesn&#x27;t stop anything, and is pretty quick. It also gives you a quick gut-check to see the PR; if you think your team members won&#x27;t understand &quot;why&quot; it needs to be refactored, then you have one of two problems:<p>1. your refactoring is probably going in the wrong direction. Team members will be able to help here more than ever. Let them bikeshed, but don&#x27;t stop working on your main refactor yet. Revist later and integrate their changes.<p>2. the PR is too small. it will have to be part of a larger PR.<p>In my experience, people tend to have the first problem, and not the second one, but they think they have the second one. There are many of these &quot;massive refactoring&quot; PRs I&#x27;ve reviewed over the last 20 years where the refactoring makes the code worse, overall. Why? Because refactoring towards a goal (implementing a feature, fixing a bug, etc.) doesn&#x27;t have the goal refactoring should have: improving code maintainability. So, the refactored code is usually LESS maintainable, but it does what they wanted.</div><br/></div></div></div></div><div id="42512001" class="c"><input type="checkbox" id="c-42512001" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511620">parent</a><span>|</span><a href="#42511737">prev</a><span>|</span><a href="#42511851">next</a><span>|</span><label class="collapse" for="c-42512001">[-]</label><label class="expand" for="c-42512001">[2 more]</label></div><br/><div class="children"><div class="content">If you make refactor PRs as you go, do you end up merging redactors towards a dead end and then--once you realize it&#x27;s a dead end--merging even more refractors in the other direction?<p>I usually wait until I have the big PR done and then merge redactors towards it because then at least I know the road I&#x27;m paving has a workable destination.</div><br/><div id="42512131" class="c"><input type="checkbox" id="c-42512131" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512001">parent</a><span>|</span><a href="#42511851">next</a><span>|</span><label class="collapse" for="c-42512131">[-]</label><label class="expand" for="c-42512131">[1 more]</label></div><br/><div class="children"><div class="content">This is why I design the heckin&#x27; huge change at the start, and then cherry pick the actual change (and associated tests) into a ton of smaller PRs, including &quot;refactor here&quot;, &quot;make this function + tests&quot;, &quot;make this class + tests&quot;, &quot;integrate the code + tests&quot;, and so on, as many times as necessary to have testable and reviewable units of code.<p>If I went about and made a ton of changes that all went into dead ends, honestly, I would get pretty demoralized and I think my team would get annoyed, especially if I then went through and rolled back many of those changes as not ending up being necessary.</div><br/></div></div></div></div></div></div><div id="42511851" class="c"><input type="checkbox" id="c-42511851" checked=""/><div class="controls bullet"><span class="by">hellisothers</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511510">parent</a><span>|</span><a href="#42511620">prev</a><span>|</span><a href="#42511395">next</a><span>|</span><label class="collapse" for="c-42511851">[-]</label><label class="expand" for="c-42511851">[2 more]</label></div><br/><div class="children"><div class="content">These same people also want to see your GitHub history filled with deep green come review time.  I start to wonder if they think high levels of GitHub activity is a proxy of performance or if it’s a proxy of plying the game the way they insist you play.</div><br/><div id="42512916" class="c"><input type="checkbox" id="c-42512916" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511851">parent</a><span>|</span><a href="#42511395">next</a><span>|</span><label class="collapse" for="c-42512916">[-]</label><label class="expand" for="c-42512916">[1 more]</label></div><br/><div class="children"><div class="content">Dunno where you get that from, but that was not my intent and is not a metric I use to judge who I’d like to be my coworkers.</div><br/></div></div></div></div></div></div><div id="42511395" class="c"><input type="checkbox" id="c-42511395" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511510">prev</a><span>|</span><a href="#42512245">next</a><span>|</span><label class="collapse" for="c-42511395">[-]</label><label class="expand" for="c-42511395">[1 more]</label></div><br/><div class="children"><div class="content">You seem to be describing a company where bureaucracy is a feature not a bug.<p>Been there. Left, live thousands times better.</div><br/></div></div><div id="42512245" class="c"><input type="checkbox" id="c-42512245" checked=""/><div class="controls bullet"><span class="by">gre</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511395">prev</a><span>|</span><a href="#42512115">next</a><span>|</span><label class="collapse" for="c-42512245">[-]</label><label class="expand" for="c-42512245">[2 more]</label></div><br/><div class="children"><div class="content">The process is introducing more room for bugs to somehow creep in. Damn.</div><br/><div id="42512336" class="c"><input type="checkbox" id="c-42512336" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512245">parent</a><span>|</span><a href="#42512115">next</a><span>|</span><label class="collapse" for="c-42512336">[-]</label><label class="expand" for="c-42512336">[1 more]</label></div><br/><div class="children"><div class="content">This is a big problem with reviews where the author is capitulating because they, with gritted teeth, acknowledge it&#x27;s the only way to get the desired result (jumping over a hurdle).<p>So you blindly accept an ill-informed suggestion because that&#x27;s the only way you can complete the process.</div><br/></div></div></div></div><div id="42512115" class="c"><input type="checkbox" id="c-42512115" checked=""/><div class="controls bullet"><span class="by">jschrf</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512245">prev</a><span>|</span><a href="#42512504">next</a><span>|</span><label class="collapse" for="c-42512115">[-]</label><label class="expand" for="c-42512115">[4 more]</label></div><br/><div class="children"><div class="content">Aye. Sign of the times. You&#x27;re 20+ years in, so I&#x27;m preaching to the choir and old-man-yelling-at-cloud here.<p>Cargo culting + AI are the culprits. Sucks to say, but engineering is going downhill fast. First wave of the shitularity. Architects? Naw, prompt engineers. Barf. Why write good code when a glorified chatbot could do it shittier and faster?<p>Sign of our times. Cardboard cutout code rather than stonemasonry. Shrinkflation of thought.<p>Peep this purified downvote fuel:<p>Everything is bad because everyone is lazy and cargo cults. Web specifically. Full-stop. AI sucks at coding and is making things recursively worse in the long run. LLMs are nothing more than recursive echo chambers of copypasta code that doesn&#x27;t keep up with API flux.<p>A great example of this is the original PHP docs, which so, so many of us copypasta&#x27;d from, leading to an untold amount of SQL injections. Oopsies.<p>Simalarily and hunting for downvotes, React is a templating framework that is useful but does not even meet its original value proposition, which is state management in UI. Hilariously tragic. See: original example of message desync state issue on FB. Unsolved for years by the purported solution.<p>The NoSQL flash is another tragic comedy. Rebuilding the wheel when there is a faster, better wheel already carefully made. Postgres with JSONB.<p>GraphQL is another example of Stuff We Don&#x27;t Need But Use Because People Say It&#x27;s Good. Devs: you don&#x27;t need it. Just write a query.<p>-<p>You mention a hugely important KPI in code. How many files, tools, commands, etc must I touch to do the simplest thing? Did something take me a day when it should have taken 30s? This is rife today, we should all pay attention. Pad left.<p>Look no further than hooks and contexts in React land for an example. Flawed to begin with, simply because &quot;class is a yucky keyword&quot;. I keep seeing this in &quot;fast moving&quot; startups: the diaspora of business logic spread through a codebase, when simplicity and unity is key, which you touch on. Absolute waste of electricity and runway, all thanks to opiniation.<p>Burnt runways abound. Sometimes I can&#x27;t help but think engineering needs a turn it off and then on again moment in safe mode without fads and chatbots.</div><br/><div id="42512786" class="c"><input type="checkbox" id="c-42512786" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512115">parent</a><span>|</span><a href="#42512504">next</a><span>|</span><label class="collapse" for="c-42512786">[-]</label><label class="expand" for="c-42512786">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Everything is bad because everyone is lazy and cargo cults.<p>It’s an interesting series of events that led to this (personal theory). Brilliant people who deeply understood fundamentals built abstractions because they were lazy, in a good way. Some people adopted those abstractions without fully comprehending what was being hidden, and some of <i>those</i> people built additional abstractions. Eventually, you wind up with people building solutions to problems which wouldn’t exist if, generations above, the original problem had been better understood.</div><br/><div id="42512936" class="c"><input type="checkbox" id="c-42512936" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512786">parent</a><span>|</span><a href="#42512504">next</a><span>|</span><label class="collapse" for="c-42512936">[-]</label><label class="expand" for="c-42512936">[2 more]</label></div><br/><div class="children"><div class="content">The road is paved with good intentions, it&#x27;s not they were lazy but they had intent to distill wisdom to save time. Then yes, the abstractions were adopted without fully comprehended what was hidden, and those people then naively built additional layers of abstractions.<p>So yes, if the original problem had been better understood, then you wouldn&#x27;t have a generation of React programmers doing retarded things.<p>Having watched many junior developers tackle different problems with various frameworks, I have to say React is conducive to brainrot by default. Only after going through a fundamentals-first approach do you not end up with one kind of spaghetti, but you end up with another kind because it&#x27;s fundamentally engineered towards producing spaghetti code unless you constantly fight the inertia of spaghettification.<p>It&#x27;s like teaching kids about `GOTO`... That is, IMO, the essence of React.</div><br/><div id="42515619" class="c"><input type="checkbox" id="c-42515619" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512936">parent</a><span>|</span><a href="#42512504">next</a><span>|</span><label class="collapse" for="c-42515619">[-]</label><label class="expand" for="c-42515619">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s not they were lazy but they had intent to distill wisdom to save time.<p>Yes – I was referring to lazy in the sense of the apocryphal quote from Bill Gates:<p>“I choose a lazy person to do a hard job, because a lazy person will find an easy way to do it.”<p>&gt; Only after going through a fundamentals-first approach do you not end up with one kind of spaghetti, but you end up with another kind because it&#x27;s fundamentally engineered towards producing spaghetti code unless you constantly fight the inertia of spaghettification.<p>I’ve been guilty of this. Thinking that a given abstraction is unnecessary and overly-complicated, building my own minimal abstraction for my use case, and then slowly creating spaghetti as I account for more and more edge cases.</div><br/></div></div></div></div></div></div></div></div><div id="42512504" class="c"><input type="checkbox" id="c-42512504" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512115">prev</a><span>|</span><a href="#42511345">next</a><span>|</span><label class="collapse" for="c-42512504">[-]</label><label class="expand" for="c-42512504">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a similar experience several times over the years.  Even at companies with no working product that ostensibly wanted to &#x27;move fast and break things&#x27;.  And I do the same thing; quit and move on.  I&#x27;m pretty convinced people like that more-or-less can&#x27;t be reasoned with.<p>My question is .. is this getting more common as time goes on, or do I just feel like it is..</div><br/></div></div><div id="42511345" class="c"><input type="checkbox" id="c-42511345" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512504">prev</a><span>|</span><a href="#42512967">next</a><span>|</span><label class="collapse" for="c-42511345">[-]</label><label class="expand" for="c-42511345">[1 more]</label></div><br/><div class="children"><div class="content">This sounds more like a case where you need a “break-the-glass” like procedure where some checks don’t apply. Or the checks should be non blocking anyway.</div><br/></div></div><div id="42512967" class="c"><input type="checkbox" id="c-42512967" checked=""/><div class="controls bullet"><span class="by">romellem</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511345">prev</a><span>|</span><a href="#42511248">next</a><span>|</span><label class="collapse" for="c-42512967">[-]</label><label class="expand" for="c-42512967">[1 more]</label></div><br/><div class="children"><div class="content">&gt; mostly useless comments about not having periods at the ends of lines<p>Oh my god, this sounds like a nightmare. I definitely would not be able to tolerate this for long.<p>Did you try to get them to change? Were you just not in a senior enough position for anyone to listen?</div><br/></div></div><div id="42511248" class="c"><input type="checkbox" id="c-42511248" checked=""/><div class="controls bullet"><span class="by">shinycode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512967">prev</a><span>|</span><a href="#42511393">next</a><span>|</span><label class="collapse" for="c-42511248">[-]</label><label class="expand" for="c-42511248">[4 more]</label></div><br/><div class="children"><div class="content">No wonder why software development used to be expensive if 50 lines of code takes multiples days for several people …</div><br/><div id="42511684" class="c"><input type="checkbox" id="c-42511684" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511248">parent</a><span>|</span><a href="#42511393">next</a><span>|</span><label class="collapse" for="c-42511684">[-]</label><label class="expand" for="c-42511684">[3 more]</label></div><br/><div class="children"><div class="content">Well maybe they do critical systems.</div><br/><div id="42511924" class="c"><input type="checkbox" id="c-42511924" checked=""/><div class="controls bullet"><span class="by">shinycode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511684">parent</a><span>|</span><a href="#42512013">next</a><span>|</span><label class="collapse" for="c-42511924">[-]</label><label class="expand" for="c-42511924">[1 more]</label></div><br/><div class="children"><div class="content">Valid point, it’s even mandatory in this case. Sometimes people do it for the sake of it. Maybe because there nothing else to make them feel important ?
In critical systems I hope it’s the case though</div><br/></div></div><div id="42512013" class="c"><input type="checkbox" id="c-42512013" checked=""/><div class="controls bullet"><span class="by">DavidPiper</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511684">parent</a><span>|</span><a href="#42511924">prev</a><span>|</span><a href="#42511393">next</a><span>|</span><label class="collapse" for="c-42512013">[-]</label><label class="expand" for="c-42512013">[1 more]</label></div><br/><div class="children"><div class="content">Narrator: &quot;They don&#x27;t.&quot;<p>(Glib, but in my experience, mostly true.)</div><br/></div></div></div></div></div></div><div id="42511393" class="c"><input type="checkbox" id="c-42511393" checked=""/><div class="controls bullet"><span class="by">notShabu</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511248">prev</a><span>|</span><a href="#42511095">next</a><span>|</span><label class="collapse" for="c-42511393">[-]</label><label class="expand" for="c-42511393">[1 more]</label></div><br/><div class="children"><div class="content">there is huge incentive for people who don&#x27;t know how to code&#x2F;create&#x2F;do-stuff to slow things down like this b&#x2F;c it allows them many years of runway at the company.<p>they are almost always cloaked in virtue signals.<p>almost every established company you join will already have had this process going for a long time.<p>doing stuff successfully at such a company is dangerous to the hierarchy and incurs an immune response to shut down or ostracize the doing-of-stuff successfully so the only way to survive or climb is to do stuff unsuccessfully (so they look good)</div><br/></div></div><div id="42511095" class="c"><input type="checkbox" id="c-42511095" checked=""/><div class="controls bullet"><span class="by">SeptiumMMX</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511393">prev</a><span>|</span><a href="#42511084">next</a><span>|</span><label class="collapse" for="c-42511095">[-]</label><label class="expand" for="c-42511095">[1 more]</label></div><br/><div class="children"><div class="content">You always need to look at the track record of the team. If they were not producing solid consistent results before you joined them, it&#x27;s a very good indicator that something&#x27;s fishy. All that &quot;they are working on something else that we can&#x27;t tell you&quot; is BS.<p>If they were, and you were the only one treated like that, hiring you was a decision forced upon the team, so they got rid of you in a rather efficient way.</div><br/></div></div><div id="42511084" class="c"><input type="checkbox" id="c-42511084" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511095">prev</a><span>|</span><a href="#42512167">next</a><span>|</span><label class="collapse" for="c-42511084">[-]</label><label class="expand" for="c-42511084">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s rough. Of course some amount of thoughtfulness towards &quot;smallest reasonable change&quot; is valuable, but if you&#x27;re not shipping then something is wrong.<p>As for the &quot;comments on every detail&quot; thing... I would fight that until I win or have to leave. What a completely asinine practice to leave comments on typical lines of code.</div><br/></div></div></div></div><div id="42512167" class="c"><input type="checkbox" id="c-42512167" checked=""/><div class="controls bullet"><span class="by">charles_f</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42510935">prev</a><span>|</span><a href="#42517627">next</a><span>|</span><label class="collapse" for="c-42512167">[-]</label><label class="expand" for="c-42512167">[1 more]</label></div><br/><div class="children"><div class="content">I like to call these smells, not rules. They&#x27;re an indication that something <i>might</i> be wrong because you&#x27;ve repeated code, or because your method is too long, or because you have too many parameters. But it might also be a false positive because in this instance it was acceptable to repeat code or have a long method or have many parameters.<p>Sometimes food smells because it  turned bad, and sometimes it&#x27;s smelly because it&#x27;s cheese.</div><br/></div></div><div id="42517627" class="c"><input type="checkbox" id="c-42517627" checked=""/><div class="controls bullet"><span class="by">diekhans</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42512167">prev</a><span>|</span><a href="#42510878">next</a><span>|</span><label class="collapse" for="c-42517627">[-]</label><label class="expand" for="c-42517627">[2 more]</label></div><br/><div class="children"><div class="content">Hard rules are the problem. There is a lot of &quot;it depends.&quot;<p>After over 40 years of programming, I continue to reduce the size of functions and find it easier to write and understand when I return to them. Ten lines are now a personal guideline.<p>However, a linear function with only tiny loops or conditionals can be easily understood when hundreds of lines are long, but not so much with nested conditionals and loops, where there is natural decomposition into functions.<p>I observed that the same guidelines became rules problems when test coverage became popular. They soon became metrics rather than tools to think about code and tests.   People became reluctant to add sanity check code for things that could should never happen because it brought down code coverage.</div><br/><div id="42517729" class="c"><input type="checkbox" id="c-42517729" checked=""/><div class="controls bullet"><span class="by">asdff</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42517627">parent</a><span>|</span><a href="#42510878">next</a><span>|</span><label class="collapse" for="c-42517729">[-]</label><label class="expand" for="c-42517729">[1 more]</label></div><br/><div class="children"><div class="content">There are certainly functions written too cleverly to be apparent how they manage to work at all in a few lines. By my own hand six months ago sometimes. The solution is an unsexy one but always works: write a books worth of comments near that function code that explains absolutely everything and why it was done.</div><br/></div></div></div></div><div id="42510878" class="c"><input type="checkbox" id="c-42510878" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42517627">prev</a><span>|</span><a href="#42517704">next</a><span>|</span><label class="collapse" for="c-42510878">[-]</label><label class="expand" for="c-42510878">[2 more]</label></div><br/><div class="children"><div class="content">Same deal with DRY, the principle is obviously correct but people can take it too literally. It&#x27;s so easy to get yourself in a huge mess trying to extract out two or three bits of code that <i>look</i> pretty similar but aren&#x27;t really used in the same context.</div><br/><div id="42510955" class="c"><input type="checkbox" id="c-42510955" checked=""/><div class="controls bullet"><span class="by">skeeter2020</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510878">parent</a><span>|</span><a href="#42517704">next</a><span>|</span><label class="collapse" for="c-42510955">[-]</label><label class="expand" for="c-42510955">[1 more]</label></div><br/><div class="children"><div class="content">The problem with DRY and generic rules around size, etc. really seems to be figuring out the boundaries, and that&#x27;s tough to get right, even for experienced devs, plus very contextual. If you need to open up a dozen files to make a small change you&#x27;re overwhelmed, but then if you need to wade through a big function  or change code in 2 places you&#x27;re just as frustrated.</div><br/></div></div></div></div><div id="42517704" class="c"><input type="checkbox" id="c-42517704" checked=""/><div class="controls bullet"><span class="by">asdff</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42510878">prev</a><span>|</span><a href="#42512340">next</a><span>|</span><label class="collapse" for="c-42517704">[-]</label><label class="expand" for="c-42517704">[1 more]</label></div><br/><div class="children"><div class="content">Doing things the right way always introduces a shackle to your ankle. Oh am I to package my functions as discrete packages I call via library name carefully crafted to install into some specific folder structure that I now have to learn and not make mistakes with. Or I can do it “improperly” and just write a function and start using it immediately.<p>Not everything has to be designed like some standardized mass produced part ready to drop into anything made in the last 40 years. And what is crazy is that even things written to that standard aren’t even compatible and might have very specific dependencies themselves.</div><br/></div></div><div id="42512340" class="c"><input type="checkbox" id="c-42512340" checked=""/><div class="controls bullet"><span class="by">dennis_jeeves2</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42517704">prev</a><span>|</span><a href="#42511356">next</a><span>|</span><label class="collapse" for="c-42512340">[-]</label><label class="expand" for="c-42512340">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It almost always comes from a lead or manager who reads too many business books and then cargo cults those books on to the team.<p>Worse, they behave as though they have  profound insights, and put themselves on an intellectually elevated pedestal,  which the rest of their ordinary team mortals cannot achieve.</div><br/></div></div><div id="42511356" class="c"><input type="checkbox" id="c-42511356" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42512340">prev</a><span>|</span><a href="#42511195">next</a><span>|</span><label class="collapse" for="c-42511356">[-]</label><label class="expand" for="c-42511356">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a book promoting the idea that methods should not be longer than 5 lines.<p>Of course now I know these ridiculous statements are from people hardly wrote any code in their lives, but if I&#x27;d read them at 18 I would have been totally misled.</div><br/><div id="42514915" class="c"><input type="checkbox" id="c-42514915" checked=""/><div class="controls bullet"><span class="by">arzke</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511356">parent</a><span>|</span><a href="#42512147">next</a><span>|</span><label class="collapse" for="c-42514915">[-]</label><label class="expand" for="c-42514915">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I know these ridiculous statements are from people hardly wrote any code in their lives<p>Some people who actually wrote a decent amount of code in their lives are sharing that opinion, so your comment just sounds like an ad-hominem attack.</div><br/><div id="42516528" class="c"><input type="checkbox" id="c-42516528" checked=""/><div class="controls bullet"><span class="by">wholinator2</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42514915">parent</a><span>|</span><a href="#42512147">next</a><span>|</span><label class="collapse" for="c-42516528">[-]</label><label class="expand" for="c-42516528">[1 more]</label></div><br/><div class="children"><div class="content">I disagree that it&#x27;s an attack, I&#x27;ve also never heard anyone say methods should be less than 5 lines. 5 lines is an insane limit, 15 is much more reasonable. This kind of enforcement reeks to me of unnecessarily &quot;one-lining&quot; complicated statements into completely unreadable garbage. I mean seriously though, 5 lines? Why not 4, or 3, or 6? 15 lines of well thought out code is infinitely preferable to 3 different 5-line monstrosities. Who(m&#x27;st&#x27;ve) among us that actually writes code would preach such a guideline, and can i please see their code for reference. Maybe they are just better than us, i still don&#x27;t think that makes it a reasonable general rule. And i disagree that calling that out as crazy counts as a personal ad-hominem attack against this nebulous entity</div><br/></div></div></div></div><div id="42512147" class="c"><input type="checkbox" id="c-42512147" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511356">parent</a><span>|</span><a href="#42514915">prev</a><span>|</span><a href="#42511195">next</a><span>|</span><label class="collapse" for="c-42512147">[-]</label><label class="expand" for="c-42512147">[1 more]</label></div><br/><div class="children"><div class="content">Weirdly if you do break everything down into purely functional components it&#x27;s entirely possible to uncompromisingly make every concept a few lines of code at most, and you will end up with some extremely elegant solutions this way.<p>You wouldn&#x27;t be misled at all, only that the path you&#x27;d go down is an entirely different one to what you expected it to be.</div><br/></div></div></div></div><div id="42511195" class="c"><input type="checkbox" id="c-42511195" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42511356">prev</a><span>|</span><a href="#42514034">next</a><span>|</span><label class="collapse" for="c-42511195">[-]</label><label class="expand" for="c-42511195">[1 more]</label></div><br/><div class="children"><div class="content">If a function is longer than what I can display on a single screen, it better has to be argumented with very exceptional relevant requirements, which is just as straight forward to judge for anyone with a bit of experience.</div><br/></div></div><div id="42514034" class="c"><input type="checkbox" id="c-42514034" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42511195">prev</a><span>|</span><a href="#42510938">next</a><span>|</span><label class="collapse" for="c-42514034">[-]</label><label class="expand" for="c-42514034">[1 more]</label></div><br/><div class="children"><div class="content">In my experience it usually devs that do that to themselves after reading stuff on the internet and thinking “I want to be a professional and I want to show it to everyone.”<p>Then rules stay and new people just continue with same silly rules instead of thinking if those are really that useful.</div><br/></div></div><div id="42510938" class="c"><input type="checkbox" id="c-42510938" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42514034">prev</a><span>|</span><a href="#42513478">next</a><span>|</span><label class="collapse" for="c-42510938">[-]</label><label class="expand" for="c-42510938">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same with writing. The best authors occasionally break the rules of grammar and spelling in order to achieve a specific effect. But you have to learn the rules first, and break them only intentionally rather than accidentally. Otherwise your writing ends up as sloppy crap.<p>(Of course some organizations have coding conventions that are just stupid, but that&#x27;s a separate issue.)</div><br/></div></div><div id="42513478" class="c"><input type="checkbox" id="c-42513478" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42510938">prev</a><span>|</span><a href="#42512054">next</a><span>|</span><label class="collapse" for="c-42513478">[-]</label><label class="expand" for="c-42513478">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an experienced developer and I enforce these kinds of rules upon myself without giving it much thought, and I very much prefer the results.</div><br/></div></div><div id="42512054" class="c"><input type="checkbox" id="c-42512054" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42513478">prev</a><span>|</span><a href="#42512063">next</a><span>|</span><label class="collapse" for="c-42512054">[-]</label><label class="expand" for="c-42512054">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re  confusing this with a software development process problem. It&#x27;s really just good old fashioned psychological abuse.</div><br/></div></div></div></div><div id="42512063" class="c"><input type="checkbox" id="c-42512063" checked=""/><div class="controls bullet"><span class="by">nbyron</span><span>|</span><a href="#42510866">prev</a><span>|</span><a href="#42510573">next</a><span>|</span><label class="collapse" for="c-42512063">[-]</label><label class="expand" for="c-42512063">[3 more]</label></div><br/><div class="children"><div class="content">The spirit of this piece is excellent, and introduces some useful terms from psychology to help codify - and more importantly, explain - how to make tasks less unnecessarily demanding.<p>However, as someone who spends their days teaching and writing about cognitive psychology, worth clarifying that this isn’t <i>quite</i> correct:<p><i>Intrinsic - caused by the inherent difficulty of a task. It can&#x27;t be reduced, it&#x27;s at the very heart of software development.</i><p>Intrinsic load is a function of the element interactivity that results within a task (the degree to which different elements, or items, that you need to think about interact and rely upon one another), and prior knowledge.<p>You can’t really reduce element interactivity if you want to keep the task itself intact. However if it’s possible to break a task down into sub tasks then you can often reduce this somewhat, at the expense of efficiency.<p>However, you can absolutely affect the prior knowledge factor that influences intrinsic load. The author speaks of the finding from Cowan (2001) that working memory can process 4+—1 items simultaneously, but what most people neglect here is that what constitutes an “item” is wholly depending upon the schemas that a given person has embedded in their long-term memory. Example: someone with no scientific knowledge may look at O2 + C6H12O6 -&gt; CO2 + H2O as potentially up to 18 items of information to handle (then individual characters), whereas someone with some experience of biology may instead handle this entire expression as a single unit - using their knowledge in long-term memory to “chunk” this string as a single unit - ‘the unbalanced symbol equation for respiration’.</div><br/><div id="42512354" class="c"><input type="checkbox" id="c-42512354" checked=""/><div class="controls bullet"><span class="by">energy123</span><span>|</span><a href="#42512063">parent</a><span>|</span><a href="#42512722">next</a><span>|</span><label class="collapse" for="c-42512354">[-]</label><label class="expand" for="c-42512354">[1 more]</label></div><br/><div class="children"><div class="content">Another good article, not directly related to work tasks, but related to unnecessary complexity: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30802349">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30802349</a></div><br/></div></div><div id="42512722" class="c"><input type="checkbox" id="c-42512722" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42512063">parent</a><span>|</span><a href="#42512354">prev</a><span>|</span><a href="#42510573">next</a><span>|</span><label class="collapse" for="c-42512722">[-]</label><label class="expand" for="c-42512722">[1 more]</label></div><br/><div class="children"><div class="content">Another interesting thing is when there is inherent complexity in the system, things remain simple.<p>For example in game programming, nobody is doing function currying.<p>And yet in React and frontend land because it is a button on screen which toggles a boolean field in the db, there are graphs, render cycles, &quot;use client&quot;, &quot;use server&quot;, &quot;dynamic islands&quot;, &quot;dependency arrays&quot; etc. This is the coding equivalent of bullshit jobs.</div><br/></div></div></div></div><div id="42510573" class="c"><input type="checkbox" id="c-42510573" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42512063">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510573">[-]</label><label class="expand" for="c-42510573">[89 more]</label></div><br/><div class="children"><div class="content"><i>Mantras like &quot;methods should be shorter than 15 lines of code&quot; or &quot;classes should be small&quot; turned out to be somewhat wrong.</i><p>So much this.<p>The whole point of functions and classes was to make code <i>reusable</i>. If the entire contents of a 100 line method are only ever used in that method and it&#x27;s not recursive or using continuations or anything else weird, why the hell would it be &quot;easier to read&quot; if I had to jump up and down the file to 7 different submethods when the function&#x27;s entire flow is always sequential?</div><br/><div id="42511646" class="c"><input type="checkbox" id="c-42511646" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511114">next</a><span>|</span><label class="collapse" for="c-42511646">[-]</label><label class="expand" for="c-42511646">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The whole point of functions and classes was to make code reusable.<p>I’m amazed that here we are &gt;40 years on from C++, and still this argument is made. Classes never encapsulated a module of reusability, except in toy or academic examples. To try and use them in this way either leads to gigantic “god” classes, or so many tiny classes with scaffolding classes between them that the “communication overhead” dwarfs the actual business logic.<p>Code base after code base proves this again and again. I have never seen a “class” be useful as a component of re-use. So what is? Libraries. A public interface&#x2F;api wrapping a “I don’t care what you did inside”. Bunch of classes, one class, methods? So long as the interface is small and well defined, who cares how it’s structured inside.<p>Modular programming can be done in any paradigm, just think about the api and the internal as separate things. Build some tests at the interface layer, and you’ve got documentation for free too! Re-use happens at the dll or cluster of dll boundaries. Software has a <i>physical</i> aspect to it as well as code.</div><br/><div id="42511767" class="c"><input type="checkbox" id="c-42511767" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511646">parent</a><span>|</span><a href="#42515643">next</a><span>|</span><label class="collapse" for="c-42511767">[-]</label><label class="expand" for="c-42511767">[4 more]</label></div><br/><div class="children"><div class="content">This is not my experience. Multiple inheritance within a code base of certain sub-functionalities and states is a perfectly good example of reuse. You do not need to go all the way out to the library level. In fact, it is the abstract bases that really minimize the reusable parts that I find most useful.<p>I&#x27;m not saying you <i>have</i> to use classes to do this, but they certainly get the job done.</div><br/><div id="42511829" class="c"><input type="checkbox" id="c-42511829" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511767">parent</a><span>|</span><a href="#42515902">next</a><span>|</span><label class="collapse" for="c-42511829">[-]</label><label class="expand" for="c-42511829">[1 more]</label></div><br/><div class="children"><div class="content">We are talking about different things. If you want to use inheritance inside your module, behind a reasonable API, in order to re-use common logic, I won’t bat an eye. I won’t know, I’m working with the public part of your module.<p>If you structure your code so that people in my team can inherit from your base class (because you didn’t make an interface and left everything public), and later you change some of this common logic, then I will curse your name and the manner of your conception.</div><br/></div></div><div id="42515902" class="c"><input type="checkbox" id="c-42515902" checked=""/><div class="controls bullet"><span class="by">redman25</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511767">parent</a><span>|</span><a href="#42511829">prev</a><span>|</span><a href="#42512151">next</a><span>|</span><label class="collapse" for="c-42515902">[-]</label><label class="expand" for="c-42515902">[1 more]</label></div><br/><div class="children"><div class="content">I know that a lot of people advocate for composition over inheritance. Inheritance can add a lot of complexity especially if it is deep or involves a lot of overrides. It can be difficult to find out where a method came from inside the inheritance chain or if it has been overridden and consequently how it will behave.<p>Composition at least makes things a little more obvious where methods are getting their functionality. It also has other benefits in terms of making objects easier to mock.</div><br/></div></div><div id="42512151" class="c"><input type="checkbox" id="c-42512151" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511767">parent</a><span>|</span><a href="#42515902">prev</a><span>|</span><a href="#42515643">next</a><span>|</span><label class="collapse" for="c-42512151">[-]</label><label class="expand" for="c-42512151">[1 more]</label></div><br/><div class="children"><div class="content">Since learning functional programming well. I feel a need to use inheritance in C++ maybe a handful of places.<p>The problem with inherentice reuse is if you need to do something slightly different you are out of luck. Alternatively with functions you call what you need. And can break apart functionality without changing the other reuses.</div><br/></div></div></div></div><div id="42515643" class="c"><input type="checkbox" id="c-42515643" checked=""/><div class="controls bullet"><span class="by">aiisjustanif</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511646">parent</a><span>|</span><a href="#42511767">prev</a><span>|</span><a href="#42511114">next</a><span>|</span><label class="collapse" for="c-42515643">[-]</label><label class="expand" for="c-42515643">[2 more]</label></div><br/><div class="children"><div class="content">Surely this is use case dependent? I’ve worked on projects where modular programming works well and others where not so much.</div><br/><div id="42518001" class="c"><input type="checkbox" id="c-42518001" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42515643">parent</a><span>|</span><a href="#42511114">next</a><span>|</span><label class="collapse" for="c-42518001">[-]</label><label class="expand" for="c-42518001">[1 more]</label></div><br/><div class="children"><div class="content">Specifically here I am talking about the concept of “re-use”. That is, the ability to write a bunch of code that does a “thing” and use that more than once, without significant modification.<p>Modularity is a much bigger concept, related to the <i>engineering</i> of large software systems. These days, “micro-services” is one way that people achieve modularity, but in the old days it was needed for many of the same reasons, but inside the monolith. The overall solution is composed of blocks living at different layers.<p>Re-use also exists inside modules, of course, by using functions or composition or — shudder — inheritance of code.<p>Modular programming has value as soon as more than one team needs to work on something. As it’s impossible to predict the future, my opinion is that it always has value to structure a code-base in this way.</div><br/></div></div></div></div></div></div><div id="42511114" class="c"><input type="checkbox" id="c-42511114" checked=""/><div class="controls bullet"><span class="by">onionisafruit</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511646">prev</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42511114">[-]</label><label class="expand" for="c-42511114">[12 more]</label></div><br/><div class="children"><div class="content">To paraphrase a recentish comment from jerf, “sometimes you just have a long list of tasks to do”. That stuck with me. Now I’m a bit quicker to realize when I’m in that situation and don’t bother trying to find a natural place to break up the function.</div><br/><div id="42511203" class="c"><input type="checkbox" id="c-42511203" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511114">parent</a><span>|</span><a href="#42513871">next</a><span>|</span><label class="collapse" for="c-42511203">[-]</label><label class="expand" for="c-42511203">[4 more]</label></div><br/><div class="children"><div class="content">For me it depends. Sometimes I find value in making a function for a block of work I can give its own name to, because that can make the flow more obvious when looking at what the function does at a high level. But arbitrarily breaking up a function just because is silly and pointless.</div><br/><div id="42511322" class="c"><input type="checkbox" id="c-42511322" checked=""/><div class="controls bullet"><span class="by">lostdog</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511203">parent</a><span>|</span><a href="#42511858">next</a><span>|</span><label class="collapse" for="c-42511322">[-]</label><label class="expand" for="c-42511322">[2 more]</label></div><br/><div class="children"><div class="content">Plus, laying the list of tasks out in order sometimes makes it obvious how to split it up eventually. If you try to split it up the first time you write it, you get a bunch of meaningless splits, but if you write a 300 line function, and let it simmer for a few weeks, usually you can spot commonalities later.</div><br/><div id="42511390" class="c"><input type="checkbox" id="c-42511390" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511322">parent</a><span>|</span><a href="#42511858">next</a><span>|</span><label class="collapse" for="c-42511390">[-]</label><label class="expand" for="c-42511390">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s also true, though in this case I&#x27;m not necessarily worried about commonalities, just changing the way it reads to focus on the higher level ideas making up the large function.<p>But revisiting code after a time, either just because you slept on it or you&#x27;ve written more adjacent code, is almost always worth some time to try and improve the readability of the code (so long as you don&#x27;t sacrifice performance unnecessarily).</div><br/></div></div></div></div><div id="42511858" class="c"><input type="checkbox" id="c-42511858" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511203">parent</a><span>|</span><a href="#42511322">prev</a><span>|</span><a href="#42513871">next</a><span>|</span><label class="collapse" for="c-42511858">[-]</label><label class="expand" for="c-42511858">[1 more]</label></div><br/><div class="children"><div class="content">Define that function directly in the place where it is used (e.g. as a lambda, if nesting of function definitions is not allowed). Keeps the locality and makes it obvious that you could just have put a comment instead.</div><br/></div></div></div></div><div id="42513871" class="c"><input type="checkbox" id="c-42513871" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511114">parent</a><span>|</span><a href="#42511203">prev</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42513871">[-]</label><label class="expand" for="c-42513871">[7 more]</label></div><br/><div class="children"><div class="content">A useful trick is to then at least visually structure those 150 lines with comments that separate some blocks of functionality. Keeps the linear flow but makes it still easier to digest.</div><br/><div id="42514057" class="c"><input type="checkbox" id="c-42514057" checked=""/><div class="controls bullet"><span class="by">mr_mitm</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513871">parent</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42514057">[-]</label><label class="expand" for="c-42514057">[6 more]</label></div><br/><div class="children"><div class="content">Why not just do something like this then? This:<p><pre><code>    myfunction(data) {
        # do one thing to the data
        ...

        # now do another
        ...
    }
</code></pre>
becomes that:<p><pre><code>    myfunction(data) {
        do_one_thing_to_the_data(data)
        now_do_another(data)
    }

    do_one_thing_to_the_data(data) {
        ...
    }

    now_do_another(data) {
        ...
    }
</code></pre>
Still linear, easier to get an overview, and you can write more modular tests.</div><br/><div id="42514223" class="c"><input type="checkbox" id="c-42514223" checked=""/><div class="controls bullet"><span class="by">ropejumper</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42514057">parent</a><span>|</span><a href="#42517118">next</a><span>|</span><label class="collapse" for="c-42514223">[-]</label><label class="expand" for="c-42514223">[2 more]</label></div><br/><div class="children"><div class="content">Because now you have to jump around in order to see the sequence of events, which can be very frustrating if you have to constantly switch between two of these functions.<p>Plus, if we&#x27;re dealing with a &quot;long list of tasks&quot; that can&#x27;t be broken up in reusable chunks, it probably means that you need to share some context, which is way easier to do if you&#x27;re in the same scope.<p>One thing I find useful is to structure it in blocks instead, so you can share things but also contain what you don&#x27;t want shared. So e.g. in rust you could do this:<p><pre><code>    let shared_computation = do_shared_computation();
    
    let result_one = {
        let result = do_useful_things();
        other_things(&amp;shared_computation);
        result
    }
    
    ...
</code></pre>
I think it&#x27;s a nice middleground. But you still can&#x27;t write modular tests. But maybe you don&#x27;t have to, because again, this <i>is</i> just a long list of tasks you need to do that conceptually can&#x27;t be broken down, so maybe it&#x27;s better to just test the whole thing as a unit.</div><br/></div></div><div id="42517118" class="c"><input type="checkbox" id="c-42517118" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42514057">parent</a><span>|</span><a href="#42514223">prev</a><span>|</span><a href="#42514579">next</a><span>|</span><label class="collapse" for="c-42517118">[-]</label><label class="expand" for="c-42517118">[1 more]</label></div><br/><div class="children"><div class="content">Instead of, say, 10 functions in a file that are all individually meaningful, you now have maybe 50 functions that are mostly tiny steps that don&#x27;t make much sense on their own. Good like finding the &quot;real&quot; 10 functions buried amongst them. It&#x27;s certainly higher cognitive load in my (painful) experience.</div><br/></div></div><div id="42514579" class="c"><input type="checkbox" id="c-42514579" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42514057">parent</a><span>|</span><a href="#42517118">prev</a><span>|</span><a href="#42516844">next</a><span>|</span><label class="collapse" for="c-42514579">[-]</label><label class="expand" for="c-42514579">[1 more]</label></div><br/><div class="children"><div class="content">If the arguments to the function required are small, then breaking such a block down makes sense. Otherwise, it usually feels like an unnatural function to me.</div><br/></div></div><div id="42516844" class="c"><input type="checkbox" id="c-42516844" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42514057">parent</a><span>|</span><a href="#42514579">prev</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42516844">[-]</label><label class="expand" for="c-42516844">[1 more]</label></div><br/><div class="children"><div class="content">We have different ideas about what &quot;linear&quot; means.</div><br/></div></div></div></div></div></div></div></div><div id="42513571" class="c"><input type="checkbox" id="c-42513571" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511114">prev</a><span>|</span><a href="#42510812">next</a><span>|</span><label class="collapse" for="c-42513571">[-]</label><label class="expand" for="c-42513571">[4 more]</label></div><br/><div class="children"><div class="content">&gt;why the hell would it be &quot;easier to read&quot; if I had to jump up and down the file to 7 different submethods when the function&#x27;s entire flow is always sequential?<p>Because <i>you don&#x27;t</i> jump up and down the file to read it.<p>Each method that you create has a name, and the name is an opportunity to explain the process - naturally, in-line, without comments.<p>I write code like this all the time - e.g. from my current project: <a href="https:&#x2F;&#x2F;github.com&#x2F;zahlman&#x2F;bbbb&#x2F;blob&#x2F;master&#x2F;src&#x2F;bbbb.py">https:&#x2F;&#x2F;github.com&#x2F;zahlman&#x2F;bbbb&#x2F;blob&#x2F;master&#x2F;src&#x2F;bbbb.py</a> . If I wanted to follow the flow of execution, I would be hammering the % key in Vim. But I don&#x27;t do that, because I don&#x27;t need or want to. The flow of <i>the function</i> is already there in the function. It calls out to other functions that <i>encapsulate details that would be a distraction</i> if I want to understand the function. The functions have names that explain their purpose. I put effort into names, and I trust myself and my names. I only look at the code I&#x27;m currently interested in. To look at other parts of the code, I would first need a reason to be interested in it.<p>When you look at yourself in the mirror, and notice your hand, do you feel compelled to examine your hand in detail before you can consider anything about the rest of your reflection? Would you prefer to conceive of that image as a grid of countless points of light? Or do you not find it useful that your mind&#x27;s eye automatically folds what it sees into abstractions like &quot;hand&quot;?<p>35 years into my journey as a programmer, the idea of a 100-line function frightens me (although I have had to face this fear countless times when dealing with others&#x27; code). For me, that&#x27;s half of a reasonable length (though certainly not a hard limit) for the entire file.</div><br/><div id="42515000" class="c"><input type="checkbox" id="c-42515000" checked=""/><div class="controls bullet"><span class="by">arzke</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513571">parent</a><span>|</span><a href="#42513659">next</a><span>|</span><label class="collapse" for="c-42515000">[-]</label><label class="expand" for="c-42515000">[1 more]</label></div><br/><div class="children"><div class="content">This is how I work as well, and the reason I tend to write many small functions rather than few large ones is precisely because it reduces cognitive load. You don&#x27;t have to understand what the canSubmit function does, unless you are interested in knowing what the conditions to submit this form are.<p>Ironically, the author of the post claims it has the opposite effect.</div><br/></div></div><div id="42513659" class="c"><input type="checkbox" id="c-42513659" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513571">parent</a><span>|</span><a href="#42515000">prev</a><span>|</span><a href="#42510812">next</a><span>|</span><label class="collapse" for="c-42513659">[-]</label><label class="expand" for="c-42513659">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    # Can&#x27;t import at the start, because of the need to bootstrap the
    # environment via `get_requires_for_build_*`.
  
</code></pre>
This comment is a great example of what information you lose when you split linear code into small interrelated methods. You lose ordering and dependencies.<p>Sometimes it&#x27;s worth it. Sometimes it isn&#x27;t. In my opinion it&#x27;s almost never worth it to get to the Uncle Bob&#x27;s approved length of methods.<p>10-30 lines is OK. 3 is counterproductive except for a small subset of wrappers, getters etc. Occasionally it&#x27;s good to leave a method that is 300 lines long.<p>If your code always does 9 things in that exact order - it&#x27;s counterproductive to split them artificially into 3 sets of 3 things to meet an arbitrary limit.</div><br/><div id="42513783" class="c"><input type="checkbox" id="c-42513783" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513659">parent</a><span>|</span><a href="#42510812">next</a><span>|</span><label class="collapse" for="c-42513783">[-]</label><label class="expand" for="c-42513783">[1 more]</label></div><br/><div class="children"><div class="content">&gt;This comment is a great example of what information you lose when you split linear code into small interrelated methods.<p>Inlining `_read_toml` or `_read_config` would change nothing about the reasoning. The purpose was to make sure the import isn&#x27;t tried until the library providing it is installed in the environment. <i>This has nothing to do with the call graph within my code.</i> It&#x27;s not caused by &quot;splitting the code into interrelated methods&quot; and is not a consequence of the dependencies of those functions on each other. It&#x27;s a consequence of the greater context in which the entire module runs.<p>The way that the system (which is not under my control) works (I don&#x27;t have a really good top-down reference handy for this - I may have to write one), a &quot;build frontend&quot; will invoke my code - <i>as a subprocess</i> - multiple times, possibly looking for and calling different hooks each time. The public `get_requires_for_build_wheel` and `get_requires_for_build_sdist` are optional hooks in that specification (<a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0517&#x2F;#optional-hooks" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0517&#x2F;#optional-hooks</a>).<p>However, this approach is left behind from an earlier iteration - I don&#x27;t need to use these hooks to ask the build frontend to install `tomli`, because the necessary conditions can be (and currently are) provided declaratively in `pyproject.toml` (and thus `tomli` will be installed, if necessary, before any attempts to run my backend code). I&#x27;ll rework this when I get back to it (I should just be able to do the import normally now, but of course this requires testing).</div><br/></div></div></div></div></div></div><div id="42510812" class="c"><input type="checkbox" id="c-42510812" checked=""/><div class="controls bullet"><span class="by">shivawu</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42513571">prev</a><span>|</span><a href="#42511476">next</a><span>|</span><label class="collapse" for="c-42510812">[-]</label><label class="expand" for="c-42510812">[6 more]</label></div><br/><div class="children"><div class="content">I agree except I think 100 lines is definitely worth a method, whereas 15 lines is obviously not worthy for the most cases and yet we do that a lot.<p>My principle has always been: “is this part a isolated and intuitive subroutine that I can clearly name and when other people see it they’ll get it at first glance without pausing to think what this does (not to mention reading through the implemention)”. I’m surprised this has not been a common wisdom from many others.</div><br/><div id="42511584" class="c"><input type="checkbox" id="c-42511584" checked=""/><div class="controls bullet"><span class="by">andrewingram</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510812">parent</a><span>|</span><a href="#42513590">next</a><span>|</span><label class="collapse" for="c-42511584">[-]</label><label class="expand" for="c-42511584">[1 more]</label></div><br/><div class="children"><div class="content">In recent years my general principle has been to introduce an abstraction (in this case split up a function) if it lowers local concepts to ~4 (presumably based on similar principles to the original post). I’ve taken to saying something along the lines of “abstractions motivated by reducing repetition or lines of code are often bad, whilst ones motivated by reducing cognitive load tend to be better”.<p>Good abstractions often reduce LOC, but I prefer to think of that as a happy byproduct rather than the goal.</div><br/></div></div><div id="42513590" class="c"><input type="checkbox" id="c-42513590" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510812">parent</a><span>|</span><a href="#42511584">prev</a><span>|</span><a href="#42511033">next</a><span>|</span><label class="collapse" for="c-42513590">[-]</label><label class="expand" for="c-42513590">[3 more]</label></div><br/><div class="children"><div class="content">&gt;My principle has always been: “is this part a isolated and intuitive subroutine that I can clearly name and when other people see it they’ll get it at first glance without pausing to think what this does (not to mention reading through the implemention)”.<p>I hold this principle as well.<p>And I commonly produce one-liner subroutines following it. For me, 15 lines has become disturbingly long.</div><br/><div id="42515984" class="c"><input type="checkbox" id="c-42515984" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513590">parent</a><span>|</span><a href="#42511033">next</a><span>|</span><label class="collapse" for="c-42515984">[-]</label><label class="expand" for="c-42515984">[2 more]</label></div><br/><div class="children"><div class="content">I tend toward John Carnack&#x27;s view. He seemed annoyed that he was being pressed to provide a maximum at all and specified 7000 lines. I don&#x27;t think I have ever gone that high. But really is just a matter of what you are doing. We expect to reuse things way more often than we actually do. If you wrote out everything you need to do in order and then applied the rule of three to make a function out of everything you did three times, it is very possible you wouldn&#x27;t remove anything. In which case I think it should just be the one function.</div><br/><div id="42517736" class="c"><input type="checkbox" id="c-42517736" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42515984">parent</a><span>|</span><a href="#42511033">next</a><span>|</span><label class="collapse" for="c-42517736">[-]</label><label class="expand" for="c-42517736">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We expect to reuse things way more often than we actually do.<p>This is about readability (which includes comprehensibility), not reuse. When I read code from others who take my view, I understand. When I read code from those who do not, I do not, until I refactor. I extract a piece that seems coherent, and guess its purpose, and then see what its surroundings look like, with that purpose written in place of the implementation. I repeat, and refine, and rename.<p>It is the same even if I never press a key in my editor. Understanding code within my mind is the same process, but relying on my memory to store the unwritten names. This is the nature of &quot;cognitive load&quot;.</div><br/></div></div></div></div></div></div><div id="42511033" class="c"><input type="checkbox" id="c-42511033" checked=""/><div class="controls bullet"><span class="by">toasterlovin</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510812">parent</a><span>|</span><a href="#42513590">prev</a><span>|</span><a href="#42511476">next</a><span>|</span><label class="collapse" for="c-42511033">[-]</label><label class="expand" for="c-42511033">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I find extracting code into methods very useful for naming things that are 1) a digression from the core logic, and 2) enough code to make the core logic harder to comprehend. It’s basically like, “here’s this thing, you can dig into it if you want, but you don’t have to.” Or, the core logic is the top level summary and the methods it calls out to are sections or footnotes.</div><br/></div></div></div></div><div id="42511476" class="c"><input type="checkbox" id="c-42511476" checked=""/><div class="controls bullet"><span class="by">westcoast49</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42510812">prev</a><span>|</span><a href="#42510615">next</a><span>|</span><label class="collapse" for="c-42511476">[-]</label><label class="expand" for="c-42511476">[1 more]</label></div><br/><div class="children"><div class="content">It comes down to the quality of the abstractions. If they are well made and well named, you&#x27;d rather read this:<p><pre><code>  axios.get(&#x27;https:&#x2F;&#x2F;api.example.com&#x27;, {
      headers: { &#x27;Authorization&#x27;: &#x27;Bearer token&#x27; },
      params: { key: &#x27;value&#x27; }
  })
  .then(response =&gt; console.log(response.data))
  .catch(error =&gt; console.error(error));
</code></pre>
than to read the entire implementations of get(), then() and catch() inlined.</div><br/></div></div><div id="42510615" class="c"><input type="checkbox" id="c-42510615" checked=""/><div class="controls bullet"><span class="by">Freak_NL</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511476">prev</a><span>|</span><a href="#42511030">next</a><span>|</span><label class="collapse" for="c-42510615">[-]</label><label class="expand" for="c-42510615">[4 more]</label></div><br/><div class="children"><div class="content">For unit testing those sub-sections in a clear and concise manner (i.e., low cognitive load). As long as the method names are descriptive no jumping to and fro is needed usually.<p>That doesn&#x27;t mean every little unit needs to be split out, but it can make sense to do so if it helps write and debug those parts.</div><br/><div id="42510841" class="c"><input type="checkbox" id="c-42510841" checked=""/><div class="controls bullet"><span class="by">oxidant</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510615">parent</a><span>|</span><a href="#42511030">next</a><span>|</span><label class="collapse" for="c-42510841">[-]</label><label class="expand" for="c-42510841">[3 more]</label></div><br/><div class="children"><div class="content">Then you need to make those functions public, when the goal is to keep them private and unusable outside of the parent function.<p>Sometimes it&#x27;s easy to write multiple named functions, but I&#x27;ve found debugging functions can be more difficult when the interactions of the sub functions contribute to a bug.<p>Why jump back and forth between sections of a module when I could&#x27;ve read the 10 lines in context together?</div><br/><div id="42510990" class="c"><input type="checkbox" id="c-42510990" checked=""/><div class="controls bullet"><span class="by">Freak_NL</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510841">parent</a><span>|</span><a href="#42511030">next</a><span>|</span><label class="collapse" for="c-42510990">[-]</label><label class="expand" for="c-42510990">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Then you need to make those functions public, […]<p>That depends on the language, but often there will be a way to expose them to unit tests while keeping them limited in exposure. Java has package private for this, with Rust the unit test sits in the same file and can access private function just fine. Other languages have comparable idioms.</div><br/><div id="42512740" class="c"><input type="checkbox" id="c-42512740" checked=""/><div class="controls bullet"><span class="by">oxidant</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510990">parent</a><span>|</span><a href="#42511030">next</a><span>|</span><label class="collapse" for="c-42512740">[-]</label><label class="expand" for="c-42512740">[1 more]</label></div><br/><div class="children"><div class="content">Javascript doesn&#x27;t, AFAIK. I work in Elixir, which doesn&#x27;t.<p>I&#x27;m for it if it&#x27;s possible but it can still make it harder to follow.</div><br/></div></div></div></div></div></div></div></div><div id="42511030" class="c"><input type="checkbox" id="c-42511030" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42510615">prev</a><span>|</span><a href="#42511457">next</a><span>|</span><label class="collapse" for="c-42511030">[-]</label><label class="expand" for="c-42511030">[3 more]</label></div><br/><div class="children"><div class="content">Because a function clearly defines the scope of the state within it, whereas a section of code within a long function does not. Therefore a function can be reasoned about in isolation, which lowers cognitive load.</div><br/><div id="42512295" class="c"><input type="checkbox" id="c-42512295" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511030">parent</a><span>|</span><a href="#42511744">next</a><span>|</span><label class="collapse" for="c-42512295">[-]</label><label class="expand" for="c-42512295">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree. If there are side effects happening which may be relevant, the section of code within a long function is executing in a clearly defined state (the stuff above it has happened, the stuff below it won&#x27;t happen until it finishes) while the same code in a separate function could be called from anywhere.  Even without side effects, if it&#x27;s called from more than one place, you have to think about all of its callers before you change its semantics, and before you look, you don&#x27;t know if there is more than one caller.  Therefore the section of code can be reasoned about with much lower cognitive load.  This may be why larger subroutines correlate with lower bug rates, at least in the small number of published empirical studies.<p>The advantage of small subroutines is not that they&#x27;re more logically tractable.  They&#x27;re less logically tractable!  The advantage is that they are <i>more flexible</i>, because the set of previously defined subroutines forms a language you can use to write new code.<p>Factoring into subroutines is not completely without its advantages for intellectual tractability.  You can write tests for a subroutine which give you some assurance of what it does and how it can be broken.  And (in the absence of global state, which is a huge caveat) you know that the subroutine only depends on its arguments, while a block in the middle of a long subroutine may have a lot of local variables in scope that it doesn&#x27;t use.  And often the <i>caller</i> of the new subroutine is more readable when you can see the code before the call to it and the code after it on the same screen: code written in the language extended with the new subroutine can be higher level.</div><br/></div></div><div id="42511744" class="c"><input type="checkbox" id="c-42511744" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511030">parent</a><span>|</span><a href="#42512295">prev</a><span>|</span><a href="#42511457">next</a><span>|</span><label class="collapse" for="c-42511744">[-]</label><label class="expand" for="c-42511744">[1 more]</label></div><br/><div class="children"><div class="content">You can write long functions in a bad way, don&#x27;t get me wrong. I&#x27;m just saying the rule that the <i>length itself</i> is an anti-pattern has no inherent validity.</div><br/></div></div></div></div><div id="42510769" class="c"><input type="checkbox" id="c-42510769" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511457">prev</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42510769">[-]</label><label class="expand" for="c-42510769">[16 more]</label></div><br/><div class="children"><div class="content">I find &quot;is_enabled(x)&quot; to be easier to reason about than<p><pre><code>    if (x.foo || x.bar.baz || (x.quux &amp;&amp; x.bar.foo))
</code></pre>
Even if it&#x27;s only ever used once. Functions and methods provide abstraction which is useful for more than just removing repetition.</div><br/><div id="42510973" class="c"><input type="checkbox" id="c-42510973" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510769">parent</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42510973">[-]</label><label class="expand" for="c-42510973">[5 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re literally using it just once, why not stick it in a local variable instead?  You&#x27;re still getting the advantage of naming the concept that it represents, without eroding code locality.<p>However, the example is a slightly tricky basis to form an opinion on best practice: you&#x27;re proposing that the clearly named example function name is_enabled is better than an expression based on symbols with gibberish names.  Had those names (x, foo, bar, baz, etc) instead been well chosen meaningful names, then perhaps the inline expression would have been just as clear, especially if the body of the if makes it obvious what&#x27;s being checked here.<p>It all sounds great to introduce well named functions in isolated examples, but examples like that are intrinsically so small that the costs of extra indirection are irrelevant. Furthermore, in these hypothetical examples, we&#x27;re kind of assuming that there _is_ a clearly correct and unique definition for is_enabled, but in reality, many ifs like this have more nuance.  The if may well not represent if-enabled, it might be more something like was-enabled-last-app-startup-assuming-authorization-already-checked-unless-io-error.  And the danger of leaving out implicit context like that is precisely that it sounds simple, is_enabled, but that simplicity hides corner cases and unchecked assumptions that may be invalidated by later code evolution - especially if the person changing the code is _not_ changing is_enabled and therefore at risk of assuming it really means whether something is enabled regardless of context.<p>A poor abstraction is worse than no abstraction. We need abstractions, but there&#x27;s a risk of doing so recklessly. It&#x27;s possible to abstract too little, especially if that&#x27;s a sign of just not thinking enough about semantics, but also to abstract too much, especially if that&#x27;s a sign of thinking superficially, e.g. to reduce syntactic duplication regardless of meaning.</div><br/><div id="42511226" class="c"><input type="checkbox" id="c-42511226" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510973">parent</a><span>|</span><a href="#42511354">next</a><span>|</span><label class="collapse" for="c-42511226">[-]</label><label class="expand" for="c-42511226">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure every compiler can manage optimizing out that method call, so do whichever makes you and your code reviewer happy.</div><br/></div></div><div id="42511354" class="c"><input type="checkbox" id="c-42511354" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510973">parent</a><span>|</span><a href="#42511226">prev</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42511354">[-]</label><label class="expand" for="c-42511354">[3 more]</label></div><br/><div class="children"><div class="content">A local variable is often <i>worse</i>: Now I suffer both the noise of the unabstracted thing, and an extra assignment. While part of the goal is to give a reasonable logical name to the complex business logic, the other value is to hide the business logic for readers who truly don&#x27;t care (which is most of them).<p>The names could be better and more expressive, sure, but they could also be function calls themselves or long and difficult to read names, as an example:<p><pre><code>    if (
        x.is_enabled ||
        x.new_is_enabled ||
        (x.in_us_timezone &amp;&amp; is_daytime()) ||
        x.experimental_feature_mode_for_testing 
        )...
</code></pre>
That&#x27;s somewhat realistic for cases where the abstraction is covering for business logic. Now if you&#x27;re lucky you can abstract that away entirely to something like an injected feature or binary flag (but then you&#x27;re actually doing what I&#x27;m suggesting, just with extra ceremony), but sometimes you can&#x27;t for various reasons, and the same concept applies.<p>In fact I&#x27;d actually strongly disagree with you and say that doing what I&#x27;m suggesting is even more important if the example is larger and more complicated. That&#x27;s not an excuse to not have tests or not maintain your code well, but if your argument is functionally &quot;we cannot write abstractions because I can&#x27;t trust that functions do what they say they do&quot;, that&#x27;s not a problem with abstractions, that&#x27;s a problem with the codebase.<p>I&#x27;m arguing that keeping the complexity of any given stanza of code low is important to long-term maintainability, and I think this is true because it invites a bunch of really good questions and naturally pushes back on some increases in complexity: if `is_enabled(x)` is the current state of things, there&#x27;s a natural question asked, and inherent pushback to changing that to `is_enabled(x, y)`. That&#x27;s <i>good</i>. Whereas its much easier for natural development of the god-function to result in 17 local variables with complex interrelations that are difficult to parse out and track.<p>My experience says that identifying, removing, and naming assumptions is vastly easier when any given function is small and tightly scoped and the abstractions you use to do so also naturally discourage other folks who develop on the same codebase from adding unnecessary complexity.<p>And I&#x27;ll reiterate: my goal, at least, when dealing with abstraction isn&#x27;t to focus on duplication, but on clarity. It&#x27;s worthwhile to introduce an abstraction even for code used once if it improves clarity. It may not be worthwhile to introduce an abstraction for something used many times if those things aren&#x27;t inherently related. That creates unnecessary coupling that you either undo or hack around later.</div><br/><div id="42512805" class="c"><input type="checkbox" id="c-42512805" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511354">parent</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42512805">[-]</label><label class="expand" for="c-42512805">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Now I suffer both the noise of the unabstracted thing, and an extra assignment.<p>Depends on your goals &#x2F; constraints. From a performance standpoint, the attribute lookups can often dwarf the overhead of an extra assignment.</div><br/><div id="42513051" class="c"><input type="checkbox" id="c-42513051" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42512805">parent</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42513051">[-]</label><label class="expand" for="c-42513051">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m speaking solely from a developer experience perspective.<p>We&#x27;re talking about cases where the expression is only used once, so the assignment is free&#x2F;can be trivially inlined, and the attribute lookups are also only used once so there is nothing saved by creating a temporary for them.</div><br/></div></div></div></div></div></div></div></div><div id="42510881" class="c"><input type="checkbox" id="c-42510881" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510769">parent</a><span>|</span><a href="#42510973">prev</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42510881">[-]</label><label class="expand" for="c-42510881">[10 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t you jump to is_enabled to see what it does?<p>That&#x27;s what I always do in new code, and probably why I dislike functions that are only used once or twice. The overhead of the jump is not worth it. is_enabled could be a comment above the block (up to a point, notif it&#x27;s too long)</div><br/><div id="42513625" class="c"><input type="checkbox" id="c-42513625" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510881">parent</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42513625">[-]</label><label class="expand" for="c-42513625">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t you jump to is_enabled to see what it does?<p>It determines whether the thing is enabled. Or else some other dev has some &#x27;splainin&#x27; to do. I already understand &quot;what it does&quot;; I am not interested in seeing the code until I have a reason to suspect a problem in that code.<p>If the corresponding logic were inline, I would have to think about it (or maybe read a comment) in order to understand its purpose. The function name tells me the purpose directly, and hides the implementation that doesn&#x27;t help me understand the bigger picture of the calling function.<p>Inline code does the opposite.<p>When <i>the calculation is neatly representable as a single, short, self-evident expression</i>, then yes, I just use a local assignment instead. If I find myself wanting to comment it - if I need to say something about the implementation that the implementation doesn&#x27;t say directly - using a separate function is beneficial, because a comment in that function then clearly refers to <i>that calculation specifically</i>, and I can consider that separately from the overall process.</div><br/><div id="42513839" class="c"><input type="checkbox" id="c-42513839" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513625">parent</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42513839">[-]</label><label class="expand" for="c-42513839">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It determines whether the thing is enabled.<p>Ah, but what exactly does &quot;enabled&quot; mean in this context? Might seem nitpicky, but I might very well have a different opinion than the person who wrote the code. I mean, if it was just `if foo.enabled ..` no one would put it in a new function.. right? :)<p>I would say a comment does the same, and better because it can be multi line, and you can read it without having to click or move to the function call to see the docs.<p>And you can jump past the implementation, iff it&#x27;s short and &quot;tidy&quot; and enough.<p>Yes, at some point it should be moved out anyway. I&#x27;m just weary from reading code with dozens of small functions, having to jump back and forth again and again and again</div><br/><div id="42514221" class="c"><input type="checkbox" id="c-42514221" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513839">parent</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42514221">[-]</label><label class="expand" for="c-42514221">[5 more]</label></div><br/><div class="children"><div class="content">&gt;Ah, but what exactly does &quot;enabled&quot; mean in this context?<p>If the code is working, it means what it needs to mean.<p>&gt; I mean, if it was just `if foo.enabled ..` no one would put it in a new function. right?<p>Sure. This is missing the point, however.<p>&gt; I&#x27;m just weary from reading code with dozens of small functions, having to jump back and forth again and again and again<p>Why do you jump to look at the other parts of the code? Did it fail a test?</div><br/><div id="42515940" class="c"><input type="checkbox" id="c-42515940" checked=""/><div class="controls bullet"><span class="by">Hasu</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42514221">parent</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42515940">[-]</label><label class="expand" for="c-42515940">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If the code is working, it means what it needs to mean.<p>No. Working code says nothing about the meaning of a label, which is purely to inform humans. The computer throws it away, the code will work no matter what you name it, even if the name is entirely wrong.<p>&gt; Why do you jump to look at the other parts of the code? Did it fail a test?<p>Because people pick bad names for methods, and I&#x27;ve been hurt before. I&#x27;m not reading the code just to fix a problem, I&#x27;m reading the code to understand what it does (what it ACTUALLY does, not what the programmer who wrote it THOUGHT it does), so I can fix the problem properly.</div><br/><div id="42517661" class="c"><input type="checkbox" id="c-42517661" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42515940">parent</a><span>|</span><a href="#42517635">next</a><span>|</span><label class="collapse" for="c-42517661">[-]</label><label class="expand" for="c-42517661">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Because people pick bad names for methods, and I&#x27;ve been hurt before.<p>So <i>you</i> write long functions because <i>other people</i> are bad at writing short ones?</div><br/><div id="42519058" class="c"><input type="checkbox" id="c-42519058" checked=""/><div class="controls bullet"><span class="by">Hasu</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42517661">parent</a><span>|</span><a href="#42517635">next</a><span>|</span><label class="collapse" for="c-42519058">[-]</label><label class="expand" for="c-42519058">[1 more]</label></div><br/><div class="children"><div class="content">I have absolutely done this myself in the past and confused myself with bad names. Any criticism I apply to other people also applies to myself: I am not a special case.<p>Naming things is hard! Even if you&#x27;re really good at naming things, adding more names and labels and file separation to a system adds to the complexity of the system. A long function may be complex, but it doesn&#x27;t leak the complexity into the rest of the system. Creating a function and splitting it out is not a zero cost action.<p>I write long functions when long functions make sense. I write plenty of short functions too, when that makes sense. I&#x27;m not religiously attached to function or file size, I&#x27;m attached to preserving the overall system structure and avoiding stuff that makes easy bugs.</div><br/></div></div></div></div><div id="42517635" class="c"><input type="checkbox" id="c-42517635" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42515940">parent</a><span>|</span><a href="#42517661">prev</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42517635">[-]</label><label class="expand" for="c-42517635">[1 more]</label></div><br/><div class="children"><div class="content">So my claim is that you do this less often than you claim to. There is some cutoff where you trust the code enough to not investigate it further. I&#x27;m of the opinion that this trust <i>should</i> generally be pretty close to the actual thing you&#x27;re working on or investigating, and if it isn&#x27;t that&#x27;s a cultural issue that won&#x27;t be solved by just &quot;prefer to inline&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42511236" class="c"><input type="checkbox" id="c-42511236" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510881">parent</a><span>|</span><a href="#42513625">prev</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42511236">[-]</label><label class="expand" for="c-42511236">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t you jump to is_enabled to see what it does?<p>That depends on a lot of things. But the answer is (usually) no. I might do it if I think the error is specifically in that section of code. But especially if you want to provide any kind of documentation or history on why that code is the way it is, it&#x27;s easier to abstract that away into the function.<p>Furthermore, most of the time code is being read isn&#x27;t the first time, and I emphatically don&#x27;t want to reread some visual noise every time I am looking at a larger piece of code.</div><br/><div id="42513874" class="c"><input type="checkbox" id="c-42513874" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511236">parent</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42513874">[-]</label><label class="expand" for="c-42513874">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense. To mee it&#x27;s not about the function having bad code, but different opinions about what exactly &quot;enabled&quot; means.<p>If I&#x27;m not interested I just jump past the block when reading (given that it&#x27;s short and tidy)</div><br/></div></div></div></div></div></div></div></div><div id="42513013" class="c"><input type="checkbox" id="c-42513013" checked=""/><div class="controls bullet"><span class="by">BenoitEssiambre</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42510769">prev</a><span>|</span><a href="#42511057">next</a><span>|</span><label class="collapse" for="c-42513013">[-]</label><label class="expand" for="c-42513013">[1 more]</label></div><br/><div class="children"><div class="content">Indeed and breaking out logic into more global scopes has serious downsides if that logic needs to be modified in the future, if your system still needs to support innovation and improvements, downsides not totally unlike the downsides of using a lot of global variables instead of local ones.<p>Prematurely abstracting and breaking code out into small high level chunks is bad. I try to lay it out from an information theoretic, mathematical perspective here:<p><a href="https:&#x2F;&#x2F;benoitessiambre.com&#x2F;entropy.html" rel="nofollow">https:&#x2F;&#x2F;benoitessiambre.com&#x2F;entropy.html</a><p>with some implications for testing:<p><a href="https:&#x2F;&#x2F;benoitessiambre.com&#x2F;integration.html" rel="nofollow">https:&#x2F;&#x2F;benoitessiambre.com&#x2F;integration.html</a><p>It all comes down to managing code entropy.</div><br/></div></div><div id="42511057" class="c"><input type="checkbox" id="c-42511057" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42513013">prev</a><span>|</span><a href="#42510678">next</a><span>|</span><label class="collapse" for="c-42511057">[-]</label><label class="expand" for="c-42511057">[5 more]</label></div><br/><div class="children"><div class="content">As a non English speaker, what does &quot;so much this&quot; mean?<p>Does it essentially just mean &quot;I agree&quot;?</div><br/><div id="42511134" class="c"><input type="checkbox" id="c-42511134" checked=""/><div class="controls bullet"><span class="by">scott_w</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511368">next</a><span>|</span><label class="collapse" for="c-42511134">[-]</label><label class="expand" for="c-42511134">[1 more]</label></div><br/><div class="children"><div class="content">Yep, basically “I agree with this statement a lot.” It’s very much an “online Americanism.”</div><br/></div></div><div id="42511368" class="c"><input type="checkbox" id="c-42511368" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511134">prev</a><span>|</span><a href="#42511147">next</a><span>|</span><label class="collapse" for="c-42511368">[-]</label><label class="expand" for="c-42511368">[1 more]</label></div><br/><div class="children"><div class="content">In the superlative, yes. It&#x27;s a fairly new phrase, and hardly in my parlance, but it&#x27;s growing on me when I&#x27;m in informal typed chat contexts.</div><br/></div></div><div id="42511147" class="c"><input type="checkbox" id="c-42511147" checked=""/><div class="controls bullet"><span class="by">ericjmorey</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511368">prev</a><span>|</span><a href="#42512471">next</a><span>|</span><label class="collapse" for="c-42511147">[-]</label><label class="expand" for="c-42511147">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a call for others to take note of the important or profound message being highlighted. So more than just &quot;I agree&quot;.</div><br/></div></div><div id="42512471" class="c"><input type="checkbox" id="c-42512471" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511147">prev</a><span>|</span><a href="#42510678">next</a><span>|</span><label class="collapse" for="c-42512471">[-]</label><label class="expand" for="c-42512471">[1 more]</label></div><br/><div class="children"><div class="content">When someone says &quot;this&quot; they are basically pointing at a comment and saying &quot;this is what I think too&quot;.<p>&quot;So much&quot; is applied to intensify that.<p>So, yes, it&#x27;s a strong assertion of agreement with the comment they&#x27;re replying to.</div><br/></div></div></div></div><div id="42510678" class="c"><input type="checkbox" id="c-42510678" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511057">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510678">[-]</label><label class="expand" for="c-42510678">[28 more]</label></div><br/><div class="children"><div class="content">&gt;why the hell would it be &quot;easier to read&quot; if I had to jump up and down the file to 7 different submethods when the function&#x27;s entire flow is always sequential?<p>If the submethods were clearly named then you&#x27;d only need to read the seven submethod names to understand what the function did, which is easier than reading 100 lines of code.</div><br/><div id="42511751" class="c"><input type="checkbox" id="c-42511751" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510678">parent</a><span>|</span><a href="#42510745">next</a><span>|</span><label class="collapse" for="c-42511751">[-]</label><label class="expand" for="c-42511751">[2 more]</label></div><br/><div class="children"><div class="content">If the variables were clearly named, I wouldn&#x27;t have to read much at all, unless I was interested in the details. I reitrate: why does the <i>length</i> of the single function with no reuse matter?</div><br/><div id="42511917" class="c"><input type="checkbox" id="c-42511917" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511751">parent</a><span>|</span><a href="#42510745">next</a><span>|</span><label class="collapse" for="c-42511917">[-]</label><label class="expand" for="c-42511917">[1 more]</label></div><br/><div class="children"><div class="content">It does not matter if function foo is reused, only if the code inside foo that is to be pulled into new function bar is.</div><br/></div></div></div></div><div id="42510745" class="c"><input type="checkbox" id="c-42510745" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510678">parent</a><span>|</span><a href="#42511751">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510745">[-]</label><label class="expand" for="c-42510745">[25 more]</label></div><br/><div class="children"><div class="content">Why is that any easier than having comments in the code that describe each part? In languages that don&#x27;t allow closures, there&#x27;s no good way to pass state between the seven functions unless you pass all the state you need, either by passing all the variables directly, or by creating an instance of a class&#x2F;struct&#x2F;whatever to hold those same variables and passing that. If you&#x27;re lucky it might only be a couple of variables, but one can imagine that it could be a lot.</div><br/><div id="42510806" class="c"><input type="checkbox" id="c-42510806" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42510818">next</a><span>|</span><label class="collapse" for="c-42510806">[-]</label><label class="expand" for="c-42510806">[9 more]</label></div><br/><div class="children"><div class="content">If all the functions need state from all the other functions, that is the problem a class or a struct solves - e.g. a place to store shared state.<p>If the 7 things are directly related to one another and are _really_ not atomic things (e.g. &quot;Find first user email&quot;, &quot;Filter unknown hostnames&quot;, etc), then they can be in a big pile in their own place, but that is typically pretty rare.<p>In general, you really want to let the code be crisp enough and your function names be intuitive enough that you don&#x27;t need comments. If you have comments above little blocks of code like &quot;Get user name and reorder list&quot;, that should probably just go into its own function.<p>Typically I build my code in &quot;layers&quot; or &quot;levels&quot;. The lowest level is a gigantic pile of utility functions. The top level is the highest level abstractions of whatever framework or interface I&#x27;m building. In the middle are all the abstractions I needed to build to bridge the two, typically programs are between 2-4 layers deep. Each layer should have all the same semantics of everything else at that layer, and lower layers should be less abstract than higher layers.</div><br/><div id="42510941" class="c"><input type="checkbox" id="c-42510941" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510806">parent</a><span>|</span><a href="#42510818">next</a><span>|</span><label class="collapse" for="c-42510941">[-]</label><label class="expand" for="c-42510941">[8 more]</label></div><br/><div class="children"><div class="content">My problem with the class&#x2F;struct approach is it doesn&#x27;t work if you don&#x27;t need everything everywhere.<p><pre><code>    foo(...):
        f1(a,b,c,d,e,f)
        f2(a,c,d,f)
        f3(b,c,d,e)
        ...
        f7(d,e)
</code></pre>
But with long descriptive variable names that you&#x27;d actually use so the function calls don&#x27;t fit on one line. Better imo to have a big long function instead of a class and passing around extra variables.<p>Though, ideally there isn&#x27;t this problem in the first place&#x2F;it&#x27;s refactored away (if possible).</div><br/><div id="42511347" class="c"><input type="checkbox" id="c-42511347" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510941">parent</a><span>|</span><a href="#42512425">next</a><span>|</span><label class="collapse" for="c-42511347">[-]</label><label class="expand" for="c-42511347">[3 more]</label></div><br/><div class="children"><div class="content">A function that needs so many parameters is already a no go.<p>If it doesn&#x27;t return anything, then it&#x27;s either a method in a class, or it&#x27;s a thing that perform some tricky side effect that will be better completely removed with a more sound design.</div><br/><div id="42514519" class="c"><input type="checkbox" id="c-42514519" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511347">parent</a><span>|</span><a href="#42512425">next</a><span>|</span><label class="collapse" for="c-42514519">[-]</label><label class="expand" for="c-42514519">[2 more]</label></div><br/><div class="children"><div class="content">Creating a class around the too many arguments you want to pass to your function <i>may</i> be a good idea if the concept happens to be coherent and hopefully a bit more long-lived than just the function call.<p>Otherwise, your just hiding the fact that your function requires too many arguments by calling them properties.</div><br/><div id="42517436" class="c"><input type="checkbox" id="c-42517436" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42514519">parent</a><span>|</span><a href="#42512425">next</a><span>|</span><label class="collapse" for="c-42517436">[-]</label><label class="expand" for="c-42517436">[1 more]</label></div><br/><div class="children"><div class="content">Well, if there is no class that seems to make sense to group them, that&#x27;s an additional flag that points to additional thoughts on design. Or discussion with fellow developer about it.<p>Of course, on some very exceptional case, 7 arguments might be relevant after all. If that is like the single one in the code base, and after thorough discussion with everyone implicated in the maintenance of the code it was agreed as an exceptionally acceptable trade-off for some reasons, making sure this would not leak in all the code base as it&#x27;s called almost everywhere, then let it be.<p>But if it&#x27;s a generalized style through the whole codebase, there are obvious lake of care for maintenability of the work and the team is going to pay for that sooner than later.</div><br/></div></div></div></div></div></div><div id="42512425" class="c"><input type="checkbox" id="c-42512425" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510941">parent</a><span>|</span><a href="#42511347">prev</a><span>|</span><a href="#42511415">next</a><span>|</span><label class="collapse" for="c-42512425">[-]</label><label class="expand" for="c-42512425">[3 more]</label></div><br/><div class="children"><div class="content">You access the shared data via the struct &#x2F; class reference, not as method parameters. That&#x27;s the benefit.<p>e.g.<p><pre><code>    foo(...):
        # Fields
        a
        b
        c
        d 
        e
        
        # Methods
        f1(f)
        f2(f)
        f3()
        ...
        f7()</code></pre></div><br/><div id="42513136" class="c"><input type="checkbox" id="c-42513136" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42512425">parent</a><span>|</span><a href="#42511415">next</a><span>|</span><label class="collapse" for="c-42513136">[-]</label><label class="expand" for="c-42513136">[2 more]</label></div><br/><div class="children"><div class="content">Moving them to a higher scope makes it harder to change anything in foo. Now anytime you want to read or write a-e you have to build the context to understand their complete lifecycles. If all the logic were smooshed together, or if it were factored into the original functions with lots of parameters, as ugly as either of them might be, you still have much more assurance about when they are initialized and changed, and the possible scopes for those events are much more obviously constrained in the code.</div><br/><div id="42515964" class="c"><input type="checkbox" id="c-42515964" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513136">parent</a><span>|</span><a href="#42511415">next</a><span>|</span><label class="collapse" for="c-42515964">[-]</label><label class="expand" for="c-42515964">[1 more]</label></div><br/><div class="children"><div class="content">If all those functions need all those variables, then you&#x27;re either going to put them in a class, or put all those variables in something like a dict and just pass that in.<p>Seeing 10 variables passed in to a function is a code smell.<p>Whether you put in in a common class &#x2F; struct or aggregate them in a dict depends on whether or not all those functions are related.<p>In general, your functions should not be super duper long or super duper intended. Those are also code smells that indicate you have the wrong abstractions.</div><br/></div></div></div></div></div></div><div id="42511415" class="c"><input type="checkbox" id="c-42511415" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510941">parent</a><span>|</span><a href="#42512425">prev</a><span>|</span><a href="#42510818">next</a><span>|</span><label class="collapse" for="c-42511415">[-]</label><label class="expand" for="c-42511415">[1 more]</label></div><br/><div class="children"><div class="content">It works fine. Not all the methods need to use all the struct members.</div><br/></div></div></div></div></div></div><div id="42510818" class="c"><input type="checkbox" id="c-42510818" checked=""/><div class="controls bullet"><span class="by">hackinthebochs</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42510806">prev</a><span>|</span><a href="#42511251">next</a><span>|</span><label class="collapse" for="c-42510818">[-]</label><label class="expand" for="c-42510818">[5 more]</label></div><br/><div class="children"><div class="content">Language syntax defines functional boundaries. A strong functional boundary means you don&#x27;t have to reason about how other code can <i>potentially</i> influence your code, these boundaries are clearly defined and enforced by the compiler. If you just have one function with blocks of code with comments, you still must engage with the potential for non-obvious code interactions. That&#x27;s much higher cognitive load than managing the extra function with its defined parameters.</div><br/><div id="42510877" class="c"><input type="checkbox" id="c-42510877" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510818">parent</a><span>|</span><a href="#42511251">next</a><span>|</span><label class="collapse" for="c-42510877">[-]</label><label class="expand" for="c-42510877">[4 more]</label></div><br/><div class="children"><div class="content">In the ideal case, sure, but if assuming this can&#x27;t be refactored, then the code<p><pre><code>    foo(...):
       &#x2F;&#x2F; init
       f1(a,b,c,d,e,f)
       f2(a,b,c,d,e,f)
       ...
       f7(a,b,c,d,e,f)
</code></pre>
or the same just with a,b,c,d,e,f stuffed into a class&#x2F;struct and passed around, isn&#x27;t any easier to reason about than if those functions are inline.</div><br/><div id="42512379" class="c"><input type="checkbox" id="c-42512379" checked=""/><div class="controls bullet"><span class="by">hackinthebochs</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510877">parent</a><span>|</span><a href="#42511422">next</a><span>|</span><label class="collapse" for="c-42512379">[-]</label><label class="expand" for="c-42512379">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Your example tells me the structure of the code at a glance. If it was all inlined I would have to comprehend the code to recover this simple structure. Assuming the F&#x27;s are well-name that&#x27;s code I don&#x27;t have to read to comprehend its function. That&#x27;s always a win.</div><br/></div></div><div id="42511422" class="c"><input type="checkbox" id="c-42511422" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510877">parent</a><span>|</span><a href="#42512379">prev</a><span>|</span><a href="#42511399">next</a><span>|</span><label class="collapse" for="c-42511422">[-]</label><label class="expand" for="c-42511422">[1 more]</label></div><br/><div class="children"><div class="content">This typically can be coded with something like<p>def foo(...) = Something.new(...).f1.f2.f7<p>Note that ellipsis here are actual syntax in something like Ruby, other languages might not be as terse and convinient, but the fluent pattern can be implemented basically everywhere (ok maybe not cobol)</div><br/></div></div><div id="42511399" class="c"><input type="checkbox" id="c-42511399" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510877">parent</a><span>|</span><a href="#42511422">prev</a><span>|</span><a href="#42511251">next</a><span>|</span><label class="collapse" for="c-42511399">[-]</label><label class="expand" for="c-42511399">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s at least one reason that something like this is going to be exceedingly rare in practice, which is that (usually) functions return things.<p>In certain cases in C++ or C you might use in&#x2F;out params, but those are less necessary these days, and in most other languages you can just return stuff from your functions.<p>So in <i>almost</i> every case, f1 will have computed some intermediate value useful to f2, and so on and so forth. And these intermediate values will be arguments to the later functions. I&#x27;ve basically never encountered a situation where I <i>can&#x27;t</i> do that.<p>Edit: and as psychoslave mentions, the arguments themselves can be hidden with fluent syntax or by abstracting a-f out to a struct and a fluent api or `self`&#x2F;`this` reference.<p>Cases where you only use some of the parameters in each sub-function are the most challenging to cleanly abstract, but are also the most useful because they help to make complex spaghetti control-flow easier to follow.</div><br/></div></div></div></div></div></div><div id="42511251" class="c"><input type="checkbox" id="c-42511251" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42510818">prev</a><span>|</span><a href="#42513639">next</a><span>|</span><label class="collapse" for="c-42511251">[-]</label><label class="expand" for="c-42511251">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s no good way to pass state between the seven functions unless you pass all the state you need,<p>That’s why it’s better than comments: because it gives you clarity on what part of the state each function reads or writes. If you have a big complex state and a 100 line operation that is entirely “set attribute c to d, set attribute x to off” then no, you don’t need to extract functions, but it’s possible that e.g this method belongs inside the state object.</div><br/></div></div><div id="42513639" class="c"><input type="checkbox" id="c-42513639" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42511251">prev</a><span>|</span><a href="#42510949">next</a><span>|</span><label class="collapse" for="c-42513639">[-]</label><label class="expand" for="c-42513639">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Why is that any easier than having comments in the code that describe each part?<p>Because you only read the submethod names, and then you already understand what the code does, at the level you&#x27;re currently interested in.</div><br/></div></div><div id="42510949" class="c"><input type="checkbox" id="c-42510949" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42513639">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510949">[-]</label><label class="expand" for="c-42510949">[8 more]</label></div><br/><div class="children"><div class="content">&gt;Why is that any easier than having comments in the code that describe each part?<p>Because 7&lt;&lt;100</div><br/><div id="42511308" class="c"><input type="checkbox" id="c-42511308" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510949">parent</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42511308">[-]</label><label class="expand" for="c-42511308">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Because 7&lt;&lt;100</i><p>But then, 7 &lt;&lt; 100 &lt;&lt; (7 but each access blanks out your short-term memory), which is how jumping to all those tiny functions and back plays out in practice.</div><br/><div id="42513648" class="c"><input type="checkbox" id="c-42513648" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511308">parent</a><span>|</span><a href="#42511405">next</a><span>|</span><label class="collapse" for="c-42513648">[-]</label><label class="expand" for="c-42513648">[3 more]</label></div><br/><div class="children"><div class="content">&gt;which is how jumping to all those tiny functions and back plays out in practice.<p>Why would you jump into those functions and back?</div><br/><div id="42515930" class="c"><input type="checkbox" id="c-42515930" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513648">parent</a><span>|</span><a href="#42511405">next</a><span>|</span><label class="collapse" for="c-42515930">[-]</label><label class="expand" for="c-42515930">[2 more]</label></div><br/><div class="children"><div class="content">Because I need to know what they <i>actually</i> do? The most interesting details are almost always absent from the function name.<p>EDIT:<p>For even a simplest helper, there&#x27;s many ways to implement it. Half of them stupid, some only incorrect, some handling errors the wrong way or just the wrong way <i>for the needs of that specific callee I&#x27;m working on</i>. Stupidity often manifests in unnecessary copying and&#x2F;or looping over copy and&#x2F;or copying every step of the loop - all of which gets trivially hidden by extra indirection of a small function calling another small function. That&#x27;s how you often get accidental O(n^2) in random places.<p>Many such things are OK or not <i>in context of caller</i>, none of this is readily apparent in function signatures or type system. If the helper fn is otherwise abstracting a small idiom, I&#x27;d argue it&#x27;s only <i>obscuring it</i> and providing ample opportunities to screw up.<p>I know many devs don&#x27;t care, they prefer to instead submit slow and buggy code and fix it later when it breaks. I&#x27;m more of a &quot;don&#x27;t do stupid shit, you&#x27;ll have less bugs to fix and less performance issues for customers to curse you for&quot; kind of person, so cognitive load actually matters for me, and wishing it away isn&#x27;t an acceptable solution.</div><br/><div id="42517644" class="c"><input type="checkbox" id="c-42517644" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42515930">parent</a><span>|</span><a href="#42511405">next</a><span>|</span><label class="collapse" for="c-42517644">[-]</label><label class="expand" for="c-42517644">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Because I need to know what they actually do?<p>Strange. The longer I&#x27;ve been programming, the less I agree with this.<p>&gt;For even a simplest helper, there&#x27;s many ways to implement it.<p>Sure. But by definition, the interface is what matters at the call site.<p>&gt; That&#x27;s how you often get accidental O(n^2) in random places.<p>Both loops still have to be written. If they&#x27;re in separate places, then instead of a combined function which is needlessly O(n^2) where it should be O(n), you have two functions, one of which is needlessly O(n) where it should be O(1).<p>When you pinpoint a bottleneck function with a profiler, you want it to be obvious as possible what&#x27;s wrong: is it called too often, or does it take too long each time?<p>&gt; If the helper fn is otherwise abstracting a small idiom, I&#x27;d argue it&#x27;s only obscuring it and providing ample opportunities to screw up.<p>Abstractions explain the purpose in context.<p>&gt; I&#x27;m more of a &quot;don&#x27;t do stupid shit, you&#x27;ll have less bugs to fix and less performance issues for customers to curse you for&quot; kind of person<p>The shorter the function is, the less opportunity I have to introduce a stupidity.</div><br/></div></div></div></div></div></div><div id="42511405" class="c"><input type="checkbox" id="c-42511405" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511308">parent</a><span>|</span><a href="#42513648">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42511405">[-]</label><label class="expand" for="c-42511405">[3 more]</label></div><br/><div class="children"><div class="content">Why does pressing &quot;go to defn&quot; blank your short term memory in a way that code scrolling beyond the top of the screen doesn&#x27;t?</div><br/><div id="42515739" class="c"><input type="checkbox" id="c-42515739" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511405">parent</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42515739">[-]</label><label class="expand" for="c-42515739">[2 more]</label></div><br/><div class="children"><div class="content">Because jumping is disorienting, because each defn has a 1-3 lines of overhead (header, delimiters, whitespace) and lives among other defns, which may not be related to the task at hand, and are arranged in arbitrary order?<p>Does this really need explaining? My screen can show 35-50 lines of code; that can be 35-50 lines of relevant code in a &quot;fat&quot; function, or 10-20 lines of actual code, out of order, mixed with syntactic noise. The latter does <i>not</i> lower cognitive load.</div><br/><div id="42517833" class="c"><input type="checkbox" id="c-42517833" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42515739">parent</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42517833">[-]</label><label class="expand" for="c-42517833">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t have asked if I didn&#x27;t have a real curiosity!<p>To use a real world example where this comes up a lot, lots and lots of code can be structured as something like:<p><pre><code>    accum = []
    for x in something():
        for y in something_else():
            accum.append(operate_on(x, y))
</code></pre>
I find structuring it like this much easier than fully expanding all of these out, which at best ends up being something like<p><pre><code>    accum = []
    req = my_service.RpcRequest(foo=&quot;hello&quot;, bar=12)
    rpc = my_service.new_rpc()
    resp = my_service.call(rpc, req)
    
    req = my_service.OtherRpcRequest(foo=&quot;goodbye&quot;, bar=12)
    rpc = my_service.new_rpc()
    resp2 = my_service.call(rpc, req)

    for x in resp.something:
        for y in resp2.something_else:
            my_frobnicator = foo_frobnicator.new()
            accum.append(my_frobnicator.frob(x).nicate(y))
</code></pre>
and that&#x27;s sort of the best case where there isn&#x27;t some associated error handling that needs to be done for the rpc requests&#x2F;responses etc.<p>I find it much easier to understand what&#x27;s happening in the first case than the second, since the overall structure of the operations on the data is readily apparent at a glance, and I don&#x27;t need to scan through error handling and boilerplate.<p>Like, looking at real-life examples I have handy, there&#x27;s a bunch of cases where I have 6-10 lines of nonsense fiddling (with additional lines of documentation that would be even more costly to put inline!), and that&#x27;s in python. In cpp, go, and java which I use at work and are generally more verbose, and have more rpc and other boilerplate, this is usually even higher.<p>So the difference is that my approach means that when you jump to a function, you can be confident that the actual structure and logic of that function will be present and apparent to you on your screen without scrolling or puzzling. Whereas your approach gives you that, say, 50% of the time, maybe less, because the entire function doesn&#x27;t usually fit on the screen, and the structure may contain multiple logical subroutines, but they aren&#x27;t clearly delineated.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42513343" class="c"><input type="checkbox" id="c-42513343" checked=""/><div class="controls bullet"><span class="by">pcblues</span><span>|</span><a href="#42510573">prev</a><span>|</span><a href="#42515797">next</a><span>|</span><label class="collapse" for="c-42513343">[-]</label><label class="expand" for="c-42513343">[18 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a fan of using the least number of language features to get the job done. If a language is simple and can be stepped through easily, one benefits from the removal of the added cognitive load of knowing a large number of language features. This provides extra brainspace to understand the problem space and the system one is working on. Most importantly, it makes it easier to have the whole shebang in your mind while you add code (correctly.)<p>And it adds to maintainability (so long as done in a balanced way!)<p>I had a boss who saw me looking out a window say, &quot;You look like you are concentrating. I&#x27;ll come back later.&quot;<p>I document EVERYTHING I think straight away into their appropriate documents so I can forget about it while I&#x27;m loading as much of a system&#x27;s design into my head as I can. It allows me to write good code during that small window of available zen. After years of doing that, I made a document about documentation. Hope it&#x27;s of use. <a href="https:&#x2F;&#x2F;pcblues.com&#x2F;assets&#x2F;approaching_software_projects.pdf" rel="nofollow">https:&#x2F;&#x2F;pcblues.com&#x2F;assets&#x2F;approaching_software_projects.pdf</a></div><br/><div id="42513787" class="c"><input type="checkbox" id="c-42513787" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42514202">next</a><span>|</span><label class="collapse" for="c-42513787">[-]</label><label class="expand" for="c-42513787">[10 more]</label></div><br/><div class="children"><div class="content"><i>I&#x27;m a fan of using the least number of language features to get the job done.</i><p>Some people seem to love doing the opposite, which IMHO is the biggest problem with the software industry --- there&#x27;s a huge number of developers who think that the more complex (or in their words, &quot;structured&quot;) software is, and the more latest language features it has, is somehow better than the simple &quot;deprecated&quot; stuff that&#x27;s been working for decades.<p>I&#x27;ve come to the conclusion that a lot of new language features are there only for the benefit of trendchasers and worshippers of planned obsolescence, and not the users nor the developers on their side.</div><br/><div id="42515529" class="c"><input type="checkbox" id="c-42515529" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42513787">parent</a><span>|</span><a href="#42514880">next</a><span>|</span><label class="collapse" for="c-42515529">[-]</label><label class="expand" for="c-42515529">[1 more]</label></div><br/><div class="children"><div class="content">I think the biggest problem with the software industry is all the people who insist that everything that everyone <i>else</i> does is the biggest problem with the software industry.<p>I guess that set includes me now ¯\_(ツ)_&#x2F;¯</div><br/></div></div><div id="42514880" class="c"><input type="checkbox" id="c-42514880" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42513787">parent</a><span>|</span><a href="#42515529">prev</a><span>|</span><a href="#42514239">next</a><span>|</span><label class="collapse" for="c-42514880">[-]</label><label class="expand" for="c-42514880">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve come to the conclusion that a lot of new language features are there only for the benefit of trendchasers and worshippers of planned obsolescence, and not the users nor the developers on their side.<p>What are your thoughts on aync&#x2F;await then (available in Python&#x2F;JavaScript etc.)?</div><br/><div id="42515397" class="c"><input type="checkbox" id="c-42515397" checked=""/><div class="controls bullet"><span class="by">normie3000</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42514880">parent</a><span>|</span><a href="#42519310">next</a><span>|</span><label class="collapse" for="c-42515397">[-]</label><label class="expand" for="c-42515397">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What are your thoughts on aync&#x2F;await then (available in Python&#x2F;JavaScript etc.)?<p>Not the OP, but I find it hard to have an absolute opinion on this - IMO some recent additions to javascript significantly decrease cognitive load.<p>async&#x2F;await is a great example of this (vs then&#x2F;catch&#x2F;finally chains), and also:<p>* spreading of arrays, props, and more arguably args
* shortcutting prop&#x2F;value pairs, e.g. { x:x } as { x }<p>Some stuff it seems are more confusing, e.g.<p>* similar but subtly different things like for&#x2F;of vs for&#x2F;in vs forEach vs iterating Object.keys(), Object.values(), Object.entries()
* what are generators and the yield keyword for?</div><br/><div id="42515992" class="c"><input type="checkbox" id="c-42515992" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42515397">parent</a><span>|</span><a href="#42519310">next</a><span>|</span><label class="collapse" for="c-42515992">[-]</label><label class="expand" for="c-42515992">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what are generators and the yield keyword for?<p>Generators are great for memory intensive data structures (ie. large lists), as they provide lazy evaluation to languages that are designed to evaluate eagerly. Generators can be considered to be a first step towards coroutines if you will, as the subroutines are the ones <i>yield</i>-ing control back to the event loop - David Beazley has a great talk[0] on it, coding an event loop live from scratch.<p>&gt; similar but subtly different things like for&#x2F;of vs for&#x2F;in vs forEach vs iterating Object.keys(), Object.values(), Object.entries()<p><i>Array.forEach</i>[1] is the oldest of that bunch, <i>Object.keys</i>[2] came later, <i>for...in</i>[3]&#x2F;<i>for...of</i>[4] after that, and <i>Object.values</i>[5]&#x2F;<i>Object.entries</i>[6] are the newest addition. I personally prefer the new way here.<p>EDIT: <i>for...in</i>[3], then <i>Array.forEach</i>[1], then <i>Object.keys</i>[2], then the rest it seems.<p>[0]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;MCs5OvhV9S4?t=1072" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;MCs5OvhV9S4?t=1072</a> (video)<p>[1]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;forEach#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[2]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;keys#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[3]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;for...in#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[4]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;for...of#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[5]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;values#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[6]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;entries#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div></div></div><div id="42519310" class="c"><input type="checkbox" id="c-42519310" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42514880">parent</a><span>|</span><a href="#42515397">prev</a><span>|</span><a href="#42515863">next</a><span>|</span><label class="collapse" for="c-42519310">[-]</label><label class="expand" for="c-42519310">[1 more]</label></div><br/><div class="children"><div class="content">My thoughts can be summed up in 4 words: &quot;stay away from async&quot;.<p>Several decades of experience debugging race conditions and other obscure concurrency bugs have taught me that the benefits of async code are rarely worth it, and more often than not add unnececessary overhead both at runtime and in development.</div><br/></div></div><div id="42515863" class="c"><input type="checkbox" id="c-42515863" checked=""/><div class="controls bullet"><span class="by">redman25</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42514880">parent</a><span>|</span><a href="#42519310">prev</a><span>|</span><a href="#42514239">next</a><span>|</span><label class="collapse" for="c-42515863">[-]</label><label class="expand" for="c-42515863">[3 more]</label></div><br/><div class="children"><div class="content">Complexity in javascript is probably more like the fact that there are three different ways of constructing classes. Async&#x2F;await has it&#x27;s own pitfalls but at least it is adding new functionality.</div><br/><div id="42516069" class="c"><input type="checkbox" id="c-42516069" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42515863">parent</a><span>|</span><a href="#42514239">next</a><span>|</span><label class="collapse" for="c-42516069">[-]</label><label class="expand" for="c-42516069">[2 more]</label></div><br/><div class="children"><div class="content">JavaScript has multiple ways to blueprint objects, yes, but that isn&#x27;t really what GP stated. I consider the <i>class</i> keyword as way more beneficial than just being for &quot;trendchasers and worshippers&quot;.<p>The only pitfall with async&#x2F;await is all the existing I&#x2F;O-intensive code where blocking your runtime wasn&#x27;t seen as a problem that waisted unnecessary resources (yet). <i>Must be This Tall to Write Multi-Threaded Code</i>[0] comes to mind.<p>[0]: <a href="https:&#x2F;&#x2F;bholley.net&#x2F;blog&#x2F;2015&#x2F;must-be-this-tall-to-write-multi-threaded-code.html" rel="nofollow">https:&#x2F;&#x2F;bholley.net&#x2F;blog&#x2F;2015&#x2F;must-be-this-tall-to-write-mul...</a></div><br/><div id="42516447" class="c"><input type="checkbox" id="c-42516447" checked=""/><div class="controls bullet"><span class="by">redman25</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42516069">parent</a><span>|</span><a href="#42514239">next</a><span>|</span><label class="collapse" for="c-42516447">[-]</label><label class="expand" for="c-42516447">[1 more]</label></div><br/><div class="children"><div class="content">I agree, class syntax is better. If javascript had been designed today, I imagine that would be the _only_ way to blueprint objects.</div><br/></div></div></div></div></div></div></div></div><div id="42514239" class="c"><input type="checkbox" id="c-42514239" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42513787">parent</a><span>|</span><a href="#42514880">prev</a><span>|</span><a href="#42514202">next</a><span>|</span><label class="collapse" for="c-42514239">[-]</label><label class="expand" for="c-42514239">[1 more]</label></div><br/><div class="children"><div class="content">Funny thing is, humans have a huge bias towards traditions that seems to have reversed in the last century or so.<p>My take is that consumerism did a number on our psyche.</div><br/></div></div></div></div><div id="42514202" class="c"><input type="checkbox" id="c-42514202" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42513787">prev</a><span>|</span><a href="#42513472">next</a><span>|</span><label class="collapse" for="c-42514202">[-]</label><label class="expand" for="c-42514202">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If a language is simple and can be stepped through easily, one benefits from the removal of the added cognitive load of knowing a large number of language features.<p>Things that you know and have internalised <i>don&#x27;t</i> occupy your brainspace. That&#x27;s why you can read this paragraph without having to think about every word individually.</div><br/><div id="42515536" class="c"><input type="checkbox" id="c-42515536" checked=""/><div class="controls bullet"><span class="by">qw</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42514202">parent</a><span>|</span><a href="#42513472">next</a><span>|</span><label class="collapse" for="c-42515536">[-]</label><label class="expand" for="c-42515536">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Things that you know and have internalised don&#x27;t occupy your brainspace<p>Some &quot;10x&quot; developers are extremely productive because they know the software stack inside and out.<p>There are also &quot;10x&quot; teams where they share an institutional knowledge of the software stack and are constantly improving and finding more efficient ways of solving a problem. When someone finds a better library, more efficient CI&#x2F;CD or establish new code practices it is easy to apply it when they have a single stack to focus on.<p>It&#x27;s hard to replicate this in teams where they are responsible for 10 micro services, each written in their own language and using different software stacks that are more &quot;optimal&quot; for some use case.</div><br/><div id="42515811" class="c"><input type="checkbox" id="c-42515811" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42515536">parent</a><span>|</span><a href="#42513472">next</a><span>|</span><label class="collapse" for="c-42515811">[-]</label><label class="expand" for="c-42515811">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The constant push for constantly solving 100 problems with 50 poorly understood technologies instead of doing a couple of things and understanding them really well sometimes really makes me hate modern software development.</div><br/></div></div></div></div></div></div><div id="42513472" class="c"><input type="checkbox" id="c-42513472" checked=""/><div class="controls bullet"><span class="by">pcblues</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42514202">prev</a><span>|</span><a href="#42513554">next</a><span>|</span><label class="collapse" for="c-42513472">[-]</label><label class="expand" for="c-42513472">[1 more]</label></div><br/><div class="children"><div class="content">Also, it&#x27;s important that you make your own templates for each of the document types, because thinking about them is part of the design process. It reduces the cognitive load of understanding yet another set of design document templates, and they are malleable in your own hands :)</div><br/></div></div><div id="42513554" class="c"><input type="checkbox" id="c-42513554" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42513472">prev</a><span>|</span><a href="#42515797">next</a><span>|</span><label class="collapse" for="c-42513554">[-]</label><label class="expand" for="c-42513554">[3 more]</label></div><br/><div class="children"><div class="content">I agree and will add in a few bits: although I will obey the language&#x27;s idiom, in general, I like to keep the number of &quot;things it does&quot; per line of code to the minimum.  Kind of an anti-code golf.<p>I also document (or comment code) when I am waiting for the <i>flow</i> to kick in.  For me, the documentation starts at the appendices.  One for input files or api source tricks or describing the input tables in a database.  Another for the relevant outputs.  Maybe a &quot;justify overall design decisions&quot; section.  Just stuff someone would wish if they had to handle it in five years.</div><br/><div id="42516873" class="c"><input type="checkbox" id="c-42516873" checked=""/><div class="controls bullet"><span class="by">pcblues</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42513554">parent</a><span>|</span><a href="#42515797">next</a><span>|</span><label class="collapse" for="c-42516873">[-]</label><label class="expand" for="c-42516873">[2 more]</label></div><br/><div class="children"><div class="content">I wonder why people boast they can do ten things in one line. Less lines of code doesn&#x27;t mean less bugs. The debugger just stops at each symbol instead of each line which I think adds to the cognitive load.<p>Documenting while waiting for the flow is like stretching before exercise. It gets you to that place :)<p>I got my experience&#x2F;slaps by fixing my own code in the same codebase for more than ten years. I have empathy for the future maintainers :)</div><br/><div id="42520404" class="c"><input type="checkbox" id="c-42520404" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#42513343">root</a><span>|</span><a href="#42516873">parent</a><span>|</span><a href="#42515797">next</a><span>|</span><label class="collapse" for="c-42520404">[-]</label><label class="expand" for="c-42520404">[1 more]</label></div><br/><div class="children"><div class="content">I have passed on at least a few codebases.  Sometimes, people get bright ideas and just dump what&#x27;s working to do greenfield stuff.  This is why an ex-coworker recently wanted me to come back to braindump on something I finished in 2009.  After I left, some bright spark wanted to start from scratch and now there are continual complaints when the previous thing just <i>worked</i>, aside from a per-semester update, which the software would nag you about, as new departments appeared and such.<p>On the other hand, I had an apartment-renting suite I had written get passed on to students.  While it was written in Perl (a famously &quot;write once, read never&quot; language according to critics), because I did just one thing per line and had comments at multiple levels (a block header for each function, comments within functions, a changelog at the top), they called back and said it was the easiest thing in the world for them to convert it, despite not knowing Perl at all.<p>Although I had been programming for years and years by the time I took a FORTRAN course in high school, I had a particularly exacting teacher with a Ph.D. in Computer Science and he drilled us on how we would have to deal with the code of others, or our old code, or code when we did not want to come into work with a cold.  Cleverness is held in reserve for data structures and algorithms, when you have no other options.  He was very firm on that.</div><br/></div></div></div></div></div></div></div></div><div id="42515797" class="c"><input type="checkbox" id="c-42515797" checked=""/><div class="controls bullet"><span class="by">ipython</span><span>|</span><a href="#42513343">prev</a><span>|</span><a href="#42516533">next</a><span>|</span><label class="collapse" for="c-42515797">[-]</label><label class="expand" for="c-42515797">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure I’d use the Unix io interface as a shining example of reducing cognitive load. Sure, it’s a simple interface on the surface but…<p>Let’s just take write() as an example. Just calling write() does not guarantee that the full contents were written to the file. You could have the case where write() wrote nothing, or some data, but was interrupted because of a signal before it completed. Or you could have a short write because of a quota or disk limit.<p>And I’m sure I’ll be nerd sniped shortly with even more obscure examples of the sharp edges awaiting you in such a “simple” interface. (For a more snarky version of my comment, see the last essay “the rise of worse is better” of the Unix haters handbook: <a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;~simsong&#x2F;www&#x2F;ugh.pdf" rel="nofollow">https:&#x2F;&#x2F;web.mit.edu&#x2F;~simsong&#x2F;www&#x2F;ugh.pdf</a>)<p>Point is, this interface just shifts cognitive load on to the application developer - it’s got to go somewhere after all.</div><br/><div id="42517977" class="c"><input type="checkbox" id="c-42517977" checked=""/><div class="controls bullet"><span class="by">C-programmer</span><span>|</span><a href="#42515797">parent</a><span>|</span><a href="#42516533">next</a><span>|</span><label class="collapse" for="c-42517977">[-]</label><label class="expand" for="c-42517977">[1 more]</label></div><br/><div class="children"><div class="content">`write` can format your disk if a trickster sets LD_PRELOAD to a malicious shared object.</div><br/></div></div></div></div><div id="42516533" class="c"><input type="checkbox" id="c-42516533" checked=""/><div class="controls bullet"><span class="by">throw4847285</span><span>|</span><a href="#42515797">prev</a><span>|</span><a href="#42511137">next</a><span>|</span><label class="collapse" for="c-42516533">[-]</label><label class="expand" for="c-42516533">[3 more]</label></div><br/><div class="children"><div class="content">I think this is compelling programming advice, but &quot;cognitive load&quot; isn&#x27;t adding anything. The problem with popularizing a term like cognitive load is that it just becomes a new more scientific term for an existing concept in folk psychology. It can then be applied, detached from any experimental psych, to anybody&#x27;s personal bugbear.<p>&quot;This programming paradigm is bad because cognitive load&quot; becomes identical to &quot;this programming paradigm is bad because it isn&#x27;t simple&quot; and then simple is such a fuzzy concept that you can define whatever you like as simple and whatever you don&#x27;t as having high cognitive load.</div><br/><div id="42516939" class="c"><input type="checkbox" id="c-42516939" checked=""/><div class="controls bullet"><span class="by">frou_dh</span><span>|</span><a href="#42516533">parent</a><span>|</span><a href="#42517050">next</a><span>|</span><label class="collapse" for="c-42516939">[-]</label><label class="expand" for="c-42516939">[1 more]</label></div><br/><div class="children"><div class="content">&gt; then simple is such a fuzzy concept that you can define whatever you like as simple and whatever you don&#x27;t as having high cognitive load.<p>Good observation. That is absolutely rampant in online programmer discussions&#x2F;flame-wars. Which is why Rich Hickey&#x27;s classic presentation Simple Made Easy, although not the last word on the topic, at least tried to bring some objectivity to what simple is.</div><br/></div></div><div id="42517050" class="c"><input type="checkbox" id="c-42517050" checked=""/><div class="controls bullet"><span class="by">rTX5CMRXIfFG</span><span>|</span><a href="#42516533">parent</a><span>|</span><a href="#42516939">prev</a><span>|</span><a href="#42511137">next</a><span>|</span><label class="collapse" for="c-42517050">[-]</label><label class="expand" for="c-42517050">[1 more]</label></div><br/><div class="children"><div class="content">Which is why engineers who intend to use the term in their discussions shouldn’t dumb it down or loosely define it in their own words, and cite the definition from authoritative sources, say reference texts.<p>And whenever it is being used as an argument to reject or approve code, just saying “because cognitive load” should not be accepted as enough. Instead, there should be an accompanying explanation for what exactly in the code raises the cognitive load and what mechanisms come into play that creates the cognitive load according to cognitive science. (Note: I’m using “science” here as opposed to just “psychology”, because the ana&#x2F;physio of human memory is not exclusive to the domain of psychology.)</div><br/></div></div></div></div><div id="42511137" class="c"><input type="checkbox" id="c-42511137" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42516533">prev</a><span>|</span><a href="#42510521">next</a><span>|</span><label class="collapse" for="c-42511137">[-]</label><label class="expand" for="c-42511137">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Types of cognitive load - Extrinsic&#x2F;Intrinsic<p>This neatly mirrors the central ideas presented in Out of the Tar Pit [0], which defines accidental and essential complexity.<p>Reading this paper was probably one of the biggest career unlocks for me. You really can win ~the entire game if you stay focused on the schema and keep in touch with the customer often enough to ensure that it makes sense to them over time.<p>OOTP presents a functional-relational programming approach, but you really just need the relational part to manage the complexity of the domain. Being able to say that one domain type is relevant to another domain type, but only by way of a certain set of attributes (in a 3rd domain type - join table), is an unbelievably powerful tool when used with discipline. This is how you can directly represent messy real world things like circular dependencies. Modern SQL dialects provide recursive CTEs which were intended to query these implied graphs.<p>Over time, my experience has evolved into &quot;let&#x27;s do as much within the RDBMS as we possibly can&quot;. LINQ &amp; friends are certainly nice to have if you need to build a fancy ETL pipeline that interfaces with some non-SQL target, but they&#x27;ll never beat a simple merge statement in brevity or performance if the source &amp; target of the information is ultimately within the same DB scope. I find myself spending more time in the SQL tools (and Excel) than I do in the various code tools.<p>[0] <a href="https:&#x2F;&#x2F;curtclifton.net&#x2F;papers&#x2F;MoseleyMarks06a.pdf" rel="nofollow">https:&#x2F;&#x2F;curtclifton.net&#x2F;papers&#x2F;MoseleyMarks06a.pdf</a></div><br/></div></div><div id="42510521" class="c"><input type="checkbox" id="c-42510521" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42511137">prev</a><span>|</span><a href="#42510834">next</a><span>|</span><label class="collapse" for="c-42510521">[-]</label><label class="expand" for="c-42510521">[99 more]</label></div><br/><div class="children"><div class="content">OMG, so much this.<p>One of the biggest sources of cognitive load is poor language design.  There are so many examples that I can&#x27;t even begin to list them all here, but in general, any time a compiler gives you an error <i>and tells you how to fix it</i> that is a big red flag.  For example, if the compiler can tell you that there needs to be a semicolon <i>right here</i>, that means that there does not in fact <i>need</i> to be a semicolon right there, but rather that this semicolon is redundant with information that is available elsewhere in the code, and the only reason it&#x27;s needed is because the language design demands it, not because of any actual necessity to precisely specify the behavior of the code.<p>Another red flag is boilerplate.  <i>By definition</i> boilerplate is something that you have to type not because it&#x27;s required to specify the behavior of the code but simply because the language design demands it.  Boilerplate is always unnecessary cognitive load, and it&#x27;s one sign of a badly designed language.  (Yes, I&#x27;m looking at you, Java.)<p>I use Common Lisp for my coding whenever I can, and one of the reasons is that it, uniquely among languages, allows me to change the syntax and add new constructs so that the language meets the problem and not the other way around.  This reduces cognitive load tremendously, and once you get used to it, writing code in any other language starts to feel like a slog.  You become keenly aware of the fact that 90% of your mental effort is going not towards actually solving the problem at hand, but appeasing the compiler or conforming to some stupid syntax rule that exists for no reason other than that someone at some time in the dim and distant past thought it might be a good idea, and were almost certainly wrong.</div><br/><div id="42510893" class="c"><input type="checkbox" id="c-42510893" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510616">next</a><span>|</span><label class="collapse" for="c-42510893">[-]</label><label class="expand" for="c-42510893">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Another red flag is boilerplate.<p>I have to disagree. Boilerplate can simply be a one-time cost that is paid at setup time, when somebody is already required to have an understanding of what’s happening. That boilerplate can be the platform for others to come along and easily read&#x2F;modify something verbose without having to go context-switch or learn something.<p>Arguing against boilerplate to an extreme is like arguing for DRY and total prevention of duplicated lines of code. It actually increases the cognitive load. Simple code to read and simple code to write is low-cost, and paying a one-time cost at setup is low compared to repeated cost during maintenance.</div><br/><div id="42511149" class="c"><input type="checkbox" id="c-42511149" checked=""/><div class="controls bullet"><span class="by">singingfish</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510893">parent</a><span>|</span><a href="#42513541">next</a><span>|</span><label class="collapse" for="c-42511149">[-]</label><label class="expand" for="c-42511149">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had some C# code inflicted on me recently that follows the pile of garbage design pattern.  Just some offshore guys fulfilling the poorly expressed spec with as little brain work as possible.  The amount of almost-duplicate boilerplate kicking around is one of the problems.  Yeah it looks like the language design encourages this lowest common denominator type approach, and has lead into the supplier providing code that needs substantial refactoring in order be able to create automated tests as the entry points ignore separation of concerns and abuse private v public members to give the pretense of best practices while in reality providing worst practice modify this code at your peril instead. It&#x27;s very annoying because I could have used that budget to do something actually useful, but on the other hand improves my job security for now.</div><br/><div id="42511597" class="c"><input type="checkbox" id="c-42511597" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511149">parent</a><span>|</span><a href="#42513541">next</a><span>|</span><label class="collapse" for="c-42511597">[-]</label><label class="expand" for="c-42511597">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like you would have had problems whether there was boilerplate-y code or not.</div><br/><div id="42512594" class="c"><input type="checkbox" id="c-42512594" checked=""/><div class="controls bullet"><span class="by">singingfish</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511597">parent</a><span>|</span><a href="#42513541">next</a><span>|</span><label class="collapse" for="c-42512594">[-]</label><label class="expand" for="c-42512594">[1 more]</label></div><br/><div class="children"><div class="content">The extra boilerplate noise with excessive repetition doesn&#x27;t help one little bit.</div><br/></div></div></div></div></div></div><div id="42513541" class="c"><input type="checkbox" id="c-42513541" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510893">parent</a><span>|</span><a href="#42511149">prev</a><span>|</span><a href="#42510616">next</a><span>|</span><label class="collapse" for="c-42513541">[-]</label><label class="expand" for="c-42513541">[1 more]</label></div><br/><div class="children"><div class="content">If some program can generate that code automatically, the need to generate it, write it to disk, and for you to edit it is proof that there is some flaw in the language the code is written in. When the generator needs to change, the whole project is fucked because you either have to delete the generated code, regenerate it, and replicate your modifications (where they still apply, and if they don&#x27;t still apply, it could have major implications for the entire project), or you have to manually replicate the differences between what the new version of the generator would generate and what the old version generated when you ran it.<p>With AST macros, you don&#x27;t change generated code, but instead provide pieces of code that get incorporated into the generated code in well-defined ways that allow the generated code to change in the future without scuttling your entire project.<p>&gt;others to come along and easily read&#x2F;modify something verbose without having to go context-switch or learn something.<p>They&#x27;re probably not reading it, but assuming it&#x27;s exactly the same code that appears in countless tutorials, other projects, and LLMs. If there&#x27;s some subtle modification in there, it could escape notice, and probably will at some point. If there are extensive modifications, then people who rely on that code looking like the tutorials will be unable to comprehend it in any way.</div><br/></div></div></div></div><div id="42510616" class="c"><input type="checkbox" id="c-42510616" checked=""/><div class="controls bullet"><span class="by">kvark</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510893">prev</a><span>|</span><a href="#42510600">next</a><span>|</span><label class="collapse" for="c-42510616">[-]</label><label class="expand" for="c-42510616">[38 more]</label></div><br/><div class="children"><div class="content">I disagree with the first point. Say, the compiler figured out your missing semicolon. Doesn&#x27;t mean it&#x27;s easy for another human to clearly see it. The compiler can spend enormous compute to guess that, and that guess doesn&#x27;t even have to be right! Ever been in a situation where following the compiler recommendation produces code that doesn&#x27;t work or even build?
We are optimizing syntax for humans here, so pointing out some redundancies is totally fine.</div><br/><div id="42510680" class="c"><input type="checkbox" id="c-42510680" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510616">parent</a><span>|</span><a href="#42510846">next</a><span>|</span><label class="collapse" for="c-42510680">[-]</label><label class="expand" for="c-42510680">[26 more]</label></div><br/><div class="children"><div class="content">&gt;  Doesn&#x27;t mean it&#x27;s easy for another human to clearly see it.<p>Why do you think that matters?  If it&#x27;s not needed, then it should never have been there in the first place.  If it helps to make the program readable by humans then it can be shown as part of the <i>rendering</i> of the program on a screen, but again, that should be part of the work the <i>computer</i> does, not the human.  Unnecessary cognitive load is still unnecessary cognitive load regardless of the goal in whose name it is imposed.</div><br/><div id="42510762" class="c"><input type="checkbox" id="c-42510762" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42516115">next</a><span>|</span><label class="collapse" for="c-42510762">[-]</label><label class="expand" for="c-42510762">[4 more]</label></div><br/><div class="children"><div class="content">In languages (both natural and machine languages) a certain amount of syntax redundancy is a feature. The point of syntax &quot;boilerplate&quot; is to turn typos into syntax errors. When you have a language without any redundant syntactical features, you run the risk that your typo is also valid syntax, just with different semantics than what you intended. IMHO, that&#x27;s much worse than dealing with a missing semicolon error.</div><br/><div id="42513176" class="c"><input type="checkbox" id="c-42513176" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510762">parent</a><span>|</span><a href="#42516115">next</a><span>|</span><label class="collapse" for="c-42513176">[-]</label><label class="expand" for="c-42513176">[3 more]</label></div><br/><div class="children"><div class="content">Can you provide an example where syntax that’s required to be typed and can be accurately diagnosed by the compiler can lead to unintended logic? This is not the same thing as like not typing curly braces under an if directive and then adding a second line under it.</div><br/><div id="42516252" class="c"><input type="checkbox" id="c-42516252" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513176">parent</a><span>|</span><a href="#42516115">next</a><span>|</span><label class="collapse" for="c-42516252">[-]</label><label class="expand" for="c-42516252">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can you provide an example where syntax that’s required to be typed and can be accurately diagnosed by the compiler can lead to unintended logic?<p>I&#x27;m not sure we are on the same page here. I&#x27;m saying the <i>absence</i> of redundant syntax of the sort that lets the compiler  accurately diagnose &#x27;trivial&#x27; syntax errors, that can create scenarios where a typo can give you unintended valid syntax with different logic.<p>So yes, the conditional shorthand in C would be an example. Getting rid of the braces means you lose an opportunity for the compiler to catch a &#x27;trivial&#x27; syntax error, which can lead to different semantics than what the writer intended.</div><br/><div id="42516950" class="c"><input type="checkbox" id="c-42516950" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516252">parent</a><span>|</span><a href="#42516115">next</a><span>|</span><label class="collapse" for="c-42516950">[-]</label><label class="expand" for="c-42516950">[1 more]</label></div><br/><div class="children"><div class="content">Yes, these are different things, which is why I discounted curly braces before. Those are not required for an if statement’s scope. Semicolon’s are “required” everywhere. The compiler can easily spot where one should be by parsing an invalid expression because it encounters illegal tokens to append onto the end of a valid expression, eg you cannot have one statement that contains two assignment operators at the same level of precedence.<p>However for curly brances around a conditional lexical scope, the compiler cannot tell you where the closing brace should be, besides before the end of the lexical scope that contains it, like the end of the containing function or class. There can be multiple valid locations before that: every other valid line of code. This is not the same as a semicolon, which must end <i>every</i> line of code.<p>Can you provide another example?</div><br/></div></div></div></div></div></div></div></div><div id="42516115" class="c"><input type="checkbox" id="c-42516115" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42510762">prev</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42516115">[-]</label><label class="expand" for="c-42516115">[9 more]</label></div><br/><div class="children"><div class="content">The full stop at the end of your last sentence isn’t strictly needed. It isn’t even strictly needed in the preceding sentences (except for the first one with the question mark), because the capitalization already indicates the beginning of the next sentence. We still use full stops because redundancy and consistency help preventing errors and ambiguities. Reducing the tolerances to zero increases the risk of mistakes and misinterpretations.<p>Ideally, adding&#x2F;removing&#x2F;changing a single character in valid source code would always render the code invalid instead of “silently” changing its meaning.</div><br/><div id="42516254" class="c"><input type="checkbox" id="c-42516254" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516115">parent</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42516254">[-]</label><label class="expand" for="c-42516254">[8 more]</label></div><br/><div class="children"><div class="content">&gt; The full stop at the end of your last sentence isn’t strictly needed.<p>yes, that&#x27;s true | but this redundancy is not necessary | it&#x27;s there for historical reasons | there are other ways to designate the separation between sentences | some of those alternatives might even make more sense than the usual convention</div><br/><div id="42516476" class="c"><input type="checkbox" id="c-42516476" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516254">parent</a><span>|</span><a href="#42516551">next</a><span>|</span><label class="collapse" for="c-42516476">[-]</label><label class="expand" for="c-42516476">[3 more]</label></div><br/><div class="children"><div class="content">The point was that the full stop is currently a redundant element in most cases, yet we would not want to omit it just for the reason of being redundant.<p>The spaces in your “ | ” punctuation are also not strictly needed, yet one would want to keep then for readability and for risk of otherwise mistaking an “|” for an “l” or similar.<p>Again, something not being strictly needed isn’t a sufficient argument to do without it. There are trade-offs.</div><br/><div id="42516509" class="c"><input type="checkbox" id="c-42516509" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516476">parent</a><span>|</span><a href="#42516551">next</a><span>|</span><label class="collapse" for="c-42516509">[-]</label><label class="expand" for="c-42516509">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The spaces in your “ | ” punctuation are also not strictly needed.<p>yes.that.is.true|spaces.are.not.strictly.needed.at.all|there.are.alternatives.and.there.are.situations.where.using.those.alternatives.actually.makes.sense|however.the.use.of.whitespace.is.so.deeply.ingrained.that.if.you.dont.do.it.the.rendering.of.your.text.will.generally.be.very.annoying.on.contemporary.systems<p>The Right Answer is to separate the underlying representation from the rendering.  We already do this to some extent in modern systems.  For example, the meaning of text generally doesn&#x27;t change if you change the font.  This is not always true.  The font can matter in math, for example.  And some font modifications can carry semantic information -- using italics can provide <i>emphasis</i>, for example.<p>The Right Way to design a programming language is to have an underlying unambiguous non-redundant canonical representation, and then multiple possible renderings that can be tailored to different requirements.  Again, we kinda-sorta do that in modern systems with, for example, syntax coloring.  But that&#x27;s just a half-assed hack layered on top of deeply broken language designs.</div><br/><div id="42516586" class="c"><input type="checkbox" id="c-42516586" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516509">parent</a><span>|</span><a href="#42516551">next</a><span>|</span><label class="collapse" for="c-42516586">[-]</label><label class="expand" for="c-42516586">[1 more]</label></div><br/><div class="children"><div class="content">Considering all the &quot;tabs or spaces&quot; flamewars and standardized formatting as with gofmt for Go code, I think this would get restricted at most professional codebases to some person&#x27;s favored style. Not sure that&#x27;s a good reason, but it&#x27;s worth considering. For projects that are solo or along those lines, feel free.</div><br/></div></div></div></div></div></div><div id="42516551" class="c"><input type="checkbox" id="c-42516551" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516254">parent</a><span>|</span><a href="#42516476">prev</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42516551">[-]</label><label class="expand" for="c-42516551">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re being disingenuous. Your suggestion is more like if you wrote<p>yes, that&#x27;s true but this redundancy is not necessary it&#x27;s there for historical reasons...<p>without any breaks. That might be exaggerating compared to your actual position, but surely you can see that &quot;unnecessary in this situation&quot; doesn&#x27;t imply &quot;unnecessary overall&quot;. &quot;Not necessary&quot; if we&#x27;re cherrypicking, sure.<p>If my program now has no semicolons and then I write something else that behaves differently than expected, I&#x27;m going to be sad. My mental model for programming fares better when semicolons are used, so I will favor writing programs with semicolons. To me, the cost is trivial and the benefit, while minimal, outweights the cost. I consider it separate from actual boilerplate. You can disagree and use other languages, but then we&#x27;re probably being moreso opinionated than divided into better or worse camps.</div><br/><div id="42516609" class="c"><input type="checkbox" id="c-42516609" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516551">parent</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42516609">[-]</label><label class="expand" for="c-42516609">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That might be exaggerating compared to your actual position<p>To the point of being a straw man.<p>There was actually a time when neither white space nor punctuation was used andallwordswerejustruntogetherlikethis.  Note that it&#x27;s still possible to decipher that text, it just takes a bit more effort.  Natural language is inherently redundant to a certain extent.  It&#x27;s mathematically impossible to remove all redundancy (that would be tantamount to achieving optimal compression, which is uncomputable).<p>The spaces around the vertical bars in my example were redundant because they <i>always</i> appeared before and after.  That is a sort of trivial redundancy and yes, you can remove it without loss of information.  It just makes the typography look a little less aesthetically appealing (IMHO).  But having <i>something</i> to indicate the boundaries between words and sentences has actual value and reduces cognitive load.<p>---<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Kolmogorov_complexity#Uncomputability_of_Kolmogorov_complexity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Kolmogorov_complexity#Uncomput...</a></div><br/><div id="42517467" class="c"><input type="checkbox" id="c-42517467" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516609">parent</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42517467">[-]</label><label class="expand" for="c-42517467">[2 more]</label></div><br/><div class="children"><div class="content">I think you forgot the analogy. Why is it bad to have semicolons in programs then?<p>&gt; You become keenly aware of the fact that 90% of your mental effort is going not towards actually solving the problem at hand, but appeasing the compiler or conforming to some stupid syntax rule that exists for no reason other than that someone at some time in the dim and distant past thought it might be a good idea, and were almost certainly wrong.<p>You said this originally. I definitely agree for something like parentheses in if conditions in Java, but I think semicolons are a great example of how<p>&gt; having something to indicate the boundaries between words and sentences has actual value and reduces cognitive load.</div><br/><div id="42518143" class="c"><input type="checkbox" id="c-42518143" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42517467">parent</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42518143">[-]</label><label class="expand" for="c-42518143">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why is it bad to have semicolons in programs then?<p>It&#x27;s not bad to <i>have</i> them, it&#x27;s bad to <i>require</i> them when they aren&#x27;t necessary.  It&#x27;s bad to make their absence be a fatal syntax error when they aren&#x27;t necessary.  (Some times they are necessary, but that&#x27;s the exception in contemporary languages.)<p>Also, I know I&#x27;m the one who brought them up, but semicolons are just one small example of a much bigger and more widespread problem.  It&#x27;s a mistake to fixate on semicolons.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42511431" class="c"><input type="checkbox" id="c-42511431" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42516115">prev</a><span>|</span><a href="#42518530">next</a><span>|</span><label class="collapse" for="c-42511431">[-]</label><label class="expand" for="c-42511431">[6 more]</label></div><br/><div class="children"><div class="content">Aside from the other good points, this thread is about cognitive load. If a language lets you leave off lots of syntactic elements &amp; let the compiler infer from context, that also forces anyone else reading it to also do the cognitive work to infer from context.<p>The only overhead it increases is the mechanical effort to type the syntax by the code author; they already had to know the context to know there should be two statements, because they made them, so there&#x27;s no increased &quot;cognitive&quot; load.</div><br/><div id="42511487" class="c"><input type="checkbox" id="c-42511487" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511431">parent</a><span>|</span><a href="#42518530">next</a><span>|</span><label class="collapse" for="c-42511487">[-]</label><label class="expand" for="c-42511487">[5 more]</label></div><br/><div class="children"><div class="content">I guess I didn&#x27;t make this clear.  I&#x27;m not advocating for semicolons to be made <i>optional</i>.  I&#x27;m saying that they should not be included in the language syntax <i>at all</i> unless they are <i>necessary</i> for some semantic purpose.  And this goes for <i>any</i> language element, not just semicolons.<p>The vast majority of punctuation in programming languages is unnecessary.  The vast majority of type declarations are unnecessary.  All boilerplate is unnecessary.  All these things are there mostly because of tradition, not because there is any technical justification for any of it.</div><br/><div id="42511880" class="c"><input type="checkbox" id="c-42511880" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511487">parent</a><span>|</span><a href="#42518530">next</a><span>|</span><label class="collapse" for="c-42511880">[-]</label><label class="expand" for="c-42511880">[4 more]</label></div><br/><div class="children"><div class="content">The point generalises beyond semicolons; everything you leave to context is something other people have to load up the context for in order to understand.<p>Consider Python; if there are the optional type hints, those can tell you the third parameter to a function is optional. If those are missing, you need to dive into the function to find that out; those type hints are entirely optional, and yet they reduce the cognitive load of anyone using it.</div><br/><div id="42513183" class="c"><input type="checkbox" id="c-42513183" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511880">parent</a><span>|</span><a href="#42513568">next</a><span>|</span><label class="collapse" for="c-42513183">[-]</label><label class="expand" for="c-42513183">[2 more]</label></div><br/><div class="children"><div class="content">I haven’t used type hints in Python, but can what you’re describing lead to situations where the code cannot run and the interpreter gives you a suggestion on how to fix it?</div><br/><div id="42513785" class="c"><input type="checkbox" id="c-42513785" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513183">parent</a><span>|</span><a href="#42513568">next</a><span>|</span><label class="collapse" for="c-42513785">[-]</label><label class="expand" for="c-42513785">[1 more]</label></div><br/><div class="children"><div class="content">Type hints have no runtime impact, so they can&#x27;t make stuff not work.<p>Type linters like mypy can check your code &amp; report something like &quot;this function call requires str, you&#x27;re providing str | None&quot; though.</div><br/></div></div></div></div><div id="42513568" class="c"><input type="checkbox" id="c-42513568" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511880">parent</a><span>|</span><a href="#42513183">prev</a><span>|</span><a href="#42518530">next</a><span>|</span><label class="collapse" for="c-42513568">[-]</label><label class="expand" for="c-42513568">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The point generalises beyond semicolons; everything you leave to context is something other people have to load up the context for in order to understand.<p>This is not true, because an editor can add any on-screen hints that are needed to help a human understand the code. For example, in my editor, Python code gets vertical lines that indicate where the different indentation levels are, so I can easily see when two lines of code far apart on the screen are at the same indentation level, or how many indentation levels lower the next line is after a long, highly-indented block. Python could add an end-of-block marker like Ruby does to make things like this easier to see, or it could try to encode the vertical lines into the language somehow, but I&#x27;d derive no benefit because the editor already gives me the visual clues I need.</div><br/></div></div></div></div></div></div></div></div><div id="42518530" class="c"><input type="checkbox" id="c-42518530" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42511431">prev</a><span>|</span><a href="#42510956">next</a><span>|</span><label class="collapse" for="c-42518530">[-]</label><label class="expand" for="c-42518530">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If it helps to make the program readable by humans then it can be shown as part of the rendering of the program on a screen, but again, that should be part of the work the computer does, not the human.<p>That means you and the compiler front-end are looking at different representations. Sounds doesn&#x27;t sound like a good idea. Keep it stupid simple: all of our source control tools should work on the same representation, and it should be simpler and portable. Well defined syntax is a good choice here, even if there&#x27;s some redundancy.</div><br/><div id="42518937" class="c"><input type="checkbox" id="c-42518937" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42518530">parent</a><span>|</span><a href="#42510956">next</a><span>|</span><label class="collapse" for="c-42518937">[-]</label><label class="expand" for="c-42518937">[1 more]</label></div><br/><div class="children"><div class="content">&gt; doesn&#x27;t sound like a good idea.<p>It isn&#x27;t, but that ship sailed when cpp was invented.<p>&gt; Keep it stupid simple<p>Could not agree more.  That&#x27;s why I use Lisp.</div><br/></div></div></div></div><div id="42510876" class="c"><input type="checkbox" id="c-42510876" checked=""/><div class="controls bullet"><span class="by">nullstyle</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42510956">prev</a><span>|</span><a href="#42510846">next</a><span>|</span><label class="collapse" for="c-42510876">[-]</label><label class="expand" for="c-42510876">[3 more]</label></div><br/><div class="children"><div class="content">&gt; then it can be shown as part of the rendering of the program on a screen<p>I disagree with this, and can most easily express my disagreement by pointing out that people look at code with a diversity of programs: From simple text editors with few affordances to convey a programs meaning apart from the plain text like notepad and pico all the way up to the full IDEs that can do automatic refactoring and structured editing like the Jet Brains suite, Emacs+Paredit, or the clearly ever-superior Visual Interdev 6.<p>If people view code through a diversity of programs, then code&#x27;s on-disk form matters, IMO.</div><br/><div id="42511949" class="c"><input type="checkbox" id="c-42511949" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510876">parent</a><span>|</span><a href="#42513608">next</a><span>|</span><label class="collapse" for="c-42511949">[-]</label><label class="expand" for="c-42511949">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but nothing stops you from looking at the raw code.  Consider looking at compiled code.  You can always hexdump the object file, but have a disassembly helps a lot.</div><br/></div></div><div id="42513608" class="c"><input type="checkbox" id="c-42513608" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510876">parent</a><span>|</span><a href="#42511949">prev</a><span>|</span><a href="#42510846">next</a><span>|</span><label class="collapse" for="c-42513608">[-]</label><label class="expand" for="c-42513608">[1 more]</label></div><br/><div class="children"><div class="content">People&#x27;s choice of editor is influenced by what they&#x27;re editing. For example, virtually every Lisp programmer uses Emacs, even though there are many alternatives out there, including VS Code plugins. And virtually every Java programmer uses a JetBrains IDE or something similar. I&#x27;d probably install an IDE if I had to work on a Java codebase. Editing with a diversity of programs isn&#x27;t universal.</div><br/></div></div></div></div></div></div><div id="42510846" class="c"><input type="checkbox" id="c-42510846" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510616">parent</a><span>|</span><a href="#42510680">prev</a><span>|</span><a href="#42510600">next</a><span>|</span><label class="collapse" for="c-42510846">[-]</label><label class="expand" for="c-42510846">[11 more]</label></div><br/><div class="children"><div class="content">No, as python and other languages amply demonstrate, the semicolon is for the compiler, not the developer. If the compiler is sophisticated enough to figure out that a semicolon is needed, it has become <i>optional</i>. That&#x27;s the OP&#x27;s point.</div><br/><div id="42510872" class="c"><input type="checkbox" id="c-42510872" checked=""/><div class="controls bullet"><span class="by">taormina</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510846">parent</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42510872">[-]</label><label class="expand" for="c-42510872">[8 more]</label></div><br/><div class="children"><div class="content">But the language spec for Python is what allows for this, not the compiler. \n is just the magic character now except now we also need a \ to make multiline expressions. It’s all trade offs, compilers are not magic</div><br/><div id="42513378" class="c"><input type="checkbox" id="c-42513378" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510872">parent</a><span>|</span><a href="#42510908">next</a><span>|</span><label class="collapse" for="c-42513378">[-]</label><label class="expand" for="c-42513378">[3 more]</label></div><br/><div class="children"><div class="content">&gt; now except now we also need a \ to make multiline expressions.<p>You never need the backslash in Python to make multiple expressions. There&#x27;s always a way to do multiline using parentheses. Their own style guidelines discourage using backslash for this purpose.</div><br/><div id="42516425" class="c"><input type="checkbox" id="c-42516425" checked=""/><div class="controls bullet"><span class="by">taormina</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513378">parent</a><span>|</span><a href="#42510908">next</a><span>|</span><label class="collapse" for="c-42516425">[-]</label><label class="expand" for="c-42516425">[2 more]</label></div><br/><div class="children"><div class="content">And you can also do it with triple quotation marks if strings are involved, but it’s still more work for the compiler that someone explicitly did, it’s not magic.</div><br/><div id="42516943" class="c"><input type="checkbox" id="c-42516943" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42516425">parent</a><span>|</span><a href="#42510908">next</a><span>|</span><label class="collapse" for="c-42516943">[-]</label><label class="expand" for="c-42516943">[1 more]</label></div><br/><div class="children"><div class="content">Plain strings work fine. Python has the same behavior as C: If two strings separated by whitespace, it concatenates them. So if I have a long string, I start with an open parenthesis, type one string, go to the next line, and another, and so on over several lines. Python sees it all as one string. Very readable.</div><br/></div></div></div></div></div></div><div id="42510908" class="c"><input type="checkbox" id="c-42510908" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510872">parent</a><span>|</span><a href="#42513378">prev</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42510908">[-]</label><label class="expand" for="c-42510908">[4 more]</label></div><br/><div class="children"><div class="content">Scala then. Semicolons are optional but you still can have them if you need them</div><br/><div id="42511005" class="c"><input type="checkbox" id="c-42511005" checked=""/><div class="controls bullet"><span class="by">lblume</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510908">parent</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42511005">[-]</label><label class="expand" for="c-42511005">[3 more]</label></div><br/><div class="children"><div class="content">The obvious example would have been JavaScript, but nobody wants to say something positive about JavaScript...</div><br/><div id="42513544" class="c"><input type="checkbox" id="c-42513544" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511005">parent</a><span>|</span><a href="#42511118">next</a><span>|</span><label class="collapse" for="c-42513544">[-]</label><label class="expand" for="c-42513544">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but nobody wants to say something positive about JavaScript...<p>For obvious reasons...</div><br/></div></div><div id="42511118" class="c"><input type="checkbox" id="c-42511118" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511005">parent</a><span>|</span><a href="#42513544">prev</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42511118">[-]</label><label class="expand" for="c-42511118">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript has some specific and unique issues. Some silly choices (like auto inserting of semi-colons after empty return) and source code routinely, intentionally getting mangled by minification.</div><br/></div></div></div></div></div></div></div></div><div id="42511830" class="c"><input type="checkbox" id="c-42511830" checked=""/><div class="controls bullet"><span class="by">nazgul17</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510846">parent</a><span>|</span><a href="#42510872">prev</a><span>|</span><a href="#42511001">next</a><span>|</span><label class="collapse" for="c-42511830">[-]</label><label class="expand" for="c-42511830">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that the semicolon is somehow a special character and that&#x27;s why it&#x27;s required&#x2F;optional. It&#x27;s the context that makes it necessary or not. Python proves that it&#x27;s possible to design a language that doesn&#x27;t need semicolons; it does not mean that e.g. Java or C are well defined if you make semicolons optional.</div><br/></div></div><div id="42511001" class="c"><input type="checkbox" id="c-42511001" checked=""/><div class="controls bullet"><span class="by">sokoloff</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510846">parent</a><span>|</span><a href="#42511830">prev</a><span>|</span><a href="#42510600">next</a><span>|</span><label class="collapse" for="c-42511001">[-]</label><label class="expand" for="c-42511001">[1 more]</label></div><br/><div class="children"><div class="content">If it’s in the language spec as required there and I’m using a compiler that claims to implement that language spec, I want the compiler to raise the error.<p><i>Additionally</i> offering help on how to fix it is welcome, but silently accepting not-language-X code as if it were valid language-X code is not what I want in a language-X compiler.</div><br/></div></div></div></div></div></div><div id="42510600" class="c"><input type="checkbox" id="c-42510600" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510616">prev</a><span>|</span><a href="#42510630">next</a><span>|</span><label class="collapse" for="c-42510600">[-]</label><label class="expand" for="c-42510600">[2 more]</label></div><br/><div class="children"><div class="content">Totally agree. I think the biggest and most important things a language designer chooses is what to disallow. For instance, private&#x2F;package&#x2F;public etc is one small example of an imposed restriction which makes it easier to reason about changing a large project because if e.g. something is private then you know it&#x27;s okay and probably easy to refactor. The self-imposed restrictions save you mental effort later. I also love lisps but am a Clojure fan. This is because in Clojure, 90+% of the code is static functions operating on immutable data. That makes it extremely easy to reason about in the large. Those two restrictions are big and impose a lot of structure, but man I can tear around the codebase with a machete because there are so many things that code &#x2F;can&#x27;t do&#x2F;. Also, testing is boneheaded simple because everything is just parameters in to those static functions and assert on the values coming out. I don&#x27;t have to do some arduous object construction with all these factories if I need to mock anything, I can use &quot;with-redefs&quot; to statically swap function definitions too, which is clean and very easy to reason about. Choosing the things you mr language disallows is one of the most important things you can do to reduce cognitive load.</div><br/><div id="42513668" class="c"><input type="checkbox" id="c-42513668" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510600">parent</a><span>|</span><a href="#42510630">next</a><span>|</span><label class="collapse" for="c-42513668">[-]</label><label class="expand" for="c-42513668">[1 more]</label></div><br/><div class="children"><div class="content">When the code needs to do something that it can&#x27;t do, there is a massive cognitive load associated with figuring out how to do something approximating it. When the language or a framework is associated with lots of &quot;how do I X&quot; questions, the answers to which are all &quot;completely rethink your program&quot;, that is evidence that the language&#x2F;framework is not reducing cognitive load.</div><br/></div></div></div></div><div id="42510630" class="c"><input type="checkbox" id="c-42510630" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510600">prev</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510630">[-]</label><label class="expand" for="c-42510630">[6 more]</label></div><br/><div class="children"><div class="content">Yes, semicolons are totally unnecessary. That’s why nobody who works on JavaScript has ever regretted that automatic semicolon insertion was added to the language.  It has never prevented the introduction of new syntaxes to the language (like discussed here: &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;twbs&#x2F;bootstrap&#x2F;issues&#x2F;3057#issuecomment-5135562">https:&#x2F;&#x2F;github.com&#x2F;twbs&#x2F;bootstrap&#x2F;issues&#x2F;3057#issuecomment-5...</a>&gt;), nor motivated the addition of awkward grammatical contortions like [no LineTerminator here].</div><br/><div id="42510704" class="c"><input type="checkbox" id="c-42510704" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510630">parent</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510704">[-]</label><label class="expand" for="c-42510704">[5 more]</label></div><br/><div class="children"><div class="content">There are plenty of languages that don’t require semicolons and yet manage to avoid those issues: Clojure, Go, Odin…</div><br/><div id="42512527" class="c"><input type="checkbox" id="c-42512527" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510704">parent</a><span>|</span><a href="#42510800">next</a><span>|</span><label class="collapse" for="c-42512527">[-]</label><label class="expand" for="c-42512527">[2 more]</label></div><br/><div class="children"><div class="content">Funny enough, Go’s grammar does require semicolons. It avoids needing them typed in the source code by automatically adding them on each newline before parsing.</div><br/><div id="42514244" class="c"><input type="checkbox" id="c-42514244" checked=""/><div class="controls bullet"><span class="by">ropejumper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42512527">parent</a><span>|</span><a href="#42510800">next</a><span>|</span><label class="collapse" for="c-42514244">[-]</label><label class="expand" for="c-42514244">[1 more]</label></div><br/><div class="children"><div class="content">On <i>almost</i> every newline, which is the reason why this doesn&#x27;t work:<p><pre><code>    func thing()
    {
</code></pre>
I quite like this approach. It&#x27;s very simple and consistent, and once you know how it works it&#x27;s not ever surprising.</div><br/></div></div></div></div><div id="42510800" class="c"><input type="checkbox" id="c-42510800" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510704">parent</a><span>|</span><a href="#42512527">prev</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510800">[-]</label><label class="expand" for="c-42510800">[2 more]</label></div><br/><div class="children"><div class="content">Clojure delineates everything by explicitly putting statements in parentheses (like any LISP). That&#x27;s basically the same thing.<p>Go is an interesting example but it gets away with this by being far stricter with syntax IIRC (for the record, I&#x27;m a fan of Go&#x27;s opinionated formatting).</div><br/><div id="42510922" class="c"><input type="checkbox" id="c-42510922" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510800">parent</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510922">[-]</label><label class="expand" for="c-42510922">[1 more]</label></div><br/><div class="children"><div class="content">Also Scala</div><br/></div></div></div></div></div></div></div></div><div id="42510731" class="c"><input type="checkbox" id="c-42510731" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510630">prev</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42510731">[-]</label><label class="expand" for="c-42510731">[9 more]</label></div><br/><div class="children"><div class="content">&gt; the compiler can tell you that there needs to be a semicolon right here<p>I can see that this is an annoyance, but does it really increase cognitive load? For me language design choices like allowing arbitrary arguments to functions (instead of having a written list of allowed arguments, I have to keep it in my head), or not having static types (instead of the compiler or my ide keeping track of types, I have to hold them in my head) are the main culprits for increasing cognitive load. Putting a semicolon where it belongs after the compiler telling me I have to is a fairly mindless exercise. The mental acrobatics I have to pull off to get anything done in dynamically typed languages is much more taxing to me.</div><br/><div id="42511520" class="c"><input type="checkbox" id="c-42511520" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510731">parent</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42511520">[-]</label><label class="expand" for="c-42511520">[8 more]</label></div><br/><div class="children"><div class="content">Semicolons are just an example, and a fairly minor one.  A bigger pet peeve of mine is C-style type declarations.  If I create a binding for X and initialize it to 1, the compiler should be able to figure out that X is an integer without my having to tell it.<p>In fact, all type declarations should be optional, with run-time dynamic typing as a fallback when type inferencing fails.  Type &quot;errors&quot; should always be warnings.  There should be no dichotomy between &quot;statically typed&quot; and &quot;dynamically typed&quot; languages.  There should be a smooth transition between programs with little or no compile-time type information and programs with a lot of compile-time type information, and the compiler should do something reasonable in all cases.</div><br/><div id="42518575" class="c"><input type="checkbox" id="c-42518575" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511520">parent</a><span>|</span><a href="#42516944">prev</a><span>|</span><a href="#42513337">next</a><span>|</span><label class="collapse" for="c-42518575">[-]</label><label class="expand" for="c-42518575">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If I create a binding for X and initialize it to 1, the compiler should be able to figure out that X is an integer without my having to tell it.<p>There are many integral types, all of which have different properties, often for good reasons.</div><br/><div id="42518961" class="c"><input type="checkbox" id="c-42518961" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42518575">parent</a><span>|</span><a href="#42513337">next</a><span>|</span><label class="collapse" for="c-42518961">[-]</label><label class="expand" for="c-42518961">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but often != always.  And if your language forbids type inference then you are burdened with the cognitive load of worrying about types every single time whether there is a good reason in that instance or not.</div><br/><div id="42520690" class="c"><input type="checkbox" id="c-42520690" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42518961">parent</a><span>|</span><a href="#42513337">next</a><span>|</span><label class="collapse" for="c-42520690">[-]</label><label class="expand" for="c-42520690">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a difference between inference and coercion, and no one here is arguing against inference, as far as I can tell.</div><br/></div></div></div></div></div></div><div id="42513337" class="c"><input type="checkbox" id="c-42513337" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511520">parent</a><span>|</span><a href="#42518575">prev</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42513337">[-]</label><label class="expand" for="c-42513337">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  with run-time dynamic typing as a fallback when type inferencing fails.<p>I&#x27;ve seen the code that comes out of this, and how difficult it can be to refactor. I definitely prefer strict typing in every situation that it can&#x27;t be inferred, if you&#x27;re going to have a language with static types.</div><br/><div id="42518480" class="c"><input type="checkbox" id="c-42518480" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513337">parent</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42518480">[-]</label><label class="expand" for="c-42518480">[2 more]</label></div><br/><div class="children"><div class="content">It works the other way too. Ive seen plenty of code with strict typing that could have its cognitive load reduced greatly by dynamic typing. A far bigger problem is hidden sideffects and static typing does nothing to fix that</div><br/><div id="42520791" class="c"><input type="checkbox" id="c-42520791" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42518480">parent</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42520791">[-]</label><label class="expand" for="c-42520791">[1 more]</label></div><br/><div class="children"><div class="content">I work in dynamically typed languages a lot, so I don&#x27;t have many opportunities to feel the way you do. Could you give an example where moving from static to dynamic would reduce cognitive load?<p>For the opposite example, here&#x27;s where my preference comes from: I&#x27;m editing a function. There&#x27;s an argument called order, and most likely it&#x27;s either an instance of some Order class, which has some attribute I need, or it&#x27;s an integer representing the I&#x27;d of such an order, or it&#x27;s null. I&#x27;m hoping to access that attribute, so I have to figure out the type of order.<p>In a dynamically typed language, I&#x27;ll have to look at the caller of my function (goes on my mental stack), see where it gets it order from, potentially go to the caller of that function (goes on my mental stack), etc until I hopefully see where order is instantiated and figure out it&#x27;s type, so I can take the call sites off of my mind, and just keep the type of order in my mental stack.<p>But actually, this is wrong, because my function is called by way more functions than the ones I examined. So really, all I know now is that _sometimes_ order is of type Order. To be sure, I have to go to _all_ callers of my function, and all their callers, etc. This grows exponentially.<p>But let&#x27;s say I manage, and I find the type of order, and keep it in my mind. Then I need to repeat the same process for other arguments I want to use, which is now harder because I&#x27;m keeping the type of order on my mental stack. If I manage to succeed, I can go and edit the function, keeping the types of whatever variables I&#x27;m using in my head. I pray that I didn&#x27;t miss a call site, and that the logic is not too complicated, because my mental stack is occupied with remembering types.<p>Here&#x27;s how to do this in a statically typed language: read the type signature. Done.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42511484" class="c"><input type="checkbox" id="c-42511484" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510731">prev</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42511484">[-]</label><label class="expand" for="c-42511484">[9 more]</label></div><br/><div class="children"><div class="content">The very same reasons you find CL to lower your cognitive load are why ultimately after 60 years all lisps have been relegated to niche languages despite their benefits, and I say it as a Racket lover. It raises cognitive load for everybody else by having to go through further steps into decoding your choices.<p>It&#x27;s the very same reason why Haskell monocle-wielding developers haven&#x27;t been able to produce one single killer software in decades: every single project&#x2F;library out there has its own extensions to the language, specific compiler flags, etc that onboarding and sharing code becomes a huge chore. And again I say it as an avid Haskeller.<p>Haskellers know that, and there was some short lived simple Haskell momentum but it died fast.<p>But choosing Haskell or a lisp (maybe I can exclude Clojure somewhat) at work? No, no and no.<p>Meanwhile bidonville PHP programmers can boast Laravel, Symfony and dozens of other libraries and frameworks that Haskellers will never ever be able to produce. Java?<p>C? Even more.<p>The language might be old and somewhat complex, but read a line and it means the same in any other project, there are no surprises only your intimacy with the language limiting you. There&#x27;s no ambiguity.</div><br/><div id="42514222" class="c"><input type="checkbox" id="c-42514222" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511484">parent</a><span>|</span><a href="#42511940">next</a><span>|</span><label class="collapse" for="c-42514222">[-]</label><label class="expand" for="c-42514222">[1 more]</label></div><br/><div class="children"><div class="content">I’m surprised to hear this from an avid Haskeller and I think it might give the wrong impression to those who are less familiar with Haskell. I’m sure you know this, but for the benefit of others, projects don’t have their <i>own</i> extensions, they just may or may not use some of the extensions provided by GHC. Anyway, that practice is now diminishing given the GHC2021 and GHC2024 “standards”, which just enable a fixed set of stable extensions.<p>And regarding using specific compiler flags, well, projects almost never do that.</div><br/></div></div><div id="42511940" class="c"><input type="checkbox" id="c-42511940" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511484">parent</a><span>|</span><a href="#42514222">prev</a><span>|</span><a href="#42515278">next</a><span>|</span><label class="collapse" for="c-42511940">[-]</label><label class="expand" for="c-42511940">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But choosing Haskell or a lisp (maybe I can exclude Clojure somewhat) at work? No, no and no.<p>I&#x27;ve been using CL at work for pretty much my entire career and have always gotten a huge amount of leverage from it.</div><br/><div id="42511983" class="c"><input type="checkbox" id="c-42511983" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511940">parent</a><span>|</span><a href="#42515278">next</a><span>|</span><label class="collapse" for="c-42511983">[-]</label><label class="expand" for="c-42511983">[2 more]</label></div><br/><div class="children"><div class="content">So do I, but not in large projects and teams that need to scale.</div><br/><div id="42518547" class="c"><input type="checkbox" id="c-42518547" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511983">parent</a><span>|</span><a href="#42515278">next</a><span>|</span><label class="collapse" for="c-42518547">[-]</label><label class="expand" for="c-42518547">[1 more]</label></div><br/><div class="children"><div class="content">This requirement has become a meme. I can do more on a project alone (spanning several new for me domains) with lisp than I can with a group of 5 or 10 in any other language</div><br/></div></div></div></div></div></div><div id="42515278" class="c"><input type="checkbox" id="c-42515278" checked=""/><div class="controls bullet"><span class="by">cognate</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511484">parent</a><span>|</span><a href="#42511940">prev</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42515278">[-]</label><label class="expand" for="c-42515278">[4 more]</label></div><br/><div class="children"><div class="content">I dumped Haskell specifically because of its enormous cognitive load. All my time and energy went into Haskell and its endless quirks, leaving nothing for the business problem and its stakeholders.</div><br/><div id="42515526" class="c"><input type="checkbox" id="c-42515526" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42515278">parent</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42515526">[-]</label><label class="expand" for="c-42515526">[3 more]</label></div><br/><div class="children"><div class="content">Intriguing! Could you say more about which aspects of Haskell gave it a high cognitive load for you?<p>By contrast, I&#x27;ve used predominantly Haskell in my career for the last ten years, exactly because it has <i>reduced</i> my cognitive load.  So I&#x27;m interested in understand the discrepancy here.</div><br/><div id="42518711" class="c"><input type="checkbox" id="c-42518711" checked=""/><div class="controls bullet"><span class="by">cognate</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42515526">parent</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42518711">[-]</label><label class="expand" for="c-42518711">[2 more]</label></div><br/><div class="children"><div class="content">Too much experimental software, too much fragmentation in major architectural design approaches, compounded by weak documentation, abandonware, and a tiny community.<p>Consider the choices in optics libraries, effects systems, regex packages, Haskell design patterns, web frameworks, SQL libraries, and even basic string datatypes. Now consider the Cartesian product of those choices and all their mutual incompatibilities. That&#x27;s cognitive overload and nobody pays for analysis paralysis.<p>A stable engineering group with long-term projects can define a reference architecture and these problems are manageable. But consider large enterprise consulting, where I work. We routinely see unrelated new client projects, quickly assembled teams with non-intersecting skill sets, and arbitrary client technical constraints. Here, the idea of a repeatable, reference architecture doesn&#x27;t fit, and every new project suffered cognitive overload from Haskell&#x27;s big Cartesian product.<p>I really hoped Boring Haskell, Simple Haskell, and other pragmatic influences would prevail but Haskell has gone elsewhere. Those values are worth reconsidering, either in Haskell directly, or in a new and simpler language that puts those goals at center of its mission.</div><br/><div id="42520816" class="c"><input type="checkbox" id="c-42520816" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42518711">parent</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42520816">[-]</label><label class="expand" for="c-42520816">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! You seem to be mostly talking about cognitive load arising from having too many choices. Is that right?<p>(That said, I don&#x27;t understand what abandonware and a tiny community have to do with cognitive load -- I agree they&#x27;re bad, I just don&#x27;t see the connection to cognitive load.)<p>&gt; I really hoped Boring Haskell, Simple Haskell, and other pragmatic influences would prevail but Haskell has gone elsewhere. Those values are worth reconsidering<p>I agree with this, except the &quot;gone elsewhere&quot; part.  Haskell has far more pragmatic influences today than it did ten years ago when I started using it professionally.  The change is slow, but it is in the right direction.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42510672" class="c"><input type="checkbox" id="c-42510672" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42511484">prev</a><span>|</span><a href="#42510852">next</a><span>|</span><label class="collapse" for="c-42510672">[-]</label><label class="expand" for="c-42510672">[1 more]</label></div><br/><div class="children"><div class="content">Great points. I strongly agree with your first point. Regrettably, I haven&#x27;t used any language that solves this. (But believe it&#x27;s possible, and you&#x27;ve demonstrated with one I haven&#x27;t used).<p>I&#x27;m stuck between two lesser evils, not having the ideal solution you found:
1: Rust: Commits the sin  you say.
2: Python, Kotlin, C++ etc: Commits a worse sin: Prints lots of words.. (Varying degrees depending on which of these), where I may or may not be able to tell what&#x27;s wrong, and if I can, I have to pick it out of a text well.<p>Regarding boilerplate: This is one of the things I dislike most about rust. (As an example). I feel like prefixing`#[derive(Clone, Copy, PartialEq)]` on every (non-holding) enum is a flaw. Likewise, the way I use structs almost always results in prefixing each field with `pub`. (Other people use them in a different way, I believe, which doesn&#x27;t require this)</div><br/></div></div><div id="42510852" class="c"><input type="checkbox" id="c-42510852" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510672">prev</a><span>|</span><a href="#42510945">next</a><span>|</span><label class="collapse" for="c-42510852">[-]</label><label class="expand" for="c-42510852">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another red flag is boilerplate. By definition boilerplate is something that you have to type not because it&#x27;s required to specify the behavior of the code but simply because the language design demands it. Boilerplate is always unnecessary cognitive load, and it&#x27;s one sign of a badly designed language. (Yes, I&#x27;m looking at you, Java.)<p>The claim that LLMs are great for spitting out boilerplate has always sat wrong with me for this reason. They <i>are</i>, but could we not spend some of that research money on eliminating some of the need for boilerplate, rather than just making it faster to input?</div><br/></div></div><div id="42510945" class="c"><input type="checkbox" id="c-42510945" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510852">prev</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42510945">[-]</label><label class="expand" for="c-42510945">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Another red flag is boilerplate. By definition boilerplate is something that you have to type not because it&#x27;s required to specify the behavior of the code but simply because the language design demands it.<p>Two things: 1) this is often not language design but rather framework design, and 2) any semantic redundancy <i>in context</i> can be called boilerplate. Those same semantics may not be considered boilerplate in a different context.<p>And on the (Common) Lisp perspective—reading and writing lisp is arguably a unique skill that takes time and money to develop and brings much less value in return. I&#x27;m not fan of java from an <i>essentialist</i> perspective, but much of that cognitive load can be offset by IDEs, templates, lint tooling, etc etc. It has a role, particularly when you need to marshall a small army of coders very rapidly.</div><br/><div id="42511967" class="c"><input type="checkbox" id="c-42511967" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510945">parent</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42511967">[-]</label><label class="expand" for="c-42511967">[5 more]</label></div><br/><div class="children"><div class="content">If the world put even a tenth of the effort into training Lisp programmers as it does into training Java programmers you would have no trouble marshaling an army of Lisp programmers.</div><br/><div id="42513786" class="c"><input type="checkbox" id="c-42513786" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511967">parent</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42513786">[-]</label><label class="expand" for="c-42513786">[4 more]</label></div><br/><div class="children"><div class="content">The real problem is you cannot ever marshal an army of <i>cheap</i> Lisp programmers, because Lisp programming requires not only learning but raw ability. The big companies are searching for a language that any idiot can learn in a week, with the hope that they can hire thousands of them now, and fire them all next year when LLMs are slightly smarter.<p>They run into the problem that programming is inherently hard, and no amount of finagling with the language can change that, so you have to have <i>someone</i> on every team with actual talent. But the team can be made of <i>mostly</i> idiots, and <i>some</i> of them can be fired next year if LLMs keep improving.<p>If you use Lisp for everything, you can&#x27;t just hire any idiot. You have to be selective, and that costs money. And you won&#x27;t be able to fire them unless AGI is achieved.</div><br/><div id="42513849" class="c"><input type="checkbox" id="c-42513849" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513786">parent</a><span>|</span><a href="#42518572">next</a><span>|</span><label class="collapse" for="c-42513849">[-]</label><label class="expand" for="c-42513849">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you cannot ever marshal an army of cheap Lisp programmers<p>That may be, but since Lisp programmers are easily 10x as productive as ordinary mortals you can pay them, say, 5x as much and still get a pretty good ROI.<p>&gt; you can&#x27;t just hire any idiot<p>Yeah, well, if you think hiring any idiot is a winning strategy, far be it for me to stand in your way.</div><br/><div id="42517900" class="c"><input type="checkbox" id="c-42517900" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513849">parent</a><span>|</span><a href="#42518572">next</a><span>|</span><label class="collapse" for="c-42517900">[-]</label><label class="expand" for="c-42517900">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s a winning strategy, but I&#x27;m in no position to make hiring or programming-language decisions, and I don&#x27;t have the market insight that would be required to start my own company.</div><br/></div></div></div></div><div id="42518572" class="c"><input type="checkbox" id="c-42518572" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513786">parent</a><span>|</span><a href="#42513849">prev</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42518572">[-]</label><label class="expand" for="c-42518572">[1 more]</label></div><br/><div class="children"><div class="content">I would rather take on a lisp job that pays my bills than a Java job that pays my bills + upgrades my car</div><br/></div></div></div></div></div></div></div></div><div id="42510773" class="c"><input type="checkbox" id="c-42510773" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510945">prev</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42510773">[-]</label><label class="expand" for="c-42510773">[4 more]</label></div><br/><div class="children"><div class="content">Regarding Common Lisp, do you know of any articles that highlight the methods used to <i>&quot;change the syntax and add new constructs so that the language meets the problem and not the other way around.&quot;</i></div><br/><div id="42510946" class="c"><input type="checkbox" id="c-42510946" checked=""/><div class="controls bullet"><span class="by">webnrrd2k</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510773">parent</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42510946">[-]</label><label class="expand" for="c-42510946">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s talking about lisp macros, idempotent languages, and a few other features of lispey languages. I&#x27;d suggest the book On Lisp, or Lisp in Small Pieces as good places to learn about it, but there are a ton of other resources that may be better suited to your needs.</div><br/><div id="42510958" class="c"><input type="checkbox" id="c-42510958" checked=""/><div class="controls bullet"><span class="by">webnrrd2k</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510946">parent</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42510958">[-]</label><label class="expand" for="c-42510958">[2 more]</label></div><br/><div class="children"><div class="content">Also check out clojure, and the books: Norvig&#x27;s PAIP, or Graham&#x27;s ANSI Common Lisp.</div><br/><div id="42511082" class="c"><input type="checkbox" id="c-42511082" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510958">parent</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42511082">[-]</label><label class="expand" for="c-42511082">[1 more]</label></div><br/><div class="children"><div class="content">And don&#x27;t miss Sonja Keene&#x27;s book &quot;Object-Oriented Programming in Common Lisp&quot; and Kiczales&#x27; &quot;The Art of the Meta-Object Protocol&quot;. If you don&#x27;t reach enlightenment after those, Libgen will refund your money.</div><br/></div></div></div></div></div></div></div></div><div id="42511126" class="c"><input type="checkbox" id="c-42511126" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510773">prev</a><span>|</span><a href="#42513116">next</a><span>|</span><label class="collapse" for="c-42511126">[-]</label><label class="expand" for="c-42511126">[3 more]</label></div><br/><div class="children"><div class="content">My gripe with the post is that there is no objective &quot;cognitive load&quot; solution. Arguably this varies from 1 person to another.</div><br/><div id="42511532" class="c"><input type="checkbox" id="c-42511532" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511126">parent</a><span>|</span><a href="#42512656">next</a><span>|</span><label class="collapse" for="c-42511532">[-]</label><label class="expand" for="c-42511532">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can have golden rules, if you do, you fall in the usual don&#x27;t do X, or limit Y to Z lines, etc.<p>But what you _can_ do is to ask yourself whether you&#x27;re adding or removing cognitive load as you work and seek feedback from (possibly junior) coworkers.</div><br/></div></div><div id="42512656" class="c"><input type="checkbox" id="c-42512656" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511126">parent</a><span>|</span><a href="#42511532">prev</a><span>|</span><a href="#42513116">next</a><span>|</span><label class="collapse" for="c-42512656">[-]</label><label class="expand" for="c-42512656">[1 more]</label></div><br/><div class="children"><div class="content">This is true for exactly the same reason that no one algorithm compresses all types of data equally well.</div><br/></div></div></div></div><div id="42513116" class="c"><input type="checkbox" id="c-42513116" checked=""/><div class="controls bullet"><span class="by">isodev</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42511126">prev</a><span>|</span><a href="#42510952">next</a><span>|</span><label class="collapse" for="c-42513116">[-]</label><label class="expand" for="c-42513116">[1 more]</label></div><br/><div class="children"><div class="content">&gt; poor language design<p>We have an excellent modern-day example with Swift - it managed to grow from a simple and effective tool for building apps, to a “designed by committee” monstrosity that requires months to get into.</div><br/></div></div><div id="42510952" class="c"><input type="checkbox" id="c-42510952" checked=""/><div class="controls bullet"><span class="by">frenchslumber</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42513116">prev</a><span>|</span><a href="#42510989">next</a><span>|</span><label class="collapse" for="c-42510952">[-]</label><label class="expand" for="c-42510952">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree! Common Lisp is truly the tool of the Gods.</div><br/></div></div><div id="42510989" class="c"><input type="checkbox" id="c-42510989" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510952">prev</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42510989">[-]</label><label class="expand" for="c-42510989">[4 more]</label></div><br/><div class="children"><div class="content">The criticisms of Java syntax are somewhat fair, but it&#x27;s important to understand the historical context. It was first designed in 1995 and intended to be an easy transition for C++ programmers (minimal cognitive load). In an alternate history where James Gosling and his colleagues designed Java &quot;better&quot; then it would have never been widely adopted and ended up as a mere curiosity like Common Lisp is today. Sometimes you have to meet your customers where they are.<p>It has taken a few decades but the latest version significantly reduces the boilerplate.</div><br/><div id="42511975" class="c"><input type="checkbox" id="c-42511975" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510989">parent</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42511975">[-]</label><label class="expand" for="c-42511975">[3 more]</label></div><br/><div class="children"><div class="content">Sure.  I understand why things are the way they are.  But that I don&#x27;t think that is a reason not to complain about the way things are.  Improvement is always the product of discontent.</div><br/><div id="42512191" class="c"><input type="checkbox" id="c-42512191" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511975">parent</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42512191">[-]</label><label class="expand" for="c-42512191">[2 more]</label></div><br/><div class="children"><div class="content">Improvement is always the product of submitting a JEP or JSR.<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;0" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;0</a><p><a href="https:&#x2F;&#x2F;jcp.org&#x2F;en&#x2F;jsr&#x2F;overview" rel="nofollow">https:&#x2F;&#x2F;jcp.org&#x2F;en&#x2F;jsr&#x2F;overview</a></div><br/><div id="42517904" class="c"><input type="checkbox" id="c-42517904" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42512191">parent</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42517904">[-]</label><label class="expand" for="c-42517904">[1 more]</label></div><br/><div class="children"><div class="content">The more you contribute to Java, the bigger the problem gets. Java will never die if people keep feeding it, and it&#x27;ll never be a good language, because that&#x27;s impossible.</div><br/></div></div></div></div></div></div></div></div><div id="42510734" class="c"><input type="checkbox" id="c-42510734" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510989">prev</a><span>|</span><a href="#42511343">next</a><span>|</span><label class="collapse" for="c-42510734">[-]</label><label class="expand" for="c-42510734">[2 more]</label></div><br/><div class="children"><div class="content">I agree up until the end. Languages that let you change the syntax can result in stuff where every program is written in its own DSL. Ruby has this issue to some extent.</div><br/><div id="42511556" class="c"><input type="checkbox" id="c-42511556" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510734">parent</a><span>|</span><a href="#42511343">next</a><span>|</span><label class="collapse" for="c-42511556">[-]</label><label class="expand" for="c-42511556">[1 more]</label></div><br/><div class="children"><div class="content">Sure, changing the syntax is not something to be done lightly.  It has to be done judiciously and with great care.  But it can be a huge win in some cases.  For example, take a look at:<p><a href="https:&#x2F;&#x2F;flownet.com&#x2F;gat&#x2F;lisp&#x2F;djbec.lisp" rel="nofollow">https:&#x2F;&#x2F;flownet.com&#x2F;gat&#x2F;lisp&#x2F;djbec.lisp</a><p>It implements elliptic curve cryptography in Common Lisp using an embedded infix syntax.</div><br/></div></div></div></div><div id="42511343" class="c"><input type="checkbox" id="c-42511343" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510734">prev</a><span>|</span><a href="#42511129">next</a><span>|</span><label class="collapse" for="c-42511343">[-]</label><label class="expand" for="c-42511343">[3 more]</label></div><br/><div class="children"><div class="content">You can reduce your Java boilerplate to annotations or succinct XML or whatever. Code generation is used a lot on the JVM.<p>Can you show a real compiler message about such a semicolon?</div><br/><div id="42511923" class="c"><input type="checkbox" id="c-42511923" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511343">parent</a><span>|</span><a href="#42511129">next</a><span>|</span><label class="collapse" for="c-42511923">[-]</label><label class="expand" for="c-42511923">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    % cat test.c
    main () {
      int x
      x=1
    }
    % gcc test.c  
    test.c:1:1: warning: type specifier missing, defaults to &#x27;int&#x27; [-Wimplicit-int]
    main () {
    ^
    test.c:2:8: error: expected &#x27;;&#x27; at end of declaration
      int x
           ^
           ;
    1 warning and 1 error generated.</code></pre></div><br/><div id="42514167" class="c"><input type="checkbox" id="c-42514167" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511923">parent</a><span>|</span><a href="#42511129">next</a><span>|</span><label class="collapse" for="c-42514167">[-]</label><label class="expand" for="c-42514167">[1 more]</label></div><br/><div class="children"><div class="content">I added int to the main declaration to clean the irrelevant warning, and I get this:<p><pre><code>   tst.c: In function ‘main’:
   tst.c:3:5: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘x’
       3 |     x=1
         |     ^
   tst.c:3:5: error: ‘x’ undeclared (first use in this function)
   tst.c:3:5: note: each undeclared identifier is reported only once for each function it appears in
   tst.c:3:8: error: expected ‘;’ before ‘}’ token
       3 |     x=1
         |        ^
         |        ;
       4 | }
         | ~       
</code></pre>
gcc (Debian 12.2.0-14) 12.2.0<p>I get three errors, all on line 3 rather than 2, and as the first of them says, there are at least four alternatives for resolution besides semicolon.<p>Full code after adding type to main, including linter message from c.vim:<p><pre><code>         1 int main () {                                                                        
         2     int x                                                                            
     E   3     x=1 &#x2F;\* E: &#x27;x&#x27; undeclared (first use in this function)                            
         4 }

.</code></pre></div><br/></div></div></div></div></div></div><div id="42511129" class="c"><input type="checkbox" id="c-42511129" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42511343">prev</a><span>|</span><a href="#42510834">next</a><span>|</span><label class="collapse" for="c-42511129">[-]</label><label class="expand" for="c-42511129">[3 more]</label></div><br/><div class="children"><div class="content">So with semi-colons, you have three basic options:<p>1. Not required (eg Python, Go)<p>2. Required (eg C&#x2F;C++, Java)<p>3. Optional (eg Javascript)<p>For me, (3) is by far the worst option. To me, the whole ASI debate is so ridiculous. To get away with (1), the languages make restrictions on syntax, most of which I think are acceptable. For example, Java&#x2F;C&#x2F;C++ allow you to put multiple statements on a single line. Do you need that? Probably not. I can&#x27;t even think of an example where that&#x27;s useful&#x2F;helpful.<p>&quot;Boilerplate&quot; becomes a matter of debate. It&#x27;s a common criticism with Java, for example (eg anonymous classes). I personally think with modern IDEs it&#x27;s really a very minor issue.<p>But some languages make, say, the return statement optional. I actually don&#x27;t like this. I like a return being explicit and clear in the code. Some will argue the return statement is boilerplate.<p>Also, explicit type declarations can be viewed as boilerplate.. There are levels to this. C++&#x27;s auto is one-level. So are &quot;var&quot; declarations. Java is more restrictive than this (eg &lt;&gt; for implied types to avoid repeating types in a single declaration). But is this boilerplate?<p>Common Lisp is where you lose me. Like the meme goes, if CL was a good idea it would&#x27;ve caught on at some point in the last 60 years. Redefning the language seems like a recipe for disaster, or at least adding a bunch of cognitive load because you can&#x27;t trust that &quot;standard&quot; functions aren&#x27;t doing standard things.<p>Someone once said they like in Java that they&#x27;re never surprised by 100 lines of code of Java. Unlike CL, there&#x27;s never a parser or an interpreter hidden in there. Now that&#x27;s a testament to CL&#x27;s power for sure. But this kind of power just isn&#x27;t conducive to maintainable code.</div><br/><div id="42518766" class="c"><input type="checkbox" id="c-42518766" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511129">parent</a><span>|</span><a href="#42511536">next</a><span>|</span><label class="collapse" for="c-42518766">[-]</label><label class="expand" for="c-42518766">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unlike CL, there&#x27;s never a parser or an interpreter hidden in there<p>Ive never ever run into this problem in the years of writing common lisp. Can you show me an example code that has this? I wager you cannot and you are writing poopoo about something you know poo about and want it to be true just because you are too lazy to move beyond knowing poo<p>&gt; But this kind of power just isn&#x27;t conducive to maintainable code.<p>I can usually run code decades old in common lisp. In fact this is one of its well known features. How much more maintainable can it possibly get :)</div><br/></div></div><div id="42511536" class="c"><input type="checkbox" id="c-42511536" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511129">parent</a><span>|</span><a href="#42518766">prev</a><span>|</span><a href="#42510834">next</a><span>|</span><label class="collapse" for="c-42511536">[-]</label><label class="expand" for="c-42511536">[1 more]</label></div><br/><div class="children"><div class="content">I like (3) to be honest and the number of times it has poised any issue is virtually 0.</div><br/></div></div></div></div></div></div><div id="42510834" class="c"><input type="checkbox" id="c-42510834" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42510521">prev</a><span>|</span><a href="#42511031">next</a><span>|</span><label class="collapse" for="c-42510834">[-]</label><label class="expand" for="c-42510834">[1 more]</label></div><br/><div class="children"><div class="content">Composition over inheritance is one of the most valuable lessons I learned earlier in my career as a developer. In fact these days, I&#x27;m hard-pressed to think of a case in which I would prefer inheritance as my first choice to model <i>any</i> problem. I&#x27;m sure there probably are some, but it feels too easy to wield irresponsibly and let bad design creep in.<p>At a previous job I had, a fairly important bit of code made use of a number of class hierarchies each five or six layers deep, including the massive code smell&#x2F;design failure of certain layers stubbing out methods on a parent class due to irrelevancy.<p>To make matters worse, at the point of use often only the base&#x2F;abstract types were referenced, so even working out what code was running basically required stepping through in a debugger if you didn&#x27;t want to end up like the meme of Charlie from Always Sunny. And of course, testing was a nightmare because everything happened internally to the classes, so you would end up extending them even further in tests just to stub&#x2F;mock bits you needed to control.</div><br/></div></div><div id="42511031" class="c"><input type="checkbox" id="c-42511031" checked=""/><div class="controls bullet"><span class="by">svilen_dobrev</span><span>|</span><a href="#42510834">prev</a><span>|</span><a href="#42510700">next</a><span>|</span><label class="collapse" for="c-42511031">[-]</label><label class="expand" for="c-42511031">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Involve junior developers in architecture reviews. They will help you to identify the mentally demanding areas.<p>This.<p>And also, a mantra of my own: Listen <i>carefully</i> to any newcomer in the team&#x2F;company in first 1-3 weeks, until s&#x2F;he gets accustomed (and&#x2F;or stop paying attention to somewhat uneasy stuff). They will tell you all things that are, if not wrong, at least weird.</div><br/><div id="42511570" class="c"><input type="checkbox" id="c-42511570" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42511031">parent</a><span>|</span><a href="#42511045">next</a><span>|</span><label class="collapse" for="c-42511570">[-]</label><label class="expand" for="c-42511570">[1 more]</label></div><br/><div class="children"><div class="content">I second this, but one should also be extremely wary of newcomers feedback and try to understand their nature.<p>Some people are extremely resistant to new ideas, some might be simply lazy, some can&#x27;t be bothered to read documentations, etc.<p>Spotting the real person behind the feedback is crucial and often those people need to be fired fast.<p>I myself tend to be lazy when it comes to learn new stuff&#x2F;patterns, especially when I am in the middle of having to progress a project so my own feedback may be more of a frustration for my inability to progress due to having to understand first a, b, c and d which may take considerable time and pain for something I can do in an old way in few minutes.</div><br/></div></div><div id="42511045" class="c"><input type="checkbox" id="c-42511045" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#42511031">parent</a><span>|</span><a href="#42511570">prev</a><span>|</span><a href="#42511352">next</a><span>|</span><label class="collapse" for="c-42511045">[-]</label><label class="expand" for="c-42511045">[2 more]</label></div><br/><div class="children"><div class="content">Junior developers probably won&#x27;t say anything, because they are used to not understanding code, and they are not going to second guess the more-experienced author.</div><br/><div id="42511059" class="c"><input type="checkbox" id="c-42511059" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#42511031">root</a><span>|</span><a href="#42511045">parent</a><span>|</span><a href="#42511352">next</a><span>|</span><label class="collapse" for="c-42511059">[-]</label><label class="expand" for="c-42511059">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely on the senior to prompt the junior appropriately. But when you do, they will.</div><br/></div></div></div></div><div id="42511352" class="c"><input type="checkbox" id="c-42511352" checked=""/><div class="controls bullet"><span class="by">ben_w</span><span>|</span><a href="#42511031">parent</a><span>|</span><a href="#42511045">prev</a><span>|</span><a href="#42510700">next</a><span>|</span><label class="collapse" for="c-42511352">[-]</label><label class="expand" for="c-42511352">[1 more]</label></div><br/><div class="children"><div class="content">Aye, but the joiners may need prompting as well as getting listened to.<p>In each place where I&#x27;ve seen something wildly wrong, the problem has been clear in the first few weeks — sometimes even in the first few days* — but I always start with the assumption that if I disagree with someone who has been at it for years, they&#x27;ve probably got good reasons for the stuff that surprises me.<p>Unfortunately I&#x27;m not very convincing: when I do finally feel confident enough to raise stuff, quite often they do indeed have reasons… bad reasons that ultimately prove to be fatal or near-fatal flaws to their business plans, but the issues only seldom get fixed once I raise them.<p>* one case where the problem was visible in the interview, but I was too young and naive so I disregarded what I witnessed, and I regretted it.</div><br/></div></div></div></div><div id="42510700" class="c"><input type="checkbox" id="c-42510700" checked=""/><div class="controls bullet"><span class="by">hn8726</span><span>|</span><a href="#42511031">prev</a><span>|</span><a href="#42515911">next</a><span>|</span><label class="collapse" for="c-42510700">[-]</label><label class="expand" for="c-42510700">[5 more]</label></div><br/><div class="children"><div class="content">I agree with vast majority of the post, and it matches my experience. What I&#x27;m not sure I follow is the part about layered architecture, and what is offered as an alternative. The author quickly gets to a _conclusion_ that<p>&gt; So, why pay the price of high cognitive load for such a layered architecture, if it doesn&#x27;t pay off in the future?<p>where one of the examples is<p>&gt; If you think that such layering will allow you to quickly replace a database or other dependencies, you&#x27;re mistaken. Changing the storage causes lots of problems, and believe us, having some abstractions for the data access layer is the least of your worries.<p>but in my experience, it&#x27;s crucial to abstract away — even if the interface is not ideal — external dependencies. The point is not to be able to &quot;replace a database&quot;, but to _own_ the interface that is used by the application. Maybe the author only means _unnecessary layering_, but the way the argument is framed seems like using external dependency APIs throughout the entire app is somehow better.</div><br/><div id="42517026" class="c"><input type="checkbox" id="c-42517026" checked=""/><div class="controls bullet"><span class="by">o_nate</span><span>|</span><a href="#42510700">parent</a><span>|</span><a href="#42510887">next</a><span>|</span><label class="collapse" for="c-42517026">[-]</label><label class="expand" for="c-42517026">[1 more]</label></div><br/><div class="children"><div class="content">If you feel like you are missing key parts of the argument, like I was, it might help to switch the view from &quot;short&quot; to &quot;long&quot; - there&#x27;s a little slider on the right hand side of the screen. This adds in some paragraphs that help the piece flow better. (I&#x27;d never seen a blog post with this feature before.)</div><br/></div></div><div id="42510887" class="c"><input type="checkbox" id="c-42510887" checked=""/><div class="controls bullet"><span class="by">master_crab</span><span>|</span><a href="#42510700">parent</a><span>|</span><a href="#42517026">prev</a><span>|</span><a href="#42517180">next</a><span>|</span><label class="collapse" for="c-42510887">[-]</label><label class="expand" for="c-42510887">[1 more]</label></div><br/><div class="children"><div class="content">I commented on this in another thread here.<p>What I read it as is don’t over-index on creating separate layers&#x2F;services if they are already highly dependent on each other. It just adds additional complexity tracing dependencies over the networking stack, databases&#x2F;datastores, etc that the services are now split across.<p>In other words: a monolithic design is acceptable if the services are highly intertwined and dependent.</div><br/></div></div><div id="42517180" class="c"><input type="checkbox" id="c-42517180" checked=""/><div class="controls bullet"><span class="by">nogridbag</span><span>|</span><a href="#42510700">parent</a><span>|</span><a href="#42510887">prev</a><span>|</span><a href="#42511371">next</a><span>|</span><label class="collapse" for="c-42517180">[-]</label><label class="expand" for="c-42517180">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I find this part of the article weird as it has contracting statements:<p>&gt; No port&#x2F;adapter terms to learn<p>and<p>&gt; we gave it all up in favour of the good old dependency inversion principle<p>Both use interfaces, just in different ways. We use hexagonal (ports and adapters) pattern in my project. If you asked anyone on my team to define hexagonal architecture they&#x27;ll have no idea what you&#x27;re talking about. They just follow the project coding patterns. There&#x27;s no additional complexity.<p>&gt; If you think that such layering will allow you to quickly replace a database or other dependencies, you&#x27;re mistaken<p>I think most people do not stay at companies long enough to see the price of not abstracting away these things. That&#x27;s the next developer&#x27;s problem. The code tends to be tightly coupled to the libraries and frameworks used. Eventually, the projects dependencies have to be upgraded (usually due to security issues) and the migrations are usually incredibly difficult, expensive, and fragile. The product&#x27;s business logic is tightly coupled with the framework and libraries used at the time. Even if the company realizes that framework has no future, they&#x27;re kind of locked into their initial decision made a decade ago. At least, that&#x27;s been my experience.<p>We have two major products at my company. Both started with the same initial framework, but the project I architected that used hexagonal was migrated to a faster and more modern framework within 4 weeks. The other product had a multi-year migration to a newer version of the same framework (and by the time it was completed is already two major versions outdated). Both products are similar in scale and code size.</div><br/></div></div><div id="42511371" class="c"><input type="checkbox" id="c-42511371" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42510700">parent</a><span>|</span><a href="#42517180">prev</a><span>|</span><a href="#42515911">next</a><span>|</span><label class="collapse" for="c-42511371">[-]</label><label class="expand" for="c-42511371">[1 more]</label></div><br/><div class="children"><div class="content">I think the &#x27;Layered Architecture&#x27; section is all over the place.<p>There are a lot of terms thrown around with pretty loose definitions - in this article and others.  I had to look up &quot;layered architecture&quot; to see what other people wrote about it, and it looks like an anti-pattern to me:<p><pre><code>  In a four-layered architecture, the layers are typically divided into:
    Presentation
    Application
    Domain
    Infrastructure

  These layers are arranged in a hierarchical order, where each layer provides services to the layer above it and uses services from the layer below it, and each layer is responsible for handling specific tasks and has limited communication with the other layers. [1]
</code></pre>
It looks like an anti-pattern to be because, as described, each layer <i>depends</i> on the one below it.  It looks like how you&#x27;d define the &quot;dependency non-inversion&quot; principle.  <i>Domain</i> depends on <i>Infrastructure</i>?  A BankBalance is going to depend on MySQL?  Even if you put the DB behind an interface, the direction of dependencies is still wrong: BankBalace-&gt;IDatabase.<p>Back to TFA:<p>&gt; In the end, we gave it all up in favour of the good old dependency inversion principle.<p>OK.  DIP is terrific.<p>&gt; No port&#x2F;adapter terms to learn<p>There is a big overlap between ports&#x2F;adapters, hexagonal, and DIP:<p><pre><code>  Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases. [2]
</code></pre>
That is, the Domain (&quot;application&quot;) is at the bottom of the dependency graph, so that the Infrastructure {Programs, Tests, Scripts} can depend upon it.<p>&gt; If you think that such layering will allow you to quickly replace a database or other dependencies, you&#x27;re mistaken.<p><i>Layering</i> will not help - it will hinder, as I described above.  But you should be able to quickly replace any dependency you like, which is what DIP&#x2F;PortsAdapters&#x2F;Hexagonal gives you.<p>&gt; Changing the storage causes lots of problems, and believe us, having some abstractions for the data access layer is the least of your worries. At best, abstractions can save somewhat 10% of your migration time (if any)<p>I iterate on my application code without spinning up a particular database.  Same with my unit tests.  Well worth it.<p>[1] <a href="https:&#x2F;&#x2F;bitloops.com&#x2F;docs&#x2F;bitloops-language&#x2F;learning&#x2F;software-architecture&#x2F;layered-architecture" rel="nofollow">https:&#x2F;&#x2F;bitloops.com&#x2F;docs&#x2F;bitloops-language&#x2F;learning&#x2F;softwar...</a>
[2] <a href="https:&#x2F;&#x2F;alistair.cockburn.us&#x2F;hexagonal-architecture&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alistair.cockburn.us&#x2F;hexagonal-architecture&#x2F;</a></div><br/></div></div></div></div><div id="42515911" class="c"><input type="checkbox" id="c-42515911" checked=""/><div class="controls bullet"><span class="by">wnmurphy</span><span>|</span><a href="#42510700">prev</a><span>|</span><a href="#42510412">next</a><span>|</span><label class="collapse" for="c-42515911">[-]</label><label class="expand" for="c-42515911">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Introduce intermediate variables with meaningful names<p>Abstracting chunks of compound conditionals into easy-to-read variables is one of my favorite techniques. Underrated.<p>&gt; isValid = val &gt; someConstant<p>&gt; isAllowed = condition2 || condition3<p>&gt; isSecure = condition4 &amp;&amp; !condition5<p>&gt; if isValid &amp;&amp; isAllowed &amp;&amp; isSecure { &#x2F;&#x2F;...</div><br/><div id="42515938" class="c"><input type="checkbox" id="c-42515938" checked=""/><div class="controls bullet"><span class="by">goalieca</span><span>|</span><a href="#42515911">parent</a><span>|</span><a href="#42516764">next</a><span>|</span><label class="collapse" for="c-42515938">[-]</label><label class="expand" for="c-42515938">[1 more]</label></div><br/><div class="children"><div class="content">I treat it a lot like english. Run-on sentences, too much technical jargon, and too many fragmented short sentences all make it harder to read. There&#x27;s analogies to writing code.</div><br/></div></div><div id="42516764" class="c"><input type="checkbox" id="c-42516764" checked=""/><div class="controls bullet"><span class="by">RaftPeople</span><span>|</span><a href="#42515911">parent</a><span>|</span><a href="#42515938">prev</a><span>|</span><a href="#42520190">next</a><span>|</span><label class="collapse" for="c-42516764">[-]</label><label class="expand" for="c-42516764">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Abstracting chunks of compound conditionals into easy-to-read variables is one of my favorite techniques. Underrated.</i><p>Same.  Or alternatively I will just put the English version in comments above each portion of the conditional, makes it easy to read and understand.</div><br/></div></div><div id="42520190" class="c"><input type="checkbox" id="c-42520190" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#42515911">parent</a><span>|</span><a href="#42516764">prev</a><span>|</span><a href="#42510412">next</a><span>|</span><label class="collapse" for="c-42520190">[-]</label><label class="expand" for="c-42520190">[1 more]</label></div><br/><div class="children"><div class="content">So you like procedural code.<p>I mean, at least western people seem to think in recipes, todo lists, or numbered instructions. Which is what procedural code is.<p>Dogma will chop up those blocks into sometimes a dozen functions, and that&#x27;s in stuff like Java, functional is even worse for &quot;function misdirection &#x2F; short term memory overload&quot;.<p>I don&#x27;t really mind the hundred line method if that thing is doing the real meat of the work. I find stepping through code to be helpful, and those types of methods&#x2F;functions&#x2F;code are easy to track.  Lots of functions? You have to set breakpoints or step into the functions, and who knows if you are stepping into a library function or a code-relevant function.<p>Of course a thousand line method may be a bit much too, but the dogma for a long time was &quot;more than ten lines? subdivide into more functions&quot; which was always weird to me.</div><br/></div></div></div></div><div id="42510412" class="c"><input type="checkbox" id="c-42510412" checked=""/><div class="controls bullet"><span class="by">ScotterC</span><span>|</span><a href="#42515911">prev</a><span>|</span><a href="#42515438">next</a><span>|</span><label class="collapse" for="c-42510412">[-]</label><label class="expand" for="c-42510412">[4 more]</label></div><br/><div class="children"><div class="content">Looks like a solid post with solid learnings. Apologies for hijacking the thread but I’d really love to have a discussion on how these heuristics of software development change with the likes of Cursor&#x2F;LLM cyborg coding in the mix.<p>I’ve done an extensive amount of LLM assisted coding and our heuristics need to change. Synthesis of a design still needs to be low cognitive load - e.g. how data flows between multiple modules - because you need to be able to verify the actual system or that the LLM suggestion matches the intended mental model. However, striving for simplicity inside a method&#x2F;function matters way less. It’s relatively easy to verify that an LLM generated unit test is working as intended and the complexity of the code within the function doesn’t matter if its scope is sufficiently narrow.<p>IMO identifying the line between locations where “low cognitive load required” vs “low cognitive load is unnecessary” changes the game of software development and is not often discussed.</div><br/><div id="42510869" class="c"><input type="checkbox" id="c-42510869" checked=""/><div class="controls bullet"><span class="by">codespin</span><span>|</span><a href="#42510412">parent</a><span>|</span><a href="#42512842">next</a><span>|</span><label class="collapse" for="c-42510869">[-]</label><label class="expand" for="c-42510869">[2 more]</label></div><br/><div class="children"><div class="content">With LLM generated code (and any code really) the interface between components becomes much more important. It needs to be clearly defined so that it can be tested and avoid implicit features that could go away if it were re-generated.<p>Only when you know for sure the problem can&#x27;t be coming through from that component can you stop thinking about it and reduce the cognitive load.</div><br/><div id="42512929" class="c"><input type="checkbox" id="c-42512929" checked=""/><div class="controls bullet"><span class="by">ScotterC</span><span>|</span><a href="#42510412">root</a><span>|</span><a href="#42510869">parent</a><span>|</span><a href="#42512842">next</a><span>|</span><label class="collapse" for="c-42512929">[-]</label><label class="expand" for="c-42512929">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>Regarding some of the ‘layered architecture’ discussion from the OP, I’d argue that having many modules that are clearly defined is not as large a detriment to cognitive load when an LLM is interpreting it. This is dependent on two factors, each module being clearly defined enough that you can be confident the problem lies within the interactions between modules&#x2F;components and not within them AND sharing proper&#x2F;sufficient context with an LLM so that it is focused on the interactions between components so that it doesn’t try to force fit a solution into one of them or miss the problem space entirely.<p>The latter is a constant nagging issue but the former is completely doable (types and unit testing helps) but flies in the face of the mo’ files, mo’ problems issue that creates higher cognitive loads for humans.</div><br/></div></div></div></div><div id="42512842" class="c"><input type="checkbox" id="c-42512842" checked=""/><div class="controls bullet"><span class="by">tkgally</span><span>|</span><a href="#42510412">parent</a><span>|</span><a href="#42510869">prev</a><span>|</span><a href="#42515438">next</a><span>|</span><label class="collapse" for="c-42512842">[-]</label><label class="expand" for="c-42512842">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’d really love to have a discussion on how these heuristics of software development change with the likes of Cursor&#x2F;LLM cyborg coding in the mix<p>I would also be interested in reading people’s thoughts about how those heuristics might change in the months and years ahead, as reasoning LLMs get more powerful and as context windows continue to increase. Even if it never becomes possible to offload software development completely to AI, it does seem at least possible that human cognitive load will not be an issue in the same way it is now.</div><br/></div></div></div></div><div id="42515438" class="c"><input type="checkbox" id="c-42515438" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42510412">prev</a><span>|</span><a href="#42519615">next</a><span>|</span><label class="collapse" for="c-42515438">[-]</label><label class="expand" for="c-42515438">[1 more]</label></div><br/><div class="children"><div class="content">A more formal look at this is Ousterhout&#x27;s _A Philosophy of Software Design_<p>which has been specifically discussed extensively here:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27686818">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27686818</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37975558">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37975558</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31248641">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31248641</a><p>including more peripherally:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34733120">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34733120</a></div><br/></div></div><div id="42519615" class="c"><input type="checkbox" id="c-42519615" checked=""/><div class="controls bullet"><span class="by">MiscCompFacts</span><span>|</span><a href="#42515438">prev</a><span>|</span><a href="#42510561">next</a><span>|</span><label class="collapse" for="c-42519615">[-]</label><label class="expand" for="c-42519615">[2 more]</label></div><br/><div class="children"><div class="content">I really enjoyed this post quite abit, and it’s a topic that I and many developers have discussed concerning good abstractions. This isn’t directly related to the article it’s self, but to the website minds.md. I was surprised to see it seems like a blogging platform for various authors but I didn’t see any information about where to upload or who runs this service. It mentions GitHub but doesn’t seem to link to it on the home page. Just curious to know more about this site and if it’s for anyone or a specific group of people?</div><br/><div id="42519809" class="c"><input type="checkbox" id="c-42519809" checked=""/><div class="controls bullet"><span class="by">adr1an</span><span>|</span><a href="#42519615">parent</a><span>|</span><a href="#42510561">next</a><span>|</span><label class="collapse" for="c-42519809">[-]</label><label class="expand" for="c-42519809">[1 more]</label></div><br/><div class="children"><div class="content">I believe it&#x27;s specific to a group of people, since the site has 3 posts. Yet, this post is a living document awaiting contributions (or so it claims), <a href="https:&#x2F;&#x2F;github.com&#x2F;zakirullin&#x2F;cognitive-load">https:&#x2F;&#x2F;github.com&#x2F;zakirullin&#x2F;cognitive-load</a></div><br/></div></div></div></div><div id="42510561" class="c"><input type="checkbox" id="c-42510561" checked=""/><div class="controls bullet"><span class="by">vonnik</span><span>|</span><a href="#42519615">prev</a><span>|</span><a href="#42511605">next</a><span>|</span><label class="collapse" for="c-42510561">[-]</label><label class="expand" for="c-42510561">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree with this and would add that cognitive load is not just a matter of the code before you, but a function of your total digital environment:<p><a href="https:&#x2F;&#x2F;vonnik.substack.com&#x2F;p&#x2F;how-to-take-your-brain-back" rel="nofollow">https:&#x2F;&#x2F;vonnik.substack.com&#x2F;p&#x2F;how-to-take-your-brain-back</a><p>Interruptions and distractions leave a cognitive residue that drastically reduces working memory through the Zeigarnik effect.</div><br/></div></div><div id="42511605" class="c"><input type="checkbox" id="c-42511605" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42510561">prev</a><span>|</span><a href="#42513161">next</a><span>|</span><label class="collapse" for="c-42511605">[-]</label><label class="expand" for="c-42511605">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Layered architecture: Abstraction is supposed to hide complexity, here it just adds indirection<p>Agree with everything except this. As someone who deals with workflows and complex business domains, separating your technical concerns from your core domain is not only necessary. They are a key means to survival.<p>Once you have 3 different input-channels and 5 external systems you need to call, you absolutely need to keep your distance not to pollute your core representation of the actual problem you need to solve.</div><br/><div id="42515447" class="c"><input type="checkbox" id="c-42515447" checked=""/><div class="controls bullet"><span class="by">ImPleadThe5th</span><span>|</span><a href="#42511605">parent</a><span>|</span><a href="#42513161">next</a><span>|</span><label class="collapse" for="c-42515447">[-]</label><label class="expand" for="c-42515447">[1 more]</label></div><br/><div class="children"><div class="content">As with all things, it&#x27;s useful used properly.<p>The codebase at my job has far too many abstractions&#x2F;layers for things that do not provide any benefit for being abstract. It was simply done because it was the &quot;coderly&quot; thing to do.<p>I do agree that at the least it makes sense to separate out repository logic.</div><br/></div></div></div></div><div id="42513161" class="c"><input type="checkbox" id="c-42513161" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#42511605">prev</a><span>|</span><a href="#42511469">next</a><span>|</span><label class="collapse" for="c-42513161">[-]</label><label class="expand" for="c-42513161">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the author&#x27;s point. It was the founding principle of &quot;object oriented&quot; programming in that once the object was a black box, you could just rely on it working and let go of the implementation details. But it is also important in day to day work. I remember when I realized that I could only keep six distinct &quot;disasters&quot; in my head at the same time. Trying to add another one would pop one out of my head. So much of life can be simplified if you systematize things so that the thing to remember is small, like all of the stuff you take on business trips (shave kit, travel charger, noise cancelling headphones, whatever) if you put all of it in a box in your closet labelled &quot;travel kit&quot; then you only have to remember three things, outfits for &#x27;n&#x27; days, your laptop, and your travel kit. Got those three and you are good to go.</div><br/></div></div><div id="42511469" class="c"><input type="checkbox" id="c-42511469" checked=""/><div class="controls bullet"><span class="by">jeremydeanlakey</span><span>|</span><a href="#42513161">prev</a><span>|</span><a href="#42515328">next</a><span>|</span><label class="collapse" for="c-42511469">[-]</label><label class="expand" for="c-42511469">[3 more]</label></div><br/><div class="children"><div class="content">The central idea around cognitive load is very good, central to writing good code.<p>But it&#x27;s deeply mistaken to oppose smaller (or more correctly: simpler) classes&#x2F;functions and layered architecture.<p>Layered architecture and simple (mostly small) classes and methods are critical to light cognitive load.<p>e.g. You should not be handling database functionality in your service classes, nor should you be doing business logic in your controllers.  These different kinds of logic are very different, require different kinds of knowledge.  Combining them _increases_ cognitive load, not decreases.<p>It&#x27;s not mainly about swapping out dependencies (although this is an important benefit), it&#x27;s about doing one thing at a time.</div><br/><div id="42514096" class="c"><input type="checkbox" id="c-42514096" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#42511469">parent</a><span>|</span><a href="#42511607">next</a><span>|</span><label class="collapse" for="c-42514096">[-]</label><label class="expand" for="c-42514096">[1 more]</label></div><br/><div class="children"><div class="content">There are some nice studies on correlations between metrics (cohesiveness, coupling, complexity, levels of indirection, etc.) and maintainability. Basically anything that scores poorly is inherently hard to understand because it induces a high cognitive load.<p>The reason what you outline is bad is because they each impact these metrics. Bypassing layers creates a more tight coupling: you are basically putting code in the wrong place. This also makes the code less coherent. The two go hand in hand. And then you end up doing complex things like reaching deep into layers (which violates Demeter&#x27;s law).<p>Anyway, MVC style architectures have always had the problem that they invite people to mix viewer and controller code and logic. And once your business logic mixes with your rendering logic, your code is well on its way of becoming yet another UI project that fell into the trap of tight coupling, low cohesiveness, and high complexity.</div><br/></div></div><div id="42511607" class="c"><input type="checkbox" id="c-42511607" checked=""/><div class="controls bullet"><span class="by">jeremydeanlakey</span><span>|</span><a href="#42511469">parent</a><span>|</span><a href="#42514096">prev</a><span>|</span><a href="#42515328">next</a><span>|</span><label class="collapse" for="c-42511607">[-]</label><label class="expand" for="c-42511607">[1 more]</label></div><br/><div class="children"><div class="content">To make this more concrete:<p>If your service layer method requires data to be saved and the results to be sorted, you want to call a data layer method that saves it and a library method that sorts it.  You do not want any of that saving or sorting functionality in your service method.<p>Combining different layers and different tasks so that your module is &quot;deep&quot; rather than &quot;shallow&quot; will make your code much higher cognitive load and create a lot of bugs.</div><br/></div></div></div></div><div id="42515328" class="c"><input type="checkbox" id="c-42515328" checked=""/><div class="controls bullet"><span class="by">mark_l_watson</span><span>|</span><a href="#42511469">prev</a><span>|</span><a href="#42510953">next</a><span>|</span><label class="collapse" for="c-42515328">[-]</label><label class="expand" for="c-42515328">[1 more]</label></div><br/><div class="children"><div class="content">I have been programming since 1963 and I was a Master Software Engineer at Capital One before I retired. I have my own ways of managing cognitive load. I usually use Lisp languages, Python, and Haskell and I tend to write my own short libraries and then treat these libraries as black boxes unless I want to extend them. I obviously use a zillion libraries that other people write also, but there is a comfort and ease using my own code.</div><br/></div></div><div id="42510953" class="c"><input type="checkbox" id="c-42510953" checked=""/><div class="controls bullet"><span class="by">mrcsd</span><span>|</span><a href="#42515328">prev</a><span>|</span><a href="#42510594">next</a><span>|</span><label class="collapse" for="c-42510953">[-]</label><label class="expand" for="c-42510953">[1 more]</label></div><br/><div class="children"><div class="content">IMO cognative load is much easier to manage when required (human) memory use is less of a factor. In practical terms, this means maximising the locality of reasoning, i.e., having everything you need in front of you to make a decision. One of the reasons I favour rust is precisely because this factor has been a focus in the design.</div><br/></div></div><div id="42510594" class="c"><input type="checkbox" id="c-42510594" checked=""/><div class="controls bullet"><span class="by">Freak_NL</span><span>|</span><a href="#42510953">prev</a><span>|</span><a href="#42510338">next</a><span>|</span><label class="collapse" for="c-42510594">[-]</label><label class="expand" for="c-42510594">[2 more]</label></div><br/><div class="children"><div class="content">That short&#x2F;long toggle in the top-right seems to expand and collapse the article. It defaults to short. Reading this article in its short form I kept wondering if I was missing something relevant (cognitive load++), but with the long form on I kept wondering if some paragraphs were explicitly intended to be superfluous or tangential (cognitive load++) for the sake of that collapsing trick.<p>For an article on cognitive load, using a gimmick which increases it seems ironic.</div><br/><div id="42510627" class="c"><input type="checkbox" id="c-42510627" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#42510594">parent</a><span>|</span><a href="#42510338">next</a><span>|</span><label class="collapse" for="c-42510627">[-]</label><label class="expand" for="c-42510627">[1 more]</label></div><br/><div class="children"><div class="content">I thought these things were pretty inferable</div><br/></div></div></div></div><div id="42510338" class="c"><input type="checkbox" id="c-42510338" checked=""/><div class="controls bullet"><span class="by">xnx</span><span>|</span><a href="#42510594">prev</a><span>|</span><a href="#42511165">next</a><span>|</span><label class="collapse" for="c-42510338">[-]</label><label class="expand" for="c-42510338">[1 more]</label></div><br/><div class="children"><div class="content">This applies to user experience as well. I&#x27;ve seen designers focus on number of items or number of clicks when mental effort &#x2F; cognitive load is what matters. Sometimes picking from a list of 50 links is easier. Sometimes answering 7 yes&#x2F;no questions is easier.</div><br/></div></div><div id="42511165" class="c"><input type="checkbox" id="c-42511165" checked=""/><div class="controls bullet"><span class="by">meowface</span><span>|</span><a href="#42510338">prev</a><span>|</span><a href="#42513767">next</a><span>|</span><label class="collapse" for="c-42511165">[-]</label><label class="expand" for="c-42511165">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve sometimes seen people attack early returns and I&#x27;ve never understood it. To me they make things so much cleaner that it seems like common sense.</div><br/></div></div><div id="42513767" class="c"><input type="checkbox" id="c-42513767" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42511165">prev</a><span>|</span><a href="#42513812">next</a><span>|</span><label class="collapse" for="c-42513767">[-]</label><label class="expand" for="c-42513767">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We were told that a really smart developer had contributed to it. Lots of cool architectures, fancy libraries and trendy technologies were used. In other words, the author had created a high cognitive load for us.<p>Maybe that dev was &quot;really smart&quot; but then not very senior. Eventually the dev will hopefully use their smarts to make things so simple+dumb that the cognitive load when maintaining all that code is minimized.<p>One of the first things I try to drill into our junior devs. If the code looks smart, it needs to be fixed until it&#x27;s really simple and straight forward. &quot;That&#x27;s impossible&quot; some people might say. And that&#x27;s why only the really smart folks can achieve it.</div><br/><div id="42513782" class="c"><input type="checkbox" id="c-42513782" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#42513767">parent</a><span>|</span><a href="#42513812">next</a><span>|</span><label class="collapse" for="c-42513782">[-]</label><label class="expand" for="c-42513782">[2 more]</label></div><br/><div class="children"><div class="content">&gt; make things so simple+dumb that the cognitive load when maintaining all that code is minimized.<p>That&#x27;s not very smart in BigCo, instead you want the complexity to leak into adjacent systems and make them depend on you.</div><br/><div id="42513823" class="c"><input type="checkbox" id="c-42513823" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42513767">root</a><span>|</span><a href="#42513782">parent</a><span>|</span><a href="#42513812">next</a><span>|</span><label class="collapse" for="c-42513823">[-]</label><label class="expand" for="c-42513823">[1 more]</label></div><br/><div class="children"><div class="content">I know your comment is a little tongue-in-cheek, but that kind of thinking is in fact widespread and a reason why many of us are so miserable.</div><br/></div></div></div></div></div></div><div id="42513812" class="c"><input type="checkbox" id="c-42513812" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42513767">prev</a><span>|</span><a href="#42514177">next</a><span>|</span><label class="collapse" for="c-42513812">[-]</label><label class="expand" for="c-42513812">[3 more]</label></div><br/><div class="children"><div class="content">Re: complex conditionals<p>I contributed some code to a FOSS project recently which is written in C. In my 10 lines of contributions, 3 were a complex conditional. I&#x27;d have loved to do what the article suggests, with some intermediate booleans. But that C version would have required me to define those variables at the beginning of the function, a hundred lines earlier instead of just right there. No way that&#x27;s going to fly, so now they will need to live with a complex conditional. It&#x27;s one of those &quot;modern language&quot; features which C fanatics generally frown upon but which makes code much easier to read.</div><br/><div id="42514686" class="c"><input type="checkbox" id="c-42514686" checked=""/><div class="controls bullet"><span class="by">pegas1</span><span>|</span><a href="#42513812">parent</a><span>|</span><a href="#42514162">next</a><span>|</span><label class="collapse" for="c-42514686">[-]</label><label class="expand" for="c-42514686">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I remember those times, trying to do structured programming in the unstructured environment. So, we both know that even very complex conditionals can be made readable by CRLFs, TABs, and inline comments. It is not about the language, it is about the person.</div><br/></div></div><div id="42514162" class="c"><input type="checkbox" id="c-42514162" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42513812">parent</a><span>|</span><a href="#42514686">prev</a><span>|</span><a href="#42514177">next</a><span>|</span><label class="collapse" for="c-42514162">[-]</label><label class="expand" for="c-42514162">[1 more]</label></div><br/><div class="children"><div class="content">Can you not move to c99?</div><br/></div></div></div></div><div id="42514177" class="c"><input type="checkbox" id="c-42514177" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42513812">prev</a><span>|</span><a href="#42513758">next</a><span>|</span><label class="collapse" for="c-42514177">[-]</label><label class="expand" for="c-42514177">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Prefer composition over inheritance.<p>Why? Because if SuperuserController is built on AdminController via composition rather than inheritance, it is magically protected from breakage due to changes in AdminController?<p>Not buying it.</div><br/></div></div><div id="42513758" class="c"><input type="checkbox" id="c-42513758" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#42514177">prev</a><span>|</span><a href="#42517326">next</a><span>|</span><label class="collapse" for="c-42513758">[-]</label><label class="expand" for="c-42513758">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By no means I am trying to blame C++. I love the language. It&#x27;s just that I am tired now.<p>I feel that in my bones.</div><br/></div></div><div id="42517326" class="c"><input type="checkbox" id="c-42517326" checked=""/><div class="controls bullet"><span class="by">dherikb</span><span>|</span><a href="#42513758">prev</a><span>|</span><label class="collapse" for="c-42517326">[-]</label><label class="expand" for="c-42517326">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mantras like &quot;methods should be shorter than 15 lines of code&quot; or &quot;classes should be small&quot; turned out to be somewhat wrong.<p>I really have some concerns about this kind of opinion.<p>I know that we can&#x27;t follow this rule (or smell) every time, but I already see this affirmation being used by very poor or inexperienced programmers to justify understandable gigantic and hard to test pieces of code.<p>This is the type of advice that just experienced programmers can understand what this means and know when is applied.<p>Most part of the time, it&#x27;s easier to fix a cod</div><br/></div></div></div></div></div></div></div></body></html>