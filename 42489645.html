<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735203655002" as="style"/><link rel="stylesheet" href="styles.css?v=1735203655002"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://minds.md/zakirullin/cognitive">Cognitive load is what matters</a> <span class="domain">(<a href="https://minds.md">minds.md</a>)</span></div><div class="subtext"><span>zdw</span> | <span>310 comments</span></div><br/><div><div id="42511276" class="c"><input type="checkbox" id="c-42511276" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42511276">[-]</label><label class="expand" for="c-42511276">[62 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking about the notion of &quot;reasoning locally&quot; recently. Enabling local reasoning is the only way to scale software development past some number of lines or complexity. When reasoning locally, one only needs to understand a small subset, hundreds of lines, to safely make changes in programs comprising millions.<p>I find types helps massively with this. A function with well-constrained inputs and outputs is easy to reason about. One does not have to look at other code to do it. However, programs that leverage types effectively are sometimes construed as having high cognitive load, when it in fact they have low load. For example a type like `Option&lt;HashSet&lt;UserId&gt;&gt;` carries a lot of information(has low load): we might not have a set of user ids, but if we do they are unique.<p>The discourse around small functions and the clean code guidelines is fascinating. The complaint is usually, as in this post, that having to go read all the small functions adds cognitive load and makes reading the code harder. Proponents of small functions argue that you don&#x27;t have to read more than the signature and name of a function to understand what it does; it&#x27;s obvious what a function called last that takes a list and returns an optional value does. If someone feels compelled to read every function either the functions are poor abstractions or the reader has trust issues, which may be warranted. Of course, all abstractions are leaky, but perhaps some initial trust in `last` is warranted.</div><br/><div id="42511509" class="c"><input type="checkbox" id="c-42511509" checked=""/><div class="controls bullet"><span class="by">0xFACEFEED</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512310">next</a><span>|</span><label class="collapse" for="c-42511509">[-]</label><label class="expand" for="c-42511509">[27 more]</label></div><br/><div class="children"><div class="content">&gt; A function with well-constrained inputs and outputs is easy to reason about.<p>It&#x27;s quite easy to imagine a well factored codebase where all things are neatly separated. If you&#x27;ve written something a thousand times, like user authentication, then you can plan out exactly how you want to separate everything. But user authentication isn&#x27;t where things get messy.<p>The messy stuff is where the real world concepts need to be transformed into code. Where just the <i>concepts</i> need to be whiteboarded and explained because they&#x27;re unintuitive and confusing. Then these unintuitive and confusing concepts need to somehow described to the computer.<p>Oh, and it needs to be fast. So not only do you need to model an unintuitive and confusing concept - you also need to write it in a convoluted way because, for various annoying reasons, that&#x27;s what performs best on the computer.<p>Oh, and in 6 months the unintuitive and confusing concept needs to be completely changed into - surprise, surprise - a completely different but equally unintuitive and confusing concept.<p>Oh, and you can&#x27;t rewrite everything because there isn&#x27;t enough time or budget to do that. You have to minimally change the current uintuitive and confusing thing so that it works like the new unintuitive and confusing thing is supposed to work.<p>Oh, and the original author doesn&#x27;t work here anymore so no one&#x27;s here to explain the original code&#x27;s intent.</div><br/><div id="42512497" class="c"><input type="checkbox" id="c-42512497" checked=""/><div class="controls bullet"><span class="by">justinram11</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42512497">[-]</label><label class="expand" for="c-42512497">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Oh, and the original author doesn&#x27;t work here anymore so no one&#x27;s here to explain the original code&#x27;s intent.<p>To be fair, even if I still work there I don&#x27;t know that I&#x27;m going to be of much help 6 months later other than a &quot;oh yeah, I remember that had some weird business requirements&quot;</div><br/><div id="42512674" class="c"><input type="checkbox" id="c-42512674" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512497">parent</a><span>|</span><a href="#42512672">next</a><span>|</span><label class="collapse" for="c-42512674">[-]</label><label class="expand" for="c-42512674">[5 more]</label></div><br/><div class="children"><div class="content">Might I recommend writing those weird business requirements down as comments instead of just hoping someone will guess them six months down the line?</div><br/><div id="42513642" class="c"><input type="checkbox" id="c-42513642" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513765">next</a><span>|</span><label class="collapse" for="c-42513642">[-]</label><label class="expand" for="c-42513642">[2 more]</label></div><br/><div class="children"><div class="content">So even if comments are flawlessly updated they are not a silver bullet. Not everyone are good at explaining confusing concepts in plain English so worst case you have confusing code and a comment that is 90% accurate but describe one detail in a way that doesn&#x27;t really match what the code says.  This will make you question if you have understood what the code does and it will take time and effort to convince yourself that code is in fact deterministic and unsurprising.<p>(but most often the comment is is just not updated or updated along with the code but without full understanding, which is what caused the bug that is the reason you are looking at the code in question)</div><br/><div id="42513738" class="c"><input type="checkbox" id="c-42513738" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513642">parent</a><span>|</span><a href="#42513765">next</a><span>|</span><label class="collapse" for="c-42513738">[-]</label><label class="expand" for="c-42513738">[1 more]</label></div><br/><div class="children"><div class="content">An outdated comment is still a datapoint! Including if the comment was wrong when it was first written!<p>We live in a world with version history, repositories with change requests, communications… code comments are a part of that ecosystem.<p>A comment that is outright incorrect at inception is still valuable even if it is at least an attempt by the writer to describe their internal understanding of things.</div><br/></div></div></div></div><div id="42513765" class="c"><input type="checkbox" id="c-42513765" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513642">prev</a><span>|</span><a href="#42513646">next</a><span>|</span><label class="collapse" for="c-42513765">[-]</label><label class="expand" for="c-42513765">[1 more]</label></div><br/><div class="children"><div class="content">Business requirements deviate from code almost immediately. Serving several clients with customisation adds even more strain on the process. Eventually you want to map paragraphs of business req to code which is not a 1:1 mapping.<p>Aging codebase and the ongoing operations make it even harder to maintain consistently. eventually people surrender.</div><br/></div></div><div id="42513646" class="c"><input type="checkbox" id="c-42513646" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512674">parent</a><span>|</span><a href="#42513765">prev</a><span>|</span><a href="#42512672">next</a><span>|</span><label class="collapse" for="c-42513646">[-]</label><label class="expand" for="c-42513646">[1 more]</label></div><br/><div class="children"><div class="content">Then in 3 months someone in between came changing the code slightly that makes comment obsolete but doesn’t update the comment. Making all worse not better.<p>Issue trackers are much better because then in git you can find tickets attached to the change.<p>No ticket explaining why - no code change.<p>Why not in repo? because business people write tickets not devs. Then tickets are passed to QA who also does read the code but also need that information.</div><br/></div></div></div></div><div id="42512672" class="c"><input type="checkbox" id="c-42512672" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512497">parent</a><span>|</span><a href="#42512674">prev</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42512672">[-]</label><label class="expand" for="c-42512672">[7 more]</label></div><br/><div class="children"><div class="content">Thank god we’re held to such low standards. Every time I’ve worked in a field like pharmaceuticals or manufacturing, the documentation burden felt overwhelming by comparison and a shrug six months later would never fly.</div><br/><div id="42512923" class="c"><input type="checkbox" id="c-42512923" checked=""/><div class="controls bullet"><span class="by">mnau</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512672">parent</a><span>|</span><a href="#42512817">next</a><span>|</span><label class="collapse" for="c-42512923">[-]</label><label class="expand" for="c-42512923">[1 more]</label></div><br/><div class="children"><div class="content">We are not engineers. We are craftsmen, instead of working with wood, we work with code. What most customers want is an equivalent of &quot;I need a chair, it should look roughly like this.&quot;<p>If they want blueprints and documentation (e.g. maximum possible load and other limits), we can supply (and do supply, e.g. in pharma or medicine), but it will cost them quite a lot more. By the order of magnitude. Most customers prefer cobbled up solution that is cheap and works. That&#x27;s on them.<p>Edit: It is called waterfall. There is nothing inherently wrong with it, except customers didn&#x27;t like the time it took to implement a change. And they want changes all the time.</div><br/></div></div><div id="42512817" class="c"><input type="checkbox" id="c-42512817" checked=""/><div class="controls bullet"><span class="by">Yiin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512672">parent</a><span>|</span><a href="#42512923">prev</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42512817">[-]</label><label class="expand" for="c-42512817">[5 more]</label></div><br/><div class="children"><div class="content">there is difference between building a dashboard for internal systems and tech that if failed can kill people</div><br/><div id="42512847" class="c"><input type="checkbox" id="c-42512847" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512817">parent</a><span>|</span><a href="#42513770">next</a><span>|</span><label class="collapse" for="c-42512847">[-]</label><label class="expand" for="c-42512847">[1 more]</label></div><br/><div class="children"><div class="content">Most software work in pharma and manufacturing is still CRUD, they just have cultures of rigorous documentation that permeates the industry even when it&#x27;s low value. Documenting every little change made sense when I was programming the robotics for a genetic diagnostics pipeline, not so much when I had to write a one pager justifying a one line fix to the parser for the configuration format or updating some LIMS dependency to fix a vulnerability in an internal tool that&#x27;s not even open to the internet.</div><br/></div></div><div id="42513770" class="c"><input type="checkbox" id="c-42513770" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512817">parent</a><span>|</span><a href="#42512847">prev</a><span>|</span><a href="#42513282">next</a><span>|</span><label class="collapse" for="c-42513770">[-]</label><label class="expand" for="c-42513770">[1 more]</label></div><br/><div class="children"><div class="content">The word code comes from Latin coudex which seems mean - to hack a tree. Are we then not mere lumberjacks with the beards and beer and all :)))</div><br/></div></div><div id="42513282" class="c"><input type="checkbox" id="c-42513282" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512817">parent</a><span>|</span><a href="#42513770">prev</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42513282">[-]</label><label class="expand" for="c-42513282">[2 more]</label></div><br/><div class="children"><div class="content">Well, a hand watch or a chair cannot kill people, but the manufacturing documentation for them will be very precise.<p>Software development is not engineering because it is still relatively young and immature field. There is a joke where a mathematician, a physicist and a engineer are given a little red rubber ball and asked to find its volume. The mathematician measures the diameter and computes, the physicist immerses the ball into water and sees how much was displaced, and an the engineer looks it up in his &quot;Little red rubber balls&quot; reference.<p>Software development does not yet have anything that may even potentially grow into such a reference. If we decide to write it we would not even know where to start. We have mathematicians who write computer science papers; or physicists who test programs; standup comedians, philosophers, everyone. But not engineers.</div><br/><div id="42513952" class="c"><input type="checkbox" id="c-42513952" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513282">parent</a><span>|</span><a href="#42511720">next</a><span>|</span><label class="collapse" for="c-42513952">[-]</label><label class="expand" for="c-42513952">[1 more]</label></div><br/><div class="children"><div class="content">Difference is that code is the documentation and design.<p>That is problem where people don’t understand that point.<p>Runtime and running application is the chair. Code is design how to make “chair” run on computer.<p>I say in software development we are years ahead when it comes to handling complexity of documentation with GIT and CI&#x2F;CD practices, code reviews and QA coverage with unit testing of the designs and general testing.<p>So I do not agree that software development is immature field. There are immature projects and companies cut corners much more than on physical products because it is much easier to fix software later.<p>But in terms of practices we are way ahead.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42511720" class="c"><input type="checkbox" id="c-42511720" checked=""/><div class="controls bullet"><span class="by">mgkimsal</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42512497">prev</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42511720">[-]</label><label class="expand" for="c-42511720">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Oh, and in 6 months the unintuitive and confusing concept needs to be completely changed into - surprise, surprise - a completely different but equally unintuitive and confusing concept.<p>But you have to keep the old way of working exactly the same, and the data can&#x27;t change, but also needs to work in the new version as well.  Actually show someone there&#x27;s two modes, and offer to migrate their data to version 2?  No way - that&#x27;s confusing!  Show different UI in different areas with the same data that behaves differently based on ... undisclosed-to-the-user criteria.  That will be far less confusing.</div><br/><div id="42511743" class="c"><input type="checkbox" id="c-42511743" checked=""/><div class="controls bullet"><span class="by">terribleperson</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511720">parent</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42511743">[-]</label><label class="expand" for="c-42511743">[5 more]</label></div><br/><div class="children"><div class="content">As a user &#x27;intuitive&#x27; UIs that hide a bunch of undisclosed but relevant complexity send me into a frothing rage.</div><br/><div id="42513459" class="c"><input type="checkbox" id="c-42513459" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511743">parent</a><span>|</span><a href="#42512206">next</a><span>|</span><label class="collapse" for="c-42513459">[-]</label><label class="expand" for="c-42513459">[2 more]</label></div><br/><div class="children"><div class="content">In many problem spaces, software developers are only happy with interfaces made for software developers. This article diving into the layers of complex logic we can reason about at once perfectly demonstrates why. Developers ‘get’ that complexity, because it’s our job, and think about GUIs as thin convenience wrappers for the program underneath. To most users, the GUI <i>is</i> the software, and they consider applications like appliances for solving specific problems. You aren’t <i>using the refrigerator,</i> you’re <i>getting food</i>. You’re <i>cooking</i>, not <i>using the stove.</i> The fewer things they have to do or think about to solve their problem to their satisfaction, the better. They don’t give a flying fuck about <i>how</i> software does something, probably wouldn’t bother figuring out how to adjust it if they could, and the longer it takes them to figure out how to apply their existing mental models UI idioms to the screen they’re looking at, the more frustrated they get. Software developers know what’s going on behind the scenes so seeing all of the controls and adjustments and statuses and data helps developers orient themselves save figure out what they’re doing. Seeing all that stuff is often a huge hindrance to users that just have a problem they need to solve, and have a much more limited set of mental models and usage idioms they need to use figuring how which of those buttons to press and parameters to adjust. That’s the primary reason FOSS has so few non-technical users.<p>The problem comes in when people that aren’t UI designers want to make something “look designed” so they start ripping stuff out and moving it around without understanding how it works affect different types of users. I don’t hear too many developers complain about the interface for iMessage for example despite having a fraction of the controls visible at any given time, because it effectively solves their problem, and does so easier than with a visible toggle for read receipts, SMS&#x2F;iMessages, text size, etc etc etc. It doesn’t merely look designed, it it’s designed for optimal usability.<p>Developers often see an interface that doesn’t work well for developers usage style, assume that means it doesn’t work well, and then complain about it among other developers creating an echo chamber. Developers being frustrated with an interface is an important data point that shouldn’t be ignored, but our perspectives and preferences aren’t nearly as generalizable some might think.</div><br/><div id="42513927" class="c"><input type="checkbox" id="c-42513927" checked=""/><div class="controls bullet"><span class="by">terribleperson</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513459">parent</a><span>|</span><a href="#42512206">next</a><span>|</span><label class="collapse" for="c-42513927">[-]</label><label class="expand" for="c-42513927">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not particularly bothered by non-developer UI. I&#x27;m bothered by the incessant application of mobile UI idioms to desktop programs (remember when all windows programs looked somewhat similar?), by UI churn with no purpose, by software that puts functionality five clicks deep for no reason other than to keep the ui &#x27;minimal&#x27;, by the use of unclear icons when there&#x27;s room for text (worse, when it&#x27;s one of the bare handful of things with a universally-understood icon and they decided to invent their own), by UIs that just plain don&#x27;t present important information for fear of making things &#x27;busy&#x27;. There&#x27;s a lot to get mad about when it comes to modern UIs without needing to approach it from a software developer usage style perspective.</div><br/></div></div></div></div><div id="42512206" class="c"><input type="checkbox" id="c-42512206" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511743">parent</a><span>|</span><a href="#42513459">prev</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42512206">[-]</label><label class="expand" for="c-42512206">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m trying to learn acceptance: how not to get so angry at despicable UIs.<p>Although I admit I&#x27;m kinda failing. My minor successes have been by avoiding software: e.g. giving up programming (broken tools and broken targets were a major frustration) and getting rid of Windows.</div><br/><div id="42512322" class="c"><input type="checkbox" id="c-42512322" checked=""/><div class="controls bullet"><span class="by">shnock</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512206">parent</a><span>|</span><a href="#42513488">next</a><span>|</span><label class="collapse" for="c-42512322">[-]</label><label class="expand" for="c-42512322">[1 more]</label></div><br/><div class="children"><div class="content">Having given up programming, what do you do now?</div><br/></div></div></div></div></div></div></div></div><div id="42513488" class="c"><input type="checkbox" id="c-42513488" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511720">prev</a><span>|</span><a href="#42513515">next</a><span>|</span><label class="collapse" for="c-42513488">[-]</label><label class="expand" for="c-42513488">[1 more]</label></div><br/><div class="children"><div class="content">IMO the fact that code tends to become hard over time in the real world, is even more reason to lower cognitive load. Because cognitive load is related to complexity. Things like inheritance make it far too easy to end up with spaghetti. So if it&#x27;s not providing significant benefit, god damn don&#x27;t do it in the first place (like the article mentions).</div><br/></div></div><div id="42513515" class="c"><input type="checkbox" id="c-42513515" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42513488">prev</a><span>|</span><a href="#42512727">next</a><span>|</span><label class="collapse" for="c-42513515">[-]</label><label class="expand" for="c-42513515">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Where just the concepts need to be whiteboarded and explained because they&#x27;re unintuitive and confusing.<p>they&#x27;re intuitive to somebody - just not the software engineer. This simply means there&#x27;s some domain expertise which isn&#x27;t available to the engineer.</div><br/></div></div><div id="42512727" class="c"><input type="checkbox" id="c-42512727" checked=""/><div class="controls bullet"><span class="by">dogcomplex</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42513515">prev</a><span>|</span><a href="#42513723">next</a><span>|</span><label class="collapse" for="c-42512727">[-]</label><label class="expand" for="c-42512727">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a bunch of excellent excuses why code is not typically well factored.  But that all just seems to make it more evident that the ideal format should be more well-factored.</div><br/></div></div><div id="42513723" class="c"><input type="checkbox" id="c-42513723" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42512727">prev</a><span>|</span><a href="#42511677">next</a><span>|</span><label class="collapse" for="c-42513723">[-]</label><label class="expand" for="c-42513723">[1 more]</label></div><br/><div class="children"><div class="content">I mean really nobody wants an app that is slow, hard to refactor, with confusing business logic etc. Everyone wants good proporties.<p>So then you get into what you’re good at. Maybe you’re good at modeling business logic (even confusing ones!). Maybe you’re good at writing code that is easy to refactor.<p>Maybe you’re good at getting stuff right the first time. Maybe you’re good at quickly fixing issues.<p>You can lean into what you’re good at to get the most bang for your buck. But you probably still have some sort of minimum standards for the whole thing. Just gotta decide what that looks like.</div><br/></div></div><div id="42511677" class="c"><input type="checkbox" id="c-42511677" checked=""/><div class="controls bullet"><span class="by">ilvez</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42513723">prev</a><span>|</span><a href="#42511557">next</a><span>|</span><label class="collapse" for="c-42511677">[-]</label><label class="expand" for="c-42511677">[1 more]</label></div><br/><div class="children"><div class="content">Plus to everything said. It&#x27;s an everyday life of &quot;maintainer&quot;, picking the next battle to pick the best way to avoid sinking deeper and defending the story that exactly &quot;this&quot; is the next refactoring project. All that while balancing different factors as you mention to actually believe oneself, because there are countless of paths..</div><br/></div></div><div id="42511557" class="c"><input type="checkbox" id="c-42511557" checked=""/><div class="controls bullet"><span class="by">haliskerbas</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511677">prev</a><span>|</span><a href="#42511926">next</a><span>|</span><label class="collapse" for="c-42511557">[-]</label><label class="expand" for="c-42511557">[1 more]</label></div><br/><div class="children"><div class="content">This puts things really well. I’ll add into it that between the first white boarding session and the first working MVP there’ll be plenty of stakeholders who change their mind, find new info, or ask for updates that may break the original plan</div><br/></div></div><div id="42511926" class="c"><input type="checkbox" id="c-42511926" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511509">parent</a><span>|</span><a href="#42511557">prev</a><span>|</span><a href="#42512310">next</a><span>|</span><label class="collapse" for="c-42511926">[-]</label><label class="expand" for="c-42511926">[1 more]</label></div><br/><div class="children"><div class="content">It can be done. Sometimes.<p>I am so proud and happy, when I can make a seemingly complicated change quickly, because the architecture was well designed and everthing neatly seperated.<p>Most of the time though, it is exactly like you described. Or randalls good code comic:<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;844&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;844&#x2F;</a><p>Allmost too painful to be funny, when you know the pain is avoidable in theory.<p>Still, it should not be an excuse to be lazy and just write bad code by default. Developing the habit of making everything as clean, structured and clear as possible allways pays of. Especially if that code, that was supposed to be a quick and dirty throw away code experiment somehow ended up being used and 2 years later you suddenly need to debug it.
(I just experienced that joy)</div><br/></div></div></div></div><div id="42512310" class="c"><input type="checkbox" id="c-42512310" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511509">prev</a><span>|</span><a href="#42511630">next</a><span>|</span><label class="collapse" for="c-42512310">[-]</label><label class="expand" for="c-42512310">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If someone feels compelled to read every function either the functions are poor abstractions or the reader has trust issues, which may be warranted.<p>I joined a company with great code and architecture for 3 months last year. They deal with remittances and payments.<p>Their architecture leads are very clued up, and I observed that they spent a lot of quality time figuring out their architecture and improvements, continuously. They&#x27;d do a lot of refactors for all the various teams, and the cadence of feature development and release was quite impressive.<p>In that period though, I and another long-standing colleague made a few errors that cost the company a lot of money, like an automated system duplicating payments to users for a few hours until we noticed it.<p>Part of their architectural decision was to use small functions to encapsulate logic, and great care and code review was put into naming functions appropriately (though they were comment averse).<p>The mistakes we committed, were because we trusted that those functions did what they said they did correctly. After all, they&#x27;ve also been unit tested, and there&#x27;s also integration tests.<p>If it weren&#x27;t for the fortitude of the project manager (great guy hey) in firmly believing in collective responsibility if there&#x27;s no malice, I&#x27;d probably have been fired after a few weeks (I left for a higher offer elsewhere).<p>---<p>So the part about trust issues resonates well with me. As a team we made the decision that we shouldn&#x27;t always trust existing code, and the weeks thereafter had much higher cognitive load.</div><br/><div id="42512869" class="c"><input type="checkbox" id="c-42512869" checked=""/><div class="controls bullet"><span class="by">avg_dev</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512310">parent</a><span>|</span><a href="#42511630">next</a><span>|</span><label class="collapse" for="c-42512869">[-]</label><label class="expand" for="c-42512869">[2 more]</label></div><br/><div class="children"><div class="content">That sounds like a very difficult situation. Would you be willing to elaborate on what kinds of bugs lay in the pre-existing functions? Was some sort of operation that was supposed to be idempotent (“if you call it with these unique parameters over and over, it will be the same as if you only called it once”) not so? I am trying to imagine what went wrong here. A tough situation, must have been quite painful. How serious were the consequences? If you don’t feel comfortable answering that is okay.</div><br/><div id="42513361" class="c"><input type="checkbox" id="c-42513361" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512869">parent</a><span>|</span><a href="#42511630">next</a><span>|</span><label class="collapse" for="c-42513361">[-]</label><label class="expand" for="c-42513361">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember the exact detail, but one instance was a function checking whether a user should be paid based on some conditions. It checked the db, and I think because the codebase and db move fast, there was a new enum added a few months prior which was triggered by our transaction type.<p>So that helped function didn&#x27;t account for the new enum, and we ended up sending &gt;2 payments to users, in some cases I think over 10 to one user.<p>The issue was brought to customer support&#x27;s attention, else we might have only noticed it at the end of the week, which I think would have led to severe consequences.<p>The consequences never reached us because our PM dealt with them. I suppose in all the financial loss instances, the business absorbed the losses.</div><br/></div></div></div></div></div></div><div id="42511630" class="c"><input type="checkbox" id="c-42511630" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512310">prev</a><span>|</span><a href="#42511578">next</a><span>|</span><label class="collapse" for="c-42511630">[-]</label><label class="expand" for="c-42511630">[1 more]</label></div><br/><div class="children"><div class="content">100% agree and this not only concerns readability. The concept of &quot;locality&quot; turns out to be a fairly universal concept, which applies to human processes just as much as technical ones. Side-effects are the root of all evil.<p>You don&#x27;t see a waiter taking orders from 1 person on a table, but rather go to a table and get orders from everybody sitting there.<p>And as for large methods, I find that they can be broken into smaller once just fine as long as you keep them side-effect free. Give them a clear name, a clear return value and now you have a good model for the underlying problem you are solving. Looking up the actual definition is just looking at implementation details.</div><br/></div></div><div id="42511578" class="c"><input type="checkbox" id="c-42511578" checked=""/><div class="controls bullet"><span class="by">motorest</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511630">prev</a><span>|</span><a href="#42512571">next</a><span>|</span><label class="collapse" for="c-42511578">[-]</label><label class="expand" for="c-42511578">[17 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been thinking about the notion of &quot;reasoning locally&quot; recently. Enabling local reasoning is the only way to scale software development past some number of lines or complexity. When reasoning locally, one only needs to understand a small subset, hundreds of lines, to safely make changes in programs comprising millions.<p>That was supposedly the main trait of object-oriented programming. Personally that was how it was taught to me: the whole point of encapsulation and information hiding is to ensure developers can &quot;reason locally&quot;, and thus be able to develop more complex projects by containing complexity to specific units of execution.<p>Half of SOLID principles also push for that. The main benefit of Liskov&#x27;s substitution principle is ensure developers don&#x27;t need to dig into each and every concrete implementation to be able to reason locally about the code.<p>On top of that, there are a multitude of principles and rules of thumb that also enforce that trait. For example, declaring variables right before they are used the first time. Don&#x27;t Repeat Yourself to avoid parsing multiple implementations of the same routine. Write Everything Twice to avoid premature abstractions and tightly coupling units of execution that are actually completely independent, etc etc etc.<p>Heck, even modularity, layered software architectures, and even microservices are used to allow developers to reason locally.<p>In fact, is there any software engineering principle that isn&#x27;t pushing for limiting complexity and allowing developers to reason locally?</div><br/><div id="42511953" class="c"><input type="checkbox" id="c-42511953" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42511953">[-]</label><label class="expand" for="c-42511953">[11 more]</label></div><br/><div class="children"><div class="content">Encapsulation is the good part of object-oriented programming for precisely this reason, and most serious software development relies heavily on encapsulation. What&#x27;s bad about OOP is inheritance.<p>Microservices (in the sense of small services) are interesting because they are good at providing independent failure domains, but add the complexity of network calls to what would otherwise be a simple function call. I think the correct size of service is the largest you can get away with that fits into your available hardware and doesn&#x27;t compromise on resilience. Within a service, use things like encapsulation.</div><br/><div id="42512413" class="c"><input type="checkbox" id="c-42512413" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511953">parent</a><span>|</span><a href="#42512143">next</a><span>|</span><label class="collapse" for="c-42512413">[-]</label><label class="expand" for="c-42512413">[6 more]</label></div><br/><div class="children"><div class="content">Inheritance is everyone&#x27;s favorite whipping boy, but I&#x27;ve still never been in a codebase and felt like the existing inheritance was seriously hindering my ability to reason about it or contribute to it, and I find it productive to use on my own. It makes intuitive sense and aids understanding and modularity&#x2F;code resuse when used appropriately. Even really deep inheritance hierarchies where reasonable have never bothered me. I&#x27;ve been in the industry for at least 8 years and a volunteer for longer than that, and I&#x27;m currently in a role where I&#x27;m one of the most trusted &quot;architects&quot; on the team, so I feel like I should &quot;get it&quot; by now if it&#x27;s really that bad. I understand the arguments against inheritance in the abstract but I simply can&#x27;t bring myself to agree or even really empathize with them. Honestly, I find the whole anti-inheritance zeitgeist as silly and impotent as the movement to replace pi with tau, it&#x27;s simply a non-issue that&#x27;s unlikely to be on your mind if you&#x27;re actually getting work done IMHO.</div><br/><div id="42513996" class="c"><input type="checkbox" id="c-42513996" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42513466">next</a><span>|</span><label class="collapse" for="c-42513996">[-]</label><label class="expand" for="c-42513996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [...] it&#x27;s simply a non-issue that&#x27;s unlikely to be on your mind if you&#x27;re actually getting work done IMHO.<p>Part of why I get (more) work done is that I don&#x27;t bother with the near-useless taxonomical exercises that inheritance invites, and I understand that there are ways of writing functions for &quot;all of these things, but no others&quot; that are simpler to understand, maintain and implement.<p>The amount of times you actually need an open set of things (i.e. what you get with inheritance) is so laughably low it&#x27;s a wonder inheritance ever became a thing. A closed set is way more likely to be what you want and is trivially represented as a tagged union. It just so happens that C++ (and Java) historically has had absolutely awful support for tagged unions so people have made do with inheritance even though it doesn&#x27;t do the right thing. Some people have then taken this to mean that&#x27;s what they ought to be using.<p>&gt; I&#x27;ve been in the industry for at least 8 years and a volunteer for longer than that, and I&#x27;m currently in a role where I&#x27;m one of the most trusted &quot;architects&quot; on the team, so I feel like I should &quot;get it&quot; by now if it&#x27;s really that bad.<p>I don&#x27;t think that&#x27;s really how it works. There are plenty of people who have tons of work experience but they&#x27;ve got bad ideas and are bad at what they do. You don&#x27;t automatically just gain wisdom and there are lots of scenarios where you end up reinforcing bad ideas, behavior and habits. It&#x27;s also very easy to get caught up in a collective of poorly thought out ideas in aggregate: Most of modern C++ is a great example of the kind of thinking that will absolutely drag maintainability, readability and performance down, but most of the ideas can absolutely sound good on their own, especially if you don&#x27;t consider the type of architecture they&#x27;ll cause.</div><br/></div></div><div id="42513466" class="c"><input type="checkbox" id="c-42513466" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42513996">prev</a><span>|</span><a href="#42512562">next</a><span>|</span><label class="collapse" for="c-42513466">[-]</label><label class="expand" for="c-42513466">[1 more]</label></div><br/><div class="children"><div class="content">The problem of inheritance is that it should be an internal mechanism of code reuse, yet it is made public in a declarative form that implies a single pattern of such reuse. It works more or less but it also regularly runs into limitations imposed by that declarativeness.<p>For example, assume I want to write emulators for old computer architectures. Clearly there will be lots of places where I will be able to reuse the same code in different virtual CPUs. But can I somehow express all these patterns of reuse with inheritance? Will it be clearer to invent some generic CPU traits and make a specific CPU to inherit several such traits? It sounds very unlikely. It probably will be much simpler to just extract common code into subroutines and call them as necessary without trying to build a hierarchy of classes.<p>Or lets take, for example, search trees. Assume I want to have a library of such trees for research or pedagogic purposes. There are lots of mechanisms: AVL trees, 2-3, 2-3-4, red-black, B-Trees and so on. Again there will be places where I can reuse the same code for different trees. But can I really express all this as a neat hierarchy of tree classes?</div><br/></div></div><div id="42512562" class="c"><input type="checkbox" id="c-42512562" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42513466">prev</a><span>|</span><a href="#42512629">next</a><span>|</span><label class="collapse" for="c-42512562">[-]</label><label class="expand" for="c-42512562">[2 more]</label></div><br/><div class="children"><div class="content">So you&#x27;ve never worked on a code base with a 3-level+ deep inheritance tree and classes accessing their grandparent&#x27;s protected member variables and violating every single invariant possible?</div><br/><div id="42513232" class="c"><input type="checkbox" id="c-42513232" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512562">parent</a><span>|</span><a href="#42512629">next</a><span>|</span><label class="collapse" for="c-42513232">[-]</label><label class="expand" for="c-42513232">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 3-level+ deep inheritance tree and classes accessing their grandparent&#x27;s protected member variables<p>Yes, I have. Per MSDN, a protected member is accessible within its class and by derived class instances - that&#x27;s the point. Works fine in the game I work on.<p>&gt; violating every single invariant possible<p>Sure, sometimes, but I see that happen without class inheritance just as often.</div><br/></div></div></div></div><div id="42512629" class="c"><input type="checkbox" id="c-42512629" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512413">parent</a><span>|</span><a href="#42512562">prev</a><span>|</span><a href="#42512143">next</a><span>|</span><label class="collapse" for="c-42512629">[-]</label><label class="expand" for="c-42512629">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad it&#x27;s been useful to you!<p>I can only share my own experience here. I&#x27;m thinking of a very specific ~20k LoC part of a large developer infrastructure service. This was really interesting because it was:<p>* inherently complex: with a number of state manipulation algorithms, ranging from &quot;call this series of external services&quot; to &quot;carefully written mutable DFS variant with rigorous error handling and worst-case bounds analysis&quot;.<p>* quite polymorphic by necessity, with several backends and even more frontends<p>* (edit: added because it&#x27;s important) a <i>textbook</i> case of where inheritance should work: not artificial or forced at all, perfect Liskov is-a substitution<p>* very thick interfaces involved: a number of different options and arguments that weren&#x27;t possible to simplify, and several calls back and forth between components<p>* changing quite often as needs changed, at least 3-4 times a week and often much more<p>* and like a lot of dev infrastructure, absolutely critical: unimaginable to have the rest of engineering function without it<p>A number of developers contributed to this part of the code, from many different teams and at all experience levels.<p>This is a perfect storm for code that is going to get messy, unless strict discipline is enforced. I think situations like these are a good stress test for development &quot;paradigms&quot;.<p>With polymorphic inheritance, over time, a spaghetti structure developed. Parent functions started calling child functions, and child functions started calling parent ones, based on whatever was convenient in the moment. Some functions were designed to be overridden and some were not. Any kind of documentation about code contracts would quickly fall out of date. As this got worse, refactoring became basically impossible over time. Every change became harder and harder to make. I tried my best to improve the code, but spent so much time just trying to understand which way the calls were supposed to go.<p>This experience radicalized me against class-based inheritance. It felt that the easy path, the series of local decisions individual developers made to get their jobs done, led to code that was incredibly difficult to understand -- global deterioration. Each individual parent-to-child and child-to-parent call made sense in the moment, but the cumulative effect was a maintenance nightmare.<p>One of the reasons I like Rust is that trait&#x2F;typeclass-based polymorphism makes this much less of a problem. The contracts between components are quite clear since they&#x27;re mediated by traits. Rather than relying on inheritance for polymorphism, you write code that&#x27;s generic over a trait. You cannot easily make upcalls from the trait impl to the parent -- you must go through a API designed for this (say, a context argument provided to you). Some changes that are easy to do with an inheritance model become harder with traits, but that&#x27;s <i>fine</i> -- code evolving towards a series of messy interleaved callbacks is bad, and making you do a refactor now is better in the long run. It is <i>possible</i> to write spaghetti code if you push really hard (mixing required and provided methods) but the easy path is to refactor the code.<p>(I think more restricted forms of inheritance might work, particularly ones that make upcalls difficult to do -- but only if tooling firmly enforces discipline. As it stands though, class-based inheritance just has too many degrees of freedom to work well under sustained pressure. I think more restricted kinds of polymorphism work better.)</div><br/></div></div></div></div><div id="42512143" class="c"><input type="checkbox" id="c-42512143" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511953">parent</a><span>|</span><a href="#42512413">prev</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42512143">[-]</label><label class="expand" for="c-42512143">[4 more]</label></div><br/><div class="children"><div class="content">Encapsulation arguably isn’t a good part, either. It encourages complex state and as a result makes testing difficult. I feel like stateless or low-state has won out.</div><br/><div id="42512397" class="c"><input type="checkbox" id="c-42512397" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512143">parent</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42512397">[-]</label><label class="expand" for="c-42512397">[3 more]</label></div><br/><div class="children"><div class="content">Hmm, to me encapsulation means a scheme where the set of valid states is a subset of all representable states. It&#x27;s kind of a weakening of &quot;making invalid states unrepresentable&quot;, but is often more practical.<p>Not all strings are valid identifiers, for example, it&#x27;s hard to represent &quot;the set of all valid identifiers&quot; directly into the type system. So encapsulation is a good way to ensure that a particular identifier you&#x27;re working with is valid -- helping scale local reasoning (code to validate identifiers) up into global correctness.<p>This is a pretty FP and&#x2F;or Rust way to look at things, but I think it&#x27;s the essence of what makes encapsulation valuable.</div><br/><div id="42512492" class="c"><input type="checkbox" id="c-42512492" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512397">parent</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42512492">[-]</label><label class="expand" for="c-42512492">[2 more]</label></div><br/><div class="children"><div class="content">What you’re talking about is good design but has nothing to do with encapsulation. From Wikipedia:<p>&gt; In software systems, encapsulation refers to the bundling of data with the mechanisms or methods that operate on the data. It may also refer to the limiting of direct access to some of that data, such as an object&#x27;s components. Essentially, encapsulation prevents external code from being concerned with the internal workings of an object.<p>You could use encapsulation to enforce only valid states, but there are many ways to do that.</div><br/><div id="42512758" class="c"><input type="checkbox" id="c-42512758" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512492">parent</a><span>|</span><a href="#42511616">next</a><span>|</span><label class="collapse" for="c-42512758">[-]</label><label class="expand" for="c-42512758">[1 more]</label></div><br/><div class="children"><div class="content">Well whatever that is, that&#x27;s what I like :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42511616" class="c"><input type="checkbox" id="c-42511616" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511953">prev</a><span>|</span><a href="#42511776">next</a><span>|</span><label class="collapse" for="c-42511616">[-]</label><label class="expand" for="c-42511616">[1 more]</label></div><br/><div class="children"><div class="content">In theory, you could design a parallel set of software engineering best practices which emphasize long-term memory of the codebase over short-term ability to leaf through and understand it. I guess that would be &quot;reasoning nonlocally&quot; in a useful sense.<p>In practice I think the only time this would be seen as a potentially good thing by most devs is if it was happening in heavily optimized code.</div><br/></div></div><div id="42511776" class="c"><input type="checkbox" id="c-42511776" checked=""/><div class="controls bullet"><span class="by">708145_</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511616">prev</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42511776">[-]</label><label class="expand" for="c-42511776">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The main benefit of Liskov&#x27;s substitution principle is ensure developers don&#x27;t need to dig into each and every concrete implementation to be able to reason locally about the code.<p>Yeah, but doesn&#x27;t help in this context (enable local reasoning) if the objects passed around have too much magic or are mutated all over the place. The enterprise OOP from 2010s was a clusterfuck full of unexpected side effects.</div><br/><div id="42511863" class="c"><input type="checkbox" id="c-42511863" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511776">parent</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42511863">[-]</label><label class="expand" for="c-42511863">[2 more]</label></div><br/><div class="children"><div class="content">I suspect that enterprise anything is going to be a hot mess, just because enterprises can&#x27;t hire many of the best people. Probably the problem we should address as an industry is: how to produce software with mostly low wattage people.</div><br/><div id="42512068" class="c"><input type="checkbox" id="c-42512068" checked=""/><div class="controls bullet"><span class="by">brokencode</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511863">parent</a><span>|</span><a href="#42512698">next</a><span>|</span><label class="collapse" for="c-42512068">[-]</label><label class="expand" for="c-42512068">[1 more]</label></div><br/><div class="children"><div class="content">The eventual solution will probably be to replace the low wattage people with high wattage machines.</div><br/></div></div></div></div></div></div><div id="42512698" class="c"><input type="checkbox" id="c-42512698" checked=""/><div class="controls bullet"><span class="by">6510</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42511578">parent</a><span>|</span><a href="#42511776">prev</a><span>|</span><a href="#42512571">next</a><span>|</span><label class="collapse" for="c-42512698">[-]</label><label class="expand" for="c-42512698">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity I sometimes rewrite things as spaghetti (if functions are short and aren&#x27;t called frequently) or using globals (if multiple functions have to many params) it usually doesn&#x27;t look better and when it does it usually doesn&#x27;t stay that way for very long. In the very few remaining cases I&#x27;m quite happy with it. It does help me think about what is going on.</div><br/></div></div></div></div><div id="42512571" class="c"><input type="checkbox" id="c-42512571" checked=""/><div class="controls bullet"><span class="by">jreback</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511578">prev</a><span>|</span><a href="#42513570">next</a><span>|</span><label class="collapse" for="c-42512571">[-]</label><label class="expand" for="c-42512571">[2 more]</label></div><br/><div class="children"><div class="content">Re: trust issues...I&#x27;d argue this is the purpose of automated tests. I think tests are too often left out of architectural discussions as if they are some additional artifact that gets created separately from the running software. The core &#x2F; foundational &#x2F; heavily reused parts of the architecture should have the most tests and ensure the consumers of those parts has no trust issues!</div><br/><div id="42513959" class="c"><input type="checkbox" id="c-42513959" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42512571">parent</a><span>|</span><a href="#42513570">next</a><span>|</span><label class="collapse" for="c-42513959">[-]</label><label class="expand" for="c-42513959">[1 more]</label></div><br/><div class="children"><div class="content">Tests are good but moving left by lifting invariants into the type system is better.<p>Compare<p><pre><code>   fn send_email(addr: &amp;str, subject: &amp;str, body: &amp;str) -&gt; Result&lt;()&gt;
</code></pre>
to<p><pre><code>    fn send_email(add: &amp;EmailAddr, subject: &amp;str, body: &amp;str) -&gt; Result&lt;()&gt;
</code></pre>
In the second case, the edge cases of an empty or invalid email address don&#x27;t need to be tested, they are statically impossible.</div><br/></div></div></div></div><div id="42513570" class="c"><input type="checkbox" id="c-42513570" checked=""/><div class="controls bullet"><span class="by">holri</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512571">prev</a><span>|</span><a href="#42512568">next</a><span>|</span><label class="collapse" for="c-42513570">[-]</label><label class="expand" for="c-42513570">[2 more]</label></div><br/><div class="children"><div class="content">I do not agree that typing leads to less cognitive load.
Typing often leads to more and more complicated code.
Dynamically typed code is often shorter and more compact.
If dynamically typed code is well written, its function, inputs and outputs are clear and obvious.
Clear and easy to understand code is not primarily a matter of typed or not typed code, it is a matter of a great programmer or a poor one.</div><br/><div id="42513619" class="c"><input type="checkbox" id="c-42513619" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513570">parent</a><span>|</span><a href="#42512568">next</a><span>|</span><label class="collapse" for="c-42513619">[-]</label><label class="expand" for="c-42513619">[1 more]</label></div><br/><div class="children"><div class="content">This is true at smaller scales and flips over on larger scales (larger codebase, dependencies, team&#x2F;teams sizes).</div><br/></div></div></div></div><div id="42512568" class="c"><input type="checkbox" id="c-42512568" checked=""/><div class="controls bullet"><span class="by">casenmgreen</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42513570">prev</a><span>|</span><a href="#42513498">next</a><span>|</span><label class="collapse" for="c-42512568">[-]</label><label class="expand" for="c-42512568">[1 more]</label></div><br/><div class="children"><div class="content">I may be wrong, but my view of software is : you have functions, and you have the order in which functions are called.  Any given function is straightforward enough, if you define its function clearly and keep it small enough - both of which can reasonably be done.  Then we have the problem, which is the main problem, of the order in which functions are called.  For this, I use a state machine.  Write out the state machine, in full, in text, and then implement it directly, one function per state, one function per state transition.<p>The SM design doc is the documentation of the order of function calling, it is exhaustive and correct, and allows for straightforward changes in future (at least, as straightforward as possible - it is always a challenge to make changes).</div><br/></div></div><div id="42513498" class="c"><input type="checkbox" id="c-42513498" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42512568">prev</a><span>|</span><a href="#42513262">next</a><span>|</span><label class="collapse" for="c-42513498">[-]</label><label class="expand" for="c-42513498">[1 more]</label></div><br/><div class="children"><div class="content">In regards to small functions, I think an important - but not often mentioned - aspect is shared assumptions. You can have many small functions with garbage abstractions that each implictly rely on the behaviour of each other - therefore the cognitive load is high. Or, you can have many small functions which are truly well-contained, in which case you may well need not read the implementation. Far too much code falls into the former scenario, IMO.</div><br/></div></div><div id="42513262" class="c"><input type="checkbox" id="c-42513262" checked=""/><div class="controls bullet"><span class="by">mattmcknight</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42513498">prev</a><span>|</span><a href="#42511974">next</a><span>|</span><label class="collapse" for="c-42513262">[-]</label><label class="expand" for="c-42513262">[3 more]</label></div><br/><div class="children"><div class="content">Types? &quot;Option&lt;HashSet&lt;UserId&gt;&gt;&quot; means almost nothing to me. A well defined domain model should indicate what that structure represents.</div><br/><div id="42513987" class="c"><input type="checkbox" id="c-42513987" checked=""/><div class="controls bullet"><span class="by">jbggs</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513262">parent</a><span>|</span><a href="#42513294">next</a><span>|</span><label class="collapse" for="c-42513987">[-]</label><label class="expand" for="c-42513987">[1 more]</label></div><br/><div class="children"><div class="content">it seems like you&#x27;re just not familiar with the domains defined by those types, or at least the names used here</div><br/></div></div><div id="42513294" class="c"><input type="checkbox" id="c-42513294" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#42511276">root</a><span>|</span><a href="#42513262">parent</a><span>|</span><a href="#42513987">prev</a><span>|</span><a href="#42511974">next</a><span>|</span><label class="collapse" for="c-42513294">[-]</label><label class="expand" for="c-42513294">[1 more]</label></div><br/><div class="children"><div class="content">Even that means a lot more than `{}`, who&#x27;s tortured journeys I have to painstakingly take notes om in the source code while I wonder what the heck happened to produce the stack trace...</div><br/></div></div></div></div><div id="42511974" class="c"><input type="checkbox" id="c-42511974" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42513262">prev</a><span>|</span><a href="#42511733">next</a><span>|</span><label class="collapse" for="c-42511974">[-]</label><label class="expand" for="c-42511974">[1 more]</label></div><br/><div class="children"><div class="content">This is absolutely the right way to think about things.<p>I like thinking about local reasoning in terms of (borrowing from Ed Page) &quot;units of controversy&quot;. For example, I like using newtypes for identifiers, because &quot;what strings are permitted to be identifiers&quot; is a unit of controversy.</div><br/></div></div><div id="42511733" class="c"><input type="checkbox" id="c-42511733" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511974">prev</a><span>|</span><a href="#42511654">next</a><span>|</span><label class="collapse" for="c-42511733">[-]</label><label class="expand" for="c-42511733">[1 more]</label></div><br/><div class="children"><div class="content">The larger problem are things that have global effect: databases, caches, files, static memory, etc.  Or protocols between different systems.  These are hard to abstract away, usually because of shared state.</div><br/></div></div><div id="42511654" class="c"><input type="checkbox" id="c-42511654" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511733">prev</a><span>|</span><a href="#42511929">next</a><span>|</span><label class="collapse" for="c-42511654">[-]</label><label class="expand" for="c-42511654">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen functions called getValue() that were actually creating files on disk and writing stuff.<p>Also, even if the function actually does what advertised, I&#x27;ve seen functions that go 4-5 levels deep where the outer functions are just abstracting optional parameters. So to avoid exposing 3 or 4 parameters, tens of functions are created instead.<p>I think you do have a point but ideas get abused a lot.</div><br/></div></div><div id="42511929" class="c"><input type="checkbox" id="c-42511929" checked=""/><div class="controls bullet"><span class="by">peterlada</span><span>|</span><a href="#42511276">parent</a><span>|</span><a href="#42511654">prev</a><span>|</span><a href="#42510866">next</a><span>|</span><label class="collapse" for="c-42511929">[-]</label><label class="expand" for="c-42511929">[1 more]</label></div><br/><div class="children"><div class="content">There is an issue of reading a code that is written by somebody else. If it&#x27;s not in a common style, the cognitive load of parsing how it&#x27;s done is an overhead.<p>The reason I used to hate Perl was around this, everyone had a unique way of using Perl and it had many ways to do the same thing.<p>The reason I dislike functional programming is around the same, you can skin the cat 5 ways, then all 5 engineers will pick a different way of writing that in Typescript.<p>The reason I like Python more is that all experienced engineers will eventually gravitate towards the idea of Pythonic notion and I&#x27;ve had colleagues whose code looked identical to how I&#x27;d have written it.</div><br/></div></div></div></div><div id="42510866" class="c"><input type="checkbox" id="c-42510866" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#42511276">prev</a><span>|</span><a href="#42510573">next</a><span>|</span><label class="collapse" for="c-42510866">[-]</label><label class="expand" for="c-42510866">[71 more]</label></div><br/><div class="children"><div class="content">&gt; Mantras like &quot;methods should be shorter than 15 lines of code&quot; or &quot;classes should be small&quot; turned out to be somewhat wrong.<p>These hard rules may be useful when trying to instill good habits in juniors, but they become counterproductive when you start constraining experienced developers with arbitrary limits.<p>It’s really bad when you join a team that enforces rules like this. It almost always comes from a lead or manager who reads too many business books and then cargo cults those books on to the team.</div><br/><div id="42510935" class="c"><input type="checkbox" id="c-42510935" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42512167">next</a><span>|</span><label class="collapse" for="c-42510935">[-]</label><label class="expand" for="c-42510935">[60 more]</label></div><br/><div class="children"><div class="content">This is the bane of my existence at the moment after ~20 years into my career, and it frustrates me when I run into these situations when trying to get certain people to review pull requests (because I&#x27;m being kind, and adhering to a process, and there is really valuable feedback at times). But on the whole it&#x27;s like being dragged back down to working at a snails pace.<p>- Can&#x27;t refactor code because it changes too many files and too many lines.<p>- Can&#x27;t commit large chunks of well tested code that &#x27;Does feature X&#x27;, because... too many files and too many lines.<p>- Have to split everything down into a long sequence of consecutive pull requests that become a process nightmare in its own right<p>- The documentation comments gets nitpicked to death with mostly useless comments about not having periods at the ends of lines<p>- End up having to explain every little detail throughout the function as if I&#x27;m trying to produce a lecture, things like `&#x2F;* loop until not valid *&#x2F; while (!valid) {...` seemed to be what they wanted, but to me it made no sense what so ever to even have that comment<p>This can turn a ~50 line function into a 3 day process, a couple of hundred lines into a multi-week process, and a thousand or two line refactor (while retaining full test coverage) into a multi-month process.<p>At one point I just downed tools and quit the company, the absurdity of it all completely drained my motivation, killed progress &amp; flow and lead to features not being shipped.<p>Meanwhile with projects I&#x27;m managing I have a fairly good handle on &#x27;ok this code isnt the best, but it does work, it is fairly well tested, and it will be shipped as the beta&#x27;, so as to not be obstinate.</div><br/><div id="42512773" class="c"><input type="checkbox" id="c-42512773" checked=""/><div class="controls bullet"><span class="by">charlie0</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512575">next</a><span>|</span><label class="collapse" for="c-42512773">[-]</label><label class="expand" for="c-42512773">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m one of the rare individuals who really tries to review code and leave helpful comments. I&#x27;ve been on the receiving end of really big PRs and can say I understand why you&#x27;re being told to break things up into smaller chunks.<p>Most of the devs who submit large PRs just don&#x27;t have a good grasp of organizing things well enough. I&#x27;ve seen this over and over again and it&#x27;s due to not spending enough time planning out a feature. There will be exceptions to this, but when devs keep doing it over and over, it&#x27;s the reviewer&#x27;s job to reject it and send it back with helpful feedback.<p>I also understand most people don&#x27;t like the friction this can create and so you end you with 80% of PRs being rubber stamped and bugs getting into production because the reviewers just give up on trying to make people better devs.</div><br/></div></div><div id="42512575" class="c"><input type="checkbox" id="c-42512575" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512773">prev</a><span>|</span><a href="#42511011">next</a><span>|</span><label class="collapse" for="c-42512575">[-]</label><label class="expand" for="c-42512575">[3 more]</label></div><br/><div class="children"><div class="content">After 20 years of doing this, I’m convinced that required PR reviews aren’t worth the cost.<p>In the thousands of pull requests I’ve merged across many companies, I have never once had a reviewer catch a major bug (a bug that is severe enough that if discovered after hours, would require an oncall engineer to push a hot fix rather than wait for the normal deployment process to fix it).<p>I’ve pushed a few major bugs to production, but I’ve never had a PR reviewer catch one.<p>I’ve had reviewers make excellent suggestions, but it’s almost never anything that really matters. Certainly not worth all the time I’ve spent on the process.<p>That being said, I’m certainly not against collaboration, but I think required PR reviews aren’t the way to do it.</div><br/><div id="42512907" class="c"><input type="checkbox" id="c-42512907" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42513303">next</a><span>|</span><label class="collapse" for="c-42512907">[-]</label><label class="expand" for="c-42512907">[1 more]</label></div><br/><div class="children"><div class="content">Wow someone who finally has this same unpopular opinion as I do. I&#x27;m a huge fan of review-optional PRs. Let it be up to the author to make that call and if it were really important to enforce it would be more foolproof to do so with automation.<p>Unfortunately every time I&#x27;ve proposed this it&#x27;s received like it&#x27;s sacrilegious but nobody could tell me why PR reviews are really necessary to be required.<p>The most ironic part is that I once caught a production-breaking bug in a PR while at FAANG and the author pushed back. Ultimately I decided it wasn&#x27;t worth the argument and just let it go through. Unsurprisingly, it broke production but we fixed it very quickly after we were all finally aligned that it was actually a problem.</div><br/></div></div><div id="42513303" class="c"><input type="checkbox" id="c-42513303" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512575">parent</a><span>|</span><a href="#42512907">prev</a><span>|</span><a href="#42511011">next</a><span>|</span><label class="collapse" for="c-42513303">[-]</label><label class="expand" for="c-42513303">[1 more]</label></div><br/><div class="children"><div class="content">The point of code reviews isn’t to catch bugs. It’s for someone else on the team to read your code and make sure they can understand it. If no one else on your team can understand your code, you shouldn’t be committing it to the repository.</div><br/></div></div></div></div><div id="42511011" class="c"><input type="checkbox" id="c-42511011" checked=""/><div class="controls bullet"><span class="by">NotBoolean</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512575">prev</a><span>|</span><a href="#42511510">next</a><span>|</span><label class="collapse" for="c-42511011">[-]</label><label class="expand" for="c-42511011">[23 more]</label></div><br/><div class="children"><div class="content">I don’t have your experience but I personally think some of this feedback can be warranted.<p>&gt; Can&#x27;t refactor code because it changes too many files and too many lines.<p>This really depends on the change. If you are just doing a mass rename like updating a function signature, fair enough but if you changing a lot of code it’s very hard to review it. Lots of cognitive load on the reviewer who might not have the same understanding of codebase as you.<p>&gt; Can&#x27;t commit large chunks of well tested code that &#x27;Does feature X&#x27;, because... too many files and too many lines.<p>Same as the above, reviewing is hard and more code means people get lazy and bored. Just because the code is tested doesn’t mean it’s correct, just means it passes tests.<p>&gt; Have to split everything down into a long sequence of consecutive pull requests that become a process nightmare in its own right<p>This is planning issue, if you correctly size tickets you aren’t going to end up in messy situations as often.<p>&gt; The documentation comments gets nitpicked to death with mostly useless comments about not having periods at the ends of lines<p>Having correctly written documentation is important. It can live a long time and if you don’t keep an eye on it can becomes a mess. Ideally you should review it before you submitting it to avoid these issues.<p>&gt; End up having to explain every little detail throughout the function as if I&#x27;m trying to produce a lecture, things like `&#x2F;* loop until not valid *&#x2F; while (!valid) {...` seemed to be what they wanted, but to me it made no sense what so ever to even have that comment<p>I definitely agree with this one. Superfluous comments are a waste of time.<p>Obviously this is just my option and you can take things too far but I do think that making code reviewable (by making it small) goes a long way. No one wants to review 1000s lines of code at once. It’s too much to process and people will do a worse job.<p>Happy to hear your thoughts.</div><br/><div id="42511206" class="c"><input type="checkbox" id="c-42511206" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511056">next</a><span>|</span><label class="collapse" for="c-42511206">[-]</label><label class="expand" for="c-42511206">[12 more]</label></div><br/><div class="children"><div class="content">&gt; This is planning issue, if you correctly size tickets you aren’t going to end up in messy situations as often.<p>No, it’s “this refactor looks very different to the original code because the original code thought it was doing two different things and it’s only by stepping through it with real customer data that you realized with the right inputs (not documented) it could do a third thing (not documented) that had very important “side effects” and was a no-op in the original code flow. Yea, it touches a lot of files. Ok, yea, I can break it up step by step, and wait a few days between approval for each of them so that you never have to actually understand what just happened”.</div><br/><div id="42511383" class="c"><input type="checkbox" id="c-42511383" checked=""/><div class="controls bullet"><span class="by">grey-area</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511206">parent</a><span>|</span><a href="#42511644">next</a><span>|</span><label class="collapse" for="c-42511383">[-]</label><label class="expand" for="c-42511383">[4 more]</label></div><br/><div class="children"><div class="content">The way I normally approach this is one big pr for context and then break it into lots of small ones for review.</div><br/><div id="42511852" class="c"><input type="checkbox" id="c-42511852" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511383">parent</a><span>|</span><a href="#42511832">next</a><span>|</span><label class="collapse" for="c-42511852">[-]</label><label class="expand" for="c-42511852">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found processes like this to work better, too. Basically, the one big pr is like building a prototype to throw away. And the benefit is it has to get thrown away because the PR will never pass review.</div><br/></div></div><div id="42511832" class="c"><input type="checkbox" id="c-42511832" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511383">parent</a><span>|</span><a href="#42511852">prev</a><span>|</span><a href="#42511644">next</a><span>|</span><label class="collapse" for="c-42511832">[-]</label><label class="expand" for="c-42511832">[2 more]</label></div><br/><div class="children"><div class="content">A PR with self-contained smaller commits would be possible as well.</div><br/><div id="42512148" class="c"><input type="checkbox" id="c-42512148" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511832">parent</a><span>|</span><a href="#42511644">next</a><span>|</span><label class="collapse" for="c-42512148">[-]</label><label class="expand" for="c-42512148">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though it does depend on how good the commenting system is; and, for something like that, you&#x27;re still probably going to want a meeting to walk people through such a huge change.<p>And you&#x27;d better hope you&#x27;re not squashing that monstrous thing when you&#x27;re done.</div><br/></div></div></div></div></div></div><div id="42511644" class="c"><input type="checkbox" id="c-42511644" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511206">parent</a><span>|</span><a href="#42511383">prev</a><span>|</span><a href="#42512455">next</a><span>|</span><label class="collapse" for="c-42511644">[-]</label><label class="expand" for="c-42511644">[5 more]</label></div><br/><div class="children"><div class="content">so, it&#x27;s not just a refactoring then; it&#x27;s also bug fixes + refactoring. In my experience, those are the worst PRs to review. Either just fix the bugs, or just refactor it. Don&#x27;t do both because now I have to spend more time checking the bugs you claim to fix AND your refactoring for new bugs.</div><br/><div id="42511759" class="c"><input type="checkbox" id="c-42511759" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511644">parent</a><span>|</span><a href="#42512455">next</a><span>|</span><label class="collapse" for="c-42511759">[-]</label><label class="expand" for="c-42511759">[4 more]</label></div><br/><div class="children"><div class="content">There are certainly classes of bugs for which refactoring is the path of lowest resistance</div><br/><div id="42512215" class="c"><input type="checkbox" id="c-42512215" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511759">parent</a><span>|</span><a href="#42512139">next</a><span>|</span><label class="collapse" for="c-42512215">[-]</label><label class="expand" for="c-42512215">[2 more]</label></div><br/><div class="children"><div class="content">The most common IME are bugs that come from some wrong conceptual understanding underpinning the code. Rewriting the code with a correct conceptual understanding automatically fixes the bugs.</div><br/><div id="42512476" class="c"><input type="checkbox" id="c-42512476" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512215">parent</a><span>|</span><a href="#42512139">next</a><span>|</span><label class="collapse" for="c-42512476">[-]</label><label class="expand" for="c-42512476">[1 more]</label></div><br/><div class="children"><div class="content">The classic example of this is concurrency errors or data corruption related to multiple non-atomic writes.</div><br/></div></div></div></div><div id="42512139" class="c"><input type="checkbox" id="c-42512139" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511759">parent</a><span>|</span><a href="#42512215">prev</a><span>|</span><a href="#42512455">next</a><span>|</span><label class="collapse" for="c-42512139">[-]</label><label class="expand" for="c-42512139">[1 more]</label></div><br/><div class="children"><div class="content">And there are multi-PR processes that can be followed to most successfully convert those changes in a comprehensible way.<p>It&#x27;ll often include extra scaffolding and &#x2F; or extra classes and then renaming those classes to match the old classes&#x27; name after you&#x27;re done, to reduce future cognitive load.</div><br/></div></div></div></div></div></div><div id="42512455" class="c"><input type="checkbox" id="c-42512455" checked=""/><div class="controls bullet"><span class="by">justatdotin</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511206">parent</a><span>|</span><a href="#42511644">prev</a><span>|</span><a href="#42511417">next</a><span>|</span><label class="collapse" for="c-42512455">[-]</label><label class="expand" for="c-42512455">[1 more]</label></div><br/><div class="children"><div class="content">&gt; only by stepping through it with real customer data that you realized with the right inputs (not documented) it could do a third thing (not documented) that had very important “side effects” and was a no-op in the original code flow<p>sounds like the &#x27;nightmare&#x27; was already there, not in the refactor. First step should be some tests to confirm the undocumented behaviour.<p>Some of your complaints seem to be about peer review (&#x27;approval&#x27;). I found my work life improved a lot once I embraced async review as a feature, not a bug.<p>As for &#x27;break it up step by step&#x27; - I know how much I appreciate reviewing a feature that is well presented in this way, and so I&#x27;ve got good at rearranging my work (when necessary) to facilitate smooth reviews.</div><br/></div></div></div></div><div id="42511056" class="c"><input type="checkbox" id="c-42511056" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511206">prev</a><span>|</span><a href="#42511300">next</a><span>|</span><label class="collapse" for="c-42511056">[-]</label><label class="expand" for="c-42511056">[7 more]</label></div><br/><div class="children"><div class="content">I do object to the notion of something being a planning issue when you&#x27;re talking about a days worth of work.<p>Implement X, needs Y and Z, ok that was straightforward, also discovered U and V on the way and sorted that out, here&#x27;s a pull request that neatly wraps it up.<p>Which subsequently gets turned into a multi-week process, going back &amp; forth almost every day, meaning I can&#x27;t move on to the next thing, meanwhile I&#x27;m looking at the cumulative hourly wages of everybody involved and the cost is... shocking.<p>Death by process IHMO.</div><br/><div id="42511222" class="c"><input type="checkbox" id="c-42511222" checked=""/><div class="controls bullet"><span class="by">bspammer</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511056">parent</a><span>|</span><a href="#42512490">next</a><span>|</span><label class="collapse" for="c-42511222">[-]</label><label class="expand" for="c-42511222">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Implement X, needs Y and Z, ok that was straightforward, also discovered U and V on the way and sorted that out, here&#x27;s a pull request that neatly wraps it up<p>This sounds very difficult to review to be honest. At a minimum unrelated changes should be in their own pull request (U and V in your example).</div><br/><div id="42512557" class="c"><input type="checkbox" id="c-42512557" checked=""/><div class="controls bullet"><span class="by">tacitusarc</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511222">parent</a><span>|</span><a href="#42512114">next</a><span>|</span><label class="collapse" for="c-42512557">[-]</label><label class="expand" for="c-42512557">[2 more]</label></div><br/><div class="children"><div class="content">I work as a tech lead, so I get a lot of leeway in setting process. For small PRs, we use the normal “leave comments, resolve comments” approach. For large PRs, we schedule 30m  meetings, where the submitter can explain the changes and answer questions, and record any feedback. This ensures everyone is on the same page with the changes, gives folks a chance to rapidly gather feedback, and helps familiarize devs who do not work in that area with what is going on. If the meeting is insufficient to feel like everyone is on the same page and approves the changes, we schedule another one.<p>These are some of the best meetings we have. They are targeted, educational, and ensure we don’t have long delays waiting for code to go in. Instead of requiring every PR to be small, which has a high cost, I recommend doing this for large&#x2F;complex projects.<p>One additional thing to note on small PRs: often, they require significant context, which could take hours or even days, to be built up repeatedly. Contrast that with being able to establish context, and then solve several large problems all at once. The latter is more efficient, so if it can be enabled without negative side effects, it is really valuable.<p>I want my team to be productive, and I want to empower them to improve the codebase whenever they see an opportunity, even if it is not related to their immediate task.</div><br/><div id="42512610" class="c"><input type="checkbox" id="c-42512610" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512557">parent</a><span>|</span><a href="#42512114">next</a><span>|</span><label class="collapse" for="c-42512610">[-]</label><label class="expand" for="c-42512610">[1 more]</label></div><br/><div class="children"><div class="content">One minor piece of insight from me is about release management vs pull-requests.<p>As you say it&#x27;s much easier to schedule a 30 minute meeting, then we can - with context - resolve any immediate nitpicks you have, but we can also structure bigger things.<p>&#x27;Would this block a release?&#x27;<p>&#x27;Can we just get this done in the PR and merge it&#x27;<p>&#x27;Ok, so when it&#x27;s done... what is the most important thing that we need to document?&#x27;<p>Where the fact that even after it&#x27;s merged, it&#x27;s going to sit in the repo for a while until we decide to hit the &#x27;release&#x27; button&#x27;, this lets people defer stuff to work on next and defines a clear line of &#x27;good enough&#x27;</div><br/></div></div></div></div><div id="42512114" class="c"><input type="checkbox" id="c-42512114" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511222">parent</a><span>|</span><a href="#42512557">prev</a><span>|</span><a href="#42511366">next</a><span>|</span><label class="collapse" for="c-42512114">[-]</label><label class="expand" for="c-42512114">[1 more]</label></div><br/><div class="children"><div class="content">How do you rework a core process, then? If you rework a major unit that touches just about everything... Sharding something like that can break the actual improvement it is trying to deliver.<p>Like... Increase the performance of a central VM. You&#x27;ll touch every part of the code, but probably also build a new compiler analysis system. The system is seperate to existing code, but useless without the core changes. Seperating the two can ruin the optimisation meant to be delivered, because the context is no longer front and center. Allowing more quibling to degrade the changes.</div><br/></div></div><div id="42511366" class="c"><input type="checkbox" id="c-42511366" checked=""/><div class="controls bullet"><span class="by">pbh101</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511222">parent</a><span>|</span><a href="#42512114">prev</a><span>|</span><a href="#42512490">next</a><span>|</span><label class="collapse" for="c-42511366">[-]</label><label class="expand" for="c-42511366">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Another item here that is contextual: what is the cost of a bug? Does it cost millions, do we find that out immediately, or does it take months? Or does it not really matter, and when we’ll find the big it will be cheap?  The OP joining a new company might not have the context that existing employees have about why we’re being cautious&#x2F;clear about what we’re changing as opposed to smuggling in refactors in the same PR as a feature change.<p>I’m going to be the guy that is asking for a refactor to be in a separate commit&#x2F;PR from the feature and clearly marked.<p>It doesn’t justify everything else he mentioned (especially the comments piece) but once you get used to this it doesn’t need to extend timelines.</div><br/></div></div></div></div><div id="42512490" class="c"><input type="checkbox" id="c-42512490" checked=""/><div class="controls bullet"><span class="by">justatdotin</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511056">parent</a><span>|</span><a href="#42511222">prev</a><span>|</span><a href="#42511300">next</a><span>|</span><label class="collapse" for="c-42512490">[-]</label><label class="expand" for="c-42512490">[1 more]</label></div><br/><div class="children"><div class="content">Yes, wrapping other discoveries into your feature work is a planning issue that might impact on the review burden.</div><br/></div></div></div></div><div id="42511300" class="c"><input type="checkbox" id="c-42511300" checked=""/><div class="controls bullet"><span class="by">callc</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511056">prev</a><span>|</span><a href="#42512316">next</a><span>|</span><label class="collapse" for="c-42511300">[-]</label><label class="expand" for="c-42511300">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is planning issue, if you correctly size tickets you aren’t going to end up in messy situations as often.<p>I think the underlying issue is what is an appropriate “unit of work”. Parent commenter may want to ship a complete&#x2F;entire feature in one MR. Ticketing obsessed people will have some other metric. Merge process may be broken in this aspect. I would rather explain to reviewer to bring them up to speed on the changes to make their cognitive load easier</div><br/><div id="42511708" class="c"><input type="checkbox" id="c-42511708" checked=""/><div class="controls bullet"><span class="by">gjadi</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511300">parent</a><span>|</span><a href="#42512316">next</a><span>|</span><label class="collapse" for="c-42511708">[-]</label><label class="expand" for="c-42511708">[1 more]</label></div><br/><div class="children"><div class="content">This. The solution to long and multiple reviews to MR is single pair review session where most of the big picture aspects can be addressed immediately and verbally discussed and challenged.<p>IMHO it is the same as chat. If talking about an issue over mail or chat takes more than 3-5 messages, trigger a call to solve it face to face.</div><br/></div></div></div></div><div id="42512316" class="c"><input type="checkbox" id="c-42512316" checked=""/><div class="controls bullet"><span class="by">8note</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511011">parent</a><span>|</span><a href="#42511300">prev</a><span>|</span><a href="#42511510">next</a><span>|</span><label class="collapse" for="c-42512316">[-]</label><label class="expand" for="c-42512316">[1 more]</label></div><br/><div class="children"><div class="content">code reviews that are too small, i think are worse than ones that are too big, and let through more bugs.<p>10 different reviewers can each look at a 100 lin change out of the 1000 line total change, but each miss how the changes work together.<p>theyre all lying by approving, since they dont have the right context to approve</div><br/></div></div></div></div><div id="42511510" class="c"><input type="checkbox" id="c-42511510" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511011">prev</a><span>|</span><a href="#42511471">next</a><span>|</span><label class="collapse" for="c-42511510">[-]</label><label class="expand" for="c-42511510">[8 more]</label></div><br/><div class="children"><div class="content">I’m 15 years in and I feel basically the same. I end up making a feature or change, then going back and trying to split it into chunks that are digestible to my colleagues. I’ve got thousands of lines of staged changes that I’m waiting to drip out to people at a digestible pace.<p>I yearn for the early stage startup where every commit is a big change and my colleagues are used to reviewing this, and I can execute at my actual pace.<p>It’s really changed the way I think about software in general, I’ve come around to Rich Hickey’s radically simple language Clojure, because types bloat the refactors I’m doing.<p>I’d love to have more of you where I work, is there some way I can see your work and send some job descriptions and see if you’re interested?</div><br/><div id="42511620" class="c"><input type="checkbox" id="c-42511620" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511510">parent</a><span>|</span><a href="#42511851">next</a><span>|</span><label class="collapse" for="c-42511620">[-]</label><label class="expand" for="c-42511620">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I end up making a feature or change, then going back and trying to split it into chunks that are digestible to my colleagues.<p>If you are doing this AFTER you&#x27;ve written the code, it is probably way easier to do it as you go. It&#x27;s one thing if you have no idea what the code will look like from the beginning -- just go ahead and open the big PR and EXPLAIN WHY. I know that I&#x27;m more than happy to review a big PR if I understand why it has to be big.<p>I will be annoyed if I see a PR that is a mix of refactoring, bug fixes, and new features. You can (and should) have done those all as separate PRs (and tickets). If you need to refactor something, refactor it, and open a PR. It doesn&#x27;t take that long and there&#x27;s no need to wait until your huge PR is ready.</div><br/><div id="42511737" class="c"><input type="checkbox" id="c-42511737" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511620">parent</a><span>|</span><a href="#42512001">next</a><span>|</span><label class="collapse" for="c-42511737">[-]</label><label class="expand" for="c-42511737">[2 more]</label></div><br/><div class="children"><div class="content">Solving creative problems is often iterative, and one things I&#x27;m very concerned about when doing engineering management is maintaining momentum and flow. Looking at latency hierarchies is a really good example, you have registers, then cache, then memory, SSD, network etc. and consulting with another human asynchronously is like sending a message to Jupiter (in the best case).<p>So, with an iterative process, the more times you introduce (at best) hour long delays, you end up sitting on your arse twiddling your thumbs doing nothing, until the response comes back.<p>The concept of making PRs as you go fails to capture one of the aspects of low-latency problem solving, which is that you catch a problem, you correct it and you <i>revise it</i> locally, without exiting that loop. Which is problematic because not only have you put yourself in a situation where you&#x27;re waiting for a response, but you&#x27;ve stopped half-way through an unfinished idea.<p>This comes back to &#x27;is it done&#x27;, a gut feel that it&#x27;s an appropriate time to break the loop and incur the latency cost, which for every developer will be different and is something that I have grown to deeply trust and and adjust to for everybody I work with.<p>What I&#x27;m getting at is the iterative problem solving process often can&#x27;t be neatly dissected into discrete units while it&#x27;s happening, and after we&#x27;ve reached the &#x27;doneness&#x27; point it takes much more work to undo part of your work and re-do it than it took to do originally, so not only do you have the async overhead of every interaction, but you have the cognitive burden of untangling what was previously a cohesive unit of thought - which again is another big time killer</div><br/><div id="42513572" class="c"><input type="checkbox" id="c-42513572" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511737">parent</a><span>|</span><a href="#42512001">next</a><span>|</span><label class="collapse" for="c-42513572">[-]</label><label class="expand" for="c-42513572">[1 more]</label></div><br/><div class="children"><div class="content">What I mean is, you make your commit, cherry pick it over to the main branch, and open a draft pr. It doesn&#x27;t break your flow, it doesn&#x27;t stop anything, and is pretty quick. It also gives you a quick gut-check to see the PR; if you think your team members won&#x27;t understand &quot;why&quot; it needs to be refactored, then you have one of two problems:<p>1. your refactoring is probably going in the wrong direction. Team members will be able to help here more than ever. Let them bikeshed, but don&#x27;t stop working on your main refactor yet. Revist later and integrate their changes.<p>2. the PR is too small. it will have to be part of a larger PR.<p>In my experience, people tend to have the first problem, and not the second one, but they think they have the second one. There are many of these &quot;massive refactoring&quot; PRs I&#x27;ve reviewed over the last 20 years where the refactoring makes the code worse, overall. Why? Because refactoring towards a goal (implementing a feature, fixing a bug, etc.) doesn&#x27;t have the goal refactoring should have: improving code maintainability. So, the refactored code is usually LESS maintainable, but it does what they wanted.</div><br/></div></div></div></div><div id="42512001" class="c"><input type="checkbox" id="c-42512001" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511620">parent</a><span>|</span><a href="#42511737">prev</a><span>|</span><a href="#42511851">next</a><span>|</span><label class="collapse" for="c-42512001">[-]</label><label class="expand" for="c-42512001">[2 more]</label></div><br/><div class="children"><div class="content">If you make refactor PRs as you go, do you end up merging redactors towards a dead end and then--once you realize it&#x27;s a dead end--merging even more refractors in the other direction?<p>I usually wait until I have the big PR done and then merge redactors towards it because then at least I know the road I&#x27;m paving has a workable destination.</div><br/><div id="42512131" class="c"><input type="checkbox" id="c-42512131" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512001">parent</a><span>|</span><a href="#42511851">next</a><span>|</span><label class="collapse" for="c-42512131">[-]</label><label class="expand" for="c-42512131">[1 more]</label></div><br/><div class="children"><div class="content">This is why I design the heckin&#x27; huge change at the start, and then cherry pick the actual change (and associated tests) into a ton of smaller PRs, including &quot;refactor here&quot;, &quot;make this function + tests&quot;, &quot;make this class + tests&quot;, &quot;integrate the code + tests&quot;, and so on, as many times as necessary to have testable and reviewable units of code.<p>If I went about and made a ton of changes that all went into dead ends, honestly, I would get pretty demoralized and I think my team would get annoyed, especially if I then went through and rolled back many of those changes as not ending up being necessary.</div><br/></div></div></div></div></div></div><div id="42511851" class="c"><input type="checkbox" id="c-42511851" checked=""/><div class="controls bullet"><span class="by">hellisothers</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511510">parent</a><span>|</span><a href="#42511620">prev</a><span>|</span><a href="#42511471">next</a><span>|</span><label class="collapse" for="c-42511851">[-]</label><label class="expand" for="c-42511851">[2 more]</label></div><br/><div class="children"><div class="content">These same people also want to see your GitHub history filled with deep green come review time.  I start to wonder if they think high levels of GitHub activity is a proxy of performance or if it’s a proxy of plying the game the way they insist you play.</div><br/><div id="42512916" class="c"><input type="checkbox" id="c-42512916" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511851">parent</a><span>|</span><a href="#42511471">next</a><span>|</span><label class="collapse" for="c-42512916">[-]</label><label class="expand" for="c-42512916">[1 more]</label></div><br/><div class="children"><div class="content">Dunno where you get that from, but that was not my intent and is not a metric I use to judge who I’d like to be my coworkers.</div><br/></div></div></div></div></div></div><div id="42511471" class="c"><input type="checkbox" id="c-42511471" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511510">prev</a><span>|</span><a href="#42511212">next</a><span>|</span><label class="collapse" for="c-42511471">[-]</label><label class="expand" for="c-42511471">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The documentation comments gets nitpicked to death with mostly useless comments about not having periods at the ends of lines
&gt; End up having to explain every little detail throughout the function<p>For these cases I like to use the ‘suggest an edit’ feature on gitlab&#x2F;github. Can have the change queued up in the comments and batch commit together, and takes almost no additional time&#x2F;effort for the author. I typically add these suggestion comments and give an approve at the same time for small nitpicks, so no slow down in the PR process.</div><br/><div id="42511827" class="c"><input type="checkbox" id="c-42511827" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511471">parent</a><span>|</span><a href="#42511212">next</a><span>|</span><label class="collapse" for="c-42511827">[-]</label><label class="expand" for="c-42511827">[2 more]</label></div><br/><div class="children"><div class="content">I good process would be to just push the proposal to the branch in review.</div><br/><div id="42512293" class="c"><input type="checkbox" id="c-42512293" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511827">parent</a><span>|</span><a href="#42511212">next</a><span>|</span><label class="collapse" for="c-42512293">[-]</label><label class="expand" for="c-42512293">[1 more]</label></div><br/><div class="children"><div class="content">I still want to let the author have the final say on if they decide to accept or reject the change, or modify it further. Editing the branch directly might cause some rebasing&#x2F;merge conflicts if they’re addressing other peoples comments too, so I don&#x27;t typically edit their working branch directly unless they ask me to.</div><br/></div></div></div></div></div></div><div id="42511212" class="c"><input type="checkbox" id="c-42511212" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511471">prev</a><span>|</span><a href="#42511286">next</a><span>|</span><label class="collapse" for="c-42511212">[-]</label><label class="expand" for="c-42511212">[4 more]</label></div><br/><div class="children"><div class="content">I am trying my best to build in an <i>inordinate</i> amount of upfront linting and automated checks just to avoid such things - and then I still need to do a roadshow, or lots of explanations- but that’s probably good.<p>But the good idea is to say “we all have the same brutal linting standards (including full stops in docs!) - so hopefully the human linger will actually start reading the code for what it is, not what it says”</div><br/><div id="42511364" class="c"><input type="checkbox" id="c-42511364" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511212">parent</a><span>|</span><a href="#42512516">next</a><span>|</span><label class="collapse" for="c-42511364">[-]</label><label class="expand" for="c-42511364">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also a fan of linting everything. Custom linter rules ftw.<p>This and documenting non-lintable standards so that people are on the same page (&quot;we do controllers like this&quot;).<p>This is how I like to build and run my teams. This makes juniors so much more confident because they can ship stuff from the get go without going through a lengthy nitpicky brutal review process. And more senior devs need to actually look at code and business rules rather than nitpicking silly shit.</div><br/><div id="42512182" class="c"><input type="checkbox" id="c-42512182" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511364">parent</a><span>|</span><a href="#42512516">next</a><span>|</span><label class="collapse" for="c-42512182">[-]</label><label class="expand" for="c-42512182">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This makes juniors so much more confident because they can ship stuff from the get go without going through a lengthy nitpicky brutal review process.<p>I had not considered that linters could greatly help new developers in this way, especially if you make it a one-button linting process for all established development environments.<p>Thanks for the insight! I will use this for the future.</div><br/></div></div></div></div><div id="42512516" class="c"><input type="checkbox" id="c-42512516" checked=""/><div class="controls bullet"><span class="by">justatdotin</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511212">parent</a><span>|</span><a href="#42511364">prev</a><span>|</span><a href="#42511286">next</a><span>|</span><label class="collapse" for="c-42512516">[-]</label><label class="expand" for="c-42512516">[1 more]</label></div><br/><div class="children"><div class="content">if a colleague wants to argue over placement of a curly boy, I&#x27;ll fight to the death.<p>if it&#x27;s a linter, I shrug and move on.</div><br/></div></div></div></div><div id="42511286" class="c"><input type="checkbox" id="c-42511286" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511212">prev</a><span>|</span><a href="#42512245">next</a><span>|</span><label class="collapse" for="c-42511286">[-]</label><label class="expand" for="c-42511286">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, cognitive load is not the only thing that matters. Non-cognitive toil is also a problem and often enough it doesn&#x27;t get sufficient attention even when things get really bad.<p>We do need better code review tools though. We also need to approach that process as a mechanism of effectively building good shared understanding about the (new) code, not just &quot;code review&quot;.</div><br/></div></div><div id="42512245" class="c"><input type="checkbox" id="c-42512245" checked=""/><div class="controls bullet"><span class="by">gre</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511286">prev</a><span>|</span><a href="#42511395">next</a><span>|</span><label class="collapse" for="c-42512245">[-]</label><label class="expand" for="c-42512245">[2 more]</label></div><br/><div class="children"><div class="content">The process is introducing more room for bugs to somehow creep in. Damn.</div><br/><div id="42512336" class="c"><input type="checkbox" id="c-42512336" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512245">parent</a><span>|</span><a href="#42511395">next</a><span>|</span><label class="collapse" for="c-42512336">[-]</label><label class="expand" for="c-42512336">[1 more]</label></div><br/><div class="children"><div class="content">This is a big problem with reviews where the author is capitulating because they, with gritted teeth, acknowledge it&#x27;s the only way to get the desired result (jumping over a hurdle).<p>So you blindly accept an ill-informed suggestion because that&#x27;s the only way you can complete the process.</div><br/></div></div></div></div><div id="42511395" class="c"><input type="checkbox" id="c-42511395" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512245">prev</a><span>|</span><a href="#42512967">next</a><span>|</span><label class="collapse" for="c-42511395">[-]</label><label class="expand" for="c-42511395">[1 more]</label></div><br/><div class="children"><div class="content">You seem to be describing a company where bureaucracy is a feature not a bug.<p>Been there. Left, live thousands times better.</div><br/></div></div><div id="42512967" class="c"><input type="checkbox" id="c-42512967" checked=""/><div class="controls bullet"><span class="by">romellem</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511395">prev</a><span>|</span><a href="#42512504">next</a><span>|</span><label class="collapse" for="c-42512967">[-]</label><label class="expand" for="c-42512967">[1 more]</label></div><br/><div class="children"><div class="content">&gt; mostly useless comments about not having periods at the ends of lines<p>Oh my god, this sounds like a nightmare. I definitely would not be able to tolerate this for long.<p>Did you try to get them to change? Were you just not in a senior enough position for anyone to listen?</div><br/></div></div><div id="42512504" class="c"><input type="checkbox" id="c-42512504" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512967">prev</a><span>|</span><a href="#42511345">next</a><span>|</span><label class="collapse" for="c-42512504">[-]</label><label class="expand" for="c-42512504">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a similar experience several times over the years.  Even at companies with no working product that ostensibly wanted to &#x27;move fast and break things&#x27;.  And I do the same thing; quit and move on.  I&#x27;m pretty convinced people like that more-or-less can&#x27;t be reasoned with.<p>My question is .. is this getting more common as time goes on, or do I just feel like it is..</div><br/></div></div><div id="42511345" class="c"><input type="checkbox" id="c-42511345" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512504">prev</a><span>|</span><a href="#42511248">next</a><span>|</span><label class="collapse" for="c-42511345">[-]</label><label class="expand" for="c-42511345">[1 more]</label></div><br/><div class="children"><div class="content">This sounds more like a case where you need a “break-the-glass” like procedure where some checks don’t apply. Or the checks should be non blocking anyway.</div><br/></div></div><div id="42511248" class="c"><input type="checkbox" id="c-42511248" checked=""/><div class="controls bullet"><span class="by">shinycode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511345">prev</a><span>|</span><a href="#42512115">next</a><span>|</span><label class="collapse" for="c-42511248">[-]</label><label class="expand" for="c-42511248">[4 more]</label></div><br/><div class="children"><div class="content">No wonder why software development used to be expensive if 50 lines of code takes multiples days for several people …</div><br/><div id="42511684" class="c"><input type="checkbox" id="c-42511684" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511248">parent</a><span>|</span><a href="#42512115">next</a><span>|</span><label class="collapse" for="c-42511684">[-]</label><label class="expand" for="c-42511684">[3 more]</label></div><br/><div class="children"><div class="content">Well maybe they do critical systems.</div><br/><div id="42511924" class="c"><input type="checkbox" id="c-42511924" checked=""/><div class="controls bullet"><span class="by">shinycode</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511684">parent</a><span>|</span><a href="#42512013">next</a><span>|</span><label class="collapse" for="c-42511924">[-]</label><label class="expand" for="c-42511924">[1 more]</label></div><br/><div class="children"><div class="content">Valid point, it’s even mandatory in this case. Sometimes people do it for the sake of it. Maybe because there nothing else to make them feel important ?
In critical systems I hope it’s the case though</div><br/></div></div><div id="42512013" class="c"><input type="checkbox" id="c-42512013" checked=""/><div class="controls bullet"><span class="by">DavidPiper</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511684">parent</a><span>|</span><a href="#42511924">prev</a><span>|</span><a href="#42512115">next</a><span>|</span><label class="collapse" for="c-42512013">[-]</label><label class="expand" for="c-42512013">[1 more]</label></div><br/><div class="children"><div class="content">Narrator: &quot;They don&#x27;t.&quot;<p>(Glib, but in my experience, mostly true.)</div><br/></div></div></div></div></div></div><div id="42512115" class="c"><input type="checkbox" id="c-42512115" checked=""/><div class="controls bullet"><span class="by">jschrf</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511248">prev</a><span>|</span><a href="#42511393">next</a><span>|</span><label class="collapse" for="c-42512115">[-]</label><label class="expand" for="c-42512115">[3 more]</label></div><br/><div class="children"><div class="content">Aye. Sign of the times. You&#x27;re 20+ years in, so I&#x27;m preaching to the choir and old-man-yelling-at-cloud here.<p>Cargo culting + AI are the culprits. Sucks to say, but engineering is going downhill fast. First wave of the shitularity. Architects? Naw, prompt engineers. Barf. Why write good code when a glorified chatbot could do it shittier and faster?<p>Sign of our times. Cardboard cutout code rather than stonemasonry. Shrinkflation of thought.<p>Peep this purified downvote fuel:<p>Everything is bad because everyone is lazy and cargo cults. Web specifically. Full-stop. AI sucks at coding and is making things recursively worse in the long run. LLMs are nothing more than recursive echo chambers of copypasta code that doesn&#x27;t keep up with API flux.<p>A great example of this is the original PHP docs, which so, so many of us copypasta&#x27;d from, leading to an untold amount of SQL injections. Oopsies.<p>Simalarily and hunting for downvotes, React is a templating framework that is useful but does not even meet its original value proposition, which is state management in UI. Hilariously tragic. See: original example of message desync state issue on FB. Unsolved for years by the purported solution.<p>The NoSQL flash is another tragic comedy. Rebuilding the wheel when there is a faster, better wheel already carefully made. Postgres with JSONB.<p>GraphQL is another example of Stuff We Don&#x27;t Need But Use Because People Say It&#x27;s Good. Devs: you don&#x27;t need it. Just write a query.<p>-<p>You mention a hugely important KPI in code. How many files, tools, commands, etc must I touch to do the simplest thing? Did something take me a day when it should have taken 30s? This is rife today, we should all pay attention. Pad left.<p>Look no further than hooks and contexts in React land for an example. Flawed to begin with, simply because &quot;class is a yucky keyword&quot;. I keep seeing this in &quot;fast moving&quot; startups: the diaspora of business logic spread through a codebase, when simplicity and unity is key, which you touch on. Absolute waste of electricity and runway, all thanks to opiniation.<p>Burnt runways abound. Sometimes I can&#x27;t help but think engineering needs a turn it off and then on again moment in safe mode without fads and chatbots.</div><br/><div id="42512786" class="c"><input type="checkbox" id="c-42512786" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512115">parent</a><span>|</span><a href="#42511393">next</a><span>|</span><label class="collapse" for="c-42512786">[-]</label><label class="expand" for="c-42512786">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Everything is bad because everyone is lazy and cargo cults.<p>It’s an interesting series of events that led to this (personal theory). Brilliant people who deeply understood fundamentals built abstractions because they were lazy, in a good way. Some people adopted those abstractions without fully comprehending what was being hidden, and some of <i>those</i> people built additional abstractions. Eventually, you wind up with people building solutions to problems which wouldn’t exist if, generations above, the original problem had been better understood.</div><br/><div id="42512936" class="c"><input type="checkbox" id="c-42512936" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42512786">parent</a><span>|</span><a href="#42511393">next</a><span>|</span><label class="collapse" for="c-42512936">[-]</label><label class="expand" for="c-42512936">[1 more]</label></div><br/><div class="children"><div class="content">The road is paved with good intentions, it&#x27;s not they were lazy but they had intent to distill wisdom to save time. Then yes, the abstractions were adopted without fully comprehended what was hidden, and those people then naively built additional layers of abstractions.<p>So yes, if the original problem had been better understood, then you wouldn&#x27;t have a generation of React programmers doing retarded things.<p>Having watched many junior developers tackle different problems with various frameworks, I have to say React is conducive to brainrot by default. Only after going through a fundamentals-first approach do you not end up with one kind of spaghetti, but you end up with another kind because it&#x27;s fundamentally engineered towards producing spaghetti code unless you constantly fight the inertia of spaghettification.<p>It&#x27;s like teaching kids about `GOTO`... That is, IMO, the essence of React.</div><br/></div></div></div></div></div></div><div id="42511393" class="c"><input type="checkbox" id="c-42511393" checked=""/><div class="controls bullet"><span class="by">notShabu</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42512115">prev</a><span>|</span><a href="#42511084">next</a><span>|</span><label class="collapse" for="c-42511393">[-]</label><label class="expand" for="c-42511393">[1 more]</label></div><br/><div class="children"><div class="content">there is huge incentive for people who don&#x27;t know how to code&#x2F;create&#x2F;do-stuff to slow things down like this b&#x2F;c it allows them many years of runway at the company.<p>they are almost always cloaked in virtue signals.<p>almost every established company you join will already have had this process going for a long time.<p>doing stuff successfully at such a company is dangerous to the hierarchy and incurs an immune response to shut down or ostracize the doing-of-stuff successfully so the only way to survive or climb is to do stuff unsuccessfully (so they look good)</div><br/></div></div><div id="42511084" class="c"><input type="checkbox" id="c-42511084" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511393">prev</a><span>|</span><a href="#42511095">next</a><span>|</span><label class="collapse" for="c-42511084">[-]</label><label class="expand" for="c-42511084">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s rough. Of course some amount of thoughtfulness towards &quot;smallest reasonable change&quot; is valuable, but if you&#x27;re not shipping then something is wrong.<p>As for the &quot;comments on every detail&quot; thing... I would fight that until I win or have to leave. What a completely asinine practice to leave comments on typical lines of code.</div><br/></div></div><div id="42511095" class="c"><input type="checkbox" id="c-42511095" checked=""/><div class="controls bullet"><span class="by">SeptiumMMX</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510935">parent</a><span>|</span><a href="#42511084">prev</a><span>|</span><a href="#42512167">next</a><span>|</span><label class="collapse" for="c-42511095">[-]</label><label class="expand" for="c-42511095">[1 more]</label></div><br/><div class="children"><div class="content">You always need to look at the track record of the team. If they were not producing solid consistent results before you joined them, it&#x27;s a very good indicator that something&#x27;s fishy. All that &quot;they are working on something else that we can&#x27;t tell you&quot; is BS.<p>If they were, and you were the only one treated like that, hiring you was a decision forced upon the team, so they got rid of you in a rather efficient way.</div><br/></div></div></div></div><div id="42512167" class="c"><input type="checkbox" id="c-42512167" checked=""/><div class="controls bullet"><span class="by">charles_f</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42510935">prev</a><span>|</span><a href="#42510878">next</a><span>|</span><label class="collapse" for="c-42512167">[-]</label><label class="expand" for="c-42512167">[1 more]</label></div><br/><div class="children"><div class="content">I like to call these smells, not rules. They&#x27;re an indication that something <i>might</i> be wrong because you&#x27;ve repeated code, or because your method is too long, or because you have too many parameters. But it might also be a false positive because in this instance it was acceptable to repeat code or have a long method or have many parameters.<p>Sometimes food smells because it  turned bad, and sometimes it&#x27;s smelly because it&#x27;s cheese.</div><br/></div></div><div id="42510878" class="c"><input type="checkbox" id="c-42510878" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42512167">prev</a><span>|</span><a href="#42512340">next</a><span>|</span><label class="collapse" for="c-42510878">[-]</label><label class="expand" for="c-42510878">[2 more]</label></div><br/><div class="children"><div class="content">Same deal with DRY, the principle is obviously correct but people can take it too literally. It&#x27;s so easy to get yourself in a huge mess trying to extract out two or three bits of code that <i>look</i> pretty similar but aren&#x27;t really used in the same context.</div><br/><div id="42510955" class="c"><input type="checkbox" id="c-42510955" checked=""/><div class="controls bullet"><span class="by">skeeter2020</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42510878">parent</a><span>|</span><a href="#42512340">next</a><span>|</span><label class="collapse" for="c-42510955">[-]</label><label class="expand" for="c-42510955">[1 more]</label></div><br/><div class="children"><div class="content">The problem with DRY and generic rules around size, etc. really seems to be figuring out the boundaries, and that&#x27;s tough to get right, even for experienced devs, plus very contextual. If you need to open up a dozen files to make a small change you&#x27;re overwhelmed, but then if you need to wade through a big function  or change code in 2 places you&#x27;re just as frustrated.</div><br/></div></div></div></div><div id="42512340" class="c"><input type="checkbox" id="c-42512340" checked=""/><div class="controls bullet"><span class="by">dennis_jeeves2</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42510878">prev</a><span>|</span><a href="#42511356">next</a><span>|</span><label class="collapse" for="c-42512340">[-]</label><label class="expand" for="c-42512340">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It almost always comes from a lead or manager who reads too many business books and then cargo cults those books on to the team.<p>Worse, they behave as though they have  profound insights, and put themselves on an intellectually elevated pedestal,  which the rest of their ordinary team mortals cannot achieve.</div><br/></div></div><div id="42511356" class="c"><input type="checkbox" id="c-42511356" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42512340">prev</a><span>|</span><a href="#42513478">next</a><span>|</span><label class="collapse" for="c-42511356">[-]</label><label class="expand" for="c-42511356">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a book promoting the idea that methods should not be longer than 5 lines.<p>Of course now I know these ridiculous statements are from people hardly wrote any code in their lives, but if I&#x27;d read them at 18 I would have been totally misled.</div><br/><div id="42512147" class="c"><input type="checkbox" id="c-42512147" checked=""/><div class="controls bullet"><span class="by">quesomaster9000</span><span>|</span><a href="#42510866">root</a><span>|</span><a href="#42511356">parent</a><span>|</span><a href="#42513478">next</a><span>|</span><label class="collapse" for="c-42512147">[-]</label><label class="expand" for="c-42512147">[1 more]</label></div><br/><div class="children"><div class="content">Weirdly if you do break everything down into purely functional components it&#x27;s entirely possible to uncompromisingly make every concept a few lines of code at most, and you will end up with some extremely elegant solutions this way.<p>You wouldn&#x27;t be misled at all, only that the path you&#x27;d go down is an entirely different one to what you expected it to be.</div><br/></div></div></div></div><div id="42513478" class="c"><input type="checkbox" id="c-42513478" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42511356">prev</a><span>|</span><a href="#42511195">next</a><span>|</span><label class="collapse" for="c-42513478">[-]</label><label class="expand" for="c-42513478">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an experienced developer and I enforce these kinds of rules upon myself without giving it much thought, and I very much prefer the results.</div><br/></div></div><div id="42511195" class="c"><input type="checkbox" id="c-42511195" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42513478">prev</a><span>|</span><a href="#42510938">next</a><span>|</span><label class="collapse" for="c-42511195">[-]</label><label class="expand" for="c-42511195">[1 more]</label></div><br/><div class="children"><div class="content">If a function is longer than what I can display on a single screen, it better has to be argumented with very exceptional relevant requirements, which is just as straight forward to judge for anyone with a bit of experience.</div><br/></div></div><div id="42510938" class="c"><input type="checkbox" id="c-42510938" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42511195">prev</a><span>|</span><a href="#42512054">next</a><span>|</span><label class="collapse" for="c-42510938">[-]</label><label class="expand" for="c-42510938">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same with writing. The best authors occasionally break the rules of grammar and spelling in order to achieve a specific effect. But you have to learn the rules first, and break them only intentionally rather than accidentally. Otherwise your writing ends up as sloppy crap.<p>(Of course some organizations have coding conventions that are just stupid, but that&#x27;s a separate issue.)</div><br/></div></div><div id="42512054" class="c"><input type="checkbox" id="c-42512054" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42510866">parent</a><span>|</span><a href="#42510938">prev</a><span>|</span><a href="#42510573">next</a><span>|</span><label class="collapse" for="c-42512054">[-]</label><label class="expand" for="c-42512054">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re  confusing this with a software development process problem. It&#x27;s really just good old fashioned psychological abuse.</div><br/></div></div></div></div><div id="42510573" class="c"><input type="checkbox" id="c-42510573" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510866">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510573">[-]</label><label class="expand" for="c-42510573">[65 more]</label></div><br/><div class="children"><div class="content"><i>Mantras like &quot;methods should be shorter than 15 lines of code&quot; or &quot;classes should be small&quot; turned out to be somewhat wrong.</i><p>So much this.<p>The whole point of functions and classes was to make code <i>reusable</i>. If the entire contents of a 100 line method are only ever used in that method and it&#x27;s not recursive or using continuations or anything else weird, why the hell would it be &quot;easier to read&quot; if I had to jump up and down the file to 7 different submethods when the function&#x27;s entire flow is always sequential?</div><br/><div id="42511646" class="c"><input type="checkbox" id="c-42511646" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511114">next</a><span>|</span><label class="collapse" for="c-42511646">[-]</label><label class="expand" for="c-42511646">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The whole point of functions and classes was to make code reusable.<p>I’m amazed that here we are &gt;40 years on from C++, and still this argument is made. Classes never encapsulated a module of reusability, except in toy or academic examples. To try and use them in this way either leads to gigantic “god” classes, or so many tiny classes with scaffolding classes between them that the “communication overhead” dwarfs the actual business logic.<p>Code base after code base proves this again and again. I have never seen a “class” be useful as a component of re-use. So what is? Libraries. A public interface&#x2F;api wrapping a “I don’t care what you did inside”. Bunch of classes, one class, methods? So long as the interface is small and well defined, who cares how it’s structured inside.<p>Modular programming can be done in any paradigm, just think about the api and the internal as separate things. Build some tests at the interface layer, and you’ve got documentation for free too! Re-use happens at the dll or cluster of dll boundaries. Software has a <i>physical</i> aspect to it as well as code.</div><br/><div id="42511767" class="c"><input type="checkbox" id="c-42511767" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511646">parent</a><span>|</span><a href="#42511114">next</a><span>|</span><label class="collapse" for="c-42511767">[-]</label><label class="expand" for="c-42511767">[3 more]</label></div><br/><div class="children"><div class="content">This is not my experience. Multiple inheritance within a code base of certain sub-functionalities and states is a perfectly good example of reuse. You do not need to go all the way out to the library level. In fact, it is the abstract bases that really minimize the reusable parts that I find most useful.<p>I&#x27;m not saying you <i>have</i> to use classes to do this, but they certainly get the job done.</div><br/><div id="42511829" class="c"><input type="checkbox" id="c-42511829" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511767">parent</a><span>|</span><a href="#42512151">next</a><span>|</span><label class="collapse" for="c-42511829">[-]</label><label class="expand" for="c-42511829">[1 more]</label></div><br/><div class="children"><div class="content">We are talking about different things. If you want to use inheritance inside your module, behind a reasonable API, in order to re-use common logic, I won’t bat an eye. I won’t know, I’m working with the public part of your module.<p>If you structure your code so that people in my team can inherit from your base class (because you didn’t make an interface and left everything public), and later you change some of this common logic, then I will curse your name and the manner of your conception.</div><br/></div></div><div id="42512151" class="c"><input type="checkbox" id="c-42512151" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511767">parent</a><span>|</span><a href="#42511829">prev</a><span>|</span><a href="#42511114">next</a><span>|</span><label class="collapse" for="c-42512151">[-]</label><label class="expand" for="c-42512151">[1 more]</label></div><br/><div class="children"><div class="content">Since learning functional programming well. I feel a need to use inheritance in C++ maybe a handful of places.<p>The problem with inherentice reuse is if you need to do something slightly different you are out of luck. Alternatively with functions you call what you need. And can break apart functionality without changing the other reuses.</div><br/></div></div></div></div></div></div><div id="42511114" class="c"><input type="checkbox" id="c-42511114" checked=""/><div class="controls bullet"><span class="by">onionisafruit</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511646">prev</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42511114">[-]</label><label class="expand" for="c-42511114">[6 more]</label></div><br/><div class="children"><div class="content">To paraphrase a recentish comment from jerf, “sometimes you just have a long list of tasks to do”. That stuck with me. Now I’m a bit quicker to realize when I’m in that situation and don’t bother trying to find a natural place to break up the function.</div><br/><div id="42513871" class="c"><input type="checkbox" id="c-42513871" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511114">parent</a><span>|</span><a href="#42511203">next</a><span>|</span><label class="collapse" for="c-42513871">[-]</label><label class="expand" for="c-42513871">[1 more]</label></div><br/><div class="children"><div class="content">A useful trick is to then at least visually structure those 150 lines with comments that separate some blocks of functionality. Keeps the linear flow but makes it still easier to digest.</div><br/></div></div><div id="42511203" class="c"><input type="checkbox" id="c-42511203" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511114">parent</a><span>|</span><a href="#42513871">prev</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42511203">[-]</label><label class="expand" for="c-42511203">[4 more]</label></div><br/><div class="children"><div class="content">For me it depends. Sometimes I find value in making a function for a block of work I can give its own name to, because that can make the flow more obvious when looking at what the function does at a high level. But arbitrarily breaking up a function just because is silly and pointless.</div><br/><div id="42511322" class="c"><input type="checkbox" id="c-42511322" checked=""/><div class="controls bullet"><span class="by">lostdog</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511203">parent</a><span>|</span><a href="#42511858">next</a><span>|</span><label class="collapse" for="c-42511322">[-]</label><label class="expand" for="c-42511322">[2 more]</label></div><br/><div class="children"><div class="content">Plus, laying the list of tasks out in order sometimes makes it obvious how to split it up eventually. If you try to split it up the first time you write it, you get a bunch of meaningless splits, but if you write a 300 line function, and let it simmer for a few weeks, usually you can spot commonalities later.</div><br/><div id="42511390" class="c"><input type="checkbox" id="c-42511390" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511322">parent</a><span>|</span><a href="#42511858">next</a><span>|</span><label class="collapse" for="c-42511390">[-]</label><label class="expand" for="c-42511390">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s also true, though in this case I&#x27;m not necessarily worried about commonalities, just changing the way it reads to focus on the higher level ideas making up the large function.<p>But revisiting code after a time, either just because you slept on it or you&#x27;ve written more adjacent code, is almost always worth some time to try and improve the readability of the code (so long as you don&#x27;t sacrifice performance unnecessarily).</div><br/></div></div></div></div><div id="42511858" class="c"><input type="checkbox" id="c-42511858" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511203">parent</a><span>|</span><a href="#42511322">prev</a><span>|</span><a href="#42513571">next</a><span>|</span><label class="collapse" for="c-42511858">[-]</label><label class="expand" for="c-42511858">[1 more]</label></div><br/><div class="children"><div class="content">Define that function directly in the place where it is used (e.g. as a lambda, if nesting of function definitions is not allowed). Keeps the locality and makes it obvious that you could just have put a comment instead.</div><br/></div></div></div></div></div></div><div id="42513571" class="c"><input type="checkbox" id="c-42513571" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511114">prev</a><span>|</span><a href="#42510812">next</a><span>|</span><label class="collapse" for="c-42513571">[-]</label><label class="expand" for="c-42513571">[3 more]</label></div><br/><div class="children"><div class="content">&gt;why the hell would it be &quot;easier to read&quot; if I had to jump up and down the file to 7 different submethods when the function&#x27;s entire flow is always sequential?<p>Because <i>you don&#x27;t</i> jump up and down the file to read it.<p>Each method that you create has a name, and the name is an opportunity to explain the process - naturally, in-line, without comments.<p>I write code like this all the time - e.g. from my current project: <a href="https:&#x2F;&#x2F;github.com&#x2F;zahlman&#x2F;bbbb&#x2F;blob&#x2F;master&#x2F;src&#x2F;bbbb.py">https:&#x2F;&#x2F;github.com&#x2F;zahlman&#x2F;bbbb&#x2F;blob&#x2F;master&#x2F;src&#x2F;bbbb.py</a> . If I wanted to follow the flow of execution, I would be hammering the % key in Vim. But I don&#x27;t do that, because I don&#x27;t need or want to. The flow of <i>the function</i> is already there in the function. It calls out to other functions that <i>encapsulate details that would be a distraction</i> if I want to understand the function. The functions have names that explain their purpose. I put effort into names, and I trust myself and my names. I only look at the code I&#x27;m currently interested in. To look at other parts of the code, I would first need a reason to be interested in it.<p>When you look at yourself in the mirror, and notice your hand, do you feel compelled to examine your hand in detail before you can consider anything about the rest of your reflection? Would you prefer to conceive of that image as a grid of countless points of light? Or do you not find it useful that your mind&#x27;s eye automatically folds what it sees into abstractions like &quot;hand&quot;?<p>35 years into my journey as a programmer, the idea of a 100-line function frightens me (although I have had to face this fear countless times when dealing with others&#x27; code). For me, that&#x27;s half of a reasonable length (though certainly not a hard limit) for the entire file.</div><br/><div id="42513659" class="c"><input type="checkbox" id="c-42513659" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513571">parent</a><span>|</span><a href="#42510812">next</a><span>|</span><label class="collapse" for="c-42513659">[-]</label><label class="expand" for="c-42513659">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    # Can&#x27;t import at the start, because of the need to bootstrap the
    # environment via `get_requires_for_build_*`.
  
</code></pre>
This comment is a great example of what information you lose when you split linear code into small interrelated methods. You lose ordering and dependencies.<p>Sometimes it&#x27;s worth it. Sometimes it isn&#x27;t. In my opinion it&#x27;s almost never worth it to get to the Uncle Bob&#x27;s approved length of methods.<p>10-30 lines is OK. 3 is counterproductive except for a small subset of wrappers, getters etc. Occasionally it&#x27;s good to leave a method that is 300 lines long.<p>If your code always does 9 things in that exact order - it&#x27;s counterproductive to split them artificially into 3 sets of 3 things to meet an arbitrary limit.</div><br/><div id="42513783" class="c"><input type="checkbox" id="c-42513783" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513659">parent</a><span>|</span><a href="#42510812">next</a><span>|</span><label class="collapse" for="c-42513783">[-]</label><label class="expand" for="c-42513783">[1 more]</label></div><br/><div class="children"><div class="content">&gt;This comment is a great example of what information you lose when you split linear code into small interrelated methods.<p>Inlining `_read_toml` or `_read_config` would change nothing about the reasoning. The purpose was to make sure the import isn&#x27;t tried until the library providing it is installed in the environment. <i>This has nothing to do with the call graph within my code.</i> It&#x27;s not caused by &quot;splitting the code into interrelated methods&quot; and is not a consequence of the dependencies of those functions on each other. It&#x27;s a consequence of the greater context in which the entire module runs.<p>The way that the system (which is not under my control) works (I don&#x27;t have a really good top-down reference handy for this - I may have to write one), a &quot;build frontend&quot; will invoke my code - <i>as a subprocess</i> - multiple times, possibly looking for and calling different hooks each time. The public `get_requires_for_build_wheel` and `get_requires_for_build_sdist` are optional hooks in that specification (<a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0517&#x2F;#optional-hooks" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0517&#x2F;#optional-hooks</a>).<p>However, this approach is left behind from an earlier iteration - I don&#x27;t need to use these hooks to ask the build frontend to install `tomli`, because the necessary conditions can be (and currently are) provided declaratively in `pyproject.toml` (and thus `tomli` will be installed, if necessary, before any attempts to run my backend code). I&#x27;ll rework this when I get back to it (I should just be able to do the import normally now, but of course this requires testing).</div><br/></div></div></div></div></div></div><div id="42510812" class="c"><input type="checkbox" id="c-42510812" checked=""/><div class="controls bullet"><span class="by">shivawu</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42513571">prev</a><span>|</span><a href="#42511476">next</a><span>|</span><label class="collapse" for="c-42510812">[-]</label><label class="expand" for="c-42510812">[4 more]</label></div><br/><div class="children"><div class="content">I agree except I think 100 lines is definitely worth a method, whereas 15 lines is obviously not worthy for the most cases and yet we do that a lot.<p>My principle has always been: “is this part a isolated and intuitive subroutine that I can clearly name and when other people see it they’ll get it at first glance without pausing to think what this does (not to mention reading through the implemention)”. I’m surprised this has not been a common wisdom from many others.</div><br/><div id="42511584" class="c"><input type="checkbox" id="c-42511584" checked=""/><div class="controls bullet"><span class="by">andrewingram</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510812">parent</a><span>|</span><a href="#42513590">next</a><span>|</span><label class="collapse" for="c-42511584">[-]</label><label class="expand" for="c-42511584">[1 more]</label></div><br/><div class="children"><div class="content">In recent years my general principle has been to introduce an abstraction (in this case split up a function) if it lowers local concepts to ~4 (presumably based on similar principles to the original post). I’ve taken to saying something along the lines of “abstractions motivated by reducing repetition or lines of code are often bad, whilst ones motivated by reducing cognitive load tend to be better”.<p>Good abstractions often reduce LOC, but I prefer to think of that as a happy byproduct rather than the goal.</div><br/></div></div><div id="42513590" class="c"><input type="checkbox" id="c-42513590" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510812">parent</a><span>|</span><a href="#42511584">prev</a><span>|</span><a href="#42511033">next</a><span>|</span><label class="collapse" for="c-42513590">[-]</label><label class="expand" for="c-42513590">[1 more]</label></div><br/><div class="children"><div class="content">&gt;My principle has always been: “is this part a isolated and intuitive subroutine that I can clearly name and when other people see it they’ll get it at first glance without pausing to think what this does (not to mention reading through the implemention)”.<p>I hold this principle as well.<p>And I commonly produce one-liner subroutines following it. For me, 15 lines has become disturbingly long.</div><br/></div></div><div id="42511033" class="c"><input type="checkbox" id="c-42511033" checked=""/><div class="controls bullet"><span class="by">toasterlovin</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510812">parent</a><span>|</span><a href="#42513590">prev</a><span>|</span><a href="#42511476">next</a><span>|</span><label class="collapse" for="c-42511033">[-]</label><label class="expand" for="c-42511033">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I find extracting code into methods very useful for naming things that are 1) a digression from the core logic, and 2) enough code to make the core logic harder to comprehend. It’s basically like, “here’s this thing, you can dig into it if you want, but you don’t have to.” Or, the core logic is the top level summary and the methods it calls out to are sections or footnotes.</div><br/></div></div></div></div><div id="42511476" class="c"><input type="checkbox" id="c-42511476" checked=""/><div class="controls bullet"><span class="by">westcoast49</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42510812">prev</a><span>|</span><a href="#42510615">next</a><span>|</span><label class="collapse" for="c-42511476">[-]</label><label class="expand" for="c-42511476">[1 more]</label></div><br/><div class="children"><div class="content">It comes down to the quality of the abstractions. If they are well made and well named, you&#x27;d rather read this:<p><pre><code>  axios.get(&#x27;https:&#x2F;&#x2F;api.example.com&#x27;, {
      headers: { &#x27;Authorization&#x27;: &#x27;Bearer token&#x27; },
      params: { key: &#x27;value&#x27; }
  })
  .then(response =&gt; console.log(response.data))
  .catch(error =&gt; console.error(error));
</code></pre>
than to read the entire implementations of get(), then() and catch() inlined.</div><br/></div></div><div id="42510615" class="c"><input type="checkbox" id="c-42510615" checked=""/><div class="controls bullet"><span class="by">Freak_NL</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511476">prev</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42510615">[-]</label><label class="expand" for="c-42510615">[4 more]</label></div><br/><div class="children"><div class="content">For unit testing those sub-sections in a clear and concise manner (i.e., low cognitive load). As long as the method names are descriptive no jumping to and fro is needed usually.<p>That doesn&#x27;t mean every little unit needs to be split out, but it can make sense to do so if it helps write and debug those parts.</div><br/><div id="42510841" class="c"><input type="checkbox" id="c-42510841" checked=""/><div class="controls bullet"><span class="by">oxidant</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510615">parent</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42510841">[-]</label><label class="expand" for="c-42510841">[3 more]</label></div><br/><div class="children"><div class="content">Then you need to make those functions public, when the goal is to keep them private and unusable outside of the parent function.<p>Sometimes it&#x27;s easy to write multiple named functions, but I&#x27;ve found debugging functions can be more difficult when the interactions of the sub functions contribute to a bug.<p>Why jump back and forth between sections of a module when I could&#x27;ve read the 10 lines in context together?</div><br/><div id="42510990" class="c"><input type="checkbox" id="c-42510990" checked=""/><div class="controls bullet"><span class="by">Freak_NL</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510841">parent</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42510990">[-]</label><label class="expand" for="c-42510990">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Then you need to make those functions public, […]<p>That depends on the language, but often there will be a way to expose them to unit tests while keeping them limited in exposure. Java has package private for this, with Rust the unit test sits in the same file and can access private function just fine. Other languages have comparable idioms.</div><br/><div id="42512740" class="c"><input type="checkbox" id="c-42512740" checked=""/><div class="controls bullet"><span class="by">oxidant</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510990">parent</a><span>|</span><a href="#42513013">next</a><span>|</span><label class="collapse" for="c-42512740">[-]</label><label class="expand" for="c-42512740">[1 more]</label></div><br/><div class="children"><div class="content">Javascript doesn&#x27;t, AFAIK. I work in Elixir, which doesn&#x27;t.<p>I&#x27;m for it if it&#x27;s possible but it can still make it harder to follow.</div><br/></div></div></div></div></div></div></div></div><div id="42513013" class="c"><input type="checkbox" id="c-42513013" checked=""/><div class="controls bullet"><span class="by">BenoitEssiambre</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42510615">prev</a><span>|</span><a href="#42511457">next</a><span>|</span><label class="collapse" for="c-42513013">[-]</label><label class="expand" for="c-42513013">[1 more]</label></div><br/><div class="children"><div class="content">Indeed and breaking out logic into more global scopes has serious downsides if that logic needs to be modified in the future, if your system still needs to support innovation and improvements, downsides not totally unlike the downsides of using a lot of global variables instead of local ones.<p>Prematurely abstracting and breaking code out into small high level chunks is bad. I try to lay it out from an information theoretic, mathematical perspective here:<p><a href="https:&#x2F;&#x2F;benoitessiambre.com&#x2F;entropy.html" rel="nofollow">https:&#x2F;&#x2F;benoitessiambre.com&#x2F;entropy.html</a><p>with some implications for testing:<p><a href="https:&#x2F;&#x2F;benoitessiambre.com&#x2F;integration.html" rel="nofollow">https:&#x2F;&#x2F;benoitessiambre.com&#x2F;integration.html</a><p>It all comes down to managing code entropy.</div><br/></div></div><div id="42511030" class="c"><input type="checkbox" id="c-42511030" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511457">prev</a><span>|</span><a href="#42511057">next</a><span>|</span><label class="collapse" for="c-42511030">[-]</label><label class="expand" for="c-42511030">[3 more]</label></div><br/><div class="children"><div class="content">Because a function clearly defines the scope of the state within it, whereas a section of code within a long function does not. Therefore a function can be reasoned about in isolation, which lowers cognitive load.</div><br/><div id="42512295" class="c"><input type="checkbox" id="c-42512295" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511030">parent</a><span>|</span><a href="#42511744">next</a><span>|</span><label class="collapse" for="c-42512295">[-]</label><label class="expand" for="c-42512295">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree. If there are side effects happening which may be relevant, the section of code within a long function is executing in a clearly defined state (the stuff above it has happened, the stuff below it won&#x27;t happen until it finishes) while the same code in a separate function could be called from anywhere.  Even without side effects, if it&#x27;s called from more than one place, you have to think about all of its callers before you change its semantics, and before you look, you don&#x27;t know if there is more than one caller.  Therefore the section of code can be reasoned about with much lower cognitive load.  This may be why larger subroutines correlate with lower bug rates, at least in the small number of published empirical studies.<p>The advantage of small subroutines is not that they&#x27;re more logically tractable.  They&#x27;re less logically tractable!  The advantage is that they are <i>more flexible</i>, because the set of previously defined subroutines forms a language you can use to write new code.<p>Factoring into subroutines is not completely without its advantages for intellectual tractability.  You can write tests for a subroutine which give you some assurance of what it does and how it can be broken.  And (in the absence of global state, which is a huge caveat) you know that the subroutine only depends on its arguments, while a block in the middle of a long subroutine may have a lot of local variables in scope that it doesn&#x27;t use.  And often the <i>caller</i> of the new subroutine is more readable when you can see the code before the call to it and the code after it on the same screen: code written in the language extended with the new subroutine can be higher level.</div><br/></div></div><div id="42511744" class="c"><input type="checkbox" id="c-42511744" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511030">parent</a><span>|</span><a href="#42512295">prev</a><span>|</span><a href="#42511057">next</a><span>|</span><label class="collapse" for="c-42511744">[-]</label><label class="expand" for="c-42511744">[1 more]</label></div><br/><div class="children"><div class="content">You can write long functions in a bad way, don&#x27;t get me wrong. I&#x27;m just saying the rule that the <i>length itself</i> is an anti-pattern has no inherent validity.</div><br/></div></div></div></div><div id="42511057" class="c"><input type="checkbox" id="c-42511057" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511030">prev</a><span>|</span><a href="#42510769">next</a><span>|</span><label class="collapse" for="c-42511057">[-]</label><label class="expand" for="c-42511057">[5 more]</label></div><br/><div class="children"><div class="content">As a non English speaker, what does &quot;so much this&quot; mean?<p>Does it essentially just mean &quot;I agree&quot;?</div><br/><div id="42511134" class="c"><input type="checkbox" id="c-42511134" checked=""/><div class="controls bullet"><span class="by">scott_w</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511368">next</a><span>|</span><label class="collapse" for="c-42511134">[-]</label><label class="expand" for="c-42511134">[1 more]</label></div><br/><div class="children"><div class="content">Yep, basically “I agree with this statement a lot.” It’s very much an “online Americanism.”</div><br/></div></div><div id="42511368" class="c"><input type="checkbox" id="c-42511368" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511134">prev</a><span>|</span><a href="#42512471">next</a><span>|</span><label class="collapse" for="c-42511368">[-]</label><label class="expand" for="c-42511368">[1 more]</label></div><br/><div class="children"><div class="content">In the superlative, yes. It&#x27;s a fairly new phrase, and hardly in my parlance, but it&#x27;s growing on me when I&#x27;m in informal typed chat contexts.</div><br/></div></div><div id="42512471" class="c"><input type="checkbox" id="c-42512471" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42511368">prev</a><span>|</span><a href="#42511147">next</a><span>|</span><label class="collapse" for="c-42512471">[-]</label><label class="expand" for="c-42512471">[1 more]</label></div><br/><div class="children"><div class="content">When someone says &quot;this&quot; they are basically pointing at a comment and saying &quot;this is what I think too&quot;.<p>&quot;So much&quot; is applied to intensify that.<p>So, yes, it&#x27;s a strong assertion of agreement with the comment they&#x27;re replying to.</div><br/></div></div><div id="42511147" class="c"><input type="checkbox" id="c-42511147" checked=""/><div class="controls bullet"><span class="by">ericjmorey</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511057">parent</a><span>|</span><a href="#42512471">prev</a><span>|</span><a href="#42510769">next</a><span>|</span><label class="collapse" for="c-42511147">[-]</label><label class="expand" for="c-42511147">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a call for others to take note of the important or profound message being highlighted. So more than just &quot;I agree&quot;.</div><br/></div></div></div></div><div id="42510769" class="c"><input type="checkbox" id="c-42510769" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42511057">prev</a><span>|</span><a href="#42510678">next</a><span>|</span><label class="collapse" for="c-42510769">[-]</label><label class="expand" for="c-42510769">[11 more]</label></div><br/><div class="children"><div class="content">I find &quot;is_enabled(x)&quot; to be easier to reason about than<p><pre><code>    if (x.foo || x.bar.baz || (x.quux &amp;&amp; x.bar.foo))
</code></pre>
Even if it&#x27;s only ever used once. Functions and methods provide abstraction which is useful for more than just removing repetition.</div><br/><div id="42510973" class="c"><input type="checkbox" id="c-42510973" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510769">parent</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42510973">[-]</label><label class="expand" for="c-42510973">[5 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re literally using it just once, why not stick it in a local variable instead?  You&#x27;re still getting the advantage of naming the concept that it represents, without eroding code locality.<p>However, the example is a slightly tricky basis to form an opinion on best practice: you&#x27;re proposing that the clearly named example function name is_enabled is better than an expression based on symbols with gibberish names.  Had those names (x, foo, bar, baz, etc) instead been well chosen meaningful names, then perhaps the inline expression would have been just as clear, especially if the body of the if makes it obvious what&#x27;s being checked here.<p>It all sounds great to introduce well named functions in isolated examples, but examples like that are intrinsically so small that the costs of extra indirection are irrelevant. Furthermore, in these hypothetical examples, we&#x27;re kind of assuming that there _is_ a clearly correct and unique definition for is_enabled, but in reality, many ifs like this have more nuance.  The if may well not represent if-enabled, it might be more something like was-enabled-last-app-startup-assuming-authorization-already-checked-unless-io-error.  And the danger of leaving out implicit context like that is precisely that it sounds simple, is_enabled, but that simplicity hides corner cases and unchecked assumptions that may be invalidated by later code evolution - especially if the person changing the code is _not_ changing is_enabled and therefore at risk of assuming it really means whether something is enabled regardless of context.<p>A poor abstraction is worse than no abstraction. We need abstractions, but there&#x27;s a risk of doing so recklessly. It&#x27;s possible to abstract too little, especially if that&#x27;s a sign of just not thinking enough about semantics, but also to abstract too much, especially if that&#x27;s a sign of thinking superficially, e.g. to reduce syntactic duplication regardless of meaning.</div><br/><div id="42511226" class="c"><input type="checkbox" id="c-42511226" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510973">parent</a><span>|</span><a href="#42511354">next</a><span>|</span><label class="collapse" for="c-42511226">[-]</label><label class="expand" for="c-42511226">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure every compiler can manage optimizing out that method call, so do whichever makes you and your code reviewer happy.</div><br/></div></div><div id="42511354" class="c"><input type="checkbox" id="c-42511354" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510973">parent</a><span>|</span><a href="#42511226">prev</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42511354">[-]</label><label class="expand" for="c-42511354">[3 more]</label></div><br/><div class="children"><div class="content">A local variable is often <i>worse</i>: Now I suffer both the noise of the unabstracted thing, and an extra assignment. While part of the goal is to give a reasonable logical name to the complex business logic, the other value is to hide the business logic for readers who truly don&#x27;t care (which is most of them).<p>The names could be better and more expressive, sure, but they could also be function calls themselves or long and difficult to read names, as an example:<p><pre><code>    if (
        x.is_enabled ||
        x.new_is_enabled ||
        (x.in_us_timezone &amp;&amp; is_daytime()) ||
        x.experimental_feature_mode_for_testing 
        )...
</code></pre>
That&#x27;s somewhat realistic for cases where the abstraction is covering for business logic. Now if you&#x27;re lucky you can abstract that away entirely to something like an injected feature or binary flag (but then you&#x27;re actually doing what I&#x27;m suggesting, just with extra ceremony), but sometimes you can&#x27;t for various reasons, and the same concept applies.<p>In fact I&#x27;d actually strongly disagree with you and say that doing what I&#x27;m suggesting is even more important if the example is larger and more complicated. That&#x27;s not an excuse to not have tests or not maintain your code well, but if your argument is functionally &quot;we cannot write abstractions because I can&#x27;t trust that functions do what they say they do&quot;, that&#x27;s not a problem with abstractions, that&#x27;s a problem with the codebase.<p>I&#x27;m arguing that keeping the complexity of any given stanza of code low is important to long-term maintainability, and I think this is true because it invites a bunch of really good questions and naturally pushes back on some increases in complexity: if `is_enabled(x)` is the current state of things, there&#x27;s a natural question asked, and inherent pushback to changing that to `is_enabled(x, y)`. That&#x27;s <i>good</i>. Whereas its much easier for natural development of the god-function to result in 17 local variables with complex interrelations that are difficult to parse out and track.<p>My experience says that identifying, removing, and naming assumptions is vastly easier when any given function is small and tightly scoped and the abstractions you use to do so also naturally discourage other folks who develop on the same codebase from adding unnecessary complexity.<p>And I&#x27;ll reiterate: my goal, at least, when dealing with abstraction isn&#x27;t to focus on duplication, but on clarity. It&#x27;s worthwhile to introduce an abstraction even for code used once if it improves clarity. It may not be worthwhile to introduce an abstraction for something used many times if those things aren&#x27;t inherently related. That creates unnecessary coupling that you either undo or hack around later.</div><br/><div id="42512805" class="c"><input type="checkbox" id="c-42512805" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511354">parent</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42512805">[-]</label><label class="expand" for="c-42512805">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Now I suffer both the noise of the unabstracted thing, and an extra assignment.<p>Depends on your goals &#x2F; constraints. From a performance standpoint, the attribute lookups can often dwarf the overhead of an extra assignment.</div><br/><div id="42513051" class="c"><input type="checkbox" id="c-42513051" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42512805">parent</a><span>|</span><a href="#42510881">next</a><span>|</span><label class="collapse" for="c-42513051">[-]</label><label class="expand" for="c-42513051">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m speaking solely from a developer experience perspective.<p>We&#x27;re talking about cases where the expression is only used once, so the assignment is free&#x2F;can be trivially inlined, and the attribute lookups are also only used once so there is nothing saved by creating a temporary for them.</div><br/></div></div></div></div></div></div></div></div><div id="42510881" class="c"><input type="checkbox" id="c-42510881" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510769">parent</a><span>|</span><a href="#42510973">prev</a><span>|</span><a href="#42510678">next</a><span>|</span><label class="collapse" for="c-42510881">[-]</label><label class="expand" for="c-42510881">[5 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t you jump to is_enabled to see what it does?<p>That&#x27;s what I always do in new code, and probably why I dislike functions that are only used once or twice. The overhead of the jump is not worth it. is_enabled could be a comment above the block (up to a point, notif it&#x27;s too long)</div><br/><div id="42513625" class="c"><input type="checkbox" id="c-42513625" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510881">parent</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42513625">[-]</label><label class="expand" for="c-42513625">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t you jump to is_enabled to see what it does?<p>It determines whether the thing is enabled. Or else some other dev has some &#x27;splainin&#x27; to do. I already understand &quot;what it does&quot;; I am not interested in seeing the code until I have a reason to suspect a problem in that code.<p>If the corresponding logic were inline, I would have to think about it (or maybe read a comment) in order to understand its purpose. The function name tells me the purpose directly, and hides the implementation that doesn&#x27;t help me understand the bigger picture of the calling function.<p>Inline code does the opposite.<p>When <i>the calculation is neatly representable as a single, short, self-evident expression</i>, then yes, I just use a local assignment instead. If I find myself wanting to comment it - if I need to say something about the implementation that the implementation doesn&#x27;t say directly - using a separate function is beneficial, because a comment in that function then clearly refers to <i>that calculation specifically</i>, and I can consider that separately from the overall process.</div><br/><div id="42513839" class="c"><input type="checkbox" id="c-42513839" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42513625">parent</a><span>|</span><a href="#42511236">next</a><span>|</span><label class="collapse" for="c-42513839">[-]</label><label class="expand" for="c-42513839">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It determines whether the thing is enabled.<p>Ah, but what exactly does &quot;enabled&quot; mean in this context? Might seem nitpicky, but I might very well have a different opinion than the person who wrote the code. I mean, if it was just `if foo.enabled ..` no one would put it in a new function.. right? :)<p>I would say a comment does the same, and better because it can be multi line, and you can read it without having to click or move to the function call to see the docs.<p>And you can jump past the implementation, iff it&#x27;s short and &quot;tidy&quot; and enough.<p>Yes, at some point it should be moved out anyway. I&#x27;m just weary from reading code with dozens of small functions, having to jump back and forth again and again and again</div><br/></div></div></div></div><div id="42511236" class="c"><input type="checkbox" id="c-42511236" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510881">parent</a><span>|</span><a href="#42513625">prev</a><span>|</span><a href="#42510678">next</a><span>|</span><label class="collapse" for="c-42511236">[-]</label><label class="expand" for="c-42511236">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t you jump to is_enabled to see what it does?<p>That depends on a lot of things. But the answer is (usually) no. I might do it if I think the error is specifically in that section of code. But especially if you want to provide any kind of documentation or history on why that code is the way it is, it&#x27;s easier to abstract that away into the function.<p>Furthermore, most of the time code is being read isn&#x27;t the first time, and I emphatically don&#x27;t want to reread some visual noise every time I am looking at a larger piece of code.</div><br/><div id="42513874" class="c"><input type="checkbox" id="c-42513874" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511236">parent</a><span>|</span><a href="#42510678">next</a><span>|</span><label class="collapse" for="c-42513874">[-]</label><label class="expand" for="c-42513874">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense. To mee it&#x27;s not about the function having bad code, but different opinions about what exactly &quot;enabled&quot; means.<p>If I&#x27;m not interested I just jump past the block when reading (given that it&#x27;s short and tidy)</div><br/></div></div></div></div></div></div></div></div><div id="42510678" class="c"><input type="checkbox" id="c-42510678" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#42510573">parent</a><span>|</span><a href="#42510769">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510678">[-]</label><label class="expand" for="c-42510678">[21 more]</label></div><br/><div class="children"><div class="content">&gt;why the hell would it be &quot;easier to read&quot; if I had to jump up and down the file to 7 different submethods when the function&#x27;s entire flow is always sequential?<p>If the submethods were clearly named then you&#x27;d only need to read the seven submethod names to understand what the function did, which is easier than reading 100 lines of code.</div><br/><div id="42511751" class="c"><input type="checkbox" id="c-42511751" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510678">parent</a><span>|</span><a href="#42510745">next</a><span>|</span><label class="collapse" for="c-42511751">[-]</label><label class="expand" for="c-42511751">[2 more]</label></div><br/><div class="children"><div class="content">If the variables were clearly named, I wouldn&#x27;t have to read much at all, unless I was interested in the details. I reitrate: why does the <i>length</i> of the single function with no reuse matter?</div><br/><div id="42511917" class="c"><input type="checkbox" id="c-42511917" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511751">parent</a><span>|</span><a href="#42510745">next</a><span>|</span><label class="collapse" for="c-42511917">[-]</label><label class="expand" for="c-42511917">[1 more]</label></div><br/><div class="children"><div class="content">It does not matter if function foo is reused, only if the code inside foo that is to be pulled into new function bar is.</div><br/></div></div></div></div><div id="42510745" class="c"><input type="checkbox" id="c-42510745" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510678">parent</a><span>|</span><a href="#42511751">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510745">[-]</label><label class="expand" for="c-42510745">[18 more]</label></div><br/><div class="children"><div class="content">Why is that any easier than having comments in the code that describe each part? In languages that don&#x27;t allow closures, there&#x27;s no good way to pass state between the seven functions unless you pass all the state you need, either by passing all the variables directly, or by creating an instance of a class&#x2F;struct&#x2F;whatever to hold those same variables and passing that. If you&#x27;re lucky it might only be a couple of variables, but one can imagine that it could be a lot.</div><br/><div id="42510806" class="c"><input type="checkbox" id="c-42510806" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42513639">next</a><span>|</span><label class="collapse" for="c-42510806">[-]</label><label class="expand" for="c-42510806">[6 more]</label></div><br/><div class="children"><div class="content">If all the functions need state from all the other functions, that is the problem a class or a struct solves - e.g. a place to store shared state.<p>If the 7 things are directly related to one another and are _really_ not atomic things (e.g. &quot;Find first user email&quot;, &quot;Filter unknown hostnames&quot;, etc), then they can be in a big pile in their own place, but that is typically pretty rare.<p>In general, you really want to let the code be crisp enough and your function names be intuitive enough that you don&#x27;t need comments. If you have comments above little blocks of code like &quot;Get user name and reorder list&quot;, that should probably just go into its own function.<p>Typically I build my code in &quot;layers&quot; or &quot;levels&quot;. The lowest level is a gigantic pile of utility functions. The top level is the highest level abstractions of whatever framework or interface I&#x27;m building. In the middle are all the abstractions I needed to build to bridge the two, typically programs are between 2-4 layers deep. Each layer should have all the same semantics of everything else at that layer, and lower layers should be less abstract than higher layers.</div><br/><div id="42510941" class="c"><input type="checkbox" id="c-42510941" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510806">parent</a><span>|</span><a href="#42513639">next</a><span>|</span><label class="collapse" for="c-42510941">[-]</label><label class="expand" for="c-42510941">[5 more]</label></div><br/><div class="children"><div class="content">My problem with the class&#x2F;struct approach is it doesn&#x27;t work if you don&#x27;t need everything everywhere.<p><pre><code>    foo(...):
        f1(a,b,c,d,e,f)
        f2(a,c,d,f)
        f3(b,c,d,e)
        ...
        f7(d,e)
</code></pre>
But with long descriptive variable names that you&#x27;d actually use so the function calls don&#x27;t fit on one line. Better imo to have a big long function instead of a class and passing around extra variables.<p>Though, ideally there isn&#x27;t this problem in the first place&#x2F;it&#x27;s refactored away (if possible).</div><br/><div id="42511347" class="c"><input type="checkbox" id="c-42511347" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510941">parent</a><span>|</span><a href="#42512425">next</a><span>|</span><label class="collapse" for="c-42511347">[-]</label><label class="expand" for="c-42511347">[1 more]</label></div><br/><div class="children"><div class="content">A function that needs so many parameters is already a no go.<p>If it doesn&#x27;t return anything, then it&#x27;s either a method in a class, or it&#x27;s a thing that perform some tricky side effect that will be better completely removed with a more sound design.</div><br/></div></div><div id="42512425" class="c"><input type="checkbox" id="c-42512425" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510941">parent</a><span>|</span><a href="#42511347">prev</a><span>|</span><a href="#42511415">next</a><span>|</span><label class="collapse" for="c-42512425">[-]</label><label class="expand" for="c-42512425">[2 more]</label></div><br/><div class="children"><div class="content">You access the shared data via the struct &#x2F; class reference, not as method parameters. That&#x27;s the benefit.<p>e.g.<p><pre><code>    foo(...):
        # Fields
        a
        b
        c
        d 
        e
        
        # Methods
        f1(f)
        f2(f)
        f3()
        ...
        f7()</code></pre></div><br/><div id="42513136" class="c"><input type="checkbox" id="c-42513136" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42512425">parent</a><span>|</span><a href="#42511415">next</a><span>|</span><label class="collapse" for="c-42513136">[-]</label><label class="expand" for="c-42513136">[1 more]</label></div><br/><div class="children"><div class="content">Moving them to a higher scope makes it harder to change anything in foo. Now anytime you want to read or write a-e you have to build the context to understand their complete lifecycles. If all the logic were smooshed together, or if it were factored into the original functions with lots of parameters, as ugly as either of them might be, you still have much more assurance about when they are initialized and changed, and the possible scopes for those events are much more obviously constrained in the code.</div><br/></div></div></div></div><div id="42511415" class="c"><input type="checkbox" id="c-42511415" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510941">parent</a><span>|</span><a href="#42512425">prev</a><span>|</span><a href="#42513639">next</a><span>|</span><label class="collapse" for="c-42511415">[-]</label><label class="expand" for="c-42511415">[1 more]</label></div><br/><div class="children"><div class="content">It works fine. Not all the methods need to use all the struct members.</div><br/></div></div></div></div></div></div><div id="42513639" class="c"><input type="checkbox" id="c-42513639" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42510806">prev</a><span>|</span><a href="#42510818">next</a><span>|</span><label class="collapse" for="c-42513639">[-]</label><label class="expand" for="c-42513639">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Why is that any easier than having comments in the code that describe each part?<p>Because you only read the submethod names, and then you already understand what the code does, at the level you&#x27;re currently interested in.</div><br/></div></div><div id="42510818" class="c"><input type="checkbox" id="c-42510818" checked=""/><div class="controls bullet"><span class="by">hackinthebochs</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42513639">prev</a><span>|</span><a href="#42511251">next</a><span>|</span><label class="collapse" for="c-42510818">[-]</label><label class="expand" for="c-42510818">[5 more]</label></div><br/><div class="children"><div class="content">Language syntax defines functional boundaries. A strong functional boundary means you don&#x27;t have to reason about how other code can <i>potentially</i> influence your code, these boundaries are clearly defined and enforced by the compiler. If you just have one function with blocks of code with comments, you still must engage with the potential for non-obvious code interactions. That&#x27;s much higher cognitive load than managing the extra function with its defined parameters.</div><br/><div id="42510877" class="c"><input type="checkbox" id="c-42510877" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510818">parent</a><span>|</span><a href="#42511251">next</a><span>|</span><label class="collapse" for="c-42510877">[-]</label><label class="expand" for="c-42510877">[4 more]</label></div><br/><div class="children"><div class="content">In the ideal case, sure, but if assuming this can&#x27;t be refactored, then the code<p><pre><code>    foo(...):
       &#x2F;&#x2F; init
       f1(a,b,c,d,e,f)
       f2(a,b,c,d,e,f)
       ...
       f7(a,b,c,d,e,f)
</code></pre>
or the same just with a,b,c,d,e,f stuffed into a class&#x2F;struct and passed around, isn&#x27;t any easier to reason about than if those functions are inline.</div><br/><div id="42512379" class="c"><input type="checkbox" id="c-42512379" checked=""/><div class="controls bullet"><span class="by">hackinthebochs</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510877">parent</a><span>|</span><a href="#42511422">next</a><span>|</span><label class="collapse" for="c-42512379">[-]</label><label class="expand" for="c-42512379">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Your example tells me the structure of the code at a glance. If it was all inlined I would have to comprehend the code to recover this simple structure. Assuming the F&#x27;s are well-name that&#x27;s code I don&#x27;t have to read to comprehend its function. That&#x27;s always a win.</div><br/></div></div><div id="42511422" class="c"><input type="checkbox" id="c-42511422" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510877">parent</a><span>|</span><a href="#42512379">prev</a><span>|</span><a href="#42511399">next</a><span>|</span><label class="collapse" for="c-42511422">[-]</label><label class="expand" for="c-42511422">[1 more]</label></div><br/><div class="children"><div class="content">This typically can be coded with something like<p>def foo(...) = Something.new(...).f1.f2.f7<p>Note that ellipsis here are actual syntax in something like Ruby, other languages might not be as terse and convinient, but the fluent pattern can be implemented basically everywhere (ok maybe not cobol)</div><br/></div></div><div id="42511399" class="c"><input type="checkbox" id="c-42511399" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510877">parent</a><span>|</span><a href="#42511422">prev</a><span>|</span><a href="#42511251">next</a><span>|</span><label class="collapse" for="c-42511399">[-]</label><label class="expand" for="c-42511399">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s at least one reason that something like this is going to be exceedingly rare in practice, which is that (usually) functions return things.<p>In certain cases in C++ or C you might use in&#x2F;out params, but those are less necessary these days, and in most other languages you can just return stuff from your functions.<p>So in <i>almost</i> every case, f1 will have computed some intermediate value useful to f2, and so on and so forth. And these intermediate values will be arguments to the later functions. I&#x27;ve basically never encountered a situation where I <i>can&#x27;t</i> do that.<p>Edit: and as psychoslave mentions, the arguments themselves can be hidden with fluent syntax or by abstracting a-f out to a struct and a fluent api or `self`&#x2F;`this` reference.<p>Cases where you only use some of the parameters in each sub-function are the most challenging to cleanly abstract, but are also the most useful because they help to make complex spaghetti control-flow easier to follow.</div><br/></div></div></div></div></div></div><div id="42511251" class="c"><input type="checkbox" id="c-42511251" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42510818">prev</a><span>|</span><a href="#42510949">next</a><span>|</span><label class="collapse" for="c-42511251">[-]</label><label class="expand" for="c-42511251">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s no good way to pass state between the seven functions unless you pass all the state you need,<p>That’s why it’s better than comments: because it gives you clarity on what part of the state each function reads or writes. If you have a big complex state and a 100 line operation that is entirely “set attribute c to d, set attribute x to off” then no, you don’t need to extract functions, but it’s possible that e.g this method belongs inside the state object.</div><br/></div></div><div id="42510949" class="c"><input type="checkbox" id="c-42510949" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510745">parent</a><span>|</span><a href="#42511251">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42510949">[-]</label><label class="expand" for="c-42510949">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Why is that any easier than having comments in the code that describe each part?<p>Because 7&lt;&lt;100</div><br/><div id="42511308" class="c"><input type="checkbox" id="c-42511308" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42510949">parent</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42511308">[-]</label><label class="expand" for="c-42511308">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Because 7&lt;&lt;100</i><p>But then, 7 &lt;&lt; 100 &lt;&lt; (7 but each access blanks out your short-term memory), which is how jumping to all those tiny functions and back plays out in practice.</div><br/><div id="42513648" class="c"><input type="checkbox" id="c-42513648" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511308">parent</a><span>|</span><a href="#42511405">next</a><span>|</span><label class="collapse" for="c-42513648">[-]</label><label class="expand" for="c-42513648">[1 more]</label></div><br/><div class="children"><div class="content">&gt;which is how jumping to all those tiny functions and back plays out in practice.<p>Why would you jump into those functions and back?</div><br/></div></div><div id="42511405" class="c"><input type="checkbox" id="c-42511405" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42510573">root</a><span>|</span><a href="#42511308">parent</a><span>|</span><a href="#42513648">prev</a><span>|</span><a href="#42513343">next</a><span>|</span><label class="collapse" for="c-42511405">[-]</label><label class="expand" for="c-42511405">[1 more]</label></div><br/><div class="children"><div class="content">Why does pressing &quot;go to defn&quot; blank your short term memory in a way that code scrolling beyond the top of the screen doesn&#x27;t?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42513343" class="c"><input type="checkbox" id="c-42513343" checked=""/><div class="controls bullet"><span class="by">pcblues</span><span>|</span><a href="#42510573">prev</a><span>|</span><a href="#42512063">next</a><span>|</span><label class="collapse" for="c-42513343">[-]</label><label class="expand" for="c-42513343">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a fan of using the least number of language features to get the job done. If a language is simple and can be stepped through easily, one benefits from the removal of the added cognitive load of knowing a large number of language features. This provides extra brainspace to understand the problem space and the system one is working on. Most importantly, it makes it easier to have the whole shebang in your mind while you add code (correctly.)<p>And it adds to maintainability (so long as done in a balanced way!)<p>I had a boss who saw me looking out a window say, &quot;You look like you are concentrating. I&#x27;ll come back later.&quot;<p>I document EVERYTHING I think straight away into their appropriate documents so I can forget about it while I&#x27;m loading as much of a system&#x27;s design into my head as I can. It allows me to write good code during that small window of available zen. After years of doing that, I made a document about documentation. Hope it&#x27;s of use. <a href="https:&#x2F;&#x2F;pcblues.com&#x2F;assets&#x2F;approaching_software_projects.pdf" rel="nofollow">https:&#x2F;&#x2F;pcblues.com&#x2F;assets&#x2F;approaching_software_projects.pdf</a></div><br/><div id="42513787" class="c"><input type="checkbox" id="c-42513787" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42513472">next</a><span>|</span><label class="collapse" for="c-42513787">[-]</label><label class="expand" for="c-42513787">[1 more]</label></div><br/><div class="children"><div class="content"><i>I&#x27;m a fan of using the least number of language features to get the job done.</i><p>Some people seem to love doing the opposite, which IMHO is the biggest problem with the software industry --- there&#x27;s a huge number of developers who think that the more complex (or in their words, &quot;structured&quot;) software is, and the more latest language features it has, is somehow better than the simple &quot;deprecated&quot; stuff that&#x27;s been working for decades.<p>I&#x27;ve come to the conclusion that a lot of new language features are there only for the benefit of trendchasers and worshippers of planned obsolescence, and not the users nor the developers on their side.</div><br/></div></div><div id="42513472" class="c"><input type="checkbox" id="c-42513472" checked=""/><div class="controls bullet"><span class="by">pcblues</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42513787">prev</a><span>|</span><a href="#42513554">next</a><span>|</span><label class="collapse" for="c-42513472">[-]</label><label class="expand" for="c-42513472">[1 more]</label></div><br/><div class="children"><div class="content">Also, it&#x27;s important that you make your own templates for each of the document types, because thinking about them is part of the design process. It reduces the cognitive load of understanding yet another set of design document templates, and they are malleable in your own hands :)</div><br/></div></div><div id="42513554" class="c"><input type="checkbox" id="c-42513554" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#42513343">parent</a><span>|</span><a href="#42513472">prev</a><span>|</span><a href="#42512063">next</a><span>|</span><label class="collapse" for="c-42513554">[-]</label><label class="expand" for="c-42513554">[1 more]</label></div><br/><div class="children"><div class="content">I agree and will add in a few bits: although I will obey the language&#x27;s idiom, in general, I like to keep the number of &quot;things it does&quot; per line of code to the minimum.  Kind of an anti-code golf.<p>I also document (or comment code) when I am waiting for the <i>flow</i> to kick in.  For me, the documentation starts at the appendices.  One for input files or api source tricks or describing the input tables in a database.  Another for the relevant outputs.  Maybe a &quot;justify overall design decisions&quot; section.  Just stuff someone would wish if they had to handle it in five years.</div><br/></div></div></div></div><div id="42512063" class="c"><input type="checkbox" id="c-42512063" checked=""/><div class="controls bullet"><span class="by">nbyron</span><span>|</span><a href="#42513343">prev</a><span>|</span><a href="#42511137">next</a><span>|</span><label class="collapse" for="c-42512063">[-]</label><label class="expand" for="c-42512063">[3 more]</label></div><br/><div class="children"><div class="content">The spirit of this piece is excellent, and introduces some useful terms from psychology to help codify - and more importantly, explain - how to make tasks less unnecessarily demanding.<p>However, as someone who spends their days teaching and writing about cognitive psychology, worth clarifying that this isn’t <i>quite</i> correct:<p><i>Intrinsic - caused by the inherent difficulty of a task. It can&#x27;t be reduced, it&#x27;s at the very heart of software development.</i><p>Intrinsic load is a function of the element interactivity that results within a task (the degree to which different elements, or items, that you need to think about interact and rely upon one another), and prior knowledge.<p>You can’t really reduce element interactivity if you want to keep the task itself intact. However if it’s possible to break a task down into sub tasks then you can often reduce this somewhat, at the expense of efficiency.<p>However, you can absolutely affect the prior knowledge factor that influences intrinsic load. The author speaks of the finding from Cowan (2001) that working memory can process 4+—1 items simultaneously, but what most people neglect here is that what constitutes an “item” is wholly depending upon the schemas that a given person has embedded in their long-term memory. Example: someone with no scientific knowledge may look at O2 + C6H12O6 -&gt; CO2 + H2O as potentially up to 18 items of information to handle (then individual characters), whereas someone with some experience of biology may instead handle this entire expression as a single unit - using their knowledge in long-term memory to “chunk” this string as a single unit - ‘the unbalanced symbol equation for respiration’.</div><br/><div id="42512354" class="c"><input type="checkbox" id="c-42512354" checked=""/><div class="controls bullet"><span class="by">energy123</span><span>|</span><a href="#42512063">parent</a><span>|</span><a href="#42512722">next</a><span>|</span><label class="collapse" for="c-42512354">[-]</label><label class="expand" for="c-42512354">[1 more]</label></div><br/><div class="children"><div class="content">Another good article, not directly related to work tasks, but related to unnecessary complexity: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30802349">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30802349</a></div><br/></div></div><div id="42512722" class="c"><input type="checkbox" id="c-42512722" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42512063">parent</a><span>|</span><a href="#42512354">prev</a><span>|</span><a href="#42511137">next</a><span>|</span><label class="collapse" for="c-42512722">[-]</label><label class="expand" for="c-42512722">[1 more]</label></div><br/><div class="children"><div class="content">Another interesting thing is when there is inherent complexity in the system, things remain simple.<p>For example in game programming, nobody is doing function currying.<p>And yet in React and frontend land because it is a button on screen which toggles a boolean field in the db, there are graphs, render cycles, &quot;use client&quot;, &quot;use server&quot;, &quot;dynamic islands&quot;, &quot;dependency arrays&quot; etc. This is the coding equivalent of bullshit jobs.</div><br/></div></div></div></div><div id="42511137" class="c"><input type="checkbox" id="c-42511137" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42512063">prev</a><span>|</span><a href="#42513812">next</a><span>|</span><label class="collapse" for="c-42511137">[-]</label><label class="expand" for="c-42511137">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Types of cognitive load - Extrinsic&#x2F;Intrinsic<p>This neatly mirrors the central ideas presented in Out of the Tar Pit [0], which defines accidental and essential complexity.<p>Reading this paper was probably one of the biggest career unlocks for me. You really can win ~the entire game if you stay focused on the schema and keep in touch with the customer often enough to ensure that it makes sense to them over time.<p>OOTP presents a functional-relational programming approach, but you really just need the relational part to manage the complexity of the domain. Being able to say that one domain type is relevant to another domain type, but only by way of a certain set of attributes (in a 3rd domain type - join table), is an unbelievably powerful tool when used with discipline. This is how you can directly represent messy real world things like circular dependencies. Modern SQL dialects provide recursive CTEs which were intended to query these implied graphs.<p>Over time, my experience has evolved into &quot;let&#x27;s do as much within the RDBMS as we possibly can&quot;. LINQ &amp; friends are certainly nice to have if you need to build a fancy ETL pipeline that interfaces with some non-SQL target, but they&#x27;ll never beat a simple merge statement in brevity or performance if the source &amp; target of the information is ultimately within the same DB scope. I find myself spending more time in the SQL tools (and Excel) than I do in the various code tools.<p>[0] <a href="https:&#x2F;&#x2F;curtclifton.net&#x2F;papers&#x2F;MoseleyMarks06a.pdf" rel="nofollow">https:&#x2F;&#x2F;curtclifton.net&#x2F;papers&#x2F;MoseleyMarks06a.pdf</a></div><br/></div></div><div id="42513812" class="c"><input type="checkbox" id="c-42513812" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42511137">prev</a><span>|</span><a href="#42513767">next</a><span>|</span><label class="collapse" for="c-42513812">[-]</label><label class="expand" for="c-42513812">[1 more]</label></div><br/><div class="children"><div class="content">Re: complex conditionals<p>I contributed some code to a FOSS project recently which is written in C. In my 10 lines of contributions, 3 were a complex conditional. I&#x27;d have loved to do what the article suggests, with some intermediate booleans. But that C version would have required me to define those variables at the beginning of the function, a hundred lines earlier instead of just right there. No way that&#x27;s going to fly, so now they will need to live with a complex conditional. It&#x27;s one of those &quot;modern language&quot; features which C fanatics generally frown upon but which makes code much easier to read.</div><br/></div></div><div id="42513767" class="c"><input type="checkbox" id="c-42513767" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42513812">prev</a><span>|</span><a href="#42510521">next</a><span>|</span><label class="collapse" for="c-42513767">[-]</label><label class="expand" for="c-42513767">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We were told that a really smart developer had contributed to it. Lots of cool architectures, fancy libraries and trendy technologies were used. In other words, the author had created a high cognitive load for us.<p>Maybe that dev was &quot;really smart&quot; but then not very senior. Eventually the dev will hopefully use their smarts to make things so simple+dumb that the cognitive load when maintaining all that code is minimized.<p>One of the first things I try to drill into our junior devs. If the code looks smart, it needs to be fixed until it&#x27;s really simple and straight forward. &quot;That&#x27;s impossible&quot; some people might say. And that&#x27;s why only the really smart folks can achieve it.</div><br/><div id="42513782" class="c"><input type="checkbox" id="c-42513782" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#42513767">parent</a><span>|</span><a href="#42510521">next</a><span>|</span><label class="collapse" for="c-42513782">[-]</label><label class="expand" for="c-42513782">[2 more]</label></div><br/><div class="children"><div class="content">&gt; make things so simple+dumb that the cognitive load when maintaining all that code is minimized.<p>That&#x27;s not very smart in BigCo, instead you want the complexity to leak into adjacent systems and make them depend on you.</div><br/><div id="42513823" class="c"><input type="checkbox" id="c-42513823" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42513767">root</a><span>|</span><a href="#42513782">parent</a><span>|</span><a href="#42510521">next</a><span>|</span><label class="collapse" for="c-42513823">[-]</label><label class="expand" for="c-42513823">[1 more]</label></div><br/><div class="children"><div class="content">I know your comment is a little tongue-in-cheek, but that kind of thinking is in fact widespread and a reason why many of us are so miserable.</div><br/></div></div></div></div></div></div><div id="42510521" class="c"><input type="checkbox" id="c-42510521" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42513767">prev</a><span>|</span><a href="#42510834">next</a><span>|</span><label class="collapse" for="c-42510521">[-]</label><label class="expand" for="c-42510521">[66 more]</label></div><br/><div class="children"><div class="content">OMG, so much this.<p>One of the biggest sources of cognitive load is poor language design.  There are so many examples that I can&#x27;t even begin to list them all here, but in general, any time a compiler gives you an error <i>and tells you how to fix it</i> that is a big red flag.  For example, if the compiler can tell you that there needs to be a semicolon <i>right here</i>, that means that there does not in fact <i>need</i> to be a semicolon right there, but rather that this semicolon is redundant with information that is available elsewhere in the code, and the only reason it&#x27;s needed is because the language design demands it, not because of any actual necessity to precisely specify the behavior of the code.<p>Another red flag is boilerplate.  <i>By definition</i> boilerplate is something that you have to type not because it&#x27;s required to specify the behavior of the code but simply because the language design demands it.  Boilerplate is always unnecessary cognitive load, and it&#x27;s one sign of a badly designed language.  (Yes, I&#x27;m looking at you, Java.)<p>I use Common Lisp for my coding whenever I can, and one of the reasons is that it, uniquely among languages, allows me to change the syntax and add new constructs so that the language meets the problem and not the other way around.  This reduces cognitive load tremendously, and once you get used to it, writing code in any other language starts to feel like a slog.  You become keenly aware of the fact that 90% of your mental effort is going not towards actually solving the problem at hand, but appeasing the compiler or conforming to some stupid syntax rule that exists for no reason other than that someone at some time in the dim and distant past thought it might be a good idea, and were almost certainly wrong.</div><br/><div id="42510893" class="c"><input type="checkbox" id="c-42510893" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510616">next</a><span>|</span><label class="collapse" for="c-42510893">[-]</label><label class="expand" for="c-42510893">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Another red flag is boilerplate.<p>I have to disagree. Boilerplate can simply be a one-time cost that is paid at setup time, when somebody is already required to have an understanding of what’s happening. That boilerplate can be the platform for others to come along and easily read&#x2F;modify something verbose without having to go context-switch or learn something.<p>Arguing against boilerplate to an extreme is like arguing for DRY and total prevention of duplicated lines of code. It actually increases the cognitive load. Simple code to read and simple code to write is low-cost, and paying a one-time cost at setup is low compared to repeated cost during maintenance.</div><br/><div id="42511149" class="c"><input type="checkbox" id="c-42511149" checked=""/><div class="controls bullet"><span class="by">singingfish</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510893">parent</a><span>|</span><a href="#42513541">next</a><span>|</span><label class="collapse" for="c-42511149">[-]</label><label class="expand" for="c-42511149">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had some C# code inflicted on me recently that follows the pile of garbage design pattern.  Just some offshore guys fulfilling the poorly expressed spec with as little brain work as possible.  The amount of almost-duplicate boilerplate kicking around is one of the problems.  Yeah it looks like the language design encourages this lowest common denominator type approach, and has lead into the supplier providing code that needs substantial refactoring in order be able to create automated tests as the entry points ignore separation of concerns and abuse private v public members to give the pretense of best practices while in reality providing worst practice modify this code at your peril instead. It&#x27;s very annoying because I could have used that budget to do something actually useful, but on the other hand improves my job security for now.</div><br/><div id="42511597" class="c"><input type="checkbox" id="c-42511597" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511149">parent</a><span>|</span><a href="#42513541">next</a><span>|</span><label class="collapse" for="c-42511597">[-]</label><label class="expand" for="c-42511597">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like you would have had problems whether there was boilerplate-y code or not.</div><br/><div id="42512594" class="c"><input type="checkbox" id="c-42512594" checked=""/><div class="controls bullet"><span class="by">singingfish</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511597">parent</a><span>|</span><a href="#42513541">next</a><span>|</span><label class="collapse" for="c-42512594">[-]</label><label class="expand" for="c-42512594">[1 more]</label></div><br/><div class="children"><div class="content">The extra boilerplate noise with excessive repetition doesn&#x27;t help one little bit.</div><br/></div></div></div></div></div></div><div id="42513541" class="c"><input type="checkbox" id="c-42513541" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510893">parent</a><span>|</span><a href="#42511149">prev</a><span>|</span><a href="#42510616">next</a><span>|</span><label class="collapse" for="c-42513541">[-]</label><label class="expand" for="c-42513541">[1 more]</label></div><br/><div class="children"><div class="content">If some program can generate that code automatically, the need to generate it, write it to disk, and for you to edit it is proof that there is some flaw in the language the code is written in. When the generator needs to change, the whole project is fucked because you either have to delete the generated code, regenerate it, and replicate your modifications (where they still apply, and if they don&#x27;t still apply, it could have major implications for the entire project), or you have to manually replicate the differences between what the new version of the generator would generate and what the old version generated when you ran it.<p>With AST macros, you don&#x27;t change generated code, but instead provide pieces of code that get incorporated into the generated code in well-defined ways that allow the generated code to change in the future without scuttling your entire project.<p>&gt;others to come along and easily read&#x2F;modify something verbose without having to go context-switch or learn something.<p>They&#x27;re probably not reading it, but assuming it&#x27;s exactly the same code that appears in countless tutorials, other projects, and LLMs. If there&#x27;s some subtle modification in there, it could escape notice, and probably will at some point. If there are extensive modifications, then people who rely on that code looking like the tutorials will be unable to comprehend it in any way.</div><br/></div></div></div></div><div id="42510616" class="c"><input type="checkbox" id="c-42510616" checked=""/><div class="controls bullet"><span class="by">kvark</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510893">prev</a><span>|</span><a href="#42510600">next</a><span>|</span><label class="collapse" for="c-42510616">[-]</label><label class="expand" for="c-42510616">[23 more]</label></div><br/><div class="children"><div class="content">I disagree with the first point. Say, the compiler figured out your missing semicolon. Doesn&#x27;t mean it&#x27;s easy for another human to clearly see it. The compiler can spend enormous compute to guess that, and that guess doesn&#x27;t even have to be right! Ever been in a situation where following the compiler recommendation produces code that doesn&#x27;t work or even build?
We are optimizing syntax for humans here, so pointing out some redundancies is totally fine.</div><br/><div id="42510680" class="c"><input type="checkbox" id="c-42510680" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510616">parent</a><span>|</span><a href="#42510846">next</a><span>|</span><label class="collapse" for="c-42510680">[-]</label><label class="expand" for="c-42510680">[13 more]</label></div><br/><div class="children"><div class="content">&gt;  Doesn&#x27;t mean it&#x27;s easy for another human to clearly see it.<p>Why do you think that matters?  If it&#x27;s not needed, then it should never have been there in the first place.  If it helps to make the program readable by humans then it can be shown as part of the <i>rendering</i> of the program on a screen, but again, that should be part of the work the <i>computer</i> does, not the human.  Unnecessary cognitive load is still unnecessary cognitive load regardless of the goal in whose name it is imposed.</div><br/><div id="42510762" class="c"><input type="checkbox" id="c-42510762" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42510762">[-]</label><label class="expand" for="c-42510762">[2 more]</label></div><br/><div class="children"><div class="content">In languages (both natural and machine languages) a certain amount of syntax redundancy is a feature. The point of syntax &quot;boilerplate&quot; is to turn typos into syntax errors. When you have a language without any redundant syntactical features, you run the risk that your typo is also valid syntax, just with different semantics than what you intended. IMHO, that&#x27;s much worse than dealing with a missing semicolon error.</div><br/><div id="42513176" class="c"><input type="checkbox" id="c-42513176" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510762">parent</a><span>|</span><a href="#42511431">next</a><span>|</span><label class="collapse" for="c-42513176">[-]</label><label class="expand" for="c-42513176">[1 more]</label></div><br/><div class="children"><div class="content">Can you provide an example where syntax that’s required to be typed and can be accurately diagnosed by the compiler can lead to unintended logic? This is not the same thing as like not typing curly braces under an if directive and then adding a second line under it.</div><br/></div></div></div></div><div id="42511431" class="c"><input type="checkbox" id="c-42511431" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42510762">prev</a><span>|</span><a href="#42510956">next</a><span>|</span><label class="collapse" for="c-42511431">[-]</label><label class="expand" for="c-42511431">[6 more]</label></div><br/><div class="children"><div class="content">Aside from the other good points, this thread is about cognitive load. If a language lets you leave off lots of syntactic elements &amp; let the compiler infer from context, that also forces anyone else reading it to also do the cognitive work to infer from context.<p>The only overhead it increases is the mechanical effort to type the syntax by the code author; they already had to know the context to know there should be two statements, because they made them, so there&#x27;s no increased &quot;cognitive&quot; load.</div><br/><div id="42511487" class="c"><input type="checkbox" id="c-42511487" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511431">parent</a><span>|</span><a href="#42510956">next</a><span>|</span><label class="collapse" for="c-42511487">[-]</label><label class="expand" for="c-42511487">[5 more]</label></div><br/><div class="children"><div class="content">I guess I didn&#x27;t make this clear.  I&#x27;m not advocating for semicolons to be made <i>optional</i>.  I&#x27;m saying that they should not be included in the language syntax <i>at all</i> unless they are <i>necessary</i> for some semantic purpose.  And this goes for <i>any</i> language element, not just semicolons.<p>The vast majority of punctuation in programming languages is unnecessary.  The vast majority of type declarations are unnecessary.  All boilerplate is unnecessary.  All these things are there mostly because of tradition, not because there is any technical justification for any of it.</div><br/><div id="42511880" class="c"><input type="checkbox" id="c-42511880" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511487">parent</a><span>|</span><a href="#42510956">next</a><span>|</span><label class="collapse" for="c-42511880">[-]</label><label class="expand" for="c-42511880">[4 more]</label></div><br/><div class="children"><div class="content">The point generalises beyond semicolons; everything you leave to context is something other people have to load up the context for in order to understand.<p>Consider Python; if there are the optional type hints, those can tell you the third parameter to a function is optional. If those are missing, you need to dive into the function to find that out; those type hints are entirely optional, and yet they reduce the cognitive load of anyone using it.</div><br/><div id="42513183" class="c"><input type="checkbox" id="c-42513183" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511880">parent</a><span>|</span><a href="#42513568">next</a><span>|</span><label class="collapse" for="c-42513183">[-]</label><label class="expand" for="c-42513183">[2 more]</label></div><br/><div class="children"><div class="content">I haven’t used type hints in Python, but can what you’re describing lead to situations where the code cannot run and the interpreter gives you a suggestion on how to fix it?</div><br/><div id="42513785" class="c"><input type="checkbox" id="c-42513785" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513183">parent</a><span>|</span><a href="#42513568">next</a><span>|</span><label class="collapse" for="c-42513785">[-]</label><label class="expand" for="c-42513785">[1 more]</label></div><br/><div class="children"><div class="content">Type hints have no runtime impact, so they can&#x27;t make stuff not work.<p>Type linters like mypy can check your code &amp; report something like &quot;this function call requires str, you&#x27;re providing str | None&quot; though.</div><br/></div></div></div></div><div id="42513568" class="c"><input type="checkbox" id="c-42513568" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511880">parent</a><span>|</span><a href="#42513183">prev</a><span>|</span><a href="#42510956">next</a><span>|</span><label class="collapse" for="c-42513568">[-]</label><label class="expand" for="c-42513568">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The point generalises beyond semicolons; everything you leave to context is something other people have to load up the context for in order to understand.<p>This is not true, because an editor can add any on-screen hints that are needed to help a human understand the code. For example, in my editor, Python code gets vertical lines that indicate where the different indentation levels are, so I can easily see when two lines of code far apart on the screen are at the same indentation level, or how many indentation levels lower the next line is after a long, highly-indented block. Python could add an end-of-block marker like Ruby does to make things like this easier to see, or it could try to encode the vertical lines into the language somehow, but I&#x27;d derive no benefit because the editor already gives me the visual clues I need.</div><br/></div></div></div></div></div></div></div></div><div id="42510876" class="c"><input type="checkbox" id="c-42510876" checked=""/><div class="controls bullet"><span class="by">nullstyle</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510680">parent</a><span>|</span><a href="#42510956">prev</a><span>|</span><a href="#42510846">next</a><span>|</span><label class="collapse" for="c-42510876">[-]</label><label class="expand" for="c-42510876">[3 more]</label></div><br/><div class="children"><div class="content">&gt; then it can be shown as part of the rendering of the program on a screen<p>I disagree with this, and can most easily express my disagreement by pointing out that people look at code with a diversity of programs: From simple text editors with few affordances to convey a programs meaning apart from the plain text like notepad and pico all the way up to the full IDEs that can do automatic refactoring and structured editing like the Jet Brains suite, Emacs+Paredit, or the clearly ever-superior Visual Interdev 6.<p>If people view code through a diversity of programs, then code&#x27;s on-disk form matters, IMO.</div><br/><div id="42511949" class="c"><input type="checkbox" id="c-42511949" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510876">parent</a><span>|</span><a href="#42513608">next</a><span>|</span><label class="collapse" for="c-42511949">[-]</label><label class="expand" for="c-42511949">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but nothing stops you from looking at the raw code.  Consider looking at compiled code.  You can always hexdump the object file, but have a disassembly helps a lot.</div><br/></div></div><div id="42513608" class="c"><input type="checkbox" id="c-42513608" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510876">parent</a><span>|</span><a href="#42511949">prev</a><span>|</span><a href="#42510846">next</a><span>|</span><label class="collapse" for="c-42513608">[-]</label><label class="expand" for="c-42513608">[1 more]</label></div><br/><div class="children"><div class="content">People&#x27;s choice of editor is influenced by what they&#x27;re editing. For example, virtually every Lisp programmer uses Emacs, even though there are many alternatives out there, including VS Code plugins. And virtually every Java programmer uses a JetBrains IDE or something similar. I&#x27;d probably install an IDE if I had to work on a Java codebase. Editing with a diversity of programs isn&#x27;t universal.</div><br/></div></div></div></div></div></div><div id="42510846" class="c"><input type="checkbox" id="c-42510846" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510616">parent</a><span>|</span><a href="#42510680">prev</a><span>|</span><a href="#42510600">next</a><span>|</span><label class="collapse" for="c-42510846">[-]</label><label class="expand" for="c-42510846">[9 more]</label></div><br/><div class="children"><div class="content">No, as python and other languages amply demonstrate, the semicolon is for the compiler, not the developer. If the compiler is sophisticated enough to figure out that a semicolon is needed, it has become <i>optional</i>. That&#x27;s the OP&#x27;s point.</div><br/><div id="42510872" class="c"><input type="checkbox" id="c-42510872" checked=""/><div class="controls bullet"><span class="by">taormina</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510846">parent</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42510872">[-]</label><label class="expand" for="c-42510872">[6 more]</label></div><br/><div class="children"><div class="content">But the language spec for Python is what allows for this, not the compiler. \n is just the magic character now except now we also need a \ to make multiline expressions. It’s all trade offs, compilers are not magic</div><br/><div id="42513378" class="c"><input type="checkbox" id="c-42513378" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510872">parent</a><span>|</span><a href="#42510908">next</a><span>|</span><label class="collapse" for="c-42513378">[-]</label><label class="expand" for="c-42513378">[1 more]</label></div><br/><div class="children"><div class="content">&gt; now except now we also need a \ to make multiline expressions.<p>You never need the backslash in Python to make multiple expressions. There&#x27;s always a way to do multiline using parentheses. Their own style guidelines discourage using backslash for this purpose.</div><br/></div></div><div id="42510908" class="c"><input type="checkbox" id="c-42510908" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510872">parent</a><span>|</span><a href="#42513378">prev</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42510908">[-]</label><label class="expand" for="c-42510908">[4 more]</label></div><br/><div class="children"><div class="content">Scala then. Semicolons are optional but you still can have them if you need them</div><br/><div id="42511005" class="c"><input type="checkbox" id="c-42511005" checked=""/><div class="controls bullet"><span class="by">lblume</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510908">parent</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42511005">[-]</label><label class="expand" for="c-42511005">[3 more]</label></div><br/><div class="children"><div class="content">The obvious example would have been JavaScript, but nobody wants to say something positive about JavaScript...</div><br/><div id="42513544" class="c"><input type="checkbox" id="c-42513544" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511005">parent</a><span>|</span><a href="#42511118">next</a><span>|</span><label class="collapse" for="c-42513544">[-]</label><label class="expand" for="c-42513544">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but nobody wants to say something positive about JavaScript...<p>For obvious reasons...</div><br/></div></div><div id="42511118" class="c"><input type="checkbox" id="c-42511118" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511005">parent</a><span>|</span><a href="#42513544">prev</a><span>|</span><a href="#42511830">next</a><span>|</span><label class="collapse" for="c-42511118">[-]</label><label class="expand" for="c-42511118">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript has some specific and unique issues. Some silly choices (like auto inserting of semi-colons after empty return) and source code routinely, intentionally getting mangled by minification.</div><br/></div></div></div></div></div></div></div></div><div id="42511830" class="c"><input type="checkbox" id="c-42511830" checked=""/><div class="controls bullet"><span class="by">nazgul17</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510846">parent</a><span>|</span><a href="#42510872">prev</a><span>|</span><a href="#42511001">next</a><span>|</span><label class="collapse" for="c-42511830">[-]</label><label class="expand" for="c-42511830">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that the semicolon is somehow a special character and that&#x27;s why it&#x27;s required&#x2F;optional. It&#x27;s the context that makes it necessary or not. Python proves that it&#x27;s possible to design a language that doesn&#x27;t need semicolons; it does not mean that e.g. Java or C are well defined if you make semicolons optional.</div><br/></div></div><div id="42511001" class="c"><input type="checkbox" id="c-42511001" checked=""/><div class="controls bullet"><span class="by">sokoloff</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510846">parent</a><span>|</span><a href="#42511830">prev</a><span>|</span><a href="#42510600">next</a><span>|</span><label class="collapse" for="c-42511001">[-]</label><label class="expand" for="c-42511001">[1 more]</label></div><br/><div class="children"><div class="content">If it’s in the language spec as required there and I’m using a compiler that claims to implement that language spec, I want the compiler to raise the error.<p><i>Additionally</i> offering help on how to fix it is welcome, but silently accepting not-language-X code as if it were valid language-X code is not what I want in a language-X compiler.</div><br/></div></div></div></div></div></div><div id="42510600" class="c"><input type="checkbox" id="c-42510600" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510616">prev</a><span>|</span><a href="#42510630">next</a><span>|</span><label class="collapse" for="c-42510600">[-]</label><label class="expand" for="c-42510600">[2 more]</label></div><br/><div class="children"><div class="content">Totally agree. I think the biggest and most important things a language designer chooses is what to disallow. For instance, private&#x2F;package&#x2F;public etc is one small example of an imposed restriction which makes it easier to reason about changing a large project because if e.g. something is private then you know it&#x27;s okay and probably easy to refactor. The self-imposed restrictions save you mental effort later. I also love lisps but am a Clojure fan. This is because in Clojure, 90+% of the code is static functions operating on immutable data. That makes it extremely easy to reason about in the large. Those two restrictions are big and impose a lot of structure, but man I can tear around the codebase with a machete because there are so many things that code &#x2F;can&#x27;t do&#x2F;. Also, testing is boneheaded simple because everything is just parameters in to those static functions and assert on the values coming out. I don&#x27;t have to do some arduous object construction with all these factories if I need to mock anything, I can use &quot;with-redefs&quot; to statically swap function definitions too, which is clean and very easy to reason about. Choosing the things you mr language disallows is one of the most important things you can do to reduce cognitive load.</div><br/><div id="42513668" class="c"><input type="checkbox" id="c-42513668" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510600">parent</a><span>|</span><a href="#42510630">next</a><span>|</span><label class="collapse" for="c-42513668">[-]</label><label class="expand" for="c-42513668">[1 more]</label></div><br/><div class="children"><div class="content">When the code needs to do something that it can&#x27;t do, there is a massive cognitive load associated with figuring out how to do something approximating it. When the language or a framework is associated with lots of &quot;how do I X&quot; questions, the answers to which are all &quot;completely rethink your program&quot;, that is evidence that the language&#x2F;framework is not reducing cognitive load.</div><br/></div></div></div></div><div id="42510630" class="c"><input type="checkbox" id="c-42510630" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510600">prev</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510630">[-]</label><label class="expand" for="c-42510630">[5 more]</label></div><br/><div class="children"><div class="content">Yes, semicolons are totally unnecessary. That’s why nobody who works on JavaScript has ever regretted that automatic semicolon insertion was added to the language.  It has never prevented the introduction of new syntaxes to the language (like discussed here: &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;twbs&#x2F;bootstrap&#x2F;issues&#x2F;3057#issuecomment-5135562">https:&#x2F;&#x2F;github.com&#x2F;twbs&#x2F;bootstrap&#x2F;issues&#x2F;3057#issuecomment-5...</a>&gt;), nor motivated the addition of awkward grammatical contortions like [no LineTerminator here].</div><br/><div id="42510704" class="c"><input type="checkbox" id="c-42510704" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510630">parent</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510704">[-]</label><label class="expand" for="c-42510704">[4 more]</label></div><br/><div class="children"><div class="content">There are plenty of languages that don’t require semicolons and yet manage to avoid those issues: Clojure, Go, Odin…</div><br/><div id="42512527" class="c"><input type="checkbox" id="c-42512527" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510704">parent</a><span>|</span><a href="#42510800">next</a><span>|</span><label class="collapse" for="c-42512527">[-]</label><label class="expand" for="c-42512527">[1 more]</label></div><br/><div class="children"><div class="content">Funny enough, Go’s grammar does require semicolons. It avoids needing them typed in the source code by automatically adding them on each newline before parsing.</div><br/></div></div><div id="42510800" class="c"><input type="checkbox" id="c-42510800" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510704">parent</a><span>|</span><a href="#42512527">prev</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510800">[-]</label><label class="expand" for="c-42510800">[2 more]</label></div><br/><div class="children"><div class="content">Clojure delineates everything by explicitly putting statements in parentheses (like any LISP). That&#x27;s basically the same thing.<p>Go is an interesting example but it gets away with this by being far stricter with syntax IIRC (for the record, I&#x27;m a fan of Go&#x27;s opinionated formatting).</div><br/><div id="42510922" class="c"><input type="checkbox" id="c-42510922" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510800">parent</a><span>|</span><a href="#42510731">next</a><span>|</span><label class="collapse" for="c-42510922">[-]</label><label class="expand" for="c-42510922">[1 more]</label></div><br/><div class="children"><div class="content">Also Scala</div><br/></div></div></div></div></div></div></div></div><div id="42510731" class="c"><input type="checkbox" id="c-42510731" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510630">prev</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42510731">[-]</label><label class="expand" for="c-42510731">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the compiler can tell you that there needs to be a semicolon right here<p>I can see that this is an annoyance, but does it really increase cognitive load? For me language design choices like allowing arbitrary arguments to functions (instead of having a written list of allowed arguments, I have to keep it in my head), or not having static types (instead of the compiler or my ide keeping track of types, I have to hold them in my head) are the main culprits for increasing cognitive load. Putting a semicolon where it belongs after the compiler telling me I have to is a fairly mindless exercise. The mental acrobatics I have to pull off to get anything done in dynamically typed languages is much more taxing to me.</div><br/><div id="42511520" class="c"><input type="checkbox" id="c-42511520" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510731">parent</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42511520">[-]</label><label class="expand" for="c-42511520">[2 more]</label></div><br/><div class="children"><div class="content">Semicolons are just an example, and a fairly minor one.  A bigger pet peeve of mine is C-style type declarations.  If I create a binding for X and initialize it to 1, the compiler should be able to figure out that X is an integer without my having to tell it.<p>In fact, all type declarations should be optional, with run-time dynamic typing as a fallback when type inferencing fails.  Type &quot;errors&quot; should always be warnings.  There should be no dichotomy between &quot;statically typed&quot; and &quot;dynamically typed&quot; languages.  There should be a smooth transition between programs with little or no compile-time type information and programs with a lot of compile-time type information, and the compiler should do something reasonable in all cases.</div><br/><div id="42513337" class="c"><input type="checkbox" id="c-42513337" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511520">parent</a><span>|</span><a href="#42511484">next</a><span>|</span><label class="collapse" for="c-42513337">[-]</label><label class="expand" for="c-42513337">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  with run-time dynamic typing as a fallback when type inferencing fails.<p>I&#x27;ve seen the code that comes out of this, and how difficult it can be to refactor. I definitely prefer strict typing in every situation that it can&#x27;t be inferred, if you&#x27;re going to have a language with static types.</div><br/></div></div></div></div></div></div><div id="42511484" class="c"><input type="checkbox" id="c-42511484" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510731">prev</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42511484">[-]</label><label class="expand" for="c-42511484">[3 more]</label></div><br/><div class="children"><div class="content">The very same reasons you find CL to lower your cognitive load are why ultimately after 60 years all lisps have been relegated to niche languages despite their benefits, and I say it as a Racket lover. It raises cognitive load for everybody else by having to go through further steps into decoding your choices.<p>It&#x27;s the very same reason why Haskell monocle-wielding developers haven&#x27;t been able to produce one single killer software in decades: every single project&#x2F;library out there has its own extensions to the language, specific compiler flags, etc that onboarding and sharing code becomes a huge chore. And again I say it as an avid Haskeller.<p>Haskellers know that, and there was some short lived simple Haskell momentum but it died fast.<p>But choosing Haskell or a lisp (maybe I can exclude Clojure somewhat) at work? No, no and no.<p>Meanwhile bidonville PHP programmers can boast Laravel, Symfony and dozens of other libraries and frameworks that Haskellers will never ever be able to produce. Java?<p>C? Even more.<p>The language might be old and somewhat complex, but read a line and it means the same in any other project, there are no surprises only your intimacy with the language limiting you. There&#x27;s no ambiguity.</div><br/><div id="42511940" class="c"><input type="checkbox" id="c-42511940" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511484">parent</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42511940">[-]</label><label class="expand" for="c-42511940">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But choosing Haskell or a lisp (maybe I can exclude Clojure somewhat) at work? No, no and no.<p>I&#x27;ve been using CL at work for pretty much my entire career and have always gotten a huge amount of leverage from it.</div><br/><div id="42511983" class="c"><input type="checkbox" id="c-42511983" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511940">parent</a><span>|</span><a href="#42510672">next</a><span>|</span><label class="collapse" for="c-42511983">[-]</label><label class="expand" for="c-42511983">[1 more]</label></div><br/><div class="children"><div class="content">So do I, but not in large projects and teams that need to scale.</div><br/></div></div></div></div></div></div><div id="42510672" class="c"><input type="checkbox" id="c-42510672" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42511484">prev</a><span>|</span><a href="#42510852">next</a><span>|</span><label class="collapse" for="c-42510672">[-]</label><label class="expand" for="c-42510672">[1 more]</label></div><br/><div class="children"><div class="content">Great points. I strongly agree with your first point. Regrettably, I haven&#x27;t used any language that solves this. (But believe it&#x27;s possible, and you&#x27;ve demonstrated with one I haven&#x27;t used).<p>I&#x27;m stuck between two lesser evils, not having the ideal solution you found:
1: Rust: Commits the sin  you say.
2: Python, Kotlin, C++ etc: Commits a worse sin: Prints lots of words.. (Varying degrees depending on which of these), where I may or may not be able to tell what&#x27;s wrong, and if I can, I have to pick it out of a text well.<p>Regarding boilerplate: This is one of the things I dislike most about rust. (As an example). I feel like prefixing`#[derive(Clone, Copy, PartialEq)]` on every (non-holding) enum is a flaw. Likewise, the way I use structs almost always results in prefixing each field with `pub`. (Other people use them in a different way, I believe, which doesn&#x27;t require this)</div><br/></div></div><div id="42510852" class="c"><input type="checkbox" id="c-42510852" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510672">prev</a><span>|</span><a href="#42513116">next</a><span>|</span><label class="collapse" for="c-42510852">[-]</label><label class="expand" for="c-42510852">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another red flag is boilerplate. By definition boilerplate is something that you have to type not because it&#x27;s required to specify the behavior of the code but simply because the language design demands it. Boilerplate is always unnecessary cognitive load, and it&#x27;s one sign of a badly designed language. (Yes, I&#x27;m looking at you, Java.)<p>The claim that LLMs are great for spitting out boilerplate has always sat wrong with me for this reason. They <i>are</i>, but could we not spend some of that research money on eliminating some of the need for boilerplate, rather than just making it faster to input?</div><br/></div></div><div id="42513116" class="c"><input type="checkbox" id="c-42513116" checked=""/><div class="controls bullet"><span class="by">isodev</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510852">prev</a><span>|</span><a href="#42510945">next</a><span>|</span><label class="collapse" for="c-42513116">[-]</label><label class="expand" for="c-42513116">[1 more]</label></div><br/><div class="children"><div class="content">&gt; poor language design<p>We have an excellent modern-day example with Swift - it managed to grow from a simple and effective tool for building apps, to a “designed by committee” monstrosity that requires months to get into.</div><br/></div></div><div id="42510945" class="c"><input type="checkbox" id="c-42510945" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42513116">prev</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42510945">[-]</label><label class="expand" for="c-42510945">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Another red flag is boilerplate. By definition boilerplate is something that you have to type not because it&#x27;s required to specify the behavior of the code but simply because the language design demands it.<p>Two things: 1) this is often not language design but rather framework design, and 2) any semantic redundancy <i>in context</i> can be called boilerplate. Those same semantics may not be considered boilerplate in a different context.<p>And on the (Common) Lisp perspective—reading and writing lisp is arguably a unique skill that takes time and money to develop and brings much less value in return. I&#x27;m not fan of java from an <i>essentialist</i> perspective, but much of that cognitive load can be offset by IDEs, templates, lint tooling, etc etc. It has a role, particularly when you need to marshall a small army of coders very rapidly.</div><br/><div id="42511967" class="c"><input type="checkbox" id="c-42511967" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510945">parent</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42511967">[-]</label><label class="expand" for="c-42511967">[3 more]</label></div><br/><div class="children"><div class="content">If the world put even a tenth of the effort into training Lisp programmers as it does into training Java programmers you would have no trouble marshaling an army of Lisp programmers.</div><br/><div id="42513786" class="c"><input type="checkbox" id="c-42513786" checked=""/><div class="controls bullet"><span class="by">oalae5niMiel7qu</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511967">parent</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42513786">[-]</label><label class="expand" for="c-42513786">[2 more]</label></div><br/><div class="children"><div class="content">The real problem is you cannot ever marshal an army of <i>cheap</i> Lisp programmers, because Lisp programming requires not only learning but raw ability. The big companies are searching for a language that any idiot can learn in a week, with the hope that they can hire thousands of them now, and fire them all next year when LLMs are slightly smarter.<p>They run into the problem that programming is inherently hard, and no amount of finagling with the language can change that, so you have to have <i>someone</i> on every team with actual talent. But the team can be made of <i>mostly</i> idiots, and <i>some</i> of them can be fired next year if LLMs keep improving.<p>If you use Lisp for everything, you can&#x27;t just hire any idiot. You have to be selective, and that costs money. And you won&#x27;t be able to fire them unless AGI is achieved.</div><br/><div id="42513849" class="c"><input type="checkbox" id="c-42513849" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42513786">parent</a><span>|</span><a href="#42510773">next</a><span>|</span><label class="collapse" for="c-42513849">[-]</label><label class="expand" for="c-42513849">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you cannot ever marshal an army of cheap Lisp programmers<p>That may be, but since Lisp programmers are easily 10x as productive as ordinary mortals you can pay them, say, 5x as much and still get a pretty good ROI.<p>&gt; you can&#x27;t just hire any idiot<p>Yeah, well, if you think hiring any idiot is a winning strategy, far be it for me to stand in your way.</div><br/></div></div></div></div></div></div></div></div><div id="42510773" class="c"><input type="checkbox" id="c-42510773" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510945">prev</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42510773">[-]</label><label class="expand" for="c-42510773">[4 more]</label></div><br/><div class="children"><div class="content">Regarding Common Lisp, do you know of any articles that highlight the methods used to <i>&quot;change the syntax and add new constructs so that the language meets the problem and not the other way around.&quot;</i></div><br/><div id="42510946" class="c"><input type="checkbox" id="c-42510946" checked=""/><div class="controls bullet"><span class="by">webnrrd2k</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510773">parent</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42510946">[-]</label><label class="expand" for="c-42510946">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s talking about lisp macros, idempotent languages, and a few other features of lispey languages. I&#x27;d suggest the book On Lisp, or Lisp in Small Pieces as good places to learn about it, but there are a ton of other resources that may be better suited to your needs.</div><br/><div id="42510958" class="c"><input type="checkbox" id="c-42510958" checked=""/><div class="controls bullet"><span class="by">webnrrd2k</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510946">parent</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42510958">[-]</label><label class="expand" for="c-42510958">[2 more]</label></div><br/><div class="children"><div class="content">Also check out clojure, and the books: Norvig&#x27;s PAIP, or Graham&#x27;s ANSI Common Lisp.</div><br/><div id="42511082" class="c"><input type="checkbox" id="c-42511082" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510958">parent</a><span>|</span><a href="#42511126">next</a><span>|</span><label class="collapse" for="c-42511082">[-]</label><label class="expand" for="c-42511082">[1 more]</label></div><br/><div class="children"><div class="content">And don&#x27;t miss Sonja Keene&#x27;s book &quot;Object-Oriented Programming in Common Lisp&quot; and Kiczales&#x27; &quot;The Art of the Meta-Object Protocol&quot;. If you don&#x27;t reach enlightenment after those, Libgen will refund your money.</div><br/></div></div></div></div></div></div></div></div><div id="42511126" class="c"><input type="checkbox" id="c-42511126" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510773">prev</a><span>|</span><a href="#42510989">next</a><span>|</span><label class="collapse" for="c-42511126">[-]</label><label class="expand" for="c-42511126">[3 more]</label></div><br/><div class="children"><div class="content">My gripe with the post is that there is no objective &quot;cognitive load&quot; solution. Arguably this varies from 1 person to another.</div><br/><div id="42511532" class="c"><input type="checkbox" id="c-42511532" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511126">parent</a><span>|</span><a href="#42512656">next</a><span>|</span><label class="collapse" for="c-42511532">[-]</label><label class="expand" for="c-42511532">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can have golden rules, if you do, you fall in the usual don&#x27;t do X, or limit Y to Z lines, etc.<p>But what you _can_ do is to ask yourself whether you&#x27;re adding or removing cognitive load as you work and seek feedback from (possibly junior) coworkers.</div><br/></div></div><div id="42512656" class="c"><input type="checkbox" id="c-42512656" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511126">parent</a><span>|</span><a href="#42511532">prev</a><span>|</span><a href="#42510989">next</a><span>|</span><label class="collapse" for="c-42512656">[-]</label><label class="expand" for="c-42512656">[1 more]</label></div><br/><div class="children"><div class="content">This is true for exactly the same reason that no one algorithm compresses all types of data equally well.</div><br/></div></div></div></div><div id="42510989" class="c"><input type="checkbox" id="c-42510989" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42511126">prev</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42510989">[-]</label><label class="expand" for="c-42510989">[3 more]</label></div><br/><div class="children"><div class="content">The criticisms of Java syntax are somewhat fair, but it&#x27;s important to understand the historical context. It was first designed in 1995 and intended to be an easy transition for C++ programmers (minimal cognitive load). In an alternate history where James Gosling and his colleagues designed Java &quot;better&quot; then it would have never been widely adopted and ended up as a mere curiosity like Common Lisp is today. Sometimes you have to meet your customers where they are.<p>It has taken a few decades but the latest version significantly reduces the boilerplate.</div><br/><div id="42511975" class="c"><input type="checkbox" id="c-42511975" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510989">parent</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42511975">[-]</label><label class="expand" for="c-42511975">[2 more]</label></div><br/><div class="children"><div class="content">Sure.  I understand why things are the way they are.  But that I don&#x27;t think that is a reason not to complain about the way things are.  Improvement is always the product of discontent.</div><br/><div id="42512191" class="c"><input type="checkbox" id="c-42512191" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511975">parent</a><span>|</span><a href="#42510734">next</a><span>|</span><label class="collapse" for="c-42512191">[-]</label><label class="expand" for="c-42512191">[1 more]</label></div><br/><div class="children"><div class="content">Improvement is always the product of submitting a JEP or JSR.<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;0" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;0</a><p><a href="https:&#x2F;&#x2F;jcp.org&#x2F;en&#x2F;jsr&#x2F;overview" rel="nofollow">https:&#x2F;&#x2F;jcp.org&#x2F;en&#x2F;jsr&#x2F;overview</a></div><br/></div></div></div></div></div></div><div id="42510734" class="c"><input type="checkbox" id="c-42510734" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510989">prev</a><span>|</span><a href="#42510952">next</a><span>|</span><label class="collapse" for="c-42510734">[-]</label><label class="expand" for="c-42510734">[2 more]</label></div><br/><div class="children"><div class="content">I agree up until the end. Languages that let you change the syntax can result in stuff where every program is written in its own DSL. Ruby has this issue to some extent.</div><br/><div id="42511556" class="c"><input type="checkbox" id="c-42511556" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42510734">parent</a><span>|</span><a href="#42510952">next</a><span>|</span><label class="collapse" for="c-42511556">[-]</label><label class="expand" for="c-42511556">[1 more]</label></div><br/><div class="children"><div class="content">Sure, changing the syntax is not something to be done lightly.  It has to be done judiciously and with great care.  But it can be a huge win in some cases.  For example, take a look at:<p><a href="https:&#x2F;&#x2F;flownet.com&#x2F;gat&#x2F;lisp&#x2F;djbec.lisp" rel="nofollow">https:&#x2F;&#x2F;flownet.com&#x2F;gat&#x2F;lisp&#x2F;djbec.lisp</a><p>It implements elliptic curve cryptography in Common Lisp using an embedded infix syntax.</div><br/></div></div></div></div><div id="42510952" class="c"><input type="checkbox" id="c-42510952" checked=""/><div class="controls bullet"><span class="by">frenchslumber</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510734">prev</a><span>|</span><a href="#42511343">next</a><span>|</span><label class="collapse" for="c-42510952">[-]</label><label class="expand" for="c-42510952">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree! Common Lisp is truly the tool of the Gods.</div><br/></div></div><div id="42511343" class="c"><input type="checkbox" id="c-42511343" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42510952">prev</a><span>|</span><a href="#42511129">next</a><span>|</span><label class="collapse" for="c-42511343">[-]</label><label class="expand" for="c-42511343">[2 more]</label></div><br/><div class="children"><div class="content">You can reduce your Java boilerplate to annotations or succinct XML or whatever. Code generation is used a lot on the JVM.<p>Can you show a real compiler message about such a semicolon?</div><br/><div id="42511923" class="c"><input type="checkbox" id="c-42511923" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511343">parent</a><span>|</span><a href="#42511129">next</a><span>|</span><label class="collapse" for="c-42511923">[-]</label><label class="expand" for="c-42511923">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    % cat test.c
    main () {
      int x
      x=1
    }
    % gcc test.c  
    test.c:1:1: warning: type specifier missing, defaults to &#x27;int&#x27; [-Wimplicit-int]
    main () {
    ^
    test.c:2:8: error: expected &#x27;;&#x27; at end of declaration
      int x
           ^
           ;
    1 warning and 1 error generated.</code></pre></div><br/></div></div></div></div><div id="42511129" class="c"><input type="checkbox" id="c-42511129" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#42510521">parent</a><span>|</span><a href="#42511343">prev</a><span>|</span><a href="#42510834">next</a><span>|</span><label class="collapse" for="c-42511129">[-]</label><label class="expand" for="c-42511129">[2 more]</label></div><br/><div class="children"><div class="content">So with semi-colons, you have three basic options:<p>1. Not required (eg Python, Go)<p>2. Required (eg C&#x2F;C++, Java)<p>3. Optional (eg Javascript)<p>For me, (3) is by far the worst option. To me, the whole ASI debate is so ridiculous. To get away with (1), the languages make restrictions on syntax, most of which I think are acceptable. For example, Java&#x2F;C&#x2F;C++ allow you to put multiple statements on a single line. Do you need that? Probably not. I can&#x27;t even think of an example where that&#x27;s useful&#x2F;helpful.<p>&quot;Boilerplate&quot; becomes a matter of debate. It&#x27;s a common criticism with Java, for example (eg anonymous classes). I personally think with modern IDEs it&#x27;s really a very minor issue.<p>But some languages make, say, the return statement optional. I actually don&#x27;t like this. I like a return being explicit and clear in the code. Some will argue the return statement is boilerplate.<p>Also, explicit type declarations can be viewed as boilerplate.. There are levels to this. C++&#x27;s auto is one-level. So are &quot;var&quot; declarations. Java is more restrictive than this (eg &lt;&gt; for implied types to avoid repeating types in a single declaration). But is this boilerplate?<p>Common Lisp is where you lose me. Like the meme goes, if CL was a good idea it would&#x27;ve caught on at some point in the last 60 years. Redefning the language seems like a recipe for disaster, or at least adding a bunch of cognitive load because you can&#x27;t trust that &quot;standard&quot; functions aren&#x27;t doing standard things.<p>Someone once said they like in Java that they&#x27;re never surprised by 100 lines of code of Java. Unlike CL, there&#x27;s never a parser or an interpreter hidden in there. Now that&#x27;s a testament to CL&#x27;s power for sure. But this kind of power just isn&#x27;t conducive to maintainable code.</div><br/><div id="42511536" class="c"><input type="checkbox" id="c-42511536" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42510521">root</a><span>|</span><a href="#42511129">parent</a><span>|</span><a href="#42510834">next</a><span>|</span><label class="collapse" for="c-42511536">[-]</label><label class="expand" for="c-42511536">[1 more]</label></div><br/><div class="children"><div class="content">I like (3) to be honest and the number of times it has poised any issue is virtually 0.</div><br/></div></div></div></div></div></div><div id="42510834" class="c"><input type="checkbox" id="c-42510834" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42510521">prev</a><span>|</span><a href="#42510700">next</a><span>|</span><label class="collapse" for="c-42510834">[-]</label><label class="expand" for="c-42510834">[1 more]</label></div><br/><div class="children"><div class="content">Composition over inheritance is one of the most valuable lessons I learned earlier in my career as a developer. In fact these days, I&#x27;m hard-pressed to think of a case in which I would prefer inheritance as my first choice to model <i>any</i> problem. I&#x27;m sure there probably are some, but it feels too easy to wield irresponsibly and let bad design creep in.<p>At a previous job I had, a fairly important bit of code made use of a number of class hierarchies each five or six layers deep, including the massive code smell&#x2F;design failure of certain layers stubbing out methods on a parent class due to irrelevancy.<p>To make matters worse, at the point of use often only the base&#x2F;abstract types were referenced, so even working out what code was running basically required stepping through in a debugger if you didn&#x27;t want to end up like the meme of Charlie from Always Sunny. And of course, testing was a nightmare because everything happened internally to the classes, so you would end up extending them even further in tests just to stub&#x2F;mock bits you needed to control.</div><br/></div></div><div id="42510700" class="c"><input type="checkbox" id="c-42510700" checked=""/><div class="controls bullet"><span class="by">hn8726</span><span>|</span><a href="#42510834">prev</a><span>|</span><a href="#42511031">next</a><span>|</span><label class="collapse" for="c-42510700">[-]</label><label class="expand" for="c-42510700">[3 more]</label></div><br/><div class="children"><div class="content">I agree with vast majority of the post, and it matches my experience. What I&#x27;m not sure I follow is the part about layered architecture, and what is offered as an alternative. The author quickly gets to a _conclusion_ that<p>&gt; So, why pay the price of high cognitive load for such a layered architecture, if it doesn&#x27;t pay off in the future?<p>where one of the examples is<p>&gt; If you think that such layering will allow you to quickly replace a database or other dependencies, you&#x27;re mistaken. Changing the storage causes lots of problems, and believe us, having some abstractions for the data access layer is the least of your worries.<p>but in my experience, it&#x27;s crucial to abstract away — even if the interface is not ideal — external dependencies. The point is not to be able to &quot;replace a database&quot;, but to _own_ the interface that is used by the application. Maybe the author only means _unnecessary layering_, but the way the argument is framed seems like using external dependency APIs throughout the entire app is somehow better.</div><br/><div id="42510887" class="c"><input type="checkbox" id="c-42510887" checked=""/><div class="controls bullet"><span class="by">master_crab</span><span>|</span><a href="#42510700">parent</a><span>|</span><a href="#42511371">next</a><span>|</span><label class="collapse" for="c-42510887">[-]</label><label class="expand" for="c-42510887">[1 more]</label></div><br/><div class="children"><div class="content">I commented on this in another thread here.<p>What I read it as is don’t over-index on creating separate layers&#x2F;services if they are already highly dependent on each other. It just adds additional complexity tracing dependencies over the networking stack, databases&#x2F;datastores, etc that the services are now split across.<p>In other words: a monolithic design is acceptable if the services are highly intertwined and dependent.</div><br/></div></div><div id="42511371" class="c"><input type="checkbox" id="c-42511371" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42510700">parent</a><span>|</span><a href="#42510887">prev</a><span>|</span><a href="#42511031">next</a><span>|</span><label class="collapse" for="c-42511371">[-]</label><label class="expand" for="c-42511371">[1 more]</label></div><br/><div class="children"><div class="content">I think the &#x27;Layered Architecture&#x27; section is all over the place.<p>There are a lot of terms thrown around with pretty loose definitions - in this article and others.  I had to look up &quot;layered architecture&quot; to see what other people wrote about it, and it looks like an anti-pattern to me:<p><pre><code>  In a four-layered architecture, the layers are typically divided into:
    Presentation
    Application
    Domain
    Infrastructure

  These layers are arranged in a hierarchical order, where each layer provides services to the layer above it and uses services from the layer below it, and each layer is responsible for handling specific tasks and has limited communication with the other layers. [1]
</code></pre>
It looks like an anti-pattern to be because, as described, each layer <i>depends</i> on the one below it.  It looks like how you&#x27;d define the &quot;dependency non-inversion&quot; principle.  <i>Domain</i> depends on <i>Infrastructure</i>?  A BankBalance is going to depend on MySQL?  Even if you put the DB behind an interface, the direction of dependencies is still wrong: BankBalace-&gt;IDatabase.<p>Back to TFA:<p>&gt; In the end, we gave it all up in favour of the good old dependency inversion principle.<p>OK.  DIP is terrific.<p>&gt; No port&#x2F;adapter terms to learn<p>There is a big overlap between ports&#x2F;adapters, hexagonal, and DIP:<p><pre><code>  Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases. [2]
</code></pre>
That is, the Domain (&quot;application&quot;) is at the bottom of the dependency graph, so that the Infrastructure {Programs, Tests, Scripts} can depend upon it.<p>&gt; If you think that such layering will allow you to quickly replace a database or other dependencies, you&#x27;re mistaken.<p><i>Layering</i> will not help - it will hinder, as I described above.  But you should be able to quickly replace any dependency you like, which is what DIP&#x2F;PortsAdapters&#x2F;Hexagonal gives you.<p>&gt; Changing the storage causes lots of problems, and believe us, having some abstractions for the data access layer is the least of your worries. At best, abstractions can save somewhat 10% of your migration time (if any)<p>I iterate on my application code without spinning up a particular database.  Same with my unit tests.  Well worth it.<p>[1] <a href="https:&#x2F;&#x2F;bitloops.com&#x2F;docs&#x2F;bitloops-language&#x2F;learning&#x2F;software-architecture&#x2F;layered-architecture" rel="nofollow">https:&#x2F;&#x2F;bitloops.com&#x2F;docs&#x2F;bitloops-language&#x2F;learning&#x2F;softwar...</a>
[2] <a href="https:&#x2F;&#x2F;alistair.cockburn.us&#x2F;hexagonal-architecture&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alistair.cockburn.us&#x2F;hexagonal-architecture&#x2F;</a></div><br/></div></div></div></div><div id="42511031" class="c"><input type="checkbox" id="c-42511031" checked=""/><div class="controls bullet"><span class="by">svilen_dobrev</span><span>|</span><a href="#42510700">prev</a><span>|</span><a href="#42513758">next</a><span>|</span><label class="collapse" for="c-42511031">[-]</label><label class="expand" for="c-42511031">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Involve junior developers in architecture reviews. They will help you to identify the mentally demanding areas.<p>This.<p>And also, a mantra of my own: Listen <i>carefully</i> to any newcomer in the team&#x2F;company in first 1-3 weeks, until s&#x2F;he gets accustomed (and&#x2F;or stop paying attention to somewhat uneasy stuff). They will tell you all things that are, if not wrong, at least weird.</div><br/><div id="42511570" class="c"><input type="checkbox" id="c-42511570" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#42511031">parent</a><span>|</span><a href="#42511352">next</a><span>|</span><label class="collapse" for="c-42511570">[-]</label><label class="expand" for="c-42511570">[1 more]</label></div><br/><div class="children"><div class="content">I second this, but one should also be extremely wary of newcomers feedback and try to understand their nature.<p>Some people are extremely resistant to new ideas, some might be simply lazy, some can&#x27;t be bothered to read documentations, etc.<p>Spotting the real person behind the feedback is crucial and often those people need to be fired fast.<p>I myself tend to be lazy when it comes to learn new stuff&#x2F;patterns, especially when I am in the middle of having to progress a project so my own feedback may be more of a frustration for my inability to progress due to having to understand first a, b, c and d which may take considerable time and pain for something I can do in an old way in few minutes.</div><br/></div></div><div id="42511352" class="c"><input type="checkbox" id="c-42511352" checked=""/><div class="controls bullet"><span class="by">ben_w</span><span>|</span><a href="#42511031">parent</a><span>|</span><a href="#42511570">prev</a><span>|</span><a href="#42511045">next</a><span>|</span><label class="collapse" for="c-42511352">[-]</label><label class="expand" for="c-42511352">[1 more]</label></div><br/><div class="children"><div class="content">Aye, but the joiners may need prompting as well as getting listened to.<p>In each place where I&#x27;ve seen something wildly wrong, the problem has been clear in the first few weeks — sometimes even in the first few days* — but I always start with the assumption that if I disagree with someone who has been at it for years, they&#x27;ve probably got good reasons for the stuff that surprises me.<p>Unfortunately I&#x27;m not very convincing: when I do finally feel confident enough to raise stuff, quite often they do indeed have reasons… bad reasons that ultimately prove to be fatal or near-fatal flaws to their business plans, but the issues only seldom get fixed once I raise them.<p>* one case where the problem was visible in the interview, but I was too young and naive so I disregarded what I witnessed, and I regretted it.</div><br/></div></div><div id="42511045" class="c"><input type="checkbox" id="c-42511045" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#42511031">parent</a><span>|</span><a href="#42511352">prev</a><span>|</span><a href="#42513758">next</a><span>|</span><label class="collapse" for="c-42511045">[-]</label><label class="expand" for="c-42511045">[2 more]</label></div><br/><div class="children"><div class="content">Junior developers probably won&#x27;t say anything, because they are used to not understanding code, and they are not going to second guess the more-experienced author.</div><br/><div id="42511059" class="c"><input type="checkbox" id="c-42511059" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#42511031">root</a><span>|</span><a href="#42511045">parent</a><span>|</span><a href="#42513758">next</a><span>|</span><label class="collapse" for="c-42511059">[-]</label><label class="expand" for="c-42511059">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely on the senior to prompt the junior appropriately. But when you do, they will.</div><br/></div></div></div></div></div></div><div id="42513758" class="c"><input type="checkbox" id="c-42513758" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#42511031">prev</a><span>|</span><a href="#42510412">next</a><span>|</span><label class="collapse" for="c-42513758">[-]</label><label class="expand" for="c-42513758">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By no means I am trying to blame C++. I love the language. It&#x27;s just that I am tired now.<p>I feel that in my bones.</div><br/></div></div><div id="42510412" class="c"><input type="checkbox" id="c-42510412" checked=""/><div class="controls bullet"><span class="by">ScotterC</span><span>|</span><a href="#42513758">prev</a><span>|</span><a href="#42511469">next</a><span>|</span><label class="collapse" for="c-42510412">[-]</label><label class="expand" for="c-42510412">[4 more]</label></div><br/><div class="children"><div class="content">Looks like a solid post with solid learnings. Apologies for hijacking the thread but I’d really love to have a discussion on how these heuristics of software development change with the likes of Cursor&#x2F;LLM cyborg coding in the mix.<p>I’ve done an extensive amount of LLM assisted coding and our heuristics need to change. Synthesis of a design still needs to be low cognitive load - e.g. how data flows between multiple modules - because you need to be able to verify the actual system or that the LLM suggestion matches the intended mental model. However, striving for simplicity inside a method&#x2F;function matters way less. It’s relatively easy to verify that an LLM generated unit test is working as intended and the complexity of the code within the function doesn’t matter if its scope is sufficiently narrow.<p>IMO identifying the line between locations where “low cognitive load required” vs “low cognitive load is unnecessary” changes the game of software development and is not often discussed.</div><br/><div id="42512842" class="c"><input type="checkbox" id="c-42512842" checked=""/><div class="controls bullet"><span class="by">tkgally</span><span>|</span><a href="#42510412">parent</a><span>|</span><a href="#42510869">next</a><span>|</span><label class="collapse" for="c-42512842">[-]</label><label class="expand" for="c-42512842">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’d really love to have a discussion on how these heuristics of software development change with the likes of Cursor&#x2F;LLM cyborg coding in the mix<p>I would also be interested in reading people’s thoughts about how those heuristics might change in the months and years ahead, as reasoning LLMs get more powerful and as context windows continue to increase. Even if it never becomes possible to offload software development completely to AI, it does seem at least possible that human cognitive load will not be an issue in the same way it is now.</div><br/></div></div><div id="42510869" class="c"><input type="checkbox" id="c-42510869" checked=""/><div class="controls bullet"><span class="by">codespin</span><span>|</span><a href="#42510412">parent</a><span>|</span><a href="#42512842">prev</a><span>|</span><a href="#42511469">next</a><span>|</span><label class="collapse" for="c-42510869">[-]</label><label class="expand" for="c-42510869">[2 more]</label></div><br/><div class="children"><div class="content">With LLM generated code (and any code really) the interface between components becomes much more important. It needs to be clearly defined so that it can be tested and avoid implicit features that could go away if it were re-generated.<p>Only when you know for sure the problem can&#x27;t be coming through from that component can you stop thinking about it and reduce the cognitive load.</div><br/><div id="42512929" class="c"><input type="checkbox" id="c-42512929" checked=""/><div class="controls bullet"><span class="by">ScotterC</span><span>|</span><a href="#42510412">root</a><span>|</span><a href="#42510869">parent</a><span>|</span><a href="#42511469">next</a><span>|</span><label class="collapse" for="c-42512929">[-]</label><label class="expand" for="c-42512929">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>Regarding some of the ‘layered architecture’ discussion from the OP, I’d argue that having many modules that are clearly defined is not as large a detriment to cognitive load when an LLM is interpreting it. This is dependent on two factors, each module being clearly defined enough that you can be confident the problem lies within the interactions between modules&#x2F;components and not within them AND sharing proper&#x2F;sufficient context with an LLM so that it is focused on the interactions between components so that it doesn’t try to force fit a solution into one of them or miss the problem space entirely.<p>The latter is a constant nagging issue but the former is completely doable (types and unit testing helps) but flies in the face of the mo’ files, mo’ problems issue that creates higher cognitive loads for humans.</div><br/></div></div></div></div></div></div><div id="42511469" class="c"><input type="checkbox" id="c-42511469" checked=""/><div class="controls bullet"><span class="by">jeremydeanlakey</span><span>|</span><a href="#42510412">prev</a><span>|</span><a href="#42513597">next</a><span>|</span><label class="collapse" for="c-42511469">[-]</label><label class="expand" for="c-42511469">[2 more]</label></div><br/><div class="children"><div class="content">The central idea around cognitive load is very good, central to writing good code.<p>But it&#x27;s deeply mistaken to oppose smaller (or more correctly: simpler) classes&#x2F;functions and layered architecture.<p>Layered architecture and simple (mostly small) classes and methods are critical to light cognitive load.<p>e.g. You should not be handling database functionality in your service classes, nor should you be doing business logic in your controllers.  These different kinds of logic are very different, require different kinds of knowledge.  Combining them _increases_ cognitive load, not decreases.<p>It&#x27;s not mainly about swapping out dependencies (although this is an important benefit), it&#x27;s about doing one thing at a time.</div><br/><div id="42511607" class="c"><input type="checkbox" id="c-42511607" checked=""/><div class="controls bullet"><span class="by">jeremydeanlakey</span><span>|</span><a href="#42511469">parent</a><span>|</span><a href="#42513597">next</a><span>|</span><label class="collapse" for="c-42511607">[-]</label><label class="expand" for="c-42511607">[1 more]</label></div><br/><div class="children"><div class="content">To make this more concrete:<p>If your service layer method requires data to be saved and the results to be sorted, you want to call a data layer method that saves it and a library method that sorts it.  You do not want any of that saving or sorting functionality in your service method.<p>Combining different layers and different tasks so that your module is &quot;deep&quot; rather than &quot;shallow&quot; will make your code much higher cognitive load and create a lot of bugs.</div><br/></div></div></div></div><div id="42513597" class="c"><input type="checkbox" id="c-42513597" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#42511469">prev</a><span>|</span><a href="#42511605">next</a><span>|</span><label class="collapse" for="c-42513597">[-]</label><label class="expand" for="c-42513597">[2 more]</label></div><br/><div class="children"><div class="content">I think it is somewhat misguided notion that code could have a property whose value is its &quot;cognitive load&quot;. Instead we should start from the premise that:<p>1. Somebody writes a program<p>2. Somebody else (perhaps the same programmer a few years later) tries to read and understand that program<p>So the &quot;cognitive load&quot; is a property of the communication between the person who writes the program and others who read and (try to) understand the program.<p>Cognitive Load is an attribute of communication, not of the artifact that is the medium of the communication (i.r. the code written).<p>Are we writing in a &quot;language&quot; that readers will understand? And are we reading in a way that our assumptions about what the writer is trying communicate to us are correct?<p>A program is instructions to the computer. But when written in a highj-level language it is also meant to be read by other prrogrammers, not just by the CPU. It is human-to-human communication. How easy is it for somebody to understand what somebody else is trying to tell the computer to do? That&#x27;s the &quot;Cognitive Load&quot;.</div><br/><div id="42513634" class="c"><input type="checkbox" id="c-42513634" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#42513597">parent</a><span>|</span><a href="#42511605">next</a><span>|</span><label class="collapse" for="c-42513634">[-]</label><label class="expand" for="c-42513634">[1 more]</label></div><br/><div class="children"><div class="content">Code is 95% of the communication.<p>And how overcomplicated the code is has a huge (overwhelming everything else) influence on how hard it is to communicate what it does.<p>So in practice it&#x27;s fair to call it the property of the code, even if bad documentation or mentoring can make things unnecessarily worse.<p>Solar system can be modeled as geocentric with enough epicycles, or as heliocentric system with eliptical orbits.<p>One of these is inherently easier to communicate.</div><br/></div></div></div></div><div id="42511605" class="c"><input type="checkbox" id="c-42511605" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42513597">prev</a><span>|</span><a href="#42513161">next</a><span>|</span><label class="collapse" for="c-42511605">[-]</label><label class="expand" for="c-42511605">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Layered architecture: Abstraction is supposed to hide complexity, here it just adds indirection<p>Agree with everything except this. As someone who deals with workflows and complex business domains, separating your technical concerns from your core domain is not only necessary. They are a key means to survival.<p>Once you have 3 different input-channels and 5 external systems you need to call, you absolutely need to keep your distance not to pollute your core representation of the actual problem you need to solve.</div><br/></div></div><div id="42513161" class="c"><input type="checkbox" id="c-42513161" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#42511605">prev</a><span>|</span><a href="#42510561">next</a><span>|</span><label class="collapse" for="c-42513161">[-]</label><label class="expand" for="c-42513161">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the author&#x27;s point. It was the founding principle of &quot;object oriented&quot; programming in that once the object was a black box, you could just rely on it working and let go of the implementation details. But it is also important in day to day work. I remember when I realized that I could only keep six distinct &quot;disasters&quot; in my head at the same time. Trying to add another one would pop one out of my head. So much of life can be simplified if you systematize things so that the thing to remember is small, like all of the stuff you take on business trips (shave kit, travel charger, noise cancelling headphones, whatever) if you put all of it in a box in your closet labelled &quot;travel kit&quot; then you only have to remember three things, outfits for &#x27;n&#x27; days, your laptop, and your travel kit. Got those three and you are good to go.</div><br/></div></div><div id="42510561" class="c"><input type="checkbox" id="c-42510561" checked=""/><div class="controls bullet"><span class="by">vonnik</span><span>|</span><a href="#42513161">prev</a><span>|</span><a href="#42510594">next</a><span>|</span><label class="collapse" for="c-42510561">[-]</label><label class="expand" for="c-42510561">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree with this and would add that cognitive load is not just a matter of the code before you, but a function of your total digital environment:<p><a href="https:&#x2F;&#x2F;vonnik.substack.com&#x2F;p&#x2F;how-to-take-your-brain-back" rel="nofollow">https:&#x2F;&#x2F;vonnik.substack.com&#x2F;p&#x2F;how-to-take-your-brain-back</a><p>Interruptions and distractions leave a cognitive residue that drastically reduces working memory through the Zeigarnik effect.</div><br/></div></div><div id="42510594" class="c"><input type="checkbox" id="c-42510594" checked=""/><div class="controls bullet"><span class="by">Freak_NL</span><span>|</span><a href="#42510561">prev</a><span>|</span><a href="#42513792">next</a><span>|</span><label class="collapse" for="c-42510594">[-]</label><label class="expand" for="c-42510594">[2 more]</label></div><br/><div class="children"><div class="content">That short&#x2F;long toggle in the top-right seems to expand and collapse the article. It defaults to short. Reading this article in its short form I kept wondering if I was missing something relevant (cognitive load++), but with the long form on I kept wondering if some paragraphs were explicitly intended to be superfluous or tangential (cognitive load++) for the sake of that collapsing trick.<p>For an article on cognitive load, using a gimmick which increases it seems ironic.</div><br/><div id="42510627" class="c"><input type="checkbox" id="c-42510627" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#42510594">parent</a><span>|</span><a href="#42513792">next</a><span>|</span><label class="collapse" for="c-42510627">[-]</label><label class="expand" for="c-42510627">[1 more]</label></div><br/><div class="children"><div class="content">I thought these things were pretty inferable</div><br/></div></div></div></div><div id="42513792" class="c"><input type="checkbox" id="c-42513792" checked=""/><div class="controls bullet"><span class="by">jonplackett</span><span>|</span><a href="#42510594">prev</a><span>|</span><a href="#42510953">next</a><span>|</span><label class="collapse" for="c-42513792">[-]</label><label class="expand" for="c-42513792">[1 more]</label></div><br/><div class="children"><div class="content">Lots of board games exploit this - eg settlers of catan has 5 resources and it’s really hard to think about all 5 at once. You always forget one! (Well I do anyway)</div><br/></div></div><div id="42510953" class="c"><input type="checkbox" id="c-42510953" checked=""/><div class="controls bullet"><span class="by">mrcsd</span><span>|</span><a href="#42513792">prev</a><span>|</span><a href="#42513712">next</a><span>|</span><label class="collapse" for="c-42510953">[-]</label><label class="expand" for="c-42510953">[1 more]</label></div><br/><div class="children"><div class="content">IMO cognative load is much easier to manage when required (human) memory use is less of a factor. In practical terms, this means maximising the locality of reasoning, i.e., having everything you need in front of you to make a decision. One of the reasons I favour rust is precisely because this factor has been a focus in the design.</div><br/></div></div><div id="42513712" class="c"><input type="checkbox" id="c-42513712" checked=""/><div class="controls bullet"><span class="by">majgr</span><span>|</span><a href="#42510953">prev</a><span>|</span><a href="#42511791">next</a><span>|</span><label class="collapse" for="c-42513712">[-]</label><label class="expand" for="c-42513712">[1 more]</label></div><br/><div class="children"><div class="content">My whole experience of working 18 years as a software developer can be summed up with two words: ‚it depends’. Every nice architecture set up front breaks at some point. There is no silver bullet.</div><br/></div></div><div id="42511791" class="c"><input type="checkbox" id="c-42511791" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#42513712">prev</a><span>|</span><a href="#42513533">next</a><span>|</span><label class="collapse" for="c-42511791">[-]</label><label class="expand" for="c-42511791">[1 more]</label></div><br/><div class="children"><div class="content">Programmers and tech people should understand why cognitive load needs to be reduced.<p>All of us would scream if we saw how some bureaucrat at a government office makes you fill out some form digitally only to print it out and then type off the printout, only to print it out and give it to their collegue, who.. you get the point.<p>This is a problem that could be solved perfectly by a good IT process — a process which instead of multiplying work instead reduces it.<p>Yet programmers and nerds tend to similar wasteful behaviour when it comes to cognitive load. &quot;Why should I explain the code — it speaks for itself&quot; can be similarily foolish. You <i>already</i> spent all that time to think about and understand your code, so why let that all go to waste and throw out all clues that would help even other hardcore nerds to orient themselves? Good code is clear code, good projects are like a good spaceship: the hero who never has been in this ship knows which button to press, because you — the engineer — made sure the obvious button does the obvious thing. More often than not that hero is your future self.<p>People reading our code, readmes and using our interfaces got all kind of things on their minds, the best we can do is not waste their mental capacity without a good reason.</div><br/></div></div><div id="42513533" class="c"><input type="checkbox" id="c-42513533" checked=""/><div class="controls bullet"><span class="by">RandomWorker</span><span>|</span><a href="#42511791">prev</a><span>|</span><a href="#42513152">next</a><span>|</span><label class="collapse" for="c-42513533">[-]</label><label class="expand" for="c-42513533">[1 more]</label></div><br/><div class="children"><div class="content">This is the best article I&#x27;ve read on programming in a while. When I code all I do is work on one object or one function at a time. Working usually on the end result. The key here is to develop a quick and easy solution without too many issues. This is also the difference between new and experienced developers. Experienced developers have less fluid intelligence so build reliable simple programs.</div><br/></div></div><div id="42510338" class="c"><input type="checkbox" id="c-42510338" checked=""/><div class="controls bullet"><span class="by">xnx</span><span>|</span><a href="#42513152">prev</a><span>|</span><a href="#42511165">next</a><span>|</span><label class="collapse" for="c-42510338">[-]</label><label class="expand" for="c-42510338">[1 more]</label></div><br/><div class="children"><div class="content">This applies to user experience as well. I&#x27;ve seen designers focus on number of items or number of clicks when mental effort &#x2F; cognitive load is what matters. Sometimes picking from a list of 50 links is easier. Sometimes answering 7 yes&#x2F;no questions is easier.</div><br/></div></div><div id="42511165" class="c"><input type="checkbox" id="c-42511165" checked=""/><div class="controls bullet"><span class="by">meowface</span><span>|</span><a href="#42510338">prev</a><span>|</span><a href="#42510740">next</a><span>|</span><label class="collapse" for="c-42511165">[-]</label><label class="expand" for="c-42511165">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve sometimes seen people attack early returns and I&#x27;ve never understood it. To me they make things so much cleaner that it seems like common sense.</div><br/></div></div><div id="42510740" class="c"><input type="checkbox" id="c-42510740" checked=""/><div class="controls bullet"><span class="by">fferen</span><span>|</span><a href="#42511165">prev</a><span>|</span><a href="#42512432">next</a><span>|</span><label class="collapse" for="c-42510740">[-]</label><label class="expand" for="c-42510740">[1 more]</label></div><br/><div class="children"><div class="content">Disagree with first example. If that condition is only used once, adding a variable introduces more state to keep track of, that could just be a comment next to the conditional.</div><br/></div></div><div id="42512432" class="c"><input type="checkbox" id="c-42512432" checked=""/><div class="controls bullet"><span class="by">singingfish</span><span>|</span><a href="#42510740">prev</a><span>|</span><label class="collapse" for="c-42512432">[-]</label><label class="expand" for="c-42512432">[1 more]</label></div><br/><div class="children"><div class="content">Aligning the computer&#x27;s and the humans&#x27; thinking processes.  Cognitive load is exceptionally important - one of the few uncontravenable facts in human psychology is that healthy human short term memory has a capacity of 5 items plus or minus 2.  So reliably 5.  And thus the maximum number of thinking balls you should be juggling at one time.<p>Which then leads to thinking about designs that lead to the management of cognitive load - thus the nature of the balls changes due to things like chunking and context.  Which are theoretical constructs that came out of that memory research.<p>So yes, this is pretty much principal zero -  cognitive load and understanding the theory underneath it are the most important thing - and are closely related to the two hard problems in computer science (cache invalidation, naming things and off by one errors).<p>Thank you for attending my TED talk</div><br/></div></div></div></div></div></div></div></body></html>