<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692435656830" as="style"/><link rel="stylesheet" href="styles.css?v=1692435656830"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/source-and-buggy/do-one-thing-and-do-it-well-886b11a5d21">Kernighan and Pike were right: Do one thing, and do it well</a> <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>yarapavan</span> | <span>49 comments</span></div><br/><div><div id="37186877" class="c"><input type="checkbox" id="c-37186877" checked=""/><div class="controls bullet"><span class="by">francasso</span><span>|</span><a href="#37186068">next</a><span>|</span><label class="collapse" for="c-37186877">[-]</label><label class="expand" for="c-37186877">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need a damn network between two pieces of code just to &quot;do one thing and do it well&quot;, for God&#x27;s sake, I&#x27;m so sick of this rampant cluelessness in the industry.<p>Do you saturate the resources of one machine and need to split things off? Do you have multiple teams each taking care of their own stuff? Do multiple services, it&#x27;s fine in those cases. For almost any other reason you are just adding complexity, boilerplate and additional failure conditions.<p>If you think that microservices solve the &quot;spaghetti code problem&quot;, well, good luck to you, you&#x27;ll need it.</div><br/></div></div><div id="37186068" class="c"><input type="checkbox" id="c-37186068" checked=""/><div class="controls bullet"><span class="by">tailspin2019</span><span>|</span><a href="#37186877">prev</a><span>|</span><a href="#37186144">next</a><span>|</span><label class="collapse" for="c-37186068">[-]</label><label class="expand" for="c-37186068">[8 more]</label></div><br/><div class="children"><div class="content">Good article, but to me it seems to be co-opting the term enshitification in a strange way:<p>&gt; Large codebases will eventually reach an “enshittification point” — the point at which bugs are introduced faster than they can reasonably be fixed.<p>I think of enshitification primarily as an organisational&#x2F;business phenomenon rather than a technical one.<p>It doesn’t necessarily emerge “bottom up” as the result of technical debt but from top down as a result of misalignment of values between the brutally commercial goals of the business and the values&#x2F;goals if its customers. Tech debt and development velocity do play into this but I don’t think it’s the <i>primary</i> driver of it.<p>The term is a useful one at that level of abstraction imho because we already have quite a lot of language to describe things like this at the lower, more technical level.</div><br/><div id="37186437" class="c"><input type="checkbox" id="c-37186437" checked=""/><div class="controls bullet"><span class="by">maxweylandt</span><span>|</span><a href="#37186068">parent</a><span>|</span><a href="#37186301">next</a><span>|</span><label class="collapse" for="c-37186437">[-]</label><label class="expand" for="c-37186437">[1 more]</label></div><br/><div class="children"><div class="content">That caught my attention too. The misuse is especially strange because the author both cites Doctorow and links to a definition in line with Doctorow&#x27;s usage, before then using it in a  completely different sense<p><a href="https:&#x2F;&#x2F;en.m.wiktionary.org&#x2F;wiki&#x2F;enshittification" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wiktionary.org&#x2F;wiki&#x2F;enshittification</a></div><br/></div></div><div id="37186301" class="c"><input type="checkbox" id="c-37186301" checked=""/><div class="controls bullet"><span class="by">asddubs</span><span>|</span><a href="#37186068">parent</a><span>|</span><a href="#37186437">prev</a><span>|</span><a href="#37186653">next</a><span>|</span><label class="collapse" for="c-37186301">[-]</label><label class="expand" for="c-37186301">[1 more]</label></div><br/><div class="children"><div class="content">To me enshittification is when the overall usefulness of a piece of software starts going down as more money is attempted to be squeezed out of its users. Agree that it&#x27;s not a technical phenomenon</div><br/></div></div><div id="37186653" class="c"><input type="checkbox" id="c-37186653" checked=""/><div class="controls bullet"><span class="by">benj111</span><span>|</span><a href="#37186068">parent</a><span>|</span><a href="#37186301">prev</a><span>|</span><a href="#37186646">next</a><span>|</span><label class="collapse" for="c-37186653">[-]</label><label class="expand" for="c-37186653">[4 more]</label></div><br/><div class="children"><div class="content">Suggestions for a term for the phenomena?<p>Emshitifaction?</div><br/><div id="37186880" class="c"><input type="checkbox" id="c-37186880" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#37186068">root</a><span>|</span><a href="#37186653">parent</a><span>|</span><a href="#37186779">next</a><span>|</span><label class="collapse" for="c-37186880">[-]</label><label class="expand" for="c-37186880">[1 more]</label></div><br/><div class="children"><div class="content">In my native language, we widely use therm &quot;Information explosion&quot;.</div><br/></div></div><div id="37186779" class="c"><input type="checkbox" id="c-37186779" checked=""/><div class="controls bullet"><span class="by">ahofmann</span><span>|</span><a href="#37186068">root</a><span>|</span><a href="#37186653">parent</a><span>|</span><a href="#37186880">prev</a><span>|</span><a href="#37186871">next</a><span>|</span><label class="collapse" for="c-37186779">[-]</label><label class="expand" for="c-37186779">[1 more]</label></div><br/><div class="children"><div class="content">The article could have used the term technical debt. To me technical debt happens not only when new code gets added in a sloppy way, but also when the developer experience gets worse.</div><br/></div></div><div id="37186871" class="c"><input type="checkbox" id="c-37186871" checked=""/><div class="controls bullet"><span class="by">SuchAnonMuchWow</span><span>|</span><a href="#37186068">root</a><span>|</span><a href="#37186653">parent</a><span>|</span><a href="#37186779">prev</a><span>|</span><a href="#37186646">next</a><span>|</span><label class="collapse" for="c-37186871">[-]</label><label class="expand" for="c-37186871">[1 more]</label></div><br/><div class="children"><div class="content">crushed by technical debt</div><br/></div></div></div></div><div id="37186646" class="c"><input type="checkbox" id="c-37186646" checked=""/><div class="controls bullet"><span class="by">badpun</span><span>|</span><a href="#37186068">parent</a><span>|</span><a href="#37186653">prev</a><span>|</span><a href="#37186144">next</a><span>|</span><label class="collapse" for="c-37186646">[-]</label><label class="expand" for="c-37186646">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve once worked on a large and old Scala-cats codebase (i.e. Haskel-style, the whole program as an IO monad). I&#x27;d say we (the team) hardly introduced any bugs. The language made making whole classes of errors less likely, and the team&#x27;s disciplined approach handled the rest.</div><br/></div></div></div></div><div id="37186144" class="c"><input type="checkbox" id="c-37186144" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37186068">prev</a><span>|</span><a href="#37186817">next</a><span>|</span><label class="collapse" for="c-37186144">[-]</label><label class="expand" for="c-37186144">[12 more]</label></div><br/><div class="children"><div class="content">The basic point is right, but I think a lot of the details are off. The core idea is composition. A system is compositional if you can build it from small reusable parts. It&#x27;s one of the key ideas in functional programming, and it&#x27;s somewhat core to object-oriented programming. (OO is too big to be able to claim their is a consistent philosophy behind it.)<p>But ... firstly, let&#x27;s stop with the Unix worship. They didn&#x27;t deliver, even in the domain of the terminal. My copy of `ls` has at least 40 flags (where I stopped counting). Secondly, people have tried composition on the desktop. That&#x27;s what CORBA, COM, and OLE were all about. They all kinda sucked for various reasons. Finally, the place at which the author arises has been around for as long as Unix: it&#x27;s Emacs.</div><br/><div id="37186855" class="c"><input type="checkbox" id="c-37186855" checked=""/><div class="controls bullet"><span class="by">throwaway31381</span><span>|</span><a href="#37186144">parent</a><span>|</span><a href="#37186158">next</a><span>|</span><label class="collapse" for="c-37186855">[-]</label><label class="expand" for="c-37186855">[1 more]</label></div><br/><div class="children"><div class="content">&gt;But ... firstly, let&#x27;s stop with the Unix worship. They didn&#x27;t deliver, even in the domain of the terminal. My copy of `ls` has at least 40 flags<p>GNU is Not Unix.<p>I count 13 flags on both Unix V10 [1] and on Plan 9 [2], its spiritual successor.<p>[1] <a href="http:&#x2F;&#x2F;man.cat-v.org&#x2F;unix_10th&#x2F;1&#x2F;ls" rel="nofollow noreferrer">http:&#x2F;&#x2F;man.cat-v.org&#x2F;unix_10th&#x2F;1&#x2F;ls</a><p>[2] <a href="http:&#x2F;&#x2F;man.cat-v.org&#x2F;plan_9&#x2F;1&#x2F;ls" rel="nofollow noreferrer">http:&#x2F;&#x2F;man.cat-v.org&#x2F;plan_9&#x2F;1&#x2F;ls</a></div><br/></div></div><div id="37186158" class="c"><input type="checkbox" id="c-37186158" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37186144">parent</a><span>|</span><a href="#37186855">prev</a><span>|</span><a href="#37186256">next</a><span>|</span><label class="collapse" for="c-37186158">[-]</label><label class="expand" for="c-37186158">[5 more]</label></div><br/><div class="children"><div class="content">Not only is COM still around, it is the main delivery mechanism for Windows APIs since Vista.<p>Agree with UNIX worship point, I also had it, I was young and naive, lacking experience in the history of computer systems.</div><br/><div id="37186167" class="c"><input type="checkbox" id="c-37186167" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186158">parent</a><span>|</span><a href="#37186256">next</a><span>|</span><label class="collapse" for="c-37186167">[-]</label><label class="expand" for="c-37186167">[4 more]</label></div><br/><div class="children"><div class="content">Wow, I didn&#x27;t realise. I haven&#x27;t paid attention to Windows APIs for a long time. I really thought it would have died a long time ago.</div><br/><div id="37186184" class="c"><input type="checkbox" id="c-37186184" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186167">parent</a><span>|</span><a href="#37186343">next</a><span>|</span><label class="collapse" for="c-37186184">[-]</label><label class="expand" for="c-37186184">[1 more]</label></div><br/><div class="children"><div class="content">That is what people outside Windows keep thinking.<p>After WinDev managed to botch Longhorn efforts, its .NET ideas were redone in COM for Vista, and it has been like that ever since.<p>WinRT&#x2F;UAP&#x2F;UWP, is basically COM with a new base interface IInspectable, .NET metadata instead of TLB files, and app boxing.<p>And it is the foundation of WinAppSDK, whose goal is to port UWP subsystem into plain Win32, although their current execution leaves a lot to be desired.</div><br/></div></div><div id="37186343" class="c"><input type="checkbox" id="c-37186343" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186167">parent</a><span>|</span><a href="#37186184">prev</a><span>|</span><a href="#37186256">next</a><span>|</span><label class="collapse" for="c-37186343">[-]</label><label class="expand" for="c-37186343">[2 more]</label></div><br/><div class="children"><div class="content">The core of COM is about allowing binary code to be used from any language through a standardized interface.<p>As pjmlp mentioned, this part was very successful and all new Windows APIs are based on it.<p>The COM which failed and which you are thinking about was related to OLE and the idea of embedding Excel sheets inside Photoshop drawings, ...</div><br/></div></div></div></div></div></div><div id="37186256" class="c"><input type="checkbox" id="c-37186256" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37186144">parent</a><span>|</span><a href="#37186158">prev</a><span>|</span><a href="#37186817">next</a><span>|</span><label class="collapse" for="c-37186256">[-]</label><label class="expand" for="c-37186256">[5 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s just be careful what we call Unix though. In SVR4, I don&#x27;t think &quot;ls&quot; had that many options. It didn&#x27;t even have colour (not that I would know; my Wyse 60 could only have Green, Orange or White text... and the colour was set in the factory).<p>It&#x27;s the same for many programs that started small but grew loads of knobs with age. You can&#x27;t claim that this was the Unix vision, because what we call Unix today isn&#x27;t even technically Unix.<p>I&#x27;m not saying Linux is bad or anything; I&#x27;m just pointing out that it&#x27;s much more organic than Unix ever was, and that the resulting system is not necessarily carefully orchestrated.</div><br/><div id="37186644" class="c"><input type="checkbox" id="c-37186644" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186256">parent</a><span>|</span><a href="#37186703">next</a><span>|</span><label class="collapse" for="c-37186644">[-]</label><label class="expand" for="c-37186644">[3 more]</label></div><br/><div class="children"><div class="content">IMO the problem with the Unix model is not that it&#x27;s been corrupted over time, but that it was fundamentally flawed from the start. I&#x27;m hardly the first to point this out, but sending around unstructured text makes doing some things inordinately hard (imagine writing a separate program to color ls&#x27;s output, instead of having that as a flag) + going beyond pipes leads to the awful experience of programming in shell.</div><br/><div id="37186749" class="c"><input type="checkbox" id="c-37186749" checked=""/><div class="controls bullet"><span class="by">benj111</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186644">parent</a><span>|</span><a href="#37186703">next</a><span>|</span><label class="collapse" for="c-37186749">[-]</label><label class="expand" for="c-37186749">[2 more]</label></div><br/><div class="children"><div class="content">Ls seems like a bad example.<p>Anything that you&#x27;d want to colour, the data should already be there.<p>Further I&#x27;m not sure the Unix way inherently requires completely unstructured text</div><br/><div id="37186844" class="c"><input type="checkbox" id="c-37186844" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186749">parent</a><span>|</span><a href="#37186703">next</a><span>|</span><label class="collapse" for="c-37186844">[-]</label><label class="expand" for="c-37186844">[1 more]</label></div><br/><div class="children"><div class="content">Unstructured text <i>is</i> the unix way. You can have pipelines sending other things between your programs (see powershell), but that&#x27;s definitely not Unix.</div><br/></div></div></div></div></div></div><div id="37186703" class="c"><input type="checkbox" id="c-37186703" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#37186144">root</a><span>|</span><a href="#37186256">parent</a><span>|</span><a href="#37186644">prev</a><span>|</span><a href="#37186817">next</a><span>|</span><label class="collapse" for="c-37186703">[-]</label><label class="expand" for="c-37186703">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still a failing of the Unix philosophy that people found it easier to add all these flags to ls than to string together a few &quot;simple&amp;composable&quot; commands.</div><br/></div></div></div></div></div></div><div id="37186817" class="c"><input type="checkbox" id="c-37186817" checked=""/><div class="controls bullet"><span class="by">i_don_t_know</span><span>|</span><a href="#37186144">prev</a><span>|</span><a href="#37186756">next</a><span>|</span><label class="collapse" for="c-37186817">[-]</label><label class="expand" for="c-37186817">[1 more]</label></div><br/><div class="children"><div class="content">To me, Wirth’s Oberon system has the same philosophy of having small composable tools and being extensible. There’s no distinction between system language and scripting language. Text is also a common way of passing data, but you can use whatever data structure you want. I think of it less as an OS than as an application shell that you shape to your needs.</div><br/></div></div><div id="37186756" class="c"><input type="checkbox" id="c-37186756" checked=""/><div class="controls bullet"><span class="by">deng</span><span>|</span><a href="#37186817">prev</a><span>|</span><a href="#37186312">next</a><span>|</span><label class="collapse" for="c-37186756">[-]</label><label class="expand" for="c-37186756">[1 more]</label></div><br/><div class="children"><div class="content">I wish people would stop applying the &quot;only do one thing and do it well&quot; to all software. 
Kernighan&#x2F;Pike were explicitly talking about software tools in the Unix environment, not about all software in general. It is an idealist, you might even say elitist view of how software should work, which they then realized in Plan9. And as impressive as Plan9 is, there&#x27;s a reason it never got widespread adoption, and that is not just because of evil Microsoft&#x2F;IBM&#x2F;whatever. It simply did not solve the problems people had, because it did not run the software the people (which are mostly non-programmers) actually needed to do their daily work. Yes, you can use these systems to write shell primitives, yet another build system, a window manager, a Wiki system, a basic text editor - mostly tools for programmers. It&#x27;s like people with 3D printers mostly printing stuff to improve their 3D printer.</div><br/></div></div><div id="37186312" class="c"><input type="checkbox" id="c-37186312" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#37186756">prev</a><span>|</span><a href="#37185999">next</a><span>|</span><label class="collapse" for="c-37186312">[-]</label><label class="expand" for="c-37186312">[9 more]</label></div><br/><div class="children"><div class="content">These tools are not composable once you venture outside of a shell, and if I have to write anything beyond 5 lines, I&#x27;m not using one. There needs to be a way to make these applications usable as software libraries, and no, invoking them as a separate process from the main application does not count. This is the reason the functionality of these tools have been reinvented many times over and why they get extra cruft added is because they&#x27;re actually not composable everywhere that matters.<p>edit: typo</div><br/><div id="37186469" class="c"><input type="checkbox" id="c-37186469" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37186312">parent</a><span>|</span><a href="#37186529">next</a><span>|</span><label class="collapse" for="c-37186469">[-]</label><label class="expand" for="c-37186469">[1 more]</label></div><br/><div class="children"><div class="content">We need more standard special purpose interfaces. Not unstructured RPC protocols, but very specific &quot;Every plugin of this type has this function that does exactly this&quot; kinds of things.<p>Linux people seem to tolerate bash partly because they DO have a special purpose modular system. They algorithmically manipulate text in batch rather than realtime mode to produce an output on a regular basis(I&#x27;m not sure for what, besides compiling and building, but they all say they have use cases).  Apparently it works great if you process lots of text files.<p>Perhaps a GitHub awesome list.  I&#x27;ve been meaning to start one for very common standards in general(18650 batteries, tripod thread, etc).<p>We have LADSPA and LV2 for audio, shell commands for text, etc, What else do we have, and what should we have?</div><br/></div></div><div id="37186529" class="c"><input type="checkbox" id="c-37186529" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#37186312">parent</a><span>|</span><a href="#37186469">prev</a><span>|</span><a href="#37186545">next</a><span>|</span><label class="collapse" for="c-37186529">[-]</label><label class="expand" for="c-37186529">[4 more]</label></div><br/><div class="children"><div class="content">&gt; invoking them as a separate process from the main application does not count<p>Why not?  What is your worry?  That starting a process is too slow?  That data transfer is too slow?  Something else?<p>I agree that process startup may be meaningful overhead in the rare cases when the actual computation is very fast.  But sharing uncompressed data between programs is essentially zero-cost.<p>Separate processes look particularly elegant and modular to me.  They are much easier to debug and profile than bolted-in dependencies, since the running time and input&#x2F;output of each process are trivial to isolate.  Of course, having both a library and a cli interface for the same computational brick is always better, but the unix-style tool is an essential thing to have.</div><br/><div id="37186780" class="c"><input type="checkbox" id="c-37186780" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#37186312">root</a><span>|</span><a href="#37186529">parent</a><span>|</span><a href="#37186732">next</a><span>|</span><label class="collapse" for="c-37186780">[-]</label><label class="expand" for="c-37186780">[1 more]</label></div><br/><div class="children"><div class="content">As someone who writes software that does a lot of this:<p>Process management gets very annoying, very quickly. When you run a helper program soon you have to consider process management. What if it crashes? What if it gets stuck? What if you crash and it remains running? What if the user uses the same program elsewhere? None of this gets work done.<p>A text stream is an awful API. Many times the called program doesn&#x27;t intend to provide an API, or doesn&#x27;t commit to stability. Your code breaks because version 5.0.2 fixed a typo, and you relied on the typo for your parsing.<p>A text stream is an awful API. Instead of a nice protocol you get to parse lots of text, deal with escaping and quoting. You better hope the called program does it competently. It may well not, then you have a problem.<p>A text stream is an awful API. No normal program will dump or read a JPEG over stdin&#x2F;stdout, so if you need to communicate some sort of binary data now you need another communication channel. That may involve commandline arguments, killing, restarting the program, and reestablishing the state. More process management fun.<p>A text stream is an awful API. You&#x27;ll find yourself doing things like assembling multiple lines of output into a single coherent concept, and trying to detect where something ends when the program doesn&#x27;t necessarily provide a clear indication.<p>A text stream is an awful API. Sometimes programs print stuff before it took effect, and may not ever give you a clear indication of &quot;now it&#x27;s been applied&quot;. You may need to somehow test for it, retry operations, insert wait states.<p>99% of the effort invested in this doesn&#x27;t get work done. You&#x27;re spending it on management that wouldn&#x27;t exist if you were using a sane API like DBus or similar, where you don&#x27;t deal with process management, where things are broken down into nice fields, and where the API is intended as an API.</div><br/></div></div><div id="37186732" class="c"><input type="checkbox" id="c-37186732" checked=""/><div class="controls bullet"><span class="by">gonzus</span><span>|</span><a href="#37186312">root</a><span>|</span><a href="#37186529">parent</a><span>|</span><a href="#37186780">prev</a><span>|</span><a href="#37186650">next</a><span>|</span><label class="collapse" for="c-37186732">[-]</label><label class="expand" for="c-37186732">[1 more]</label></div><br/><div class="children"><div class="content">I agree 100% with using processes as the natural unit of isolation.<p>I also believe we could solve many of the integration issues between multiple tools, by having them all optionally spit out a universal, easy &#x2F; easier to parse format -- even JSON would be good here. So you could do<p><pre><code>  ls --foo --bar --json | jq ...
</code></pre>
and be able to process the output to your heart&#x27;s content, <i>without</i> having to do any kind of white space parsing; as a free bonus, you get automatic support for file names with embedded white space...<p>The best we have for now is jc (<a href="https:&#x2F;&#x2F;kellyjonbrazil.github.io&#x2F;jc&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;kellyjonbrazil.github.io&#x2F;jc&#x2F;</a>), which knows how to do this for a closed (but growing?) set of commands:<p><pre><code>  ls -l *.db | jc --ls | jq .</code></pre></div><br/></div></div><div id="37186650" class="c"><input type="checkbox" id="c-37186650" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#37186312">root</a><span>|</span><a href="#37186529">parent</a><span>|</span><a href="#37186732">prev</a><span>|</span><a href="#37186545">next</a><span>|</span><label class="collapse" for="c-37186650">[-]</label><label class="expand" for="c-37186650">[1 more]</label></div><br/><div class="children"><div class="content">Performance is not what concerns me, it&#x27;s design. To what end is it useful to have distinctions between libraries and applications? If I have a JSON parsing library, it might be nice to run one-off scripts that grab a certain value and pipe it somewhere else. It&#x27;s also useful to deserialise in complex manners inside an app of my design. My belief is that programs whether they are intended to or not usually end up being composed with other programs so on that basis, having the distinction of bin&#x2F;lib doesn&#x27;t serve a useful end to me at least.</div><br/></div></div></div></div><div id="37186545" class="c"><input type="checkbox" id="c-37186545" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#37186312">parent</a><span>|</span><a href="#37186529">prev</a><span>|</span><a href="#37186377">next</a><span>|</span><label class="collapse" for="c-37186545">[-]</label><label class="expand" for="c-37186545">[1 more]</label></div><br/><div class="children"><div class="content">On a modern Unix-like OS, these tools aren’t as simple as they used to be in the 1970s. The man page for ls alone lists tens of options, corner cases and historical cruft. If those tools were really composable, they wouldn’t need so many options hidden in their man pages.</div><br/></div></div><div id="37186377" class="c"><input type="checkbox" id="c-37186377" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37186312">parent</a><span>|</span><a href="#37186545">prev</a><span>|</span><a href="#37185999">next</a><span>|</span><label class="collapse" for="c-37186377">[-]</label><label class="expand" for="c-37186377">[2 more]</label></div><br/><div class="children"><div class="content">Did you read the article? The entire last half is how to apply it to UIs and what that looks like (Obsidian, Canva, etc).</div><br/><div id="37186447" class="c"><input type="checkbox" id="c-37186447" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#37186312">root</a><span>|</span><a href="#37186377">parent</a><span>|</span><a href="#37185999">next</a><span>|</span><label class="collapse" for="c-37186447">[-]</label><label class="expand" for="c-37186447">[1 more]</label></div><br/><div class="children"><div class="content">I did. I&#x27;m talking about CLI apps, though that wasn&#x27;t clear I will admit.</div><br/></div></div></div></div></div></div><div id="37185999" class="c"><input type="checkbox" id="c-37185999" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37186312">prev</a><span>|</span><a href="#37186626">next</a><span>|</span><label class="collapse" for="c-37185999">[-]</label><label class="expand" for="c-37185999">[2 more]</label></div><br/><div class="children"><div class="content">I take issue with the pasta diagram.<p>I was there, in the 1990&#x27;s, as a working professional not a hobbyist. The popular architecture was, for better or worse, structured as layers, not spaghetti.<p>Some software from the 80s might meet that definition, but I think it&#x27;s uncharitable (almost to the point of insulting) to assert that until the 2000s most programmers didn&#x27;t know how to write anything but spaghetti code.</div><br/><div id="37186042" class="c"><input type="checkbox" id="c-37186042" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#37185999">parent</a><span>|</span><a href="#37186626">next</a><span>|</span><label class="collapse" for="c-37186042">[-]</label><label class="expand" for="c-37186042">[1 more]</label></div><br/><div class="children"><div class="content">There was a moment when OOP was the new hot thing that code got real noodly, but this was arguably a temporary regresssion.</div><br/></div></div></div></div><div id="37186626" class="c"><input type="checkbox" id="c-37186626" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#37185999">prev</a><span>|</span><a href="#37185980">next</a><span>|</span><label class="collapse" for="c-37186626">[-]</label><label class="expand" for="c-37186626">[1 more]</label></div><br/><div class="children"><div class="content">As a developer I can sort of see the appeal. I often have tasks where I can compose programs.<p>But as a user I just want the software that solves my problem from start to finish even if it does a worse job and costs more. Even if there are N pieces of software that solves my problem in N steps, that composition isn’t something I generally can or want to do. I just want someone to make a big ball of mud app that does exactly what I need. It’ll try to do whatever everyone else needs too, which is why it is a buggy ball of mud. But it’s <i>still</i> a lot more attractive than having N separate steps and doing any sort of composition myself. Because that invariably requires knowing about files, data formats compatibility between components .<p>The Unix principle works well in Unix because the people using it are computer people, perhaps even software developers. In the age of everyone using computers (so 1990 and onwards) this breaks down horribly. The big ball of buggy mud do-it-all Software wins hands down every time.</div><br/></div></div><div id="37185980" class="c"><input type="checkbox" id="c-37185980" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#37186626">prev</a><span>|</span><a href="#37186876">next</a><span>|</span><label class="collapse" for="c-37185980">[-]</label><label class="expand" for="c-37185980">[5 more]</label></div><br/><div class="children"><div class="content">Its an insightful read and the final graph analogy seems very apposite. But here is the rub: if microservices is a general graph pattern, it <i>includes</i> all the other patterns (likear, hub and spoke etc) as these are all just particular graphs.<p>In other words, you could implememt unix pipe like or plugin like microservices by applying certain constraints.</div><br/><div id="37186169" class="c"><input type="checkbox" id="c-37186169" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37185980">parent</a><span>|</span><a href="#37186120">next</a><span>|</span><label class="collapse" for="c-37186169">[-]</label><label class="expand" for="c-37186169">[2 more]</label></div><br/><div class="children"><div class="content">Is that relevant, though? An undirected cyclic graph is a superset of all other data structures[1], yet we still differentiate between them and choose the most suitable.<p>[1] And can be used to build all other data structures. A tree is a directed acyclic graph, a list is a tree with no more than one child per node, etc</div><br/><div id="37186828" class="c"><input type="checkbox" id="c-37186828" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#37185980">root</a><span>|</span><a href="#37186169">parent</a><span>|</span><a href="#37186120">next</a><span>|</span><label class="collapse" for="c-37186828">[-]</label><label class="expand" for="c-37186828">[1 more]</label></div><br/><div class="children"><div class="content">The proof would be in eating the pudding, but the thrust of the argument would be to indeed recognize that &quot;microservices&quot; is too general a pattern and one might benefit and make them more usable by developing tailored patterns (imposing constraints adapted to the data exchanges that dominate the application).<p>Its just a thought sparked by that interesting diagram at the end of the post and motivated by the fact that the REST architecture is also specified as a set of constraints...</div><br/></div></div></div></div><div id="37186120" class="c"><input type="checkbox" id="c-37186120" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#37185980">parent</a><span>|</span><a href="#37186169">prev</a><span>|</span><a href="#37186876">next</a><span>|</span><label class="collapse" for="c-37186120">[-]</label><label class="expand" for="c-37186120">[2 more]</label></div><br/><div class="children"><div class="content">Right, but implementing a restricted domain (pipes) with tools designed for a more general domain (graphs), gives up the efficiencies and reduced complexity of the restricted domain.<p>That is why we have restricted domains.</div><br/><div id="37186752" class="c"><input type="checkbox" id="c-37186752" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#37185980">root</a><span>|</span><a href="#37186120">parent</a><span>|</span><a href="#37186876">next</a><span>|</span><label class="collapse" for="c-37186752">[-]</label><label class="expand" for="c-37186752">[1 more]</label></div><br/><div class="children"><div class="content">The efficiency argument depends a bit on the scope one considers. If you only ever need pipes it makes sense to optimize and learn how to build pipes and your toolkit will reflect that. But if you need a variety of patterns you need to weigh in the inefficiency and cost of switching. The analogy would be a multi-purpose tool versus many special purpose ones (and the knowledge of operating each).<p>This is all theoretical ofcourse, but my sense is that the debate about microservices is colored first of all by the extra complexity of networked computation (which raises the bar for a succesful architecture) and maybe indeed the absence of well defined constraints that would guide people on different possible best practices for segmenting monoliths.</div><br/></div></div></div></div></div></div><div id="37186876" class="c"><input type="checkbox" id="c-37186876" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37185980">prev</a><span>|</span><a href="#37186613">next</a><span>|</span><label class="collapse" for="c-37186876">[-]</label><label class="expand" for="c-37186876">[1 more]</label></div><br/><div class="children"><div class="content">Good thing Elon Musk didn&#x27;t take this advice.</div><br/></div></div><div id="37186613" class="c"><input type="checkbox" id="c-37186613" checked=""/><div class="controls bullet"><span class="by">freddie_mercury</span><span>|</span><a href="#37186876">prev</a><span>|</span><a href="#37186762">next</a><span>|</span><label class="collapse" for="c-37186613">[-]</label><label class="expand" for="c-37186613">[1 more]</label></div><br/><div class="children"><div class="content">I think it is hard to reconcile this with the reality that every big billionaire dollar app does the complete opposite. Excel, Word, Jira, Salesforce, Facebook, Oracle ERP, etc.</div><br/></div></div><div id="37186762" class="c"><input type="checkbox" id="c-37186762" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#37186613">prev</a><span>|</span><a href="#37186168">next</a><span>|</span><label class="collapse" for="c-37186762">[-]</label><label class="expand" for="c-37186762">[1 more]</label></div><br/><div class="children"><div class="content">Spaghetti because there are so many &quot;engineers&quot;</div><br/></div></div><div id="37186168" class="c"><input type="checkbox" id="c-37186168" checked=""/><div class="controls bullet"><span class="by">sdenton4</span><span>|</span><a href="#37186762">prev</a><span>|</span><a href="#37186641">next</a><span>|</span><label class="collapse" for="c-37186168">[-]</label><label class="expand" for="c-37186168">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been having a delightful time these last couple years working with Jax (the machine learning thing), which takes the DOTADIW stance. The philosophy is to get rid of frameworks, and replace them with libraries developed with DOTADIW in mind. This leads to better separation of concerns (amongst the various libraries), fewer leaky abstractions, sane-r, better thought-out APIs, and so on. All kinds of good.</div><br/></div></div><div id="37186641" class="c"><input type="checkbox" id="c-37186641" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37186168">prev</a><span>|</span><a href="#37186686">next</a><span>|</span><label class="collapse" for="c-37186641">[-]</label><label class="expand" for="c-37186641">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s so different about Obsidian that sets it apart from previous plugin-based architectures?<p>In particular, what is true about Obsidian which wasn&#x27;t true about Eclipse some 20 years ago?</div><br/></div></div><div id="37186686" class="c"><input type="checkbox" id="c-37186686" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37186641">prev</a><span>|</span><a href="#37185958">next</a><span>|</span><label class="collapse" for="c-37186686">[-]</label><label class="expand" for="c-37186686">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  To count the number of functions in a rust file you could run:

   cat main.rs | grep &quot;^\s*fn\s&quot; | wc -l
</code></pre>
This both promotes the &quot;one thing well&quot; model, while revealing its inherent limitations.<p>How many functions are in this rust file?<p><pre><code>  &#x2F;* confuse things
  fn fo fp
  fn fm fl
  *&#x2F;
  fn
  main() {
      println!(&quot;Hello, world!&quot;);
  }
</code></pre>
The above grep reports two, when there is only one.<p>It can be made to work if everyone agrees to follow conventions, like always formatting the Rust code, and indenting comments which look like Rust code.<p>But that means pushing complexity onto people, rather than into the tools. Which you could do at the beginning, when complexity is low, but it gets increasingly more difficult over time.</div><br/></div></div><div id="37185958" class="c"><input type="checkbox" id="c-37185958" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#37186686">prev</a><span>|</span><a href="#37186191">next</a><span>|</span><label class="collapse" for="c-37185958">[-]</label><label class="expand" for="c-37185958">[1 more]</label></div><br/><div class="children"><div class="content">It saddens me that he didn&#x27;t have a cartoon with one saying &quot;High cohesion!&quot;  and another (smoking a pipe) saying &quot;Low Coupling!&quot;</div><br/></div></div></div></div></div></div></div></body></html>