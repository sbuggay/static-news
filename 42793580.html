<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737882065672" as="style"/><link rel="stylesheet" href="styles.css?v=1737882065672"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/SpinalHDL/VexRiscv">A FPGA friendly 32 bit RISC-V CPU implementation</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>_benj</span> | <span>50 comments</span></div><br/><div><div id="42823622" class="c"><input type="checkbox" id="c-42823622" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#42827057">next</a><span>|</span><label class="collapse" for="c-42823622">[-]</label><label class="expand" for="c-42823622">[24 more]</label></div><br/><div class="children"><div class="content">The most interesting thing about this isn’t that it’s a RISC-V implementation but that it’s written in a Scala HDL language, SpinalHDL. There are quite a few of these now - Chisel (which Spinal forked from long ago), Amaranth (Python), and Clash (Haskell) all come to mind.</div><br/><div id="42827206" class="c"><input type="checkbox" id="c-42827206" checked=""/><div class="controls bullet"><span class="by">fayalalebrun</span><span>|</span><a href="#42823622">parent</a><span>|</span><a href="#42824183">next</a><span>|</span><label class="collapse" for="c-42827206">[-]</label><label class="expand" for="c-42827206">[2 more]</label></div><br/><div class="children"><div class="content">SpinalHDL did not fork from Chisel. You might be able to say that it was inspired by Chisel, but it does not share a commit history. See this comment by the author: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;chisel&#x2F;comments&#x2F;4ivevd&#x2F;comment&#x2F;d3ljh5s&#x2F;?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;chisel&#x2F;comments&#x2F;4ivevd&#x2F;comment&#x2F;d3lj...</a></div><br/><div id="42827651" class="c"><input type="checkbox" id="c-42827651" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42827206">parent</a><span>|</span><a href="#42824183">next</a><span>|</span><label class="collapse" for="c-42827651">[-]</label><label class="expand" for="c-42827651">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the correction! My original comment is too old to update. It’s so frequently described as one (for example in <a href="https:&#x2F;&#x2F;github.com&#x2F;SpinalHDL&#x2F;SpinalHDL&#x2F;issues&#x2F;202#issuecomment-467517976">https:&#x2F;&#x2F;github.com&#x2F;SpinalHDL&#x2F;SpinalHDL&#x2F;issues&#x2F;202#issuecomme...</a> ) that I assumed they shared a history.</div><br/></div></div></div></div><div id="42824183" class="c"><input type="checkbox" id="c-42824183" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#42823622">parent</a><span>|</span><a href="#42827206">prev</a><span>|</span><a href="#42824840">next</a><span>|</span><label class="collapse" for="c-42824183">[-]</label><label class="expand" for="c-42824183">[20 more]</label></div><br/><div class="children"><div class="content">Do those languages get used in the industry, except of academia? There are so many HDLs and I am wondering if there is any other benefit of learning any of these, except of possible fun.</div><br/><div id="42824613" class="c"><input type="checkbox" id="c-42824613" checked=""/><div class="controls bullet"><span class="by">jeff_ciesielski</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824183">parent</a><span>|</span><a href="#42824854">next</a><span>|</span><label class="collapse" for="c-42824613">[-]</label><label class="expand" for="c-42824613">[2 more]</label></div><br/><div class="children"><div class="content">We do a fair bit of FPGA design in SpinalHDL, and have taped out several ASICs with parts of the design done in SpinalHDL at my dayjob.<p>In general: No, alternative HDLs don&#x27;t see a lot of use, and I&#x27;d argue that we qualify as &#x27;academia&#x27; since the ASICs are NIH funded and we tend to work with a lot of academic partners and on low-quantity R&amp;D projects.<p>Having said that, every time we&#x27;ve deployed SpinalHDL for a commercial client they&#x27;ve been blown away by the results.  The standard library, developer ergonomics, test capabilities, and little things like having clock domains as a part of the type system make development so much faster and less error prone that the NRE for doing it in verilog just doesn&#x27;t make sense.<p>You get access to the entire Java and Scala ecosystem at elaboration and test time.  We deploy ScalaCheck in our test harnesses to automatically generate test cases that can reduce inputs to identify edge cases.  It&#x27;s incredibly powerful.</div><br/><div id="42824718" class="c"><input type="checkbox" id="c-42824718" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824613">parent</a><span>|</span><a href="#42824854">next</a><span>|</span><label class="collapse" for="c-42824718">[-]</label><label class="expand" for="c-42824718">[1 more]</label></div><br/><div class="children"><div class="content">Huh, this sounds interesting. Maybe I&#x27;ll give it a shot. Thanks!</div><br/></div></div></div></div><div id="42824854" class="c"><input type="checkbox" id="c-42824854" checked=""/><div class="controls bullet"><span class="by">wespiard</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824183">parent</a><span>|</span><a href="#42824613">prev</a><span>|</span><a href="#42826367">next</a><span>|</span><label class="collapse" for="c-42824854">[-]</label><label class="expand" for="c-42824854">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know much about SpinalHDL or Chisel, but one example of an alternate HDL is HardCaml, which is used by JaneStreet for FPGA designs:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;janestreet&#x2F;hardcaml">https:&#x2F;&#x2F;github.com&#x2F;janestreet&#x2F;hardcaml</a></div><br/></div></div><div id="42826367" class="c"><input type="checkbox" id="c-42826367" checked=""/><div class="controls bullet"><span class="by">sdvsfqe</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824183">parent</a><span>|</span><a href="#42824854">prev</a><span>|</span><a href="#42825616">next</a><span>|</span><label class="collapse" for="c-42826367">[-]</label><label class="expand" for="c-42826367">[1 more]</label></div><br/><div class="children"><div class="content">In hardware everything boils down to volume and NRE.<p>If the design is low volume then minimizing NRE, which is mostly set by engineering hours, makes sense.  At low volume, the semiconductor unit cost is mostly irrelevant so you can potentially use things like SpinalHDL to keep engineering hours down, and therefore potentially save NRE, and eat the higher unit cost which occur due to toolchain inefficiencies.<p>At high volume NRE is mostly irrelevant and unit cost is everything.  So even if a tool or language is hard and annoying to use, if it gives a lower unit cost, you use it.   Here you see things like an engineers hand tuning the layout of a single MUX to eek out a bit more of something good in the PPA space.<p>I only have experience with high volume HW and there something like Chisel or SpinalHDL wouldn&#x27;t be considered as it just adds complexity to the flow, and makes it hard to do the optimizations that high volume enable us to consider, for a potential benefit we&#x27;re not interested in.</div><br/></div></div><div id="42825616" class="c"><input type="checkbox" id="c-42825616" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824183">parent</a><span>|</span><a href="#42826367">prev</a><span>|</span><a href="#42827072">next</a><span>|</span><label class="collapse" for="c-42825616">[-]</label><label class="expand" for="c-42825616">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re overall more prevalent in the FPGA world, I think. I&#x27;ve used and done several jobs with them (Clash&#x2F;Haskell, Bluespec, etc) and know others who have, too. But you basically need to know someone or do it yourself. Pretty marginal overall, but IME the results have basically been good (and more fun to write, too.)</div><br/></div></div><div id="42827072" class="c"><input type="checkbox" id="c-42827072" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824183">parent</a><span>|</span><a href="#42825616">prev</a><span>|</span><a href="#42824405">next</a><span>|</span><label class="collapse" for="c-42827072">[-]</label><label class="expand" for="c-42827072">[1 more]</label></div><br/><div class="children"><div class="content">At lumiguide we use clash for FPGA stuff. It&#x27;s not perfect but we are very, very happy we didn&#x27;t go the verilog route. What a horrible experience that is.</div><br/></div></div><div id="42824405" class="c"><input type="checkbox" id="c-42824405" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824183">parent</a><span>|</span><a href="#42827072">prev</a><span>|</span><a href="#42824840">next</a><span>|</span><label class="collapse" for="c-42824405">[-]</label><label class="expand" for="c-42824405">[13 more]</label></div><br/><div class="children"><div class="content">no matter what anyone says to you on here (or elsewhere on the blagosphere): no. the answer is absolutely flat out no.</div><br/><div id="42824570" class="c"><input type="checkbox" id="c-42824570" checked=""/><div class="controls bullet"><span class="by">oldgradstudent</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824405">parent</a><span>|</span><a href="#42825929">next</a><span>|</span><label class="collapse" for="c-42824570">[-]</label><label class="expand" for="c-42824570">[11 more]</label></div><br/><div class="children"><div class="content">No is a good first approximation.<p>There is a little bit of industry usage, with the biggest user being SiFive - the founders come from the UC Berkeley group that developed Chisel.<p>Also, VexRiscv has some industry presence.</div><br/><div id="42824681" class="c"><input type="checkbox" id="c-42824681" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824570">parent</a><span>|</span><a href="#42825929">next</a><span>|</span><label class="collapse" for="c-42824681">[-]</label><label class="expand" for="c-42824681">[10 more]</label></div><br/><div class="children"><div class="content">&gt; There is a little bit of industry usage, with the biggest user being SiFive<p>do ask sifive how much they regret that decision though &lt;shrug&gt;</div><br/><div id="42825792" class="c"><input type="checkbox" id="c-42825792" checked=""/><div class="controls bullet"><span class="by">oldgradstudent</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824681">parent</a><span>|</span><a href="#42824933">next</a><span>|</span><label class="collapse" for="c-42825792">[-]</label><label class="expand" for="c-42825792">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure they&#x27;re going to say they don&#x27;t regret it at all. Either because it&#x27;s true, or because they are too invested in it.<p>When I&#x27;ve started doing FPGA consulting a few years ago I&#x27;ve started using Chisel, but eventually had to go back to SystemVerilog due to client reluctance.<p>I was dramatically more productive with Chisel than with SystemVerilog.</div><br/><div id="42825837" class="c"><input type="checkbox" id="c-42825837" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42825792">parent</a><span>|</span><a href="#42824933">next</a><span>|</span><label class="collapse" for="c-42825837">[-]</label><label class="expand" for="c-42825837">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m pretty sure they&#x27;re going to say they don&#x27;t regret it at all.<p>i didn&#x27;t say that as a supposition - i know that they regret it. the chisel compiler has been an enormous (<i>enormous</i>) technical debt&#x2F;burden for them because of how slow&#x2F;resource intensive it is.</div><br/><div id="42828620" class="c"><input type="checkbox" id="c-42828620" checked=""/><div class="controls bullet"><span class="by">d_tr</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42825837">parent</a><span>|</span><a href="#42826465">next</a><span>|</span><label class="collapse" for="c-42828620">[-]</label><label class="expand" for="c-42828620">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. So, do you know what they&#x27;d choose now if they started over? SystemVerilog?</div><br/></div></div><div id="42826465" class="c"><input type="checkbox" id="c-42826465" checked=""/><div class="controls bullet"><span class="by">sdvsfqe</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42825837">parent</a><span>|</span><a href="#42828620">prev</a><span>|</span><a href="#42824933">next</a><span>|</span><label class="collapse" for="c-42826465">[-]</label><label class="expand" for="c-42826465">[2 more]</label></div><br/><div class="children"><div class="content">&gt; how slow&#x2F;resource intensive it is<p>compared to what?<p>It&#x27;s not like all the other EDA tools are really fast or not resource intensive.    For smaller design firms I would think things like FireSim [1] would be a significant advantage.<p>I can imagine it is a disadvantage in other ways, i.e. it&#x27;s only possible to do single phase positive edge synchronous design, which could be an impediment to high performance digital design.<p>But I wouldn&#x27;t imagine that scala performance is particularly significant.<p>[1] <a href="https:&#x2F;&#x2F;fires.im" rel="nofollow">https:&#x2F;&#x2F;fires.im</a></div><br/><div id="42826652" class="c"><input type="checkbox" id="c-42826652" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42826465">parent</a><span>|</span><a href="#42824933">next</a><span>|</span><label class="collapse" for="c-42826652">[-]</label><label class="expand" for="c-42826652">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pointless to argue with people on hn because you&#x27;ll tell them &quot;I have cold hard experience&quot; and they&#x27;ll respond with hype links and conjecture.<p>&gt; But I wouldn&#x27;t imagine that scala performance is particularly significant.<p>Imagine all you&#x27;d like - reality is much less imaginative though.</div><br/></div></div></div></div></div></div></div></div><div id="42824933" class="c"><input type="checkbox" id="c-42824933" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824681">parent</a><span>|</span><a href="#42825792">prev</a><span>|</span><a href="#42825929">next</a><span>|</span><label class="collapse" for="c-42824933">[-]</label><label class="expand" for="c-42824933">[4 more]</label></div><br/><div class="children"><div class="content">This is off topic, but I recognize your username from a thread a couple weeks ago but your account is relatively new. Out of curiosity did you just find hacker news and decide to make an account, or is this a new alias and you have an older account? I guess I&#x27;d be surprised if there&#x27;s still new people joining lol.</div><br/><div id="42825485" class="c"><input type="checkbox" id="c-42825485" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824933">parent</a><span>|</span><a href="#42825929">next</a><span>|</span><label class="collapse" for="c-42825485">[-]</label><label class="expand" for="c-42825485">[3 more]</label></div><br/><div class="children"><div class="content">my account is 8 months old? also i&#x27;m sure new people join hn all the time because you know... new people are being born all the time...</div><br/><div id="42826199" class="c"><input type="checkbox" id="c-42826199" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42825485">parent</a><span>|</span><a href="#42825929">next</a><span>|</span><label class="collapse" for="c-42826199">[-]</label><label class="expand" for="c-42826199">[2 more]</label></div><br/><div class="children"><div class="content">I was just wondering. It seemed like you had a perspective that I wouldn&#x27;t associate with someone new to the industry.</div><br/><div id="42826288" class="c"><input type="checkbox" id="c-42826288" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42826199">parent</a><span>|</span><a href="#42825929">next</a><span>|</span><label class="collapse" for="c-42826288">[-]</label><label class="expand" for="c-42826288">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea who they are, but I think you&#x27;d find there are lots of &quot;old-timers&quot; (even notable ones) who&#x27;ve never had HN accounts. Any of them could decide to join at any moment</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42825929" class="c"><input type="checkbox" id="c-42825929" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#42823622">root</a><span>|</span><a href="#42824405">parent</a><span>|</span><a href="#42824570">prev</a><span>|</span><a href="#42824840">next</a><span>|</span><label class="collapse" for="c-42825929">[-]</label><label class="expand" for="c-42825929">[1 more]</label></div><br/><div class="children"><div class="content">In the ASIC space, sure, I don&#x27;t think any of these tools scale in the way that most ASIC companies have forced their &quot;traditional&quot; HDL toolchains to scale.<p>In the FPGA-based space (accelerators, RF&#x2F;SDR, trading), hard disagree. There&#x27;s plenty of boutique FPGA work going on in these.</div><br/></div></div></div></div></div></div></div></div><div id="42827057" class="c"><input type="checkbox" id="c-42827057" checked=""/><div class="controls bullet"><span class="by">tverbeure</span><span>|</span><a href="#42823622">prev</a><span>|</span><a href="#42827683">next</a><span>|</span><label class="collapse" for="c-42827057">[-]</label><label class="expand" for="c-42827057">[4 more]</label></div><br/><div class="children"><div class="content">6 years ago, I wrote an in-depth blog post about the design principles of the Vexriscv. It’s unlike any other CPU I’ve seen.<p><a href="https:&#x2F;&#x2F;tomverbeure.github.io&#x2F;rtl&#x2F;2018&#x2F;12&#x2F;06&#x2F;The-VexRiscV-CPU-A-New-Way-To-Design.html" rel="nofollow">https:&#x2F;&#x2F;tomverbeure.github.io&#x2F;rtl&#x2F;2018&#x2F;12&#x2F;06&#x2F;The-VexRiscV-CP...</a></div><br/><div id="42828192" class="c"><input type="checkbox" id="c-42828192" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#42827057">parent</a><span>|</span><a href="#42828222">next</a><span>|</span><label class="collapse" for="c-42828192">[-]</label><label class="expand" for="c-42828192">[2 more]</label></div><br/><div class="children"><div class="content">Do you still use spinal? Have there been other advances in HDL that you&#x27;ve seen over the last 6 years?</div><br/><div id="42828467" class="c"><input type="checkbox" id="c-42828467" checked=""/><div class="controls bullet"><span class="by">tverbeure</span><span>|</span><a href="#42827057">root</a><span>|</span><a href="#42828192">parent</a><span>|</span><a href="#42828222">next</a><span>|</span><label class="collapse" for="c-42828467">[-]</label><label class="expand" for="c-42828467">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I still use it for all my hobby projects but I don&#x27;t use any of the advanced techniques that are used in the Vexriscv. My Scale knowledge is way too limited for that. I use SpinalHDL as a more efficient way to write pure RTL.</div><br/></div></div></div></div><div id="42828222" class="c"><input type="checkbox" id="c-42828222" checked=""/><div class="controls bullet"><span class="by">awjlogan</span><span>|</span><a href="#42827057">parent</a><span>|</span><a href="#42828192">prev</a><span>|</span><a href="#42827683">next</a><span>|</span><label class="collapse" for="c-42828222">[-]</label><label class="expand" for="c-42828222">[1 more]</label></div><br/><div class="children"><div class="content">This was a really interesting read, thanks.</div><br/></div></div></div></div><div id="42827683" class="c"><input type="checkbox" id="c-42827683" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#42827057">prev</a><span>|</span><a href="#42823580">next</a><span>|</span><label class="collapse" for="c-42827683">[-]</label><label class="expand" for="c-42827683">[3 more]</label></div><br/><div class="children"><div class="content">What does &quot;FPGA friendly&quot; mean? I tried to figure it out from the README, which says &quot;Implement multiplication using multiple sub multiplication operations in parallel (&quot;FPGA friendly&quot;)&quot;. Put another way: what is the FPGA-UNfriendly way to do multiplication?</div><br/><div id="42828340" class="c"><input type="checkbox" id="c-42828340" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42827683">parent</a><span>|</span><a href="#42823580">next</a><span>|</span><label class="collapse" for="c-42828340">[-]</label><label class="expand" for="c-42828340">[2 more]</label></div><br/><div class="children"><div class="content">Most FPGAs have converged on 18 bit wide multiplier blocks. If you ask for a 64 bit multiplier, the router will automatically chain together four multiplier blocks and add them together in a single cycle, which is really going to hurt your maximum clock speed (fmax).<p>VexRiscv is aware of this unofficial standard, and asks for four 16x64 multiplies and adds the result together on the next cycle. This produces a much better fmax on FPGAs, but if you were targeting an ASIC, you would be better off asking for a 64-bit multiplier, or not trying for a single-cycle multiply.<p>Most modern CPUs tend to target a 3 cycle pipelined multiplication, which means 22-bit wide multipliers. Doing this on an FPGA each 22-bit multiplication would require two 18-bit multiplier blocks, for a total of six multipliers, wasting more resources.<p>-----<p>In general, &quot;FPGA friendly&quot; means optimizing your design to take advantage of the things which are cheap on FPGAs, like the 18-bit wide multipliers and the block ram. Such designs tend to run faster on FPGAs and use less resources, but it&#x27;s wasteful to synthesize them to ASICs.</div><br/><div id="42828391" class="c"><input type="checkbox" id="c-42828391" checked=""/><div class="controls bullet"><span class="by">cjbillington</span><span>|</span><a href="#42827683">root</a><span>|</span><a href="#42828340">parent</a><span>|</span><a href="#42823580">next</a><span>|</span><label class="collapse" for="c-42828391">[-]</label><label class="expand" for="c-42828391">[1 more]</label></div><br/><div class="children"><div class="content">It took me to the end of your comment to realise the crucial bit I was missing: that they&#x27;re talking about <i>implementing the CPU on an FPGA</i>.<p>As opposed to, say, <i>interfacing with an FPGA</i> which could be totally different way to be &quot;FPGA-friendly&quot;.</div><br/></div></div></div></div></div></div><div id="42823580" class="c"><input type="checkbox" id="c-42823580" checked=""/><div class="controls bullet"><span class="by">davidjade</span><span>|</span><a href="#42827683">prev</a><span>|</span><a href="#42823377">next</a><span>|</span><label class="collapse" for="c-42823580">[-]</label><label class="expand" for="c-42823580">[2 more]</label></div><br/><div class="children"><div class="content">There is a successor project as well: <a href="https:&#x2F;&#x2F;github.com&#x2F;SpinalHDL&#x2F;VexiiRiscv">https:&#x2F;&#x2F;github.com&#x2F;SpinalHDL&#x2F;VexiiRiscv</a></div><br/><div id="42823885" class="c"><input type="checkbox" id="c-42823885" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#42823580">parent</a><span>|</span><a href="#42823377">next</a><span>|</span><label class="collapse" for="c-42823885">[-]</label><label class="expand" for="c-42823885">[1 more]</label></div><br/><div class="children"><div class="content">And a spiritual sibling: <a href="https:&#x2F;&#x2F;github.com&#x2F;SpinalHDL&#x2F;NaxRiscv">https:&#x2F;&#x2F;github.com&#x2F;SpinalHDL&#x2F;NaxRiscv</a></div><br/></div></div></div></div><div id="42823377" class="c"><input type="checkbox" id="c-42823377" checked=""/><div class="controls bullet"><span class="by">le-mark</span><span>|</span><a href="#42823580">prev</a><span>|</span><a href="#42825331">next</a><span>|</span><label class="collapse" for="c-42823377">[-]</label><label class="expand" for="c-42823377">[1 more]</label></div><br/><div class="children"><div class="content">Fits on an ICE-40 fpga, that’s not nothing!</div><br/></div></div><div id="42825331" class="c"><input type="checkbox" id="c-42825331" checked=""/><div class="controls bullet"><span class="by">disdi</span><span>|</span><a href="#42823377">prev</a><span>|</span><a href="#42823482">next</a><span>|</span><label class="collapse" for="c-42825331">[-]</label><label class="expand" for="c-42825331">[1 more]</label></div><br/><div class="children"><div class="content">Latest presentation on this topic by main developer:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;dR_jqS13D2c?si=bbZf7Oo5a3JsINYs" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;dR_jqS13D2c?si=bbZf7Oo5a3JsINYs</a></div><br/></div></div><div id="42823482" class="c"><input type="checkbox" id="c-42823482" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42825331">prev</a><span>|</span><a href="#42823709">next</a><span>|</span><label class="collapse" for="c-42823482">[-]</label><label class="expand" for="c-42823482">[2 more]</label></div><br/><div class="children"><div class="content">How does it compare to the many other RISC-V CPUs?</div><br/><div id="42824661" class="c"><input type="checkbox" id="c-42824661" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#42823482">parent</a><span>|</span><a href="#42823709">next</a><span>|</span><label class="collapse" for="c-42824661">[-]</label><label class="expand" for="c-42824661">[1 more]</label></div><br/><div class="children"><div class="content">The code is much more readable and modular than you typical verilog dump, so it&#x27;s probably the best CPU for microarchitecture experimentation. Source: did my master thesis prototyping a specialized cache. Started on Rocket Core, which turned out to be a total mess with all of the pipeline in a single module, basically impossible to introduce a new datapath without rewriting everything. Vex was a breath of fresh air. Spinal is also awesome, lots of QoL features for separating concerns between modules in a way that&#x27;s impossible on Verilog and fixes lots of rough edges of Chisel.<p>Performance on FPGA was better than most open-source RISC-V cores out there as of 2020. Rocket might have been better on silicon, but that&#x27;s it. I haven&#x27;t looked much into it since then through.</div><br/></div></div></div></div><div id="42823709" class="c"><input type="checkbox" id="c-42823709" checked=""/><div class="controls bullet"><span class="by">vollbrecht</span><span>|</span><a href="#42823482">prev</a><span>|</span><a href="#42823515">next</a><span>|</span><label class="collapse" for="c-42823709">[-]</label><label class="expand" for="c-42823709">[8 more]</label></div><br/><div class="children"><div class="content">I find it fascinating, calling a CPU implementation FPGA friendly. I don&#x27;t know why everybody always wants to run soft CPU&#x27;s on an FPGA.<p>I mean I understand that its nice for the development stage of a CPU, but for all practical purposes, a FPGA is a thing where you can do hyper specialized things in massively parallel fashion, and essentially don&#x27;t do something to run general purpose code.<p>I am not saying that people should stop doing this things, everybody is free to do what they want, still i don&#x27;t understand why most of FPGA talks are about soft CPU&#x27;s when the really interesting stuff is something completely different.</div><br/><div id="42823871" class="c"><input type="checkbox" id="c-42823871" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#42823709">parent</a><span>|</span><a href="#42824244">next</a><span>|</span><label class="collapse" for="c-42823871">[-]</label><label class="expand" for="c-42823871">[3 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with performance or hardware CPU development.<p>FPGA-specific soft cores like VexRiscv and NaxRiscv are immensely useful for anything involving state machine logic or glue code that you do not want to implement in-fabric.<p>Peripherals like on-chip MMCMs&#x2F;PLLs, on-board I2C and SPI peripherals, etc. with complicated initialization routines or communication flows or sequencing are very easily handled in a soft CPU.<p>Soft CPUs can also be used like high-powered programmable in-circuit logic analyzers: without rebuilding a potentially massive FPGA bitstream, you can probe&#x2F;observe&#x2F;inspect, inject&#x2F;alter any signals or buses you pipe to the CPU. VexRiscv is far more pleasant to use than any vendor ILA IP.<p>Soft CPUs also normally utilize FPGA LUTRAM&#x2F;BRAM resources, enabling whatever program to run with hard real-time latency consistency.</div><br/><div id="42826524" class="c"><input type="checkbox" id="c-42826524" checked=""/><div class="controls bullet"><span class="by">sdvsfqe</span><span>|</span><a href="#42823709">root</a><span>|</span><a href="#42823871">parent</a><span>|</span><a href="#42824432">next</a><span>|</span><label class="collapse" for="c-42826524">[-]</label><label class="expand" for="c-42826524">[1 more]</label></div><br/><div class="children"><div class="content">Also, soft cpus without strict performance and power requirements are really easy to implement with modern toolchains.  In one quarter you can take an undergraduate who doesn&#x27;t even know digital design and have them make a cpu core as a final project, and they can make a decent one.<p>HW is actually really hard.  If you can use a soft core to simplify the overall design and suck up a bunch of peripheral logic it&#x27;s probably a good idea.  Then the engineers can spend their time focusing on getting the hard parts of the design correct.</div><br/></div></div><div id="42824432" class="c"><input type="checkbox" id="c-42824432" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42823709">root</a><span>|</span><a href="#42823871">parent</a><span>|</span><a href="#42826524">prev</a><span>|</span><a href="#42824244">next</a><span>|</span><label class="collapse" for="c-42824432">[-]</label><label class="expand" for="c-42824432">[1 more]</label></div><br/><div class="children"><div class="content">this guy gets it - softcores are for giving people access to your IP without forcing them write their own RTL. it&#x27;s literally the exact same thing as an embedded scripting language (i.e., vm interpreter.......) in a C&#x2F;C++ program.</div><br/></div></div></div></div><div id="42824244" class="c"><input type="checkbox" id="c-42824244" checked=""/><div class="controls bullet"><span class="by">wildzzz</span><span>|</span><a href="#42823709">parent</a><span>|</span><a href="#42823871">prev</a><span>|</span><a href="#42827035">next</a><span>|</span><label class="collapse" for="c-42824244">[-]</label><label class="expand" for="c-42824244">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you just need a microcontroller to handle some tasks that would be immensely complicated to do yourself. Or maybe you want custom instructions that make use of extra logic on the fabric. I use a RISC-V in my design but most of the chip is dedicated as a modem, I just needed a way to easily send commands and receive telemetry without bit banging hundreds of pins. Another nice thing about using a CPU is that the logic blocks are reusable. I could write a bunch of verilog to receive data from an ADC once a second, average some samples, convert to units, and then send them out as ASCII but now those logic blocks are sitting idle 99.9% of the time. Instead I could have the CPU convert the data and then get back to work on other any other tasks using the same logic blocks. It&#x27;s certainly possible to reduce area usage by trying to reuse blocks for other functions but it&#x27;s a lot more work for the engineer.<p>You wouldn&#x27;t have only a soft CPU on an FPGA, that&#x27;s a waste of time and money.</div><br/></div></div><div id="42827035" class="c"><input type="checkbox" id="c-42827035" checked=""/><div class="controls bullet"><span class="by">tverbeure</span><span>|</span><a href="#42823709">parent</a><span>|</span><a href="#42824244">prev</a><span>|</span><a href="#42824240">next</a><span>|</span><label class="collapse" for="c-42827035">[-]</label><label class="expand" for="c-42827035">[1 more]</label></div><br/><div class="children"><div class="content">I have designed large FPGAs with 5 soft CPUs. They’re immensely useful as programmable replacements of very complex FSMs and their use of FPGA resources is marginal.<p>One example: our vendor had an FSM to quickly save and restore trained SERDES parameters. We replaced that with a tiny CPU and it allowed us to make training decisions that could be changed without resynthesis.<p>Similarly, Altera themselves use a Nios CPU for their DDR4 DRAM controller IO training.<p>There are so many other possibilities. In one case, we fixed a corner case bug in a HW I2C controller by bit-banging the protocol.<p>Soft CPUs cost a few thousands gates, one or 2 BRAMs which is totally fine if you have some left. It’s no different than having tons of tiny controller CPUs in large ASICs (which literally everybody does these days.)<p>What makes the Vexriscv (and Nios and Microblaze) FPGA friendly is that they don’t require zero latency access to the register file. You can use BRAM instead. FF based register files are murder on the FPGA routing fabric.</div><br/></div></div><div id="42824240" class="c"><input type="checkbox" id="c-42824240" checked=""/><div class="controls bullet"><span class="by">shadowpho</span><span>|</span><a href="#42823709">parent</a><span>|</span><a href="#42827035">prev</a><span>|</span><a href="#42825142">next</a><span>|</span><label class="collapse" for="c-42824240">[-]</label><label class="expand" for="c-42824240">[1 more]</label></div><br/><div class="children"><div class="content">Fpga are great at some things but they are pretty difficult with others. There are many applications where you can use the CPU as the control block while keeping fpga for other reasons. Furthermore keeping the cpu inside the fpga means you get to have direct access to many knobs and settings.<p>For example I worked on a project that used fpga to mux audio&#x2F;video. It simply redirected digital pins. However the internal cpu was used to control&#x2F;decide what to mux, when and how.<p>It could’ve been all done in fpga but that would’ve been more work (difficult&#x2F;tricky&#x2F;inflexible). Instead we had a small core that run a simple program and communicated to external world.</div><br/></div></div><div id="42825142" class="c"><input type="checkbox" id="c-42825142" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#42823709">parent</a><span>|</span><a href="#42824240">prev</a><span>|</span><a href="#42823515">next</a><span>|</span><label class="collapse" for="c-42825142">[-]</label><label class="expand" for="c-42825142">[1 more]</label></div><br/><div class="children"><div class="content">Aside from the legitimate use cases mentioned by the
sibling comments, it&#x27;s just fun to run a soft CPU. There&#x27;s something that tickles me about setting up a computer that can run real software, especially if it&#x27;s one you&#x27;ve had some part in designing.</div><br/></div></div></div></div><div id="42823515" class="c"><input type="checkbox" id="c-42823515" checked=""/><div class="controls bullet"><span class="by">nomad86</span><span>|</span><a href="#42823709">prev</a><span>|</span><a href="#42823487">next</a><span>|</span><label class="collapse" for="c-42823515">[-]</label><label class="expand" for="c-42823515">[3 more]</label></div><br/><div class="children"><div class="content">It reminded me of how, a long time ago, FPGAs were used in Bitcoin mining.</div><br/><div id="42823584" class="c"><input type="checkbox" id="c-42823584" checked=""/><div class="controls bullet"><span class="by">TheAmazingRace</span><span>|</span><a href="#42823515">parent</a><span>|</span><a href="#42823487">next</a><span>|</span><label class="collapse" for="c-42823584">[-]</label><label class="expand" for="c-42823584">[2 more]</label></div><br/><div class="children"><div class="content">I thought it was ASICs?</div><br/><div id="42823626" class="c"><input type="checkbox" id="c-42823626" checked=""/><div class="controls bullet"><span class="by">zoenolan</span><span>|</span><a href="#42823515">root</a><span>|</span><a href="#42823584">parent</a><span>|</span><a href="#42823487">next</a><span>|</span><label class="collapse" for="c-42823626">[-]</label><label class="expand" for="c-42823626">[1 more]</label></div><br/><div class="children"><div class="content">CPU to GPU to FPGA to ASIC<p>All the acronyms</div><br/></div></div></div></div></div></div><div id="42823487" class="c"><input type="checkbox" id="c-42823487" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42823515">prev</a><span>|</span><label class="collapse" for="c-42823487">[-]</label><label class="expand" for="c-42823487">[1 more]</label></div><br/><div class="children"><div class="content">Saw .scala files and thought &quot;some verilog thing that uses that extension&quot;.
Nope. Lots of Scala. That&#x27;s not what I expected!</div><br/></div></div></div></div></div></div></div></body></html>