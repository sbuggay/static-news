<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711357261539" as="style"/><link rel="stylesheet" href="styles.css?v=1711357261539"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/source-and-buggy/context-the-missing-feature-of-programming-languages-7c1095fe8d32">Context: The Missing Feature of Programming Languages</a> <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>andsoitis</span> | <span>9 comments</span></div><br/><div><div id="39813368" class="c"><input type="checkbox" id="c-39813368" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39813913">next</a><span>|</span><label class="collapse" for="c-39813368">[-]</label><label class="expand" for="c-39813368">[1 more]</label></div><br/><div class="children"><div class="content">It seems like there&#x27;s a tension between making implementation details part of the API (so you can catch mistakes) and hiding detail (which improves reusability and makes changes easier).<p>For example, if every function is allowed to allocate memory whether it does or not, then changing the implementation of a function so that now it allocates memory is a simple, backward compatible change. If you have to declare that you allocate memory (for example, by adding a new argument, as in Zig), making the same change breaks compatibility, so now you have to change all the callers.<p>Depending on the circumstances, that might not be considered worth the trouble. It&#x27;s a reason that Java&#x27;s checked exceptions aren&#x27;t popular. Often, reporting a new kind of error shouldn&#x27;t be a compatibility break; they&#x27;re all going to get caught and logged the same way anyway.<p>(An extreme case would be making performance guarantees part of the API, which, outside maybe real-time environments, nobody does. This means that a new version of a library could be much slower than before, maybe causing your servers to become overloaded, without any compiler warning. But performance depend so many factors that making guarantees is usually unfeasible.)<p>The proposed idea of having a compiler do certain context checks without declaring anything in the API means that there are invisible API constraints that are generated from the implementation. This is sort of like having type inference without the option of declaring a function&#x27;s type explicitly.</div><br/></div></div><div id="39813913" class="c"><input type="checkbox" id="c-39813913" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39813368">prev</a><span>|</span><a href="#39813235">next</a><span>|</span><label class="collapse" for="c-39813913">[-]</label><label class="expand" for="c-39813913">[1 more]</label></div><br/><div class="children"><div class="content">Curious that CDI and other dependency injection frameworks are not discussed here, I would have imagined them to be relevant. But otherwise, I think the article does highlight a real problem and I would hope that future PLs improve on this front, allowing for even more &quot;pure&quot; functions in some sense.<p>The section on exceptions got me thinking of CL condition system. Idk if it somehow meshes in here, I suspect it might provide some mechanism to inject context somehow... but I never have programmed a single line of CL so idk.</div><br/></div></div><div id="39813235" class="c"><input type="checkbox" id="c-39813235" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#39813913">prev</a><span>|</span><a href="#39813451">next</a><span>|</span><label class="collapse" for="c-39813235">[-]</label><label class="expand" for="c-39813235">[1 more]</label></div><br/><div class="children"><div class="content">ISTR that Jon Blow has a built in context mechanism in Jai.<p>(Some googling later)<p>Yes, it does. Looks like it supports a stack of contexts and is used for stuff like allocators and loggers.<p><a href="https:&#x2F;&#x2F;jai.community&#x2F;t&#x2F;context&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jai.community&#x2F;t&#x2F;context&#x2F;</a></div><br/></div></div><div id="39813451" class="c"><input type="checkbox" id="c-39813451" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39813235">prev</a><span>|</span><a href="#39813200">next</a><span>|</span><label class="collapse" for="c-39813451">[-]</label><label class="expand" for="c-39813451">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One of the simplest and most pernicious programming problems is the humble deadlock<p>&gt; […]<p>&gt; Unfortunately deadlocks are not always so easy to spot, especially as more layers of abstraction are added<p>&gt; […]<p>&gt; Compilers don’t even try to help here.<p><a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThreadSafetyAnalysis.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThreadSafetyAnalysis.html</a>:<p><i>“Clang Thread Safety Analysis is a C++ language extension which warns about potential race conditions in code. The analysis is completely static (i.e. compile-time); there is no run-time overhead. The analysis is still under active development, but it is mature enough to be deployed in an industrial setting. It is being developed by Google, in collaboration with CERT&#x2F;SEI, and is used extensively in Google’s internal code base.<p>Thread safety analysis works very much like a type system for multi-threaded programs. In addition to declaring the type of data (e.g. int, float, etc.), the programmer can (optionally) declare how access to that data is controlled in a multi-threaded environment. For example, if foo is guarded by the mutex mu, then the analysis will issue a warning whenever a piece of code reads or writes to foo without first locking mu. Similarly, if there are particular routines that should only be called by the GUI thread, then the analysis will warn if other threads call those routines.<p>[…]<p>EXCLUDES is an attribute on functions or methods, which declares that the caller must not hold the given capabilities. This annotation is used to prevent deadlock.”</i><p>Googling “static deadlock detection” will uncover similar tools (often not as well integrated with the compiler)</div><br/></div></div><div id="39813200" class="c"><input type="checkbox" id="c-39813200" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39813451">prev</a><span>|</span><a href="#39813452">next</a><span>|</span><label class="collapse" for="c-39813200">[-]</label><label class="expand" for="c-39813200">[1 more]</label></div><br/><div class="children"><div class="content">What I&#x27;d like is a React context like mechanism<p>Calling useContext(ctx) looks up nearest parent call frame defining setContext(ctx, value)<p>Of course that makes for implicit global dependency, unless you pass a context manager ref around almost like Go does<p>But at least it&#x27;d help scope resources instead of using globals while avoiding a coloring problem (see Go context where if an interface doesn&#x27;t take context one has to find an alternative means to passing context through)</div><br/></div></div><div id="39813452" class="c"><input type="checkbox" id="c-39813452" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39813200">prev</a><span>|</span><a href="#39813911">next</a><span>|</span><label class="collapse" for="c-39813452">[-]</label><label class="expand" for="c-39813452">[1 more]</label></div><br/><div class="children"><div class="content">If you want a more approachable model of context than effects, try &quot;dynamic scope&quot;.<p>(and remember there are good reasons we try to do as much as possible with lexical instead)</div><br/></div></div><div id="39813911" class="c"><input type="checkbox" id="c-39813911" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39813452">prev</a><span>|</span><a href="#39813281">next</a><span>|</span><label class="collapse" for="c-39813911">[-]</label><label class="expand" for="c-39813911">[1 more]</label></div><br/><div class="children"><div class="content">This article is a litany of issues that pure functions solve, despite the backhanded dismissal:<p>&gt; Much as we like our platonic ideals, our pure functions, we ultimately have to acknowledge that every function exists in a context.  The most basic context is the physical hardware on which your code is running<p>(Note: pure functions set such a high bar that it&#x27;s a stretch to criticise them.  Might as well blame the hardware instead.  Which is fine, just be equally dismissive of other &#x27;solutions&#x27;.)<p>&gt; when one fails, it’s up to the engineer to figure out why. In the case of race conditions or other rare occurrences it might not even be possible to reliably reproduce the issue in a debugger,<p>Pure functions will return the same input for the same output.  It will reproduce.<p>&gt; In particular, they should be better at detecting cases where two separate units conflict with each-other.<p>Pure functions do not conflict with each other - no detection needed.  (&quot;Conflicts&quot; can only arise by &quot;passing the wrong thing&quot; from function to function, which I don&#x27;t think is the idea here, e.g. in `getPetsName = (getName . getPet)`, getName and getPet cannot conflict <i>with each other</i>, but if getName accidentally returns an address, then of course getPetsName will return the pet&#x27;s address.<p>Deadlocks:<p>&gt; One of the simplest and most pernicious programming problems is the humble deadlock.<p>&gt; Unfortunately deadlocks are not always so easy to spot, especially as more layers of abstraction are added.<p>&gt; Deadlocks are common, hard to debug, and can crash an entire app — yet our best defenses against them, integration tests, are porous and blunt.<p>Pure functions don&#x27;t deadlock.<p>&gt; The symptoms are less severe than a deadlock, but the root cause is often quite similar: a function calls a function that calls a function that calls a function that does something inappropriate.<p>&gt; Compilers don&#x27;t even try to help here.<p>It is a compile-time error to call an impure function from a pure function.<p>&gt; When I call getTimestamp(user.registeredAt, TimeZone.PST) I can assume that it’s just doing some simple math and returning a result. It probably doesn’t make network calls or hold locks or mine bitcoin<p>No need to assume, check the type signature.  Pure function.  The compiler will check it for you if you forget:<p><pre><code>    utcTimeTimestamp :: UTCTime -&gt; Timestamp
    https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;timestamp-0.2&#x2F;docs&#x2F;Timestamp.html
</code></pre>
&gt; Context is only dangerous because it is absent from a function&#x27;s arguments and so is opaque to the caller. The caller, for example, has no way to know if a function could cause a deadlock because it cannot know if the implementation of that function relies on locking.<p>&gt; Knowing when a function modifies state is half the battle, the other half is knowing when a function reads state. This is not an Effect, but rather a Coeffect — although sometimes it all gets lumped together under the banner of ‘Effects’ or ‘Effect Systems’.<p>Of course it gets lumped together.  That kind of reading <i>is</i> an effect.  It can cause deadlocks, it can block your UI, it requires thinking about context, it may not be trivially reproducible.<p>That&#x27;s enough about pure functions.  The author then pivots to proposed features to support context.  These don&#x27;t solve the above problems, but there&#x27;s plenty of prior art.  So this last bit is more about Haskell and less about pure functions in general.<p>We have a complicated git merge process at work, with around 70 repos.  I wrote a Haskell CLI tool to help me out with the process.  I believe I&#x27;ve done exactly what the author is suggesting (explicit, compiler-assisted context markers) by using the &#x27;tagless final&#x27; approach.  Here are a couple of example type signatures:<p><pre><code>  ensureCheckedOut :: (Git m, Logger m, Monad m, StatusApi m) =&gt; Repo -&gt; m ()

  ensureRepoDeleted :: (Logger m, Monad m, Shell m, StatusApi m) =&gt; Repo -&gt; m ()
</code></pre>
This keeps my context in check by only allowing me to call <i>impure</i> functions <i>if</i> they are provided by one of the constraints on <i>m</i>.  e.g. I can call logging from both, but <i>ensureCheckedOut</i> cannot run shell commands, and <i>ensureRepoDeleted</i> cannot invoke my git api (for the pedantic, it could technically use the shell to invoke git via cli.)  Pure functions are of course allowed from anywhere.<p>In short:<p>* Pure functions <i>do</i> solve the above problems and it&#x27;s a mistake not to use them wherever possible.<p>* Context systems <i>do not</i> solve deadlocks, integration issues, reproducibility, etc.  But if you think they&#x27;re useful, Haskell&#x27;s got you covered using the &#x27;tagless final&#x27; approach.</div><br/></div></div><div id="39813281" class="c"><input type="checkbox" id="c-39813281" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#39813911">prev</a><span>|</span><label class="collapse" for="c-39813281">[-]</label><label class="expand" for="c-39813281">[1 more]</label></div><br/><div class="children"><div class="content">Each program building it&#x27;s own bespoke core models is endemic to programming. Sometimes we get as refined as &quot;everything is a protobuf&quot; or everything is defined in zod.  But then we still have our informal ad-hoc object management or passing systems. Unless there&#x27;s some inversion of control&#x2F;dependency injection system normalizing this too. Yes sirree, would be nice having some powerful capable context type things in languages.<p>Kubernetes is somewhat distinct in how it normalizes what a broad range of infrastructure objects or intents. Context is a collection of state, and those common ways of dealing with state are the missing practice, be that at a programming language level or other systems level.</div><br/></div></div></div></div></div></div></div></body></html>