<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719133273248" as="style"/><link rel="stylesheet" href="styles.css?v=1719133273248"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rednafi.com/misc/on_rebasing/">I kind of like rebasing</a> <span class="domain">(<a href="https://rednafi.com">rednafi.com</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>212 comments</span></div><br/><div><div id="40754234" class="c"><input type="checkbox" id="c-40754234" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#40754250">next</a><span>|</span><label class="collapse" for="c-40754234">[-]</label><label class="expand" for="c-40754234">[96 more]</label></div><br/><div class="children"><div class="content">Ah! My people.<p>I, too, much prefer a rebase-heavy workflow. It allows me to both have a dirty &quot;internal&quot; history and clean up for publication.<p>As a side-effect, it also makes me comfortable having a mostly linear-history for what I publish, as opposed to a many-branched, merge-heavy one, which I dislike, and makes history confusing.<p>I reject the argument that a no-rebase, merge-only history &quot;preserves the true history of how commits were created&quot;, because I believe that is irrelevant. What is relevant is what the tree looks like once the merge (or rebase) lands.<p>Should a merge conflict arise, in a rebase workflow the conflict resolution is folded into the rebased commit, so it looks like it was fine all along. In a merge workflow, the fix is in the separate merge commit. In both cases you still have to handle the merge conflict. And in my opinion it is not significant for the merge conflict resolution to be separate from the original commit itself because, again: what&#x27;s important is the final state of the repo.</div><br/><div id="40765833" class="c"><input type="checkbox" id="c-40765833" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40754344">next</a><span>|</span><label class="collapse" for="c-40765833">[-]</label><label class="expand" for="c-40765833">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always felt the the rebase vs. merge debate was pointless but then I realized that I never have dirty internal history by the time I&#x27;m ready to make an MR&#x2F;PR.<p>It&#x27;s just that squashing takes 2 seconds. I just shift-select the commits in my Git client and click &#x27;squash&#x27;. To me it&#x27;s like just cleaning up after cooking. And if I want to re-order my commits, I just like drag and drop the order of them. Yet people make these long blog posts about having to do things a certain way when it just takes 2 seconds if you do it from the beginning.<p>Whether you merge or rebase my branches, it will always look nice and this whole rebase vs. merge debate is moot.</div><br/></div></div><div id="40754344" class="c"><input type="checkbox" id="c-40754344" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40765833">prev</a><span>|</span><a href="#40754565">next</a><span>|</span><label class="collapse" for="c-40754344">[-]</label><label class="expand" for="c-40754344">[25 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll add what should be obvious to any seasoned git user: rebase is only possible for &quot;private&quot; commits. If the commits were published, then merge is the only solution, because otherwise with a rebase you will &quot;change (git) history&quot; and break people&#x27;s repos that have yours as upstream.<p>I recommend reading this 2008 exchange between top Linux developers learning to use git, and Torvalds&#x27;s... characteristic language when talking about rebasing a &quot;public&quot; repo:<p><a href="https:&#x2F;&#x2F;www.yarchive.net&#x2F;comp&#x2F;linux&#x2F;git_rebase.html" rel="nofollow">https:&#x2F;&#x2F;www.yarchive.net&#x2F;comp&#x2F;linux&#x2F;git_rebase.html</a><p>(I&#x27;m putting &quot;private&quot; and &quot;public&quot; in quotes because they&#x27;re really on a spectrum)</div><br/><div id="40763432" class="c"><input type="checkbox" id="c-40763432" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754344">parent</a><span>|</span><a href="#40762643">next</a><span>|</span><label class="collapse" for="c-40763432">[-]</label><label class="expand" for="c-40763432">[20 more]</label></div><br/><div class="children"><div class="content">If you work on a branch also worked on by others, then yes, rebase is &quot;only&quot; possible on private commits.<p>But if you work on a feature branch, you can publish that branch as long as everybody else understands that it is yours and nobody should push to it. Then you can safely git push --force to the feature branch so that others can (a) see what you&#x27;re up to (b) test the results. When you&#x27;re done, you can do a final (or only) rebase against the target branch then merge to that branch.</div><br/><div id="40765268" class="c"><input type="checkbox" id="c-40765268" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763432">parent</a><span>|</span><a href="#40764301">next</a><span>|</span><label class="collapse" for="c-40765268">[-]</label><label class="expand" for="c-40765268">[1 more]</label></div><br/><div class="children"><div class="content">Never use git push —force. Alway use git push —force-with-lease.<p>Then <i>if</i> someone changed your remote branch, git will always let you know :)</div><br/></div></div><div id="40764301" class="c"><input type="checkbox" id="c-40764301" checked=""/><div class="controls bullet"><span class="by">patrickthebold</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763432">parent</a><span>|</span><a href="#40765268">prev</a><span>|</span><a href="#40763937">next</a><span>|</span><label class="collapse" for="c-40764301">[-]</label><label class="expand" for="c-40764301">[9 more]</label></div><br/><div class="children"><div class="content">What annoys me about this is that every branch ends up being &quot;private&quot; and people don&#x27;t collaborate (In practice). So you end up with: &quot;I can&#x27;t start work on X until feature Y is merged, and there&#x27;s a lot of PR comments left unaddressed so let&#x27;s just merge Y since X is urgent and fix the PR comments later...&quot;</div><br/><div id="40765677" class="c"><input type="checkbox" id="c-40765677" checked=""/><div class="controls bullet"><span class="by">kalaksi</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764301">parent</a><span>|</span><a href="#40765814">next</a><span>|</span><label class="collapse" for="c-40765677">[-]</label><label class="expand" for="c-40765677">[1 more]</label></div><br/><div class="children"><div class="content">If feature Y is incomplete, then sharing a feature branch (which sounds like a road to a messy commit history) doesn&#x27;t change that. You could also use the unmerged feature branch Y temporarily as a base for X if you need some code from it.</div><br/></div></div><div id="40765814" class="c"><input type="checkbox" id="c-40765814" checked=""/><div class="controls bullet"><span class="by">watwut</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764301">parent</a><span>|</span><a href="#40765677">prev</a><span>|</span><a href="#40764513">next</a><span>|</span><label class="collapse" for="c-40765814">[-]</label><label class="expand" for="c-40765814">[1 more]</label></div><br/><div class="children"><div class="content">cooperating on half baked code sux so much, that I happily take the trade off</div><br/></div></div><div id="40764513" class="c"><input type="checkbox" id="c-40764513" checked=""/><div class="controls bullet"><span class="by">Shog9</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764301">parent</a><span>|</span><a href="#40765814">prev</a><span>|</span><a href="#40764384">next</a><span>|</span><label class="collapse" for="c-40764513">[-]</label><label class="expand" for="c-40764513">[1 more]</label></div><br/><div class="children"><div class="content">My team ran into this early on when attempting to adopt a rebase-preferred workflow for feature branches...<p>...then we got used to it. A few workflow changes were necessary:<p>- configure pull.rebase=true. This is kinda just nice <i>in general</i>, but critical if someone might have rebased the branch you&#x27;re working on overnight.
- get used to pushing up your changes regularly - at very least before you quit for the day. 
- get used to pulling remote changes regularly - at very least before you start work on a branch each day. Rebase after pulling - especially important if you&#x27;ve branched off another feature branch (which may have been rebased). This way you avoid doing a bunch of work on an out of date base.
- *Talk to each other.* If it isn&#x27;t already obvious what a collaborator is doing... Ask them! And err on the side of over communicating what you&#x27;re doing.<p>It turns out, all of these behaviors are kinda just generally useful, and after a bit you forget about rebase being the motivation and just enjoy having a bit less friction when working together.</div><br/></div></div><div id="40764384" class="c"><input type="checkbox" id="c-40764384" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764301">parent</a><span>|</span><a href="#40764513">prev</a><span>|</span><a href="#40763937">next</a><span>|</span><label class="collapse" for="c-40764384">[-]</label><label class="expand" for="c-40764384">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not at all our experience at ardour.org.<p>Most PRs happen against the main branch, maybe after a private feature branch, maybe not.<p>Meanwhile, major developments happen in a feature branch, and these are almost always owned by a single person who is responsible for rebasing against the main branch (and eventually merging back there).<p>But maybe our development team and pace are not good tests for this model.</div><br/><div id="40765502" class="c"><input type="checkbox" id="c-40765502" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764384">parent</a><span>|</span><a href="#40764976">next</a><span>|</span><label class="collapse" for="c-40765502">[-]</label><label class="expand" for="c-40765502">[1 more]</label></div><br/><div class="children"><div class="content">Off topic, but thank you for having a perfectly modern and beautiful skeuomorphic GUI in Ardour.  Tactile buttons with descriptive names instead of vague flat squares with incomprehensible icons; I wish more software offered this kind of interface.</div><br/></div></div><div id="40764976" class="c"><input type="checkbox" id="c-40764976" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764384">parent</a><span>|</span><a href="#40765502">prev</a><span>|</span><a href="#40764760">next</a><span>|</span><label class="collapse" for="c-40764976">[-]</label><label class="expand" for="c-40764976">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and these are almost always owned by a single person who is responsible for rebasing against the main branch<p>That still seems very annoying. People have unplanned time-off all the time, live in different timezones, or perhaps are l just busy ATM and can&#x27;t do the rebase.</div><br/><div id="40765147" class="c"><input type="checkbox" id="c-40765147" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764976">parent</a><span>|</span><a href="#40764760">next</a><span>|</span><label class="collapse" for="c-40765147">[-]</label><label class="expand" for="c-40765147">[1 more]</label></div><br/><div class="children"><div class="content">In practice I’ve found:<p>- Unplanned time off means the feature just doesn’t make it in<p>- Living in different time zones means that you just wait and work slows down<p>In either event, there is rebase and squash auto merge from major git providers like GitHub which helps with this a ton. With that enabled unless the repo is super high traffic usually this is an afterthought unless there is merge conflicts which is semi rare.<p>That being said, that’s just the reality of what I’ve seen play out in various organizations. I personally like to work off other people branches a lot more than my peers because I work in platform engineering and very often developers come to me with feature branches that need some CI&#x2F;infra&#x2F;other change or optimization and very often it’s easiest for me to just drop a commit into their existing branch. The change falls under their ownership and it gets mainlined along with their feature.</div><br/></div></div></div></div><div id="40764760" class="c"><input type="checkbox" id="c-40764760" checked=""/><div class="controls bullet"><span class="by">kfrzcode</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764384">parent</a><span>|</span><a href="#40764976">prev</a><span>|</span><a href="#40763937">next</a><span>|</span><label class="collapse" for="c-40764760">[-]</label><label class="expand" for="c-40764760">[1 more]</label></div><br/><div class="children"><div class="content">OT but I love Audour so much. Thanks for you and your team!</div><br/></div></div></div></div></div></div><div id="40763937" class="c"><input type="checkbox" id="c-40763937" checked=""/><div class="controls bullet"><span class="by">smcameron</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763432">parent</a><span>|</span><a href="#40764301">prev</a><span>|</span><a href="#40762643">next</a><span>|</span><label class="collapse" for="c-40763937">[-]</label><label class="expand" for="c-40763937">[9 more]</label></div><br/><div class="children"><div class="content">&gt;  Then you can safely git push --force<p>What I hate about this workflow is it teaches you to git push --force.<p>Then one day, you&#x27;re in the wrong window and you accidentally git push --force on master.<p>Much prefer a workflow where you <i>never</i> git push --force</div><br/><div id="40764210" class="c"><input type="checkbox" id="c-40764210" checked=""/><div class="controls bullet"><span class="by">necessary</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763937">parent</a><span>|</span><a href="#40764402">next</a><span>|</span><label class="collapse" for="c-40764210">[-]</label><label class="expand" for="c-40764210">[4 more]</label></div><br/><div class="children"><div class="content">Git hosting platforms generally have controls that allow you to prohibit force pushes on protected branches (i.e. master)</div><br/><div id="40764985" class="c"><input type="checkbox" id="c-40764985" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764210">parent</a><span>|</span><a href="#40764402">next</a><span>|</span><label class="collapse" for="c-40764985">[-]</label><label class="expand" for="c-40764985">[3 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t fix the problem since you still can do a lot of damage doing that on a (perhaps wrong) feature branch.</div><br/><div id="40765165" class="c"><input type="checkbox" id="c-40765165" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764985">parent</a><span>|</span><a href="#40765506">next</a><span>|</span><label class="collapse" for="c-40765165">[-]</label><label class="expand" for="c-40765165">[1 more]</label></div><br/><div class="children"><div class="content">It certainly diminishes it significantly. Very few people are usually collaborating on the same branch together that isn’t the main branch in most orgs. So the chances of you destroying yours or someone else’s work that way is pretty low. You can also branch protect any arbitrary branch, at least on GitHub, though I’ve never been in an org that protects branches other than the main one, besides an org that used release branches. I’ve also never seen someone clobber someone else’s feature branch, though it probably does happen. Much more often people are accidentally clobbering their own branches.<p>The ability to rewrite history on feature branches is powerful in a good way and slots right into the way Git is philosophically designed. I would probably not be interested in removing that feature to prevent the rare case that someone footguns themselves or someone else</div><br/></div></div><div id="40765506" class="c"><input type="checkbox" id="c-40765506" checked=""/><div class="controls bullet"><span class="by">nickkell</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764985">parent</a><span>|</span><a href="#40765165">prev</a><span>|</span><a href="#40764402">next</a><span>|</span><label class="collapse" for="c-40765506">[-]</label><label class="expand" for="c-40765506">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s where reflog comes in handy</div><br/></div></div></div></div></div></div><div id="40764402" class="c"><input type="checkbox" id="c-40764402" checked=""/><div class="controls bullet"><span class="by">zimbu668</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763937">parent</a><span>|</span><a href="#40764210">prev</a><span>|</span><a href="#40764893">next</a><span>|</span><label class="collapse" for="c-40764402">[-]</label><label class="expand" for="c-40764402">[2 more]</label></div><br/><div class="children"><div class="content">You should do this instead:<p>git push —-force-with-lease repo branch</div><br/><div id="40764980" class="c"><input type="checkbox" id="c-40764980" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764402">parent</a><span>|</span><a href="#40764893">next</a><span>|</span><label class="collapse" for="c-40764980">[-]</label><label class="expand" for="c-40764980">[1 more]</label></div><br/><div class="children"><div class="content">This. --force-with-lease is what --force should have been in the first place. Hopefully they will eventually make it so, and rename --force to something less accessible.</div><br/></div></div></div></div><div id="40764893" class="c"><input type="checkbox" id="c-40764893" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763937">parent</a><span>|</span><a href="#40764402">prev</a><span>|</span><a href="#40762643">next</a><span>|</span><label class="collapse" for="c-40764893">[-]</label><label class="expand" for="c-40764893">[2 more]</label></div><br/><div class="children"><div class="content">Any repo worth its salt shouldn&#x27;t allow a force push to the main branch.</div><br/><div id="40765577" class="c"><input type="checkbox" id="c-40765577" checked=""/><div class="controls bullet"><span class="by">ck45</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764893">parent</a><span>|</span><a href="#40762643">next</a><span>|</span><label class="collapse" for="c-40765577">[-]</label><label class="expand" for="c-40765577">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree, and also think that 
if it&#x27;s a professional environment pushing to the main branch itself is very questionable for most &#x2F; code repos. Not only because of the Sarbanes-Oxley Act for public companies.</div><br/></div></div></div></div></div></div></div></div><div id="40762643" class="c"><input type="checkbox" id="c-40762643" checked=""/><div class="controls bullet"><span class="by">MrDarcy</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754344">parent</a><span>|</span><a href="#40763432">prev</a><span>|</span><a href="#40755101">next</a><span>|</span><label class="collapse" for="c-40762643">[-]</label><label class="expand" for="c-40762643">[3 more]</label></div><br/><div class="children"><div class="content">In practice it’s fine to rebase and force push to your own published branch, even when it’s an open PR.<p>Just mark it draft or otherwise communicate when it’s no longer a moving target.</div><br/><div id="40762774" class="c"><input type="checkbox" id="c-40762774" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762643">parent</a><span>|</span><a href="#40755101">next</a><span>|</span><label class="collapse" for="c-40762774">[-]</label><label class="expand" for="c-40762774">[2 more]</label></div><br/><div class="children"><div class="content">Especially when it&#x27;s an open PR. That&#x27;s effectively essential in order to, say, address feedback</div><br/><div id="40763672" class="c"><input type="checkbox" id="c-40763672" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762774">parent</a><span>|</span><a href="#40755101">next</a><span>|</span><label class="collapse" for="c-40763672">[-]</label><label class="expand" for="c-40763672">[1 more]</label></div><br/><div class="children"><div class="content">I try not to rebase and force push for branches under active review though. It makes it much harder for the reviewer to see the changes that have happened since they last reviewed.</div><br/></div></div></div></div></div></div><div id="40755101" class="c"><input type="checkbox" id="c-40755101" checked=""/><div class="controls bullet"><span class="by">ruraljuror</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754344">parent</a><span>|</span><a href="#40762643">prev</a><span>|</span><a href="#40754565">next</a><span>|</span><label class="collapse" for="c-40755101">[-]</label><label class="expand" for="c-40755101">[1 more]</label></div><br/><div class="children"><div class="content">I like your point. The exception is if the project you work on is itself downstream, in which case maintainers will rebase those “published” commits, probably employing the same technique they use to keep their local development branches up-to-date with the downstream project.</div><br/></div></div></div></div><div id="40754565" class="c"><input type="checkbox" id="c-40754565" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40754344">prev</a><span>|</span><a href="#40764504">next</a><span>|</span><label class="collapse" for="c-40754565">[-]</label><label class="expand" for="c-40754565">[34 more]</label></div><br/><div class="children"><div class="content">&gt; I reject the argument that a no-rebase, merge-only history &quot;preserves the true history of how commits were created&quot;, because I believe that is irrelevant. What is relevant is what the tree looks like once the merge (or rebase) lands.<p>That&#x27;s kind of the point though: being reasonably sure that a commit contains a tree that the committer <i>had seen</i> at some point, instead of making up history with commits that contain trees that the committer never saw at any point at all.<p>When someone rebases `n` commits, experience has taught me I can&#x27;t trust any commits other than `HEAD`; chances are any commit printed by `git log &quot;HEAD~${n}..HEAD^&quot;` was never checked out by anyone, much less tested at all.<p>CI pipelines also usually run only against HEAD at the moment of push, so if someone pushes `n` commits, then `n-1` are usually ignored by CI pipeline.<p>Modifying options for compiler or linter or formatter checker; adding a new dependency or updating an existing dependency&#x27;s version; changing default options for the project. Stuff like that might make those commits useless, and if someone notices a problem in HEAD after rebase, and decides to fix it, even if the fix is moved to the earliest possible point, nobody would bother re-testing all those n-1 commits after the fix was added, leaving broken commits useless for git bisect.<p>So I agree that rebase is nice. How most people use it, though, not so nice.</div><br/><div id="40761387" class="c"><input type="checkbox" id="c-40761387" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40759293">next</a><span>|</span><label class="collapse" for="c-40761387">[-]</label><label class="expand" for="c-40761387">[5 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s kind of the point though: being reasonably sure that a commit contains a tree that the committer had seen at some point, instead of making up history with commits that contain trees that the committer never saw at any point at all.<p>I don&#x27;t really understand why this would be important. If I&#x27;m the one committing, I can rebase however I want to rewrite history before merging, so if I&#x27;m super adamant that a commit that looks a certain way exists, I can just make that commit and then put commits around it as needed to ensure that it can be merged with by fast-forward to preserve it. If I&#x27;m not the one committing, why should I care about what intermediate states that the person who committed them don&#x27;t even care about enough to preserve?<p>To me, the issue seems more that the UX for doing this sort of thing is not intuitive to most people, so the amount of effort needed to get the history rebased to what I described above often ends up being higher than people are willing to spend. This isn&#x27;t a particulary compelling argument to me in favor of merging workflows though because it doesn&#x27;t end up making the history better; it just removes most of the friction of merging by giving up any semblance of sane commit history.<p>(edited to add the below)<p>&gt; When someone rebases `n` commits, experience has taught me I can&#x27;t trust any commits other than `HEAD`; chances are any commit printed by `git log &quot;HEAD~${n}..HEAD^&quot;` was never checked out by anyone, much less tested at all.<p>I definitely agree that generating broken commits during a rebase is not a good thing for anyone, and I&#x27;d be super frustrated if I had teammates doing that. At least personally, I make sure to compile and run unit tests before continuing after each step of a rebase after I&#x27;ve fixed conflicts; there&#x27;s even the `x` option in an interactive rebase to execute a command on each commit (which will halt and drop into commit and allow you to amend before continuing if it fails), which is unfortunately not super well known.</div><br/><div id="40763737" class="c"><input type="checkbox" id="c-40763737" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40761387">parent</a><span>|</span><a href="#40759293">next</a><span>|</span><label class="collapse" for="c-40763737">[-]</label><label class="expand" for="c-40763737">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t really understand why this would be important.<p>It is important because not everyone does this:<p>&gt; [...] and then put commits around it as needed to ensure that it can be merged with by fast-forward to preserve it.<p>Good quality rebases like those are more likely to happen on patch-based workflows (not necessarily email), compared to PR-based workflows, because there&#x27;s more focus on the individual commits themselves being meaningful, with straight line history being mostly a nice side-effect. With &quot;more likely&quot; I mean literally that, more likely; I&#x27;m not saying it only happens there.<p>In PR-based workflows on the other hand, people tend to care only about HEAD. PR color is green? LGTM ship it :rocketemoji:. Most just read blog post by git shaman saying straight line pretty and then go to GitHub and enable the setting for that without thinking more than that; or learn that you can reorder commits to tell pretty story and do it without thinking more than that.<p>Though it&#x27;s also true that some repository owners only care about the tagged commits; all untagged commits could be broken and they don&#x27;t care because &quot;it&#x27;s supposed to be in progress&quot; and &quot;as long as the most recent commit works, it&#x27;s fine&quot;. They&#x27;ve never needed to checkout any specific commit on any repository (understandable if they never contribute to <i>others&#x27;</i> repositories).<p>---<p>Also, you probably noticed already because of your edit, but re:<p>&gt; If I&#x27;m not the one committing, why should I care about what intermediate states that the person who committed them don&#x27;t even care about enough to preserve?<p>With &quot;intermediate states&quot; I don&#x27;t mean what other people committed; I mean all your own commits that you just rebased (all your own commits whose hash changed) that are not the most recent one.<p>You are in the minority that fixes those; most people I&#x27;ve met would be like:<p>* All commits are tested and work fine.<p>* Create PR.<p>* See CI fails because branch is outdated.<p>* Rebase PR onto most recent commit of main branch.<p>* See CI fails because, idk, let&#x27;s say it&#x27;s something easy to fix like a more strict linter config.<p>* Make a new commit that fixes the linter errors.<p>* CI passes.<p>* Everyone LGTM&#x27;s the PR and it gets fast-forwarded.<p>* The PR had `n` commits, but now `n-1` of those fail the linter because they contain the new config for the linter, but the committer never bothered to look at those commits, they only cared about HEAD. Those `n-1` commits &quot;contain trees that the committer never saw at any point at all&quot; (copy-pasting that quote from my message). And it doesn&#x27;t matter that those commits are broken because for those people having pretty straight line is way more important than a working commit.<p>The recent FreeBSD&#x2F;Netflix thingy[1] had a successful bisect only because when people rebase stuff in there, they don&#x27;t YOLO those `n-1` rebased commits. If that had been any of my previous workplaces, or anyone who only rebase because &quot;straight line pretty&quot; without thinking anything more than that, then that whole bisect could have gone way worse.<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40630699">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40630699</a></div><br/><div id="40764047" class="c"><input type="checkbox" id="c-40764047" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763737">parent</a><span>|</span><a href="#40759293">next</a><span>|</span><label class="collapse" for="c-40764047">[-]</label><label class="expand" for="c-40764047">[3 more]</label></div><br/><div class="children"><div class="content">All of your points seem accurate to me, but I don&#x27;t see how merge workflows fix any of it. It seems like the same thing could happen where each commit along the way is broken until the final one, and then it&#x27;s merged as-is. I don&#x27;t think that having those intermediate commits being the exact ones that the person made is a solution because the problem you&#x27;re describing is social, not technical; people not caring about committing messy intermediate state to the repo isn&#x27;t going to be fixed by using merging rather than rebasing. The only workflow that would eliminate the problem entirely is to completely remove all intermediate state by squashing to a single commit before any merge, at which point doing a merge versus a rebase won&#x27;t matter.</div><br/><div id="40764425" class="c"><input type="checkbox" id="c-40764425" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764047">parent</a><span>|</span><a href="#40759293">next</a><span>|</span><label class="collapse" for="c-40764425">[-]</label><label class="expand" for="c-40764425">[2 more]</label></div><br/><div class="children"><div class="content">Neither workflow fixes anything. Each strategy helps with some things, but require discipline in other things.<p>Using merges lets you commit as you go, without needing to go back to repeat a test on a previous commit, and only worry about conflicts at the end of your development. Write code, test, commit. Write more code, test, commit. Cherry-pick, test, commit. Merge into main, fix conflicts, finish merge. There&#x27;s never a need to go back and re-test, like with rebase, because the commits that were already tested are still there. But they require discipline to not pollute history, and being open to squashing commits that don&#x27;t add any useful information (you want to avoid having &quot;WIP&quot;-style commits).<p>Using rebases lets you rewrite commits to take advantage of the most recent changes from the main branch, instead of waiting until you finish with your feature. But they require discipline to go back and repeat tests to ensure that any commit that changed still works as expected (and it&#x27;s needed because the commits changed, hence their different hash, so they are no longer the commit hashes that were tested), and being open to having <i>some</i> merge commits (you want to avoid rebasing a 10 commit migration of your telemetry library because if 3 months later you find out your costs in production were way higher than what they told you they would be, reverting a single merge commit is more dumbproof compared to reverting a manually provided range of commits).<p>So yes, choosing one or the other is a social problem. Both are good solutions with good discipline, and both are bad solutions with bad discipline. One of those makes it less likely for people in my bubble to make a mess out of that repo. It might be the same as for your bubble, or it might be different.<p>But on a good project it doesn&#x27;t really matter which one is done.</div><br/><div id="40764874" class="c"><input type="checkbox" id="c-40764874" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764425">parent</a><span>|</span><a href="#40759293">next</a><span>|</span><label class="collapse" for="c-40764874">[-]</label><label class="expand" for="c-40764874">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So yes, choosing one or the other is a social problem. Both are good solutions with good discipline, and both are bad solutions with bad discipline. One of those makes it less likely for people in my bubble to make a mess out of that repo. It might be the same as for your bubble, or it might be different.<p>&gt; But on a good project it doesn&#x27;t really matter which one is done.<p>I appreciate your explanations! I think I understand your point of view now, and I do actually agree with it. In particular, I hadn&#x27;t fully considered that the problem ultimately being social means that the &quot;best&quot; choice will be mostly dependent on what consensus a group is able to come to.<p>Thinking about this more, it almost seems like having a preference could become self-reinforcing; it&#x27;s hard to be a member of a group that reaches a consensus on using merges as someone who prefers rebases (and likewise for the reverse), which over time manifests as more and more anecdotal evidence in favor of the preference working better than the alternative. It&#x27;s no wonder that debates about this sort of thing become so contentious over time...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40759293" class="c"><input type="checkbox" id="c-40759293" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40761387">prev</a><span>|</span><a href="#40759104">next</a><span>|</span><label class="collapse" for="c-40759293">[-]</label><label class="expand" for="c-40759293">[13 more]</label></div><br/><div class="children"><div class="content">In a merge-based workflow you can have commits like &quot;wip&quot; or &quot;before lunch&quot;; no reason to believe those were ever tested either.<p>I like rebasing but it&#x27;s ultimately up to the author. Even tools like Fossil, that don&#x27;t have official history rewriting tools, don&#x27;t ensure that history has never been rewritten because people can use external tools to do the rewriting (and I&#x27;ve done this).</div><br/><div id="40759489" class="c"><input type="checkbox" id="c-40759489" checked=""/><div class="controls bullet"><span class="by">martin-t</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759293">parent</a><span>|</span><a href="#40759104">next</a><span>|</span><label class="collapse" for="c-40759489">[-]</label><label class="expand" for="c-40759489">[12 more]</label></div><br/><div class="children"><div class="content">Use a temporary branch for those. When you come back,  undo the commit (git test -- hard if memory serves but i just have an &quot;uncommit&quot; alias) and commit the fully finished work to the real branch.</div><br/><div id="40759693" class="c"><input type="checkbox" id="c-40759693" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759489">parent</a><span>|</span><a href="#40759104">next</a><span>|</span><label class="collapse" for="c-40759693">[-]</label><label class="expand" for="c-40759693">[11 more]</label></div><br/><div class="children"><div class="content">This <i>is</i> destroying the &quot;real history&quot; though. (Which again, I&#x27;m fine with, I like rebasing.)<p>Two months from now I&#x27;m quite likely to say something like &quot;oh yeah, I remember I encountered a bug related to that, I was trying to fix it before lunch&quot;. The &quot;wip&quot; and &quot;before lunch&quot; commits are just as likely to be relevant in the future as any other.<p>It&#x27;s nice to assume that all commits will compile and pass the tests, but it&#x27;s sometimes useful to have a snapshot of that weird compiler error you encountered. So much for our nice assumption.<p>This is why I say it&#x27;s all up to the author, and if the author likes rebasing, I don&#x27;t think anyone should have a problem with that. (Don&#x27;t rewrite public branches, of course.)</div><br/><div id="40760939" class="c"><input type="checkbox" id="c-40760939" checked=""/><div class="controls bullet"><span class="by">martin-t</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759693">parent</a><span>|</span><a href="#40763438">next</a><span>|</span><label class="collapse" for="c-40760939">[-]</label><label class="expand" for="c-40760939">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s levels of granularity that matter. You could just as well record all your edits in realtime. Make a script that makes a commit every second or every time you finish editing a line. It might be interesting later, yet that&#x27;s usually not how people use git. Those changes wouldn&#x27;t be meaningful units of work.<p>If you make a commit &quot;wip&quot; or &quot;before lunch&quot; because you want a backup of your work or want to continue on a different computer, then it&#x27;s not a meaningful unit either. It&#x27;s OK to throw away.<p>Most people prefer less granular commits but not to the point of having 1 commit per issue&#x2F;PR. For example after inheriting someone else&#x27;s code written in a hurry and not tested, I often end up dividing my work into several commits - first there&#x27;s a cleanup of all the things that need renaming for consistency, adding docs&#x2F;tests, removing redundant&#x2F;unused code, etc. sometimes this ends up being more commits as i reveal more tech debt. Then, when i am confident i actually understand code and it&#x27;s up to my standards, I make the actual change. This can be again multiple commits. The first and second group are often mixed.<p>And it&#x27;s important when it later turns out i broke something - i can focus on the commits that make functional changes as the issue is usually there and not in the cleanup commits which can be 10x larger.<p>BTW what git is really missing is a way to mark multiple commits as one unit of work so the granularity stays there but is hidden by default and can be expanded.</div><br/><div id="40762056" class="c"><input type="checkbox" id="c-40762056" checked=""/><div class="controls bullet"><span class="by">rawling</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40760939">parent</a><span>|</span><a href="#40763198">next</a><span>|</span><label class="collapse" for="c-40762056">[-]</label><label class="expand" for="c-40762056">[6 more]</label></div><br/><div class="children"><div class="content">&gt; BTW what git is really missing is a way to mark multiple commits as one unit of work so the granularity stays there but is hidden by default and can be expanded.<p>Is that not just a non-FF&#x27;d, non-squashed merge of a branch?</div><br/><div id="40762951" class="c"><input type="checkbox" id="c-40762951" checked=""/><div class="controls bullet"><span class="by">martin-t</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762056">parent</a><span>|</span><a href="#40763056">next</a><span>|</span><label class="collapse" for="c-40762951">[-]</label><label class="expand" for="c-40762951">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the closest you get today but it means having to make, merge and delete branches all the time. What i propose is something like git squash but that keeps the history internally. It would present as one commit in gitk and other GUIs but could be expanded to see more detail.</div><br/><div id="40765035" class="c"><input type="checkbox" id="c-40765035" checked=""/><div class="controls bullet"><span class="by">normie3000</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762951">parent</a><span>|</span><a href="#40763067">next</a><span>|</span><label class="collapse" for="c-40765035">[-]</label><label class="expand" for="c-40765035">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it means having to make, merge and delete branches all the time<p>Isn&#x27;t this something that git makes simple?</div><br/></div></div><div id="40763067" class="c"><input type="checkbox" id="c-40763067" checked=""/><div class="controls bullet"><span class="by">sam_bristow</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762951">parent</a><span>|</span><a href="#40765035">prev</a><span>|</span><a href="#40763056">next</a><span>|</span><label class="collapse" for="c-40763067">[-]</label><label class="expand" for="c-40763067">[2 more]</label></div><br/><div class="children"><div class="content">Does gitk have an equivalent of `git log --first-parent`?</div><br/><div id="40763697" class="c"><input type="checkbox" id="c-40763697" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763067">parent</a><span>|</span><a href="#40763056">next</a><span>|</span><label class="collapse" for="c-40763697">[-]</label><label class="expand" for="c-40763697">[1 more]</label></div><br/><div class="children"><div class="content">In the View menu dialog, there&#x27;s a checkbox for &quot;Limit to first parent&quot;</div><br/></div></div></div></div></div></div><div id="40763056" class="c"><input type="checkbox" id="c-40763056" checked=""/><div class="controls bullet"><span class="by">sam_bristow</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762056">parent</a><span>|</span><a href="#40762951">prev</a><span>|</span><a href="#40763198">next</a><span>|</span><label class="collapse" for="c-40763056">[-]</label><label class="expand" for="c-40763056">[1 more]</label></div><br/><div class="children"><div class="content">This is my preferred branching model. Most forges seem to call it &quot;semi-linear history&quot;. If you have a lot of people working on the repo you&#x27;ll probably want a merge queue to handle landing PRs but that&#x27;s pretty straight forward.<p>It works really well with things like git bisect. It also means history is actually useful.</div><br/></div></div></div></div><div id="40763198" class="c"><input type="checkbox" id="c-40763198" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40760939">parent</a><span>|</span><a href="#40762056">prev</a><span>|</span><a href="#40763438">next</a><span>|</span><label class="collapse" for="c-40763198">[-]</label><label class="expand" for="c-40763198">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Make a script that makes a commit every second or every time you finish editing a line. It might be interesting later, yet that&#x27;s usually not how people use git. Those changes wouldn&#x27;t be meaningful units of work.<p>Every Jetbrains IDE does this, and VSCode has it&#x27;s own equivalent feature. They don&#x27;t use git, but same thing really. It&#x27;s one of the most useful features ever IMO.</div><br/></div></div></div></div><div id="40763438" class="c"><input type="checkbox" id="c-40763438" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759693">parent</a><span>|</span><a href="#40760939">prev</a><span>|</span><a href="#40763158">next</a><span>|</span><label class="collapse" for="c-40763438">[-]</label><label class="expand" for="c-40763438">[1 more]</label></div><br/><div class="children"><div class="content">If people say &quot;preserve history&quot; as in &quot;literally don&#x27;t delete anything&quot;, then yeah I see where you&#x27;re coming from.<p>I&#x27;m not against rebase, and even use it myself. But having a repo where every 3rd commit is a dice roll for git bisect just because straight line pretty, is just as annoying as people shipping their reflog.<p>A rebase of one commit is harmless. A squash is harmless. A rebase of multiple commits where every commit is deliberate (verifying all rebased commits, etc) is harmless.<p>A rebase that ignores the fact that any commit whose hash changed can now fail, is irresponsible.  Shipping `wip` commit messages is irresponsible. A merge commit with the default message is irresponsible (it&#x27;s no different from a `wip`-style commit). Having a branch with merge commits that could have been cherry-picks[3].<p>Also, <i>to me</i> the lie is not some aesthetic thing like commit order or some easily forgeable timestamp; the lie is having a commit that (for example) assumes the `p4tcc` driver is being used[1], and you read the diff and indeed it has assumptions that imply that driver is being used[2], but when you actually checkout that commit and see if that driver exists it turns out no it fucking doesn&#x27;t, and hours were wasted chasing ghosts. Only because when that commit was created, the p4tcc driver was being used, but when <i>you</i> checked out weeks later now that commit magically uses the `est` driver instead.<p>If you&#x27;re going to keep straight line, then test every change; if you don&#x27;t do it, don&#x27;t complain about broken middle commits.<p>If you&#x27;re going to do merge commits, then keep each commit clean[4], even the merge commit[5]; if you don&#x27;t don&#x27;t complain about a history that is polluted with weird commits and looks like the timeline of a time-travelling show.<p>[1]: Because it did when that commit was created.<p>[2]: Because, again, it did when that commit was created.<p>[3]: This assumes the branch will later be integrated into main with a merge commit.<p>[4]: Squash is harmless. It&#x27;s just omission. If anyone complains about purity, then just keep them happy with `git reset $COMMIT ; git add --all ; git commit -m &quot;This is a new commit from scratch&quot;`<p>[5]: Write something that helps those who use `git log --first-parent`. If you&#x27;re on GitHub, at least use PR title and description as default (can be overriden on a case-by-case basis). If not, then even just &quot;${JIRA_ID}: ${JIRA_TITLE}&quot; is more useful than the default merge commit message while still letting you be lazy.</div><br/></div></div><div id="40763158" class="c"><input type="checkbox" id="c-40763158" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759693">parent</a><span>|</span><a href="#40763438">prev</a><span>|</span><a href="#40759104">next</a><span>|</span><label class="collapse" for="c-40763158">[-]</label><label class="expand" for="c-40763158">[1 more]</label></div><br/><div class="children"><div class="content">I depends on what you view as the real history. If you link each pull request to a work item you’re not going to really need all the commits on a development branch, because the only part of the history which matters is the pull request.<p>I think people should just use what works for them, if that’s debase who cares? The important part is being able to commit “asd” 9 billion times. If you can’t do that it will tax your developers with needlessly having to come up with reasons why they committed before lunch… that meeting… going to the toilet and so on.</div><br/></div></div></div></div></div></div></div></div><div id="40759104" class="c"><input type="checkbox" id="c-40759104" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40759293">prev</a><span>|</span><a href="#40762892">next</a><span>|</span><label class="collapse" for="c-40759104">[-]</label><label class="expand" for="c-40759104">[8 more]</label></div><br/><div class="children"><div class="content">I think most people these days just look at PRs. Everything else is largely noise.</div><br/><div id="40762646" class="c"><input type="checkbox" id="c-40762646" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759104">parent</a><span>|</span><a href="#40762892">next</a><span>|</span><label class="collapse" for="c-40762646">[-]</label><label class="expand" for="c-40762646">[7 more]</label></div><br/><div class="children"><div class="content">Not at all. Someone’s got to look at your commits in the future when your code breaks ;)</div><br/><div id="40763718" class="c"><input type="checkbox" id="c-40763718" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762646">parent</a><span>|</span><a href="#40762863">next</a><span>|</span><label class="collapse" for="c-40763718">[-]</label><label class="expand" for="c-40763718">[5 more]</label></div><br/><div class="children"><div class="content">Yep, this is why I&#x27;m mostly against squashing (and completely against blind squash-merges).</div><br/><div id="40765249" class="c"><input type="checkbox" id="c-40765249" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763718">parent</a><span>|</span><a href="#40765099">next</a><span>|</span><label class="collapse" for="c-40765249">[-]</label><label class="expand" for="c-40765249">[1 more]</label></div><br/><div class="children"><div class="content">Oh I&#x27;m for squashing to make the history make sense. Please do not blindly squash-merge though.</div><br/></div></div><div id="40765099" class="c"><input type="checkbox" id="c-40765099" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763718">parent</a><span>|</span><a href="#40765249">prev</a><span>|</span><a href="#40762863">next</a><span>|</span><label class="collapse" for="c-40765099">[-]</label><label class="expand" for="c-40765099">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I get the advantage. The only thing I know is that the last commit on each PR is the one that is claimed to work. All others might as well be noise at that point since those random intermediates were never HEAD on the main branch, might be broken, incomplete, have failing tests, etc.. Squashing every PR into a single commit is at least an honest history of what&#x27;s actually going out.<p>If you squash you have a history where every commit was tested and works (bugs notwithstanding) which to me is way more useful.</div><br/><div id="40765299" class="c"><input type="checkbox" id="c-40765299" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40765099">parent</a><span>|</span><a href="#40765253">next</a><span>|</span><label class="collapse" for="c-40765299">[-]</label><label class="expand" for="c-40765299">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (bugs notwithstanding)<p>This is the reason.  I&#x27;ve been on a maintenance team for years where almost everything we handle was written by people no longer at the company, and often enough I&#x27;ve seen bugs get introduced during the original work, where the fix ends up being obvious because I can see the original commits and how the code got into its current state.  A squash of any sort would&#x27;ve hidden the refactor and made it much more difficult.<p>My favorite are ones where &quot;linting&quot; and code formatter commits introduce bugs.  Keep those separate from your actual work, <i>please</i>.</div><br/></div></div><div id="40765253" class="c"><input type="checkbox" id="c-40765253" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40765099">parent</a><span>|</span><a href="#40765299">prev</a><span>|</span><a href="#40762863">next</a><span>|</span><label class="collapse" for="c-40765253">[-]</label><label class="expand" for="c-40765253">[1 more]</label></div><br/><div class="children"><div class="content">I mean you should be designing your commits such that each individual commit builds. That&#x27;s the point of using squashes to fix up your history!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40762892" class="c"><input type="checkbox" id="c-40762892" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40759104">prev</a><span>|</span><a href="#40763605">next</a><span>|</span><label class="collapse" for="c-40762892">[-]</label><label class="expand" for="c-40762892">[1 more]</label></div><br/><div class="children"><div class="content">When I rebase I diff after each rebase to check that the only diffs are the ones I intended.  So I, the committer, have seen all my rebased commits.</div><br/></div></div><div id="40763605" class="c"><input type="checkbox" id="c-40763605" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40762892">prev</a><span>|</span><a href="#40762853">next</a><span>|</span><label class="collapse" for="c-40763605">[-]</label><label class="expand" for="c-40763605">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s kind of the point though: being reasonably sure that a commit contains a tree that the committer had seen at some point, instead of making up history with commits that contain trees that the committer never saw at any point at all.<p>I don&#x27;t see how this follows.  Merge-heavy histories in my experience tend to be <i>far less</i> bisectable.  They have all sorts of &quot;oops, fixup&quot; nonsense going on, precisely because the author did <i>not</i> take the time to get things right the first time.<p>Any workflow that happens on a number of patches greater than 1 accepts poor bisectability as a risk.  But the only real solution there is Giant Monolithic Commits, which we all agree is even worse, right?</div><br/><div id="40764051" class="c"><input type="checkbox" id="c-40764051" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763605">parent</a><span>|</span><a href="#40762853">next</a><span>|</span><label class="collapse" for="c-40764051">[-]</label><label class="expand" for="c-40764051">[1 more]</label></div><br/><div class="children"><div class="content">Yeah if &quot;merge-heavy&quot; means &quot;ship the reflog&quot;, I get what you mean.<p>But if &quot;merge-heavy&quot; means &quot;use merges when it makes sense, use rebase when it makes sense&quot;, then you can get a nice history with `git log --first-parent` that groups related commits together, and also a nice history with `git log --cherry` that shows what the &quot;always-rebase-never-merge&quot; dogmatic people want.<p>If for this particular project it <i>just so happens</i> that merge doesn&#x27;t make sense because of the specific needs of the project, then so be it, nothing wrong with that. Same with rebases.<p>Unfortunately this topic is another holy war where the ship-the-reflog dogma fights against the always-rebase-never-merge dogma.<p>No balance.<p>&gt; I don&#x27;t see how this follows. Merge-heavy histories in my experience tend to be far less bisectable. They have all sorts of &quot;oops, fixup&quot; nonsense going on, precisely because the author did not take the time to get things right the first time.<p>That sounds more like merge-only (a.k.a. &quot;ship the reflog&quot;). Doesn&#x27;t have to be that way.<p>Evaluate trade-offs and choose based on that evaluation.<p>Does adding a new commit have any <i>actual advantage</i> (e.g. easily reverting one or the other) compared to just amending&#x2F;squashing it, or is it just some developer&#x27;s own subjective sense of purity?<p>Does re-ordering the commits have any <i>actual advantage</i> (e.g. change has a smaller context and can be more easily reverted that way) compared to just leaving those commits in that order, or is it just some developer&#x27;s own subjective sense of aesthetics?<p>Does using merge commits bring any <i>actual advantage</i> (e.g. the project benefits from being able to bisect on PRs or features as a whole) compared to rebasing (not fast-forwarding), or is it just some developer&#x27;s own subjective sense of purity?<p>Does rebasing bring any <i>actual advantage</i> (e.g. each commit is already atomic, fully self-contained, and well tested against the new base, so &quot;grouping&quot; them with a merge commit doesn&#x27;t make sense) compared to doing a merge-commit, or is it just some developer&#x27;s own subjective sense of aesthetics?<p>&gt; Any workflow that happens on a number of patches greater than 1 accepts poor bisectability as a risk.<p>Poor bisectability <i>or</i> developers putting actual effort into ensuring commits are atomic and test them.<p>Bisectability is nice with good rebased commits. Bisectability is nice with good merge commits.<p>Bisectability is bad when developers don&#x27;t care about keeping bisectability good.<p>&gt; But the only real solution there is Giant Monolithic Commits, which we all agree is even worse, right?<p>It depends.<p>Those commits might not be easy to understand, but they sure as hell are easy to revert (more likely than not) if something goes wrong, because they tend to correspond almost 1:1 to GitHub issues (or Jira tickets, or whatever equivalent). Keyword &quot;almost&quot; because sometimes you can get 2 of those for the same issue&#x2F;ticket&#x2F;whatever.<p>But those 2 unproperly split commits (therefore huge) are still easier to revert compared to a spray of 10 unproperly rebased tiny commits where 9 of them are broken (because of what I mention in other comments where people only test HEAD).</div><br/></div></div></div></div><div id="40762853" class="c"><input type="checkbox" id="c-40762853" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40763605">prev</a><span>|</span><a href="#40764422">next</a><span>|</span><label class="collapse" for="c-40762853">[-]</label><label class="expand" for="c-40762853">[1 more]</label></div><br/><div class="children"><div class="content">If you want the full history of someone&#x27;s work, you need all the edits. Including all the times they backspaced over the typo. With down-to-the-millisecond timestamps attached!</div><br/></div></div><div id="40764422" class="c"><input type="checkbox" id="c-40764422" checked=""/><div class="controls bullet"><span class="by">zimbu668</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40762853">prev</a><span>|</span><a href="#40758788">next</a><span>|</span><label class="collapse" for="c-40764422">[-]</label><label class="expand" for="c-40764422">[1 more]</label></div><br/><div class="children"><div class="content">&gt; nobody would bother re-testing all those n-1 commits after the fix was added<p>I do.</div><br/></div></div><div id="40758788" class="c"><input type="checkbox" id="c-40758788" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754565">parent</a><span>|</span><a href="#40764422">prev</a><span>|</span><a href="#40764504">next</a><span>|</span><label class="collapse" for="c-40758788">[-]</label><label class="expand" for="c-40758788">[2 more]</label></div><br/><div class="children"><div class="content">This assumes the rebasing will be done in a shared branch. Two rules of rebasing:<p>1. Never rebase a shared branch
2. Never break rule 1</div><br/><div id="40758857" class="c"><input type="checkbox" id="c-40758857" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758788">parent</a><span>|</span><a href="#40764504">next</a><span>|</span><label class="collapse" for="c-40758857">[-]</label><label class="expand" for="c-40758857">[1 more]</label></div><br/><div class="children"><div class="content">No, that describes rebasing and preserving the intermediate commits. Of course, if you squash into one commit at merge time, this won&#x27;t happen.</div><br/></div></div></div></div></div></div><div id="40764504" class="c"><input type="checkbox" id="c-40764504" checked=""/><div class="controls bullet"><span class="by">ak217</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40754565">prev</a><span>|</span><a href="#40759731">next</a><span>|</span><label class="collapse" for="c-40764504">[-]</label><label class="expand" for="c-40764504">[3 more]</label></div><br/><div class="children"><div class="content">I love rebasing, and use it most of the time. At work we also enforce squash-merging, which is the only scalable way to prevent low quality commits from polluting the main branch history.<p>While rebasing works most of the time, the problem arises when actually collaborating on feature branches - <i>especially</i> when your collaborator is not confident enough with git to realize when a rebase conflict might lose data. Merging works better in these situations. So while standardizing on rebasing is great for productivity across the org, you also have to watch out for this and make sure developers don&#x27;t lose the ability to collaborate on branches.</div><br/><div id="40764998" class="c"><input type="checkbox" id="c-40764998" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764504">parent</a><span>|</span><a href="#40759731">next</a><span>|</span><label class="collapse" for="c-40764998">[-]</label><label class="expand" for="c-40764998">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of rebasing when you in the end squash-merge?<p>In my mind the only real benefit of rebasing is that you split your work into a couple of &quot;nice&quot; commits, but if you squash them anyway...<p>Ok, I&#x27;ve seen people doing this to ease the review process and I guess it makes sense sometimes, but to me it&#x27;s still a largely &quot;not worth it&quot; effort.</div><br/><div id="40765540" class="c"><input type="checkbox" id="c-40765540" checked=""/><div class="controls bullet"><span class="by">sensanaty</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40764998">parent</a><span>|</span><a href="#40759731">next</a><span>|</span><label class="collapse" for="c-40765540">[-]</label><label class="expand" for="c-40765540">[1 more]</label></div><br/><div class="children"><div class="content">The squash merge is for the sanity of master&#x2F;main, whereas rebase is for the sanity of the reviewer. That&#x27;s how I look at it at least</div><br/></div></div></div></div></div></div><div id="40759731" class="c"><input type="checkbox" id="c-40759731" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40764504">prev</a><span>|</span><a href="#40762719">next</a><span>|</span><label class="collapse" for="c-40759731">[-]</label><label class="expand" for="c-40759731">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. The only true history is the clean, properly rebased history with one change per commit, as I want it.</div><br/></div></div><div id="40762719" class="c"><input type="checkbox" id="c-40762719" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40759731">prev</a><span>|</span><a href="#40754907">next</a><span>|</span><label class="collapse" for="c-40762719">[-]</label><label class="expand" for="c-40762719">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I reject the argument that a no-rebase, merge-only history &quot;preserves the true history of how commits were created&quot;, because I believe that is irrelevant. What is relevant is what the tree looks like once the merge (or rebase) lands.<p>Was the bug introduced by the rebase, or was that code always broken?</div><br/><div id="40762749" class="c"><input type="checkbox" id="c-40762749" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762719">parent</a><span>|</span><a href="#40754907">next</a><span>|</span><label class="collapse" for="c-40762749">[-]</label><label class="expand" for="c-40762749">[3 more]</label></div><br/><div class="children"><div class="content">Code doesn&#x27;t exist until it is merged, so these are equivalent</div><br/><div id="40763016" class="c"><input type="checkbox" id="c-40763016" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762749">parent</a><span>|</span><a href="#40754907">next</a><span>|</span><label class="collapse" for="c-40763016">[-]</label><label class="expand" for="c-40763016">[2 more]</label></div><br/><div class="children"><div class="content">Err, what?<p>If I&#x27;m trying to fix the PR, the distinction is often a critical starting point for finding the root problem.</div><br/><div id="40763995" class="c"><input type="checkbox" id="c-40763995" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40763016">parent</a><span>|</span><a href="#40754907">next</a><span>|</span><label class="collapse" for="c-40763995">[-]</label><label class="expand" for="c-40763995">[1 more]</label></div><br/><div class="children"><div class="content">If your PR is big enough that you&#x27;re relying on a git bisect to find a bug, that&#x27;s a problem in its own right.<p>A workflow like what OP is describing (code doesn&#x27;t exist until it&#x27;s merged) typically also assumes that your PR is one atomic change, not a whole feature. You&#x27;d use feature flags or something similar to decide when to actually release a feature, not the PR process.</div><br/></div></div></div></div></div></div></div></div><div id="40754907" class="c"><input type="checkbox" id="c-40754907" checked=""/><div class="controls bullet"><span class="by">rictic</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40762719">prev</a><span>|</span><a href="#40762620">next</a><span>|</span><label class="collapse" for="c-40754907">[-]</label><label class="expand" for="c-40754907">[10 more]</label></div><br/><div class="children"><div class="content">Sure it looks nice, but it&#x27;s a fake history. After a rebase you have commits where no one&#x27;s ever run the tests, no author ever intended to get the repo into that state. Hell, most likely no one knows if the code even compiles.<p>It&#x27;s assuming that that merge conflicts will never be too difficult, and people won&#x27;t make mistakes in resolving them. If so, too bad, the original commits are lost by the rebase process. (They might or might not be kept in any given clone. No guarantees, good luck trawling through the reflog.)<p>It&#x27;s corrupting your database because it makes the UI for exploring it nicer.<p>This is the opposite of what we should be doing! If the truth is messy we should build better UIs for exploring it. Add additional information on top of the true history, allow people to group and describe commits. Add more information to get the UI that you want, rather than destroying information because it makes things look cluttered.</div><br/><div id="40756594" class="c"><input type="checkbox" id="c-40756594" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754907">parent</a><span>|</span><a href="#40762786">next</a><span>|</span><label class="collapse" for="c-40756594">[-]</label><label class="expand" for="c-40756594">[3 more]</label></div><br/><div class="children"><div class="content">&gt;After a rebase you have commits where no one&#x27;s ever run the tests, no author ever intended to get the repo into that state. Hell, most likely no one knows if the code even compiles.<p>Only true if the commit author doesn&#x27;t do so, and it is trivial to do so, either during or after a rebase using the rebase exec command. So given this is a discipline issue no different from a developer authoring a change without testing it, I fail to see how this is &quot;rebase&quot;&#x27;s fault.<p>&gt;it makes the UI for exploring it nicer<p>Not to imply I accept the &quot;corrupt database&quot; opinion, but I think it&#x27;s worth saying that aside from the collaborative element of VCS, commits exist for the purpose of exploring past code changes. A practice which improves that seems sound to me.<p>&gt;we should build better UIs for exploring it<p>Go right ahead :)</div><br/><div id="40762759" class="c"><input type="checkbox" id="c-40762759" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40756594">parent</a><span>|</span><a href="#40762786">next</a><span>|</span><label class="collapse" for="c-40762759">[-]</label><label class="expand" for="c-40762759">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Only true if the commit author doesn&#x27;t do so, and it is trivial to do so, either during or after a rebase using the rebase exec command. So given this is a discipline issue no different from a developer authoring a change without testing it, I fail to see how this is &quot;rebase&quot;&#x27;s fault.<p>&quot;Undisciplined enough to use rebase, disciplined enough to put in extra effort to mitigate <i>some</i> of the harms of rebase&quot; is an imaginary intersection.<p>&gt; Go right ahead :)<p><pre><code>    git log --first-parent</code></pre></div><br/><div id="40764018" class="c"><input type="checkbox" id="c-40764018" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762759">parent</a><span>|</span><a href="#40762786">next</a><span>|</span><label class="collapse" for="c-40764018">[-]</label><label class="expand" for="c-40764018">[1 more]</label></div><br/><div class="children"><div class="content">This is begging the question (the fallacy, not the colloquial expression). It&#x27;s only undisciplined to rebase if it&#x27;s a bad practice, which is the topic under consideration here.<p>You can&#x27;t use your preferred answer to the debate as justification for dismissing your opponent&#x27;s arguments.</div><br/></div></div></div></div></div></div><div id="40762786" class="c"><input type="checkbox" id="c-40762786" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754907">parent</a><span>|</span><a href="#40756594">prev</a><span>|</span><a href="#40755183">next</a><span>|</span><label class="collapse" for="c-40762786">[-]</label><label class="expand" for="c-40762786">[1 more]</label></div><br/><div class="children"><div class="content">Nothing prevents people from committing untested code that doesn&#x27;t even compile without any rebase involved. Even hooks don&#x27;t help since the incompetent coworkers are just barely smart enough to learn about -n</div><br/></div></div><div id="40755183" class="c"><input type="checkbox" id="c-40755183" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754907">parent</a><span>|</span><a href="#40762786">prev</a><span>|</span><a href="#40764050">next</a><span>|</span><label class="collapse" for="c-40755183">[-]</label><label class="expand" for="c-40755183">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>After a rebase you have commits where no one&#x27;s ever run the tests, no author ever intended to get the repo into that state. Hell, most likely no one knows if the code even compiles.</i><p>That is the role of the CI system.</div><br/><div id="40758868" class="c"><input type="checkbox" id="c-40758868" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40755183">parent</a><span>|</span><a href="#40764050">next</a><span>|</span><label class="collapse" for="c-40758868">[-]</label><label class="expand" for="c-40758868">[3 more]</label></div><br/><div class="children"><div class="content">CI will usually only run the latest commit. Even if commit a, b, and c were all tested, the resulting commits a&#x27;, b&#x27;, and c&#x27; after rebase would usually only have the last one tested.</div><br/><div id="40762383" class="c"><input type="checkbox" id="c-40762383" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758868">parent</a><span>|</span><a href="#40764050">next</a><span>|</span><label class="collapse" for="c-40762383">[-]</label><label class="expand" for="c-40762383">[2 more]</label></div><br/><div class="children"><div class="content">Since you shouldn&#x27;t publish commits that weren&#x27;t tested, this suggests you should publish only one commit at a time.<p>(Unless you think &quot;works on my machine&quot; is good enough testing. Sometimes it is.)</div><br/><div id="40763768" class="c"><input type="checkbox" id="c-40763768" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762383">parent</a><span>|</span><a href="#40764050">next</a><span>|</span><label class="collapse" for="c-40763768">[-]</label><label class="expand" for="c-40763768">[1 more]</label></div><br/><div class="children"><div class="content">So rebase then force push a&#x27;, wait for CI, push b&#x27;, wait for CI, push c&#x27;? Personally I just squash on merge.</div><br/></div></div></div></div></div></div></div></div><div id="40764050" class="c"><input type="checkbox" id="c-40764050" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40754907">parent</a><span>|</span><a href="#40755183">prev</a><span>|</span><a href="#40762620">next</a><span>|</span><label class="collapse" for="c-40764050">[-]</label><label class="expand" for="c-40764050">[1 more]</label></div><br/><div class="children"><div class="content">&gt; After a rebase you have commits where no one&#x27;s ever run the tests, no author ever intended to get the repo into that state.<p>I take it that you&#x27;ve never reviewed a PR where the commits were a series of &quot;wip&quot; commits that don&#x27;t even type check, much less pass the tests?<p>Undisciplined developers will be undisciplined. Forcing a rebase-free workflow mostly makes it less likely that these developers will lose work, it doesn&#x27;t magically give you a clean commit history from them.</div><br/></div></div></div></div><div id="40762620" class="c"><input type="checkbox" id="c-40762620" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40754907">prev</a><span>|</span><a href="#40758854">next</a><span>|</span><label class="collapse" for="c-40762620">[-]</label><label class="expand" for="c-40762620">[1 more]</label></div><br/><div class="children"><div class="content">I generally prefer a rebase-free workflow (mostly due to my upbringing. Long story...) But other than rebasing shared branches, which (with notable exceptions) is a Wrong Thing, it&#x27;s mostly up to teams to decide on a workflow that gets things done for them. As long as there&#x27;s a consensus on how to do things, go with god.</div><br/></div></div><div id="40758854" class="c"><input type="checkbox" id="c-40758854" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40762620">prev</a><span>|</span><a href="#40758735">next</a><span>|</span><label class="collapse" for="c-40758854">[-]</label><label class="expand" for="c-40758854">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been a developer for twenty four years. I&#x27;ve seen a lot of people have strong opinions about whether to merge or rebase, to squash or not to squash. I haven&#x27;t seen one single time where it made a difference whether something was merged or squashed, as I&#x27;ve never seen anyone look at commit messages in depth, versus tickets or PRs or bisecting.</div><br/><div id="40759098" class="c"><input type="checkbox" id="c-40759098" checked=""/><div class="controls bullet"><span class="by">citrin_ru</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758854">parent</a><span>|</span><a href="#40759155">next</a><span>|</span><label class="collapse" for="c-40759098">[-]</label><label class="expand" for="c-40759098">[1 more]</label></div><br/><div class="children"><div class="content">I read &#x27;git log -p&#x27; often, and linear history makes it so much easier. The same with bisecting. I&#x27;m yet to see any practical advantage of not allowing rebase&#x2F;squash in feature branches. Preserving <i>all</i> history of feature branches is not an advantage to me. The history I care about is the history of the main branch and I don&#x27;t want to see it splint into many tiny commits, especially not into commits looking like add&#x2F;fix&#x2F;fix&#x2F;fix&#x2F;fix where at all point except the last the code is broken.</div><br/></div></div><div id="40759155" class="c"><input type="checkbox" id="c-40759155" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758854">parent</a><span>|</span><a href="#40759098">prev</a><span>|</span><a href="#40765533">next</a><span>|</span><label class="collapse" for="c-40759155">[-]</label><label class="expand" for="c-40759155">[8 more]</label></div><br/><div class="children"><div class="content">The problem I run into is when a developer merges the main line branch into their feature branch repeatedly to get new changes. Now your branch is completely tangled up and difficult to change</div><br/><div id="40759475" class="c"><input type="checkbox" id="c-40759475" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759155">parent</a><span>|</span><a href="#40765533">next</a><span>|</span><label class="collapse" for="c-40759475">[-]</label><label class="expand" for="c-40759475">[7 more]</label></div><br/><div class="children"><div class="content">I do this like... all the time.  At least weekly for the last 5 years maybe?  I can&#x27;t remember a time where this has caused anything to get tangled or difficult.</div><br/><div id="40759635" class="c"><input type="checkbox" id="c-40759635" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759475">parent</a><span>|</span><a href="#40762794">next</a><span>|</span><label class="collapse" for="c-40759635">[-]</label><label class="expand" for="c-40759635">[2 more]</label></div><br/><div class="children"><div class="content">Cherry-picking is harder. Splitting up the branch is harder.</div><br/><div id="40760428" class="c"><input type="checkbox" id="c-40760428" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759635">parent</a><span>|</span><a href="#40762794">next</a><span>|</span><label class="collapse" for="c-40760428">[-]</label><label class="expand" for="c-40760428">[1 more]</label></div><br/><div class="children"><div class="content">I cherry pick occasionally.  I don&#x27;t see how it&#x27;s affected at all?
Edit:  If another dev and I both cherry pick the same commit concurrently, that might do something weird.  Maybe that&#x27;s it?<p>I don&#x27;t know what splitting up a branch means.</div><br/></div></div></div></div><div id="40762794" class="c"><input type="checkbox" id="c-40762794" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759475">parent</a><span>|</span><a href="#40759635">prev</a><span>|</span><a href="#40759704">next</a><span>|</span><label class="collapse" for="c-40762794">[-]</label><label class="expand" for="c-40762794">[2 more]</label></div><br/><div class="children"><div class="content">...why? Isn&#x27;t this exactly what rebase is for?  Just plain, boring, non-interactive rebase.</div><br/><div id="40763648" class="c"><input type="checkbox" id="c-40763648" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40762794">parent</a><span>|</span><a href="#40759704">next</a><span>|</span><label class="collapse" for="c-40763648">[-]</label><label class="expand" for="c-40763648">[1 more]</label></div><br/><div class="children"><div class="content">Maybe?  But it&#x27;s also what merge is for.<p>If I used rebase like this regularly it would become difficult to determine if a given commit is an ancestor of HEAD.  Sometimes I like to do that.</div><br/></div></div></div></div><div id="40759704" class="c"><input type="checkbox" id="c-40759704" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759475">parent</a><span>|</span><a href="#40762794">prev</a><span>|</span><a href="#40765533">next</a><span>|</span><label class="collapse" for="c-40759704">[-]</label><label class="expand" for="c-40759704">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;CAHk-=wjbtip559HcMG9VQLGPmkurh5Kc50y5BceL8Q8=aL0H3Q@mail.gmail.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;CAHk-=wjbtip559HcMG9VQLGPmkurh5...</a></div><br/><div id="40760423" class="c"><input type="checkbox" id="c-40760423" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40759704">parent</a><span>|</span><a href="#40765533">next</a><span>|</span><label class="collapse" for="c-40760423">[-]</label><label class="expand" for="c-40760423">[1 more]</label></div><br/><div class="children"><div class="content">Merges I create from the CLI don&#x27;t really look that differennt from the ones through some forge UI PR process.  I don&#x27;t know what Linus is getting at.  If I was working under someone who had a process like this, I could ask them to clarify what they wanted me to do.  I don&#x27;t have that.  And I need to be able to justify all of my decisions.  So this isn&#x27;t useful to me.<p>I don&#x27;t doubt that Linus has good reasons for all this.  I just don&#x27;t know what they are.  And I don&#x27;t know if they&#x27;re applicable to other repos.</div><br/></div></div></div></div></div></div></div></div><div id="40765533" class="c"><input type="checkbox" id="c-40765533" checked=""/><div class="controls bullet"><span class="by">sensanaty</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758854">parent</a><span>|</span><a href="#40759155">prev</a><span>|</span><a href="#40760121">next</a><span>|</span><label class="collapse" for="c-40765533">[-]</label><label class="expand" for="c-40765533">[1 more]</label></div><br/><div class="children"><div class="content">I would like to do it more, but it&#x27;s hard to convince people to not produce absolutely useless commit messages, and trust me I&#x27;ve tried.<p>Looking through my work project git log, it&#x27;s a sea of random ticket numbers followed by absolutely nothing helpful or descriptive, usually just the title of the ticket if you&#x27;re lucky.</div><br/></div></div><div id="40760121" class="c"><input type="checkbox" id="c-40760121" checked=""/><div class="controls bullet"><span class="by">david_allison</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758854">parent</a><span>|</span><a href="#40765533">prev</a><span>|</span><a href="#40758993">next</a><span>|</span><label class="collapse" for="c-40760121">[-]</label><label class="expand" for="c-40760121">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, I often look at commits&#x2F;commit messages in-depth.<p>I wouldn&#x27;t do so if the history were a mess</div><br/></div></div><div id="40758993" class="c"><input type="checkbox" id="c-40758993" checked=""/><div class="controls bullet"><span class="by">dnadler</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758854">parent</a><span>|</span><a href="#40760121">prev</a><span>|</span><a href="#40758735">next</a><span>|</span><label class="collapse" for="c-40758993">[-]</label><label class="expand" for="c-40758993">[2 more]</label></div><br/><div class="children"><div class="content">Really?<p>I certainly have used commit messages and seen others do the same. Perhaps this is more an indictment of the quality of the commit messages than anything else.<p>In my experience, rebase and squash makes it easier to collect work into meaningful groups and thus write more helpful&#x2F;informative commit messages.<p>I can think of a few times off the top of my head when I referred back to a detailed commit message in a repo to understand why a change was made.</div><br/><div id="40759161" class="c"><input type="checkbox" id="c-40759161" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40754234">root</a><span>|</span><a href="#40758993">parent</a><span>|</span><a href="#40758735">next</a><span>|</span><label class="collapse" for="c-40759161">[-]</label><label class="expand" for="c-40759161">[1 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m making a change that people are likely to wonder about, I tend to add comments. Basically, anything that&#x27;s not obvious tends to get a comment, change or no.</div><br/></div></div></div></div></div></div><div id="40758735" class="c"><input type="checkbox" id="c-40758735" checked=""/><div class="controls bullet"><span class="by">danlugo92</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40758854">prev</a><span>|</span><a href="#40762512">next</a><span>|</span><label class="collapse" for="c-40758735">[-]</label><label class="expand" for="c-40758735">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I dont even do history anymore for small projects, I bisect twice a year tops and I have never evee have had to look at a 3 year old commit to figure out a bug, not that the code could&#x27;nt be 3 years old but the blame is so tangled at that point..</div><br/></div></div><div id="40762512" class="c"><input type="checkbox" id="c-40762512" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#40754234">parent</a><span>|</span><a href="#40758735">prev</a><span>|</span><a href="#40754250">next</a><span>|</span><label class="collapse" for="c-40762512">[-]</label><label class="expand" for="c-40762512">[1 more]</label></div><br/><div class="children"><div class="content">Preach, brutha!</div><br/></div></div></div></div><div id="40754250" class="c"><input type="checkbox" id="c-40754250" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#40754234">prev</a><span>|</span><a href="#40756521">next</a><span>|</span><label class="collapse" for="c-40754250">[-]</label><label class="expand" for="c-40754250">[23 more]</label></div><br/><div class="children"><div class="content">Atomic commits can be great. I really prefer to see intentional atomic commits with meaningful messages than 20+ files changed with a commit message: &quot;Feature X&quot;.<p>I am 100% onboard with devs squashing their &quot;lint fix&quot;, &quot;test fix&quot;, &quot;whatever minor fix to get CI working&quot;, &quot;generally meaningless commit to cross the finish line&quot;. Also, if devs are working on something they check in a &quot;WIP&quot; commit. It is great if you smash your WIPs into a single meaningful commit. These manual squash strategies require some discipline to clean things up.<p>I think the &quot;squash branch to a single commit&quot; merge strategy defeats the purpose of atomic commits. Of course devs will be bad at atomic commits if the commits will inevitably smashed to a single commit. IMO squashing branches on merge is a bad version control strategy. I love it when commits are intentional.<p>One rule I have for any rebasing is, when there may be more than one person using the branch, no more rebasing that branch.</div><br/><div id="40754323" class="c"><input type="checkbox" id="c-40754323" checked=""/><div class="controls bullet"><span class="by">tkiolp4</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40758493">next</a><span>|</span><label class="collapse" for="c-40754323">[-]</label><label class="expand" for="c-40754323">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Atomic commits can be great. I really prefer to see intentional atomic commits with meaningful messages than 20+ files changed with a commit message: &quot;Feature X&quot;.<p>The most valuable “feature” of git for me is the “single commit with 20+ files changes”. I explain: I have landed in a new codebase, and now I need to add a new feature that would include perhaps a migration and adding a “usecase” and perhaps a “controller” and the corresponding tests. As usual, things are never clear in new codebases (depending on the library&#x2F;framework used, one might need to add routes to a main routing file, or perhaps touch some configuration yaml file to whitelist the newly introduced endpoint, or perhaps a changelog needs to be kept  updated whenever a migration is introduced, etc.). My point is: if I can git blame a line of code of the codebase that’s doing already more or less what I want to introduce, I want to see ALL the files that were touched as part of that change. It’s a lifesaver.</div><br/><div id="40755219" class="c"><input type="checkbox" id="c-40755219" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754323">parent</a><span>|</span><a href="#40754450">next</a><span>|</span><label class="collapse" for="c-40755219">[-]</label><label class="expand" for="c-40755219">[1 more]</label></div><br/><div class="children"><div class="content">Git has great tools. It sounds like you&#x27;d want to see everything associated with a merge commit. If what you&#x27;re looking for is a certain way to view changes, git&#x27;s built in tooling usually has you covered regardless of commit strategy.<p>So if you know a commit sha and you&#x27;d like to see all of the merged branch changes associated with that commit as a single patch, I cooked up a script that takes a commit sha and finds the merge commit and show all the changes in a consolidated patch.<p>#!&#x2F;bin&#x2F;sh<p>merge_commit=$(git log -n1 --merges --pretty=format:&quot;%H&quot; $(git rev-list --ancestry-path $1..HEAD --merges -n1))<p>git show -m -p --stat --format=&quot;&quot; $merge_commit</div><br/></div></div><div id="40754450" class="c"><input type="checkbox" id="c-40754450" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754323">parent</a><span>|</span><a href="#40755219">prev</a><span>|</span><a href="#40754373">next</a><span>|</span><label class="collapse" for="c-40754450">[-]</label><label class="expand" for="c-40754450">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How many years have you worked in the software industry?<p>Professionally, 21 years. Seems like you&#x27;re implying that someone with an opinion that is different than your own is not experienced.</div><br/><div id="40754509" class="c"><input type="checkbox" id="c-40754509" checked=""/><div class="controls bullet"><span class="by">tkiolp4</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754450">parent</a><span>|</span><a href="#40754373">next</a><span>|</span><label class="collapse" for="c-40754509">[-]</label><label class="expand" for="c-40754509">[1 more]</label></div><br/><div class="children"><div class="content">I deleted that part because it sounded the wrong way (it wasn’t my intention to question your experience, but a genuine curiosity)</div><br/></div></div></div></div></div></div><div id="40758493" class="c"><input type="checkbox" id="c-40758493" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40754323">prev</a><span>|</span><a href="#40759750">next</a><span>|</span><label class="collapse" for="c-40758493">[-]</label><label class="expand" for="c-40758493">[1 more]</label></div><br/><div class="children"><div class="content">Atomic commits are also really nice for when some stealthy tricky bug appears and you need to git bisect to find out where it was introduced. Ending up with &#x27;the bug got introduced somewhere in this massive commit that touches nearly every part of the system&#x27; is not very helpful.</div><br/></div></div><div id="40759750" class="c"><input type="checkbox" id="c-40759750" checked=""/><div class="controls bullet"><span class="by">zikohh</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40758493">prev</a><span>|</span><a href="#40754354">next</a><span>|</span><label class="collapse" for="c-40759750">[-]</label><label class="expand" for="c-40759750">[1 more]</label></div><br/><div class="children"><div class="content">I agree 100%. I also like using FF only. Reviewing commits is part of the code review process - their to title, description and code. If the commits are not atomic and clear I don&#x27;t approve the merge request (MR); I believe the MR is a full snapshot of what will go to main.<p>It&#x27;s so frustrating to see 7 commits for one MR and it&#x27;s a 10 line change.</div><br/></div></div><div id="40754354" class="c"><input type="checkbox" id="c-40754354" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40759750">prev</a><span>|</span><a href="#40761583">next</a><span>|</span><label class="collapse" for="c-40754354">[-]</label><label class="expand" for="c-40754354">[12 more]</label></div><br/><div class="children"><div class="content">What do you do with the commits that are “incomplete”?<p>I frequently get halfway through building something, but the. A more urgent project comes up and i need to commit my half-done non-functional work so I can hop onto a different branch</div><br/><div id="40762883" class="c"><input type="checkbox" id="c-40762883" checked=""/><div class="controls bullet"><span class="by">kcrwfrd_</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754354">parent</a><span>|</span><a href="#40763598">next</a><span>|</span><label class="collapse" for="c-40762883">[-]</label><label class="expand" for="c-40762883">[1 more]</label></div><br/><div class="children"><div class="content">I usually use stash for this stuff. But alternatively you can commit and then come back and squash &#x2F; rebase to clean up the commit history.</div><br/></div></div><div id="40763598" class="c"><input type="checkbox" id="c-40763598" checked=""/><div class="controls bullet"><span class="by">ngai_aku</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754354">parent</a><span>|</span><a href="#40762883">prev</a><span>|</span><a href="#40754490">next</a><span>|</span><label class="collapse" for="c-40763598">[-]</label><label class="expand" for="c-40763598">[1 more]</label></div><br/><div class="children"><div class="content">Are you familiar with working trees[1]? It may be a nice thing to utilize if you’re frequently jumping around on different branches.<p>[1] <a href="https:&#x2F;&#x2F;www.git-scm.com&#x2F;docs&#x2F;git-worktree" rel="nofollow">https:&#x2F;&#x2F;www.git-scm.com&#x2F;docs&#x2F;git-worktree</a></div><br/></div></div><div id="40754490" class="c"><input type="checkbox" id="c-40754490" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754354">parent</a><span>|</span><a href="#40763598">prev</a><span>|</span><a href="#40754654">next</a><span>|</span><label class="collapse" for="c-40754490">[-]</label><label class="expand" for="c-40754490">[1 more]</label></div><br/><div class="children"><div class="content">I create &quot;WIP&quot; commits, and then I squash those. I squash intentionally to clean up commits that should be together.</div><br/></div></div><div id="40754654" class="c"><input type="checkbox" id="c-40754654" checked=""/><div class="controls bullet"><span class="by">kutenai</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754354">parent</a><span>|</span><a href="#40754490">prev</a><span>|</span><a href="#40754419">next</a><span>|</span><label class="collapse" for="c-40754654">[-]</label><label class="expand" for="c-40754654">[1 more]</label></div><br/><div class="children"><div class="content">I take all &quot;WIP&quot; branches and rebase them as  needed onto the &#x27;latest&#x27; development. Any continued work on those branches will have to be compatible with all released code, so deal with any issues -- i.e. merge issues during a rebase -- now, rather than later when you try and submit a PR.<p>As a team leader, I prefer to avoid &quot;a lot of&quot; WIP branches, but I just expect developers to rebase their WIP onto dev, etc.<p>Oh, and I really really dislike &quot;merging&quot; develop into the WIP branch. This accomplishes the same thing as &quot;rebasing&quot; the WIP branch onto develop, but it leaves a horrible mess behind.<p>Frankly, I don&#x27; give a hoot about some &quot;history&quot; of work. In the end, I care about the unit of work encapsulated in that WIP branch, and that unit must always add on top of develop. Rebase just makes that super clear.</div><br/></div></div><div id="40754411" class="c"><input type="checkbox" id="c-40754411" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754354">parent</a><span>|</span><a href="#40754419">prev</a><span>|</span><a href="#40761583">next</a><span>|</span><label class="collapse" for="c-40754411">[-]</label><label class="expand" for="c-40754411">[6 more]</label></div><br/><div class="children"><div class="content">I stash half-baked work to keep it separate from quality commits. When I come back to the stash, I may or may not like where it was going and decide to build on it.</div><br/><div id="40755516" class="c"><input type="checkbox" id="c-40755516" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40754411">parent</a><span>|</span><a href="#40761583">next</a><span>|</span><label class="collapse" for="c-40755516">[-]</label><label class="expand" for="c-40755516">[5 more]</label></div><br/><div class="children"><div class="content">Stashing always makes me nervous.<p>For some reason it feels ephemeral and I worry that I’ll lose the stashed changes like when you accidentally overwrote the copy&#x2F;paste clipboard</div><br/><div id="40764803" class="c"><input type="checkbox" id="c-40764803" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40755516">parent</a><span>|</span><a href="#40762296">next</a><span>|</span><label class="collapse" for="c-40764803">[-]</label><label class="expand" for="c-40764803">[1 more]</label></div><br/><div class="children"><div class="content">Git stash is indeed more dangerous than branching. Stashes don’t go into the reflog, and so you lose the primary safety net that git offers. I’ve watched people get into a bad state with stash and end up losing work. The stash documentation says “If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more: &lt;git fsck ...&gt;” <a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-stash" rel="nofollow">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-stash</a><p>I know stash feels easier to a lot of people, and that’s a valid reason, but it’s really no more typing or thinking to use branches instead, it just might require changing habits.</div><br/></div></div><div id="40762296" class="c"><input type="checkbox" id="c-40762296" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40755516">parent</a><span>|</span><a href="#40764803">prev</a><span>|</span><a href="#40761625">next</a><span>|</span><label class="collapse" for="c-40762296">[-]</label><label class="expand" for="c-40762296">[1 more]</label></div><br/><div class="children"><div class="content">Committing everything to a new (temporary) branch, and returning to your current branch, costs nothing and saves the headache of stash&#x27;s weirdness.</div><br/></div></div><div id="40761625" class="c"><input type="checkbox" id="c-40761625" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40755516">parent</a><span>|</span><a href="#40762296">prev</a><span>|</span><a href="#40759499">next</a><span>|</span><label class="collapse" for="c-40761625">[-]</label><label class="expand" for="c-40761625">[1 more]</label></div><br/><div class="children"><div class="content">I used to feel this way because I lost work to `git stash pop` in the past, but there is now a nice feature where if you `git stash pop` and it doesn&#x27;t cleanly applies, git keeps the stash and I use it more often now.<p>That said for me the stash is usually used either for temporary stuff (eg taking my current work to another branch) or for things that might be useful to reference later but I will rewrite differently anyways; stuff I want to keep goes into a WIP commit.</div><br/></div></div><div id="40759499" class="c"><input type="checkbox" id="c-40759499" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754250">root</a><span>|</span><a href="#40755516">parent</a><span>|</span><a href="#40761625">prev</a><span>|</span><a href="#40761583">next</a><span>|</span><label class="collapse" for="c-40759499">[-]</label><label class="expand" for="c-40759499">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I generally don&#x27;t use it much, because it forces me to remember that I have stashed work.</div><br/></div></div></div></div></div></div></div></div><div id="40761583" class="c"><input type="checkbox" id="c-40761583" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40754354">prev</a><span>|</span><a href="#40763191">next</a><span>|</span><label class="collapse" for="c-40761583">[-]</label><label class="expand" for="c-40761583">[1 more]</label></div><br/><div class="children"><div class="content">I generally prefer PRs that have multiple atomic commits to be split up in separate PRs. If the atomic commits can&#x27;t be reviewed separately&#x2F;introduce non-working states, they are probably too small.<p>&gt; One rule I have for any rebasing is, when there may be more than one person using the branch, no more rebasing that branch.<p>That is the one rule to obey for rebasing to be useable at all.</div><br/></div></div><div id="40763191" class="c"><input type="checkbox" id="c-40763191" checked=""/><div class="controls bullet"><span class="by">arwhatever</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40761583">prev</a><span>|</span><a href="#40761272">next</a><span>|</span><label class="collapse" for="c-40763191">[-]</label><label class="expand" for="c-40763191">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One rule I have for any rebasing is, when there may be more than one person using the branch, no more rebasing that branch.<p>Is it just me, or is it genuinely funny that whenever someone does this I think of Deep Thoughts by Jack Handey: “When you&#x27;re going up the stairs and you take a step, kick the other leg up high behind you to keep people from following too close.”</div><br/></div></div><div id="40761272" class="c"><input type="checkbox" id="c-40761272" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#40754250">parent</a><span>|</span><a href="#40763191">prev</a><span>|</span><a href="#40756521">next</a><span>|</span><label class="collapse" for="c-40761272">[-]</label><label class="expand" for="c-40761272">[1 more]</label></div><br/><div class="children"><div class="content">Branches should be small enough and short lived enough that they are atomic commits. Merge early, merge often, don&#x27;t break things. Work on small pieces that don&#x27;t change functionality, 
The missing part of this is that this causes you to need merge-trains earlier - You&#x27;ll want to start &quot;stacked&quot; commits that are based on the pieces that are atomic but not merged. That sucks, because the tooling isn&#x27;t yet great at handling that - It should be possible to mark and auto-rebase all your local branches in that dependency chain,</div><br/></div></div></div></div><div id="40756521" class="c"><input type="checkbox" id="c-40756521" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40754250">prev</a><span>|</span><a href="#40765775">next</a><span>|</span><label class="collapse" for="c-40756521">[-]</label><label class="expand" for="c-40756521">[2 more]</label></div><br/><div class="children"><div class="content">Everyone&#x27;s got an opinion on &quot;rebase&quot;, and IMO you can safely ignore those that conflate:<p>* the rebase command, as a means of adjusting commits<p>* the practice of squashing all commits into a single commit (typically, but not always, via rebase)<p>* the &quot;rewriting of history&quot;, whether on public or private branches<p>* rebasing on merge vs. creating a merge commit<p>This article starts by saying they &quot;like rebasing&quot; only to then say<p>&gt;Git rebase allows me to squash my disordered commits into a neat little one<p>Rebase allows this practice but you could just as easily `git reset @~` a few times and then `git add .; git commit -m &quot;My big commit&quot;`. Alternatively the author could just `git add .; git commit --amend --no-edit` throughout the task and end up with the same result. To be fair to the author, they later add that they don&#x27;t always squash to a single commit, but here I&#x27;m talking about &quot;rebasing&quot; vs. commit practices. Rebase is just a tool which allows various practices and it&#x27;s tiresome seeing the same arguments against this nebulous &quot;rebase&quot;, when the arguments are actually directed at practices.</div><br/><div id="40764329" class="c"><input type="checkbox" id="c-40764329" checked=""/><div class="controls bullet"><span class="by">taftster</span><span>|</span><a href="#40756521">parent</a><span>|</span><a href="#40765775">next</a><span>|</span><label class="collapse" for="c-40764329">[-]</label><label class="expand" for="c-40764329">[1 more]</label></div><br/><div class="children"><div class="content">I really appreciate the distinction you&#x27;re making here. That is, rebase itself is not necessarily either the hero or bane of the process. There are several ways to the &quot;squash my disordered commits&quot; problem, which you&#x27;ve described nicely.<p>I personally use rebase similar to the author, to squash all my noise down to my final intention. But this could be achieved in other ways, just the same.</div><br/></div></div></div></div><div id="40765775" class="c"><input type="checkbox" id="c-40765775" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#40756521">prev</a><span>|</span><a href="#40765742">next</a><span>|</span><label class="collapse" for="c-40765775">[-]</label><label class="expand" for="c-40765775">[1 more]</label></div><br/><div class="children"><div class="content">It’s interesting how much devs - including me! - care about git history, yet rarely do we use it in a way that makes the rebase-merge-squash differences meaningful.<p>Usually I just look at the file history, find the work item from the commit message and then understand _why_ the code is the way it is. That is the functionality I need to have in mind when changing the file. Who cares how it came to be?</div><br/></div></div><div id="40765742" class="c"><input type="checkbox" id="c-40765742" checked=""/><div class="controls bullet"><span class="by">PUSH_AX</span><span>|</span><a href="#40765775">prev</a><span>|</span><a href="#40764514">next</a><span>|</span><label class="collapse" for="c-40765742">[-]</label><label class="expand" for="c-40765742">[2 more]</label></div><br/><div class="children"><div class="content">I haven’t found meaningful use for history in years. Neither has anyone on any of the teams I’ve worked on. Nitpicking git practices really feels like a waste of time. Pick something that works and roll with it.</div><br/><div id="40765797" class="c"><input type="checkbox" id="c-40765797" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#40765742">parent</a><span>|</span><a href="#40764514">next</a><span>|</span><label class="collapse" for="c-40765797">[-]</label><label class="expand" for="c-40765797">[1 more]</label></div><br/><div class="children"><div class="content">I regularly look up the git blame on lines of code; I’m hoping to get anything from “documentation” on magic numbers, to seeing what else that line went with, although usually to find out who to go ask when I find a WTF.<p>Before I started regularly looking up that ‘blame’, I also didn’t care too much about got history. Now, I put some effort into making my own history useful to everyone (including future me).</div><br/></div></div></div></div><div id="40764514" class="c"><input type="checkbox" id="c-40764514" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#40765742">prev</a><span>|</span><a href="#40754036">next</a><span>|</span><label class="collapse" for="c-40764514">[-]</label><label class="expand" for="c-40764514">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty weak defense of rebase. It almost seems like an attempt to promote the opposite. To &quot;squash my disordered commits into a neat little one&quot; is like <i>the only</i> bad and questionable practice involving the word &quot;rebase&quot; which people can rightfully object to. And rejecting that they will usually (unjustly) reject a dozen of other practices involving &quot;rebase&quot;. &quot;rebase&quot; does not equal &quot;squash&quot;. Using &quot;squash&quot; checkbox in Gitlab is not synonymous to &quot;rebasing&quot;.<p>If you actually care about organizing you disordered commits, you can do it in a sane way and use git rebase -i master. That&#x27;s basically how I work all the time, I don&#x27;t even try to write meaningful commits first, I even commit stuff I know I must drop later and I commit every little incremental change file-by-file (to make re-ordering commits easier). Then I&#x27;ll rebase them interactively to review what I did and make several (most of the time) clean atomic commits.<p>Then, rebase is simply superior to making merge commits all over the place, because it... well, &quot;does nothing&quot; as opposed to &quot;makes your commit tree into a complete mess&quot;. There <i>can</i> be reasons why you would rather not bother rebasing on a particular project, but if you <i>don&#x27;t</i> have them (i.e. you just don&#x27;t have a strong justifiable opinion on that matter), just set [pull] rebase = true, and use git merge --ff whenever possible. Most of the time it doesn&#x27;t even feel any different and <i>just works</i>.</div><br/></div></div><div id="40754036" class="c"><input type="checkbox" id="c-40754036" checked=""/><div class="controls bullet"><span class="by">quibono</span><span>|</span><a href="#40764514">prev</a><span>|</span><a href="#40754049">next</a><span>|</span><label class="collapse" for="c-40754036">[-]</label><label class="expand" for="c-40754036">[7 more]</label></div><br/><div class="children"><div class="content">Personally I am squarely in the rebase team although I&#x27;m not completely anti-merge. I find the interactive rebase to be so useful that I pretty much never rebase non-interactively.
I wonder if part of the reason the merge flow is more popular (or at least it seems more popular) is because native Git tooling around rebasing isn&#x27;t the best. In fact doing anything more than the simple reword&#x2F;squash&#x2F;reorder (like commit splitting or moving chunks between commits) is abysmal.
Magit really shines here and makes it a breeze.</div><br/><div id="40754188" class="c"><input type="checkbox" id="c-40754188" checked=""/><div class="controls bullet"><span class="by">sjburt</span><span>|</span><a href="#40754036">parent</a><span>|</span><a href="#40754065">next</a><span>|</span><label class="collapse" for="c-40754188">[-]</label><label class="expand" for="c-40754188">[1 more]</label></div><br/><div class="children"><div class="content">The main issue is that on a longer branch, you have to fix all the rebase conflicts on the oldest commit. Then, if you changed something in the conflict zone, you fix it again on the next commit, because the next commit used to be based on something else. Sometimes git rerere can help with this, but I find it fairly unreliable (could be user error!) If you do a merge, you only need to resolve it all once.<p>Otherwise I tend to prefer rebase.</div><br/></div></div><div id="40754065" class="c"><input type="checkbox" id="c-40754065" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#40754036">parent</a><span>|</span><a href="#40754188">prev</a><span>|</span><a href="#40754049">next</a><span>|</span><label class="collapse" for="c-40754065">[-]</label><label class="expand" for="c-40754065">[5 more]</label></div><br/><div class="children"><div class="content">I think Git&#x27;s roots show in its lack of DX. But I&#x27;ll take it over the horror that was SVN and prior tooling.<p>Question: how does Magit compare to GitUp? The latter is my benchmark for complex rebases, but I&#x27;d love to know if I&#x27;m stuck in a local optima.</div><br/><div id="40754137" class="c"><input type="checkbox" id="c-40754137" checked=""/><div class="controls bullet"><span class="by">quibono</span><span>|</span><a href="#40754036">root</a><span>|</span><a href="#40754065">parent</a><span>|</span><a href="#40763538">next</a><span>|</span><label class="collapse" for="c-40754137">[-]</label><label class="expand" for="c-40754137">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not used GitUp so I&#x27;m not sure how much help this will be to you since I can&#x27;t objectively compare the two.
As an example, let&#x27;s say I want to remove some changes from a commit (and potentially move those into one or more different commits). If I go into the commit and select the chunks I want to revert, I can click `u` and right away I get the revert chunk added into my staging area AND the original chunk added to my working tree. Then I just fix-up the original commit (c F) to remove the unwanted change, and commit the original change - either in a few different commits or possibly just one.</div><br/></div></div><div id="40763538" class="c"><input type="checkbox" id="c-40763538" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40754036">root</a><span>|</span><a href="#40754065">parent</a><span>|</span><a href="#40754137">prev</a><span>|</span><a href="#40754079">next</a><span>|</span><label class="collapse" for="c-40763538">[-]</label><label class="expand" for="c-40763538">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think Git&#x27;s roots show in its lack of DX. But I&#x27;ll take it over the horror that was SVN and prior tooling.<p>This statement really confuses me. SVN was <i>so much</i> easier to use than git. It was incredibly straightforward: make changes, commit, done.</div><br/><div id="40765365" class="c"><input type="checkbox" id="c-40765365" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40754036">root</a><span>|</span><a href="#40763538">parent</a><span>|</span><a href="#40754079">next</a><span>|</span><label class="collapse" for="c-40765365">[-]</label><label class="expand" for="c-40765365">[1 more]</label></div><br/><div class="children"><div class="content">Merging branches was roughly the equivalent of git cherry-pick.  There&#x27;s tracking to prevent you from pulling the same commit twice, but not much else.<p>--reintegrate was introduced later, and even with that it was easy to get wrong.</div><br/></div></div></div></div><div id="40754079" class="c"><input type="checkbox" id="c-40754079" checked=""/><div class="controls bullet"><span class="by">joshuanapoli</span><span>|</span><a href="#40754036">root</a><span>|</span><a href="#40754065">parent</a><span>|</span><a href="#40763538">prev</a><span>|</span><a href="#40754049">next</a><span>|</span><label class="collapse" for="c-40754079">[-]</label><label class="expand" for="c-40754079">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used Magit or GitUp, but I really appreciate JetBrains IDE automatic conflict resolver.</div><br/></div></div></div></div></div></div><div id="40754049" class="c"><input type="checkbox" id="c-40754049" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#40754036">prev</a><span>|</span><a href="#40754085">next</a><span>|</span><label class="collapse" for="c-40754049">[-]</label><label class="expand" for="c-40754049">[12 more]</label></div><br/><div class="children"><div class="content">I had a colleague (smart guy, lots of impressive Ivy League creds after his name) who just _insisted_ that rebasing was evil. There was simply no way to communicate that:<p>- I can rebase all I want in my own private repo<p>- Rebasing is fine if no one else thinks they can depend on your branch&#x27;s history<p>- You obviously don&#x27;t rebase master (!) or a branch that you&#x27;ll collaborate on (not without proper warning at least).<p>I&#x27;ve seen this attitude more than a few times, and I think it&#x27;s fear born of ignorance. I just don&#x27;t get the inability to consider a different perspective.<p>Edit: formatting.</div><br/><div id="40754265" class="c"><input type="checkbox" id="c-40754265" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754049">parent</a><span>|</span><a href="#40754359">next</a><span>|</span><label class="collapse" for="c-40754265">[-]</label><label class="expand" for="c-40754265">[5 more]</label></div><br/><div class="children"><div class="content">Not only ignorance.  I don&#x27;t generally use rebase myself.  This is after having some experience with it.  I recently had to help a junior un-wedge his local repo after an attempted rebase went haywire.  I reset to the previous commit and replaced the rebase with a merge.  The rest of the lifetime of the branch was uneventful.  The problems happened because rebasing changes the identity of commits.  When merging <i>that</i> result, commits that have previously been merged create conflicts as they now need to be re-merged under the alias of a different commit hash.<p>If rebasing works for you, I&#x27;m not going to try to sell you something.  But there are other ways.</div><br/><div id="40763070" class="c"><input type="checkbox" id="c-40763070" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40754049">root</a><span>|</span><a href="#40754265">parent</a><span>|</span><a href="#40754359">next</a><span>|</span><label class="collapse" for="c-40763070">[-]</label><label class="expand" for="c-40763070">[4 more]</label></div><br/><div class="children"><div class="content">`git reflog`</div><br/><div id="40763636" class="c"><input type="checkbox" id="c-40763636" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754049">root</a><span>|</span><a href="#40763070">parent</a><span>|</span><a href="#40754359">next</a><span>|</span><label class="collapse" for="c-40763636">[-]</label><label class="expand" for="c-40763636">[3 more]</label></div><br/><div class="children"><div class="content">I use this regularly. Mostly to answer one question. What was the name of that branch I was working on yesterday?<p>Or maybe you&#x27;re suggesting it as a way to unravel a screwed up rebase.  I don&#x27;t know how to do that. But luckily I do know to abort, reset, and merge.</div><br/><div id="40763874" class="c"><input type="checkbox" id="c-40763874" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40754049">root</a><span>|</span><a href="#40763636">parent</a><span>|</span><a href="#40754359">next</a><span>|</span><label class="collapse" for="c-40763874">[-]</label><label class="expand" for="c-40763874">[2 more]</label></div><br/><div class="children"><div class="content">Yes, you can recover from a screwed up rebase or virtually any git problem you created via git commands. You find the commit before you rebased and reset to it. One reference: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;134882&#x2F;undoing-a-git-rebase" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;134882&#x2F;undoing-a-git-reb...</a></div><br/><div id="40764209" class="c"><input type="checkbox" id="c-40764209" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754049">root</a><span>|</span><a href="#40763874">parent</a><span>|</span><a href="#40754359">next</a><span>|</span><label class="collapse" for="c-40764209">[-]</label><label class="expand" for="c-40764209">[1 more]</label></div><br/><div class="children"><div class="content">Yes.  That&#x27;s literally what I did.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40754359" class="c"><input type="checkbox" id="c-40754359" checked=""/><div class="controls bullet"><span class="by">latentsea</span><span>|</span><a href="#40754049">parent</a><span>|</span><a href="#40754265">prev</a><span>|</span><a href="#40763118">next</a><span>|</span><label class="collapse" for="c-40754359">[-]</label><label class="expand" for="c-40754359">[1 more]</label></div><br/><div class="children"><div class="content">As someone in the &quot;merge-only&quot; camp, for me it simply boils down to I don&#x27;t think rebasing solves anything I view as a problem and as such I just don&#x27;t care to know anything about it. You can rebase if you want, but don&#x27;t bother trying to talk to me about it.</div><br/></div></div><div id="40763118" class="c"><input type="checkbox" id="c-40763118" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40754049">parent</a><span>|</span><a href="#40754359">prev</a><span>|</span><a href="#40764931">next</a><span>|</span><label class="collapse" for="c-40763118">[-]</label><label class="expand" for="c-40763118">[1 more]</label></div><br/><div class="children"><div class="content">Smart people with strong opinions. What can you do.<p>I&#x27;ve come from a merge workflow into a rebase (git + gerrit) workflow in a huge software project with hundreds of people. Rebase workflows are fine. Merge workflows can be fine.<p>Personal preferences + the way you&#x27;re used to doing things.<p>There&#x27;s some advantages to being able to see how conflicts were resolved when you&#x27;re looking for something that went wrong but if you have code reviews and tests then the probability of needing that in a rebase workflow is smaller. In a large team &quot;how we got to a change&quot; is IMO less interesting than &quot;this is the change&quot;.<p>Have seen occasional breaks from things that were incorrectly rebased (generally from auto-rebase situations), but those are rare enough and easy to address. Same things can happen with merges.<p>An IMO much larger question is branching strategy. Normally if you&#x27;re following a rebase workflow you&#x27;re doing trunk based development. Many teams that use a merge workflow use feature branches. If you use feature branches you&#x27;re pushed towards merge workflows. That&#x27;s a bigger debate maybe (and I&#x27;d vote for trunk based).</div><br/></div></div><div id="40764931" class="c"><input type="checkbox" id="c-40764931" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40754049">parent</a><span>|</span><a href="#40763118">prev</a><span>|</span><a href="#40762975">next</a><span>|</span><label class="collapse" for="c-40764931">[-]</label><label class="expand" for="c-40764931">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I had a colleague (smart guy, lots of impressive Ivy League creds after his name) who just _insisted_ that rebasing was evil.<p>There is an historical reason for this. It is a hyperbolic marketing point of view invented by Richard Hipp, the author of SQLite, and of Fossil, in order to try to sell Fossil as being superior to Git. “Rebase is a lie” has been a meme ever since he published an article titled “Rebase Considered Harmful”, which has been posted to HN many times. Because he has contributed a lot to open source software development and because SQLite is so widely used, a lot of people respect everything he says and so this unfortunate idea has spread and gets repeated, even by otherwise very smart people.<p>Dr. Hipp has made appearances on HN arguing that rebase is bad, and even told me it should be likened to criminal activity. (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29133188">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29133188</a>) The Fossil documentation still has remnants of it, but it has been softened over the years.<p>Luckily it seems to be dying, and I think the Fossil team might be coming around to the realization that this negative attack smear hyperbole is ultimately not helping Fossil grow. This is the primary sticking point for me and the reason I won’t use Fossil. I’m actually quite interested in trying it, but not until the (ironically) dishonest claims about Git and it’s goals are taken down.</div><br/><div id="40765293" class="c"><input type="checkbox" id="c-40765293" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40754049">root</a><span>|</span><a href="#40764931">parent</a><span>|</span><a href="#40762975">next</a><span>|</span><label class="collapse" for="c-40765293">[-]</label><label class="expand" for="c-40765293">[1 more]</label></div><br/><div class="children"><div class="content">&gt;[From the linked HN comment] To erase an entry in the financial ledger of a company is fraud. It is a felony. [..] I believe that VCSes should be treated similarly. [..] once you check-in the change - it then becomes part of the permanent record. To alter that transaction after the fact is akin to felony fraud.<p>Yikes. To give a charitable interpretation, that&#x27;s quite an extreme view. Financial ledgers and VCS histories are not equal and they serve different purposes; the primary purpose of VCS history being to aid in the understanding of the current state of the codebase. In some cases, the &quot;true&quot; activity may provide that understanding, and in others, it may hinder it. Squashing a PR-requested change like &quot;rename new variable based on PR feedback&quot; seems sensible as it reduces noise in the history - definitely not what I&#x27;d call fraudulent. To me commits are like documentation and I see no reason why I shouldn&#x27;t be able to refine that documentation if I think I can improve it for a future reader.</div><br/></div></div></div></div><div id="40762975" class="c"><input type="checkbox" id="c-40762975" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#40754049">parent</a><span>|</span><a href="#40764931">prev</a><span>|</span><a href="#40754085">next</a><span>|</span><label class="collapse" for="c-40762975">[-]</label><label class="expand" for="c-40762975">[2 more]</label></div><br/><div class="children"><div class="content">You <i>can</i> rebase, but you&#x27;re still:<p>- Creating a false history that will be harder for you to understand in the future<p>- Creating a history that tools will have a harder time dealing with in the future<p>- Doing so for no actual benefit (in 99% of cases)</div><br/><div id="40763429" class="c"><input type="checkbox" id="c-40763429" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40754049">root</a><span>|</span><a href="#40762975">parent</a><span>|</span><a href="#40754085">next</a><span>|</span><label class="collapse" for="c-40763429">[-]</label><label class="expand" for="c-40763429">[1 more]</label></div><br/><div class="children"><div class="content">I ranted about this in another comment in this thread, but what do you mean by rebase here? Reworking commits? Squashing commits?</div><br/></div></div></div></div></div></div><div id="40754085" class="c"><input type="checkbox" id="c-40754085" checked=""/><div class="controls bullet"><span class="by">fleekonpoint</span><span>|</span><a href="#40754049">prev</a><span>|</span><a href="#40759035">next</a><span>|</span><label class="collapse" for="c-40754085">[-]</label><label class="expand" for="c-40754085">[2 more]</label></div><br/><div class="children"><div class="content">I also like rebasing. Sometimes my squashing cannot be completed without manual intervention, so I&#x27;ll do a squash merge into a temporary branch instead:<p><pre><code>   git checkout main
   git checkout -b squash-branch 
   git merge --squash [branch-to-rebase]
</code></pre>
At this point I usually git diff the two branches as a sanity check before merging back into main:<p><pre><code>    git diff [branch-to-rebase]
    git checkout main
    git merge squash-branch
</code></pre>
I am normally able to squash rebase 99% of the time using git rebase -i main, but doing a git merge --squash into a temp branch has saved me a lot of hassle over the years.</div><br/></div></div><div id="40759035" class="c"><input type="checkbox" id="c-40759035" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#40754085">prev</a><span>|</span><a href="#40765134">next</a><span>|</span><label class="collapse" for="c-40759035">[-]</label><label class="expand" for="c-40759035">[8 more]</label></div><br/><div class="children"><div class="content">The problem with rebase is it creates a lot of friction when sharing with others. Even if a single dev has two checkouts, it can get confusing (&quot;can I just pull the changes or do I need to reset the branch? - dammit what did I do again? I guess I&#x27;ll have to review both checkouts history in detail&quot;).  Merge based git push &#x2F; git pull in the other hand, have none of this, thus conceptually much simpler.<p>Furthermore, since pushes must necessarily overwrite (--force), you actually risk loosing work.<p>This is all fine and doable but you have to be &quot;on the ball&quot; &#x2F; paying close attention all the time thus introducing higher cognitive load.<p>The bottom line is getting work done and making history look good are competing objectives to some extent. There are all kinds of reasons to commit code (I got something working, I want to share something, I need to try this on another machine, etc.). Thus, the only way for commits to appear logical &#x2F; atomic is to review the current state and refactor it to a logical looking but artificial series of commits. I can&#x27;t imagine such efforts being useful enough to actually do in most cases. Perhaps even a task better suited to AI.<p>In reality, the PR is the only commit that anyone cares about. Everything else is mostly just noise. Therefore it would be best if the PR  was a first class concept in git vs something only available outside of it (i.e. github).</div><br/><div id="40759152" class="c"><input type="checkbox" id="c-40759152" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#40759035">parent</a><span>|</span><a href="#40759140">next</a><span>|</span><label class="collapse" for="c-40759152">[-]</label><label class="expand" for="c-40759152">[5 more]</label></div><br/><div class="children"><div class="content">Two rules of rebasing that I follow strictly:<p>1. Never rebase a shared branch
2. Never break rule 1</div><br/><div id="40759758" class="c"><input type="checkbox" id="c-40759758" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40759035">root</a><span>|</span><a href="#40759152">parent</a><span>|</span><a href="#40760041">next</a><span>|</span><label class="collapse" for="c-40759758">[-]</label><label class="expand" for="c-40759758">[2 more]</label></div><br/><div class="children"><div class="content">Always rebase and  push --force.
Devs who cannot pull --rebase or reset --hard to latest should quit their jobs, and stop whining.</div><br/><div id="40759992" class="c"><input type="checkbox" id="c-40759992" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#40759035">root</a><span>|</span><a href="#40759758">parent</a><span>|</span><a href="#40760041">next</a><span>|</span><label class="collapse" for="c-40759992">[-]</label><label class="expand" for="c-40759992">[1 more]</label></div><br/><div class="children"><div class="content">True Scotsman. Does it or does it not increase cognitive load?</div><br/></div></div></div></div><div id="40760041" class="c"><input type="checkbox" id="c-40760041" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#40759035">root</a><span>|</span><a href="#40759152">parent</a><span>|</span><a href="#40759758">prev</a><span>|</span><a href="#40759140">next</a><span>|</span><label class="collapse" for="c-40760041">[-]</label><label class="expand" for="c-40760041">[2 more]</label></div><br/><div class="children"><div class="content">What is your definition of a shared branch? Is it shared the moment you push it (assuming a github like workflow). Is it shared if you check it out on two separate machines just for yourself?</div><br/><div id="40760516" class="c"><input type="checkbox" id="c-40760516" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#40759035">root</a><span>|</span><a href="#40760041">parent</a><span>|</span><a href="#40759140">next</a><span>|</span><label class="collapse" for="c-40760516">[-]</label><label class="expand" for="c-40760516">[1 more]</label></div><br/><div class="children"><div class="content">My definition of a shared branch is the one where only one person is working. It can be your local branch and the same one after you push it to remote. It&#x27;s still not shared in the sense that only 1 person is supposed to work on that branch.<p>In this case, you can easily perform rebase and run `git push origin HEAD --force-with-lease` without causing any headache for anyone else.</div><br/></div></div></div></div></div></div><div id="40759140" class="c"><input type="checkbox" id="c-40759140" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40759035">parent</a><span>|</span><a href="#40759152">prev</a><span>|</span><a href="#40765134">next</a><span>|</span><label class="collapse" for="c-40759140">[-]</label><label class="expand" for="c-40759140">[2 more]</label></div><br/><div class="children"><div class="content">Always use --force-with-lease.</div><br/><div id="40759174" class="c"><input type="checkbox" id="c-40759174" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#40759035">root</a><span>|</span><a href="#40759140">parent</a><span>|</span><a href="#40765134">next</a><span>|</span><label class="collapse" for="c-40759174">[-]</label><label class="expand" for="c-40759174">[1 more]</label></div><br/><div class="children"><div class="content">This will only save you if you haven&#x27;t taken a pull right before pushing your changes to the remote branch. I almost always do this:<p>```
git pull --rebase main
```<p>And then push the changes with `git push origin HEAD`. Pushing with `--force-with-rebase` won&#x27;t save me from this.<p>I usually never rebase a shared branch.</div><br/></div></div></div></div></div></div><div id="40765134" class="c"><input type="checkbox" id="c-40765134" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#40759035">prev</a><span>|</span><a href="#40754097">next</a><span>|</span><label class="collapse" for="c-40765134">[-]</label><label class="expand" for="c-40765134">[1 more]</label></div><br/><div class="children"><div class="content">I look forward to the day that I can run a local LLM (for confidentiality reasons) to automatically reorganize commits within my PR. Should be very safe compared to generating code or merging&#x2F;rebasing other code since it is just changing the grouping of commits and the final code should be unchanged.<p>This would free up developers to spend more time solving problems for the business instead of tidying up code.<p>Could also delay doing this to when somebody is trying to understand the code (during review or later) or doing a bisect.</div><br/></div></div><div id="40754097" class="c"><input type="checkbox" id="c-40754097" checked=""/><div class="controls bullet"><span class="by">elijahbenizzy</span><span>|</span><a href="#40765134">prev</a><span>|</span><a href="#40763119">next</a><span>|</span><label class="collapse" for="c-40754097">[-]</label><label class="expand" for="c-40754097">[3 more]</label></div><br/><div class="children"><div class="content">100% team rebase -- I think the fear comes from &quot;rewriting history&quot;, which sounds scary until you realize that git is entirely immutable data store (through the API at least). Blockchain for the win!<p>I find merging to be extremely tough to work with -- I don&#x27;t think I actually got <i>good</i> at git until I learned to rebase entirely.<p>Also, cherry-picking (effectively an atomic rebase-type) is underrated.</div><br/><div id="40754252" class="c"><input type="checkbox" id="c-40754252" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40754097">parent</a><span>|</span><a href="#40754314">next</a><span>|</span><label class="collapse" for="c-40754252">[-]</label><label class="expand" for="c-40754252">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; git is entirely immutable data store</i><p>Not entirely, since git can automatically garbage collect commits that aren&#x27;t reachable.</div><br/></div></div><div id="40754314" class="c"><input type="checkbox" id="c-40754314" checked=""/><div class="controls bullet"><span class="by">edfletcher_t137</span><span>|</span><a href="#40754097">parent</a><span>|</span><a href="#40754252">prev</a><span>|</span><a href="#40763119">next</a><span>|</span><label class="collapse" for="c-40754314">[-]</label><label class="expand" for="c-40754314">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find merging to be extremely tough to work with -- I don&#x27;t think I actually got good at git until I learned to rebase entirely.<p>&gt; Also, cherry-picking (effectively an atomic rebase-type) is underrated.<p>This this this, all of this.<p>I never really &quot;got git&quot; until I finally committed to learning how rebase works.<p>+1 to cherry-picking. Also patch-add (`add -p`).</div><br/></div></div></div></div><div id="40763119" class="c"><input type="checkbox" id="c-40763119" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#40754097">prev</a><span>|</span><a href="#40764861">next</a><span>|</span><label class="collapse" for="c-40763119">[-]</label><label class="expand" for="c-40763119">[1 more]</label></div><br/><div class="children"><div class="content">Our team switched over to Graphite [1] 8 months ago now. Graphite involves a lot of &quot;restacking&quot; (i.e., rebasing for every commit&#x2F;branch in a &quot;stack&quot;).<p>No one on our team had used rebasing extensively before this, but it&#x27;s hard to go back. Similar to the article, the benefits we see are:<p>- Fast iteration with `gt m` (`git commit --amend`) and `gt s` (`git push --force`)
- Using `gt restack` (`git rebase` on each parent commit) helps make merge conflicts more transparent in what happened
- Commit histories are much more legible<p>I highly recommend giving it a go.<p>[1] <a href="https:&#x2F;&#x2F;graphite.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;graphite.dev&#x2F;</a></div><br/></div></div><div id="40764861" class="c"><input type="checkbox" id="c-40764861" checked=""/><div class="controls bullet"><span class="by">micimize</span><span>|</span><a href="#40763119">prev</a><span>|</span><a href="#40759299">next</a><span>|</span><label class="collapse" for="c-40764861">[-]</label><label class="expand" for="c-40764861">[1 more]</label></div><br/><div class="children"><div class="content">Rebasing potentially allows for clean, clear documentation of changeset intent in a way that integrates easily with our existing tooling, at the expense of a potential footgun in highly collaborative scenarios. Ie, if someone forked off your branch or referenced a commit you might break a reference accidentally. So it can be nice, but really depends on the environment you&#x27;re working in.<p>Gerrit solves the referencing issue by using git notes and maintaining its own ID for changesets across rebases. Without such a system, some seeming benefits of the rebase workflow, like atomically reviewable stacked commits, become fairly awkward. IE, if we want to review commits themselves, but their references get clobbered due to a rebase, that&#x27;s no good (this was the case a few years ago with GH&#x27;s rebasing support, maybe improved since).<p>IMO, that we have to make the &quot;rebase or merge&quot; tradeoff at all, or accept the deep limitations of pure commit-based history, is fairly sub-optimal. It&#x27;d be nice if more tooling&#x2F;workflows were built more around notes. I envision someone&#x2F;some bot going back and annotatinb a range of commits with a note that associates them into some coherent code documentation system, or amends some faulty assertion, links artifacts, etc. That way blame could take us to salient docs or surface behavior snapshot gifs or w&#x2F;e. From directly within IDEs</div><br/></div></div><div id="40759299" class="c"><input type="checkbox" id="c-40759299" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#40764861">prev</a><span>|</span><a href="#40764872">next</a><span>|</span><label class="collapse" for="c-40759299">[-]</label><label class="expand" for="c-40759299">[7 more]</label></div><br/><div class="children"><div class="content">Enforce squash merging to main and move on with your life. Linear history on main, individual contributors can rebase and merge or format-patch or do whatever they want on their PR branches and it doesn’t matter. There are zero downsides to this approach.</div><br/><div id="40759439" class="c"><input type="checkbox" id="c-40759439" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#40759299">parent</a><span>|</span><a href="#40763450">next</a><span>|</span><label class="collapse" for="c-40759439">[-]</label><label class="expand" for="c-40759439">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Neither the rebase nor merge workflow negates the benefits of squash-merging to main.</div><br/></div></div><div id="40763450" class="c"><input type="checkbox" id="c-40763450" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40759299">parent</a><span>|</span><a href="#40759439">prev</a><span>|</span><a href="#40764872">next</a><span>|</span><label class="collapse" for="c-40763450">[-]</label><label class="expand" for="c-40763450">[5 more]</label></div><br/><div class="children"><div class="content">&gt;There are zero downsides to this approach.<p>Squash merge.. zero downsides.. hard to take you seriously.</div><br/><div id="40764276" class="c"><input type="checkbox" id="c-40764276" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#40759299">root</a><span>|</span><a href="#40763450">parent</a><span>|</span><a href="#40764872">next</a><span>|</span><label class="collapse" for="c-40764276">[-]</label><label class="expand" for="c-40764276">[4 more]</label></div><br/><div class="children"><div class="content">What are the downsides of enforcing squash-merge to main?</div><br/><div id="40764994" class="c"><input type="checkbox" id="c-40764994" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40759299">root</a><span>|</span><a href="#40764276">parent</a><span>|</span><a href="#40764739">next</a><span>|</span><label class="collapse" for="c-40764994">[-]</label><label class="expand" for="c-40764994">[1 more]</label></div><br/><div class="children"><div class="content">Losing granularity, obviously, no? Of course it depends on how big branches get before they’re squash-merged, but squashing can make things harder to bisect, harder to track independent semantic changes that overlap, harder to read comments &amp; history, harder to cherry-pick small fixes… lots of things. You don’t notice the downsides until you have to manage release branches or spelunk through the history to find bugs or figure out who wrote some line of code from long back.</div><br/></div></div><div id="40764739" class="c"><input type="checkbox" id="c-40764739" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40759299">root</a><span>|</span><a href="#40764276">parent</a><span>|</span><a href="#40764994">prev</a><span>|</span><a href="#40764848">next</a><span>|</span><label class="collapse" for="c-40764739">[-]</label><label class="expand" for="c-40764739">[1 more]</label></div><br/><div class="children"><div class="content">I use interactive rebase to construct a useful commit history that will communicate intent to future developers. Things like &quot;move a file first, refactor it in a separate commit&quot; make a huge difference when someone&#x27;s coming around to view the file history later, and a squash merge removes all that information that I&#x27;ve meticulously encoded in the commit history.<p>My preferred workflow on a team project is to have well-crafted commits with merge commits. The merge commits signify the wider intent and link back to the PR in GitHub, while the interactively rebased commits tell the story of the steps to get from point A to point B.</div><br/></div></div><div id="40764848" class="c"><input type="checkbox" id="c-40764848" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40759299">root</a><span>|</span><a href="#40764276">parent</a><span>|</span><a href="#40764739">prev</a><span>|</span><a href="#40764872">next</a><span>|</span><label class="collapse" for="c-40764848">[-]</label><label class="expand" for="c-40764848">[1 more]</label></div><br/><div class="children"><div class="content">Loss of utility of tools like git bisect, conventional commits, etc.<p>Git blame is less useful when what were individual commits associated with lines are instead rolled up into a massive commit, such that each affected line is now described by a more general commit.<p>It <i>can</i> encourage lazy developers to submit shit commit history in PRs knowing it&#x27;s going to be squashed anyway, making PR harder.</div><br/></div></div></div></div></div></div></div></div><div id="40764872" class="c"><input type="checkbox" id="c-40764872" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#40759299">prev</a><span>|</span><a href="#40764781">next</a><span>|</span><label class="collapse" for="c-40764872">[-]</label><label class="expand" for="c-40764872">[1 more]</label></div><br/><div class="children"><div class="content">The best solution is to squash messy commits into one atomic commit, and then use rebasing for a clean history on top of that. But I find that squash-merging <i>all</i> the commits from a PR or branch is generally <i>not</i> what you want.<p>And if you have atomic commits, then merge commits generally aren&#x27;t helpful. As others have pointed out, what matters is when the code was added and what it does, which becomes very clear if you have a linear history without merge commits (but atomic commits as much as possible).<p>If during the development process your commits aren&#x27;t atomic, that is fine, but then you should <i>make them atomic</i> with squashing before they actually get rebased into main.<p>So for example if I&#x27;m in a personal dev branch and I have &quot;messy fix feat A&quot;, &quot;fix feat A but better&quot;, &quot;even better feat A&quot;, and &quot;add feat B&quot;, I should just squash the first three into &quot;Improve feat A&quot; and leave the fourth alone as &quot;Add feat B&quot;. Then after a PR review or tests or whatever you just rebase into main. Now there is still a clear delineation between my fixes to A and my addition of B, without forcing me to make separate PRs for highly related features. I end up with:<p>- clean history<p>- atomic commits<p>- limited mental overhead when doing quick and dirty commits<p>- not forcing atomic PRs which can be overwhelming</div><br/></div></div><div id="40764781" class="c"><input type="checkbox" id="c-40764781" checked=""/><div class="controls bullet"><span class="by">overgard</span><span>|</span><a href="#40764872">prev</a><span>|</span><a href="#40765162">next</a><span>|</span><label class="collapse" for="c-40764781">[-]</label><label class="expand" for="c-40764781">[1 more]</label></div><br/><div class="children"><div class="content">I feel like squash-merge accomplishes what I want (easy revertibility and simpler history). I&#x27;ll admit I need to learn it better, but every time I&#x27;ve tried to use rebase I feel like I&#x27;m playing with fire and I end up doing silly things like making a backup of the whole folder. I just think the process is unintuitive and somewhat scary, and I don&#x27;t get the net gain. Like, outside of looking at the last couple days is anyone really spelunking into history that much anyway?</div><br/></div></div><div id="40765162" class="c"><input type="checkbox" id="c-40765162" checked=""/><div class="controls bullet"><span class="by">danjc</span><span>|</span><a href="#40764781">prev</a><span>|</span><a href="#40765186">next</a><span>|</span><label class="collapse" for="c-40765162">[-]</label><label class="expand" for="c-40765162">[1 more]</label></div><br/><div class="children"><div class="content">Your commit history is part of your product, not scaffolding. Well designed commits make a codebase a pleasure to work on and reduce the accrual rate of technical debt.</div><br/></div></div><div id="40765186" class="c"><input type="checkbox" id="c-40765186" checked=""/><div class="controls bullet"><span class="by">jacobr</span><span>|</span><a href="#40765162">prev</a><span>|</span><a href="#40754040">next</a><span>|</span><label class="collapse" for="c-40765186">[-]</label><label class="expand" for="c-40765186">[1 more]</label></div><br/><div class="children"><div class="content">Any article about rebase is incomplete without the mention of `git commit --fixup fb2f677`. When committing you usually already know which commit you’re “fixing” so you specify that.<p>Then you run `git rebase -i --autosquash origin&#x2F;main` instead and the commits are already in the right order.</div><br/></div></div><div id="40754040" class="c"><input type="checkbox" id="c-40754040" checked=""/><div class="controls bullet"><span class="by">Carrok</span><span>|</span><a href="#40765186">prev</a><span>|</span><a href="#40759858">next</a><span>|</span><label class="collapse" for="c-40754040">[-]</label><label class="expand" for="c-40754040">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Some like to rebase, while others prefer to keep the disorganized records.<p>Keeping disorganized records is the only thing you can say in favor of merge commits, and I&#x27;m unconvinced that&#x27;s a positive thing to begin with.</div><br/><div id="40754076" class="c"><input type="checkbox" id="c-40754076" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#40754040">parent</a><span>|</span><a href="#40754169">next</a><span>|</span><label class="collapse" for="c-40754076">[-]</label><label class="expand" for="c-40754076">[2 more]</label></div><br/><div class="children"><div class="content">I think the argument against rebasing is spending time polishing a PR to have a cleaner history for one feature that will maybe get looked at during review (rather than the final output) vs also making a PR for a second feature during that same time.<p>And you can eventually have github squash for you anyway.</div><br/><div id="40759484" class="c"><input type="checkbox" id="c-40759484" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#40754040">root</a><span>|</span><a href="#40754076">parent</a><span>|</span><a href="#40754169">next</a><span>|</span><label class="collapse" for="c-40759484">[-]</label><label class="expand" for="c-40759484">[1 more]</label></div><br/><div class="children"><div class="content">Rebase work resulting in atomic commits != squash</div><br/></div></div></div></div><div id="40754169" class="c"><input type="checkbox" id="c-40754169" checked=""/><div class="controls bullet"><span class="by">joe_fishfish</span><span>|</span><a href="#40754040">parent</a><span>|</span><a href="#40754076">prev</a><span>|</span><a href="#40754086">next</a><span>|</span><label class="collapse" for="c-40754169">[-]</label><label class="expand" for="c-40754169">[6 more]</label></div><br/><div class="children"><div class="content">You can’t do stacked PRs without merge commits, not unless you really like conflicts anyway.</div><br/><div id="40765221" class="c"><input type="checkbox" id="c-40765221" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#40754040">root</a><span>|</span><a href="#40754169">parent</a><span>|</span><a href="#40754273">next</a><span>|</span><label class="collapse" for="c-40765221">[-]</label><label class="expand" for="c-40765221">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s tooling that helps with some of that. I have evaluated StGit for a month or so now, and while it does require that one unlearns some git in the process, it has been handling that sort of situation well.</div><br/></div></div><div id="40754273" class="c"><input type="checkbox" id="c-40754273" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#40754040">root</a><span>|</span><a href="#40754169">parent</a><span>|</span><a href="#40765221">prev</a><span>|</span><a href="#40754276">next</a><span>|</span><label class="collapse" for="c-40754273">[-]</label><label class="expand" for="c-40754273">[3 more]</label></div><br/><div class="children"><div class="content">I have never seen stacked PRs work that well in practice. Two reasons:<p>- Namely there would be review comments on the first PRs that then cause a cascade of merge conflicts in the follow-on PRs<p>- Somehow reviewers never seem to like the stack of PRs, my experience is they always react with disdain and&#x2F;or confusion.<p>There is the counter-question too, why not stack commits cleanly?<p>A third reason against, not a good reason, but for many developers Git is super difficult (IMO largely a skill issue, not taking the time to learn basic tools that they need everyday;  otherwise I have no clue why software developers do not learn their IDEs and VCS tools very well).  Stacking PRs requires some Git skills, a simple feature-branch workflow can be a challenge for many..<p>Ultimately, I think the solution to stacked PRs is to change review policy to &quot;ship&#x2F;show&#x2F;ask&quot;: <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;ship-show-ask.html" rel="nofollow">https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;ship-show-ask.html</a><p>In other words, if someone is skilled enough to do a set of stacked PRs, the team likely benefits by letting that person merge the stack on their own when each bit is ready and do a post-merge review instead of pre-merge.<p>(Side-note, my unsolicited perspective: I&#x27;m personally convinced that the benefits of linear history is a magnitude more important than all the other peeves &amp; nits combined between  merge vs rebase.)</div><br/><div id="40754356" class="c"><input type="checkbox" id="c-40754356" checked=""/><div class="controls bullet"><span class="by">edfletcher_t137</span><span>|</span><a href="#40754040">root</a><span>|</span><a href="#40754273">parent</a><span>|</span><a href="#40754276">next</a><span>|</span><label class="collapse" for="c-40754356">[-]</label><label class="expand" for="c-40754356">[2 more]</label></div><br/><div class="children"><div class="content">&gt; - Somehow reviewers never seem to like the stack of PRs, my experience is they always react with disdain and&#x2F;or confusion.<p>Are people sending multiple branches of the stack for review at once? It should only ever be the &quot;bottom&quot; branch out-for-review at any time.<p>&gt; - Namely there would be review comments on the first PRs that then cause a cascade of merge conflicts in the follow-on PRs<p>This can still happen in the model above of course as you need to make changes to the bottom branch in response to review comments&#x2F;requests.<p>However, as I noted elsewhere, `--update-refs` is an absolute god-send in those situations: <a href="https:&#x2F;&#x2F;andrewlock.net&#x2F;working-with-stacked-branches-in-git-is-easier-with-update-refs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;andrewlock.net&#x2F;working-with-stacked-branches-in-git-...</a><p>It reduces a ton of manual work (<i>scaled</i> by how many branches you have stacked!) to <i>one</i> operation.</div><br/><div id="40755051" class="c"><input type="checkbox" id="c-40755051" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#40754040">root</a><span>|</span><a href="#40754356">parent</a><span>|</span><a href="#40754276">next</a><span>|</span><label class="collapse" for="c-40755051">[-]</label><label class="expand" for="c-40755051">[1 more]</label></div><br/><div class="children"><div class="content">Multiple at once.  Good pointer on `--update-refs`!<p>I can think of quite a few additional concerns. Overall I think it comes down to how the team wants to handle code reviews.<p>Personally, I do think if the team is at the level to coordinate and execute on a stack list of PRs, there is little need to incur extra round-trip times for &quot;reviewing&quot;  precursor changes and instead focus review time where it is explicitly wanted.<p>Though, I do indeed like stacked PRs over commit-list because there is more incremental progress, but it does come with some costs. For example, perhaps the last reviewer does not like the overall direction that the cumulative work has led to.<p>My experience is that at that rate, it&#x27;s best to let teams decide how they want to operate, formalize somewhat how things are shipped, and bias towards shipping. On the other end of the spectrum, a person quickly glancing at refactoring updates, not having good context on how a given PR fits in - it can almost put into question whether CR itself is entirely a best practice. Hence, I&#x27;m a fan of &quot;ship&#x2F;show&#x2F;ask&quot;. I think it mostly does away with the need for stacking PRs with very little downside (and upside of greater efficiency, CR is spent time reviewing more important code, things that benefit from CR and use the reviewers time well, and makes for a better flow for the author since they can readily merge).</div><br/></div></div></div></div></div></div><div id="40754276" class="c"><input type="checkbox" id="c-40754276" checked=""/><div class="controls bullet"><span class="by">edfletcher_t137</span><span>|</span><a href="#40754040">root</a><span>|</span><a href="#40754169">parent</a><span>|</span><a href="#40754273">prev</a><span>|</span><a href="#40754086">next</a><span>|</span><label class="collapse" for="c-40754276">[-]</label><label class="expand" for="c-40754276">[1 more]</label></div><br/><div class="children"><div class="content">Sure you can! In fact you can do magic on stacked branches with `rebase --update-refs` that you can&#x27;t do with merge: <a href="https:&#x2F;&#x2F;andrewlock.net&#x2F;working-with-stacked-branches-in-git-is-easier-with-update-refs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;andrewlock.net&#x2F;working-with-stacked-branches-in-git-...</a></div><br/></div></div></div></div><div id="40754086" class="c"><input type="checkbox" id="c-40754086" checked=""/><div class="controls bullet"><span class="by">lesuorac</span><span>|</span><a href="#40754040">parent</a><span>|</span><a href="#40754169">prev</a><span>|</span><a href="#40759858">next</a><span>|</span><label class="collapse" for="c-40754086">[-]</label><label class="expand" for="c-40754086">[2 more]</label></div><br/><div class="children"><div class="content">Well disorganized records can still be very useful.<p>If you&#x27;re trying to figure out where a bug came from it can be helpful to bisect through all the commits. If you bisect down to 40 file change that&#x27;s going to be a pain to continue bisecting. However, if you can bisect down to say 5 changes where your bisection fails and 4 of them are because the app fails to build and the 5th is because that&#x27;s when the bug was introduced that can be very useful.</div><br/></div></div></div></div><div id="40759858" class="c"><input type="checkbox" id="c-40759858" checked=""/><div class="controls bullet"><span class="by">breatheoften</span><span>|</span><a href="#40754040">prev</a><span>|</span><a href="#40763295">next</a><span>|</span><label class="collapse" for="c-40759858">[-]</label><label class="expand" for="c-40759858">[1 more]</label></div><br/><div class="children"><div class="content">Strongly pro rebase here.<p>I sometimes wish I could require squash merging to main so that history on main is fully linear -- however the fatal flaw with doing that is that it becomes impossible to know from git history whether a given branch has actually been merged to main or whether it was abandoned and left to dangle and rot forever.  The inability to observe merge state for a given commit increases the effort required to know whether some given piece of work was merged (or at least requires using mechanisms that are not native to git to make such a determination) and complicates cleaning up old local branches after they are merged.  If you use a graphical git client then seeing a brunch of old local branches that are already merged everywhere is noisy and distracting.  When real merges are done then can easily write a script to remove all the branches that are already merged to main which helps to reduce noise and maintain better focus and faster navigation.</div><br/></div></div><div id="40763295" class="c"><input type="checkbox" id="c-40763295" checked=""/><div class="controls bullet"><span class="by">stevebmark</span><span>|</span><a href="#40759858">prev</a><span>|</span><a href="#40754420">next</a><span>|</span><label class="collapse" for="c-40763295">[-]</label><label class="expand" for="c-40763295">[1 more]</label></div><br/><div class="children"><div class="content">I find merges more confusing than rebasing. At the end of rebasing you just have commits. Merges are commits with multiple parents, which is a confusing concept.</div><br/></div></div><div id="40754420" class="c"><input type="checkbox" id="c-40754420" checked=""/><div class="controls bullet"><span class="by">jaza</span><span>|</span><a href="#40763295">prev</a><span>|</span><a href="#40762381">next</a><span>|</span><label class="collapse" for="c-40754420">[-]</label><label class="expand" for="c-40754420">[1 more]</label></div><br/><div class="children"><div class="content">I just git commit --amend and then git push -f origin feat_branch all my incremental changes. Saves me having to think of even one word commit messages like &quot;typo&quot; or &quot;renaming&quot;. And saves me having to do an interactive rebase later (which basically has the same end result as git commit --amend anyway). Nobody on my team cares about those incremental changes, including me.</div><br/></div></div><div id="40762381" class="c"><input type="checkbox" id="c-40762381" checked=""/><div class="controls bullet"><span class="by">pseudoramble</span><span>|</span><a href="#40754420">prev</a><span>|</span><a href="#40759026">next</a><span>|</span><label class="collapse" for="c-40762381">[-]</label><label class="expand" for="c-40762381">[3 more]</label></div><br/><div class="children"><div class="content">Not too interested into diving into the debate itself, but one minor point I wanted to add to the article where they count the commits to squash and then do `git rebase -i HEAD~n` is that you can replace this strategy with using the branch you&#x27;re targeting. So if you&#x27;re working on a feature branch to merge into `main` you can update the local main branch first, then punch in `git rebase -i main` and it&#x27;ll handle finding all the commits for you.<p>I&#x27;m sure there&#x27;s even more clever ways to do this, as it always seems like there&#x27;s more when it comes to git. This is just the most intuitive way I&#x27;ve seen so far, and so it sticks in my mind.</div><br/><div id="40762547" class="c"><input type="checkbox" id="c-40762547" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40762381">parent</a><span>|</span><a href="#40759026">next</a><span>|</span><label class="collapse" for="c-40762547">[-]</label><label class="expand" for="c-40762547">[2 more]</label></div><br/><div class="children"><div class="content">And a fairly quick way to do the same sort of thing is `git fetch &amp;&amp; git rebase -i origin&#x2F;main`. You never bother updating `main` because you kind of don&#x27;t care for the task at hand.</div><br/><div id="40762588" class="c"><input type="checkbox" id="c-40762588" checked=""/><div class="controls bullet"><span class="by">pseudoramble</span><span>|</span><a href="#40762381">root</a><span>|</span><a href="#40762547">parent</a><span>|</span><a href="#40759026">next</a><span>|</span><label class="collapse" for="c-40762588">[-]</label><label class="expand" for="c-40762588">[1 more]</label></div><br/><div class="children"><div class="content">True, good point. Makes sense! Thanks for the improvement!</div><br/></div></div></div></div></div></div><div id="40759026" class="c"><input type="checkbox" id="c-40759026" checked=""/><div class="controls bullet"><span class="by">dham</span><span>|</span><a href="#40762381">prev</a><span>|</span><a href="#40765659">next</a><span>|</span><label class="collapse" for="c-40759026">[-]</label><label class="expand" for="c-40759026">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know why anyone cares about this stuff. You can literally do whatever you want on your private branch. If you want to make your life harder, that&#x27;s cool.  Just squash into the main and call it a day.  None of this stuff matters anymore, like it did when I started my career.</div><br/><div id="40759167" class="c"><input type="checkbox" id="c-40759167" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40759026">parent</a><span>|</span><a href="#40763455">next</a><span>|</span><label class="collapse" for="c-40759167">[-]</label><label class="expand" for="c-40759167">[1 more]</label></div><br/><div class="children"><div class="content">I agree you can do whatever you want on your private branch. Unfortunately I think a lot of developers don’t have a solid grasp of what’s possible in private, and more importantly what you should do in private vs. on public branches.</div><br/></div></div><div id="40763455" class="c"><input type="checkbox" id="c-40763455" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40759026">parent</a><span>|</span><a href="#40759167">prev</a><span>|</span><a href="#40765659">next</a><span>|</span><label class="collapse" for="c-40763455">[-]</label><label class="expand" for="c-40763455">[1 more]</label></div><br/><div class="children"><div class="content">&gt;None of this stuff matters anymore, like it did when I started my career.<p>Explain?</div><br/></div></div></div></div><div id="40765659" class="c"><input type="checkbox" id="c-40765659" checked=""/><div class="controls bullet"><span class="by">dudeinjapan</span><span>|</span><a href="#40759026">prev</a><span>|</span><a href="#40760360">next</a><span>|</span><label class="collapse" for="c-40765659">[-]</label><label class="expand" for="c-40765659">[1 more]</label></div><br/><div class="children"><div class="content">Do not like rebasing. For me, it&#x27;s squash-merge all the way, and I compare the actual diff of the code on my new branch.<p>Diffs are what matter--not commits.</div><br/></div></div><div id="40760360" class="c"><input type="checkbox" id="c-40760360" checked=""/><div class="controls bullet"><span class="by">Taylor_OD</span><span>|</span><a href="#40765659">prev</a><span>|</span><a href="#40754066">next</a><span>|</span><label class="collapse" for="c-40760360">[-]</label><label class="expand" for="c-40760360">[1 more]</label></div><br/><div class="children"><div class="content">I love rebasing. I know a few people who have disliked it when they first started doing it and most of the time its because they would not rebase into their branches often while working. This made for one big rebase at the end which can be a nightmare.</div><br/></div></div><div id="40754066" class="c"><input type="checkbox" id="c-40754066" checked=""/><div class="controls bullet"><span class="by">cocoto</span><span>|</span><a href="#40760360">prev</a><span>|</span><a href="#40754591">next</a><span>|</span><label class="collapse" for="c-40754066">[-]</label><label class="expand" for="c-40754066">[14 more]</label></div><br/><div class="children"><div class="content">In my opinion squashing is all you need. You keep the organic history on the original branch and the clean and easy to follow history on the master branch. Ideal would be to have a “collapsing” commit instead of squashing for ergonomy.</div><br/><div id="40754174" class="c"><input type="checkbox" id="c-40754174" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#40754066">parent</a><span>|</span><a href="#40754451">next</a><span>|</span><label class="collapse" for="c-40754174">[-]</label><label class="expand" for="c-40754174">[10 more]</label></div><br/><div class="children"><div class="content">Highly disciplined&#x2F;structured PRs (with a high rate of atomic commits) merged via merge commit have significant benefits:<p>- easier to read&#x2F;analyze<p>- have better documentation (more isolated git metadata&#x2F;history)<p>- are easier to debug (and possible to bisect; it&#x27;s not possible to bisect a squashed commit).<p>The problem is that it requires a significant amount of discipline (of course, 100% rate of atomic commits is not possible, but high rate is).</div><br/><div id="40754355" class="c"><input type="checkbox" id="c-40754355" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754174">parent</a><span>|</span><a href="#40754267">next</a><span>|</span><label class="collapse" for="c-40754355">[-]</label><label class="expand" for="c-40754355">[5 more]</label></div><br/><div class="children"><div class="content">Another benefit of not squashing is it encourages devs to think about their commits and is a great opportunity to document what you are doing when they are doing it. If you are squashing 10 commits with junk commit messages (because devs know there is little value in having meaningful commits in what will be a squashed branch), trying to summarize all the changes into a meaningful commit message is hard. It can be valuable to see the intention of atomic commits in git history. The squash branch on merge strategy is just lazy and is counterproductive to having meaningful git history.</div><br/><div id="40754882" class="c"><input type="checkbox" id="c-40754882" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754355">parent</a><span>|</span><a href="#40754410">next</a><span>|</span><label class="collapse" for="c-40754882">[-]</label><label class="expand" for="c-40754882">[1 more]</label></div><br/><div class="children"><div class="content">This depends on the assumption that going to the trouble of making a carefully curated commit history well documented is even worth the trouble.  Sometimes it might be, but I don&#x27;t think it&#x27;s a given.<p>&gt; The squash branch on merge strategy is just lazy<p>&quot;Lazy&quot; is the negative way of saying &quot;easy&quot; or even &quot;more efficient&quot;.  &quot;Lazy&quot; implies that the other way is better.  Is it?  Maybe sometimes.<p>Am I &quot;lazy&quot; if I walk on my feet instead of my hands?  It really is a lot easier.</div><br/></div></div><div id="40754410" class="c"><input type="checkbox" id="c-40754410" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754355">parent</a><span>|</span><a href="#40754882">prev</a><span>|</span><a href="#40754512">next</a><span>|</span><label class="collapse" for="c-40754410">[-]</label><label class="expand" for="c-40754410">[2 more]</label></div><br/><div class="children"><div class="content">I prefer to add commentary in the PR on the final changes - what does it do, how does it work, what are some pieces of code I&#x27;m less sure of, etc. It is accessible since the squashed commit gets linked to it and that provides a place for people to ask questions.<p>Also is a lot faster to write and easier to communicate compared to messing around with moving code across commits, ensuring tests pass across them, etc.<p>Basically I think people care more about what was built and how it works rather than how to split it up step by step (although if the latter is important I can add a comment for that on the PR - although ideally it would have been separate PRs.)</div><br/><div id="40756425" class="c"><input type="checkbox" id="c-40756425" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754410">parent</a><span>|</span><a href="#40754512">next</a><span>|</span><label class="collapse" for="c-40756425">[-]</label><label class="expand" for="c-40756425">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I prefer to add commentary in the PR on the final changes<p>That vanishes when you shift forges</div><br/></div></div></div></div><div id="40754512" class="c"><input type="checkbox" id="c-40754512" checked=""/><div class="controls bullet"><span class="by">sjburt</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754355">parent</a><span>|</span><a href="#40754410">prev</a><span>|</span><a href="#40754267">next</a><span>|</span><label class="collapse" for="c-40754512">[-]</label><label class="expand" for="c-40754512">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem is that often the order you want it in a clean history is not exactly the chronological order it was developed. Eg you may build out a feature vertically, tweaking the interfaces between the components as you go along. But a clean, atomic git history would probably introduce each component in a finished state in separate commits.</div><br/></div></div></div></div><div id="40754267" class="c"><input type="checkbox" id="c-40754267" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754174">parent</a><span>|</span><a href="#40754355">prev</a><span>|</span><a href="#40754451">next</a><span>|</span><label class="collapse" for="c-40754267">[-]</label><label class="expand" for="c-40754267">[4 more]</label></div><br/><div class="children"><div class="content">&gt;- are easier to debug (and possible to bisect; it&#x27;s not possible to bisect a squashed commit).<p>In practice, if bisecting indicates a commit caused the problem you can narrow it down further by checking out that branch and investigating further within that branch (which ideally isn&#x27;t too large). Also, if you have a highly structured PR then you may need to be careful to ensure that each individual commit passes CI.<p>At that point you might as well ship each commit via a separate PR. (While in development you can temporarily set the branch for Part 1 as the base for Part 2.)</div><br/><div id="40754402" class="c"><input type="checkbox" id="c-40754402" checked=""/><div class="controls bullet"><span class="by">fouc</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754267">parent</a><span>|</span><a href="#40762152">next</a><span>|</span><label class="collapse" for="c-40754402">[-]</label><label class="expand" for="c-40754402">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re assuming it is not an old bug and that the branch is somehow kept around for other developers to re-open months or years later.<p>A PR for each commit seems overkill.  Usually a PR is for a feature, but code-wise, a feature might require several atomic changes. For example:  prepare configuration,  move files around, add tests, add new code, delete old code, refactor.  Each of those could be a separate commit, bringing you to a polished feature with test coverage.</div><br/><div id="40754866" class="c"><input type="checkbox" id="c-40754866" checked=""/><div class="controls bullet"><span class="by">jaredsohn</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754402">parent</a><span>|</span><a href="#40762152">next</a><span>|</span><label class="collapse" for="c-40754866">[-]</label><label class="expand" for="c-40754866">[1 more]</label></div><br/><div class="children"><div class="content">Might depend on how companies use git but I just verified I can see commits for PRs from 2017 in my work codebase; could bisect that if needed (although code likely is no longer relevant.)<p>I think splitting PRs into multiple commits can make sense when there are only 2-3 commits but you&#x27;re right that it doesn&#x27;t when there are more than that.</div><br/></div></div></div></div><div id="40762152" class="c"><input type="checkbox" id="c-40762152" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754267">parent</a><span>|</span><a href="#40754402">prev</a><span>|</span><a href="#40754451">next</a><span>|</span><label class="collapse" for="c-40762152">[-]</label><label class="expand" for="c-40762152">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At that point you might as well ship each commit via a separate PR. (While in development you can temporarily set the branch for Part 1 as the base for Part 2.)<p>Absolutely. Indeed, this (independent commit) is a very positive side effect (typical example: separating refactoring commits).</div><br/></div></div></div></div></div></div><div id="40754451" class="c"><input type="checkbox" id="c-40754451" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40754066">parent</a><span>|</span><a href="#40754174">prev</a><span>|</span><a href="#40754099">next</a><span>|</span><label class="collapse" for="c-40754451">[-]</label><label class="expand" for="c-40754451">[1 more]</label></div><br/><div class="children"><div class="content">git log --first-parent shows the merges but not the complete history of each merged branch. git log --first-parent --patch displays all the changes that came with a merge as if it were one big squash commit (in general git log --patch diffs trees, not single commits).</div><br/></div></div><div id="40754099" class="c"><input type="checkbox" id="c-40754099" checked=""/><div class="controls bullet"><span class="by">simongr3dal</span><span>|</span><a href="#40754066">parent</a><span>|</span><a href="#40754451">prev</a><span>|</span><a href="#40754591">next</a><span>|</span><label class="collapse" for="c-40754099">[-]</label><label class="expand" for="c-40754099">[2 more]</label></div><br/><div class="children"><div class="content">You sort of get that if you&#x27;re consistent in working on a separate branch, rebasing, and keeping the merge commit when you finally merge.</div><br/><div id="40754212" class="c"><input type="checkbox" id="c-40754212" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40754066">root</a><span>|</span><a href="#40754099">parent</a><span>|</span><a href="#40754591">next</a><span>|</span><label class="collapse" for="c-40754212">[-]</label><label class="expand" for="c-40754212">[1 more]</label></div><br/><div class="children"><div class="content">But you can also get it with much less discipline if just go wild merging and doing whatever.  And then resolve your master PRs using squash.</div><br/></div></div></div></div></div></div><div id="40754591" class="c"><input type="checkbox" id="c-40754591" checked=""/><div class="controls bullet"><span class="by">juancn</span><span>|</span><a href="#40754066">prev</a><span>|</span><a href="#40754435">next</a><span>|</span><label class="collapse" for="c-40754591">[-]</label><label class="expand" for="c-40754591">[3 more]</label></div><br/><div class="children"><div class="content">The only issue with rebasing is if someone else has checked out the branch and now they have diverged. It&#x27;s usually a simple fix, but it can get annoying.<p>I tend to checkout branches to do code reviews, when changes are complex a diff is not enough, I want an IDE to help me reason about the code (I sometimes even refactor and try different things just so I can understand the code better, so I can make good suggestions).<p>When I do this, and comment, and the other dev rebases, it&#x27;s an extra step for me on the next CR cycle.</div><br/><div id="40754667" class="c"><input type="checkbox" id="c-40754667" checked=""/><div class="controls bullet"><span class="by">kutenai</span><span>|</span><a href="#40754591">parent</a><span>|</span><a href="#40759041">next</a><span>|</span><label class="collapse" for="c-40754667">[-]</label><label class="expand" for="c-40754667">[1 more]</label></div><br/><div class="children"><div class="content">I train my team on how to resolve this. Every team member is able to resolve a force push onto a branch they have local.<p>Also, we tend to avoid having multiple people work on the same branch.. so, that&#x27;s also a thing.<p>If there was a multi-person development effort, then each of those people would have to have a sub-branch of a main feature, and then they would be rebasing their work onto the &#x27;main&#x27; feature branch.. which would ultimately be rebased on to dev.. etc.</div><br/></div></div><div id="40759041" class="c"><input type="checkbox" id="c-40759041" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#40754591">parent</a><span>|</span><a href="#40754667">prev</a><span>|</span><a href="#40754435">next</a><span>|</span><label class="collapse" for="c-40759041">[-]</label><label class="expand" for="c-40759041">[1 more]</label></div><br/><div class="children"><div class="content">Never rebase shared branches.</div><br/></div></div></div></div><div id="40754435" class="c"><input type="checkbox" id="c-40754435" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#40754591">prev</a><span>|</span><label class="collapse" for="c-40754435">[-]</label><label class="expand" for="c-40754435">[1 more]</label></div><br/><div class="children"><div class="content">This may be rose-tinted glasses, but I was fine with merges with Mercurial &#x2F; <a href="https:&#x2F;&#x2F;tortoisehg.bitbucket.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tortoisehg.bitbucket.io&#x2F;</a> but subsequently using git (with gitlab&#x2F;GitHub ) I&#x27;ve been rebase + `--force-with-lease` every time. I&#x27;m happy with my current git workflow, but I can&#x27;t help but feel I&#x27;m missing a trick through finding git merge commits so difficult to understand</div><br/></div></div></div></div></div></div></div></body></html>