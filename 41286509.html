<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724058071688" as="style"/><link rel="stylesheet" href="styles.css?v=1724058071688"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/brannondorsey/rust-incompatible-transitive-dependencies">Can a Rust binary use incompatible versions of the same library?</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>braxxox</span> | <span>49 comments</span></div><br/><div><div id="41288537" class="c"><input type="checkbox" id="c-41288537" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#41289115">next</a><span>|</span><label class="collapse" for="c-41288537">[-]</label><label class="expand" for="c-41288537">[2 more]</label></div><br/><div class="children"><div class="content">This isn’t a magic bullet. Using multiple versions of the same crate can still blow up your project.<p>For example, the compiler error in this example:<p>note: perhaps two different versions of crate `smithay_client_toolkit` are being used?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pop-os&#x2F;launcher&#x2F;issues&#x2F;237">https:&#x2F;&#x2F;github.com&#x2F;pop-os&#x2F;launcher&#x2F;issues&#x2F;237</a></div><br/><div id="41288769" class="c"><input type="checkbox" id="c-41288769" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#41288537">parent</a><span>|</span><a href="#41289115">next</a><span>|</span><label class="collapse" for="c-41288769">[-]</label><label class="expand" for="c-41288769">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I was wondering what would happen if you&#x27;re using a type from lib-v2 and an intermediary library passes you that type from lib-v1, and the type has changed internally. Good to know the Rust compiler is set up to catch that.<p>(I&#x27;ve seen cases where that happens with C and C++ software, and things seem to compile and run... until everything <i>explodes</i>. Fun times.)</div><br/></div></div></div></div><div id="41289115" class="c"><input type="checkbox" id="c-41289115" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#41288537">prev</a><span>|</span><a href="#41288763">next</a><span>|</span><label class="collapse" for="c-41289115">[-]</label><label class="expand" for="c-41289115">[1 more]</label></div><br/><div class="children"><div class="content">FYI, Python can&#x2F;did support multiple versions via buildout (<a href="http:&#x2F;&#x2F;www.buildout.org&#x2F;en&#x2F;latest&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.buildout.org&#x2F;en&#x2F;latest&#x2F;</a>) but it&#x27;s complicated and wide-scale support has probably bit-rotted away.</div><br/></div></div><div id="41288763" class="c"><input type="checkbox" id="c-41288763" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41289115">prev</a><span>|</span><a href="#41287945">next</a><span>|</span><label class="collapse" for="c-41288763">[-]</label><label class="expand" for="c-41288763">[1 more]</label></div><br/><div class="children"><div class="content">How does this work? Assume that the log crate in its internal state has a lock it uses for synchronizing writing to some log endpoint. If I have two versions of log in my process then they must have two copies of their internal state. So they both point to the same log endpoint, but they have one mutex <i>each</i>? That means it &quot;works&quot; at compile time but fails at runtime? That&#x27;s the worst kind of &quot;works!&quot;<p>Or if I depend transitively on two versions of a library (e.g. a matrix math lib) through A and B and try to read a value from A and send it into B. Then presumably due to type namespacing that will fail at compile time?<p>So the options when using incompatible dependencies are a) it compiles, but fails at runtime, b) it doesn&#x27;t compile, or c) it compiles and works at runtime?</div><br/></div></div><div id="41287945" class="c"><input type="checkbox" id="c-41287945" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#41288763">prev</a><span>|</span><a href="#41288708">next</a><span>|</span><label class="collapse" for="c-41287945">[-]</label><label class="expand" for="c-41287945">[15 more]</label></div><br/><div class="children"><div class="content">This is great for avoiding conflicts when you try to get your project running.<p>It sucks when there is a vulnerability in a particular library, and you&#x27;re trying to track all of the ways in which that vulnerable code is being pulled into your project.<p>My preference is to force the conflict up front by saying that you can&#x27;t import conflicting versions. This creates a constant stream of small problems, but avoids really big ones later. However I absolutely understand why a lot of people prefer it the other way around.</div><br/><div id="41288197" class="c"><input type="checkbox" id="c-41288197" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#41287945">parent</a><span>|</span><a href="#41288410">next</a><span>|</span><label class="collapse" for="c-41288197">[-]</label><label class="expand" for="c-41288197">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   cargo tree -i log@0.3.9
</code></pre>
will show which dependencies require this particular version of log, and how they are transitively related to the main package. In this case, you would clearly see that the out-of-date dependency comes from package &quot;b&quot;.<p>There are equivalents for must other package managers that take this approach, and I&#x27;ve never found this a problem in practice.<p>Of course, you still need to know that there&#x27;s a vulnerability there in the first place, but that&#x27;s why tools like NPM often integrate with vulnerability scanners so that they can check your dependencies as you install them.</div><br/></div></div><div id="41288410" class="c"><input type="checkbox" id="c-41288410" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#41287945">parent</a><span>|</span><a href="#41288197">prev</a><span>|</span><a href="#41288000">next</a><span>|</span><label class="collapse" for="c-41288410">[-]</label><label class="expand" for="c-41288410">[1 more]</label></div><br/><div class="children"><div class="content">That’s nowhere near as terrible as not being able to resolve a conflict between incompatible versions. Like half of your project can’t use Guava X but another half can’t use Guava Y, and there is no common version that works. We ran into compatibility problems with our big Java project many times and wasted months on attempting things like jar shading or classloaders. At the end of the day we use shading but that comes with its own set of annoyances like increasing the build times and allowing people to occasionally import the wrong version of library (eg. shaded instead of non-shaded). The bigger the project the more likely you’re going to hit this, and the lack of support for feature-gating dependencies in the Java ecosystem doesn’t help.</div><br/></div></div><div id="41288000" class="c"><input type="checkbox" id="c-41288000" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41287945">parent</a><span>|</span><a href="#41288410">prev</a><span>|</span><a href="#41288708">next</a><span>|</span><label class="collapse" for="c-41288000">[-]</label><label class="expand" for="c-41288000">[12 more]</label></div><br/><div class="children"><div class="content">Go got this right: you want an incompatible version, you have to use a different import path. Then you can only pick one version (which is deterministically the lowest possible version) for a certain import path, not a hundred different versions.<p>Also forces people to actually take backwards compatibility seriously.</div><br/><div id="41288057" class="c"><input type="checkbox" id="c-41288057" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288000">parent</a><span>|</span><a href="#41288226">next</a><span>|</span><label class="collapse" for="c-41288057">[-]</label><label class="expand" for="c-41288057">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not surprised. Go&#x27;s design is heavily informed by what does and does not cause cascading design problems in software engineering at scale. These practical concerns are very different from the kinds of issues that academia had been focused on. But practical solutions to practical problems is central to Go&#x27;s popularity.</div><br/></div></div><div id="41288226" class="c"><input type="checkbox" id="c-41288226" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288000">parent</a><span>|</span><a href="#41288057">prev</a><span>|</span><a href="#41288432">next</a><span>|</span><label class="collapse" for="c-41288226">[-]</label><label class="expand" for="c-41288226">[3 more]</label></div><br/><div class="children"><div class="content">But surely you can still run into the same issue:<p>I import a@1 and b@1  
a@1 transitively depends on c@1  
b@1 transitively depends on c@2<p>Even with different import paths, I still have two different versions of c in my codebase. It&#x27;ll just be that one of them is imported as &quot;c&quot; and the other will be imported as &quot;c&#x2F;v2&quot; - but you don&#x27;t need to worry about that, because that&#x27;s happening in transitive dependencies that you&#x27;re not writing.<p>You still have the same issue of needing to keep track of all the different versions that can exist in your codebase.</div><br/><div id="41288571" class="c"><input type="checkbox" id="c-41288571" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288226">parent</a><span>|</span><a href="#41288432">next</a><span>|</span><label class="collapse" for="c-41288571">[-]</label><label class="expand" for="c-41288571">[2 more]</label></div><br/><div class="children"><div class="content">It’s c and c&#x2F;v2, not c@1.0.0, c@1.0.5, c@1.0.10, c@1.1.3, c@2.0.0, c@2.3.1, ... Each necessary because packages in the middle have decided to pin versions or add upper bounds to work around bugs. That’s a huge difference.</div><br/><div id="41289152" class="c"><input type="checkbox" id="c-41289152" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288571">parent</a><span>|</span><a href="#41288432">next</a><span>|</span><label class="collapse" for="c-41289152">[-]</label><label class="expand" for="c-41289152">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, I&#x27;ve just pulled up a pretty large project I work on using NPM, and almost all of the duplicate dependencies had different major versions. Most of the ones that had the same major version were 0.x dependencies with different minor versions.<p>So I&#x27;m still not convinced that Go&#x27;s approach is materially different here - certainly in terms of the practical output, NPM does a good job of ensuring that the fewest number of different versions will get installed for each dependency.</div><br/></div></div></div></div></div></div><div id="41288432" class="c"><input type="checkbox" id="c-41288432" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288000">parent</a><span>|</span><a href="#41288226">prev</a><span>|</span><a href="#41288191">next</a><span>|</span><label class="collapse" for="c-41288432">[-]</label><label class="expand" for="c-41288432">[2 more]</label></div><br/><div class="children"><div class="content">No one asked about Go here. And no, it didn’t, it’s the same PITA as in Java or maybe even worse because there are no workarounds like classloading or shading. You have no control over the transitive dependencies. The only thing you can do if there’s a conflict is asking the author to fix one of the conflicting libraries.</div><br/><div id="41288582" class="c"><input type="checkbox" id="c-41288582" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288432">parent</a><span>|</span><a href="#41288191">next</a><span>|</span><label class="collapse" for="c-41288582">[-]</label><label class="expand" for="c-41288582">[1 more]</label></div><br/><div class="children"><div class="content">If someone talks about a problem I’ll damn well explain other people’s solutions as I please. And no, you resolve conflicts by not having conflicts in the first place.</div><br/></div></div></div></div><div id="41288191" class="c"><input type="checkbox" id="c-41288191" checked=""/><div class="controls bullet"><span class="by">whatshisface</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288000">parent</a><span>|</span><a href="#41288432">prev</a><span>|</span><a href="#41288708">next</a><span>|</span><label class="collapse" for="c-41288191">[-]</label><label class="expand" for="c-41288191">[5 more]</label></div><br/><div class="children"><div class="content">Backwards compatibility is more difficult in Rust for many reasons. For example, you can&#x27;t add a new item to an enum without creating missing-case errors everywhere it is used.</div><br/><div id="41288200" class="c"><input type="checkbox" id="c-41288200" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288191">parent</a><span>|</span><a href="#41288624">next</a><span>|</span><label class="collapse" for="c-41288200">[-]</label><label class="expand" for="c-41288200">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a true effect, although I&#x27;d question whether it makes it harder or easier for things to be backwards compatible. I use Rust because I trust it to throw up a bunch of errors when I make changes; if I handle all the cases of an enum somewhere, and suddenly there&#x27;s a new enum variant, the answer is probably that I need to handle the new variant there too.</div><br/></div></div><div id="41288624" class="c"><input type="checkbox" id="c-41288624" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288191">parent</a><span>|</span><a href="#41288200">prev</a><span>|</span><a href="#41288285">next</a><span>|</span><label class="collapse" for="c-41288624">[-]</label><label class="expand" for="c-41288624">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t add a method in Go without causing new interfaces to match, which breaks at runtime.</div><br/></div></div><div id="41288285" class="c"><input type="checkbox" id="c-41288285" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#41287945">root</a><span>|</span><a href="#41288191">parent</a><span>|</span><a href="#41288624">prev</a><span>|</span><a href="#41288708">next</a><span>|</span><label class="collapse" for="c-41288285">[-]</label><label class="expand" for="c-41288285">[2 more]</label></div><br/><div class="children"><div class="content">You can use #[non_exhaustive] if you want to avoid this.</div><br/></div></div></div></div></div></div></div></div><div id="41287609" class="c"><input type="checkbox" id="c-41287609" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41288708">prev</a><span>|</span><a href="#41287207">next</a><span>|</span><label class="collapse" for="c-41287609">[-]</label><label class="expand" for="c-41287609">[2 more]</label></div><br/><div class="children"><div class="content">For fun, you could add this to Python and I think it would it cover a lot of edge cases?<p>You would need:<p>A function <i>v_tree_install(spec)</i> which installs a versioned pypi package like “foo=3.2” and all its dependencies in its own tree, rather than in site-packages.<p>Another pair of functions <i>v_import</i> and <i>v_from_import</i> to wrap importlib with a name, version, and symbols.  These functions know how to find the versioned package in its special tree <i>and</i> push that tree to sys.path before starting the import.<p>To cover the case for when the imported code has dynamic imports you could also wrap any callable code (functions, classes) with a wrapper that <i>also</i> does the sys.push&#x2F;pop before&#x2F;after each call.<p>You then replace third party imports in your code with calls assigning to symbols in your module:<p><pre><code>  # import foo
  foo = v_import(“foo==3.2”)

  # from foo import bar, baz as q
  bar, q = v_from_import(
    “foo&gt;=3.3”,
    “bar”,
    “baz”,
  )
</code></pre>
Finally, provide a function (or CLI tool) to statically scan your code looking for <i>v_import</i> and calling <i>v_tree_install</i> ahead of time.  Or just let <i>v_import</i> do it.<p>Edit: …and you’d need to edit the sys.modules cache too, or purge it after each “clever” import?</div><br/><div id="41288701" class="c"><input type="checkbox" id="c-41288701" checked=""/><div class="controls bullet"><span class="by">ahupp</span><span>|</span><a href="#41287609">parent</a><span>|</span><a href="#41287207">next</a><span>|</span><label class="collapse" for="c-41288701">[-]</label><label class="expand" for="c-41288701">[1 more]</label></div><br/><div class="children"><div class="content">You might be able to do this transparently with a [MetaPathFinder](<a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;importlib.html#importlib.abc.MetaPathFinder" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;importlib.html#importlib.a...</a>), the only trickyness would be replacing the lookup in sys.modules which I don&#x27;t think has has an official interface.</div><br/></div></div></div></div><div id="41287207" class="c"><input type="checkbox" id="c-41287207" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41287609">prev</a><span>|</span><a href="#41288435">next</a><span>|</span><label class="collapse" for="c-41287207">[-]</label><label class="expand" for="c-41287207">[13 more]</label></div><br/><div class="children"><div class="content">I thought this was about loading two incompatible versions of a shared object into the same address space at first :-)<p>The author correctly contrasts Rust (and NPM&#x27;s) behavior with that of Python&#x2F;pip, where only one version per package name is allowed. The Python packaging ecosystem <i>could</i> in theory standardize a form of package name mangling wherein multiple versions could be imported simultaneously (akin to what&#x27;s currently possible with multiple vendored versions), but that would likely be a significant undertaking given that a <i>lot</i> of applications probably - accidentally - break the indirect relationship and directly import their transitive dependencies.<p>(The more I work in Python, the more I think that Python&#x27;s approach is actually a good one: preventing multiple versions of the same package prevents dependency graph spaghetti when every subdependency depends on a slightly different version, and provides a strong incentive to keep public API surfaces small and flexible. But I don&#x27;t think that was the intention, more of an accidental perk of an otherwise informal approach to packaging.)</div><br/><div id="41287432" class="c"><input type="checkbox" id="c-41287432" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41287207">parent</a><span>|</span><a href="#41287388">next</a><span>|</span><label class="collapse" for="c-41287432">[-]</label><label class="expand" for="c-41287432">[6 more]</label></div><br/><div class="children"><div class="content">&gt; (The more I work in Python, the more I think that Python&#x27;s approach is actually a good one ...)<p>I&#x27;ve come to the opposite conclusion. I&#x27;ve &quot;git cloned&quot; several programs in both python and ruby (which has the same behaviour) only to discover that I can&#x27;t actually install the project&#x27;s dependencies. The larger your gemfile &#x2F; requirements.txt is, the more likely this is to happen. All it takes is a couple packages in your tree to update their own dependencies out of sync with one another and you can run into this problem. A build that worked yesterday doesn&#x27;t work today. Not because anyone made a mistake - but just because you got unlucky. Ugh.<p>Its a completely unnecessary landmine. Worse yet, new developers (or new teammembers) are very likely to run into this problem as it shows up when you&#x27;re getting your dev environment setup.<p>This problem is entirely unnecessary. In (almost) every way, software should treat foo-1.x.x as a totally distinct package from foo-2.x.x. They&#x27;re mutually incompatible anyway, and semantically the only thing they share is their name. There&#x27;s no reason both packages can&#x27;t be loaded into the package namespace at the same time. No reason but the mistakes of shortsighted package management systems.<p>RAM is cheap. My attention is expensive. Print a warning if you must, and I&#x27;ll fix it when I feel like it.</div><br/><div id="41288309" class="c"><input type="checkbox" id="c-41288309" checked=""/><div class="controls bullet"><span class="by">extr</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287432">parent</a><span>|</span><a href="#41287488">next</a><span>|</span><label class="collapse" for="c-41288309">[-]</label><label class="expand" for="c-41288309">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, I can see it both ways. I think it depends on programming context. On one hand you&#x27;re right that it&#x27;s annoying and a technically unnecessary gotcha, but for some Python use cases it simplifies the mental model to simply Know which version of a particular package is running. For example, pandas and numpy are IMO bad offenders for transitive dependency issues, but it&#x27;s because they&#x27;re used as building blocks everywhere and are intended to be used compositionally. It&#x27;s not uncommon to have to step through a data pipeline to debug it. That would become confusing if it&#x27;s using 5 different major versions of pandas because each package brought it&#x27;s own. Or a trip down the call stack involves multiple different versions of numpy at each level.<p>For web dev and something like requests, it&#x27;s just not as big of a deal to have a bunch of versions installed. You don&#x27;t typically use&#x2F;debug that kind of functionality in a way that would cause confusion. That said, it would be definitely be great sometimes to just be like &quot;pip, I don&#x27;t care, just make it work&quot;.</div><br/></div></div><div id="41287488" class="c"><input type="checkbox" id="c-41287488" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287432">parent</a><span>|</span><a href="#41288309">prev</a><span>|</span><a href="#41287388">next</a><span>|</span><label class="collapse" for="c-41287488">[-]</label><label class="expand" for="c-41287488">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying this hasn&#x27;t happened to you, but I&#x27;m curious: are you working with scientific Python codebases or similar? I&#x27;ve done Python development off and on for the last ~10 years, and I think I can count the number of times I&#x27;ve had transitive conflicts on a single hand. But I almost never touch scientific&#x2F;statistical&#x2F;etc. Python codebases, so I&#x27;m curious is this is a discipline&#x2F;practice concern in different subsets of the ecosystem.<p>(One of the ways I <i>have</i> seen this happen in this past is people attempting to use multiple requirements sources without synchronizing them or resolving them simultaneously. That&#x27;s indeed a highway to pain city, and it&#x27;s why modern Python packaging emphasizes either using a single standard metadata file like pyproject.toml or a fully locked environment specification like a frozen requirements file.)</div><br/><div id="41287572" class="c"><input type="checkbox" id="c-41287572" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287488">parent</a><span>|</span><a href="#41287724">next</a><span>|</span><label class="collapse" for="c-41287572">[-]</label><label class="expand" for="c-41287572">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve encountered the same problem with Python codebases in the LLM &#x2F; machine learning space. The requirements.txt files for those projects are full of unversioned dependencies, including Git repositories at some floating ref (such as master&#x2F;HEAD).<p>In the easy cases, digging through the PyPI version history to identify the latest version as of some date is enough to get a working install (as far as I can tell -- maybe it&#x27;s half-broken and I only use the working half?). In the hard cases, it may take an entire day to locate a CI log or contemporary bug report or something that lists out all the installed package versions.<p>It doesn&#x27;t help that every Python-based project seems to have its own bespoke packaging system. It&#x27;s never just pip + requirements.txt, it&#x27;ll have a Dockerfile with `apt update`, or some weird meta-packaging thing like Conda that adds it own layers of non-determinism. Overall the feeling is that it was only barely holding together on the author&#x27;s original machine, and getting it to build anywhere else is pure luck.<p>For example: <a href="https:&#x2F;&#x2F;github.com&#x2F;AUTOMATIC1111&#x2F;stable-diffusion-webui&#x2F;blob&#x2F;v1.10.1&#x2F;requirements.txt">https:&#x2F;&#x2F;github.com&#x2F;AUTOMATIC1111&#x2F;stable-diffusion-webui&#x2F;blob...</a> (with some discussion at <a href="https:&#x2F;&#x2F;github.com&#x2F;AUTOMATIC1111&#x2F;stable-diffusion-webui&#x2F;discussions&#x2F;1373">https:&#x2F;&#x2F;github.com&#x2F;AUTOMATIC1111&#x2F;stable-diffusion-webui&#x2F;disc...</a>)</div><br/></div></div><div id="41287724" class="c"><input type="checkbox" id="c-41287724" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287488">parent</a><span>|</span><a href="#41287572">prev</a><span>|</span><a href="#41287924">next</a><span>|</span><label class="collapse" for="c-41287724">[-]</label><label class="expand" for="c-41287724">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had similar problems with python packaging in both the web dev and embedded spaces. There are ways to largely solve these issues (use package managers with lock files and do irregular dependency updates), but I rarely see that being done in projects I work in.</div><br/></div></div><div id="41287924" class="c"><input type="checkbox" id="c-41287924" checked=""/><div class="controls bullet"><span class="by">marcyb5st</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287488">parent</a><span>|</span><a href="#41287724">prev</a><span>|</span><a href="#41287388">next</a><span>|</span><label class="collapse" for="c-41287924">[-]</label><label class="expand" for="c-41287924">[1 more]</label></div><br/><div class="children"><div class="content">If you use gRPC directly and some other library in your stack does it as well it&#x27;s very likely you end up with conflicts either on gRPC itself or the proto library under the hood.</div><br/></div></div></div></div></div></div><div id="41287388" class="c"><input type="checkbox" id="c-41287388" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41287207">parent</a><span>|</span><a href="#41287432">prev</a><span>|</span><a href="#41287336">next</a><span>|</span><label class="collapse" for="c-41287388">[-]</label><label class="expand" for="c-41287388">[1 more]</label></div><br/><div class="children"><div class="content">Another thing I appreciate about this in the Python world is it avoids an issue I&#x27;ve seen in node a lot, which is people being too clever by a half and pre-emptively adding major version bounds to their library. So foo depends on &quot;bar&lt;9&quot;, despite bar 9, 10, 11, 12, 13, and 14 all working with foo&#x27;s usage of bar.<p>The end result of this is that you end up with some random library in your stack (4 transitive layers deep because of course it is) holding back stuff like chokadir in a huge chunk of your dep tree for... no real good reason. So you now have several copies of a huge library.<p>Of course new major versions might break your usage! Minor versions might as well! Patch versions too sometimes! Upper bounds pre-emptively set help mainly in one thing, and that&#x27;s reducing the number of people who would help &quot;beta-test&quot; new major versions because they don&#x27;t care enough to pin their own dependencies.</div><br/></div></div><div id="41287336" class="c"><input type="checkbox" id="c-41287336" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41287207">parent</a><span>|</span><a href="#41287388">prev</a><span>|</span><a href="#41288435">next</a><span>|</span><label class="collapse" for="c-41287336">[-]</label><label class="expand" for="c-41287336">[5 more]</label></div><br/><div class="children"><div class="content">&gt; dependency graph spaghetti<p>The worst spaghetti comes from hard dependencies on minor versions and revisions.<p>I will die on the hill that you should only ever specify dependencies on “at least this major-minor (and optionally and rarely revision for a bugfix)” in whatever the syntax is for your preferred language. Excepting of course a known incompatibility with a specific version or range of versions, and&#x2F;or developers who refuse to get on the semver bandwagon who should collectively be rounded up and yelled at.<p>In Rust, Cargo makes this super easy: “x.y.z” means “&gt;= x.y.z, &lt; (x+1).0.0”.<p>It’s fine to ship a generated lock file that locks everything to a fixed, known-good version of all your dependencies. But you should be able to trivially run an update that will bring everything to the latest minor and revision (and alert on newer major versions).</div><br/><div id="41287483" class="c"><input type="checkbox" id="c-41287483" checked=""/><div class="controls bullet"><span class="by">joshka</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287336">parent</a><span>|</span><a href="#41288435">next</a><span>|</span><label class="collapse" for="c-41287483">[-]</label><label class="expand" for="c-41287483">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a subtle point there though. When you rely on something that was introduced in x.y.z, stating that your version requirement is x.y.0 is an error that can easily cause downstream breakage.</div><br/><div id="41287535" class="c"><input type="checkbox" id="c-41287535" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287483">parent</a><span>|</span><a href="#41288435">next</a><span>|</span><label class="collapse" for="c-41287535">[-]</label><label class="expand" for="c-41287535">[3 more]</label></div><br/><div class="children"><div class="content">I’m confused. If you rely on a feature introduced in X.y.z why would you specify X.y.0 to begin with (and not just X.y.z)?<p>In practice, usual rust projects that have not put a ton of work into their dependencies encode X.y.z in Cargo.toml matching the current release at the time they developed the system. So you get at worst an unnecessarily higher version requirement but never a lower one.<p>Moreover, rust semver would normally imply that new features should only be introduced in X.y releases, so this doesn’t really happen in practice!</div><br/><div id="41288165" class="c"><input type="checkbox" id="c-41288165" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41287535">parent</a><span>|</span><a href="#41288435">next</a><span>|</span><label class="collapse" for="c-41288165">[-]</label><label class="expand" for="c-41288165">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to accidentally ship a minimum version requirement that is out of date when you also consistently use lock files pinned to newer versions. The  code may silently depend on something introduced in a newer version pulled in by the lock file.</div><br/><div id="41288509" class="c"><input type="checkbox" id="c-41288509" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#41287207">root</a><span>|</span><a href="#41288165">parent</a><span>|</span><a href="#41288435">next</a><span>|</span><label class="collapse" for="c-41288509">[-]</label><label class="expand" for="c-41288509">[1 more]</label></div><br/><div class="children"><div class="content">You can have a CI builder using direct-minimal-versions to check this.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41288435" class="c"><input type="checkbox" id="c-41288435" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41287207">prev</a><span>|</span><a href="#41288674">next</a><span>|</span><label class="collapse" for="c-41288435">[-]</label><label class="expand" for="c-41288435">[1 more]</label></div><br/><div class="children"><div class="content">And this is why one gets to watch some crates being compiled from scratch multiple times in a single &quot;make world&quot; build.</div><br/></div></div><div id="41288610" class="c"><input type="checkbox" id="c-41288610" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41288674">prev</a><span>|</span><a href="#41288133">next</a><span>|</span><label class="collapse" for="c-41288610">[-]</label><label class="expand" for="c-41288610">[1 more]</label></div><br/><div class="children"><div class="content">You can do this, but you can&#x27;t use two semver-compatible versions of the same library in *different binaries* in the same workspace.</div><br/></div></div><div id="41288133" class="c"><input type="checkbox" id="c-41288133" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41288610">prev</a><span>|</span><a href="#41287714">next</a><span>|</span><label class="collapse" for="c-41288133">[-]</label><label class="expand" for="c-41288133">[1 more]</label></div><br/><div class="children"><div class="content">I cannot shake the feeling that this is actually a misfeature that will get people into trouble in new and puzzling ways. The isolated classloaders in Java and the assembly domains in .Net didn&#x27;t turn out to be very bright ideas and from a software design perspective this is virtually identical.</div><br/></div></div><div id="41287714" class="c"><input type="checkbox" id="c-41287714" checked=""/><div class="controls bullet"><span class="by">hsfzxjy</span><span>|</span><a href="#41288133">prev</a><span>|</span><label class="collapse" for="c-41287714">[-]</label><label class="expand" for="c-41287714">[9 more]</label></div><br/><div class="children"><div class="content">So both versions of log crate manage their own internal states within the same process? Would this lead to surprising results?</div><br/><div id="41287730" class="c"><input type="checkbox" id="c-41287730" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41287714">parent</a><span>|</span><label class="collapse" for="c-41287730">[-]</label><label class="expand" for="c-41287730">[8 more]</label></div><br/><div class="children"><div class="content">Their internal states in Rust are also namespaced, so two incompatible crates in the same process won&#x27;t observe each others symbols. If they access external resources that are not namespaced though, that could be a problem.</div><br/><div id="41288585" class="c"><input type="checkbox" id="c-41288585" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41287730">parent</a><span>|</span><a href="#41288138">next</a><span>|</span><label class="collapse" for="c-41288585">[-]</label><label class="expand" for="c-41288585">[5 more]</label></div><br/><div class="children"><div class="content">How would that work for malloc? How can you have two different functions manage the same heap?</div><br/><div id="41288666" class="c"><input type="checkbox" id="c-41288666" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41288585">parent</a><span>|</span><a href="#41288138">next</a><span>|</span><label class="collapse" for="c-41288666">[-]</label><label class="expand" for="c-41288666">[4 more]</label></div><br/><div class="children"><div class="content">&quot;The same heap&quot; isn&#x27;t a coherent concept here. Your malloc-implementing memory allocator has some global state, and that state has some pointers to some addresses it got from mmap and some metadata about how long those spans of memory are, which parts are unused, and how long the values it has returned from malloc previously are. If you managed to use two of these, they would each contain data referring to different non-overlapping sets of memory mappings. If you accidentally used a pointer from one with the other, you would go instantly to C UB land:<p><pre><code>  The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc() or realloc(). Otherwise, or if free(ptr) has already been called before, undefined behavior occurs. If ptr is NULL, no operation is performed.</code></pre></div><br/><div id="41288704" class="c"><input type="checkbox" id="c-41288704" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41288666">parent</a><span>|</span><a href="#41288138">next</a><span>|</span><label class="collapse" for="c-41288704">[-]</label><label class="expand" for="c-41288704">[3 more]</label></div><br/><div class="children"><div class="content">But malloc calls sbrk(), right?</div><br/><div id="41288752" class="c"><input type="checkbox" id="c-41288752" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41288704">parent</a><span>|</span><a href="#41288786">next</a><span>|</span><label class="collapse" for="c-41288752">[-]</label><label class="expand" for="c-41288752">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak to multiple users of sbrk, I assume that would fail. That&#x27;s a property of sbrk though, not of malloc (or memory allocation in general); on Windows, you can have as many implementors of malloc as you want, so long as malloc&#x2F;free calls happen to the same implementor. Each malloc implementor just asks for anonymous backing pages for their own heaps (via VirtualAlloc&#x2F;mmap).</div><br/></div></div><div id="41288786" class="c"><input type="checkbox" id="c-41288786" checked=""/><div class="controls bullet"><span class="by">unusual-name</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41288704">parent</a><span>|</span><a href="#41288752">prev</a><span>|</span><a href="#41288138">next</a><span>|</span><label class="collapse" for="c-41288786">[-]</label><label class="expand" for="c-41288786">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the implementation. For example, jemalloc can use sbrk(), sbrk() and mmap() or just mmap(), depending on what your os supports.</div><br/></div></div></div></div></div></div></div></div><div id="41288138" class="c"><input type="checkbox" id="c-41288138" checked=""/><div class="controls bullet"><span class="by">tick_tock_tick</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41287730">parent</a><span>|</span><a href="#41288585">prev</a><span>|</span><label class="collapse" for="c-41288138">[-]</label><label class="expand" for="c-41288138">[2 more]</label></div><br/><div class="children"><div class="content">Such as stdout or stderr that a log crate would be using?</div><br/><div id="41288233" class="c"><input type="checkbox" id="c-41288233" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41287714">root</a><span>|</span><a href="#41288138">parent</a><span>|</span><label class="collapse" for="c-41288233">[-]</label><label class="expand" for="c-41288233">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not a very clear example. You don&#x27;t need to be using multiple versions of the same dependency to contend on access to stderr&#x2F;out, just having a println in your code along with logging code will have the same effect.<p>I haven&#x27;t ever observed a problem of concurrent access to stdout&#x2F;err though, I expect because the methods for accessing stdout&#x2F;err lock them for the duration of their printing. If you Google for &quot;Rust print console slow&quot;, you&#x27;ll probably find advice to explicitly lock it, to avoid individual printlns from each acquiring the lock.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>