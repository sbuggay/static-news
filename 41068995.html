<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721984466086" as="style"/><link rel="stylesheet" href="styles.css?v=1721984466086"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://serd.es/2024/07/24/Memory-mapping-an-FPGA-from-a-STM32.html">Memory Mapping an FPGA from an STM32</a> <span class="domain">(<a href="https://serd.es">serd.es</a>)</span></div><div class="subtext"><span>hasheddan</span> | <span>57 comments</span></div><br/><div><div id="41071844" class="c"><input type="checkbox" id="c-41071844" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41073005">next</a><span>|</span><label class="collapse" for="c-41071844">[-]</label><label class="expand" for="c-41071844">[5 more]</label></div><br/><div class="children"><div class="content">I recommend checking out SpinalHDL generally - I do a ton of this very same kind of work with these same chips (7 series, US+) and would never look back to Verilog!<p>AXI (and all memory-mapped bus protocol schemes) becomes very very <i>pleasant.</i> SV interfaces get you 5% of the way there, though!<p>Also - I was under the impression that S1000-2M is a higher-end material, not cost-optimized? (But not Rogers, of course.)</div><br/><div id="41071930" class="c"><input type="checkbox" id="c-41071930" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41071844">parent</a><span>|</span><a href="#41073005">next</a><span>|</span><label class="collapse" for="c-41071930">[-]</label><label class="expand" for="c-41071930">[4 more]</label></div><br/><div class="children"><div class="content">S1000-2 is quite cheap and lossy (Df 0.016), slightly better than Isola 370HR (0.021) but nowhere near the stuff I usually use. At my usual Chinese board house it&#x27;s one of the lowest cost substrates available for prototypes since it&#x27;s always in stock and there&#x27;s no need to special order.<p>For higher end digital work I typically reach for Taiwan Union TU872SLK (Df 0.009) which also has a better range of prepregs and glass styles available to help minimize fiber weave effect. Still quite a bit lossier than e.g. RO4350B but far less expensive and if you have decent equalizers on your SERDES the difference is typically not significant unless you&#x27;re making some kind of humongous backplane. I get wide open eyes with just a tiny bit of post-cursor emphasis on the TX FFE at 10.3125 Gbps on TU872SLK for my typical shortish high speed tracks (FPGA to SFP+ cage).</div><br/><div id="41072056" class="c"><input type="checkbox" id="c-41072056" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41071844">root</a><span>|</span><a href="#41071930">parent</a><span>|</span><a href="#41072051">next</a><span>|</span><label class="collapse" for="c-41072056">[-]</label><label class="expand" for="c-41072056">[1 more]</label></div><br/><div class="children"><div class="content">Also S1000-2 is not rated&#x2F;controlled past 1GHz.  It shouldn&#x27;t vary that much so for small runs the risk is minimal.  But for volume production that&#x27;s exactly the sort of thing you never want to have to investigate in hindsight.</div><br/></div></div><div id="41072051" class="c"><input type="checkbox" id="c-41072051" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41071844">root</a><span>|</span><a href="#41071930">parent</a><span>|</span><a href="#41072056">prev</a><span>|</span><a href="#41073005">next</a><span>|</span><label class="collapse" for="c-41072051">[-]</label><label class="expand" for="c-41072051">[2 more]</label></div><br/><div class="children"><div class="content">Curious who you are using in CN for higher-speed FPGA boards, if you can share!<p>I haven&#x27;t seen these as directly-advertised options at any of my usual suspects.</div><br/><div id="41072403" class="c"><input type="checkbox" id="c-41072403" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41071844">root</a><span>|</span><a href="#41072051">parent</a><span>|</span><a href="#41073005">next</a><span>|</span><label class="collapse" for="c-41072403">[-]</label><label class="expand" for="c-41072403">[1 more]</label></div><br/><div class="children"><div class="content">Multech (multech-pcb.com) is my preferred manufacturer these days for high end stuff. I&#x27;ve done six layer HDI any-layer via stackups, ten layers with filled via-in-pad, RO4350B, TU872SLK, flex, 75 micron trace&#x2F;space, etc. And that&#x27;s nowhere near the limit of their capabilities, I just haven&#x27;t needed higher end yet.<p>I have some 25&#x2F;100G stuff in the pipe for probably some time next year that I plan to make with them too.<p>Their website undersells, I get the impression most of the actual sales contacts are word of mouth. I talk to my sales rep by skype mostly (the alternatives are expensive international phone calls or wechat).<p>The really cool thing is that you get a 10+ page QA report with every order including measured copper&#x2F;dielectric&#x2F;soldermask thicknesses, hole sizes, ionic contamination measurements, and a ton of other metrics. And they send the TDR strips and polished cross section with every order as their way of saying &quot;look, we actually did the QA, double check our measurements if you don&#x27;t trust us&quot;. (I actually have repeated some of the measurements to spot-check and got results within a few percent of their QA department, no surprises there).<p>And they don&#x27;t make silent gerber changes or anything. They do a full CAM review and send you working gerbers and a list of suggested DFM tweaks for you to sign off before beginning manufacture. If something doesn&#x27;t look right you have a chance to say &quot;wait there&#x27;s a problem&quot;.<p>For example, one time they wanted to make a really large width adjustment for impedance on some RF traces that I had carefully modeled in an EM solver. But they didn&#x27;t make a bad board without telling me, they flagged it on the CAM review and we went back and forth before realizing the mistake was on their end (they had calculated impedance assuming solder mask over the traces, while they were actually exposed copper). They re-ran the numbers which then closely matched my simulations, I signed off on the modified design, and the board was manufactured without issue.</div><br/></div></div></div></div></div></div></div></div><div id="41073005" class="c"><input type="checkbox" id="c-41073005" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41071844">prev</a><span>|</span><a href="#41071082">next</a><span>|</span><label class="collapse" for="c-41073005">[-]</label><label class="expand" for="c-41073005">[20 more]</label></div><br/><div class="children"><div class="content">Be veeeery careful. STM32H QSPI peripheral is <i>FULL OF</i> very nasty bugs, especially the second version (supports writes) that you find in STM32H0B chips . You are currently avoiding them by having QSPI mapped as device memory, but the minute you attempt to use it with cache or run code from it, or (god help you) put your stack, heap, and&#x2F;or vector table on a QSPI device, you are in for a world of poorly-debuggable 1:1,000,000 failures. STM knows but refuses to publicly acknowledge, even if they privately admit some other customers have &quot;hit similar issues&quot;. Issues I&#x27;ve found, demonstrated to them, and wrote reliable replications of:<p>* non-4-byte-sized writes randomly lost about 1&#x2F;million writes if QSPI is writeable and not cached<p>* non-4-byte-sized writes randomly rounded up in size to 2 or 4 bytes with garbage, overwriting nearby data about 1&#x2F;million writes if QSPI is writeable and cached<p>* when PC, SP, and VTOR all point to QSPI memory, any interrupt has about a 1&#x2F;million chance of reading garbage instead of the proper vector from the vector table if it interrupts a LDM&#x2F;STM instruction targeting the QSPI memory and it is cached and misses the cache<p>Some of these have workarounds that I found (contact me). I am refusing to disclose them to STM until they acknowledge the bugs publicly.<p>I recommend NOT using STM32H7 chips in any product where you want QSPI memory to work properly.</div><br/><div id="41073206" class="c"><input type="checkbox" id="c-41073206" checked=""/><div class="controls bullet"><span class="by">mystified5016</span><span>|</span><a href="#41073005">parent</a><span>|</span><a href="#41073091">next</a><span>|</span><label class="collapse" for="c-41073206">[-]</label><label class="expand" for="c-41073206">[5 more]</label></div><br/><div class="children"><div class="content">What the hell is going on at ST? Every STM uC I&#x27;ve tried to use in the past few years has had showstopper bugs with loads of very similar complaints online dating back to the release of the part. Bugs that have been in the wild for <i>years</i> and still exist in the current production run.<p>After burning enough company time chasing bugs through ST&#x27;s crappy silicon, I&#x27;ve had to just swear them off entirely. We&#x27;re an Atmel house now. Significantly fewer (zero) problems, and some pretty nifty features like UPDI.</div><br/><div id="41074745" class="c"><input type="checkbox" id="c-41074745" checked=""/><div class="controls bullet"><span class="by">anitil</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073206">parent</a><span>|</span><a href="#41073421">next</a><span>|</span><label class="collapse" for="c-41074745">[-]</label><label class="expand" for="c-41074745">[2 more]</label></div><br/><div class="children"><div class="content">It seems endemic with embedded devices. Only big customers get the true list of errata, and of course the errata are random PDFs rather than a useful format. Even just having them on an ftp site with all the errata in one spot would save so much pain!</div><br/><div id="41075076" class="c"><input type="checkbox" id="c-41075076" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41074745">parent</a><span>|</span><a href="#41073421">next</a><span>|</span><label class="collapse" for="c-41075076">[-]</label><label class="expand" for="c-41075076">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you don&#x27;t even get a PDF. Their Ethernet drivers for Cortex-M7 have been broken for years with subtle cache coherency bugs and the only discussion of it is a forum thread with now obsolete example code.</div><br/></div></div></div></div><div id="41073421" class="c"><input type="checkbox" id="c-41073421" checked=""/><div class="controls bullet"><span class="by">hmry</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073206">parent</a><span>|</span><a href="#41074745">prev</a><span>|</span><a href="#41073550">next</a><span>|</span><label class="collapse" for="c-41073421">[-]</label><label class="expand" for="c-41073421">[1 more]</label></div><br/><div class="children"><div class="content">In college, our SoC design instructor told us that to pass the class, our modules should be better than ST&#x27;s &quot;which is not that high of a bar&quot; :P</div><br/></div></div><div id="41073550" class="c"><input type="checkbox" id="c-41073550" checked=""/><div class="controls bullet"><span class="by">mips_r4300i</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073206">parent</a><span>|</span><a href="#41073421">prev</a><span>|</span><a href="#41073091">next</a><span>|</span><label class="collapse" for="c-41073550">[-]</label><label class="expand" for="c-41073550">[1 more]</label></div><br/><div class="children"><div class="content">They churn out new parts and don&#x27;t bring in fixes. See all the chips in their lineup that have a USB host controller. Every one of them (they use Synopsys IP) will fail with multiple LS devices through a hub. 
We talked to our FAE about this and they have no plans to fix it. The bug has existed for years and the bad IP is being baked into all the new chips still.
Solution? Just use yet another chip for its host controller, and don&#x27;t use a hub.</div><br/></div></div></div></div><div id="41073091" class="c"><input type="checkbox" id="c-41073091" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">parent</a><span>|</span><a href="#41073206">prev</a><span>|</span><a href="#41073133">next</a><span>|</span><label class="collapse" for="c-41073091">[-]</label><label class="expand" for="c-41073091">[8 more]</label></div><br/><div class="children"><div class="content">I have encountered issues with QSPI (mostly caused by the annoying prefetch queue) which is why I am switching to the FMC for FPGA interfacing (i.e. not using OCTOSPI). That was the whole point of this experiment, validating FMC as a replacement for my legacy OCTOSPI based MCU-APB bridge. I have a previous board using QSPI reliably in indirect mode (i.e. not memory mapped) but found it was full of pain when memory mapped specifically in writes. So that firmware memory maps it for reads but switches to indirect mode for writes. And has cache disabled.<p>So far I have it working quite reliably (my test firmware does a loopback test with 100K reads&#x2F;writes of a 32-bit register at the start that I had written with intent of using it for link training of the PLLs to optimize read&#x2F;write capture timing but never ended up using as such) and my iperf test can push tens of thousands of packets per second without issue.</div><br/><div id="41073182" class="c"><input type="checkbox" id="c-41073182" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073091">parent</a><span>|</span><a href="#41073473">next</a><span>|</span><label class="collapse" for="c-41073182">[-]</label><label class="expand" for="c-41073182">[3 more]</label></div><br/><div class="children"><div class="content">The NXP IMXRT-series chips have a similar EMC (external memory controller) as well as &quot;FlexIO&quot; - PIO-like programmable IO. I&#x27;ve used both for this kind of FPGA interface without issue.<p>The IMXRT1064 is around $7 and is also an M7 core with an HS USB PHY, programmable PLL-connected LVDS clock output, 2 EMACs, excellent hardened IP generally.</div><br/><div id="41073235" class="c"><input type="checkbox" id="c-41073235" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073182">parent</a><span>|</span><a href="#41073473">next</a><span>|</span><label class="collapse" for="c-41073235">[-]</label><label class="expand" for="c-41073235">[2 more]</label></div><br/><div class="children"><div class="content">I have some RT1176&#x27;s in my &quot;to try&quot; pile.<p>The big thing holding me back was that their crypto accelerators were all locked behind NDAs (a dealbreaker for F&#x2F;OSS work) while the ST ones are documented in the freely downloadable datasheet you can just google up.<p>But I did find some third party wrapper libraries that seemed to be able to use the crypto registers so it might be possible to figure things out from that. I haven&#x27;t tried yet.<p>The other issue I had with the RT is that they lacked internal flash so PCB complexity is slightly higher than with a STM32.</div><br/><div id="41073325" class="c"><input type="checkbox" id="c-41073325" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073235">parent</a><span>|</span><a href="#41073473">next</a><span>|</span><label class="collapse" for="c-41073325">[-]</label><label class="expand" for="c-41073325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have some RT1176&#x27;s in my &quot;to try&quot; pile.<p>Keep in mind the dual-core 11xx chips are a bit harder to boot than the rest of the line - but you probably need the power domain flexibility for most FPGA projects (1064 has way fewer practically-usable 1v8 banks.)<p>&gt; crypto accelerators were all locked behind NDAs<p>I&#x27;ve been able to use every bit of hard IP and high-assurance boot from registers using no vendor code whatsoever.<p>Here&#x27;s what you are looking for:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;JayHeng&#x2F;imxrt-level2-boot&#x2F;blob&#x2F;master&#x2F;devices&#x2F;MIMXRT1062&#x2F;drivers&#x2F;fsl_dcp.c">https:&#x2F;&#x2F;github.com&#x2F;JayHeng&#x2F;imxrt-level2-boot&#x2F;blob&#x2F;master&#x2F;dev...</a><p>&gt; The other issue I had with the RT is that they lacked internal flash<p>The IMXRT1064 has a 4MB Winbond QSPI chip in-package, by the way!<p>&gt; PCB complexity is slightly higher than with a STM32.<p>The Xilinx FPGA that is sitting next to your MCU incurs multiple orders of magnitude more PCB-complexity than a little QSPI flash, haha.</div><br/></div></div></div></div></div></div><div id="41073473" class="c"><input type="checkbox" id="c-41073473" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073091">parent</a><span>|</span><a href="#41073182">prev</a><span>|</span><a href="#41073133">next</a><span>|</span><label class="collapse" for="c-41073473">[-]</label><label class="expand" for="c-41073473">[4 more]</label></div><br/><div class="children"><div class="content">&gt; 100K reads&#x2F;writes of a 32-bit register<p>You&#x27;ll hit almost no bugs if you keep accessing the same address in a loop. Lucky you :)</div><br/><div id="41074290" class="c"><input type="checkbox" id="c-41074290" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073473">parent</a><span>|</span><a href="#41073133">next</a><span>|</span><label class="collapse" for="c-41074290">[-]</label><label class="expand" for="c-41074290">[3 more]</label></div><br/><div class="children"><div class="content">Yeah but again, we&#x27;re talking about the FMC here not the OCTOSPI.<p>Have you hit issues with the FMC? From what other people are telling me, the OCTOSPI is full of land mines and the FMC is pretty decent. The worst errata I&#x27;ve encountered so far is two dummy clocks with CS# asserted at the end of a read burst.</div><br/><div id="41074398" class="c"><input type="checkbox" id="c-41074398" checked=""/><div class="controls bullet"><span class="by">syntheticgate</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41074290">parent</a><span>|</span><a href="#41073133">next</a><span>|</span><label class="collapse" for="c-41074398">[-]</label><label class="expand" for="c-41074398">[2 more]</label></div><br/><div class="children"><div class="content">lol, I&#x27;m working on an FMC-FPGA interface at work right now and discovered this same chipselect behavior.</div><br/><div id="41074656" class="c"><input type="checkbox" id="c-41074656" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41074398">parent</a><span>|</span><a href="#41073133">next</a><span>|</span><label class="collapse" for="c-41074656">[-]</label><label class="expand" for="c-41074656">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a documented errata, 2.6.1 on page 8 of ES0491.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41073133" class="c"><input type="checkbox" id="c-41073133" checked=""/><div class="controls bullet"><span class="by">mips_r4300i</span><span>|</span><a href="#41073005">parent</a><span>|</span><a href="#41073091">prev</a><span>|</span><a href="#41073137">next</a><span>|</span><label class="collapse" for="c-41073133">[-]</label><label class="expand" for="c-41073133">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the heads up. I have a design at fab that uses the H7&#x27;s OctoSPI so this concerns me. I steered away from the memory mapped mode because it seemed too good to be true - wanted to be able to qsort() and put heaps in this extra space.<p>I suspect ST only ever tested it with their single PSRAM they intend this mode for.
My intent is to use indirect mode and manually poke the peripheral, though DMA will have to happen still.<p>Back on the PIC32MX platform there was a similar type of bug that doesn&#x27;t exist anywhere else but to me: If any interrupt fires while the PMP peripheral is doing a DMA, there is a 1 in a million chance that it will silently drop 1 byte. Noticed this because all my accesses were 32bit (4 bytes) and broke horribly at the misalignment. The solution is to disable all interupts while doing DMA.</div><br/><div id="41073413" class="c"><input type="checkbox" id="c-41073413" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073133">parent</a><span>|</span><a href="#41073137">next</a><span>|</span><label class="collapse" for="c-41073413">[-]</label><label class="expand" for="c-41073413">[1 more]</label></div><br/><div class="children"><div class="content">it is worse: i think they also did not test random access. I suspect their test was to: fill PSRAM linearly and then read it back and verify linearly. Random word accesses in unachached mode also randomly lose writes. I am unable to replicate quickly <i>on purpose</i>, only randomly, so i guess it is under 1&#x2F;100mil so it is not in my list above. My workarounds avoid these crashes too though.</div><br/></div></div></div></div><div id="41073137" class="c"><input type="checkbox" id="c-41073137" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">parent</a><span>|</span><a href="#41073133">prev</a><span>|</span><a href="#41071082">next</a><span>|</span><label class="collapse" for="c-41073137">[-]</label><label class="expand" for="c-41073137">[4 more]</label></div><br/><div class="children"><div class="content">As far as using QSPI memory, one thing I have planned (and will be thoroughly testing) is using an external SPI flash as configuration data storage. Right now if I want to store any nonvolatile settings with power loss protection I need to burn two 128 kB erase blocks (one primary and one secondary, so I can ping-pong data between them and not lose anything if I have a power loss during a write cycle or similar) of the on-chip flash, space that I&#x27;d much rather use for firmware.<p>MicroKVS expects to be able to memory map data fetches (uncached), but is fine with using indirect access for writes.</div><br/><div id="41073269" class="c"><input type="checkbox" id="c-41073269" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073137">parent</a><span>|</span><a href="#41071082">next</a><span>|</span><label class="collapse" for="c-41073269">[-]</label><label class="expand" for="c-41073269">[3 more]</label></div><br/><div class="children"><div class="content">But if I can memory map the FPGA via the FMC, I can simply put an APB memory mapped QSPI controller on the FPGA and store my config there, using the same flash for the FPGA bitstream as well.<p>This saves a chip on the board, reduces the amount of PCB routing required, and eliminates use of the sketchy OCTOSPI peripheral entirely. Testing that out is on my list of things to do on this board eventually.</div><br/><div id="41073333" class="c"><input type="checkbox" id="c-41073333" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073269">parent</a><span>|</span><a href="#41071082">next</a><span>|</span><label class="collapse" for="c-41073333">[-]</label><label class="expand" for="c-41073333">[2 more]</label></div><br/><div class="children"><div class="content">I almost always include I2C EEPROM - just too cheap and pretty easy to route.</div><br/><div id="41073455" class="c"><input type="checkbox" id="c-41073455" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41073005">root</a><span>|</span><a href="#41073333">parent</a><span>|</span><a href="#41071082">next</a><span>|</span><label class="collapse" for="c-41073455">[-]</label><label class="expand" for="c-41073455">[1 more]</label></div><br/><div class="children"><div class="content">That can&#x27;t be memory mapped, so I&#x27;d need to rewrite my KVS code which currently expects to be able to return a pointer to the raw on-flash image of the config data. Doable but a pain.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41071082" class="c"><input type="checkbox" id="c-41071082" checked=""/><div class="controls bullet"><span class="by">throwawayabcdef</span><span>|</span><a href="#41073005">prev</a><span>|</span><a href="#41072206">next</a><span>|</span><label class="collapse" for="c-41071082">[-]</label><label class="expand" for="c-41071082">[1 more]</label></div><br/><div class="children"><div class="content">This is dope. I work with Zynq&#x2F;Versal quite a bit and respect and understand (conceptually) the decisions you have made!<p>You get to own every aspect of your toolchain and with that will come a lot of power.<p>Are you familiar with:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;corundum&#x2F;corundum">https:&#x2F;&#x2F;github.com&#x2F;corundum&#x2F;corundum</a><p>Perhaps you can build a support package for your platform.</div><br/></div></div><div id="41072206" class="c"><input type="checkbox" id="c-41072206" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41071082">prev</a><span>|</span><a href="#41069781">next</a><span>|</span><label class="collapse" for="c-41072206">[-]</label><label class="expand" for="c-41072206">[1 more]</label></div><br/><div class="children"><div class="content">This is really crisp work and nice to see.  Before the Zynq era I worked with some designs that used a DSP or StrongARM along with a medium-sized FPGA, where the FPGA would be both the glue logic for RAM as well as custom peripherals, but I&#x27;ve been out of that world for a while.  It would be fun to find an application for a big FPGA and a modern microcontroller.</div><br/></div></div><div id="41069781" class="c"><input type="checkbox" id="c-41069781" checked=""/><div class="controls bullet"><span class="by">Already__Taken</span><span>|</span><a href="#41072206">prev</a><span>|</span><a href="#41071467">next</a><span>|</span><label class="collapse" for="c-41069781">[-]</label><label class="expand" for="c-41069781">[23 more]</label></div><br/><div class="children"><div class="content">real quite high level sorry, most of your embedded projects going forward are MCU+fpga to do what? I thought a custom router but 284mbps isn&#x27;t nearly fast for a network.</div><br/><div id="41070479" class="c"><input type="checkbox" id="c-41070479" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41069781">parent</a><span>|</span><a href="#41070143">next</a><span>|</span><label class="collapse" for="c-41070479">[-]</label><label class="expand" for="c-41070479">[1 more]</label></div><br/><div class="children"><div class="content">The intent is for the high performance datapath to live entirely in FPGA (and the project you&#x27;re probably thinking of is switching,  not routing).<p>The MCU is for control plane only. Several hundred Mbps between the control and data plane is more than enough for a SSH management CLI and poking registers on the FPGA to move a port to a different VLAN in response to a CLI command or add an ACL rule or something.</div><br/></div></div><div id="41070143" class="c"><input type="checkbox" id="c-41070143" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#41069781">parent</a><span>|</span><a href="#41070479">prev</a><span>|</span><a href="#41073279">next</a><span>|</span><label class="collapse" for="c-41070143">[-]</label><label class="expand" for="c-41070143">[19 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good question. A lot of FPGA projects I see (including some real life products I&#x27;ve looked into recently) don&#x27;t really need an FPGA. One I was asked to evaluate recently could easily have been done with a microcontroller with PWM outputs. The frequencies involved were well under 40MHz. Yes, there were a couple of multiplications going on in the FPGA, but there those could&#x27;ve been easily handled by a micorcontroller. An RP2040 would&#x27;ve sufficed instead of what they had - a microcontroller + an FPGA.</div><br/><div id="41070553" class="c"><input type="checkbox" id="c-41070553" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41070143">parent</a><span>|</span><a href="#41071707">next</a><span>|</span><label class="collapse" for="c-41070553">[-]</label><label class="expand" for="c-41070553">[1 more]</label></div><br/><div class="children"><div class="content">The projects in question include things like a 48 port gigabit Ethernet switch with packet datapath in the FPGA, and dual 10&#x2F;25G SFP28 uplinks. You&#x27;re not doing that on a MCU. Also higher end oscilloscope work (e.g. 10 Gsps 12-bit JESD204B)<p>But a STM32 is more than sufficient for the management interface on both.</div><br/></div></div><div id="41071707" class="c"><input type="checkbox" id="c-41071707" checked=""/><div class="controls bullet"><span class="by">rvense</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41070143">parent</a><span>|</span><a href="#41070553">prev</a><span>|</span><a href="#41073256">next</a><span>|</span><label class="collapse" for="c-41071707">[-]</label><label class="expand" for="c-41071707">[4 more]</label></div><br/><div class="children"><div class="content">I think a lot of people don&#x27;t fully appreciate how fast a modern &quot;microcontroller&quot; is. That &#x27;H735 is probably faster than every computer I had up to and including the iBook G4 I until early 2009.</div><br/><div id="41071962" class="c"><input type="checkbox" id="c-41071962" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41071707">parent</a><span>|</span><a href="#41073256">next</a><span>|</span><label class="collapse" for="c-41071962">[-]</label><label class="expand" for="c-41071962">[3 more]</label></div><br/><div class="children"><div class="content">I keep running into that also.  It&#x27;s like the common mental model of a microcontroller froze around Y2K as a sort of headless VIC-20.  I had an <i>FAE</i>, and a good one, from a major supplier tell me &quot;you can&#x27;t implement a filter&quot; on a low-end micro that was roughly as powerful as an early nineties DSP.</div><br/><div id="41073505" class="c"><input type="checkbox" id="c-41073505" checked=""/><div class="controls bullet"><span class="by">rvense</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41071962">parent</a><span>|</span><a href="#41073256">next</a><span>|</span><label class="collapse" for="c-41073505">[-]</label><label class="expand" for="c-41073505">[2 more]</label></div><br/><div class="children"><div class="content">Cortex-Ms, man. A lot of &#x27;em you just give 3.3V and a couple of bypass caps, and GCC will use the single-cycle hardware MAC (for M4 and above) if you just write the straight-forward C code and you can put it on there in 600ms with DFU. I&#x27;m a hobbyist, not an embedded wizard, but it really seems *pretty* good compared to what I understand about the old days.<p>(Like I like retro stuff and during COVID I bought an old DSP56k dev board with a book about the assembly language but oh boy, oh dear)</div><br/><div id="41073896" class="c"><input type="checkbox" id="c-41073896" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073505">parent</a><span>|</span><a href="#41073256">next</a><span>|</span><label class="collapse" for="c-41073896">[-]</label><label class="expand" for="c-41073896">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re amazing.  And - you can run a <i>PC emulator</i> on an ESP32.  Sure, you need the fancy ram.  OK.  And then people will tell me an ESP32 can&#x27;t do things that people definitely were doing on bare-bones PCs in the eighties.</div><br/></div></div></div></div></div></div></div></div><div id="41073256" class="c"><input type="checkbox" id="c-41073256" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41070143">parent</a><span>|</span><a href="#41071707">prev</a><span>|</span><a href="#41073279">next</a><span>|</span><label class="collapse" for="c-41073256">[-]</label><label class="expand" for="c-41073256">[13 more]</label></div><br/><div class="children"><div class="content">Zynq 7010s are $2.50 and are a hell of a lot more chip than an RP2040. If you already have the design (or copy one of the 50 available), it&#x27;s a good option when you don&#x27;t want to fight the chip.<p>PIO has extraordinarily sloppy timing (skew in all categories) compared to the cheapest and smallest FPGAs.</div><br/><div id="41073351" class="c"><input type="checkbox" id="c-41073351" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073256">parent</a><span>|</span><a href="#41075484">next</a><span>|</span><label class="collapse" for="c-41073351">[-]</label><label class="expand" for="c-41073351">[9 more]</label></div><br/><div class="children"><div class="content">Where are you getting them for $2.50?? The XC7Z010-1CLG225C is $74.83 at Digikey in qty 1.<p>Checking sketchier places Win-Source has the CLG400 package for $22.20 and even the cheapest aliexpress seller wants $4.84 for something marked as a 7Z010 that may or may not be legit.<p>Also &quot;fight the chip&quot; is pretty much the definition of what I did last time I did a zynq project. Just give me a plain FPGA and MCU with no wizards or GUIs or automatic code generation.</div><br/><div id="41073408" class="c"><input type="checkbox" id="c-41073408" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073351">parent</a><span>|</span><a href="#41075246">next</a><span>|</span><label class="collapse" for="c-41073408">[-]</label><label class="expand" for="c-41073408">[7 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.aliexpress.us&#x2F;item&#x2F;3256803970893483.html" rel="nofollow">https:&#x2F;&#x2F;www.aliexpress.us&#x2F;item&#x2F;3256803970893483.html</a><p>I&#x27;ve ordered trays (and they send the OEM tray) - unique barcodes, legit.<p>&gt; Just give me a plain FPGA and MCU with no wizards or GUIs or automatic code generation.<p>You can pretty much cut out all of their tools and get a pure Yocto&#x2F;Vivado TCL build for the bitstream for the 7 series Zynqs. Very low touch.<p>Their IO planner (in the Vivado IP integrator) is somewhat necessary for complex peripheral scenarios and is one of the few things I ever use Xilinx GUI applications for anymore.</div><br/><div id="41075328" class="c"><input type="checkbox" id="c-41075328" checked=""/><div class="controls bullet"><span class="by">scottapotamas</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073408">parent</a><span>|</span><a href="#41075250">next</a><span>|</span><label class="collapse" for="c-41075328">[-]</label><label class="expand" for="c-41075328">[3 more]</label></div><br/><div class="children"><div class="content">I was interested to see, or at least what state they&#x27;re in so I grabbed a couple. Might try to compare them against some genuine ones with CT and destructive inspection.<p>On the chance they&#x27;re half reasonable, thanks for the link.</div><br/><div id="41075394" class="c"><input type="checkbox" id="c-41075394" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41075328">parent</a><span>|</span><a href="#41075250">next</a><span>|</span><label class="collapse" for="c-41075394">[-]</label><label class="expand" for="c-41075394">[2 more]</label></div><br/><div class="children"><div class="content">Let me know if the barcodes are anything but unique&#x2F;perfect. This has been the case with many vendors, but these chips are cheap enough that you can try 50 vendors.</div><br/><div id="41076779" class="c"><input type="checkbox" id="c-41076779" checked=""/><div class="controls bullet"><span class="by">scottapotamas</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41075394">parent</a><span>|</span><a href="#41075250">next</a><span>|</span><label class="collapse" for="c-41076779">[-]</label><label class="expand" for="c-41076779">[1 more]</label></div><br/><div class="children"><div class="content">Will do. Not too worried about trying low cost parts to gain some minimal confidence in a possible source, they&#x27;re compelling for weekend side-projects at least.<p>I&#x27;ve previously struggled to roll the dice for higher end parts as the cost difference isn&#x27;t as extreme and had some obvious reballed parts a few years ago. If they&#x27;re OK then their $20 XC7K325T will be at the top of my list...</div><br/></div></div></div></div></div></div><div id="41075250" class="c"><input type="checkbox" id="c-41075250" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073408">parent</a><span>|</span><a href="#41075328">prev</a><span>|</span><a href="#41075541">next</a><span>|</span><label class="collapse" for="c-41075250">[-]</label><label class="expand" for="c-41075250">[1 more]</label></div><br/><div class="children"><div class="content">I don’t even find Vivado that bad, but maybe I have Stockholm syndrome. Or maybe it’s because I’m forced to use Intel Quartus right now and wish it was Vivado every time.</div><br/></div></div><div id="41075541" class="c"><input type="checkbox" id="c-41075541" checked=""/><div class="controls bullet"><span class="by">Yoofie</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073408">parent</a><span>|</span><a href="#41075250">prev</a><span>|</span><a href="#41075246">next</a><span>|</span><label class="collapse" for="c-41075541">[-]</label><label class="expand" for="c-41075541">[2 more]</label></div><br/><div class="children"><div class="content">How do you assemble your board with BGA packages? Or do you procure the parts and then send them somewhere for assembly?</div><br/><div id="41075554" class="c"><input type="checkbox" id="c-41075554" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41075541">parent</a><span>|</span><a href="#41075246">next</a><span>|</span><label class="collapse" for="c-41075554">[-]</label><label class="expand" for="c-41075554">[1 more]</label></div><br/><div class="children"><div class="content">Vapor phase reflow.</div><br/></div></div></div></div></div></div><div id="41075246" class="c"><input type="checkbox" id="c-41075246" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073351">parent</a><span>|</span><a href="#41073408">prev</a><span>|</span><a href="#41075484">next</a><span>|</span><label class="collapse" for="c-41075246">[-]</label><label class="expand" for="c-41075246">[1 more]</label></div><br/><div class="children"><div class="content">What parts do you have to fight? I’ve been using Zynqs for about almost a decade or so, and I really enjoy them. But that’s for personal projects with a lot of freedom, so I’m curious what problems arise in more commercial&#x2F;professional settings.<p>Nowadays, I only often wish I had their ARMv8 chips instead of the old ARMv7 32bit architecture because that’s just showing its age, but that’s par for the course of using ARMv7, and doesn’t affect the PL side (much, except for interfacing sometimes).</div><br/></div></div></div></div><div id="41075484" class="c"><input type="checkbox" id="c-41075484" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41073256">parent</a><span>|</span><a href="#41073351">prev</a><span>|</span><a href="#41073279">next</a><span>|</span><label class="collapse" for="c-41075484">[-]</label><label class="expand" for="c-41075484">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Zynq 7010<p>I&#x27;ve always wanted to do an FPGA project but haven&#x27;t looked seriously into where to start. Can the Zynq 7010 handle something like data transfer from a 4K image sensor to a USB 3 transceiver?<p>&gt; PIO has extraordinarily sloppy timing<p>Do you have any data on this? I was under the impression the PIO has fairly precise timing if you set up your clocks right, but maybe I&#x27;ve been misled here.</div><br/><div id="41075630" class="c"><input type="checkbox" id="c-41075630" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41075484">parent</a><span>|</span><a href="#41073279">next</a><span>|</span><label class="collapse" for="c-41075630">[-]</label><label class="expand" for="c-41075630">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can the Zynq 7010 handle something like data transfer from a 4K image sensor to a USB 3 transceiver?<p>The Zynq 7010 is less-than-ideal for this because you&#x27;d have to use some kind of USB3 interface PHY - which would increase cost and be pretty limited functionality-wise.<p>If you use an FPGA with transceivers (some 7 series Artix chips - <a href="https:&#x2F;&#x2F;www.lcsc.com&#x2F;product-detail&#x2F;Programmable-Logic-Device-CPLDs-FPGAs_AMD-XILINX-XC7A35T-2FGG484I_C1521727.html" rel="nofollow">https:&#x2F;&#x2F;www.lcsc.com&#x2F;product-detail&#x2F;Programmable-Logic-Devic...</a>, most 7 series Virtex&#x2F;Kintex chips, all US&#x2F;US+ chips), you can implement USB3 without an external PHY: <a href="https:&#x2F;&#x2F;github.com&#x2F;enjoy-digital&#x2F;usb3_pipe">https:&#x2F;&#x2F;github.com&#x2F;enjoy-digital&#x2F;usb3_pipe</a><p>The Z7010 probably has the area to do this type of translation but not the transceivers. There are other chips in the 7 series Zynq family with capable transceivers, but they are much more expensive ($15-$35 from CN).<p>&gt; I was under the impression the PIO has fairly precise timing if you set up your clocks right, but maybe I&#x27;ve been misled here.<p>No measured data, but when I was once implementing JTAG and SPI at 50MHz+ with an extremely overclocked chip, the edges were very inconsistent in relation to each other and in pulse width - 5-15ns (estimating from memory, they were sloppy.)<p>PIO is very precise within its specified capabilities, this range is just very low compared to cheap FPGAs.</div><br/><div id="41075799" class="c"><input type="checkbox" id="c-41075799" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#41069781">root</a><span>|</span><a href="#41075630">parent</a><span>|</span><a href="#41073279">next</a><span>|</span><label class="collapse" for="c-41075799">[-]</label><label class="expand" for="c-41075799">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the reply and the links! I&#x27;m okay with a more expensive FPGA chip if it significantly simplifies the implementation. I&#x27;m probably biting off more than I can chew trying to start FPGA dev with something like this, so I&#x27;ll also look into simpler starter projects.<p>&gt; PIO is very precise within its specified capabilities, this range is just very low compared to cheap FPGAs.<p>Good to know, I don&#x27;t plan on pushing RP2040s to their limit any time soon. They&#x27;re still excellent for lower speed projects.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41073279" class="c"><input type="checkbox" id="c-41073279" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#41069781">parent</a><span>|</span><a href="#41070143">prev</a><span>|</span><a href="#41070521">next</a><span>|</span><label class="collapse" for="c-41073279">[-]</label><label class="expand" for="c-41073279">[1 more]</label></div><br/><div class="children"><div class="content">Embedded projects are never about doing things as fast as computers: we have full scale computers (and routers, and firewalls, and switches) for that.<p>Embedded is about solving problems more physical in nature, as you are physically closer to reality in nearly all aspects.<p>--------<p>An MCU + FPGA project could implement... say... the VFIR IrDA (Infrared) protocol at 16Mbit.<p>Traditional IrDA is widely supported at SIR and MIR levels (upto 1.152MBit or so). Anything faster and the equipment has basically been lost to the 1990s (and never was very popular anyway).<p>IrDA I&#x27;d explain as a remote-controller on steroids. Its infrared based (like TV Remote Controllers), so you need to line up both devices and have them looking at each other. Infrared can reliably travel about 3 meters over the open air in a variety of conditions. IrDA allows for bidirectional communications. Its a truly wireless protocol, albeit one that requires significant alignment to function correctly.  But ~3 meters is good range and practical for many applications.<p>Nominally, you could use an entire MCU to handle the encoding &#x2F; decoding of these light-pulses. However, that&#x27;s a bit redundant. Its far more cost efficient to dedicate a few LUTs in an FPGA to the task.<p>Yes, the MCU is needed for the final application-level &#x2F; OSI layer 4&#x2F;5&#x2F;6&#x2F;7 aspects of IrDA protocol. But the lowest PHY and MAC levels of the protocol can and (probably) should be a small section of FPGA.<p>Upgrading from standard MCU 1MBit to 16MBit would be a 1600% improvement to communications compared to what&#x27;s readily available with commercial-off-the-shelf solutions. If you&#x27;ve determined that IR Communications is good for whatever purpose you&#x27;re using, maybe the 1600% improvement is going to be useful.<p>------------<p>EDIT: The &quot;physicality&quot; of this is because photodiodes react very quickly to light pulses. And an expensive enough transistor can amplify that at the ~100MHz speeds needed to run VFIR (at least in theory. I&#x27;ve never done this).<p>The FPGA (or MCU if you go that route...) just needs to clock at 100MHz or so, and interpret the start-of-frame and end-of-frame signals, while also interpreting a few other low-level details. Overall, this turns the sequence of light pulses into bits-and-bytes for higher-level processing (which code can and should handle).</div><br/></div></div></div></div><div id="41071467" class="c"><input type="checkbox" id="c-41071467" checked=""/><div class="controls bullet"><span class="by">chillingeffect</span><span>|</span><a href="#41069781">prev</a><span>|</span><label class="collapse" for="c-41071467">[-]</label><label class="expand" for="c-41071467">[6 more]</label></div><br/><div class="children"><div class="content">Neat!  I love that H7 chip and its gargantuan inatruction manual...  ...and you didn&#x27;t even mention its 2nd core :)</div><br/><div id="41071650" class="c"><input type="checkbox" id="c-41071650" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41071467">parent</a><span>|</span><label class="collapse" for="c-41071650">[-]</label><label class="expand" for="c-41071650">[5 more]</label></div><br/><div class="children"><div class="content">H735 is one of the single core SKUs. Just a 550 MHz M7.<p>Would not surprise me if the M4 was there and fused off (i.e. same die as multicore H7 offerings), but it&#x27;s not active.</div><br/><div id="41072913" class="c"><input type="checkbox" id="c-41072913" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41071467">root</a><span>|</span><a href="#41071650">parent</a><span>|</span><label class="collapse" for="c-41072913">[-]</label><label class="expand" for="c-41072913">[4 more]</label></div><br/><div class="children"><div class="content">Probably not. The dual-core parts are DIE450 (which is shared with some single-core parts like the H750 series!), but STM32H735 is DIE483.</div><br/><div id="41073106" class="c"><input type="checkbox" id="c-41073106" checked=""/><div class="controls bullet"><span class="by">azonenberg</span><span>|</span><a href="#41071467">root</a><span>|</span><a href="#41072913">parent</a><span>|</span><label class="collapse" for="c-41073106">[-]</label><label class="expand" for="c-41073106">[3 more]</label></div><br/><div class="children"><div class="content">I have a H735 on a retired board slated for decap so we&#x27;ll find out once I open it up.<p>Do you know if it&#x27;s fabbed in house, TSMC, or Samsung? I&#x27;ve seen ST silicon from all 3 foundries but the only thing I&#x27;ve seen stated publicly is 40nm. When I get it opened up it should be easy to tell, TSMC and Samsung processes have distinctive features on them that I recognize by sight.</div><br/><div id="41075649" class="c"><input type="checkbox" id="c-41075649" checked=""/><div class="controls bullet"><span class="by">thrtythreeforty</span><span>|</span><a href="#41071467">root</a><span>|</span><a href="#41073106">parent</a><span>|</span><a href="#41073703">next</a><span>|</span><label class="collapse" for="c-41075649">[-]</label><label class="expand" for="c-41075649">[1 more]</label></div><br/><div class="children"><div class="content">&gt; distinctive features on them that I recognize by sight<p>Now this would be a cool blog post!</div><br/></div></div><div id="41073703" class="c"><input type="checkbox" id="c-41073703" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41071467">root</a><span>|</span><a href="#41073106">parent</a><span>|</span><a href="#41075649">prev</a><span>|</span><label class="collapse" for="c-41073703">[-]</label><label class="expand" for="c-41073703">[1 more]</label></div><br/><div class="children"><div class="content">No idea - I&#x27;m reading the die IDs out of the STM32Cube DB. I haven&#x27;t looked at the silicon, but I have no reason to doubt what the DB says, especially since it confirms that a lot of allegedly different parts use the same dies.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>