<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699779654698" as="style"/><link rel="stylesheet" href="styles.css?v=1699779654698"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html">Introduction to Univalent Foundations of Mathematics with Agda</a> <span class="domain">(<a href="https://www.cs.bham.ac.uk">www.cs.bham.ac.uk</a>)</span></div><div class="subtext"><span>haltist</span> | <span>8 comments</span></div><br/><div><div id="38233319" class="c"><input type="checkbox" id="c-38233319" checked=""/><div class="controls bullet"><span class="by">neovialogistics</span><span>|</span><a href="#38235586">next</a><span>|</span><label class="collapse" for="c-38233319">[-]</label><label class="expand" for="c-38233319">[4 more]</label></div><br/><div class="children"><div class="content">I had a limited interest in exploring type theories for their own sake some time ago but it receded when I was unable to resolve, or find a resolution to, a conceptual problem that seems extremely foundational.<p>Each type theory has a hierarchy of types: 1-types, 2-types, 3.1*10^62-types, etc. but some niche type theories allow for types indexed by transfinite ordinals: ω-types, ω+5-types, I even found a construction of a theory that supports φ_α-types. There is apparently at least one very counterintuitive type theory where the hierarchy of indexable types provably continues past the proof-theoretic ordinal of the theory, somehow, but I haven&#x27;t seen it myself.<p>These have real implications of what kinds of proofs you can do with a given type theory.<p>.<p>The problem is deciding which of these theories to permit, or possibly even deciding how to decide which theories to permit, if you&#x27;ll pardon the pun. I decided to give it up and get back to PDEs.</div><br/><div id="38233649" class="c"><input type="checkbox" id="c-38233649" checked=""/><div class="controls bullet"><span class="by">turminal</span><span>|</span><a href="#38233319">parent</a><span>|</span><a href="#38236174">next</a><span>|</span><label class="collapse" for="c-38233649">[-]</label><label class="expand" for="c-38233649">[1 more]</label></div><br/><div class="children"><div class="content">I think this is on some level very much like deciding which programming language to use. It really depends on what problems you&#x27;re trying to solve and there isn&#x27;t a single one that is the best.<p>The difference is that type theories are much less of a &quot;solved&quot; problem and a lot of the variations are subject to ongoing research. As a consequence we&#x27;re still at the stage where we&#x27;re trying to figure out the &quot;deciding how to decide&quot;, as opposed to programming languages, where decision criteria are relatively well understood.</div><br/></div></div><div id="38236174" class="c"><input type="checkbox" id="c-38236174" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#38233319">parent</a><span>|</span><a href="#38233649">prev</a><span>|</span><a href="#38234109">next</a><span>|</span><label class="collapse" for="c-38236174">[-]</label><label class="expand" for="c-38236174">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of &quot;rzk: an experimental proof assistant for synthetic ∞-categories&quot; (<a href="https:&#x2F;&#x2F;rzk-lang.github.io&#x2F;rzk&#x2F;v0.6.4&#x2F;reference&#x2F;introduction.rzk&#x2F;#fn:1" rel="nofollow noreferrer">https:&#x2F;&#x2F;rzk-lang.github.io&#x2F;rzk&#x2F;v0.6.4&#x2F;reference&#x2F;introduction...</a>) and the ∞-categories paper (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1705.07442" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1705.07442</a>)</div><br/></div></div></div></div><div id="38235586" class="c"><input type="checkbox" id="c-38235586" checked=""/><div class="controls bullet"><span class="by">hackandthink</span><span>|</span><a href="#38233319">prev</a><span>|</span><a href="#38234624">next</a><span>|</span><label class="collapse" for="c-38235586">[-]</label><label class="expand" for="c-38235586">[1 more]</label></div><br/><div class="children"><div class="content">I have been trying for some time to understand what Homotopy Type Theory or Univalent Foundations is actually about.<p>The HOTT book announces a new branch of mathematics, what is it?<p>Martín Escardó addresses this directly at the beginning with his 8 points.<p>HOTT is a Martin-Löf Type Theory variant.<p>MLTT has been developing since at least 1970, so it&#x27;s not exactly brand new.<p>In contrast to First Order Logic and Zermelo Fränkel Set Theory, MLTT works with types that are constructed and applied according to certain rules.<p>Some of the rules are more logical (Cartesian product = conjunction, function = implication) some are more mathematical (induction rules, e.g. for natural numbers).<p>Martin-Löf&#x27;s innovations are the Dependent Types (corresponding to logical quantifiers) and the Identity Types.<p>Identity types have always been somewhat mysterious; equality actually seems to be the simplest thing in the world.<p>On the one hand, two expressions are equal if they have the same simplification (assuming confluence).<p>This is called definitional (extensional) equality. But there is also equality that has to be proven (differently), that is intensional equality.<p>Definitional equality implies intensional equality (the expressions are equal =&gt; their equality is proven).<p>HOTT now sees a non-trivial structure in the proofs of equality. Various equality proofs are possible. One level higher, however, there is the possibility of proving the equality of equality proof and on and on.
This is an infinity groupoid or homotopy type.<p>This results in a hierarchy of mathematical objects. At the bottom are objects whose equality is trivial (old school sets and propositions).<p>The new ones are the Higher Types, whose elements (e.g. cell complexes) are complicated set constructions in traditional mathematics.<p>For Univalence I better refer to Point 3, otherwise I would write that Univalence enables treating equal Objects as equal.</div><br/></div></div><div id="38234624" class="c"><input type="checkbox" id="c-38234624" checked=""/><div class="controls bullet"><span class="by">renke1</span><span>|</span><a href="#38235586">prev</a><span>|</span><a href="#38234790">next</a><span>|</span><label class="collapse" for="c-38234624">[-]</label><label class="expand" for="c-38234624">[1 more]</label></div><br/><div class="children"><div class="content">Although I had absolute no idea what I was doing when we played around with Agda in university, it was kind of fun constructing a few very basic proofs. It kind of felt like smashing some buttons until it worked. The Emacs integration with all the Unicode goodness was really something.</div><br/></div></div><div id="38234790" class="c"><input type="checkbox" id="c-38234790" checked=""/><div class="controls bullet"><span class="by">IngoBlechschmid</span><span>|</span><a href="#38234624">prev</a><span>|</span><label class="collapse" for="c-38234790">[-]</label><label class="expand" for="c-38234790">[1 more]</label></div><br/><div class="children"><div class="content">This is a great and well-regarded ressource!<p>If you want to experiment with Agda without installing it, you can do so directly in your browser: <a href="https:&#x2F;&#x2F;agdapad.quasicoherent.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;agdapad.quasicoherent.io&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>