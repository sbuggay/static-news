<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692867663432" as="style"/><link rel="stylesheet" href="styles.css?v=1692867663432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/@ludirehak/printing-lol-doubled-the-speed-of-my-go-code-e32e02fc3f92">Print(“lol”) doubled the speed of my Go function</a> <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>ludiludi</span> | <span>47 comments</span></div><br/><div><div id="37246086" class="c"><input type="checkbox" id="c-37246086" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#37245167">next</a><span>|</span><label class="collapse" for="c-37246086">[-]</label><label class="expand" for="c-37246086">[8 more]</label></div><br/><div class="children"><div class="content">Kind of tangential, but who are these people who are so comfortable with disassembling a high level language binary, reading assembly, and then making statements about branch prediction and other such low level esoterica? I&#x27;ve only ever meet people like that maybe two or thee times in my career, and yet it seems like every other blog post I read in certain language circles everyone is some kind of ASM and Reverse Engineering expert.</div><br/><div id="37246544" class="c"><input type="checkbox" id="c-37246544" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#37246086">parent</a><span>|</span><a href="#37246173">next</a><span>|</span><label class="collapse" for="c-37246544">[-]</label><label class="expand" for="c-37246544">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re a dying breed. We&#x27;re forgetting how to look under the hood and understand &quot;why something works&quot;.<p>Case in point, I&#x27;m slowly being replaced by Salesforce muppets for all my projects at work. They&#x27;re little code monkeys with amazon ebook type knowledge, projects cost 20x more and I look like the mad scientist for speaking the truth. The products are worse in every possible metrics, I&#x27;m not crazy. The politics at play is the reason why I&#x27;m losing ground, not logic.<p>Cabinet designers are being replaced by Ikea flat pack artists in the software world. All we can do is stand by and watch.<p>And in regards to this blog, when Medium eventually go, that knowledge will go too. Blogs have died, personal websites as well, and their ability to be found in Google is almost non-existent.</div><br/></div></div><div id="37246173" class="c"><input type="checkbox" id="c-37246173" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#37246086">parent</a><span>|</span><a href="#37246544">prev</a><span>|</span><a href="#37246134">next</a><span>|</span><label class="collapse" for="c-37246173">[-]</label><label class="expand" for="c-37246173">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;ll find that the deeper you go into &quot;traditional&quot; computer scientists, the more you&#x27;ll find the problem-solvers, hackers and tinkerers that post these types of blogs. Especially in odd cases where a random print statement doubles your profiled performance.<p>That being said, of all the people at all of the tech companies I&#x27;ve worked at, maybe ~5% of them had this sort of mentality <i>and</i> drive to execute on it.</div><br/></div></div><div id="37246134" class="c"><input type="checkbox" id="c-37246134" checked=""/><div class="controls bullet"><span class="by">buro9</span><span>|</span><a href="#37246086">parent</a><span>|</span><a href="#37246173">prev</a><span>|</span><a href="#37246123">next</a><span>|</span><label class="collapse" for="c-37246134">[-]</label><label class="expand" for="c-37246134">[3 more]</label></div><br/><div class="children"><div class="content">This feels semi-normal to me... just have the curiosity to ask &quot;why?&quot; and the bias-to-action to move to &quot;I&#x27;m going to find out&quot;.<p>You encounter far far more dead-ends than anyone ever says, and every unsolved mystery is a mild nerd snipe, an open case, that years from now you&#x27;ll see someone else explain something you realise it answers that question from years prior.<p>For me, the hard bit is not over-indexing on this... you learn things, but biasing too much for them is a sure fire way to over-engineer or increase complexity to the point where something is now worse for you knowing something. But once in a while that tiny thing you learned years before is a 20% savings across the board with associated performance increase and everyone wondering how on Earth you could possibly have made those jumps.<p>Also related... incidents. &quot;Why&quot; and &quot;I&#x27;m going to find out&quot; is the best way these things don&#x27;t recur in future. A high degree of observation and understanding is a happy engineer life as it can improve what can often be the most stressful parts of the work (on-call, etc).<p>That XKCD comic about everyone learning something for the first time factors too... there is stuff you know that others do not, share it.</div><br/><div id="37246262" class="c"><input type="checkbox" id="c-37246262" checked=""/><div class="controls bullet"><span class="by">totetsu</span><span>|</span><a href="#37246086">root</a><span>|</span><a href="#37246134">parent</a><span>|</span><a href="#37246358">next</a><span>|</span><label class="collapse" for="c-37246262">[-]</label><label class="expand" for="c-37246262">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;imgs.xkcd.com&#x2F;comics&#x2F;ten_thousand.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;imgs.xkcd.com&#x2F;comics&#x2F;ten_thousand.png</a> for those who haven&#x27;t heard of it.</div><br/></div></div><div id="37246358" class="c"><input type="checkbox" id="c-37246358" checked=""/><div class="controls bullet"><span class="by">djtango</span><span>|</span><a href="#37246086">root</a><span>|</span><a href="#37246134">parent</a><span>|</span><a href="#37246262">prev</a><span>|</span><a href="#37246123">next</a><span>|</span><label class="collapse" for="c-37246358">[-]</label><label class="expand" for="c-37246358">[1 more]</label></div><br/><div class="children"><div class="content">I remember someone saying the difference between Physics and Computer Science is that in CS we are the masters of the universe - there are no laws of Physics that bind us.<p>For me that means that in our world of computers there is infinite curiosities to discover. (Not that the same isn&#x27;t true for the natural world too)</div><br/></div></div></div></div><div id="37246123" class="c"><input type="checkbox" id="c-37246123" checked=""/><div class="controls bullet"><span class="by">distcs</span><span>|</span><a href="#37246086">parent</a><span>|</span><a href="#37246134">prev</a><span>|</span><a href="#37246112">next</a><span>|</span><label class="collapse" for="c-37246123">[-]</label><label class="expand" for="c-37246123">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;d call &quot;branch prediction&quot; as &quot;low level esoterica&quot;. It is a basic fact about how CPUs are implemented since many decades now. I learnt these things in my university coursework. Any module on CPU or computer system architecture is going to teach you all this stuff. But I&#x27;m sure you could learn these things from books on this topic too.</div><br/></div></div><div id="37246112" class="c"><input type="checkbox" id="c-37246112" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#37246086">parent</a><span>|</span><a href="#37246123">prev</a><span>|</span><a href="#37245167">next</a><span>|</span><label class="collapse" for="c-37246112">[-]</label><label class="expand" for="c-37246112">[1 more]</label></div><br/><div class="children"><div class="content">There are many ways you can get to this point (e.g. I just sort of picked this kind of thing up), but an example of a course which is designed precisely to give you these skills is Casey Muratori&#x27;s &quot;Performance-Aware Programming&quot;.</div><br/></div></div></div></div><div id="37245167" class="c"><input type="checkbox" id="c-37245167" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#37246086">prev</a><span>|</span><a href="#37245961">next</a><span>|</span><label class="collapse" for="c-37245167">[-]</label><label class="expand" for="c-37245167">[1 more]</label></div><br/><div class="children"><div class="content">Processor &quot;optimizations&quot; can produce surprising effects. The problem is these optimizations are not programmatically accessible to C (or most modern programming languages) given their simple memory model. <i>Deterministic</i> performance is not easy to obtain. My view is to not bother with such tricks unless absolutely necessary (and be prepared that your changes may actually <i>pessimize</i> performance on a future processor or a compatible processor by a different vendor).<p>If you are interested in this sort of thing, check out comp.arch!</div><br/></div></div><div id="37245961" class="c"><input type="checkbox" id="c-37245961" checked=""/><div class="controls bullet"><span class="by">Syrail_</span><span>|</span><a href="#37245167">prev</a><span>|</span><a href="#37245205">next</a><span>|</span><label class="collapse" for="c-37245961">[-]</label><label class="expand" for="c-37245961">[2 more]</label></div><br/><div class="children"><div class="content">I think this is a case of mis-assigned blame (on the tool’s part, not the author’s). My semi-educated guesswork follows:<p>Looking at the disassembly screenshots in the article, the total runtime for the benchmark doesn’t appear to have decreased by very much. “Time per op” has decreased by half in max_lol(), but the total number of ops being performed has likely increased, too - Specifically, extra work was done “for free” (As was shown in min_max).<p>This experiment is showing us that the compiler is in fact doing exactly what we want - maximizing throughput in the face of a stall by pipelining!<p>In this experiment, maxV is potentially being written to with each iteration of the loop. Valid execution of the next iteration requires us to wait on that updated value of maxV. This comparison and write takes longer than just running an instruction - it’s a stall point.<p>In the first profile, the compare instruction gets full credit for all the time the CPU is stalled waiting on that value to be written - there’s nothing else it can be doing at the time.<p>In the other profiles, we see a more “honest” picture of how long the comparison takes. After the compare instruction is done, we move on to other things which DON’T rely on knowing maxV - printing “lol”, or doing the other compare and write for minV.<p>I propose that the processor is doing our added work on every iteration of the loop, no matter what (And why not? Nothing else would be happening in that time). That BLT instruction isn’t making things faster, it’s just deciding whether to throw away the results of our extra work or keep it.<p>Throughput is important, but not always the same thing as speed. It’s good to keep that in mind with metrics like ops&#x2F;time, particularly if the benchmarking tool tries to blame stuff like cache misses or other stalls on a (relatively) innocent compare instruction!</div><br/><div id="37246043" class="c"><input type="checkbox" id="c-37246043" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#37245961">parent</a><span>|</span><a href="#37245205">next</a><span>|</span><label class="collapse" for="c-37246043">[-]</label><label class="expand" for="c-37246043">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this part seems wrong<p>&gt; Following standard practice, I use the benchstat tool to compare their speeds<p>That tool (at least as used here) would be suitable for comparing execution of <i>the same code</i> between two processors with the same architecture. For comparing different programs on the same architecture, you need a different tool that focuses on total execution time.</div><br/></div></div></div></div><div id="37245205" class="c"><input type="checkbox" id="c-37245205" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37245961">prev</a><span>|</span><a href="#37246429">next</a><span>|</span><label class="collapse" for="c-37245205">[-]</label><label class="expand" for="c-37245205">[18 more]</label></div><br/><div class="children"><div class="content">I read it and I still don&#x27;t get it, can someone (re-)explain what the presence of the print() is doing that is helpful for branch prediction (or any other aspect of the CPU)?<p>Update: It seems to be the conditional move, see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37245325">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37245325</a></div><br/><div id="37245386" class="c"><input type="checkbox" id="c-37245386" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#37245205">parent</a><span>|</span><a href="#37245250">next</a><span>|</span><label class="collapse" for="c-37245386">[-]</label><label class="expand" for="c-37245386">[1 more]</label></div><br/><div class="children"><div class="content">I read it three or four times. It&#x27;s never explained. If the print(&quot;lol&quot;) version has a branch-less-than, what does the regular version have? It must either be a branch or a conditional move, but we aren&#x27;t shown that part of the assembly. You can&#x27;t reach any conclusions about why one version is faster if you don&#x27;t know what you&#x27;re comparing to.</div><br/></div></div><div id="37245250" class="c"><input type="checkbox" id="c-37245250" checked=""/><div class="controls bullet"><span class="by">trolan</span><span>|</span><a href="#37245205">parent</a><span>|</span><a href="#37245386">prev</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245250">[-]</label><label class="expand" for="c-37245250">[15 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in school, so this may be oversimplified, but if the processor&#x2F;assembly code is predicting the next result, it gets the result faster. The processor only does this prediction with conditional branches. The extra if for printing or finding the min invoke the prediction with the accuracies stated.</div><br/><div id="37245280" class="c"><input type="checkbox" id="c-37245280" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245250">parent</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245280">[-]</label><label class="expand" for="c-37245280">[14 more]</label></div><br/><div class="children"><div class="content">&gt; The processor only does this prediction with conditional branches<p>This sounds... wrong? Unless ARM64 is designed in an absurd way?<p>I&#x27;d love to see the full disassembly; something seems funny here. If it was x86 I would say it&#x27;s a conditional move causing this, but I don&#x27;t know what&#x27;s going on on ARM.</div><br/><div id="37245325" class="c"><input type="checkbox" id="c-37245325" checked=""/><div class="controls bullet"><span class="by">fmstephe</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245280">parent</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245325">[-]</label><label class="expand" for="c-37245325">[13 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting that you say conditional move here.<p>I am confused by this behaviour, and although I definitely don&#x27;t know what the answer is here; the non-lol version does have a CSEL (<a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;dui0802&#x2F;b&#x2F;CSEL" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;dui0802&#x2F;b&#x2F;CSEL</a>) which is totally missing from the lol version.<p>Non-lol
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ds1raTYc9" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ds1raTYc9</a><p>lol
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;c3afrb6bG" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;c3afrb6bG</a></div><br/><div id="37245337" class="c"><input type="checkbox" id="c-37245337" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245325">parent</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245337">[-]</label><label class="expand" for="c-37245337">[12 more]</label></div><br/><div class="children"><div class="content">Ah there you go, that&#x27;s the conditional move on ARM. Yeah, those are slow.</div><br/><div id="37245594" class="c"><input type="checkbox" id="c-37245594" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245337">parent</a><span>|</span><a href="#37245364">next</a><span>|</span><label class="collapse" for="c-37245594">[-]</label><label class="expand" for="c-37245594">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Conditional move is slow&quot; is not the right takeaway. (In fact, conditional move can be much &#x2F;faster&#x2F; than a branch in certain circumstances (e.g. hard-to-predict branches, like binary search).)<p>The reason why this code is slow is because the conditional move is on the critical path for resolving a loop-carried data dependency. In other words, to execute the assignment `maxV = (v if (v &gt; maxV) else maxV)`, the CPU has to test v &gt; maxV. But in order to make this test, the CPU has to wait until the conditional move in the previous loop iteration finishes (to know what the new value of maxV is). So the overall execution time of the loop is worse, because each iteration depends on the previous iteration. (This is analogous to why traversing a linked list is slower than an array.)<p>However, for the branch version, there is no data dependency on the previous loop, so the CPU really can (speculatively) execute multiple loop iterations in parallel. The the next loop iteration can start before the previous finishes. And with the large reorder buffers on modern CPUs, maybe up to 4-8 loop iterations can execute in parallel!<p>On the other hand, conditional moves would be much faster for a loop like:<p><pre><code>  bigs := make([]int, len(numsA))
  for idx, v : range numsA {
    if numsA[idx] &gt; numsB[idx] {
      bigs[idx] = numsA[idx]
    } else {
      bigs[idx] = numsB[idx]
    }
  }
</code></pre>
There is no loop-carried data dependency, so the conditional moves can resolve in parallel. The above code with a conditional move is likely to be much faster than code with an equivalent branch. (And even if branches are perfectly predicted, the conditional move version will only be slightly slower, not 2X slower.)</div><br/><div id="37245725" class="c"><input type="checkbox" id="c-37245725" checked=""/><div class="controls bullet"><span class="by">fmstephe</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245594">parent</a><span>|</span><a href="#37245364">next</a><span>|</span><label class="collapse" for="c-37245725">[-]</label><label class="expand" for="c-37245725">[2 more]</label></div><br/><div class="children"><div class="content">So would you say in the general case, i.e. the compiler obviously doesn&#x27;t know how predictable a branch may be, using conditional move is a poor choice when writing to an address which is repeatedly written to inside the loop?<p>What I am trying to get a feel for, is whether this represents a bad choice of assembly in general for this kind of loop.</div><br/><div id="37245772" class="c"><input type="checkbox" id="c-37245772" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245725">parent</a><span>|</span><a href="#37245364">next</a><span>|</span><label class="collapse" for="c-37245772">[-]</label><label class="expand" for="c-37245772">[1 more]</label></div><br/><div class="children"><div class="content">Nit: If a variable&#x2F;object is only being written, that’s fine. There is a data dependency here because there is a read after a write.<p>I don’t have enough compiler knowledge to be able to definitively answer your question, but I think it would be a reasonable heuristic to favor emitting a branch over a cmov in cases where the cmov participates in a loop-carried data dependency.<p>The other advantage of emitting a branch is that branch prediction can better adapt to runtime conditions. Branch prediction tends to struggle when data is perfectly random, but most data is not. So in general it’s also reasonable for compilers to default to emitting branches.</div><br/></div></div></div></div></div></div><div id="37245364" class="c"><input type="checkbox" id="c-37245364" checked=""/><div class="controls bullet"><span class="by">fmstephe</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245337">parent</a><span>|</span><a href="#37245594">prev</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245364">[-]</label><label class="expand" for="c-37245364">[8 more]</label></div><br/><div class="children"><div class="content">Yeah, after reading the blog post I felt reasonably confident that this is a compiler bug (in terms of perf).<p>Hopefully someone with a deeper understanding can verify or discredit this here. I&#x27;m curious to see the fix for this (I assume it will generate a fix).</div><br/><div id="37245650" class="c"><input type="checkbox" id="c-37245650" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245364">parent</a><span>|</span><a href="#37245396">next</a><span>|</span><label class="collapse" for="c-37245650">[-]</label><label class="expand" for="c-37245650">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if I would classify it as a bug, but definitely a heuristic that could use tuning.<p>At least (at a high level) in LLVM, branches and cmovs are represented with the exact same construct, and one of the codegen passes looks at the condition and the two sides and heuristically determines whether to emit a branch or a cmov.<p>I don&#x27;t know how Go codegen works, but I assume they do something similar.</div><br/></div></div><div id="37245396" class="c"><input type="checkbox" id="c-37245396" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245364">parent</a><span>|</span><a href="#37245650">prev</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245396">[-]</label><label class="expand" for="c-37245396">[6 more]</label></div><br/><div class="children"><div class="content">Confused, why do you think this is a compiler bug? You should definitely expect a predictable branch to be faster than a conditional move, and the insertion of a conditional move in the original is totally sensible (albeit not intuitive if you haven&#x27;t seen it).</div><br/><div id="37245464" class="c"><input type="checkbox" id="c-37245464" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245396">parent</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245464">[-]</label><label class="expand" for="c-37245464">[5 more]</label></div><br/><div class="children"><div class="content">&gt; and the insertion of a conditional move in the original is totally sensible (albeit not intuitive if you haven&#x27;t seen it).<p>Would you mind expanding? If the conditional move isn&#x27;t needed, and given that it&#x27;s costly in terms of perfs, how is that “totally sensible” to have one here?</div><br/><div id="37245482" class="c"><input type="checkbox" id="c-37245482" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245464">parent</a><span>|</span><a href="#37245639">next</a><span>|</span><label class="collapse" for="c-37245482">[-]</label><label class="expand" for="c-37245482">[2 more]</label></div><br/><div class="children"><div class="content">The performance of branches is data-dependent. The performance of conditional moves is data-independent. In this case the branches are predictable, so they perform better here. In general, though, the compiler has no idea whether that&#x27;s the case, so it makes sense to insert a conditional move to avoid branch misprediction penalties.</div><br/><div id="37245645" class="c"><input type="checkbox" id="c-37245645" checked=""/><div class="controls bullet"><span class="by">fmstephe</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245482">parent</a><span>|</span><a href="#37245639">next</a><span>|</span><label class="collapse" for="c-37245645">[-]</label><label class="expand" for="c-37245645">[1 more]</label></div><br/><div class="children"><div class="content">This is a very good answer. Thanks.</div><br/></div></div></div></div><div id="37245639" class="c"><input type="checkbox" id="c-37245639" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245464">parent</a><span>|</span><a href="#37245482">prev</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37245639">[-]</label><label class="expand" for="c-37245639">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36623759">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36623759</a></div><br/><div id="37246147" class="c"><input type="checkbox" id="c-37246147" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#37245205">root</a><span>|</span><a href="#37245639">parent</a><span>|</span><a href="#37245591">next</a><span>|</span><label class="collapse" for="c-37246147">[-]</label><label class="expand" for="c-37246147">[1 more]</label></div><br/><div class="children"><div class="content">Thank you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37245591" class="c"><input type="checkbox" id="c-37245591" checked=""/><div class="controls bullet"><span class="by">EspressoGPT</span><span>|</span><a href="#37245205">parent</a><span>|</span><a href="#37245250">prev</a><span>|</span><a href="#37246429">next</a><span>|</span><label class="collapse" for="c-37245591">[-]</label><label class="expand" for="c-37245591">[1 more]</label></div><br/><div class="children"><div class="content">As to branch prediction, for anyone interested: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;11227902" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;11227902</a></div><br/></div></div></div></div><div id="37246429" class="c"><input type="checkbox" id="c-37246429" checked=""/><div class="controls bullet"><span class="by">zerr</span><span>|</span><a href="#37245205">prev</a><span>|</span><a href="#37246035">next</a><span>|</span><label class="collapse" for="c-37246429">[-]</label><label class="expand" for="c-37246429">[1 more]</label></div><br/><div class="children"><div class="content">No explanation whatsoever. Why the branch predictor is not &quot;invoked&quot; in the first version of the function?</div><br/></div></div><div id="37246035" class="c"><input type="checkbox" id="c-37246035" checked=""/><div class="controls bullet"><span class="by">asmor</span><span>|</span><a href="#37246429">prev</a><span>|</span><a href="#37245104">next</a><span>|</span><label class="collapse" for="c-37246035">[-]</label><label class="expand" for="c-37246035">[1 more]</label></div><br/><div class="children"><div class="content">Go can have unexpected performance differences way higher up in the stack.<p>Ask me about that one time I optimized code that was deadlocking because the Go compiler managed to not insert a Gosched[1] call into a loop transforming data that took ~30 minutes or so. The solution could&#x27;ve been to call Gosched, but optimizing the loop to a few seconds turned out to be easier.<p>I assume the inverse - the go compiler adding too many Goscheds - can happen too. It&#x27;s not that expensive - testing a condition - but if you do that a few million times, things add up.<p>[1]: <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;runtime#Gosched" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;runtime#Gosched</a></div><br/></div></div><div id="37245104" class="c"><input type="checkbox" id="c-37245104" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#37246035">prev</a><span>|</span><a href="#37245219">next</a><span>|</span><label class="collapse" for="c-37245104">[-]</label><label class="expand" for="c-37245104">[4 more]</label></div><br/><div class="children"><div class="content">Why is there a &quot;continue&quot; at all in the first code sample?<p>Edit to add: does removing it make any difference?</div><br/><div id="37245305" class="c"><input type="checkbox" id="c-37245305" checked=""/><div class="controls bullet"><span class="by">fmstephe</span><span>|</span><a href="#37245104">parent</a><span>|</span><a href="#37245148">next</a><span>|</span><label class="collapse" for="c-37245305">[-]</label><label class="expand" for="c-37245305">[1 more]</label></div><br/><div class="children"><div class="content">According to the godot compiler explorer removing the `continue` makes no difference to the generated assembly.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ds1raTYc9" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ds1raTYc9</a><p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;rbWsxM83b" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;rbWsxM83b</a><p>The `print(&quot;lol&quot;)` output looks remarkably different.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;c3afrb6bG" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;c3afrb6bG</a></div><br/></div></div><div id="37245148" class="c"><input type="checkbox" id="c-37245148" checked=""/><div class="controls bullet"><span class="by">ludiludi</span><span>|</span><a href="#37245104">parent</a><span>|</span><a href="#37245305">prev</a><span>|</span><a href="#37245219">next</a><span>|</span><label class="collapse" for="c-37245148">[-]</label><label class="expand" for="c-37245148">[2 more]</label></div><br/><div class="children"><div class="content">Good question. As you can see in the comment in the github repo, it has no effect. <a href="https:&#x2F;&#x2F;github.com&#x2F;ludi317&#x2F;max&#x2F;blob&#x2F;master&#x2F;blog&#x2F;max_test.go#L12">https:&#x2F;&#x2F;github.com&#x2F;ludi317&#x2F;max&#x2F;blob&#x2F;master&#x2F;blog&#x2F;max_test.go#...</a><p>It is there only to match the continue in the second code sample, where it is needed.</div><br/><div id="37245188" class="c"><input type="checkbox" id="c-37245188" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#37245104">root</a><span>|</span><a href="#37245148">parent</a><span>|</span><a href="#37245219">next</a><span>|</span><label class="collapse" for="c-37245188">[-]</label><label class="expand" for="c-37245188">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! In that case, I have to say I&#x27;m surprised. I assumed the code generated for the loop would have an instructions that branches, so adding <i>another</i> branching instruction could only hurt (edit: not necessarily a lot), but apparently my intuition is wrong.<p>I&#x27;m curious if the performance difference noted in the article happens on Intel&#x2F;AMD as well...</div><br/></div></div></div></div></div></div><div id="37245219" class="c"><input type="checkbox" id="c-37245219" checked=""/><div class="controls bullet"><span class="by">cyphar</span><span>|</span><a href="#37245104">prev</a><span>|</span><a href="#37245226">next</a><span>|</span><label class="collapse" for="c-37245219">[-]</label><label class="expand" for="c-37245219">[2 more]</label></div><br/><div class="children"><div class="content">In the Linux kernel, there are unlikely() and likely() macros which indicate to the compiler whether or not a condition is likely using __builtin_expect (which then influences the output assembly into producing code that should make the branch predictor do the right thing more of the time).<p>Unfortunately, the issue here is that the performance depends on the input and so such hints wouldn&#x27;t help (unless you knew a-priori you were dealing with mostly-sorted data). Presumably the min-max (and lol) versions perform worse for descending arrays?</div><br/><div id="37245313" class="c"><input type="checkbox" id="c-37245313" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#37245219">parent</a><span>|</span><a href="#37245226">next</a><span>|</span><label class="collapse" for="c-37245313">[-]</label><label class="expand" for="c-37245313">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice using these to mark less-likely, but latency sensitive, paths, which is something that profiler guided optimization can&#x27;t do.</div><br/></div></div></div></div><div id="37245226" class="c"><input type="checkbox" id="c-37245226" checked=""/><div class="controls bullet"><span class="by">zhzy0077</span><span>|</span><a href="#37245219">prev</a><span>|</span><a href="#37246064">next</a><span>|</span><label class="collapse" for="c-37245226">[-]</label><label class="expand" for="c-37245226">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a noob. Looking at the disasm: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;766aPTPc3" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;766aPTPc3</a>
It turns a CMOVQLT to a JLT. Is the blog saying CMOVQLT don&#x27;t have branch predication?
I don&#x27;t get it.</div><br/><div id="37245284" class="c"><input type="checkbox" id="c-37245284" checked=""/><div class="controls bullet"><span class="by">ludiludi</span><span>|</span><a href="#37245226">parent</a><span>|</span><a href="#37246064">next</a><span>|</span><label class="collapse" for="c-37245284">[-]</label><label class="expand" for="c-37245284">[4 more]</label></div><br/><div class="children"><div class="content">Your disasm is for x86-64. The benchmarks in the blog were run on an M1 MacBook Pro, which is an ARM64.</div><br/><div id="37245336" class="c"><input type="checkbox" id="c-37245336" checked=""/><div class="controls bullet"><span class="by">zhzy0077</span><span>|</span><a href="#37245226">root</a><span>|</span><a href="#37245284">parent</a><span>|</span><a href="#37246064">next</a><span>|</span><label class="collapse" for="c-37245336">[-]</label><label class="expand" for="c-37245336">[3 more]</label></div><br/><div class="children"><div class="content">Sorry. My bad. But looking at ARM64 <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;YEjGKce1Y" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;YEjGKce1Y</a>
The difference is CSEL and BLT. The question still stands. Does CSEL have no branch predication?</div><br/><div id="37245380" class="c"><input type="checkbox" id="c-37245380" checked=""/><div class="controls bullet"><span class="by">ludiludi</span><span>|</span><a href="#37245226">root</a><span>|</span><a href="#37245336">parent</a><span>|</span><a href="#37246064">next</a><span>|</span><label class="collapse" for="c-37245380">[-]</label><label class="expand" for="c-37245380">[2 more]</label></div><br/><div class="children"><div class="content">It appears so. <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;102374&#x2F;0101&#x2F;Program-flow---conditional-select-instructions" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;102374&#x2F;0101&#x2F;Program-...</a><p>&quot;So far, we have seen examples that use branches to handle decisions. The A64 instruction set also provides conditional select instructions. In many cases, these instructions can be used as an alternative to branches.&quot;<p>Seems CSEL is not a branch.</div><br/><div id="37245980" class="c"><input type="checkbox" id="c-37245980" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37245226">root</a><span>|</span><a href="#37245380">parent</a><span>|</span><a href="#37246064">next</a><span>|</span><label class="collapse" for="c-37245980">[-]</label><label class="expand" for="c-37245980">[1 more]</label></div><br/><div class="children"><div class="content">CSEL is a conditional move, they’re usually used to avoid branches (and branch predication) entirely.<p>Here it turns out to be a very bad choice, because it creates unnecessary data dependencies. But a cmov would be a fine choice if the branch was impossible to predict (e.g. if the input was random, well even then I’d expect the limit to mostly creep up so it should be predicated as mostly cold).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37246064" class="c"><input type="checkbox" id="c-37246064" checked=""/><div class="controls bullet"><span class="by">smcl</span><span>|</span><a href="#37245226">prev</a><span>|</span><a href="#37245426">next</a><span>|</span><label class="collapse" for="c-37246064">[-]</label><label class="expand" for="c-37246064">[1 more]</label></div><br/><div class="children"><div class="content">Does Go have any facility for providing hints to the optimiser (like how some C compilers support #pragmas) that could cause the branch-predicted instruction to be used rather than the slower one?</div><br/></div></div><div id="37245426" class="c"><input type="checkbox" id="c-37245426" checked=""/><div class="controls bullet"><span class="by">perryizgr8</span><span>|</span><a href="#37246064">prev</a><span>|</span><label class="collapse" for="c-37245426">[-]</label><label class="expand" for="c-37245426">[3 more]</label></div><br/><div class="children"><div class="content">Why would an unconditional print have any effect on whether the branch predictor is invoked or not? The if statement is there in both cases, so branch prediction should kick in for both. I didn&#x27;t find an explanation for this behaviour in the article.</div><br/><div id="37246028" class="c"><input type="checkbox" id="c-37246028" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37245426">parent</a><span>|</span><a href="#37245719">next</a><span>|</span><label class="collapse" for="c-37246028">[-]</label><label class="expand" for="c-37246028">[1 more]</label></div><br/><div class="children"><div class="content">The go compiler might have a heuristic where a branch with IO is considered cold compared to a branch without.<p>In the original, it essentially faces<p><pre><code>    If &lt;cond&gt;:
        Mov
    Else:
        Noop
</code></pre>
Considering these branches unpredictable, it generates a CMOV.<p>With<p><pre><code>    If &lt;cond&gt;:
        Mov
    Else:
        Print
</code></pre>
It now considers the first branch how and the second cold, and thus branch predication valuable, and generates a branch instead.<p>Turns out for the use case choice (1) is a misfiring, as the branch is extremely predictable, so all the conditional move does is create an unnecessary data dependency.<p>It’s not necessarily the wrong choice in general, as for unpredictable branches cmov will usually be a huge gain, they’ll incur a cycle or two of latency but save from 15+ cycles of penalty on a misredicted branch (which if the prediction only works half the time is an average 7.5 cycles per iteration).<p>You can find older posts which demonstrate that side of the coin e.g. <a href="https:&#x2F;&#x2F;owen.cafe&#x2F;posts&#x2F;six-times-faster-than-c&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;owen.cafe&#x2F;posts&#x2F;six-times-faster-than-c&#x2F;</a></div><br/></div></div><div id="37245719" class="c"><input type="checkbox" id="c-37245719" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#37245426">parent</a><span>|</span><a href="#37246028">prev</a><span>|</span><label class="collapse" for="c-37245719">[-]</label><label class="expand" for="c-37245719">[1 more]</label></div><br/><div class="children"><div class="content">It has to make a decision to jump over the print sequence or not, whereas without the print it can eliminate the branch with a conditional move and only have to predict the loop variable.  It just makes a bad guess as to whether branch prediction or conditional move will be faster, as explained above by tylerhou.</div><br/></div></div></div></div></div></div></div></div></div></body></html>