<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://josephg.com/blog/rewriting-rust/">Rewriting Rust</a> <span class="domain">(<a href="https://josephg.com">josephg.com</a>)</span></div><div class="subtext"><span>yett</span> | <span>144 comments</span></div><br/><div><div id="41656050" class="c"><input type="checkbox" id="c-41656050" checked=""/><div class="controls bullet"><span class="by">gary17the</span><span>|</span><a href="#41655235">next</a><span>|</span><label class="collapse" for="c-41656050">[-]</label><label class="expand" for="c-41656050">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The rust RFC process is a graveyard of good ideas.<p>I actually have quite an opposite view: I think the Rust core team is 100% correct to make it very hard to add new &quot;features&quot; to the PL, in order to prevent the &quot;language surface&quot; from being bloated, inconsistent and unpredictable.<p>I&#x27;ve seen this happen before: I started out as a Swift fan, even though I have been working with Objective-C++ for years, considered it an awesome powerhouse and I did not really need a new PL for anything in particular in the world of iOS development. With time, Swift&#x27;s insistence on introducing tons of new language &quot;features&quot; such as multiple, redundant function names, e.g., &quot;isMultiple(of:)&quot;, multiple rules for parsing curly braces at al. to make the SwiftUI declarative paradigm possible, multiple rules for reference and value types and mutability thereof, multiple shorthand notations such as argument names inside closures, etc. - all that made me just dump Swift altogether. I would have to focus on Swift development exclusively just to keep up, which I was not willing to do.<p>Good ideas are &quot;dime a dozen&quot;. Please keep Rust as lean as possible.</div><br/><div id="41656086" class="c"><input type="checkbox" id="c-41656086" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#41656050">parent</a><span>|</span><a href="#41655235">next</a><span>|</span><label class="collapse" for="c-41656086">[-]</label><label class="expand" for="c-41656086">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Please keep Rust as lean as possible.<p>Alternatively: Rust is already the Wagyu of somewhat-mainstream PLs, don&#x27;t keep adding fat until it&#x27;s inedible.</div><br/></div></div></div></div><div id="41655235" class="c"><input type="checkbox" id="c-41655235" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#41656050">prev</a><span>|</span><a href="#41655619">next</a><span>|</span><label class="collapse" for="c-41655235">[-]</label><label class="expand" for="c-41655235">[67 more]</label></div><br/><div class="children"><div class="content">I think the dependency situation is pretty rough, and very few folks want to admit it. An example I recently stumbled upon: the cargo-watch[0] crate.<p>At its core its a pretty simple app. I watches for file changes, and re-runs the compiler. The implementation is less than 1000 lines of code. But what happens if I vendor the dependencies? It turns out, the deps add up to almost 4 million lines of Rust code, spread across 8000+ files. For a simple file-watcher.<p>[0] <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;cargo-watch" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;cargo-watch</a></div><br/><div id="41655752" class="c"><input type="checkbox" id="c-41655752" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655311">next</a><span>|</span><label class="collapse" for="c-41655752">[-]</label><label class="expand" for="c-41655752">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what inevitably happens when you make transitive dependencies easy and you have a culture of &quot;if there&#x27;s a library for it you must use it!&quot;<p>C&#x2F;C++ are the only widely used languages without a popular npm-style package manager, and as a result most libraries are self-contained or have minimal, and often optional dependencies. efsw [1] is a 7000 lines (wc -l on the src directory) C++ FS watcher without dependencies.<p>The single-header libraries that are popular in the game programming space (stb_* [2], cgltf [3], etc) as well as of course Dear ImGui [4] have been some of the most pleasant ones I&#x27;ve ever worked with.<p>At this point I&#x27;m convinced that new package managers forbidding transitive dependencies would be an overall net gain. The biggest issue are large libraries that other ones justifiably depend on - OpenSSL, zlib, HTTP servers&#x2F;clients, maybe even async runtimes. It&#x27;s by no means an unsolvable problem, e.g. instead of having zlib as a transitive dependency, it could:<p>1. a library can still hard-depend on zlib, and just force the user to install it manually.<p>2. a library can provide generic compress&#x2F;decompress callbacks, that the user can implement with whatever.<p>3. the compress&#x2F;decompress functionality can be make standard<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;SpartanJ&#x2F;efsw">https:&#x2F;&#x2F;github.com&#x2F;SpartanJ&#x2F;efsw</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;nothings&#x2F;stb">https:&#x2F;&#x2F;github.com&#x2F;nothings&#x2F;stb</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;jkuhlmann&#x2F;cgltf">https:&#x2F;&#x2F;github.com&#x2F;jkuhlmann&#x2F;cgltf</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui">https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui</a></div><br/><div id="41655842" class="c"><input type="checkbox" id="c-41655842" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655752">parent</a><span>|</span><a href="#41655890">next</a><span>|</span><label class="collapse" for="c-41655842">[-]</label><label class="expand" for="c-41655842">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The single-header libraries that are popular in the game programming space (stb_* [2], cgltf [3], etc) as well as of course Dear ImGui have been some of the most pleasant ones I&#x27;ve ever worked with.<p>The mainstream game programming doesn&#x27;t use C at all. (Source: I had been a gamedev for almost a decade, and I mostly dealt with C# and sometimes C++ for low-level stuffs.) Even C++ is now out of fashion for at least a decade, anyone claiming that C++ is necessary for game programming is likely either an engine developer---a required, but very small portion of all gamedevs---or whoever haven&#x27;t done significant game programming recently.<p>Also, the reason that single-header libraries are rather popular in C is that otherwise they will be so, SO painful to use by the modern standard. As a result, those libraries have to be much more carefully designed than normal libraries either in C or other languages and contribute to their seemingly higher qualities. (Source: Again, I have written sizable single-header libraries in C and am aware of many issues from doing so.) I don&#x27;t think this approach is scalable in general.</div><br/></div></div><div id="41655890" class="c"><input type="checkbox" id="c-41655890" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655752">parent</a><span>|</span><a href="#41655842">prev</a><span>|</span><a href="#41655311">next</a><span>|</span><label class="collapse" for="c-41655890">[-]</label><label class="expand" for="c-41655890">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; as a result most libraries are self-contained or have minimal, and often optional dependencies</i><p>If you ignore the OS, then sure. Most C&#x2F;C++ codebases aren&#x27;t really portable however. They&#x27;re tied to UNIX, Windows or macOS, and often some specific version range of those, because they use so many APIs from the base OS. Include those and you&#x27;re up to millions of lines too.</div><br/></div></div></div></div><div id="41655311" class="c"><input type="checkbox" id="c-41655311" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655752">prev</a><span>|</span><a href="#41655559">next</a><span>|</span><label class="collapse" for="c-41655311">[-]</label><label class="expand" for="c-41655311">[20 more]</label></div><br/><div class="children"><div class="content">The fact is that dependency jungle is the prevalent way to get shit done these days. The best the runtime can do is embrace it, make it as performant and safe as possible and try to support minimum-dependency projects by having a broad std library.<p>Also I am no expert, but I think file-watchers are definitely not simple at all, especially if they are multi-platform.</div><br/><div id="41655674" class="c"><input type="checkbox" id="c-41655674" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655311">parent</a><span>|</span><a href="#41655360">next</a><span>|</span><label class="collapse" for="c-41655674">[-]</label><label class="expand" for="c-41655674">[6 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;eradman&#x2F;entr">https:&#x2F;&#x2F;github.com&#x2F;eradman&#x2F;entr</a> is<p><pre><code>    Language                     files          blank        comment           code
    -------------------------------------------------------------------------------
    C                                4            154            163            880
    Bourne Shell                     2             74             28            536
    C&#x2F;C++ Header                     4             21             66             70
    Markdown                         1             21              0             37
    YAML                             1              0              0             14
    -------------------------------------------------------------------------------
    SUM:                            12            270            257           1537
    -------------------------------------------------------------------------------
</code></pre>
including a well-designed CLI.<p>entr supports BSD, Mac OS, and Linux (even WSL). So that&#x27;s several platforms in &lt;2k lines of code. By using MATHEMATICS and EXTRAPOLATION we find that non-WSL Windows file-watching must take four million minus two thousand equals <i>calculate calculate</i> 3998000 lines of code. Ahem.<p>Though to be fair, cargo watch probably does more than just file-watching. (Should it? Is it worth the complexity? I guess that depends on where you land on the worse-is-better discussion.)</div><br/><div id="41655751" class="c"><input type="checkbox" id="c-41655751" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655674">parent</a><span>|</span><a href="#41656021">next</a><span>|</span><label class="collapse" for="c-41655751">[-]</label><label class="expand" for="c-41655751">[3 more]</label></div><br/><div class="children"><div class="content">You are comparing a bicycle and a car; while you might only need a bicycle for your daily life, they are not directly comparable.<p>BSD, Mac OS and Linux share the same interface that approximates POSIX---so it only supports a single platform with different variants. Its CLI is not well-designed, it&#x27;s just a fixed unconditional terminal sequence that even doesn&#x27;t look at $TERM and its options have no long counterpart (probably because it couldn&#x27;t use getopt_long which is a GNU extension). And cargo-watch actually parses the `cargo metadata` JSON output (guess what&#x27;s required for parsing JSON in C) and deals with ignore patterns which are consistent in syntax (guess what&#x27;s required for doing that besides from fnmatch).<p>And I&#x27;m not even meant to say that the supposed figure of 4M LoC is all required. In fact, while the problem itself does exist, I don&#x27;t think that figure is accurate at all, given the massive `windows` crate was blindly counted towards. I guess the faithful reproduction of cargo-watch without any external library will take about 20--50K lines of code in Rust <i>and in C</i>. But doing it in C would be much more painful and you will instead cut requirements.</div><br/><div id="41655863" class="c"><input type="checkbox" id="c-41655863" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655751">parent</a><span>|</span><a href="#41656021">next</a><span>|</span><label class="collapse" for="c-41655863">[-]</label><label class="expand" for="c-41655863">[2 more]</label></div><br/><div class="children"><div class="content"><i>(guess what&#x27;s required for parsing JSON in C)</i><p>Certainly nothing on the order of MLOC. Ditto for other features you listed.</div><br/><div id="41655874" class="c"><input type="checkbox" id="c-41655874" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655863">parent</a><span>|</span><a href="#41656021">next</a><span>|</span><label class="collapse" for="c-41655874">[-]</label><label class="expand" for="c-41655874">[1 more]</label></div><br/><div class="children"><div class="content">See my other comment about the inexactness of 4M LoC figure. The total amount of true dependencies would be probably a tenth of that, which <i>is</i> still large but much more believable.</div><br/></div></div></div></div></div></div><div id="41656021" class="c"><input type="checkbox" id="c-41656021" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655674">parent</a><span>|</span><a href="#41655751">prev</a><span>|</span><a href="#41655861">next</a><span>|</span><label class="collapse" for="c-41656021">[-]</label><label class="expand" for="c-41656021">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By using MATHEMATICS and EXTRAPOLATION we find that non-WSL Windows file-watching must take four million minus two thousand equals calculate calculate 3998000 lines of code<p>You joke, but Windows support is the main (probably the only?) reason why cargo-watch is huge. Rust ecosystem has some weird shit when interacting with Windows.</div><br/></div></div><div id="41655861" class="c"><input type="checkbox" id="c-41655861" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655674">parent</a><span>|</span><a href="#41656021">prev</a><span>|</span><a href="#41655360">next</a><span>|</span><label class="collapse" for="c-41655861">[-]</label><label class="expand" for="c-41655861">[1 more]</label></div><br/><div class="children"><div class="content">Note that entr doesn&#x27;t recursively watch for file changes. It has a list of files it watches for changes, but this list isn&#x27;t amended when new files are added. Fundamentally that&#x27;s a fairly small subset of proper recursive file watching. In terms of just watching files a better project to compare against is <a href="https:&#x2F;&#x2F;github.com&#x2F;inotify-tools&#x2F;inotify-tools">https:&#x2F;&#x2F;github.com&#x2F;inotify-tools&#x2F;inotify-tools</a>.</div><br/></div></div></div></div><div id="41655360" class="c"><input type="checkbox" id="c-41655360" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655311">parent</a><span>|</span><a href="#41655674">prev</a><span>|</span><a href="#41655671">next</a><span>|</span><label class="collapse" for="c-41655360">[-]</label><label class="expand" for="c-41655360">[9 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the usual response I get when I bring this issue up. &quot;file watching is actually very complicated&quot; or &quot;if you avoided deps, you&#x27;d just reimplement millions of loc yourself.<p>Forgive me if I&#x27;m making a very bold claim, but I think cross-platform file watching should not require this much code. It&#x27;s 32x larger than the Linux memory management subsystem.</div><br/><div id="41655555" class="c"><input type="checkbox" id="c-41655555" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655360">parent</a><span>|</span><a href="#41655612">next</a><span>|</span><label class="collapse" for="c-41655555">[-]</label><label class="expand" for="c-41655555">[2 more]</label></div><br/><div class="children"><div class="content">Good file watching that provides flexible primitives absolutely requires:<p>- ok, a single ext4 file inode changes, and its filename matches my hardcoded string<p>- oh, you don’t want to match against just changes to “package.json” but you want to match against a regex? voila, now you need a regex engine<p>- what about handling a directory rename? should that trigger matches on all files in the renamed directory?<p>- should the file watcher be triggered once per file, or just every 5ms? turns out this depends on your use case<p>- how do symlinks fit into this story?<p>- let’s say i want to handle once every 5ms- how do i actually wait for 5ms? do i yield the thread? do i allow other async contexts to execute while i’m waiting? how do those contexts know when to execute and when to yield back to me? now you have an async runtime with timers<p>- how does buffering work? are there limits on how many file change events can be buffered? do i dynamically allocate more memory as more file changes get buffered? now you need a vector&#x2F;arraylist implementation<p>And this is before you look at what this looks like on different platforms, or if you want polling fallbacks.<p>Can you do it with less dependencies? Probably, if you start making hard tradeoffs and adding even more complexity about what features you activate - but that only adds lines of code, it doesn’t remove them.<p>What you describe is ideologically nice, but in practice it’s over-optimizing for a goal that most people don’t really care about.</div><br/><div id="41655837" class="c"><input type="checkbox" id="c-41655837" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655555">parent</a><span>|</span><a href="#41655612">next</a><span>|</span><label class="collapse" for="c-41655837">[-]</label><label class="expand" for="c-41655837">[1 more]</label></div><br/><div class="children"><div class="content">Are you 100% sure all these cases are handled by cargo-watch?</div><br/></div></div></div></div><div id="41655612" class="c"><input type="checkbox" id="c-41655612" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655360">parent</a><span>|</span><a href="#41655555">prev</a><span>|</span><a href="#41655536">next</a><span>|</span><label class="collapse" for="c-41655612">[-]</label><label class="expand" for="c-41655612">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just file watching, that would be the watchexec crate, while cargo-watch properly integrate with cargo. Moreover cargo-watch also includes:<p>- proper CLI support, with help messages, subcommands and so on<p>- support for reading cargo&#x27;s metadata<p>- logging<p>- support for dotenv files<p>- proper shell escaping support<p>- and it seems also support for colored terminal writing.<p>Moreover both watchexec and cargo-watch end up depending on winapi, which includes binding for a lot of windows API, some which might be needed and some which not be.<p>This could also be worse if the offial windows crate by Microsoft was used (or maybe it&#x27;s already used due to some dependency, I haven&#x27;t checked), since that&#x27;s gigantic.</div><br/></div></div><div id="41655536" class="c"><input type="checkbox" id="c-41655536" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655360">parent</a><span>|</span><a href="#41655612">prev</a><span>|</span><a href="#41655435">next</a><span>|</span><label class="collapse" for="c-41655536">[-]</label><label class="expand" for="c-41655536">[1 more]</label></div><br/><div class="children"><div class="content">I think the issue of file-watching is that the libs usually support multiple implementations (with different tradeoffs and with multiple fallbacks) for file-watching with a lot of them being platform specific.</div><br/></div></div><div id="41655435" class="c"><input type="checkbox" id="c-41655435" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655360">parent</a><span>|</span><a href="#41655536">prev</a><span>|</span><a href="#41655671">next</a><span>|</span><label class="collapse" for="c-41655435">[-]</label><label class="expand" for="c-41655435">[4 more]</label></div><br/><div class="children"><div class="content">Eh. The standard library is also a gigantic dependency written entirely by volunteers.</div><br/><div id="41655590" class="c"><input type="checkbox" id="c-41655590" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655435">parent</a><span>|</span><a href="#41655521">next</a><span>|</span><label class="collapse" for="c-41655590">[-]</label><label class="expand" for="c-41655590">[2 more]</label></div><br/><div class="children"><div class="content">I am not a Rust expert but the thing with the standard libraries is that it only has peer dependencies with itself and they are all synced to the same version.<p>Meaning if you only use the std lib you:<p>1) Will never include two different versions of the same peer dependency because of incompatible version requirements.<p>2) Will usually not have two dependencies relying on two different peer-dependencies that do the same thing. This can still happen for deprecated std lib features, but tends to be a much lesser issue.<p>These two issues are usually the ones that cause dependency size explosion in projects.</div><br/></div></div><div id="41655521" class="c"><input type="checkbox" id="c-41655521" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655435">parent</a><span>|</span><a href="#41655590">prev</a><span>|</span><a href="#41655671">next</a><span>|</span><label class="collapse" for="c-41655521">[-]</label><label class="expand" for="c-41655521">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a problem with dependencies in principle. There&#x27;s a good reason for standard libraries to contain a decent amount of code. It <i>is</i> a vector for supply chain attacks, but I also have a lot of trust in the Rust maintainers. The Rust standard library is exceptionally well-written from what I&#x27;ve seen, so I&#x27;m not too worried about it.<p>FWIW I checked out the nightly toolchain, and it looks like the stdlib is less than 400k SLoC. So literally 10x smaller.</div><br/></div></div></div></div></div></div><div id="41655671" class="c"><input type="checkbox" id="c-41655671" checked=""/><div class="controls bullet"><span class="by">chillfox</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655311">parent</a><span>|</span><a href="#41655360">prev</a><span>|</span><a href="#41655550">next</a><span>|</span><label class="collapse" for="c-41655671">[-]</label><label class="expand" for="c-41655671">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I think file-watchers are definitely not simple at all&quot;<p>I don&#x27;t really know much about Rust, but I got curious and had a look at the file watching apis for windows&#x2F;linux&#x2F;macos and it really didn&#x27;t seem that complicated. Maybe a bit fiddly, but I have a hard time imagining how it could take more than 500 lines of code.<p>I would love to know where the hard part is if anyone knows of a good blog post or video about it.</div><br/></div></div><div id="41655550" class="c"><input type="checkbox" id="c-41655550" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655311">parent</a><span>|</span><a href="#41655671">prev</a><span>|</span><a href="#41655559">next</a><span>|</span><label class="collapse" for="c-41655550">[-]</label><label class="expand" for="c-41655550">[3 more]</label></div><br/><div class="children"><div class="content">&gt; try to support minimum-dependency projects by having a broad std library.<p>Since everyone depends on the standard library this will just mean everyone will depend on even more lines of code. You are decreasing the number of nominal dependencies but increasing of much code those amount to.<p>Moreover the moment the stdlib&#x27;s bundled dependency is not enough there are two problems:<p>- it can&#x27;t be changed because that would be a breaking change, so you&#x27;re stuck with the old bad implementation;<p>- you will have to use an alternative implementation in another crate, so now you&#x27;re back at the starting situation except with another dependency bundled in the stdlib.<p>Just look at the dependency situation with the python stdlib, e.g. how many versions of urllib there are.</div><br/><div id="41655633" class="c"><input type="checkbox" id="c-41655633" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655550">parent</a><span>|</span><a href="#41655559">next</a><span>|</span><label class="collapse" for="c-41655633">[-]</label><label class="expand" for="c-41655633">[2 more]</label></div><br/><div class="children"><div class="content">You do have good points as well and it depends heavily on how disciplined the std lib makers are. Go for example has a very clean and stable std lib.<p>I posted this in some other thread:<p>I am not a Rust expert but the thing with the standard libraries is that it only has peer dependencies with itself and they are all synced to the same version.
Meaning if you only use the std lib you:<p>1) Will never include two different versions of the same peer dependency because of incompatible version requirements.<p>2) Will usually not have two dependencies relying on two different peer-dependencies that do the same thing. This can still happen for deprecated std lib features, but tends to be a much lesser issue.<p>These two issues are usually the ones that cause dependency size explosion in projects.</div><br/><div id="41655722" class="c"><input type="checkbox" id="c-41655722" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655633">parent</a><span>|</span><a href="#41655559">next</a><span>|</span><label class="collapse" for="c-41655722">[-]</label><label class="expand" for="c-41655722">[1 more]</label></div><br/><div class="children"><div class="content">For 1), Cargo already take care of that if you use the same major version. Bundling dependencies in the stdlib &quot;solves&quot; the problem by making new major versions impossible.<p>This means that if a bundled dependency in the stdlib is even found to have some design issue that require breaking changes to fix then you&#x27;re out of luck. As you said the stdlib could deprecate the old version and add a new one, but then you&#x27;re just making problem 2) worse by forcing everyone to include the old deprecated dependency too! Or you could use a third-party implementation, especially if the stdlib doesn&#x27;t have the features you need, but even then you will still be including the stdlib version in your dependency graph!<p>Ultimately IMO bundling dependencies in the stdlib just makes the problem worse over time, though it can raise awareness about how to better handle them.</div><br/></div></div></div></div></div></div></div></div><div id="41655559" class="c"><input type="checkbox" id="c-41655559" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655311">prev</a><span>|</span><a href="#41655288">next</a><span>|</span><label class="collapse" for="c-41655559">[-]</label><label class="expand" for="c-41655559">[2 more]</label></div><br/><div class="children"><div class="content">I consciously remove and rewrite various dependencies at work, but I feel it&#x27;s only a half of the whole story because either 1K or 4M lines of code seem to be equally inaccurate estimates for the appropriate number of LoC for this project.<p>It seems that most dependencies of cargo-watch are pulled from three direct requirements: clap, cargo_metadata and watchexec. Clap would pull lots of CLI things that would be naturally platform-dependent, while cargo_metadata will surely pull most serde stuffs. Watchexec does have a room for improvement though, because it depends on command-group (maintained in the same org) which unconditionally requires Tokio! Who would have expected that? Once watchexec got improved on that aspect however, I think these requirements are indeed necessary for the project&#x27;s goal and any further dependency removal will probably come with some downsides.<p>A bigger problem here is that you can&#x27;t easily fix other crates&#x27; excessive dependencies. Watchexec can be surely improved, but what if other crates are stuck at the older version of watchexec? There are some cases where you can just tweak Cargo.lock to get things aligned, but generally you can&#x27;t do that. You have to live with excessive and&#x2F;or duplicate dependencies (not a huge problem by itself, so it&#x27;s default for most people) or work around with `[patch]` sections. (Cargo is actually in a better shape given that the second option is even possible at all!) In my opinion there should be some easy way to define a &quot;stand-in&quot; for given version of crate, so that such dependency issues can be more systematically worked around. But any such solution would be a huge research problem for any existing package manager.</div><br/><div id="41656089" class="c"><input type="checkbox" id="c-41656089" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655559">parent</a><span>|</span><a href="#41655288">next</a><span>|</span><label class="collapse" for="c-41656089">[-]</label><label class="expand" for="c-41656089">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s frustrating because the grand-daddy of build systems with automatic transitive dependency management -- Maven -- already had tools from day one to handle this kind of thing through excluded dependencies (a blunt instrument, but sometimes necessary). In my experience, [patch] doesn&#x27;t cut it or compare.<p>That, and the maven repository is moderated. Unlike crates.io.<p>Crates.io is a real problem. No namespaces, basically unmoderated, tons of abandoned stuff. Version hell like you&#x27;re talking about.<p>I have a hard time taking it at all seriously as a <i>professional</i> tool. And it&#x27;s only going to get worse.<p>If I were starting a Rust project from scratch inside a commercial company at this point, I&#x27;d use Bazel or Buck or GN&#x2F;Ninja and vendored dependencies. No Cargo, no crates.io.</div><br/></div></div></div></div><div id="41655288" class="c"><input type="checkbox" id="c-41655288" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655559">prev</a><span>|</span><a href="#41656091">next</a><span>|</span><label class="collapse" for="c-41655288">[-]</label><label class="expand" for="c-41655288">[8 more]</label></div><br/><div class="children"><div class="content">I bet most of those lines are from the generated windows api crates. They are notoriously monstrous</div><br/><div id="41655315" class="c"><input type="checkbox" id="c-41655315" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655288">parent</a><span>|</span><a href="#41656091">next</a><span>|</span><label class="collapse" for="c-41655315">[-]</label><label class="expand" for="c-41655315">[7 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, the windows crate alone contributes 2.2M. I wonder if there&#x27;s a way to deal with this issue.</div><br/><div id="41655422" class="c"><input type="checkbox" id="c-41655422" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655315">parent</a><span>|</span><a href="#41655350">next</a><span>|</span><label class="collapse" for="c-41655422">[-]</label><label class="expand" for="c-41655422">[4 more]</label></div><br/><div class="children"><div class="content">The exact size of the `windows` crate depends on feature flags, because parsing 2.2M lines of code is always going to be very expensive even when you immediately discard them.</div><br/><div id="41655499" class="c"><input type="checkbox" id="c-41655499" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655422">parent</a><span>|</span><a href="#41655350">next</a><span>|</span><label class="collapse" for="c-41655499">[-]</label><label class="expand" for="c-41655499">[3 more]</label></div><br/><div class="children"><div class="content">The parser is shockingly fast. The slow parts come after parsing, where we process all those function definitions and structure definitions, only to end up throwing 98% of them away.<p>A challenging architectural problem that several of us are trying to get someone nerdsniped into: inverting the dependency tree, such that you first check <i>what symbols exist</i> in a large crate like windows, then go to all the crates depending on it and see what they actually consume, then go back and only compile the bits needed for those symbols.<p>That&#x27;d be a massive improvement to compilation time, but it&#x27;s a complicated change. You&#x27;d have to either do a two-pass compilation (first to get the symbol list, then again to compile the needed symbols) or leave that instance of the compiler running and feed the list of needed symbols back into it.</div><br/><div id="41655601" class="c"><input type="checkbox" id="c-41655601" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655499">parent</a><span>|</span><a href="#41655350">next</a><span>|</span><label class="collapse" for="c-41655601">[-]</label><label class="expand" for="c-41655601">[2 more]</label></div><br/><div class="children"><div class="content">Agreed, though by &quot;parsing&quot; I meant to include easy steps like cfg checks. In fact, cfg checks should probably be done at the same time as parsing and disabled items should be discarded as soon as possible---though I don&#x27;t know whether that is already done in the current compiler, or whether it&#x27;s beneficial or even possible at all.</div><br/><div id="41655648" class="c"><input type="checkbox" id="c-41655648" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655601">parent</a><span>|</span><a href="#41655350">next</a><span>|</span><label class="collapse" for="c-41655648">[-]</label><label class="expand" for="c-41655648">[1 more]</label></div><br/><div class="children"><div class="content">We do some parsing &quot;underneath&quot; disabled cfg checks, in order to support user-friendliness features like &quot;that function you tried to call doesn&#x27;t exist, but if you enabled feature xyz then it would&quot;. But we do discard cfg-protected items before doing any subsequent heavier operations.</div><br/></div></div></div></div></div></div></div></div><div id="41655350" class="c"><input type="checkbox" id="c-41655350" checked=""/><div class="controls bullet"><span class="by">Flex247A</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655315">parent</a><span>|</span><a href="#41655422">prev</a><span>|</span><a href="#41656091">next</a><span>|</span><label class="collapse" for="c-41655350">[-]</label><label class="expand" for="c-41655350">[2 more]</label></div><br/><div class="children"><div class="content">Enabling FAT LTO reduces the final binary size but it isn&#x27;t a permanent fix.</div><br/><div id="41655377" class="c"><input type="checkbox" id="c-41655377" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655350">parent</a><span>|</span><a href="#41656091">next</a><span>|</span><label class="collapse" for="c-41655377">[-]</label><label class="expand" for="c-41655377">[1 more]</label></div><br/><div class="children"><div class="content">Not permanent how?</div><br/></div></div></div></div></div></div></div></div><div id="41656091" class="c"><input type="checkbox" id="c-41656091" checked=""/><div class="controls bullet"><span class="by">olalonde</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655288">prev</a><span>|</span><a href="#41655455">next</a><span>|</span><label class="collapse" for="c-41656091">[-]</label><label class="expand" for="c-41656091">[2 more]</label></div><br/><div class="children"><div class="content">Why do you care how many lines of code the dependencies are? Compile time? Lack of disk space?</div><br/><div id="41656129" class="c"><input type="checkbox" id="c-41656129" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41656091">parent</a><span>|</span><a href="#41655455">next</a><span>|</span><label class="collapse" for="c-41656129">[-]</label><label class="expand" for="c-41656129">[1 more]</label></div><br/><div class="children"><div class="content">Some of us like to understand what&#x27;s happening in the software we work on, and don&#x27;t appreciate unnecessary complexity or unknown paths in the codebase that come through third party transitive dependencies.<p>Some of us have licensing restrictions we have to adhere to.<p>Some of us are very concerned about security and the potential problems of unaudited or unmoderated code that comes in through a long dependency chain.<p>Hard learned lessons through years of dealing with this kind of thing: good software projects try to minimize the size of their impact crater.</div><br/></div></div></div></div><div id="41655455" class="c"><input type="checkbox" id="c-41655455" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41656091">prev</a><span>|</span><a href="#41656010">next</a><span>|</span><label class="collapse" for="c-41655455">[-]</label><label class="expand" for="c-41655455">[4 more]</label></div><br/><div class="children"><div class="content">Why, concretely, does this matter?<p>Other than people who care about relatively obscure concerns like distro packaging, nobody is impeded in their work in any practical way by crates having a lot of transitive dependencies.</div><br/><div id="41655574" class="c"><input type="checkbox" id="c-41655574" checked=""/><div class="controls bullet"><span class="by">zifpanachr23</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655455">parent</a><span>|</span><a href="#41656010">next</a><span>|</span><label class="collapse" for="c-41655574">[-]</label><label class="expand" for="c-41655574">[3 more]</label></div><br/><div class="children"><div class="content">Because for a lot of companies, especially ones in industries that Rust is supposedly hoping to displace C and C++ in, dependencies are a much larger concern than memory safety. They slow down velocity way more than running massive amounts of static and dynamic analysis tools to detect memory issues does in C. Every dependency is going to need explicit approval. And frankly, most crates would never receive that approval given the typical quality of a lot of the small utility crates and other transitive dependencies. Not to mention, the amount of transitive dependencies and their size in a lot of popular crates makes them functionally unauditable.<p>This more than any other issue is I think what prevents Rust adoption outside of more liberal w.r.t dependencies companies in big tech and web parts of the economy.<p>This is actually one positive in my view behind the rather unwieldy process of using dependencies and building C&#x2F;C++ projects. There&#x27;s a much bigger culture of care and minimalism w.r.t. choosing to take on a dependency in open source projects.<p>Fwiw, the capabilities feature described in the post would go a very long way towards alleviating this issue.</div><br/><div id="41655807" class="c"><input type="checkbox" id="c-41655807" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655574">parent</a><span>|</span><a href="#41655714">next</a><span>|</span><label class="collapse" for="c-41655807">[-]</label><label class="expand" for="c-41655807">[1 more]</label></div><br/><div class="children"><div class="content">Those companies can just ban using new rust dependencies, if they want to. Writing with minimal dependencies is just as easy in rust as it is in c++</div><br/></div></div><div id="41655714" class="c"><input type="checkbox" id="c-41655714" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655574">parent</a><span>|</span><a href="#41655807">prev</a><span>|</span><a href="#41656010">next</a><span>|</span><label class="collapse" for="c-41655714">[-]</label><label class="expand" for="c-41655714">[1 more]</label></div><br/><div class="children"><div class="content">Does C++ codebases with similar features parity somehow requires less code?</div><br/></div></div></div></div></div></div><div id="41656010" class="c"><input type="checkbox" id="c-41656010" checked=""/><div class="controls bullet"><span class="by">tbillington</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655455">prev</a><span>|</span><a href="#41655255">next</a><span>|</span><label class="collapse" for="c-41656010">[-]</label><label class="expand" for="c-41656010">[1 more]</label></div><br/><div class="children"><div class="content">vendor + linecount unfortunately doesn&#x27;t represent an accurate number of what cargo-watch would actually use. It includes all platform specific code behind compile time toggles even though only one would be used at any particular time, and doesn&#x27;t account for the code not included because the feature wasn&#x27;t enabled. <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;features.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;features.html</a><p>whether those factors impact how you view the result of linecount is subjective<p>also as one of the other commenters mentioned, cargo watch does more than just file watching</div><br/></div></div><div id="41655255" class="c"><input type="checkbox" id="c-41655255" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41656010">prev</a><span>|</span><a href="#41655397">next</a><span>|</span><label class="collapse" for="c-41655255">[-]</label><label class="expand" for="c-41655255">[6 more]</label></div><br/><div class="children"><div class="content">Maybe they can learn from the Javascript folks, I heard they&#x27;re very good at this.</div><br/><div id="41655437" class="c"><input type="checkbox" id="c-41655437" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655255">parent</a><span>|</span><a href="#41655370">next</a><span>|</span><label class="collapse" for="c-41655437">[-]</label><label class="expand" for="c-41655437">[1 more]</label></div><br/><div class="children"><div class="content">I think the interaction between both communities is exactly the reason of the current state.</div><br/></div></div><div id="41655370" class="c"><input type="checkbox" id="c-41655370" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655255">parent</a><span>|</span><a href="#41655437">prev</a><span>|</span><a href="#41655355">next</a><span>|</span><label class="collapse" for="c-41655370">[-]</label><label class="expand" for="c-41655370">[2 more]</label></div><br/><div class="children"><div class="content">Yes, unironically they’re now.<p>Node has improved greatly in last two years. They always had native JSON support. Now have native test runner, watch, fetch, working on permission system à la deno, added WebSockets and working on native SQLite driver. All of this makes it a really attractive platform for prototyping which scales from hello world without any dependencies to production.<p>Good luck experimenting with Rust without pulling half the internet with it.<p>E: and they’re working on native TS support</div><br/><div id="41655891" class="c"><input type="checkbox" id="c-41655891" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655370">parent</a><span>|</span><a href="#41655355">next</a><span>|</span><label class="collapse" for="c-41655891">[-]</label><label class="expand" for="c-41655891">[1 more]</label></div><br/><div class="children"><div class="content">&gt; without any dependencies<p>Nah, you still have those dependencies, they&#x27;re just integrated in your interpreter. That has advantages (you&#x27;re now only trusting a single source) and disadvantages (you always get all the goodies and the associated risks with that, even if you don&#x27;t need them).</div><br/></div></div></div></div><div id="41655355" class="c"><input type="checkbox" id="c-41655355" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655255">parent</a><span>|</span><a href="#41655370">prev</a><span>|</span><a href="#41655384">next</a><span>|</span><label class="collapse" for="c-41655355">[-]</label><label class="expand" for="c-41655355">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if you&#x27;re serious and talking about tree-shaking - or joking and talking about left-pad.</div><br/></div></div><div id="41655384" class="c"><input type="checkbox" id="c-41655384" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655255">parent</a><span>|</span><a href="#41655355">prev</a><span>|</span><a href="#41655397">next</a><span>|</span><label class="collapse" for="c-41655384">[-]</label><label class="expand" for="c-41655384">[1 more]</label></div><br/><div class="children"><div class="content">No, they are the worst perpetrators re dependency hell.</div><br/></div></div></div></div><div id="41655397" class="c"><input type="checkbox" id="c-41655397" checked=""/><div class="controls bullet"><span class="by">nullifidian</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655255">prev</a><span>|</span><a href="#41655337">next</a><span>|</span><label class="collapse" for="c-41655397">[-]</label><label class="expand" for="c-41655397">[1 more]</label></div><br/><div class="children"><div class="content">Some amount of the risk from the &quot;dependency jungle&quot; situation could be alleviated by instituting &quot;trusted&quot; set of crates that are selected based on some popularity threshold, and with a rolling-release linux-distro-like stabilization chain, graduating from &quot;testing&quot; to &quot;stable&quot;. If the Rust Foundation raised more money from the large companies, and hired devs to work as additional maintainers for these key crates, adding their signed-offs, it would be highly beneficial. That would have been a naturally evolving and changing equivalent to an extensive standard library. Mandating at least two maintainer sign offs for such critical set of crates would have been a good policy. Instead the large companies that use rust prefer to vet the crates on their own individually, duplicating the work the other companies do.<p>The fact that nothing has changed in the NPM and Python worlds indicates that market forces pressure the decision makers to prefer the more risky approach, which prioritizes growth and fast iteration.</div><br/></div></div><div id="41655337" class="c"><input type="checkbox" id="c-41655337" checked=""/><div class="controls bullet"><span class="by">moss2</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655397">prev</a><span>|</span><a href="#41655363">next</a><span>|</span><label class="collapse" for="c-41655337">[-]</label><label class="expand" for="c-41655337">[3 more]</label></div><br/><div class="children"><div class="content">Same problem with JavaScript&#x27;s NPM. And Python&#x27;s PIP.</div><br/><div id="41655507" class="c"><input type="checkbox" id="c-41655507" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655337">parent</a><span>|</span><a href="#41655363">next</a><span>|</span><label class="collapse" for="c-41655507">[-]</label><label class="expand" for="c-41655507">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t necessarily a language problem, though, more of a &quot;culture&quot; problem, I think.<p>I write in Clojure and I take great pains to avoid introducing dependencies. Contrary to the popular mantra, I will sometimes implement functionality instead of using a library, when the functionality is simple, or when the intersection area with the application is large (e.g. the library doesn&#x27;t bring as many benefits as just using a &quot;black box&quot;). I will work to reduce my dependencies, and I will also carefully check if a library isn&#x27;t just simple &quot;glue code&quot; (for example, for underlying Java functionality).<p>This approach can be used with any language, it just needs to be pervasive in the culture.</div><br/><div id="41655999" class="c"><input type="checkbox" id="c-41655999" checked=""/><div class="controls bullet"><span class="by">orwin</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655507">parent</a><span>|</span><a href="#41655363">next</a><span>|</span><label class="collapse" for="c-41655999">[-]</label><label class="expand" for="c-41655999">[1 more]</label></div><br/><div class="children"><div class="content">I think this is made easier with Clojure macro capacity. In general, if you have powerfull metaprogramming tools, you trade dependency complexity with peace of mind (I still have flashbacks of C++ templates when i talk about metaprogramming :&#x2F;. Does this qualify for PTSD?).</div><br/></div></div></div></div></div></div><div id="41655363" class="c"><input type="checkbox" id="c-41655363" checked=""/><div class="controls bullet"><span class="by">armitron</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655337">prev</a><span>|</span><a href="#41655275">next</a><span>|</span><label class="collapse" for="c-41655363">[-]</label><label class="expand" for="c-41655363">[11 more]</label></div><br/><div class="children"><div class="content">This is the main reason we have banned Rust across my Org. Every third party library needs to be audited before being introduced as a vendored dependency which   
is not easy to do with the bloated dependency chains that Cargo promotes.</div><br/><div id="41655465" class="c"><input type="checkbox" id="c-41655465" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655363">parent</a><span>|</span><a href="#41655502">next</a><span>|</span><label class="collapse" for="c-41655465">[-]</label><label class="expand" for="c-41655465">[1 more]</label></div><br/><div class="children"><div class="content">The dependency hell issue is not directly related to Rust. The Rust language can be used without using any dependency. Have you banned javascript and python too?</div><br/></div></div><div id="41655502" class="c"><input type="checkbox" id="c-41655502" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655363">parent</a><span>|</span><a href="#41655465">prev</a><span>|</span><a href="#41656046">next</a><span>|</span><label class="collapse" for="c-41655502">[-]</label><label class="expand" for="c-41655502">[3 more]</label></div><br/><div class="children"><div class="content">Good on you, this approach will keep you employed for a looooooooong time, because someone has to write all that code then, right? ;)</div><br/><div id="41655593" class="c"><input type="checkbox" id="c-41655593" checked=""/><div class="controls bullet"><span class="by">mu53</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655502">parent</a><span>|</span><a href="#41656046">next</a><span>|</span><label class="collapse" for="c-41655593">[-]</label><label class="expand" for="c-41655593">[2 more]</label></div><br/><div class="children"><div class="content">TBH, I have adjusted my programming recently to write more stuff myself instead of finding a library. Its not that bad. I think ChatGPT are really good at these at those types of questions since it can analyze multiple from github and give you an answer averaging them together.<p>Also, if you just have a really well defined problem, its easy to just whip out 10-50 lines to solve the issue and be done with it</div><br/><div id="41655766" class="c"><input type="checkbox" id="c-41655766" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655593">parent</a><span>|</span><a href="#41656046">next</a><span>|</span><label class="collapse" for="c-41655766">[-]</label><label class="expand" for="c-41655766">[1 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s how you end up with solutions that don&#x27;t handle edge cases.</div><br/></div></div></div></div></div></div><div id="41656046" class="c"><input type="checkbox" id="c-41656046" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655363">parent</a><span>|</span><a href="#41655502">prev</a><span>|</span><a href="#41655443">next</a><span>|</span><label class="collapse" for="c-41656046">[-]</label><label class="expand" for="c-41656046">[1 more]</label></div><br/><div class="children"><div class="content">Why ban Rust instead of just banning Cargo?<p>It&#x27;s entirely possible to use Rust with other build systems, with vendored dependencies.<p>Crates.io is a blight. But the language is fine.</div><br/></div></div><div id="41655443" class="c"><input type="checkbox" id="c-41655443" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655363">parent</a><span>|</span><a href="#41656046">prev</a><span>|</span><a href="#41655582">next</a><span>|</span><label class="collapse" for="c-41655443">[-]</label><label class="expand" for="c-41655443">[3 more]</label></div><br/><div class="children"><div class="content">How do you solve this for other languages you use?</div><br/><div id="41655523" class="c"><input type="checkbox" id="c-41655523" checked=""/><div class="controls bullet"><span class="by">armitron</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655443">parent</a><span>|</span><a href="#41655582">next</a><span>|</span><label class="collapse" for="c-41655523">[-]</label><label class="expand" for="c-41655523">[2 more]</label></div><br/><div class="children"><div class="content">Our main languages are Go and OCaml. We can leverage third party libraries without easily running into transitive dependency hell as there’s an implicit understanding in these communities that large number of dependencies is not a good thing. Or, expressed differently, there is coarser granularity in what ends up being a library. This is not the case with Cargo which has decided to follow the NPM approach.</div><br/><div id="41655636" class="c"><input type="checkbox" id="c-41655636" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655523">parent</a><span>|</span><a href="#41655582">next</a><span>|</span><label class="collapse" for="c-41655636">[-]</label><label class="expand" for="c-41655636">[1 more]</label></div><br/><div class="children"><div class="content">At least in my experience, Go packages and Rust crates are much coarser than NPM packages. (Look at actual direct and indirect dependencies in cargo-watch to judge it by yourself.) I think Go prefers and actually has resource to keep mostly centralized approaches, while Rust crates are heavily distributed and it takes longer for the majority to settle on a single solution.</div><br/></div></div></div></div></div></div><div id="41655582" class="c"><input type="checkbox" id="c-41655582" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655363">parent</a><span>|</span><a href="#41655443">prev</a><span>|</span><a href="#41655454">next</a><span>|</span><label class="collapse" for="c-41655582">[-]</label><label class="expand" for="c-41655582">[1 more]</label></div><br/><div class="children"><div class="content">This is what lockfiles are for.</div><br/></div></div><div id="41655454" class="c"><input type="checkbox" id="c-41655454" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655363">parent</a><span>|</span><a href="#41655582">prev</a><span>|</span><a href="#41655275">next</a><span>|</span><label class="collapse" for="c-41655454">[-]</label><label class="expand" for="c-41655454">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, but that feels like an incredibly poorly informed decision.<p>One thing is to decide to vendor everything - that&#x27;s your prerogative - but it&#x27;s very likely that pulling everything in also pulls in tons of stuff that you aren&#x27;t using, because recursively vendoring dependencies means you are also pulling in dev-dependencies, optional dependencies (including default-off features), and so on.<p>For the things you do use, is it the number of crates that is the problem, or the amount of code? Because if the alternative is to develop it in-house, then...<p>The alternative here is to include a lot of things in the standard library that doesn&#x27;t belong there, because people seem to exclude standard libraries from their auditing, which is reasonable. Why is it not just as reasonable to exclude certain widespread ecosystem crates from auditing?</div><br/></div></div></div></div><div id="41655275" class="c"><input type="checkbox" id="c-41655275" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655363">prev</a><span>|</span><a href="#41655442">next</a><span>|</span><label class="collapse" for="c-41655275">[-]</label><label class="expand" for="c-41655275">[4 more]</label></div><br/><div class="children"><div class="content">What do you propose? To include it as part of std? Are you insane? That would bloat your binaries! (Still don’t understand how the smart compiler isn’t smart enough to remove dead code) 
And imagine if there’s an update that makes cargo-watch not BlAzInGlY fAsT™ but uLtRa BlAzInGlY fAsT™? &#x2F;s</div><br/><div id="41655373" class="c"><input type="checkbox" id="c-41655373" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655275">parent</a><span>|</span><a href="#41655442">next</a><span>|</span><label class="collapse" for="c-41655373">[-]</label><label class="expand" for="c-41655373">[3 more]</label></div><br/><div class="children"><div class="content">How does Go compare?<p>I&#x27;m curious as I don&#x27;t know Go but it often gets mentioned here on HN as very lightweight.<p>(A quick googling finds <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;search?q=watch" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;search?q=watch</a> which makes me think that it&#x27;s not any different?)</div><br/><div id="41655425" class="c"><input type="checkbox" id="c-41655425" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655373">parent</a><span>|</span><a href="#41655442">next</a><span>|</span><label class="collapse" for="c-41655425">[-]</label><label class="expand" for="c-41655425">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;std" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;std</a><p>They’re much better.</div><br/><div id="41656095" class="c"><input type="checkbox" id="c-41656095" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655235">root</a><span>|</span><a href="#41655425">parent</a><span>|</span><a href="#41655442">next</a><span>|</span><label class="collapse" for="c-41656095">[-]</label><label class="expand" for="c-41656095">[1 more]</label></div><br/><div class="children"><div class="content">I recall that I was very surprised to hear that Go standard library has extensive cryptographic stuffs. Generally that would be very unwise because they will become much harder to change or remove in spite of security issues. Turns out that this particular portion would be maintained by other maintainers who are actually trained in cryptography and security---something almost any other languages wouldn&#x27;t be able to do with their resources.</div><br/></div></div></div></div></div></div></div></div><div id="41655442" class="c"><input type="checkbox" id="c-41655442" checked=""/><div class="controls bullet"><span class="by">TechDebtDevin</span><span>|</span><a href="#41655235">parent</a><span>|</span><a href="#41655275">prev</a><span>|</span><a href="#41655619">next</a><span>|</span><label class="collapse" for="c-41655442">[-]</label><label class="expand" for="c-41655442">[1 more]</label></div><br/><div class="children"><div class="content">You fuck around...</div><br/></div></div></div></div><div id="41655619" class="c"><input type="checkbox" id="c-41655619" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#41655235">prev</a><span>|</span><a href="#41655200">next</a><span>|</span><label class="collapse" for="c-41655619">[-]</label><label class="expand" for="c-41655619">[2 more]</label></div><br/><div class="children"><div class="content">Rust isn&#x27;t an Exciting New Language any more. It&#x27;s in the &quot;work towards widespread adoption&quot; phase. Slower feature development is natural and healthy, the stakes are high, mistaken design choices are much more harmful than low velocity at this point.<p>I&#x27;m not excited about Rust because of cool features, I&#x27;m excited because it&#x27;s a whole new CLASS of language (memory safe, no GC, production ready). Actually getting it into the places that matter is way more interesting to me than making it a better language. That&#x27;s easier to achieve if people are comfortable that the project is being steered with a degree of caution.</div><br/><div id="41655996" class="c"><input type="checkbox" id="c-41655996" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41655619">parent</a><span>|</span><a href="#41655200">next</a><span>|</span><label class="collapse" for="c-41655996">[-]</label><label class="expand" for="c-41655996">[1 more]</label></div><br/><div class="children"><div class="content">Maybe. But javascript is arguably in that phase of its life as well, and JS has had a oodles of wonderful new features added in the last decade. Features like the spread operator, generator functions, async, arrow functions, leftpad, a new Date, and so on. The list of significant new features is endless.<p>All that, despite JS being much older than rust, and much more widely used. Javascript also has several production implementations - which presumably all need to agree to implement any new features.<p>Javascript had a period of stagnation around ES5. The difference seems to be that the ecmascript standards committee got their act together.</div><br/></div></div></div></div><div id="41655200" class="c"><input type="checkbox" id="c-41655200" checked=""/><div class="controls bullet"><span class="by">knighthack</span><span>|</span><a href="#41655619">prev</a><span>|</span><a href="#41655395">next</a><span>|</span><label class="collapse" for="c-41655200">[-]</label><label class="expand" for="c-41655200">[9 more]</label></div><br/><div class="children"><div class="content">Since Rustaceans are so neurotic about rewriting everything in Rust, I genuinely thought that an article about rewriting Rust (in Rust) had to be a meta-satirical joke.</div><br/><div id="41655775" class="c"><input type="checkbox" id="c-41655775" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41655200">parent</a><span>|</span><a href="#41656000">next</a><span>|</span><label class="collapse" for="c-41655775">[-]</label><label class="expand" for="c-41655775">[1 more]</label></div><br/><div class="children"><div class="content">That happened already way back in the prehistory :)<p>Originally Rust was written in OCaml, but eventually it got rewritten in Rust</div><br/></div></div><div id="41656000" class="c"><input type="checkbox" id="c-41656000" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41655200">parent</a><span>|</span><a href="#41655775">prev</a><span>|</span><a href="#41655566">next</a><span>|</span><label class="collapse" for="c-41656000">[-]</label><label class="expand" for="c-41656000">[1 more]</label></div><br/><div class="children"><div class="content">Author here. That was the reference I was going for with the title :D</div><br/></div></div><div id="41655566" class="c"><input type="checkbox" id="c-41655566" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#41655200">parent</a><span>|</span><a href="#41656000">prev</a><span>|</span><a href="#41655824">next</a><span>|</span><label class="collapse" for="c-41655566">[-]</label><label class="expand" for="c-41655566">[5 more]</label></div><br/><div class="children"><div class="content">They want you (us?) to rewrite everything in Rust. Not them.</div><br/><div id="41655762" class="c"><input type="checkbox" id="c-41655762" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41655200">root</a><span>|</span><a href="#41655566">parent</a><span>|</span><a href="#41655824">next</a><span>|</span><label class="collapse" for="c-41655762">[-]</label><label class="expand" for="c-41655762">[4 more]</label></div><br/><div class="children"><div class="content">Who is &quot;they&quot;? Seriously, who?</div><br/><div id="41655962" class="c"><input type="checkbox" id="c-41655962" checked=""/><div class="controls bullet"><span class="by">SenorKimchi</span><span>|</span><a href="#41655200">root</a><span>|</span><a href="#41655762">parent</a><span>|</span><a href="#41655800">next</a><span>|</span><label class="collapse" for="c-41655962">[-]</label><label class="expand" for="c-41655962">[2 more]</label></div><br/><div class="children"><div class="content">The Rust Evangelism Strike Force</div><br/><div id="41655978" class="c"><input type="checkbox" id="c-41655978" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41655200">root</a><span>|</span><a href="#41655962">parent</a><span>|</span><a href="#41655800">next</a><span>|</span><label class="collapse" for="c-41655978">[-]</label><label class="expand" for="c-41655978">[1 more]</label></div><br/><div class="children"><div class="content">Are They in the room with us?</div><br/></div></div></div></div><div id="41655800" class="c"><input type="checkbox" id="c-41655800" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#41655200">root</a><span>|</span><a href="#41655762">parent</a><span>|</span><a href="#41655962">prev</a><span>|</span><a href="#41655824">next</a><span>|</span><label class="collapse" for="c-41655800">[-]</label><label class="expand" for="c-41655800">[1 more]</label></div><br/><div class="children"><div class="content">The parent comment referred to &quot;Rustaceans&quot;. Check the first two words.</div><br/></div></div></div></div></div></div><div id="41655824" class="c"><input type="checkbox" id="c-41655824" checked=""/><div class="controls bullet"><span class="by">lopatin</span><span>|</span><a href="#41655200">parent</a><span>|</span><a href="#41655566">prev</a><span>|</span><a href="#41655395">next</a><span>|</span><label class="collapse" for="c-41655824">[-]</label><label class="expand" for="c-41655824">[1 more]</label></div><br/><div class="children"><div class="content">PL people also like bootstrapping languages. Writing Rust in Rust might not be that far fetched?</div><br/></div></div></div></div><div id="41655395" class="c"><input type="checkbox" id="c-41655395" checked=""/><div class="controls bullet"><span class="by">gyre007</span><span>|</span><a href="#41655200">prev</a><span>|</span><a href="#41655270">next</a><span>|</span><label class="collapse" for="c-41655395">[-]</label><label class="expand" for="c-41655395">[14 more]</label></div><br/><div class="children"><div class="content">One of the things that hit me when I was picking up Rust was that I felt like it had every imaginable feature one could think of - I dont know if Rust team said no to anything (yes I know they obviously must’ve done) - and yet people wanted more and more (some justifiably, others less so) as the language  “felt” incomplete or that the features thatd be used by 2% of devs are totally necessary in the language that is “understood” by 1% of developer populace. I’m not saying the author is wrong here, just pointing out how a complex language somehow needs to be even more complicated. Spoiler: it doesn’t. Zig is simpler, arguably faster, with much less drama in the community. I wish more funding went to Zig.</div><br/><div id="41656053" class="c"><input type="checkbox" id="c-41656053" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655805">next</a><span>|</span><label class="collapse" for="c-41656053">[-]</label><label class="expand" for="c-41656053">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>&gt; I’m not saying the author is wrong here, just pointing out how a complex language somehow needs to be even more complicated. Spoiler: it doesn’t.<p>True. But I think a lot of rust&#x27;s complexity budget is spent in the wrong places. For example, the way Pin &amp; futures interact adds a crazy amount of complexity to the language. And I think at least some of that complexity is unnecessary. As an example, I&#x27;d like a rust-like language which doesn&#x27;t have Pin at all.<p>I suspect there&#x27;s also ways the borrow checker could be simplified, in both syntax and implementation. But I haven&#x27;t thought enough about it to have anything concrete.<p>I don&#x27;t think there&#x27;s much we can do about any of that now short of forking the language. But I can certainly dream.<p>Rust won&#x27;t be the last language invented which uses a borrow checker. I look forward to the next generation of these ideas. I think there&#x27;s probably a lot of ways to improve things without making a bigger language.</div><br/></div></div><div id="41655805" class="c"><input type="checkbox" id="c-41655805" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41656053">prev</a><span>|</span><a href="#41655692">next</a><span>|</span><label class="collapse" for="c-41655805">[-]</label><label class="expand" for="c-41655805">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll be surprised by the amount of features that are often proposed by random people and are then rejected by the Rust community. Rust is definitely not trying to add all possible features, though you might get that feeling when you look at some feature like GATs and TAITs without having a clear idea of what problems they solve.<p>Also, Zig might be a nice modern language, but it is not an option if you&#x27;re aiming for memory safety.</div><br/></div></div><div id="41655692" class="c"><input type="checkbox" id="c-41655692" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655805">prev</a><span>|</span><a href="#41655424">next</a><span>|</span><label class="collapse" for="c-41655692">[-]</label><label class="expand" for="c-41655692">[1 more]</label></div><br/><div class="children"><div class="content">Zig is already far more complex than what was originally presented anyway, while Rust 1.0 and the current Rust are mostly identical. (Pre-1.0 versions of Rust were heavily changing and overwent at least two or three extreme changes that make them essentially different languages with the same name.) Zig should be funded more for other reasons, but I don&#x27;t think Zig would be safe from this eventual complexity problem.</div><br/></div></div><div id="41655424" class="c"><input type="checkbox" id="c-41655424" checked=""/><div class="controls bullet"><span class="by">bn-l</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655692">prev</a><span>|</span><a href="#41655594">next</a><span>|</span><label class="collapse" for="c-41655424">[-]</label><label class="expand" for="c-41655424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wish more funding went to Zig.<p>Unfortunately that attracts the worst types. And their crapness and damage potential is sometimes not realised until it’s way too late.</div><br/></div></div><div id="41655594" class="c"><input type="checkbox" id="c-41655594" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655424">prev</a><span>|</span><a href="#41655476">next</a><span>|</span><label class="collapse" for="c-41655594">[-]</label><label class="expand" for="c-41655594">[3 more]</label></div><br/><div class="children"><div class="content">The graveyard of features in nightly is actually pretty big. Important stuff like specialization is forever stuck there.</div><br/><div id="41655771" class="c"><input type="checkbox" id="c-41655771" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41655395">root</a><span>|</span><a href="#41655594">parent</a><span>|</span><a href="#41655712">next</a><span>|</span><label class="collapse" for="c-41655771">[-]</label><label class="expand" for="c-41655771">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK many of those language features (specialization included) are blocked by the rewrite of the trait solver.</div><br/></div></div><div id="41655712" class="c"><input type="checkbox" id="c-41655712" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41655395">root</a><span>|</span><a href="#41655594">parent</a><span>|</span><a href="#41655771">prev</a><span>|</span><a href="#41655476">next</a><span>|</span><label class="collapse" for="c-41655712">[-]</label><label class="expand" for="c-41655712">[1 more]</label></div><br/><div class="children"><div class="content">While there are trucks of nightly only features, some are stuck there for a good reason.<p>Specializations allow unsound behavior in safe Rust, which is exactly what nightly was supposed to catch.</div><br/></div></div></div></div><div id="41655476" class="c"><input type="checkbox" id="c-41655476" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655594">prev</a><span>|</span><a href="#41655562">next</a><span>|</span><label class="collapse" for="c-41655476">[-]</label><label class="expand" for="c-41655476">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, what drama in the Rust community are you referring to?<p>I see some drama associated with Rust, but it&#x27;s usually around people resisting its usage or adoption (the recent kerfuffle about Rust for Linux, for example), and not really that common within the community. But I could be missing something?<p>Zig is great, but it just isn&#x27;t production ready.</div><br/><div id="41655548" class="c"><input type="checkbox" id="c-41655548" checked=""/><div class="controls bullet"><span class="by">chrisco255</span><span>|</span><a href="#41655395">root</a><span>|</span><a href="#41655476">parent</a><span>|</span><a href="#41655562">next</a><span>|</span><label class="collapse" for="c-41655548">[-]</label><label class="expand" for="c-41655548">[3 more]</label></div><br/><div class="children"><div class="content">On drama: <a href="https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;why-is-there-so-much-mismanagement-in-the-rust-foundation-and-core-team&#x2F;94822" rel="nofollow">https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;why-is-there-so-much-mismanage...</a><p>Also, Zig is set to release 1.0 beta in November.</div><br/><div id="41655699" class="c"><input type="checkbox" id="c-41655699" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41655395">root</a><span>|</span><a href="#41655548">parent</a><span>|</span><a href="#41655707">next</a><span>|</span><label class="collapse" for="c-41655699">[-]</label><label class="expand" for="c-41655699">[1 more]</label></div><br/><div class="children"><div class="content">I think the replies in that thread actually do a good job of describing how it is a bit overblown.<p>As for Zig, I hope they make it. I think I kind of see why people are excited about it, but fundamentally the reason I&#x27;m not super hyped is that it doesn&#x27;t seem to really enable anything new. It&#x27;s far more expressive than C, but it doesn&#x27;t make it easier to manage inherent complexity (to my understanding - haven&#x27;t played with it a lot).</div><br/></div></div><div id="41655707" class="c"><input type="checkbox" id="c-41655707" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41655395">root</a><span>|</span><a href="#41655548">parent</a><span>|</span><a href="#41655699">prev</a><span>|</span><a href="#41655562">next</a><span>|</span><label class="collapse" for="c-41655707">[-]</label><label class="expand" for="c-41655707">[1 more]</label></div><br/><div class="children"><div class="content">Any source on the zig 1.0 thing? As far as I can tell it is not even on thr horizon.</div><br/></div></div></div></div></div></div><div id="41655562" class="c"><input type="checkbox" id="c-41655562" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655476">prev</a><span>|</span><a href="#41655514">next</a><span>|</span><label class="collapse" for="c-41655562">[-]</label><label class="expand" for="c-41655562">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I felt like it had every imaginable feature one could think of - I dont know if Rust team said no to anything<p>Ah, like Scala you mean?</div><br/></div></div><div id="41655514" class="c"><input type="checkbox" id="c-41655514" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#41655395">parent</a><span>|</span><a href="#41655562">prev</a><span>|</span><a href="#41655270">next</a><span>|</span><label class="collapse" for="c-41655514">[-]</label><label class="expand" for="c-41655514">[1 more]</label></div><br/><div class="children"><div class="content">I wish Zig had a borrow checker... then we could see how much better it would fare.<p>(This is not a diss on Zig at all, I love its approach!)</div><br/></div></div></div></div><div id="41655270" class="c"><input type="checkbox" id="c-41655270" checked=""/><div class="controls bullet"><span class="by">iTokio</span><span>|</span><a href="#41655395">prev</a><span>|</span><a href="#41655268">next</a><span>|</span><label class="collapse" for="c-41655270">[-]</label><label class="expand" for="c-41655270">[1 more]</label></div><br/><div class="children"><div class="content">Rust mission was already a difficult mix between performance, safety and expressiveness, then the project lost its “founder mode” when Mozilla disengaged, and the original core team mostly left, so no wonder progress slowed down. I personally think that’s it’s better than going down the wrong path.</div><br/></div></div><div id="41655268" class="c"><input type="checkbox" id="c-41655268" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41655270">prev</a><span>|</span><a href="#41655155">next</a><span>|</span><label class="collapse" for="c-41655268">[-]</label><label class="expand" for="c-41655268">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Now, there are issue threads like this, in which 25 smart, well meaning people spent 2 years and over 200 comments trying to figure out how to improve Mutex. And as far as I can tell, in the end they more or less gave up.<p>The author of the linked comment did extensive analysis on the synchronization primitives in various languages, then rewrote Rust&#x27;s synchronization primitives like Mutex and RwLock on every major OS to use the underlying operating system primitives directly (like futex on Linux), making them faster and smaller and all-around better, and in the process, literally <i>wrote a book</i> on parallel programming in Rust (which is useful for non-Rust parallel programming as well): <a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;rust-atomics-and&#x2F;9781098119430&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;rust-atomics-and&#x2F;978109...</a><p>&gt; Features like Coroutines. This RFC is 7 years old now.<p>We haven&#x27;t been idling around for 7 years (either on that feature or in general). We&#x27;ve added asynchronous functions (which whole ecosystems and frameworks have arisen around), traits that can include asynchronous functions (which required <i>extensive</i> work), and many other features that are both useful in their own right and needed to get to more complex things like generators. Some of these features are also critical for being able to standardize things like `AsyncWrite` and `AsyncRead`. And we now have an implementation of generators available in nightly.<p>(There&#x27;s some debate about whether we <i>want</i> the complexity of fully general coroutines, or if we want to stop at generators.)<p>Some features have progressed slower than others; for instance, we still have a lot of discussion ongoing for how to design the AsyncIterator trait (sometimes also referred to as Stream). There have absolutely been features that stalled out. But there&#x27;s a <i>lot</i> of active work going on.<p>I always find it amusing to see, simultaneously, people complaining that the language isn&#x27;t moving fast enough and other people complaining that the language is moving too fast.<p>&gt; Function traits (effects)<p>We had a <i>huge</i> design exploration of these quite recently, right before RustConf this year. There&#x27;s a challenging balance here between usability (fully general effect systems are <i>complicated</i>) and power (not having to write multiple different versions of functions for combinations of async&#x2F;try&#x2F;etc). We&#x27;re enthusiastic about shipping a solution in this area, though. I don&#x27;t know if we&#x27;ll end up shipping an <i>extensible</i> effect system, but I think we&#x27;re very likely to ship a system that allows you to write e.g. one function accepting a closure that works for every combination of async, try, and possibly const.<p>&gt; Compile-time Capabilities<p>Sandboxing against <i>malicious</i> crates is an out-of-scope problem. You can&#x27;t do this at the language level; you need some combination of a verifier and runtime sandbox. WebAssembly components are a much more likely solution here. But there&#x27;s lots of interest in having capabilities for other reasons, for things like &quot;what allocator should I use&quot; or &quot;what async runtime should I use&quot; or &quot;can I assume the platform is 64-bit&quot; or similar. And we do want sandboxing of things like proc macros, not because of malice but to allow accurate caching that knows everything the proc macro depends on - with a sandbox, you know (for instance) exactly what files the proc macro read, so you can avoid re-running it if those files haven&#x27;t changed.<p>&gt; Rust doesn&#x27;t have syntax to mark a struct field as being in a borrowed state. And we can&#x27;t express the lifetime of y.<p>&gt; Lets just extend the borrow checker and fix that!<p>&gt; I don&#x27;t know what the ideal syntax would be, but I&#x27;m sure we can come up with something.<p>This has never been a problem of syntax. It&#x27;s a <i>remarkably</i> hard problem to make the borrow checker able to handle self-referential structures. We&#x27;ve had a couple of iterations of the borrow checker, each of which made it capable of understanding more and more things. At this point, I <i>think</i> the experts in this area have ideas of <i>how</i> to make the borrow checker understand self-referential structures, but it&#x27;s still going to take a substantial amount of effort.<p>&gt; This syntax could also be adapted to support partial borrows<p>We&#x27;ve known how to do partial borrows for quite a while, and we already support partial borrows in closure captures. The main blocker for supporting partial borrows in public APIs has been how to expose that to the type system in a forwards-compatible way that supports maintaining stable semantic versioning:<p>If you have a struct with private fields, how can you say &quot;this method and that method can borrow from the struct at the same time&quot; without exposing details that might break if you add a new private field?<p>Right now, leading candidates include some idea of named &quot;borrow groups&quot;, so that you can define your own subsets of your struct without exposing what private fields those correspond to, and so that you can change the fields as long as you don&#x27;t change which combinations of methods can hold borrows at the same time.<p>&gt; Comptime<p>We&#x27;re actively working on this in many different ways. It&#x27;s not trivial, but there are many things we can and will do better here.<p>I recently wrote two RFCs in this area, to make macro_rules more powerful so you don&#x27;t need proc macros as often.<p>And we&#x27;re already talking about how to go even further and do more programmatic parsing using something closer to Rust constant evaluation. That&#x27;s a <i>very</i> hard problem, though, particularly if you want the same flexibility of macro_rules that lets you write a macro and use it in the same crate. (Proc macros, by contrast, require you to write a separate crate, for a variety of reasons.)<p>&gt; impl&lt;T: Copy&gt; for Range&lt;T&gt;.<p>This is already in progress. This is tied to a backwards-incompatible change to the range types, so it can only occur over an edition. (It would be possible to do it without that, but having Range implement both Iterator and Copy leads to some easy programming mistakes.)<p>&gt; Make if-let expressions support logical AND<p>We have an unstable feature for this already, and we&#x27;re close to stabilizing it. We need to settle which one or both of two related features we want to ship, but otherwise, this is ready to go.<p><pre><code>    &gt; But if I have a pointer, rust insists that I write (*myptr).x or, worse: (*(*myptr).p).y.
</code></pre>
We&#x27;ve had multiple syntax proposals to improve this, including a postfix dereference operator and an operator to navigate from &quot;pointer to struct&quot; to &quot;pointer to field of that struct&quot;. We don&#x27;t currently have someone championing one of those proposals, but many of us are fairly enthusiastic about seeing one of them happen.<p>That said, there&#x27;s also a danger of spending too much language weirdness budget here to buy more ergonomics, versus having people continue using the less ergonomic but more straightforward raw-pointer syntaxes we currently have. It&#x27;s an open question whether adding more language surface area here would on balance be a win or a loss.<p>&gt; Unfortunately, most of these changes would be incompatible with existing rust.<p>One of the wonderful things about Rust editions is that there&#x27;s very little we <i>can&#x27;t</i> change, if we have a sufficiently compelling design that people will want to adopt over an edition.<p>&gt; The rust &quot;unstable book&quot; lists 700 different unstable features - which presumably are all implemented, but which have yet to be enabled in stable rust.<p>This is <i>absolutely</i> an issue; one of the big open projects we need to work on is going through all the existing unstable features and removing many that aren&#x27;t likely to ever reach stabilization (typically either because nobody is working on them anymore or because they&#x27;ve been superseded).</div><br/><div id="41655306" class="c"><input type="checkbox" id="c-41655306" checked=""/><div class="controls bullet"><span class="by">xgb84j</span><span>|</span><a href="#41655268">parent</a><span>|</span><a href="#41655941">next</a><span>|</span><label class="collapse" for="c-41655306">[-]</label><label class="expand" for="c-41655306">[1 more]</label></div><br/><div class="children"><div class="content">What you describe is how development of basic packages that are part or on the level of the standard library should be done. The languages we are currently using will still be used decades from now. Slow good decisions now save much more time later on.</div><br/></div></div><div id="41655941" class="c"><input type="checkbox" id="c-41655941" checked=""/><div class="controls bullet"><span class="by">agersant</span><span>|</span><a href="#41655268">parent</a><span>|</span><a href="#41655306">prev</a><span>|</span><a href="#41655155">next</a><span>|</span><label class="collapse" for="c-41655941">[-]</label><label class="expand" for="c-41655941">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for taking the time to write this reply. Happy to hear a lot of this is in motion!</div><br/></div></div></div></div><div id="41655155" class="c"><input type="checkbox" id="c-41655155" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41655268">prev</a><span>|</span><a href="#41655246">next</a><span>|</span><label class="collapse" for="c-41655155">[-]</label><label class="expand" for="c-41655155">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good collection of the usual suspects, when it comes to suggested improvements for Rust.<p>The one point that stuck out for me is the comptime section. It approaches the topic from a security and supply-chain attacks angle, which is a way I never thought about it.</div><br/></div></div><div id="41655246" class="c"><input type="checkbox" id="c-41655246" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41655155">prev</a><span>|</span><a href="#41655717">next</a><span>|</span><label class="collapse" for="c-41655246">[-]</label><label class="expand" for="c-41655246">[1 more]</label></div><br/><div class="children"><div class="content">The function trait section reminded me about effect systems and Purescripts row polymorphism[0], which is a great little way to be able to encode properties of your functions.<p>I think Rust might quickly run into the “negative trait” problem trying to get that working, while embracing an effect system like Purescripts might get you the goods in a “principled” way. Though I haven’t thought about this deeply.<p>[0]: <a href="https:&#x2F;&#x2F;rtpg.co&#x2F;2016&#x2F;07&#x2F;20&#x2F;supercharged-types.html" rel="nofollow">https:&#x2F;&#x2F;rtpg.co&#x2F;2016&#x2F;07&#x2F;20&#x2F;supercharged-types.html</a></div><br/></div></div><div id="41655717" class="c"><input type="checkbox" id="c-41655717" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#41655246">prev</a><span>|</span><a href="#41655538">next</a><span>|</span><label class="collapse" for="c-41655717">[-]</label><label class="expand" for="c-41655717">[2 more]</label></div><br/><div class="children"><div class="content">I would gladly switch to a Rust fork without async. Even though this article is not about async per se, it’s clear that async makes most of the described problems worse.</div><br/><div id="41655928" class="c"><input type="checkbox" id="c-41655928" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655717">parent</a><span>|</span><a href="#41655538">next</a><span>|</span><label class="collapse" for="c-41655928">[-]</label><label class="expand" for="c-41655928">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that trivial? Just use Rust but reject any occurrence of `async` or `await` in your code or dependencies. Rust doesn&#x27;t even force the use of async code for certain features in its standard library.</div><br/></div></div></div></div><div id="41655538" class="c"><input type="checkbox" id="c-41655538" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#41655717">prev</a><span>|</span><a href="#41655320">next</a><span>|</span><label class="collapse" for="c-41655538">[-]</label><label class="expand" for="c-41655538">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Rust doesn&#x27;t have syntax to mark a struct field as being in a borrowed state.<p>&gt; ast_nodes: Vec&lt;&amp;&#x27;Self::source str&gt;,<p>Oh, that would be neat to replace the <a href="https:&#x2F;&#x2F;github.com&#x2F;tommie&#x2F;incrstruct">https:&#x2F;&#x2F;github.com&#x2F;tommie&#x2F;incrstruct</a> I wrote for two-phase initialization. Unlike Ouroboros and self_cell, it uses traits so the self-references can be recreated after a move. Whether it&#x27;s a good idea, I don&#x27;t know, but the magic Ouroboros applies to my struct feels wrong. But I say that as someone coming from C++.<p>&gt; if let Some(x) = some_var &amp;&amp; some_expr { }<p>Coming from Go, I was surprised that something like<p><pre><code>    if let Some(x) = some_var; expr(x) { }
</code></pre>
isn&#x27;t a thing.</div><br/><div id="41655942" class="c"><input type="checkbox" id="c-41655942" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41655538">parent</a><span>|</span><a href="#41655320">next</a><span>|</span><label class="collapse" for="c-41655942">[-]</label><label class="expand" for="c-41655942">[1 more]</label></div><br/><div class="children"><div class="content">`if some_var.is_some_and(|x| some_expr)` is the current way to do that. It is less flexible and doesn&#x27;t actually bind `x` into the conditional body (hence the proposal) but works today.</div><br/></div></div></div></div><div id="41655320" class="c"><input type="checkbox" id="c-41655320" checked=""/><div class="controls bullet"><span class="by">olivierduval</span><span>|</span><a href="#41655538">prev</a><span>|</span><a href="#41655165">next</a><span>|</span><label class="collapse" for="c-41655320">[-]</label><label class="expand" for="c-41655320">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Most crates I use - like human-size or serde don&#x27;t need any special capabilities to work. So we don&#x27;t need to worry so much about their authors &quot;turning evil&quot; and adding malicious code to our software<p>well...  :-(<p>Actually, it&#x27;s obvious that some authors might &quot;turn evil&quot; dumbly, by abusing some kind of priviledged permissions. By chance, these kinds of supply-chain risks are &quot;easily&quot; identified because<p>1) the permissions are an &quot;easy&quot; risk indicator, so you can priorize either to pin the version library (after validating it) or validate the new version<p>2) not so many libraries will use these permissions so you &quot;have time&quot; to focus on them<p>3) in these libraries, the permissions will tell you what system call&#x2F;bad effects is possible, so will allow you to narrow even more the scope of investigation<p>So, IMHO, permissions are not really the end of all but only a tiny step.<p>The real problem is &quot;how can human-size be used to subvert the program ?&quot; For example: what is happening if the returned size &quot;forget&quot; or &quot;add&quot; 100 bytes to files bigger than 1 KB ? As a remininder, STUXNET was about some speed a tiny bit faster than planned and shown...</div><br/><div id="41655332" class="c"><input type="checkbox" id="c-41655332" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41655320">parent</a><span>|</span><a href="#41655165">next</a><span>|</span><label class="collapse" for="c-41655332">[-]</label><label class="expand" for="c-41655332">[4 more]</label></div><br/><div class="children"><div class="content">Is there a known ratio of crates that use unsafe to ones that don&#x27;t? It feels like most nontrivial crates would often need some unsafe. But a system like this might create a scenario where crates offload some of their unsafe code into separate crates so they need updating less frequently (Much like the blah-sys versus blah crates).</div><br/><div id="41655462" class="c"><input type="checkbox" id="c-41655462" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#41655320">root</a><span>|</span><a href="#41655332">parent</a><span>|</span><a href="#41655480">next</a><span>|</span><label class="collapse" for="c-41655462">[-]</label><label class="expand" for="c-41655462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It feels like most nontrivial crates would often need some unsafe<p>As a frequent contributor to a number of crates, this isn‘t really true. Also, most popular crates actively deny use of unsafe.</div><br/></div></div><div id="41655480" class="c"><input type="checkbox" id="c-41655480" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41655320">root</a><span>|</span><a href="#41655332">parent</a><span>|</span><a href="#41655462">prev</a><span>|</span><a href="#41655165">next</a><span>|</span><label class="collapse" for="c-41655480">[-]</label><label class="expand" for="c-41655480">[2 more]</label></div><br/><div class="children"><div class="content">I suppose this depends on your definition of &quot;nontrivial&quot;, but I don&#x27;t think most would, unless you count the fact that some stuff in std is implemented with unsafe under the hood. The only times I&#x27;ve ever needed to use unsafe Rust code in 5~ years of writing it professionally was for interfacing with a vendor-specific C library, and that was only for the wrapper around it; the rest of the code didn&#x27;t need to use unsafe.</div><br/><div id="41655560" class="c"><input type="checkbox" id="c-41655560" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41655320">root</a><span>|</span><a href="#41655480">parent</a><span>|</span><a href="#41655165">next</a><span>|</span><label class="collapse" for="c-41655560">[-]</label><label class="expand" for="c-41655560">[1 more]</label></div><br/><div class="children"><div class="content">Yes I&#x27;m probably biased towards seeing more unsafe as a deal with a lot of wrapper libs (crates which in turn have -sys crates and so on). Looking at the dependency graph, if I use 10 deps directly and 5 have unsafe then that might be 50% of the direct dependencies, but probably just a small fraction of the total including transitive.</div><br/></div></div></div></div></div></div></div></div><div id="41655165" class="c"><input type="checkbox" id="c-41655165" checked=""/><div class="controls bullet"><span class="by">culebron21</span><span>|</span><a href="#41655320">prev</a><span>|</span><a href="#41655254">next</a><span>|</span><label class="collapse" for="c-41655165">[-]</label><label class="expand" for="c-41655165">[2 more]</label></div><br/><div class="children"><div class="content">I think adding per-crate permissions to do undoable&#x2F;unsafe things will lead us to permissions hell of devops in big deployments. Like Amazon S3 with gazillion options. I think it&#x27;s time to do something radically different with 3rd party deps.<p>Even if we put aside safety issues, each crate brings ~10 more dependencies by default (i.e. without any features turned on), which bloats compile times. Maybe it&#x27;s better to be able to shard 3rd party crates, and not update them automatically at all?</div><br/><div id="41655243" class="c"><input type="checkbox" id="c-41655243" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41655165">parent</a><span>|</span><a href="#41655254">next</a><span>|</span><label class="collapse" for="c-41655243">[-]</label><label class="expand" for="c-41655243">[1 more]</label></div><br/><div class="children"><div class="content">That’s a solution people already use (vendering and &#x2F; lock files) but it doesn’t solve this particular problem.<p>The closest to a solution we have is dependency scanning against known CVEs.<p>Having per-crate permissions is, I think, the only way languages can evolve past this hell hole we call supply chain attacks. It’s not a silver bullet, there will be edge cases that can be bypassed and new problems it creates. But if it reduces the scope of where supply chains can attack and what they can do, then that’s still a massive win.</div><br/></div></div></div></div><div id="41655254" class="c"><input type="checkbox" id="c-41655254" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41655165">prev</a><span>|</span><a href="#41655346">next</a><span>|</span><label class="collapse" for="c-41655254">[-]</label><label class="expand" for="c-41655254">[2 more]</label></div><br/><div class="children"><div class="content">I muuuch prefer pin to any move trait. Pin is a place property, not a type property. I think this post covers it nicely. <a href="https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;pinned-places&#x2F;" rel="nofollow">https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;pinned-places&#x2F;</a>. It definitely should be more ergonomic though</div><br/><div id="41655563" class="c"><input type="checkbox" id="c-41655563" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41655254">parent</a><span>|</span><a href="#41655346">next</a><span>|</span><label class="collapse" for="c-41655563">[-]</label><label class="expand" for="c-41655563">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know. In spite of Boats&#x27; great points, I think the programmer intuition definitely aligns more with it being a type property, in the sense that it enables the most interesting use case: self-referential values. All of that interacts badly with move semantics, and especially the lack of &quot;guaranteed copy elision&quot;, but nevertheless...</div><br/></div></div></div></div><div id="41655346" class="c"><input type="checkbox" id="c-41655346" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#41655254">prev</a><span>|</span><a href="#41655241">next</a><span>|</span><label class="collapse" for="c-41655346">[-]</label><label class="expand" for="c-41655346">[1 more]</label></div><br/><div class="children"><div class="content">Marking fixed stack size (and maybe even with an actual bound) would be helpful to ensure the tail-call optimisation is being done.<p>I don&#x27;t think any language helps verifying that., and even in the ones that require it by spec, it&#x27;s unclear if it&#x27;s happening. Maybe you didn&#x27;t really wrote a tail-recursive function because of a helper that you expected to be inlined. I guess it&#x27;s easy to notice if you try to blow the stack in a unit test though.</div><br/></div></div><div id="41655241" class="c"><input type="checkbox" id="c-41655241" checked=""/><div class="controls bullet"><span class="by">maverwa</span><span>|</span><a href="#41655346">prev</a><span>|</span><a href="#41655326">next</a><span>|</span><label class="collapse" for="c-41655241">[-]</label><label class="expand" for="c-41655241">[2 more]</label></div><br/><div class="children"><div class="content">I think there are fair complaints and good ideas in this. But I also think thats a bit hypocritical: They complain that there is a gigantic backlog of features in progress (as in &quot;not in stable yet&quot;), and then goes on to propose a lot of additional, quite fundamental and far reaching featues they&#x27;d like to see.<p>Don&#x27;t get me wrong: I&#x27;d like coroutines and a lot of other unstable&#x2F;hidden features done as well. Function traits sound great, and I&#x27;d also like the whole Pin stuff to be easier (or gone?).<p>But please, &quot;Lets just extend the borrow checker and fix that&quot; sounds very demeaning. Like no one even tried? I am by far no expert, but I am very sure that its not something you &quot;just&quot; go do.<p>I like most of the proposed features and improvements, I mostly share the critique on the language, but I do not thing the &quot;why not just fix it?&quot; attitude is helpful or warranted. Theres tons of work, and only so much people &amp; time.</div><br/><div id="41655802" class="c"><input type="checkbox" id="c-41655802" checked=""/><div class="controls bullet"><span class="by">Arch485</span><span>|</span><a href="#41655241">parent</a><span>|</span><a href="#41655326">next</a><span>|</span><label class="collapse" for="c-41655802">[-]</label><label class="expand" for="c-41655802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am by far no expert, but I am very sure that its not something you &quot;just&quot; go do.<p>As someone who has dabbled in compiler writing (i.e. I may be totally wrong), I believe that from a technical standpoint, modifying the borrow checker as proposed in the article (w.r.t. self-referential structs) is actually something you can &quot;just do&quot;. The issues that come up are due to backwards compatibility and such, meaning it cannot be done in Rust without a new Rust edition (or by forking the compiler like in the article).</div><br/></div></div></div></div><div id="41655326" class="c"><input type="checkbox" id="c-41655326" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41655241">prev</a><span>|</span><a href="#41655624">next</a><span>|</span><label class="collapse" for="c-41655326">[-]</label><label class="expand" for="c-41655326">[1 more]</label></div><br/><div class="children"><div class="content">&gt; most uses of unsafe would also require explicit whitelisting.<p>I think this is probably where all proposed whitelist&#x2F;capability proposal discussions end. It&#x27;s going to be too many crates that are in that category for it to be useful.<p>A good first step (not sure if it&#x27;s already taken tbh) would be to at least sandbox <i>build</i> execution. So that an attacker can&#x27;t execute arbitrary code when your app is compiled.</div><br/></div></div><div id="41655624" class="c"><input type="checkbox" id="c-41655624" checked=""/><div class="controls bullet"><span class="by">nikolay</span><span>|</span><a href="#41655326">prev</a><span>|</span><a href="#41655160">next</a><span>|</span><label class="collapse" for="c-41655624">[-]</label><label class="expand" for="c-41655624">[1 more]</label></div><br/><div class="children"><div class="content">If functions are &quot;fn&quot;, then coroutines should be &quot;co&quot;. In terms of verbosity, Rust turned into Java.</div><br/></div></div><div id="41655160" class="c"><input type="checkbox" id="c-41655160" checked=""/><div class="controls bullet"><span class="by">bli940505</span><span>|</span><a href="#41655624">prev</a><span>|</span><a href="#41655356">next</a><span>|</span><label class="collapse" for="c-41655160">[-]</label><label class="expand" for="c-41655160">[15 more]</label></div><br/><div class="children"><div class="content">&gt;And I don&#x27;t know if it will ever be there. Progress on the language has slowed so much. When I first started using it, every release seemed to add new, great features in stable rust. Now? Crickets.<p>Is frustration with Rust on the rise? I just started using Rust few month ago and absolutely love it. I can&#x27;t tell what&#x27;s going on with the Rust foundation so I can only judge by reading sentiments. Nothing would kill my vibe harder than knowing smart people thinks the language isn&#x27;t doing great :(</div><br/><div id="41655232" class="c"><input type="checkbox" id="c-41655232" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655191">next</a><span>|</span><label class="collapse" for="c-41655232">[-]</label><label class="expand" for="c-41655232">[1 more]</label></div><br/><div class="children"><div class="content">“There are only two kinds of languages: the ones people complain about and the ones nobody uses.” ― Bjarne Stroustrup</div><br/></div></div><div id="41655191" class="c"><input type="checkbox" id="c-41655191" checked=""/><div class="controls bullet"><span class="by">culebron21</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655232">prev</a><span>|</span><a href="#41655238">next</a><span>|</span><label class="collapse" for="c-41655191">[-]</label><label class="expand" for="c-41655191">[1 more]</label></div><br/><div class="children"><div class="content">I think every tech eventually is taken to its limits, no matter that it enabled you things that were earlier impossible. With Rust, I made projects I wouldn&#x27;t dare to in Python or weren&#x27;t ever able to in C. You may think what people can do with MS Excel that was impossible with a desktop&#x2F;pocket calculator, but also look at how huge Excel books can get that it starts crashing. I&#x27;d say Rust delivers well on most promises, but as your projects grow, you start getting unexpected costs, like every dependency bringing a dozen of others, and compile times getting longer and longer.</div><br/></div></div><div id="41655238" class="c"><input type="checkbox" id="c-41655238" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655191">prev</a><span>|</span><a href="#41655432">next</a><span>|</span><label class="collapse" for="c-41655238">[-]</label><label class="expand" for="c-41655238">[1 more]</label></div><br/><div class="children"><div class="content">The article doesn&#x27;t go into detail about the unstable features, that&#x27;s not just a list of features that haven&#x27;t been released yet. Some are experiments whose result will be &quot;can&#x27;t or shouldn&#x27;t be done&quot;.<p>Some are things that will never be stable, because they&#x27;re not a feature; as an example, <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;90418">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;90418</a></div><br/></div></div><div id="41655432" class="c"><input type="checkbox" id="c-41655432" checked=""/><div class="controls bullet"><span class="by">sznio</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655238">prev</a><span>|</span><a href="#41655248">next</a><span>|</span><label class="collapse" for="c-41655432">[-]</label><label class="expand" for="c-41655432">[3 more]</label></div><br/><div class="children"><div class="content">I just returned to Rust after a few years, and the syntax is even more unreadable. Half of my code is just type signatures. I don&#x27;t remember it being like that back in 2016 -- it seems like the convention changed and any crate you import returns the wildest types.</div><br/><div id="41655670" class="c"><input type="checkbox" id="c-41655670" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#41655160">root</a><span>|</span><a href="#41655432">parent</a><span>|</span><a href="#41655565">next</a><span>|</span><label class="collapse" for="c-41655670">[-]</label><label class="expand" for="c-41655670">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary. Entire `where` blocks can now disappear thanks to notation like<p><pre><code>    arg: impl Iterator&lt;Item: Debug&gt;</code></pre></div><br/></div></div><div id="41655565" class="c"><input type="checkbox" id="c-41655565" checked=""/><div class="controls bullet"><span class="by">BuckRogers</span><span>|</span><a href="#41655160">root</a><span>|</span><a href="#41655432">parent</a><span>|</span><a href="#41655670">prev</a><span>|</span><a href="#41655248">next</a><span>|</span><label class="collapse" for="c-41655565">[-]</label><label class="expand" for="c-41655565">[1 more]</label></div><br/><div class="children"><div class="content">I use C# everyday and never want to switch languages. I just don’t understand the appeal to other things and I’ve certainly dabbled enough.<p>It would probably just be TS.</div><br/></div></div></div></div><div id="41655248" class="c"><input type="checkbox" id="c-41655248" checked=""/><div class="controls bullet"><span class="by">teschmitt</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655432">prev</a><span>|</span><a href="#41655296">next</a><span>|</span><label class="collapse" for="c-41655248">[-]</label><label class="expand" for="c-41655248">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t worry about it too much ... learning Rust will give you an edge on learning other languages and frameworks which is the more essential skill in the long run. On the other hand, smart people who have an unimaginably in-depth knowledge of a language and its compiler will also always have objections about its development and ideas on how to move forward. Being unsatisfied with the status-quo is a big part of why languages like Rust get developed in the first place.<p>I know I used to crush hard on Python and also got worried when there were dissonances within the Python Foundation. But as you progress, I assume the goings-on in certain language communities will take a back-seat to thinking deeply about how to solve the problems you are professionally tasked with. At least that&#x27;s my experience.<p>As for Rust: It&#x27;s gonna be around for a while. For the past months, I&#x27;ve been hearing a lot of chatter about how companies are using Rust for the first time in production settings and how their developers love it.</div><br/></div></div><div id="41655296" class="c"><input type="checkbox" id="c-41655296" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655248">prev</a><span>|</span><a href="#41655261">next</a><span>|</span><label class="collapse" for="c-41655296">[-]</label><label class="expand" for="c-41655296">[2 more]</label></div><br/><div class="children"><div class="content">I think the language is doing great, not least _because_ it has slowed down a bit. To me it&#x27;s an indication that is has found a decent plateau right now where people can get useful things done, and where the Rust language and compiler teams are eager to provide a stable product that doesn&#x27;t break things willy-nilly.<p>A lot of the complaints I see are not super well thought through. For example, a lot of people complain about async being too explicit (having a different &quot;color&quot; than non-async functions), but don&#x27;t consider what the ramifications of having implicit await points actually are.<p>Even in this otherwise fine article, some of those desired Fn traits are not decidable (halting problem). There&#x27;s a bit of a need to manage expectations.<p>There are definitely legitimate things to be desired from the language. I would love a `Move` trait, for example, which would ostensibly be much easier to deal with than the `Pin` API. I would love specialization to land in some form or another. I would love Macros 2.0 to land, although I don&#x27;t think the proc-macro situation is as bad as the author presents it.<p>The current big thing that is happening in the compiler is the new trait solver[0], which should solve multiple problems with the current solver, both cases where it is too conservative, and cases where it contains soundness bugs (though very difficult to accidentally trigger). This has been multiple years in the making, and as I understand it, has taken up a lot of the team&#x27;s bandwidth.<p>I personally like to follow the progress and status of the compiler on <a href="https:&#x2F;&#x2F;releases.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;releases.rs&#x2F;</a>. There&#x27;s a lot of good stuff that happens each release, still.<p>[0]: <a href="https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;solve&#x2F;trait-solving.html" rel="nofollow">https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;solve&#x2F;trait-solving.ht...</a></div><br/><div id="41655792" class="c"><input type="checkbox" id="c-41655792" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41655160">root</a><span>|</span><a href="#41655296">parent</a><span>|</span><a href="#41655261">next</a><span>|</span><label class="collapse" for="c-41655792">[-]</label><label class="expand" for="c-41655792">[1 more]</label></div><br/><div class="children"><div class="content">I’ve said this before, but the whole function colour thing could be summarised as: “here’s a pain point easily addressed with monads, but I don’t want to consider monads, so let’s turn everything inside out to avoid thinking about monads.”<p>To which many sensible people respond “I don’t want to think about monads either, but is the pain point really that bad?”</div><br/></div></div></div></div><div id="41655261" class="c"><input type="checkbox" id="c-41655261" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655296">prev</a><span>|</span><a href="#41655177">next</a><span>|</span><label class="collapse" for="c-41655261">[-]</label><label class="expand" for="c-41655261">[1 more]</label></div><br/><div class="children"><div class="content">Nah not really, just frustration a bit with how it&#x27;s managed. But Rust is relatively young, and it&#x27;s growing so fast that it&#x27;ll take a while to reach an equilibrium with management etc.</div><br/></div></div><div id="41655177" class="c"><input type="checkbox" id="c-41655177" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655261">prev</a><span>|</span><a href="#41655188">next</a><span>|</span><label class="collapse" for="c-41655177">[-]</label><label class="expand" for="c-41655177">[1 more]</label></div><br/><div class="children"><div class="content">Just look at the proposal to add an --only-dependencies flag to cargo-build.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;2644">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;2644</a><p>Its a clusterfuck of people misdirecting the discussion, the maintainers completely missing the point, and in the end its still not even been allowed to start.<p>Cargo can download-only, it cant build only dependencies. If you, for whatever reason (ignoring the misleading docker examples) want to build your dependencies separately from your main project build, you are sol unless you want to use a third party dependency to do so.</div><br/></div></div><div id="41655188" class="c"><input type="checkbox" id="c-41655188" checked=""/><div class="controls bullet"><span class="by">panick21_</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655177">prev</a><span>|</span><a href="#41655362">next</a><span>|</span><label class="collapse" for="c-41655188">[-]</label><label class="expand" for="c-41655188">[2 more]</label></div><br/><div class="children"><div class="content">No language can continue to add freatures at speed, specially not a low level one. Rust development is going fine, crickets is just inaccurate. It just takes a while to add new stuff with zero overhead and backwards compadible.</div><br/><div id="41655219" class="c"><input type="checkbox" id="c-41655219" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#41655160">root</a><span>|</span><a href="#41655188">parent</a><span>|</span><a href="#41655362">next</a><span>|</span><label class="collapse" for="c-41655219">[-]</label><label class="expand" for="c-41655219">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust development is going fine, crickets is just inaccurate.<p>Yeah. This is someone who&#x27;s frustrated that he doesn&#x27;t wake up to headlines that read &quot;Hey babe, new Rust feature just dropped&quot;.<p>If that&#x27;s what he&#x27;s looking for, he should probably switch to the Javascript ecosystem.</div><br/></div></div></div></div><div id="41655362" class="c"><input type="checkbox" id="c-41655362" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#41655160">parent</a><span>|</span><a href="#41655188">prev</a><span>|</span><a href="#41655356">next</a><span>|</span><label class="collapse" for="c-41655362">[-]</label><label class="expand" for="c-41655362">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know. But Rust FUD is at a stable high level. (Not referring to the article btw.)</div><br/></div></div></div></div><div id="41655356" class="c"><input type="checkbox" id="c-41655356" checked=""/><div class="controls bullet"><span class="by">johan_felisaz</span><span>|</span><a href="#41655160">prev</a><span>|</span><a href="#41655108">next</a><span>|</span><label class="collapse" for="c-41655356">[-]</label><label class="expand" for="c-41655356">[1 more]</label></div><br/><div class="children"><div class="content">The section on comp time is written in a way which makes you think that zig invented the concept. It slightly irritated the lisper in me...<p>Great article apart from that.</div><br/></div></div><div id="41655108" class="c"><input type="checkbox" id="c-41655108" checked=""/><div class="controls bullet"><span class="by">tskulbru</span><span>|</span><a href="#41655356">prev</a><span>|</span><a href="#41655376">next</a><span>|</span><label class="collapse" for="c-41655108">[-]</label><label class="expand" for="c-41655108">[4 more]</label></div><br/><div class="children"><div class="content">Article aside, that page background messed with eyes while reading</div><br/><div id="41655146" class="c"><input type="checkbox" id="c-41655146" checked=""/><div class="controls bullet"><span class="by">TheChaplain</span><span>|</span><a href="#41655108">parent</a><span>|</span><a href="#41655138">next</a><span>|</span><label class="collapse" for="c-41655146">[-]</label><label class="expand" for="c-41655146">[2 more]</label></div><br/><div class="children"><div class="content">Try Reader View in Firefox, has helped me with this article and many others.</div><br/><div id="41655266" class="c"><input type="checkbox" id="c-41655266" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#41655108">root</a><span>|</span><a href="#41655146">parent</a><span>|</span><a href="#41655138">next</a><span>|</span><label class="collapse" for="c-41655266">[-]</label><label class="expand" for="c-41655266">[1 more]</label></div><br/><div class="children"><div class="content">I use a bookmarklet I found ages ago which is less invasive as it doesn&#x27;t change the layout:<p><pre><code>    javascript:(function(){var newSS, styles=&#x27;* { background: white ! important; color: black !important } :link, :link * { color: #0000EE%20!important%20}%20:visited,%20:visited%20*%20{%20color:%20#551A8B%20!important%20}&#x27;;%20if(document.createStyleSheet)%20{%20document.createStyleSheet(&quot;javascript:&#x27;&quot;+styles+&quot;&#x27;&quot;);%20}%20else%20{%20newSS=document.createElement(&#x27;link&#x27;);%20newSS.rel=&#x27;stylesheet&#x27;;%20newSS.href=&#x27;data:text&#x2F;css,&#x27;+escape(styles);%20document.getElementsByTagName(&quot;head&quot;)[0].appendChild(newSS);%20}%20})();</code></pre></div><br/></div></div></div></div><div id="41655138" class="c"><input type="checkbox" id="c-41655138" checked=""/><div class="controls bullet"><span class="by">lagniappe</span><span>|</span><a href="#41655108">parent</a><span>|</span><a href="#41655146">prev</a><span>|</span><a href="#41655376">next</a><span>|</span><label class="collapse" for="c-41655138">[-]</label><label class="expand" for="c-41655138">[1 more]</label></div><br/><div class="children"><div class="content">That is a user responsibility.</div><br/></div></div></div></div><div id="41655376" class="c"><input type="checkbox" id="c-41655376" checked=""/><div class="controls bullet"><span class="by">LetMeLogin</span><span>|</span><a href="#41655108">prev</a><span>|</span><a href="#41655497">next</a><span>|</span><label class="collapse" for="c-41655376">[-]</label><label class="expand" for="c-41655376">[1 more]</label></div><br/><div class="children"><div class="content">I stopped reading at &quot;Like the first iPhone - which was amazing by the way.&quot;<p>That phone couldn&#x27;t even send MMS.... You had to jailbreak it to be able to do normal stuff that the phones could do for ages back then.</div><br/></div></div><div id="41655497" class="c"><input type="checkbox" id="c-41655497" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#41655376">prev</a><span>|</span><a href="#41655151">next</a><span>|</span><label class="collapse" for="c-41655497">[-]</label><label class="expand" for="c-41655497">[1 more]</label></div><br/><div class="children"><div class="content">You know, I agree<p>And there&#x27;s a lot of things that are weird or clunky<p>I honestly don&#x27;t &quot;get&quot; the &quot;no classes, just struct methods thing&quot; and while, sure, C++ is kinda like that, but the ergonomics are weird. I&#x27;d much rather have the class&#x2F;methods declaration as most languages do<p>Lifetimes are good but the implementation is meh. Most cases could do with a default lifetime.<p>Copy&#x2F;borrow strictness is good to think about but in most cases we don&#x27;t care? Copy should probably the default and then you borrow in special cases</div><br/></div></div><div id="41655151" class="c"><input type="checkbox" id="c-41655151" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#41655497">prev</a><span>|</span><a href="#41655262">next</a><span>|</span><label class="collapse" for="c-41655151">[-]</label><label class="expand" for="c-41655151">[1 more]</label></div><br/><div class="children"><div class="content">Seems rust has come full circle. Rewriting everything in rust.. Why not Rust! &#x2F;s</div><br/></div></div><div id="41655262" class="c"><input type="checkbox" id="c-41655262" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41655151">prev</a><span>|</span><a href="#41655416">next</a><span>|</span><label class="collapse" for="c-41655262">[-]</label><label class="expand" for="c-41655262">[1 more]</label></div><br/><div class="children"><div class="content">I hate to say it since I&#x27;m generally against this kind of obstructive elitism, but I think that maybe one of the good things about rust is it&#x27;s user-unfriendliness to amateurs. It has massive utility and ergonomy inherent to its design, but gatekeeping to keep away &quot;left-pad&quot; library authors and users is good for utility, too.</div><br/></div></div><div id="41655416" class="c"><input type="checkbox" id="c-41655416" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#41655262">prev</a><span>|</span><label class="collapse" for="c-41655416">[-]</label><label class="expand" for="c-41655416">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t tell that something is borrowed until you try to compile your program. (Aside: I wish Rust IDEs made this state visible while programming!)<p>I am not sure what the OP is using, but with LSP I do get the error message in my editor (nvim) before any compiling (though am pretty sure some checking in happening in the background).<p>&gt; Compile-time Capabilities<p>Not sure how this makes any sense when Rust compiles to multiple targets. Should all libraries become aware of all the &quot;capabilities&quot; out there. Also, this already can be implemented using features and keep things minimal.<p>&gt; Comptime<p>I can&#x27;t make sense of what the OP issue is here.<p>&gt; Make if-let expressions support logical AND. Its so simple, so obvious, and so useful. This should work: if let Some(x) = some_var &amp;&amp; some_expr { }<p>The example makes no sense.</div><br/></div></div></div></div></div></div></div></body></html>