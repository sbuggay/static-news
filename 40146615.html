<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714035655433" as="style"/><link rel="stylesheet" href="styles.css?v=1714035655433"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://verdagon.dev/grimoire/grimoire">Borrow Checking, RC, GC, and the Eleven () Other Memory Safety Approaches</a> <span class="domain">(<a href="https://verdagon.dev">verdagon.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>57 comments</span></div><br/><div><div id="40151223" class="c"><input type="checkbox" id="c-40151223" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40152602">next</a><span>|</span><label class="collapse" for="c-40151223">[-]</label><label class="expand" for="c-40151223">[29 more]</label></div><br/><div class="children"><div class="content">I think it’s better to view reference counting and gc as two kinds of garbage collection: <a href="https:&#x2F;&#x2F;courses.cs.washington.edu&#x2F;courses&#x2F;cse590p&#x2F;05au&#x2F;p50-bacon.pdf" rel="nofollow">https:&#x2F;&#x2F;courses.cs.washington.edu&#x2F;courses&#x2F;cse590p&#x2F;05au&#x2F;p50-b...</a></div><br/><div id="40154764" class="c"><input type="checkbox" id="c-40154764" checked=""/><div class="controls bullet"><span class="by">thyecust</span><span>|</span><a href="#40151223">parent</a><span>|</span><a href="#40151353">next</a><span>|</span><label class="collapse" for="c-40154764">[-]</label><label class="expand" for="c-40154764">[1 more]</label></div><br/><div class="children"><div class="content">This paper is referenced in this post too. As &quot;a whole spectrum between the two.&quot; (RC and tracing GC)</div><br/></div></div><div id="40151353" class="c"><input type="checkbox" id="c-40151353" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#40151223">parent</a><span>|</span><a href="#40154764">prev</a><span>|</span><a href="#40151861">next</a><span>|</span><label class="collapse" for="c-40151353">[-]</label><label class="expand" for="c-40151353">[3 more]</label></div><br/><div class="children"><div class="content">That is an excellent paper. One of those things that is obvious in hindsight, but no one wrote it down clearly before.</div><br/><div id="40151458" class="c"><input type="checkbox" id="c-40151458" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151353">parent</a><span>|</span><a href="#40151861">next</a><span>|</span><label class="collapse" for="c-40151458">[-]</label><label class="expand" for="c-40151458">[2 more]</label></div><br/><div class="children"><div class="content">IMO it&#x27;s not remotely obvious. Not to me anyway.</div><br/><div id="40151903" class="c"><input type="checkbox" id="c-40151903" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151458">parent</a><span>|</span><a href="#40151861">next</a><span>|</span><label class="collapse" for="c-40151903">[-]</label><label class="expand" for="c-40151903">[1 more]</label></div><br/><div class="children"><div class="content">It’s obvious that is the same problem. It’s not obvious that it’s a more continuous linear tradeoff between the approaches</div><br/></div></div></div></div></div></div><div id="40151861" class="c"><input type="checkbox" id="c-40151861" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">parent</a><span>|</span><a href="#40151353">prev</a><span>|</span><a href="#40152602">next</a><span>|</span><label class="collapse" for="c-40151861">[-]</label><label class="expand" for="c-40151861">[24 more]</label></div><br/><div class="children"><div class="content">I have to disagree? Lumping them together is like lumping together formal verification with machine learning...<p>Two fundamental characteristics of garbage collection (in pretty much every programmer&#x27;s experience) are that (a) it can handle cycles (read: more general programs), and (b) it does not provide hard performance guarantees in the general case. Reference counting is literally the opposite, and that&#x27;s exactly what people love about it.</div><br/><div id="40154099" class="c"><input type="checkbox" id="c-40154099" checked=""/><div class="controls bullet"><span class="by">rbehrends</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151861">parent</a><span>|</span><a href="#40151957">next</a><span>|</span><label class="collapse" for="c-40154099">[-]</label><label class="expand" for="c-40154099">[3 more]</label></div><br/><div class="children"><div class="content">First of all, I recommend giving the paper a read, because I think you&#x27;re misunderstanding the claim (plus, it is a very good paper). The claim is not that they are equivalent, but that tracing GC and reference counting are dual solutions to the same problem, two ends of the same spectrum if you will, with hybrid solutions existing in between.<p>Second, what you seem to consider to be fundamental characteristics of tracing GC and RC is not in fact so fundamental.<p>For starters, RC absolutely can handle cycles (e.g. through trial deletion). Such implementations may be difficult or impossible to implement as pure library solutions, but there is nothing that says it can&#x27;t be done. The most prominent example of a programming language that uses such an approach is probably Python.<p>Nor does the claim that tracing GC cannot provide hard performance guarantees in the general case (while RC does) hold up under closer examination. Leaving aside the problem that it&#x27;s already non-trivial to provide <i>hard real time</i> performance guarantees for malloc()&#x2F;free() and ignoring the issue of cascading deletions, it doesn&#x27;t hold under the more relaxed assumptions discussed downthread.<p>For starters, we have such predictability only for the single-threaded case, not for arbitrary multi-threaded situations. And even in the single-threaded case, there are real use cases where predicting performance becomes functionally intractable. Examples are implementations of binary decision diagrams or certain persistent data structures, where the presence of shared subgraphs of arbitrary size make predicting performance of individual deallocations impractical.<p>In contrast, in the single-threaded case we can absolutely bound individual operations of a tracing GC by either a constant or (in the case of arbitrarily sized allocations) make them linear in the number of bytes allocated (e.g. Baker&#x27;s treadmill).<p>What is true is that in the absence of cycles, (naive) reference counting will free memory at the earliest opportunity, which is not something we can say for tracing GC.</div><br/><div id="40154458" class="c"><input type="checkbox" id="c-40154458" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40154099">parent</a><span>|</span><a href="#40151957">next</a><span>|</span><label class="collapse" for="c-40154458">[-]</label><label class="expand" for="c-40154458">[2 more]</label></div><br/><div class="children"><div class="content">&gt; First of all, I recommend giving the paper a read<p>I&#x27;ll put it on my list, thanks for the recommendation, but it really has no impact on my point (see next point).<p>&gt; because I think you&#x27;re misunderstanding the claim (plus, it is a very good paper)<p>Note: I wasn&#x27;t criticizing the paper. I was criticizing the comment, which claimed &quot;it’s better&quot; to view these as special cases.<p>If it&#x27;s not obvious what I mean, here&#x27;s an analogy: it&#x27;s the difference between having a great paper that reduces ~everything to category theory, vs. claiming &quot;it&#x27;s better&quot; for the audience I&#x27;m talking to to view everything in terms of category theory. I can be impressed by the former while still vehemently disagreeing with the latter.<p>&gt; For starters, RC absolutely can handle cycles (e.g. through trial deletion).<p>&quot;<i>Can</i> handle&quot; is quite the hedge. You &quot;can&quot; walk across the continent too, but at what cost?<p>&gt; The most prominent example of a programming language that uses such an approach is probably Python.<p>You&#x27;re saying Python uses RC to handle reference cycles, and doesn&#x27;t need a GC for that? If so please ask them to update the documentation, because right now it specifically says &quot;you can disable the collector <i>if you are sure your program does not create reference cycles</i>&quot;. <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;gc.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;gc.html</a><p>&gt; [...] hard real time [...]<p>Nobody said &quot;real time&quot;. I just said &quot;hard guarantee&quot;.</div><br/><div id="40154964" class="c"><input type="checkbox" id="c-40154964" checked=""/><div class="controls bullet"><span class="by">rbehrends</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40154458">parent</a><span>|</span><a href="#40151957">next</a><span>|</span><label class="collapse" for="c-40154964">[-]</label><label class="expand" for="c-40154964">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Note: I wasn&#x27;t criticizing the paper. I was criticizing the comment, which claimed &quot;it’s better&quot; to view these as special cases.<p>I didn&#x27;t assume you were. My note about it being a good paper was just a general &quot;this is worth reading&quot; recommendation.<p>&gt; &quot;Can handle&quot; is quite the hedge. You &quot;can&quot; walk across the continent too, but at what cost?<p>It&#x27;s not a hedge. You claimed that (tracing) GC can handle cycles, while RC was &quot;the opposite&quot;, which I read to mean that you believe it cannot.<p>While we are at it, let&#x27;s go through the basics of trial deletion.<p>Trial deletion first looks at possible candidates for objects involved in a cycle (in the original algorithm, those were objects whose RC got decremented without reaching zero). Then, you do a recursive decrement of their children&#x27;s (and their children&#x27;s children&#x27;s, and so forth) reference counts.<p>Unlike with regular reference counting decrements, you visit children even if the reference count doesn&#x27;t reach zero. The net result is that reference counts are reduced only along internal paths, but that objects that are still reachable from external paths have reference counts &gt; 0 after that.<p>Thus, any object with a reference count of zero after this step must be part of an internal cycle and can be deleted. All other objects have their original reference counts restored.<p>Because trial deletion operates on reference counts differently, it&#x27;s not something that you can easily implement as a library, which is why you don&#x27;t see it much except when a language implementation chooses to go with reference counting over a tracing GC.<p>&gt; You&#x27;re saying Python uses RC to handle reference cycles, and doesn&#x27;t need a GC for that? If so please ask them to update the documentation, because right now it specifically says &quot;you can disable the collector if you are sure your program does not create reference cycles&quot;. <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;gc.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;gc.html</a><p>This is a terminology thing. Python uses a variant (generational) trial deletion approach [1]. It&#x27;s not a traditional tracing GC, and it&#x27;s also not inaccurate, because GC can mean more than using a traditional tracing GC.<p>&gt; Nobody said &quot;real time&quot;. I just said &quot;hard guarantee&quot;.<p>I was not sure what you meant, so I answered both, as you may have noticed.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;796b3fb28057948ea5b98f7eb0c0f3af6a1e276e&#x2F;Python&#x2F;gc.c#L1126">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;796b3fb28057948ea5b98...</a></div><br/></div></div></div></div></div></div><div id="40151957" class="c"><input type="checkbox" id="c-40151957" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151861">parent</a><span>|</span><a href="#40154099">prev</a><span>|</span><a href="#40154864">next</a><span>|</span><label class="collapse" for="c-40151957">[-]</label><label class="expand" for="c-40151957">[18 more]</label></div><br/><div class="children"><div class="content">Reference counting does not provide hard performance guarantees. If you disagree consider what happens when a large tree is freed at the root.</div><br/><div id="40152047" class="c"><input type="checkbox" id="c-40152047" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151957">parent</a><span>|</span><a href="#40154019">next</a><span>|</span><label class="collapse" for="c-40152047">[-]</label><label class="expand" for="c-40152047">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Reference counting does not provide hard performance guarantees. If you disagree consider what happens when a large tree is freed at the root.<p>Sure it does. One hard guarantee in that case is that freeing M objects (out of N total that are alive) takes O(M) time. (Another is that you can access all the other objects in parallel without any impact. Etc.)</div><br/><div id="40152246" class="c"><input type="checkbox" id="c-40152246" checked=""/><div class="controls bullet"><span class="by">hashmash</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152047">parent</a><span>|</span><a href="#40153591">next</a><span>|</span><label class="collapse" for="c-40152246">[-]</label><label class="expand" for="c-40152246">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no hard guarantee that freeing an object runs in constant time. Reference counting tends to provide more predictable performance, but I don&#x27;t think the phrase &quot;hard guarantee&quot; is appropriate.</div><br/><div id="40152407" class="c"><input type="checkbox" id="c-40152407" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152246">parent</a><span>|</span><a href="#40153591">next</a><span>|</span><label class="collapse" for="c-40152407">[-]</label><label class="expand" for="c-40152407">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re conflating a bunch of things, but the biggest one here is that &quot;hard performance guarantee&quot; is not a synonym for &quot;constant-time performance&quot;. Nevertheless, feel free to substitute your own preferred vocabulary. I&#x27;m just trying to get the underlying point across about how different GC and RC fundamentally are.</div><br/><div id="40155015" class="c"><input type="checkbox" id="c-40155015" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152407">parent</a><span>|</span><a href="#40153591">next</a><span>|</span><label class="collapse" for="c-40155015">[-]</label><label class="expand" for="c-40155015">[1 more]</label></div><br/><div class="children"><div class="content">With optimized RC (which deffer deallocation) you have no &quot;constant-time performance guarantee&quot;, because you don&#x27;t know at which time the deffered deallocation will happen... And all modern RC implementations are heavily optimized - especially in Apple&#x27;s ecosystem...</div><br/></div></div></div></div></div></div><div id="40153591" class="c"><input type="checkbox" id="c-40153591" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152047">parent</a><span>|</span><a href="#40152246">prev</a><span>|</span><a href="#40153833">next</a><span>|</span><label class="collapse" for="c-40153591">[-]</label><label class="expand" for="c-40153591">[2 more]</label></div><br/><div class="children"><div class="content">Semispace GC takes O(N) for a live set of size N. You&#x27;re also ignoring the work to actually free which is generally slightly super linear. I&#x27;m also not sure what hard means in that case.</div><br/><div id="40153777" class="c"><input type="checkbox" id="c-40153777" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40153591">parent</a><span>|</span><a href="#40153833">next</a><span>|</span><label class="collapse" for="c-40153777">[-]</label><label class="expand" for="c-40153777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Semispace GC takes O(N) for a live set of size N<p>Is this a rebuttal? How? You have a million live objects, you just want to free 1 object, and this awesome GC accesses O(1 million) objects, and that&#x27;s somehow comparable to refcounting&#x27;s O(1)?<p>&gt; You&#x27;re also ignoring the work to actually free which is generally slightly super linear<p>That&#x27;s like arguing that everyone who claims binary search is O(log n) is &quot;ignoring&quot; the fact that page-table traversals and&#x2F;or bit-complexity &quot;actually&quot; make it O((log n)^2).<p>It&#x27;s &quot;ignored&quot; because the performance of the underlying system is entirely beside the point being made about the comparison of 2 algorithms on top of it. You analyze an algorithm based on the number of calls to the APIs provided to it, which in this case would be mmap&#x2F;munmap (or VirtualAlloc&#x2F;VirtualFree, or whatever), and you assume each of those operations takes constant time, unless specified otherwise. It doesn&#x27;t make sense to dig into the underlying system, especially when nobody has specified what the underlying system is to begin with.</div><br/></div></div></div></div><div id="40153833" class="c"><input type="checkbox" id="c-40153833" checked=""/><div class="controls bullet"><span class="by">stoperaticless</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152047">parent</a><span>|</span><a href="#40153591">prev</a><span>|</span><a href="#40152488">next</a><span>|</span><label class="collapse" for="c-40153833">[-]</label><label class="expand" for="c-40153833">[3 more]</label></div><br/><div class="children"><div class="content">Nitpick on usage of term “hard guarantee” in the form of rephrasing for GC: “One hard guarantee is that GC takes O(N) (N number of alive objects)”.<p>“O(M) guarantee” and “you can access all the other objects in parallel” are valid points, but they come with caviats that to utilize the first, one must know how many objects will be freed, and to utilize the second, one must know that two objects are not reachable from each other, which is not always the case e.g. objs=find(scene,criteria)<p>(Obviously you are aware of that. This comment is meant to inform other readers and prevent further idealisation of RC)</div><br/><div id="40154236" class="c"><input type="checkbox" id="c-40154236" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40153833">parent</a><span>|</span><a href="#40152488">next</a><span>|</span><label class="collapse" for="c-40154236">[-]</label><label class="expand" for="c-40154236">[2 more]</label></div><br/><div class="children"><div class="content">&gt; to utilize the “O(M) guarantee”, one must know how many objects will be freed<p>No -- unless I&#x27;m misunderstanding you(?), this is incorrect. The following pseudocode (I&#x27;ll just use Python syntax for simplicity) has no idea how many objects are being deleted:<p><pre><code>  while True:
    print(&quot;[Progress] Deleting: &quot; + node.name)
    prev = node
    node = next(node)
    del prev   # Assume this happens M times
</code></pre>
Assume each node owns O(1) blocks of memory.<p>With GC, the user can see random arbitrarily-long stutters, depending on the shape of the rest of the object graph, and the phase of the moon.<p>With RC, you can rely on the user seeing your progress indicators consistently... without knowing or caring what M was.<p>&gt; to utilize “you can access all the other objects in parallel”, one must know that two objects are not reachable from each other, which is not always the case e.g. objs=find(scene,criteria)<p>Again, this is false, and (subtly) misses the point.<p>The claim wasn&#x27;t &quot;you can access <i>all</i> objects in parallel&quot;. That&#x27;s not true in any system, be it GC or RC.<p>The claim is &quot;you can still access <i>some</i> objects in parallel&quot; with RC. The crucial difference here is that, under a GC, <i>all threads</i> are at risk of getting throttled because of each other arbitrarily. They simply <i>cannot</i> do any work (at least, nothing that allocates&#x2F;frees memory) without getting throttled or interrupted at the whim of the GC.</div><br/><div id="40154844" class="c"><input type="checkbox" id="c-40154844" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40154236">parent</a><span>|</span><a href="#40152488">next</a><span>|</span><label class="collapse" for="c-40154844">[-]</label><label class="expand" for="c-40154844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With RC, you can rely on the user seeing your progress indicators consistently... without knowing or caring what M was.<p>What does that mean? How is that helpful for the user to know you&#x27;ve free-d 56,789 objects so far if he doesn&#x27;t know if there&#x27;s 60k in total of 600k?<p>&gt; The crucial difference here is that, under a GC, all threads are at risk of getting throttled because of each other arbitrarily. They simply cannot do any work (at least, nothing that allocates&#x2F;frees memory) without getting throttled or interrupted at the whim of the GC.<p>And that&#x27;s also the case for all thread which share the same RC-d object. They will all be throttled when the memory is freed.<p>The biggest benefit of RC is how it seamlessly interact with native code, that&#x27;s why it&#x27;s a great fit for languages like Obj-C and Swift or Rust (opt-in), but in terms of performance, be it latency or throughput, it&#x27;s not a particularly good option (the trade off it makes is comparable to copying GC but with higher max latency than copying GC and even lower throughput, and doesn&#x27;t have fast allocation and memory compaction as a side benefit).</div><br/></div></div></div></div></div></div><div id="40152488" class="c"><input type="checkbox" id="c-40152488" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152047">parent</a><span>|</span><a href="#40153833">prev</a><span>|</span><a href="#40154019">next</a><span>|</span><label class="collapse" for="c-40152488">[-]</label><label class="expand" for="c-40152488">[2 more]</label></div><br/><div class="children"><div class="content">&gt; One hard guarantee in that case is that freeing M objects (out of N total that are alive) takes O(M) time.<p>Cheney&#x27;s algorithm gives you O(N-M) time which really is in the same order of time complexity.</div><br/><div id="40152543" class="c"><input type="checkbox" id="c-40152543" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152488">parent</a><span>|</span><a href="#40154019">next</a><span>|</span><label class="collapse" for="c-40152543">[-]</label><label class="expand" for="c-40152543">[1 more]</label></div><br/><div class="children"><div class="content">&gt; O(N-M) time which really is in the same order of time complexity.<p>No, it&#x27;s not. M could be 1 and N could be a million. The entire point of O(M) is that it&#x27;s independent of N.</div><br/></div></div></div></div></div></div><div id="40154019" class="c"><input type="checkbox" id="c-40154019" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151957">parent</a><span>|</span><a href="#40152047">prev</a><span>|</span><a href="#40152390">next</a><span>|</span><label class="collapse" for="c-40154019">[-]</label><label class="expand" for="c-40154019">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you disagree consider what happens when a large tree is freed at the root.<p>Isn&#x27;t that an implementation detail of the GC itself? For example this RC algorithm [1] (which detects cycles) can be implemented by tracking free and potentially free objects in their own special structure that can be evaluated incrementally.<p>[1] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;1255450.1255453" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;1255450.1255453</a></div><br/></div></div><div id="40152390" class="c"><input type="checkbox" id="c-40152390" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151957">parent</a><span>|</span><a href="#40154019">prev</a><span>|</span><a href="#40154864">next</a><span>|</span><label class="collapse" for="c-40152390">[-]</label><label class="expand" for="c-40152390">[5 more]</label></div><br/><div class="children"><div class="content">It guarantees that the referenced memory will be available for subsequent operations. Knowing precisely how much memory is available at any particular instant in time is pretty critical for performance engineering.</div><br/><div id="40153707" class="c"><input type="checkbox" id="c-40153707" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40152390">parent</a><span>|</span><a href="#40154864">next</a><span>|</span><label class="collapse" for="c-40153707">[-]</label><label class="expand" for="c-40153707">[4 more]</label></div><br/><div class="children"><div class="content">Only if one ignores memory fragmentation.</div><br/><div id="40154629" class="c"><input type="checkbox" id="c-40154629" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40153707">parent</a><span>|</span><a href="#40153849">next</a><span>|</span><label class="collapse" for="c-40154629">[-]</label><label class="expand" for="c-40154629">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure everything they wrote is true even with fragmentation.<p>But, also, if your point is that defragmentation is a selling point... I mean, the last time I saw someone who moved from RC to GC because of defragmentation was... never? Probably because you can just solve it by throwing money at it and buying more memory to permanently solve the problem. Whereas people go in the other direction all the time... probably because you can&#x27;t just perpetually throw more money at the problem and make compute time go N times faster.</div><br/></div></div><div id="40153849" class="c"><input type="checkbox" id="c-40153849" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40153707">parent</a><span>|</span><a href="#40154629">prev</a><span>|</span><a href="#40154864">next</a><span>|</span><label class="collapse" for="c-40153849">[-]</label><label class="expand" for="c-40153849">[2 more]</label></div><br/><div class="children"><div class="content">Fragmentation is always a possibility unless you&#x27;ve handled it specifically, like with a moving garbage collector.</div><br/><div id="40154042" class="c"><input type="checkbox" id="c-40154042" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40153849">parent</a><span>|</span><a href="#40154864">next</a><span>|</span><label class="collapse" for="c-40154042">[-]</label><label class="expand" for="c-40154042">[1 more]</label></div><br/><div class="children"><div class="content">Which reference counted implementations never make use of, when they do, they slowly evolve into a tracing collector when fully implemented.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40154864" class="c"><input type="checkbox" id="c-40154864" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40151861">parent</a><span>|</span><a href="#40151957">prev</a><span>|</span><a href="#40152602">next</a><span>|</span><label class="collapse" for="c-40154864">[-]</label><label class="expand" for="c-40154864">[2 more]</label></div><br/><div class="children"><div class="content">The more optimized RC is, the more similar it is to GC - and this includes properties like cycle handling and performance guarantees.</div><br/><div id="40154924" class="c"><input type="checkbox" id="c-40154924" checked=""/><div class="controls bullet"><span class="by">pebal</span><span>|</span><a href="#40151223">root</a><span>|</span><a href="#40154864">parent</a><span>|</span><a href="#40152602">next</a><span>|</span><label class="collapse" for="c-40154924">[-]</label><label class="expand" for="c-40154924">[1 more]</label></div><br/><div class="children"><div class="content">RC is and will be slower than GC. Even in C++ I can have pointers managed by GC that are faster than shared_ptr.</div><br/></div></div></div></div></div></div></div></div><div id="40152602" class="c"><input type="checkbox" id="c-40152602" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40151223">prev</a><span>|</span><a href="#40151735">next</a><span>|</span><label class="collapse" for="c-40152602">[-]</label><label class="expand" for="c-40152602">[3 more]</label></div><br/><div class="children"><div class="content">Never free and periodically crashing by OOM killer is rarely used but can be useful in limited circumstances. There are some shops that arbitrarily kill any worker over X hours old under the hypothesis that a memory leak is present or probably present.</div><br/><div id="40155088" class="c"><input type="checkbox" id="c-40155088" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40152602">parent</a><span>|</span><a href="#40154451">next</a><span>|</span><label class="collapse" for="c-40155088">[-]</label><label class="expand" for="c-40155088">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware of several Java service backends that just disable the GC entirely and take a once-a-day crash as a cost of doing business. As long as you have enough nodes that the crashes aren&#x27;t correlated, your overall service can maintain decent uptime</div><br/></div></div><div id="40154451" class="c"><input type="checkbox" id="c-40154451" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40152602">parent</a><span>|</span><a href="#40155088">prev</a><span>|</span><a href="#40151735">next</a><span>|</span><label class="collapse" for="c-40154451">[-]</label><label class="expand" for="c-40154451">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Never free<p>AFAIK it&#x27;s how you get memory safety in missile guidance software: you just have to put enough RAM on the board so it never run out of memory before the end of its flight.<p>Edit: TFA just talks about that in the “never free”</div><br/></div></div></div></div><div id="40151735" class="c"><input type="checkbox" id="c-40151735" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40152602">prev</a><span>|</span><a href="#40152058">next</a><span>|</span><label class="collapse" for="c-40151735">[-]</label><label class="expand" for="c-40151735">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;Linear reference counting is an elusive concept, where we can completely eliminate the counter integer, and do all of the reference counting at compile time.&quot;</i><p>Right. I&#x27;ve occasionally thought about that for Rust, as a way to do back references. You can have an Rc owning an object, which can own another object, which can have a weak RC reference back to the original. This allows you to find an object&#x27;s owner when needed, so you can do inheritance-like things when you need to. The single-ownership and dangling-pointer checks are made at run time and will panic if they fail.<p>Now, the question is, can you statically check access behavior and determine that those panics will never occur? If you can, you can eliminate the reference counts and checks.
That looks 1) possible, and 2) a PhD thesis sized problem.</div><br/><div id="40152968" class="c"><input type="checkbox" id="c-40152968" checked=""/><div class="controls bullet"><span class="by">pirocks</span><span>|</span><a href="#40151735">parent</a><span>|</span><a href="#40152058">next</a><span>|</span><label class="collapse" for="c-40152968">[-]</label><label class="expand" for="c-40152968">[1 more]</label></div><br/><div class="children"><div class="content">You may enjoy: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;static-rc&#x2F;latest&#x2F;static_rc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;static-rc&#x2F;latest&#x2F;static_rc&#x2F;</a></div><br/></div></div></div></div><div id="40152058" class="c"><input type="checkbox" id="c-40152058" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40151735">prev</a><span>|</span><a href="#40153962">next</a><span>|</span><label class="collapse" for="c-40152058">[-]</label><label class="expand" for="c-40152058">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s weird to see no mention in this post of separation logic, which would seem to provide a basic, general foundation for most of these techniques if perhaps not all of them.  For instance, the RustBelt paper gives a description of Rust borrow checking that can arguably be understood as relying on some form of separation logic.</div><br/></div></div><div id="40153962" class="c"><input type="checkbox" id="c-40153962" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40152058">prev</a><span>|</span><a href="#40154146">next</a><span>|</span><label class="collapse" for="c-40153962">[-]</label><label class="expand" for="c-40153962">[1 more]</label></div><br/><div class="children"><div class="content">A compile-time reference counting and reference count ellision scheme would be awesome for jq.  It could only happen with an escape hatch to reference counting.  We had an interesting contribution that added a piece of this, but meant for libjq-using applications, not for jq itself.</div><br/></div></div><div id="40154146" class="c"><input type="checkbox" id="c-40154146" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#40153962">prev</a><span>|</span><a href="#40153931">next</a><span>|</span><label class="collapse" for="c-40154146">[-]</label><label class="expand" for="c-40154146">[2 more]</label></div><br/><div class="children"><div class="content">I am surprised that call stacks aren&#x27;t mentioned. The call stack is a great way to free up memory that&#x27;s no longer being used by a function. Maybe it was too obvious to include?</div><br/><div id="40154648" class="c"><input type="checkbox" id="c-40154648" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40154146">parent</a><span>|</span><a href="#40153931">next</a><span>|</span><label class="collapse" for="c-40154648">[-]</label><label class="expand" for="c-40154648">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t solve the &quot;use after free&quot; problem, so not memory safe (as long as not combined with something else).</div><br/></div></div></div></div><div id="40153931" class="c"><input type="checkbox" id="c-40153931" checked=""/><div class="controls bullet"><span class="by">EricRiese</span><span>|</span><a href="#40154146">prev</a><span>|</span><a href="#40151840">next</a><span>|</span><label class="collapse" for="c-40153931">[-]</label><label class="expand" for="c-40153931">[1 more]</label></div><br/><div class="children"><div class="content">Java supports the never free strategy with Epsilon GC</div><br/></div></div><div id="40151840" class="c"><input type="checkbox" id="c-40151840" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#40153931">prev</a><span>|</span><a href="#40153968">next</a><span>|</span><label class="collapse" for="c-40151840">[-]</label><label class="expand" for="c-40151840">[2 more]</label></div><br/><div class="children"><div class="content">Most of the fancier runtime-less non-GC techniques fail when it comes to graph data structures (or even linked lists) without a tremendous amount of upfront work from the programmer.</div><br/><div id="40152664" class="c"><input type="checkbox" id="c-40152664" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40151840">parent</a><span>|</span><a href="#40153968">next</a><span>|</span><label class="collapse" for="c-40152664">[-]</label><label class="expand" for="c-40152664">[1 more]</label></div><br/><div class="children"><div class="content">Are you just trying to throw shade on Rust?<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;struct.LinkedList.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;struct.LinkedList....</a><p>&gt; NOTE: It is almost always better to use Vec or VecDeque because array-based containers are generally faster, more memory efficient, and make better use of CPU cache.<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;petgraph" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;petgraph</a> 78 M downloads</div><br/></div></div></div></div><div id="40153968" class="c"><input type="checkbox" id="c-40153968" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40151840">prev</a><span>|</span><a href="#40152934">next</a><span>|</span><label class="collapse" for="c-40153968">[-]</label><label class="expand" for="c-40153968">[1 more]</label></div><br/><div class="children"><div class="content">TFA is pretty awesome, not least because of all the links.  I&#x27;m going to be reading for a while.</div><br/></div></div><div id="40152934" class="c"><input type="checkbox" id="c-40152934" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40153968">prev</a><span>|</span><a href="#40148920">next</a><span>|</span><label class="collapse" for="c-40152934">[-]</label><label class="expand" for="c-40152934">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; And as it turns out, reference counting can be blended with immutable region borrowing to greatly reduce its cache misses and make it data-race safe, something no language has done yet.</i><p>Rust prevents data races, so I&#x27;m not sure what this is referring to.</div><br/><div id="40153121" class="c"><input type="checkbox" id="c-40153121" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#40152934">parent</a><span>|</span><a href="#40153715">next</a><span>|</span><label class="collapse" for="c-40153121">[-]</label><label class="expand" for="c-40153121">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s saying that no language has blended reference counting with immutable region borrowing, not that no language is data-race safe.</div><br/></div></div><div id="40153715" class="c"><input type="checkbox" id="c-40153715" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40152934">parent</a><span>|</span><a href="#40153121">prev</a><span>|</span><a href="#40148920">next</a><span>|</span><label class="collapse" for="c-40153715">[-]</label><label class="expand" for="c-40153715">[1 more]</label></div><br/><div class="children"><div class="content">One kind of data races, in-process memory not shared with other processes.</div><br/></div></div></div></div><div id="40151841" class="c"><input type="checkbox" id="c-40151841" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40148920">prev</a><span>|</span><a href="#40150120">next</a><span>|</span><label class="collapse" for="c-40151841">[-]</label><label class="expand" for="c-40151841">[3 more]</label></div><br/><div class="children"><div class="content">The language the development of which this blog discusses is worth checking out too: <a href="https:&#x2F;&#x2F;www.uiua.org" rel="nofollow">https:&#x2F;&#x2F;www.uiua.org</a><p>It is an interesting APL successor I was planning to learn after getting current projects out of the way.</div><br/><div id="40154491" class="c"><input type="checkbox" id="c-40154491" checked=""/><div class="controls bullet"><span class="by">dash2</span><span>|</span><a href="#40151841">parent</a><span>|</span><a href="#40150120">next</a><span>|</span><label class="collapse" for="c-40154491">[-]</label><label class="expand" for="c-40154491">[2 more]</label></div><br/><div class="children"><div class="content">I thought the language was <a href="https:&#x2F;&#x2F;vale.dev" rel="nofollow">https:&#x2F;&#x2F;vale.dev</a>?</div><br/><div id="40154684" class="c"><input type="checkbox" id="c-40154684" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40151841">root</a><span>|</span><a href="#40154491">parent</a><span>|</span><a href="#40150120">next</a><span>|</span><label class="collapse" for="c-40154684">[-]</label><label class="expand" for="c-40154684">[1 more]</label></div><br/><div class="children"><div class="content">Oh. You are, of course, right.<p>Damn pattern recognition, the logo looks almost the same if you squint!</div><br/></div></div></div></div></div></div><div id="40150991" class="c"><input type="checkbox" id="c-40150991" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#40150120">prev</a><span>|</span><a href="#40150863">next</a><span>|</span><label class="collapse" for="c-40150991">[-]</label><label class="expand" for="c-40150991">[4 more]</label></div><br/><div class="children"><div class="content">This is interesting but exhausting to read. I get the joke but come on, after the first few of these can I just read the information in line.</div><br/><div id="40152346" class="c"><input type="checkbox" id="c-40152346" checked=""/><div class="controls bullet"><span class="by">fwlr</span><span>|</span><a href="#40150991">parent</a><span>|</span><a href="#40154251">next</a><span>|</span><label class="collapse" for="c-40152346">[-]</label><label class="expand" for="c-40152346">[1 more]</label></div><br/><div class="children"><div class="content">The explanation for the the chosen style is given near the end of the piece: the author says that they’ve found ‘imagining a better solution already exists and is just out of reach’ (my paraphrase) is an effective way to break the mental habit of assuming we’ve discovered everything there is to know about a problem.</div><br/></div></div><div id="40154251" class="c"><input type="checkbox" id="c-40154251" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#40150991">parent</a><span>|</span><a href="#40152346">prev</a><span>|</span><a href="#40151162">next</a><span>|</span><label class="collapse" for="c-40154251">[-]</label><label class="expand" for="c-40154251">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I don&#x27;t really have time for informational articles that don&#x27;t just present their information in a straight-forward way.</div><br/></div></div></div></div></div></div></div></div></div></body></html>