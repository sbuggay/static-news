<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734944451746" as="style"/><link rel="stylesheet" href="styles.css?v=1734944451746"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://avi.im/blag/2024/sqlite-past-present-future/">How bloom filters made SQLite 10x faster</a> <span class="domain">(<a href="https://avi.im">avi.im</a>)</span></div><div class="subtext"><span>avinassh</span> | <span>48 comments</span></div><br/><div><div id="42490362" class="c"><input type="checkbox" id="c-42490362" checked=""/><div class="controls bullet"><span class="by">jschafer</span><span>|</span><a href="#42491715">next</a><span>|</span><label class="collapse" for="c-42490362">[-]</label><label class="expand" for="c-42490362">[5 more]</label></div><br/><div class="children"><div class="content">Note that the measurements in the paper were made before they fixed a bug where they confused bits and bytes.
So SQLite only used 1&#x2F;8 of the reserved bloom filter space, thus increasing the false positive rate significantly:<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;src&#x2F;info&#x2F;56d9bb7aa63043f5" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;src&#x2F;info&#x2F;56d9bb7aa63043f5</a><p>I found and reported the bug because I wanted to know how the bloom filters work in SQLite for my uni seminar paper. Still wondering if one can find those kind of bugs with test cases.</div><br/><div id="42492891" class="c"><input type="checkbox" id="c-42492891" checked=""/><div class="controls bullet"><span class="by">agilob</span><span>|</span><a href="#42490362">parent</a><span>|</span><a href="#42491649">next</a><span>|</span><label class="collapse" for="c-42492891">[-]</label><label class="expand" for="c-42492891">[1 more]</label></div><br/><div class="children"><div class="content">On top of that I don&#x27;t think it&#x27;s fair to say it&#x27;s 10x faster when it btree was tested only on integer index primary key column. Benchmarks with that bold statements should include short string (1-16 chars maybe) and UUID indexes at least.</div><br/></div></div><div id="42491649" class="c"><input type="checkbox" id="c-42491649" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#42490362">parent</a><span>|</span><a href="#42492891">prev</a><span>|</span><a href="#42491715">next</a><span>|</span><label class="collapse" for="c-42491649">[-]</label><label class="expand" for="c-42491649">[3 more]</label></div><br/><div class="children"><div class="content">How much of a slowdown did you estimate this bug caused?</div><br/><div id="42492094" class="c"><input type="checkbox" id="c-42492094" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#42490362">root</a><span>|</span><a href="#42491649">parent</a><span>|</span><a href="#42491867">next</a><span>|</span><label class="collapse" for="c-42492094">[-]</label><label class="expand" for="c-42492094">[1 more]</label></div><br/><div class="children"><div class="content">It actually would have performed faster, but the false positive rate drastically increased.</div><br/></div></div><div id="42491867" class="c"><input type="checkbox" id="c-42491867" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#42490362">root</a><span>|</span><a href="#42491649">parent</a><span>|</span><a href="#42492094">prev</a><span>|</span><a href="#42491715">next</a><span>|</span><label class="collapse" for="c-42491867">[-]</label><label class="expand" for="c-42491867">[1 more]</label></div><br/><div class="children"><div class="content">90%?</div><br/></div></div></div></div></div></div><div id="42491715" class="c"><input type="checkbox" id="c-42491715" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42490362">prev</a><span>|</span><a href="#42492484">next</a><span>|</span><label class="collapse" for="c-42491715">[-]</label><label class="expand" for="c-42491715">[1 more]</label></div><br/><div class="children"><div class="content">Thanks to its simplicity for development and hosting SQLite has become our first choice for new Apps. We use a number of different ways to workaround its single concurrent writer limitation [1]. Whilst we&#x27;re currently using Litestream for replication, we&#x27;re currently evaluating switching to SQLite&#x27;s native rsync [2].<p>[1] <a href="https:&#x2F;&#x2F;servicestack.net&#x2F;posts&#x2F;scalable-sqlite" rel="nofollow">https:&#x2F;&#x2F;servicestack.net&#x2F;posts&#x2F;scalable-sqlite</a><p>[2] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;rsync.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;rsync.html</a></div><br/></div></div><div id="42492484" class="c"><input type="checkbox" id="c-42492484" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42491715">prev</a><span>|</span><a href="#42488633">next</a><span>|</span><label class="collapse" for="c-42492484">[-]</label><label class="expand" for="c-42492484">[1 more]</label></div><br/><div class="children"><div class="content">Bloom filters are great, I wish more people knew about them.  The most important part about a bloom filter:<p>They will never have a false negative (and only sometimes a false positive).<p>We used this to vastly improve render times for comments pages on reddit.  We used two tricks.  The first was to store the time of your last vote as a first class property on your user object.  If you loaded a comments page for a link that was submitted after your last vote, we knew that you couldn&#x27;t have voted on any of those comments.<p>But if you had voted afterwards, we had to look up every single comment on the page to see if you had voted on it (we couldn&#x27;t only do the comments made before your last vote because we didn&#x27;t know the creation time until after we looked up the comment, and it was faster to just look up the vote).<p>But with a bloom filter, we could very quickly look up all the comments and get back a list of all the ones you voted on (with a couple of false positives in there).  Then we could go to the cache and see if your actual vote was there 
(and if it was an upvote or a downvote).  It was only after a failed cache hit did we have to actually go to the database.<p>But that bloom filter saved us from doing sometimes 1000s of cache lookups.</div><br/></div></div><div id="42488633" class="c"><input type="checkbox" id="c-42488633" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42492484">prev</a><span>|</span><a href="#42489138">next</a><span>|</span><label class="collapse" for="c-42488633">[-]</label><label class="expand" for="c-42488633">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>SQLite: Past, Present, and Future</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32675861">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32675861</a> - Sept 2022 (143 comments)</div><br/></div></div><div id="42489138" class="c"><input type="checkbox" id="c-42489138" checked=""/><div class="controls bullet"><span class="by">DaveMcMartin</span><span>|</span><a href="#42488633">prev</a><span>|</span><a href="#42489883">next</a><span>|</span><label class="collapse" for="c-42489138">[-]</label><label class="expand" for="c-42489138">[21 more]</label></div><br/><div class="children"><div class="content">SQLite is getting better and better. I am using it in production for a bunch of websites and never got a problem.</div><br/><div id="42491093" class="c"><input type="checkbox" id="c-42491093" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42489138">parent</a><span>|</span><a href="#42489345">next</a><span>|</span><label class="collapse" for="c-42491093">[-]</label><label class="expand" for="c-42491093">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been really impressed with sqlite+litefs on fly.io. it&#x27;s pretty easy to get distributed reads with single master writes.</div><br/></div></div><div id="42489345" class="c"><input type="checkbox" id="c-42489345" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42489138">parent</a><span>|</span><a href="#42491093">prev</a><span>|</span><a href="#42491356">next</a><span>|</span><label class="collapse" for="c-42489345">[-]</label><label class="expand" for="c-42489345">[16 more]</label></div><br/><div class="children"><div class="content">It should be fine for read-only data. If you want to write, be aware that only one process can write at a time, and if you forget to set busy_timeout at the start of the connection, it defaults to zero milliseconds and you&#x27;ll get an error if another process has locked the database for writing while you try to read or write it. Client-server databases tend to handle concurrent writers better.</div><br/><div id="42489920" class="c"><input type="checkbox" id="c-42489920" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489345">parent</a><span>|</span><a href="#42490478">next</a><span>|</span><label class="collapse" for="c-42489920">[-]</label><label class="expand" for="c-42489920">[7 more]</label></div><br/><div class="children"><div class="content">I think people overstate this.<p>Yes, the sqlite concurrency model is a bad choice if you have a high degree of concurrent writes. However for many applications that simply isn&#x27;t true. When it comes to websites i think people significantly overestimate the amount of concurrent writes.</div><br/><div id="42490970" class="c"><input type="checkbox" id="c-42490970" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489920">parent</a><span>|</span><a href="#42490263">next</a><span>|</span><label class="collapse" for="c-42490970">[-]</label><label class="expand" for="c-42490970">[1 more]</label></div><br/><div class="children"><div class="content">This is a baseline benchmark I published of various p9x latencies for multiple readers&#x2F;writers with a single SQLite database with different configurations set: <a href="https:&#x2F;&#x2F;github.com&#x2F;mqudsi&#x2F;sqlite-readers-writers">https:&#x2F;&#x2F;github.com&#x2F;mqudsi&#x2F;sqlite-readers-writers</a><p>Even if you don’t use message passing to use one thread to perform all updates&#x2F;writes, it still performs very solidly for many use cases.</div><br/></div></div><div id="42490263" class="c"><input type="checkbox" id="c-42490263" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489920">parent</a><span>|</span><a href="#42490970">prev</a><span>|</span><a href="#42489983">next</a><span>|</span><label class="collapse" for="c-42490263">[-]</label><label class="expand" for="c-42490263">[3 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s indeed a very real problem. I ran into with a very small service.</div><br/><div id="42490886" class="c"><input type="checkbox" id="c-42490886" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42490263">parent</a><span>|</span><a href="#42489983">next</a><span>|</span><label class="collapse" for="c-42490886">[-]</label><label class="expand" for="c-42490886">[2 more]</label></div><br/><div class="children"><div class="content">You want to configure it so it has a timeout. Take turns. That’s how locks work.<p>The only difference between SQLite and Postgres write locking is the granularity.</div><br/><div id="42492173" class="c"><input type="checkbox" id="c-42492173" checked=""/><div class="controls bullet"><span class="by">miunau</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42490886">parent</a><span>|</span><a href="#42489983">next</a><span>|</span><label class="collapse" for="c-42492173">[-]</label><label class="expand" for="c-42492173">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a trivial difference like you suggest.</div><br/></div></div></div></div></div></div><div id="42489983" class="c"><input type="checkbox" id="c-42489983" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489920">parent</a><span>|</span><a href="#42490263">prev</a><span>|</span><a href="#42490478">next</a><span>|</span><label class="collapse" for="c-42489983">[-]</label><label class="expand" for="c-42489983">[2 more]</label></div><br/><div class="children"><div class="content">Depending on the amount of write throughput you need and whether you care about latency, &quot;concurrent writes&quot; aren&#x27;t necessarily a problem either. You can just shove them into a queue and then have a single thread pull stuff out of the queue and push it into SQLite. That still scales, up to a point.</div><br/><div id="42490695" class="c"><input type="checkbox" id="c-42490695" checked=""/><div class="controls bullet"><span class="by">dinosaurdynasty</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489983">parent</a><span>|</span><a href="#42490478">next</a><span>|</span><label class="collapse" for="c-42490695">[-]</label><label class="expand" for="c-42490695">[1 more]</label></div><br/><div class="children"><div class="content">FYI this is basically what Redis does (which does not support concurrent writes <i>or</i> reads afaik), and that still scales quite a lot.</div><br/></div></div></div></div></div></div><div id="42490478" class="c"><input type="checkbox" id="c-42490478" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489345">parent</a><span>|</span><a href="#42489920">prev</a><span>|</span><a href="#42490905">next</a><span>|</span><label class="collapse" for="c-42490478">[-]</label><label class="expand" for="c-42490478">[5 more]</label></div><br/><div class="children"><div class="content">SQLite really isn&#x27;t meant to be used exactly like a hosted solution. I don&#x27;t know who is advocating for this.<p>If you are sharing your database between processes or machines, you are probably doing &quot;the fancy new SQLite thing&quot; wrong.<p>If you need to share information contained in a SQLite database with other processes or machines, you can write application-level code to handle this concern.</div><br/><div id="42490896" class="c"><input type="checkbox" id="c-42490896" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42490478">parent</a><span>|</span><a href="#42490905">next</a><span>|</span><label class="collapse" for="c-42490896">[-]</label><label class="expand" for="c-42490896">[4 more]</label></div><br/><div class="children"><div class="content">Sharing between processes? Absolutely. Machines? No.<p>For example, LAMP stack applications could swap the M for SQlite (and I think it would have been better historically if they did).</div><br/><div id="42491174" class="c"><input type="checkbox" id="c-42491174" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42490896">parent</a><span>|</span><a href="#42490905">next</a><span>|</span><label class="collapse" for="c-42491174">[-]</label><label class="expand" for="c-42491174">[3 more]</label></div><br/><div class="children"><div class="content">Sharing between processes isn&#x27;t impossible but this where you get all of your performance caveats.<p>I think it is a bit unfair to argue against SQLite on performance grounds but then not explore ways to utilize instances of it within a single process scope where it is most effective.<p>Sharing a single SQLite connection across all threads within a process is where you get the best performance outcomes. Everything is serialized within the SQLite provider - assuming you are using a mainstream build. So, if your storage subsystem is fast (NVMe &amp; friends), you will achieve very good outcomes. Any utilization model that requires a file open&#x2F;close operation every time you want to touch the data is a complete non-starter by comparison. The &quot;unit of work&quot; paradigm that hosted providers recommend is catastrophic for performance with SQLite.<p>One option for the &quot;I absolutely must share this SQLite instance with 30+ services&quot; scenario is to simply wrap it with a REST API or similar.</div><br/><div id="42492948" class="c"><input type="checkbox" id="c-42492948" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42491174">parent</a><span>|</span><a href="#42492148">next</a><span>|</span><label class="collapse" for="c-42492948">[-]</label><label class="expand" for="c-42492948">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why performance would be significantly different between multiple threads using same sqlite db vs multiple processes on same machine. Can you explain more what you mean?</div><br/></div></div><div id="42492148" class="c"><input type="checkbox" id="c-42492148" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42491174">parent</a><span>|</span><a href="#42492948">prev</a><span>|</span><a href="#42490905">next</a><span>|</span><label class="collapse" for="c-42492148">[-]</label><label class="expand" for="c-42492148">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but this where you get all of your performance caveats.<p>You mean the one where it locks on write? It’s totally fine, if you wrote any cross process code yourself it’s probably going to do similar locking.</div><br/></div></div></div></div></div></div></div></div><div id="42490905" class="c"><input type="checkbox" id="c-42490905" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42489345">parent</a><span>|</span><a href="#42490478">prev</a><span>|</span><a href="#42489774">next</a><span>|</span><label class="collapse" for="c-42490905">[-]</label><label class="expand" for="c-42490905">[1 more]</label></div><br/><div class="children"><div class="content">So configure busy_timeout, that’s what it’s for.</div><br/></div></div></div></div><div id="42491356" class="c"><input type="checkbox" id="c-42491356" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42489138">parent</a><span>|</span><a href="#42489345">prev</a><span>|</span><a href="#42489883">next</a><span>|</span><label class="collapse" for="c-42491356">[-]</label><label class="expand" for="c-42491356">[3 more]</label></div><br/><div class="children"><div class="content">If you never got a problem then how is it getting better?</div><br/><div id="42492903" class="c"><input type="checkbox" id="c-42492903" checked=""/><div class="controls bullet"><span class="by">agilob</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42491356">parent</a><span>|</span><a href="#42491492">next</a><span>|</span><label class="collapse" for="c-42492903">[-]</label><label class="expand" for="c-42492903">[1 more]</label></div><br/><div class="children"><div class="content">What if we didn&#x27;t know we had a problem? And now it&#x27;s &quot;ooooh it&#x27;s better now&quot;.</div><br/></div></div><div id="42491492" class="c"><input type="checkbox" id="c-42491492" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42489138">root</a><span>|</span><a href="#42491356">parent</a><span>|</span><a href="#42492903">prev</a><span>|</span><a href="#42489883">next</a><span>|</span><label class="collapse" for="c-42491492">[-]</label><label class="expand" for="c-42491492">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps it&#x27;s getting faster?</div><br/></div></div></div></div></div></div><div id="42489883" class="c"><input type="checkbox" id="c-42489883" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#42489138">prev</a><span>|</span><a href="#42489911">next</a><span>|</span><label class="collapse" for="c-42489883">[-]</label><label class="expand" for="c-42489883">[5 more]</label></div><br/><div class="children"><div class="content">Next should be this -&gt; <a href="https:&#x2F;&#x2F;x.com&#x2F;lemire&#x2F;status&#x2F;1869752213402157131" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;lemire&#x2F;status&#x2F;1869752213402157131</a><p>What a progress we have with these. Amazing times.</div><br/><div id="42489950" class="c"><input type="checkbox" id="c-42489950" checked=""/><div class="controls bullet"><span class="by">nsteel</span><span>|</span><a href="#42489883">parent</a><span>|</span><a href="#42489911">next</a><span>|</span><label class="collapse" for="c-42489950">[-]</label><label class="expand" for="c-42489950">[4 more]</label></div><br/><div class="children"><div class="content">Maybe not such a great fit for sqlite:<p>&gt; One of the challenges with binary fuse filters, is that they are immutable once populated, so data cannot be added incrementally, and they consume a significant amount of memory during the populate process</div><br/><div id="42490961" class="c"><input type="checkbox" id="c-42490961" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42489883">root</a><span>|</span><a href="#42489950">parent</a><span>|</span><a href="#42491488">next</a><span>|</span><label class="collapse" for="c-42490961">[-]</label><label class="expand" for="c-42490961">[1 more]</label></div><br/><div class="children"><div class="content">Same restriction with cuckoo filters. Are there any better than bloom filters without this restriction?</div><br/></div></div><div id="42491488" class="c"><input type="checkbox" id="c-42491488" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42489883">root</a><span>|</span><a href="#42489950">parent</a><span>|</span><a href="#42490961">prev</a><span>|</span><a href="#42491390">next</a><span>|</span><label class="collapse" for="c-42491488">[-]</label><label class="expand" for="c-42491488">[1 more]</label></div><br/><div class="children"><div class="content">You can convert static data structures like these into dynamic ones with about a logarithmic slowdown.  So it might still be worthwhile.<p>(You could also combine a static filter with a dynamic bloom filter in front.  A bit like generational garbage collection.)</div><br/></div></div><div id="42491390" class="c"><input type="checkbox" id="c-42491390" checked=""/><div class="controls bullet"><span class="by">tehjoker</span><span>|</span><a href="#42489883">root</a><span>|</span><a href="#42489950">parent</a><span>|</span><a href="#42491488">prev</a><span>|</span><a href="#42489911">next</a><span>|</span><label class="collapse" for="c-42491390">[-]</label><label class="expand" for="c-42491390">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also not clear that a better filter will result in a substantial improvement for SQLite. If the improvement is on the order of a tens or hundreds of nanoseconds per a query, that&#x27;s nothing compared to hitting disk.<p>Edit: I guess you could get really efficient at detecting things not in the database, but the soon as you get a single false or true positive the process runs into the equivalent of a screeching halt if you need to actually check if it&#x27;s there.</div><br/></div></div></div></div></div></div><div id="42489601" class="c"><input type="checkbox" id="c-42489601" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#42489911">prev</a><span>|</span><a href="#42491757">next</a><span>|</span><label class="collapse" for="c-42489601">[-]</label><label class="expand" for="c-42489601">[4 more]</label></div><br/><div class="children"><div class="content">Just a thought, just because a general problem is NPHard doesn&#x27;t mean that we can&#x27;t find specific solutions quickly or that a given input is hard to search for. If the downstream effect results in an order of magnitude less work, it makes sense, it&#x27;s just a tradeoff.</div><br/><div id="42489859" class="c"><input type="checkbox" id="c-42489859" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42489601">parent</a><span>|</span><a href="#42491757">next</a><span>|</span><label class="collapse" for="c-42489859">[-]</label><label class="expand" for="c-42489859">[3 more]</label></div><br/><div class="children"><div class="content">Well yes, heurstics for query planning is a very well researched field</div><br/><div id="42489932" class="c"><input type="checkbox" id="c-42489932" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#42489601">root</a><span>|</span><a href="#42489859">parent</a><span>|</span><a href="#42491757">next</a><span>|</span><label class="collapse" for="c-42489932">[-]</label><label class="expand" for="c-42489932">[2 more]</label></div><br/><div class="children"><div class="content">I was more thinking about solving NP hard problems. Modern CPUs are fast, if the benefit is worth it against the downstream task, just do it.</div><br/><div id="42491501" class="c"><input type="checkbox" id="c-42491501" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42489601">root</a><span>|</span><a href="#42489932">parent</a><span>|</span><a href="#42491757">next</a><span>|</span><label class="collapse" for="c-42491501">[-]</label><label class="expand" for="c-42491501">[1 more]</label></div><br/><div class="children"><div class="content">Most instances of most NP hard problems are fast and easy to solve in practice.<p>Eg you have to go to quite a bit of effort to construct a knapsack problem that&#x27;s hard to solve.</div><br/></div></div></div></div></div></div></div></div><div id="42491757" class="c"><input type="checkbox" id="c-42491757" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42489601">prev</a><span>|</span><a href="#42488886">next</a><span>|</span><label class="collapse" for="c-42491757">[-]</label><label class="expand" for="c-42491757">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SQLite does Nested Loop join<p>Only that? Never anything better? Really?<p>EDIT: Really.<p>Section titled Joins here <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;optoverview.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;optoverview.html</a><p>states:<p>&quot;SQLite implements joins as nested loops.&quot;<p>That&#x27;s quite shocking.<p>While doing MySQL and Postgres when nested loop showed up in EXPLAIN in almost all cases I knew I botched my query and&#x2F;or indexes.</div><br/><div id="42492937" class="c"><input type="checkbox" id="c-42492937" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42491757">parent</a><span>|</span><a href="#42488886">next</a><span>|</span><label class="collapse" for="c-42492937">[-]</label><label class="expand" for="c-42492937">[1 more]</label></div><br/><div class="children"><div class="content">If you mean in mysql explain: &quot;Using join buffer (Block Nested Loop)&quot;, its not slow because nested loop algorithm is being used, its slow because of the join buffer part, which is an optimization used when its not possible to immediately get the right row of the inner table via an index.<p>As far as i know (might be wrong,im not really familiar with mysql internals), mysql (like sqlite) generally uses nested loop joins all the time. The EXPLAIN just only says something in the join buffer case. When using a simple nested loop join, EXPLAIN does not mention the fact that it is using that algorithm.</div><br/></div></div></div></div><div id="42488886" class="c"><input type="checkbox" id="c-42488886" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42491757">prev</a><span>|</span><label class="collapse" for="c-42488886">[-]</label><label class="expand" for="c-42488886">[6 more]</label></div><br/><div class="children"><div class="content">[flagged]</div><br/><div id="42489231" class="c"><input type="checkbox" id="c-42489231" checked=""/><div class="controls bullet"><span class="by">jpalawaga</span><span>|</span><a href="#42488886">parent</a><span>|</span><a href="#42489365">next</a><span>|</span><label class="collapse" for="c-42489231">[-]</label><label class="expand" for="c-42489231">[1 more]</label></div><br/><div class="children"><div class="content">SQLite is self-described as not open contribution. So yes by their own measure they&#x27;ve made it more difficult to mainline features (and intentionally so).</div><br/></div></div><div id="42489365" class="c"><input type="checkbox" id="c-42489365" checked=""/><div class="controls bullet"><span class="by">steve_gh</span><span>|</span><a href="#42488886">parent</a><span>|</span><a href="#42489231">prev</a><span>|</span><a href="#42488950">next</a><span>|</span><label class="collapse" for="c-42489365">[-]</label><label class="expand" for="c-42489365">[2 more]</label></div><br/><div class="children"><div class="content">I submitted a bug report on SQLite a year or so back (a simple test case only, not a solution). The folks were super nice, and their patch went into the next release.</div><br/><div id="42489960" class="c"><input type="checkbox" id="c-42489960" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42488886">root</a><span>|</span><a href="#42489365">parent</a><span>|</span><a href="#42488950">next</a><span>|</span><label class="collapse" for="c-42489960">[-]</label><label class="expand" for="c-42489960">[1 more]</label></div><br/><div class="children"><div class="content">Me too, repeatedly. I&#x27;ve asked questions, reported bugs, asked for enhancements, made suggestions, submitted patches for consideration, and was always welcomed. Even when I&#x27;m asking for stuff that doesn&#x27;t necessarily align with their goals.<p>OTOH, I&#x27;ve requested clarification (just some basic documentation really) on the “open contribution” fork of SQLite… and they never documented their own code.<p>And I&#x27;m sorry, I know sarcasm isn&#x27;t the way here, and is impolite, but that was exactly the point.<p>Less than a week ago we had a whole thread where, again, we discussed the impossibility of improving SQLite from the outside because it&#x27;s not “open contribution.”<p>Well, this is just a great example of much larger feature that was developed in collaboration with them.</div><br/></div></div></div></div><div id="42488950" class="c"><input type="checkbox" id="c-42488950" checked=""/><div class="controls bullet"><span class="by">gpcz</span><span>|</span><a href="#42488886">parent</a><span>|</span><a href="#42489365">prev</a><span>|</span><a href="#42489460">next</a><span>|</span><label class="collapse" for="c-42488950">[-]</label><label class="expand" for="c-42488950">[1 more]</label></div><br/><div class="children"><div class="content">Even if true, it seems like they&#x27;re doing a pretty good job on their own.</div><br/></div></div><div id="42489460" class="c"><input type="checkbox" id="c-42489460" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42488886">parent</a><span>|</span><a href="#42488950">prev</a><span>|</span><label class="collapse" for="c-42489460">[-]</label><label class="expand" for="c-42489460">[1 more]</label></div><br/><div class="children"><div class="content">Open contribution isn’t a good in and of itself.</div><br/></div></div></div></div></div></div></div></div></div></body></html>