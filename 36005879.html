<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684573246943" as="style"/><link rel="stylesheet" href="styles.css?v=1684573246943"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://netflixtechblog.com/debugging-a-fuse-deadlock-in-the-linux-kernel-c75cd7989b6d?gi=f4c590ed3fe6">Debugging a FUSE deadlock in the Linux kernel</a>Â <span class="domain">(<a href="https://netflixtechblog.com">netflixtechblog.com</a>)</span></div><div class="subtext"><span>andsoitis</span> | <span>28 comments</span></div><br/><div><div id="36006530" class="c"><input type="checkbox" id="c-36006530" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36006237">next</a><span>|</span><label class="collapse" for="c-36006530">[-]</label><label class="expand" for="c-36006530">[17 more]</label></div><br/><div class="children"><div class="content">This article is mostly about rediscovering the distinction between interruptible and non-interruptible waits.<p>At the end there is some sort of deadlock between namespace teardown, signal delivery, and FUSE, but... it isn&#x27;t articulated in a way that is super comprehensible to me.  The kernel flushes open files on exit and also kills things in the namespace on exit.  But that means the race condition was always hitable if you killed the FUSE daemon at the wrong time relative to the FUSE client shutdown?  It&#x27;s not totally obvious to me why this would impact other non-FUSE filesystems.<p>Signal delivery and multithreaded process teardown in the kernel is certainly tricky, and it&#x27;s really easy to get these weird edge cases wrong.</div><br/><div id="36009812" class="c"><input type="checkbox" id="c-36009812" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36006530">parent</a><span>|</span><a href="#36007025">next</a><span>|</span><label class="collapse" for="c-36009812">[-]</label><label class="expand" for="c-36009812">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not totally obvious to me why this would impact other non-FUSE filesystems.<p>Anything filesystem that involves writing to another process, possibly a distant one (think NFS) will be susceptible to this.<p>Generally this wouldn&#x27;t be a problem because init would normally be init, and it wouldn&#x27;t have any open FDs for remote files (unless it was a diskless boot), and it wouldn&#x27;t exit (because init never exits, and historically init exiting&#x2F;dying would cause Unixes to panic), so this doesn&#x27;t usually come up.<p>But containers can break all these assumptions since you can have applications be init.  And if applications-as-init start helper daemons for FUSE or whatever, they need to clean up in order, and if they don&#x27;t then bad things happen.  In this case the application being init caused the kernel to kill all the other processes in the namespace when the application exited.<p>Apps-as-init can always fail to exit cleanly by crashing, and that shouldn&#x27;t cause unkillable zombies.  The fix described is correct: allow flushing during exit to fail, since that could always happen (e.g., ENOSPC).  Better than waiting forever for a flush that can&#x27;t complete.</div><br/></div></div><div id="36007025" class="c"><input type="checkbox" id="c-36007025" checked=""/><div class="controls bullet"><span class="by">sargun</span><span>|</span><a href="#36006530">parent</a><span>|</span><a href="#36009812">prev</a><span>|</span><a href="#36006237">next</a><span>|</span><label class="collapse" for="c-36007025">[-]</label><label class="expand" for="c-36007025">[15 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why wants_signal returns false on PF_EXITING even if the signal is SIGKILL (and from the kernel). Shouldn&#x27;t wake up the process still, so it can get out of the flush?<p>I am curious, if you were just to walk over every PID in the pid namespace after sending zap_pid_ns_processes, and perform wake ups, would it break out of the `wait_event` loop?<p>Btw, this class of weirdness with FUSE isn&#x27;t that unusual.</div><br/><div id="36007110" class="c"><input type="checkbox" id="c-36007110" checked=""/><div class="controls bullet"><span class="by">tych0</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007025">parent</a><span>|</span><a href="#36009825">next</a><span>|</span><label class="collapse" for="c-36007110">[-]</label><label class="expand" for="c-36007110">[13 more]</label></div><br/><div class="children"><div class="content">Author here (hi Sargun), it&#x27;s not really about rediscovering killable vs. unkillable waits, and any confusion is probably a result of my poor writing.<p>The crux of it is that once you&#x27;ve called exit_signals() from do_exit(), signals will not get delivered. So if you subsequently use the kernel&#x27;s completions or other wait code, you will not get the signal from zap_pid_ns_processes(), so you don&#x27;t know to wake up and exit.<p>There&#x27;s a test case here if people want to play around: <a href="https:&#x2F;&#x2F;github.com&#x2F;tych0&#x2F;kernel-utils&#x2F;tree&#x2F;master&#x2F;fuse2">https:&#x2F;&#x2F;github.com&#x2F;tych0&#x2F;kernel-utils&#x2F;tree&#x2F;master&#x2F;fuse2</a></div><br/><div id="36007550" class="c"><input type="checkbox" id="c-36007550" checked=""/><div class="controls bullet"><span class="by">sargun</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007110">parent</a><span>|</span><a href="#36007172">next</a><span>|</span><label class="collapse" for="c-36007550">[-]</label><label class="expand" for="c-36007550">[3 more]</label></div><br/><div class="children"><div class="content">Hi Tycho!<p>I&#x27;m glad you inherited this :).<p>Oh, I wasn&#x27;t suggesting that it was about killable vs. unkillable.<p>Couple of things:
1. Should prepare_to_wait_event check if the task is in PF_EXITING, and if so, refuse to wait unless a specific flag is provided? I&#x27;d be curious if you just add a kprobe to prepare_to_wait_event that checks for PF_EXITING, how many cases are valid?<p>2. Following this:<p><pre><code>  zap_pid_ns_processes -&gt;
     __fatal_signal_pending(task)
     group_send_sig_info
       do_send_sig_info
         send_signal_locked
           __send_signal_locked -&gt; (jump to out_set)
             sigaddset &#x2F;&#x2F; It has the pending signal here
             ....
             complete_signal


</code></pre>
Shouldn&#x27;t it wake up, even if in its in PF_EXITING, that would trigger as reassessment of the condition, and then the `__fatal_signal_pending` check would make it return -ERESTARTSYS.<p>One note, in the post:<p><pre><code>  # grep Pnd &#x2F;proc&#x2F;1544574&#x2F;status
  SigPnd: 0000000000000000
  ShdPnd: 0000000000000100

</code></pre>
&gt; Viewing process status this way, you can see 0x100 (i.e. the 9th bit is set) under SigPnd, which is the signal number corresponding to SIGKILL.<p>Shouldn&#x27;t it be &quot;ShdPnd&quot;?</div><br/><div id="36007646" class="c"><input type="checkbox" id="c-36007646" checked=""/><div class="controls bullet"><span class="by">tych0</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007550">parent</a><span>|</span><a href="#36007172">next</a><span>|</span><label class="collapse" for="c-36007646">[-]</label><label class="expand" for="c-36007646">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Couple of things: 1. Should prepare_to_wait_event check if the task is in PF_EXITING, and if so, refuse to wait unless a specific flag is provided? I&#x27;d be curious if you just add a kprobe to prepare_to_wait_event that checks for PF_EXITING, how many cases are valid?<p>I would argue they&#x27;re all invalid if PF_EXITING is present. Maybe I should send a patch to WARN() and see how much I get yelled at.<p>&gt; Shouldn&#x27;t it wake up, even if in its in PF_EXITING, that would trigger as reassessment of the condition, and then the `__fatal_signal_pending` check would make it return -ERESTARTSYS.<p>No, because the signal doesn&#x27;t get delivered by complete_signal(). wants_signal() returns false if PF_EXITING is set. (Another maybe-interesting thing would be to just delete that check.) Or am I misunderstanding you?<p>&gt; Shouldn&#x27;t it be &quot;ShdPnd&quot;<p>derp, fixed, thanks.</div><br/><div id="36007697" class="c"><input type="checkbox" id="c-36007697" checked=""/><div class="controls bullet"><span class="by">tych0</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007646">parent</a><span>|</span><a href="#36007172">next</a><span>|</span><label class="collapse" for="c-36007697">[-]</label><label class="expand" for="c-36007697">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Or am I misunderstanding you?<p>Oh, I see, you&#x27;re suggesting exactly,<p>&gt; (Another maybe-interesting thing would be to just delete that check.)<p>I agree.</div><br/></div></div></div></div></div></div><div id="36007172" class="c"><input type="checkbox" id="c-36007172" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007110">parent</a><span>|</span><a href="#36007550">prev</a><span>|</span><a href="#36007272">next</a><span>|</span><label class="collapse" for="c-36007172">[-]</label><label class="expand" for="c-36007172">[5 more]</label></div><br/><div class="children"><div class="content">Should processes not be able to wait after exit_signals?  That seems like a plausible invariant.</div><br/><div id="36007239" class="c"><input type="checkbox" id="c-36007239" checked=""/><div class="controls bullet"><span class="by">tych0</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007172">parent</a><span>|</span><a href="#36007253">next</a><span>|</span><label class="collapse" for="c-36007239">[-]</label><label class="expand" for="c-36007239">[2 more]</label></div><br/><div class="children"><div class="content">I think they definitely should not. I&#x27;ve considered sending a patch that adds a WARN() or some syzkaller test for it or something, especially now that I&#x27;ve seen it in other filesystems.</div><br/><div id="36007304" class="c"><input type="checkbox" id="c-36007304" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007239">parent</a><span>|</span><a href="#36007253">next</a><span>|</span><label class="collapse" for="c-36007304">[-]</label><label class="expand" for="c-36007304">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense to me.</div><br/></div></div></div></div><div id="36007253" class="c"><input type="checkbox" id="c-36007253" checked=""/><div class="controls bullet"><span class="by">avianlyric</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007172">parent</a><span>|</span><a href="#36007239">prev</a><span>|</span><a href="#36007272">next</a><span>|</span><label class="collapse" for="c-36007253">[-]</label><label class="expand" for="c-36007253">[2 more]</label></div><br/><div class="children"><div class="content">I think thatâs the point. Currently doing that will potentially result in a deadlock.</div><br/><div id="36007294" class="c"><input type="checkbox" id="c-36007294" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007253">parent</a><span>|</span><a href="#36007272">next</a><span>|</span><label class="collapse" for="c-36007294">[-]</label><label class="expand" for="c-36007294">[1 more]</label></div><br/><div class="children"><div class="content">Well, only if the wait is for userspace or a remote resource, right?  Regular disks are sometimes considered infallible (or at least, the IO will timeout eventually in the generic SCSI logic) and might be ok to wait on.<p>To generalize a bit, I think the problem is doing any sort of interruptible wait -- because we can no longer be interrupted.  Uninterruptible waits aren&#x27;t any different without signal delivery.  I might be oversimplifying, though.</div><br/></div></div></div></div></div></div><div id="36007272" class="c"><input type="checkbox" id="c-36007272" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007110">parent</a><span>|</span><a href="#36007172">prev</a><span>|</span><a href="#36009825">next</a><span>|</span><label class="collapse" for="c-36007272">[-]</label><label class="expand" for="c-36007272">[4 more]</label></div><br/><div class="children"><div class="content">It sounds like exit_signals() is being called too early, and based on the test case linked this might be a library issue rather than a code or kernel issue?<p>Edit: Reading the article it&#x27;s more clear this happens in kernel&#x27;s:<p><pre><code>  do_exit() {
    ...
    exit_signals(tsk); &#x2F;* sets PF_EXITING *&#x2F;
    ...
    exit_files(tsk);
</code></pre>
Would a better solution not be to exit_signals(tsk); later in do_exit() after all possible signal sources are exhausted?</div><br/><div id="36009867" class="c"><input type="checkbox" id="c-36009867" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007272">parent</a><span>|</span><a href="#36007298">next</a><span>|</span><label class="collapse" for="c-36009867">[-]</label><label class="expand" for="c-36009867">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter.  Filesystem waits are historically non-interruptible.  The correct fix is indeed to allow the flushes to fail fast rather than wait forever.</div><br/></div></div><div id="36007298" class="c"><input type="checkbox" id="c-36007298" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007272">parent</a><span>|</span><a href="#36009867">prev</a><span>|</span><a href="#36009825">next</a><span>|</span><label class="collapse" for="c-36007298">[-]</label><label class="expand" for="c-36007298">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It sounds like exit_signals() is being called too early<p>Or zap_pid_ns too late, yeah.</div><br/><div id="36009872" class="c"><input type="checkbox" id="c-36009872" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007298">parent</a><span>|</span><a href="#36009825">next</a><span>|</span><label class="collapse" for="c-36009872">[-]</label><label class="expand" for="c-36009872">[1 more]</label></div><br/><div class="children"><div class="content">Later would be better, no?  Since it&#x27;d allow the FUSE process to outlive the init process, thus allowing the flushes to complete.</div><br/></div></div></div></div></div></div></div></div><div id="36009825" class="c"><input type="checkbox" id="c-36009825" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36006530">root</a><span>|</span><a href="#36007025">parent</a><span>|</span><a href="#36007110">prev</a><span>|</span><a href="#36006237">next</a><span>|</span><label class="collapse" for="c-36009825">[-]</label><label class="expand" for="c-36009825">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t understand why wants_signal returns false on PF_EXITING even if the signal is SIGKILL (and from the kernel). Shouldn&#x27;t wake up the process still, so it can get out of the flush?<p>First, a signal wouldn&#x27;t get the process out of blocking on flushing because filesystem waits are non-interruptible.<p>Second, if a process is exiting then a) no handler for a signal (other than SIGKILL or SIGSTOP) could run, b) any default-exit actions couldn&#x27;t wouldn&#x27;t change the state of the process.<p>Therefore the process can&#x27;t want the signal if the process is exiting.</div><br/></div></div></div></div></div></div><div id="36006237" class="c"><input type="checkbox" id="c-36006237" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#36006530">prev</a><span>|</span><a href="#36007296">next</a><span>|</span><label class="collapse" for="c-36006237">[-]</label><label class="expand" for="c-36006237">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reminded of Bedrock Linux hanging during sleep because Linux sleeps the FUSE daemon while a process is waiting on FUSE and unable to be suspended for sleep: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34583495" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34583495</a></div><br/></div></div><div id="36007296" class="c"><input type="checkbox" id="c-36007296" checked=""/><div class="controls bullet"><span class="by">kayson</span><span>|</span><a href="#36006237">prev</a><span>|</span><a href="#36006605">next</a><span>|</span><label class="collapse" for="c-36007296">[-]</label><label class="expand" for="c-36007296">[5 more]</label></div><br/><div class="children"><div class="content">TIL about `ps awwfux`. Great way to remember it</div><br/><div id="36007797" class="c"><input type="checkbox" id="c-36007797" checked=""/><div class="controls bullet"><span class="by">chr-s</span><span>|</span><a href="#36007296">parent</a><span>|</span><a href="#36007394">next</a><span>|</span><label class="collapse" for="c-36007797">[-]</label><label class="expand" for="c-36007797">[1 more]</label></div><br/><div class="children"><div class="content">I love `ps axufww` so much and ah fuck to having learned it that way. It&#x27;s the first thing I run on a server when logging in. It tells you so much about the system. That, `w` and a `dmesg -T` will go 90% of the way to diagnosing most system issues.</div><br/></div></div><div id="36007394" class="c"><input type="checkbox" id="c-36007394" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#36007296">parent</a><span>|</span><a href="#36007797">prev</a><span>|</span><a href="#36006605">next</a><span>|</span><label class="collapse" for="c-36007394">[-]</label><label class="expand" for="c-36007394">[3 more]</label></div><br/><div class="children"><div class="content">See explainshell [0], a great resource, for the full explanation of these flags.<p>(Another one of my favorites is cat -vet)<p>[0] <a href="https:&#x2F;&#x2F;explainshell.com&#x2F;explain?cmd=ps+awwfux" rel="nofollow">https:&#x2F;&#x2F;explainshell.com&#x2F;explain?cmd=ps+awwfux</a></div><br/><div id="36009456" class="c"><input type="checkbox" id="c-36009456" checked=""/><div class="controls bullet"><span class="by">asicsp</span><span>|</span><a href="#36007296">root</a><span>|</span><a href="#36007394">parent</a><span>|</span><a href="#36007967">next</a><span>|</span><label class="collapse" for="c-36009456">[-]</label><label class="expand" for="c-36009456">[1 more]</label></div><br/><div class="children"><div class="content">I use `cat -A` on Linux, which is equivalent to `cat -vET`</div><br/></div></div><div id="36007967" class="c"><input type="checkbox" id="c-36007967" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#36007296">root</a><span>|</span><a href="#36007394">parent</a><span>|</span><a href="#36009456">prev</a><span>|</span><a href="#36006605">next</a><span>|</span><label class="collapse" for="c-36007967">[-]</label><label class="expand" for="c-36007967">[1 more]</label></div><br/><div class="children"><div class="content">Another one I like is `netstat -tulpen` (tulpen is german for tulips)</div><br/></div></div></div></div></div></div><div id="36006605" class="c"><input type="checkbox" id="c-36006605" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#36007296">prev</a><span>|</span><label class="collapse" for="c-36006605">[-]</label><label class="expand" for="c-36006605">[4 more]</label></div><br/><div class="children"><div class="content">I thought Netflix used a BSD?
<a href="https:&#x2F;&#x2F;papers.freebsd.org&#x2F;2019&#x2F;fosdem&#x2F;looney-netflix_and_freebsd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;papers.freebsd.org&#x2F;2019&#x2F;fosdem&#x2F;looney-netflix_and_fr...</a></div><br/><div id="36006669" class="c"><input type="checkbox" id="c-36006669" checked=""/><div class="controls bullet"><span class="by">prpl</span><span>|</span><a href="#36006605">parent</a><span>|</span><a href="#36006708">next</a><span>|</span><label class="collapse" for="c-36006669">[-]</label><label class="expand" for="c-36006669">[1 more]</label></div><br/><div class="children"><div class="content">I thought &lt;bigcorp&gt; used &lt;xyz&gt; is always a funny question&#x2F;assertion.<p>Bigcorps are large and diverse. In this case - this seems to be user&#x2F;desktop facing as it&#x27;s a fuse module for studio assets.</div><br/></div></div><div id="36006708" class="c"><input type="checkbox" id="c-36006708" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#36006605">parent</a><span>|</span><a href="#36006669">prev</a><span>|</span><a href="#36006851">next</a><span>|</span><label class="collapse" for="c-36006708">[-]</label><label class="expand" for="c-36006708">[1 more]</label></div><br/><div class="children"><div class="content">They use FreeBSD for the CDN but I think their application servers use Linux.<p><a href="https:&#x2F;&#x2F;netflixtechblog.com&#x2F;linux-performance-analysis-in-60-000-milliseconds-accc10403c55" rel="nofollow">https:&#x2F;&#x2F;netflixtechblog.com&#x2F;linux-performance-analysis-in-60...</a></div><br/></div></div><div id="36006851" class="c"><input type="checkbox" id="c-36006851" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36006605">parent</a><span>|</span><a href="#36006708">prev</a><span>|</span><label class="collapse" for="c-36006851">[-]</label><label class="expand" for="c-36006851">[1 more]</label></div><br/><div class="children"><div class="content">Netflix uses FreeBSD for their dataplane and AWS Linux for control plane, at least as of ~2020.</div><br/></div></div></div></div></div></div></div></div></div></body></html>