<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716195673996" as="style"/><link rel="stylesheet" href="styles.css?v=1716195673996"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mcinglis/c-style">C Style: My favorite C programming practices (2014)</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>zerojames</span> | <span>42 comments</span></div><br/><div><div id="40412812" class="c"><input type="checkbox" id="c-40412812" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#40412908">next</a><span>|</span><label class="collapse" for="c-40412812">[-]</label><label class="expand" for="c-40412812">[6 more]</label></div><br/><div class="children"><div class="content">I feel like I probably agree with about 80% of this.  It also seems like this would apply fairly well to C++ as well.<p>One thing that I&#x27;ll strongly quibble with: &quot;Use double rather than float, unless you have a specific reason otherwise&quot;.<p>As a graphics programmer, I&#x27;ve found that single precision will do just fine in the vast majority of cases.  I&#x27;ve also found that it&#x27;s often better to try to make my code work well in the single precision while keeping an eye out for precision loss.  Then I can either rewrite my math to try to avoid the precision loss, or selectively use double precision just in the parts where its needed.  I think that using double precision from the start is a big hammer that&#x27;s often unneeded.  And using single precision buys you double the number of floats moving through your cache and memory bandwidth compared to using double precision.</div><br/><div id="40413192" class="c"><input type="checkbox" id="c-40413192" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#40412812">parent</a><span>|</span><a href="#40412874">next</a><span>|</span><label class="collapse" for="c-40413192">[-]</label><label class="expand" for="c-40413192">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m torn both ways on the double issue. On the one hand, doubles are much more widely supported these days, and will save you from some common scenarios. Timestamps are a particular one, where a float will often degrade on a time scale that you care about, and doubles not. A double will also hold any int value without loss (on mainstream platforms), and has enough precision to allow staying in world coordinates for 3D geometry without introducing depth buffer problems.<p>OTOH, double precision is often just a panacea. If you don&#x27;t know the precision requirements of your algorithm, how do you know that double precision will work either? Some types of errors will compound without anti-drifting protection in ways that are exponential, where the extra mantissa bits from a double will only get you a constant factor of additional time.<p>There are also current platforms where double will land you in very significant performance problems, not just a minor hit. GPUs are a particularly fun one -- there are currently popular GPUs where double precision math runs at 1&#x2F;32 the rate of single precision.</div><br/></div></div><div id="40412874" class="c"><input type="checkbox" id="c-40412874" checked=""/><div class="controls bullet"><span class="by">amszmidt</span><span>|</span><a href="#40412812">parent</a><span>|</span><a href="#40413192">prev</a><span>|</span><a href="#40413101">next</a><span>|</span><label class="collapse" for="c-40412874">[-]</label><label class="expand" for="c-40412874">[3 more]</label></div><br/><div class="children"><div class="content">The one about not using &#x27;switch&#x27; and instead using combined logical comparisons is terrible ... quite opinionated, but that is usually the case with these type of style guides.</div><br/><div id="40413068" class="c"><input type="checkbox" id="c-40413068" checked=""/><div class="controls bullet"><span class="by">aulin</span><span>|</span><a href="#40412812">root</a><span>|</span><a href="#40412874">parent</a><span>|</span><a href="#40413165">next</a><span>|</span><label class="collapse" for="c-40413068">[-]</label><label class="expand" for="c-40413068">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s like they purposely add some controversial rule just for engagement</div><br/></div></div><div id="40413165" class="c"><input type="checkbox" id="c-40413165" checked=""/><div class="controls bullet"><span class="by">ezconnect</span><span>|</span><a href="#40412812">root</a><span>|</span><a href="#40412874">parent</a><span>|</span><a href="#40413068">prev</a><span>|</span><a href="#40413101">next</a><span>|</span><label class="collapse" for="c-40413165">[-]</label><label class="expand" for="c-40413165">[1 more]</label></div><br/><div class="children"><div class="content">He even uses &#x27;switch&#x27; on his code.</div><br/></div></div></div></div><div id="40413101" class="c"><input type="checkbox" id="c-40413101" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40412812">parent</a><span>|</span><a href="#40412874">prev</a><span>|</span><a href="#40412908">next</a><span>|</span><label class="collapse" for="c-40413101">[-]</label><label class="expand" for="c-40413101">[1 more]</label></div><br/><div class="children"><div class="content">I think the fact that graphics care a lot more about efficiency over marginal accuracy qualifies for a specific reason. Besides from that and a few select areas like ML, almost any reason to use `float` <i>by default</i> vanishes.</div><br/></div></div></div></div><div id="40412908" class="c"><input type="checkbox" id="c-40412908" checked=""/><div class="controls bullet"><span class="by">robxorb</span><span>|</span><a href="#40412812">prev</a><span>|</span><a href="#40412979">next</a><span>|</span><label class="collapse" for="c-40412908">[-]</label><label class="expand" for="c-40412908">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Write correct, readable, simple and maintainable software, and tune it when you&#x27;re done, with benchmarks to identify the choke points<p>If speed is a primary concern, you can&#x27;t tack it on at the end, it needs to be built in architecturally. Benchmarks applied after meeting goals of read&#x2F;maintainability are only benchmarking the limits of that approach and focus.<p>They can&#x27;t capture the results of trying and benchmarking several different fundamental approaches made at the outset in order to best choose the initial direction. In this case &quot;optimisation&quot; is almost happening <i>first</i>.<p>Sometimes the fastest approach may not be particularly maintainable, and that may be just fine if that component is not expected to require maintaining, eg, a pure C bare-metal in a bespoke and one-off embedded environment.</div><br/><div id="40413405" class="c"><input type="checkbox" id="c-40413405" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40412908">parent</a><span>|</span><a href="#40413288">next</a><span>|</span><label class="collapse" for="c-40413405">[-]</label><label class="expand" for="c-40413405">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if this embedded development still alive. I&#x27;m writing firmware for nRF BLE chip which is supposed to run from battery and their SDK uses operating system. Absolutely monstrous chips with enormous RAM and Flash. Makes zero sense to optimize for anything, as long as device sleeps well.</div><br/><div id="40413513" class="c"><input type="checkbox" id="c-40413513" checked=""/><div class="controls bullet"><span class="by">robxorb</span><span>|</span><a href="#40412908">root</a><span>|</span><a href="#40413405">parent</a><span>|</span><a href="#40413288">next</a><span>|</span><label class="collapse" for="c-40413513">[-]</label><label class="expand" for="c-40413513">[1 more]</label></div><br/><div class="children"><div class="content">Probably right in the broader sense, but there are still niches. Eg, for one: space deployments, where sufficiently hardened parts may lag decades behind SOTA and the environ can require a careful balance of energy&#x2F;heat against run-time.</div><br/></div></div></div></div><div id="40413288" class="c"><input type="checkbox" id="c-40413288" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40412908">parent</a><span>|</span><a href="#40413405">prev</a><span>|</span><a href="#40412979">next</a><span>|</span><label class="collapse" for="c-40413288">[-]</label><label class="expand" for="c-40413288">[1 more]</label></div><br/><div class="children"><div class="content">That was my way of thinking as I was junior programming.</div><br/></div></div></div></div><div id="40412979" class="c"><input type="checkbox" id="c-40412979" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40412908">prev</a><span>|</span><a href="#40413428">next</a><span>|</span><label class="collapse" for="c-40412979">[-]</label><label class="expand" for="c-40412979">[10 more]</label></div><br/><div class="children"><div class="content"><i>Treat 79 characters as a hard limit</i><p>Try pasting a long URL into a comment describing a method&#x2F;problem&#x2F;solution and youâll see immediately that it doesnât fit 77 chars and you cannot wrap it. Then due to your hard limit youâll invent something like â&#x2F;&#x2F; see explained.txt:123 for explanationâ or maybe â<a href="https:&#x2F;&#x2F;shrt.url&#x2F;f0ob4râ" rel="nofollow">https:&#x2F;&#x2F;shrt.url&#x2F;f0ob4râ</a> it.<p>Thereâs nothing wrong with breaking limits if you do that reasonably, cause most limits have edge cases. Itâs (Rule -&gt; Goal X) most of the times, but sometimes itâs (Rule -&gt; Issue). Make it (Solution (breaks Rule) -&gt; Goal X), not (Solution (obeys Rule) -&gt; not (Goal X)).</div><br/><div id="40413042" class="c"><input type="checkbox" id="c-40413042" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#40412979">parent</a><span>|</span><a href="#40413076">next</a><span>|</span><label class="collapse" for="c-40413042">[-]</label><label class="expand" for="c-40413042">[5 more]</label></div><br/><div class="children"><div class="content">Agree. This 80 character limit stems from a time where terminals could only display comparatively few characters in a line, a limit we haven&#x27;t had in decades as screen resolutions grew.<p>Another argument for shorters lines is that it is much harder for us to read any text when lines get too long. There&#x27;s a reason why we read and write documents in portrait mode, not landscape.<p>But in sum, I don&#x27;t think there&#x27;s a need for creating a hard limit at the 80 character mark. Most code is not indented more than three or four times anyways, and most if not all languages allow you to insert newlines to make long expressions wrap. However, if you occasionally <i>do</i> need to go longer, I think that&#x27;s completely fine and certainly better than having to bend around an arcane character limit.</div><br/><div id="40413266" class="c"><input type="checkbox" id="c-40413266" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40412979">root</a><span>|</span><a href="#40413042">parent</a><span>|</span><a href="#40413076">next</a><span>|</span><label class="collapse" for="c-40413266">[-]</label><label class="expand" for="c-40413266">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This 80 character limit stems from a time where terminals could only display comparatively few characters in a line, a limit we haven&#x27;t had in decades as screen resolutions grew.<p>The 80 char rule has little to do with old monitors. Has to do with ergonomics, and is why any good edited and typeset book will have between 60 and 80 characters per line.</div><br/><div id="40413482" class="c"><input type="checkbox" id="c-40413482" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#40412979">root</a><span>|</span><a href="#40413266">parent</a><span>|</span><a href="#40413531">next</a><span>|</span><label class="collapse" for="c-40413482">[-]</label><label class="expand" for="c-40413482">[1 more]</label></div><br/><div class="children"><div class="content">Exactly this. Open a novel and count the characters on a line; around 80 is <i>readable</i> as 500 years of typographic practice has determined.  Two or three levels of indentation and that bumps the page width up a bit, still less than 100.</div><br/></div></div><div id="40413531" class="c"><input type="checkbox" id="c-40413531" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#40412979">root</a><span>|</span><a href="#40413266">parent</a><span>|</span><a href="#40413482">prev</a><span>|</span><a href="#40413500">next</a><span>|</span><label class="collapse" for="c-40413531">[-]</label><label class="expand" for="c-40413531">[1 more]</label></div><br/><div class="children"><div class="content">80 column punched cards were a very strong influence</div><br/></div></div><div id="40413500" class="c"><input type="checkbox" id="c-40413500" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#40412979">root</a><span>|</span><a href="#40413266">parent</a><span>|</span><a href="#40413531">prev</a><span>|</span><a href="#40413076">next</a><span>|</span><label class="collapse" for="c-40413500">[-]</label><label class="expand" for="c-40413500">[1 more]</label></div><br/><div class="children"><div class="content">It is a fair point, but a book is 60 - 80 characters of dense prose line after line in thick paragraphs; it is not clear how this translates to lines of code.</div><br/></div></div></div></div></div></div><div id="40413076" class="c"><input type="checkbox" id="c-40413076" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40412979">parent</a><span>|</span><a href="#40413042">prev</a><span>|</span><a href="#40413252">next</a><span>|</span><label class="collapse" for="c-40413076">[-]</label><label class="expand" for="c-40413076">[3 more]</label></div><br/><div class="children"><div class="content">And at the very least, &quot;80-characters-per-line is a de-facto standard for viewing code&quot; has been long wrong. As the post even mentions, 100 and 120 columns have been another popular choices and thus we don&#x27;t really have any de-facto standard about them!</div><br/><div id="40413390" class="c"><input type="checkbox" id="c-40413390" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40412979">root</a><span>|</span><a href="#40413076">parent</a><span>|</span><a href="#40413252">next</a><span>|</span><label class="collapse" for="c-40413390">[-]</label><label class="expand" for="c-40413390">[2 more]</label></div><br/><div class="children"><div class="content">My opinion is that line width depends on identifier naming style.<p>For example Java often prefers long explicitly verbose names for class, fields, methods, variables.<p>Another approach is to use short names as much as possible. `mkdir` instead of `create_directory`, `i` instead of `person_index` and so on.<p>I think that max line length greatly depends on the chosen identifier naming style. So it makes sense to use 100 or 120 for Java and it makes sense to use 72 for Golang.<p>C code often use short naming style, so 72 or 80 should be fine.</div><br/><div id="40413435" class="c"><input type="checkbox" id="c-40413435" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40412979">root</a><span>|</span><a href="#40413390">parent</a><span>|</span><a href="#40413252">next</a><span>|</span><label class="collapse" for="c-40413435">[-]</label><label class="expand" for="c-40413435">[1 more]</label></div><br/><div class="children"><div class="content">And you risk a collision for global identifiers, which cannot be reorganized in C. If some library had the same thought and defined `mkdir` first, your code can&#x27;t define `mkdir` even as a private symbol. So you have to prefix everything and that contributes to the identifier length. In comparison, Go has a much better (but personally not yet satisfactory) module system and can have a lower limit.</div><br/></div></div></div></div></div></div><div id="40413252" class="c"><input type="checkbox" id="c-40413252" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40412979">parent</a><span>|</span><a href="#40413076">prev</a><span>|</span><a href="#40413428">next</a><span>|</span><label class="collapse" for="c-40413252">[-]</label><label class="expand" for="c-40413252">[1 more]</label></div><br/><div class="children"><div class="content">No rule is absolute. So you may have some line longer. Anyway Iâm VERY skeptic that hardcoding URLs is a good idea at all.</div><br/></div></div></div></div><div id="40413428" class="c"><input type="checkbox" id="c-40413428" checked=""/><div class="controls bullet"><span class="by">jackiesshirt</span><span>|</span><a href="#40412979">prev</a><span>|</span><a href="#40413096">next</a><span>|</span><label class="collapse" for="c-40413428">[-]</label><label class="expand" for="c-40413428">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Prefer compound literals to superfluous variables<p>I used to agree with this but I have moved away from compound literals entirely except for global statics&#x2F;const definitions.<p>Having a variable and explicit:<p><pre><code>  foo.x = whatever;
  foo.y = something_else;
</code></pre>
Leads to better debug experience imo, can set breakpoints and single step each assignment and have a name to put a watch on.</div><br/><div id="40413464" class="c"><input type="checkbox" id="c-40413464" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40413428">parent</a><span>|</span><a href="#40413096">next</a><span>|</span><label class="collapse" for="c-40413464">[-]</label><label class="expand" for="c-40413464">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, what&#x27;s the point of single-stepping over a simple data assignment though? And when the initialization involves function calls, the debugger will step into those anyway.<p>One advantage of initialization via compound literals is that you can make the target immutable, and you won&#x27;t accidentially get any uninitialized junk in unlisted struct members, e.g.:<p>const vec3 vec = { .x = 1.0, .y = 2.0 };<p>...vec.z will be default-initialized to zero, and vec doesn&#x27;t need to be mutable.</div><br/></div></div></div></div><div id="40412895" class="c"><input type="checkbox" id="c-40412895" checked=""/><div class="controls bullet"><span class="by">liblfds-temp</span><span>|</span><a href="#40413096">prev</a><span>|</span><a href="#40413177">next</a><span>|</span><label class="collapse" for="c-40412895">[-]</label><label class="expand" for="c-40412895">[7 more]</label></div><br/><div class="children"><div class="content">Declare all variables&#x2F;qualifiers right-to-left.<p>Read the type for all the below right-to-left, substituting the word &quot;pointer&quot; for &quot;*&quot;.<p><pre><code>  int long long unsigned wibble; &#x2F;&#x2F; unsigned long long int
  double const *long_number; &#x2F;&#x2F; pointer to a const double
  double volatile * const immutable_pointer; &#x2F;&#x2F; immutable pointer to a volatile double
</code></pre>
They all read correctly now, when read right-to-left.  It&#x27;s not just &quot;const&quot; you do this for, as per the advice.  Do it for all qualifiers.</div><br/><div id="40412995" class="c"><input type="checkbox" id="c-40412995" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#40412895">parent</a><span>|</span><a href="#40412912">next</a><span>|</span><label class="collapse" for="c-40412995">[-]</label><label class="expand" for="c-40412995">[1 more]</label></div><br/><div class="children"><div class="content">* doesn&#x27;t (have to) mean &quot;pointer&quot;!<p>It works in simple cases, but I find the consistent thing to do is read it as &quot;dereference&quot;.<p><pre><code>    double volatile *(const immutable_pointer); 
    &#x2F;&#x2F; immutable_pointer is immutable, when you dereference it you&#x27;ll get a volatile double</code></pre></div><br/></div></div><div id="40412912" class="c"><input type="checkbox" id="c-40412912" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40412895">parent</a><span>|</span><a href="#40412995">prev</a><span>|</span><a href="#40413177">next</a><span>|</span><label class="collapse" for="c-40412912">[-]</label><label class="expand" for="c-40412912">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the author&#x27;s justification?  What&#x27;s your justification?<p>&gt; They all read correctly now, when read right-to-left.<p>... suppose I&#x27;m someone who reads from left-to-right, should I flip the order to make it correct for me?</div><br/><div id="40413029" class="c"><input type="checkbox" id="c-40413029" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#40412895">root</a><span>|</span><a href="#40412912">parent</a><span>|</span><a href="#40412947">next</a><span>|</span><label class="collapse" for="c-40413029">[-]</label><label class="expand" for="c-40413029">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s the author&#x27;s justification? What&#x27;s your justification?<p>Iâm neither of them, but chances are thatâs because you canât make them left-to-right all the time.<p><pre><code>  double const *foo; &#x2F;&#x2F; foo is a pointer to a const double
  double *const foo; &#x2F;&#x2F; foo is a const pointer to a double
</code></pre>
compile and do what the comment says; these do not compile:<p><pre><code>  * const double foo; &#x2F;&#x2F; a pointer to a const double named âfooâ
  foo * const double; &#x2F;&#x2F; foo is a pointer to a const double</code></pre></div><br/><div id="40413224" class="c"><input type="checkbox" id="c-40413224" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#40412895">root</a><span>|</span><a href="#40413029">parent</a><span>|</span><a href="#40412947">next</a><span>|</span><label class="collapse" for="c-40413224">[-]</label><label class="expand" for="c-40413224">[1 more]</label></div><br/><div class="children"><div class="content">I use the &quot;right-to-left&quot; style myself.  To me, the qualifier (in this case, const), applies to the item to the right.  This could be confusing:<p><pre><code>    const char *const ptr;
</code></pre>
The first const applies to the char, but the second one to the pointer itself.  Being consistent:<p><pre><code>    char const *const ptr;
</code></pre>
The first const applies to the item to its left---char.  The second const applies to the item to its left---the pointer.  To recap:<p><pre><code>    char *ptr1; &#x2F;&#x2F; modifiable pointer to modifiable data
    char const *ptr2; &#x2F;&#x2F; modifiable pointer to const data
    char *const ptr3; &#x2F;&#x2F; const pointer to modifiable data
    char const *const ptr4; &#x2F;&#x2F; const pointer to const data</code></pre></div><br/></div></div></div></div><div id="40412947" class="c"><input type="checkbox" id="c-40412947" checked=""/><div class="controls bullet"><span class="by">liblfds-temp</span><span>|</span><a href="#40412895">root</a><span>|</span><a href="#40412912">parent</a><span>|</span><a href="#40413029">prev</a><span>|</span><a href="#40413177">next</a><span>|</span><label class="collapse" for="c-40412947">[-]</label><label class="expand" for="c-40412947">[2 more]</label></div><br/><div class="children"><div class="content">Readability.<p>C declarations can become unfriendly by being too complex and disordered.</div><br/><div id="40413014" class="c"><input type="checkbox" id="c-40413014" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40412895">root</a><span>|</span><a href="#40412947">parent</a><span>|</span><a href="#40413177">next</a><span>|</span><label class="collapse" for="c-40413014">[-]</label><label class="expand" for="c-40413014">[1 more]</label></div><br/><div class="children"><div class="content">Nothing seems wrong with âvolatile double pointer as a constantâ or âconstant character pointerâ either, tbh. The way you presented is equivalent, but non-idiomatic, people would stumble upon it often. To become more readable universally this must have been adopted 50 years ago.</div><br/></div></div></div></div></div></div></div></div><div id="40413177" class="c"><input type="checkbox" id="c-40413177" checked=""/><div class="controls bullet"><span class="by">marhee</span><span>|</span><a href="#40412895">prev</a><span>|</span><a href="#40413338">next</a><span>|</span><label class="collapse" for="c-40413177">[-]</label><label class="expand" for="c-40413177">[2 more]</label></div><br/><div class="children"><div class="content">&gt; developers have a hope of being able to determine which #includes can be removed and which can&#x27;t<p>Canât a modern compiler do that already? Didnât google but seems an obvious compiler feature at the very least behind a warning flag.</div><br/><div id="40413431" class="c"><input type="checkbox" id="c-40413431" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40413177">parent</a><span>|</span><a href="#40413338">next</a><span>|</span><label class="collapse" for="c-40413431">[-]</label><label class="expand" for="c-40413431">[1 more]</label></div><br/><div class="children"><div class="content">Clang-tidy (linter) can do that. IMO it&#x27;s a good idea to integrate this tool to any C project. I&#x27;m using gcc for embedded projects and clang-tidy works just fine as a separate tool.<p><a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;extra&#x2F;clang-tidy&#x2F;checks&#x2F;misc&#x2F;include-cleaner.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;extra&#x2F;clang-tidy&#x2F;checks&#x2F;misc&#x2F;include-...</a></div><br/></div></div></div></div><div id="40413338" class="c"><input type="checkbox" id="c-40413338" checked=""/><div class="controls bullet"><span class="by">LeoNatan25</span><span>|</span><a href="#40413177">prev</a><span>|</span><a href="#40413381">next</a><span>|</span><label class="collapse" for="c-40413338">[-]</label><label class="expand" for="c-40413338">[8 more]</label></div><br/><div class="children"><div class="content">&gt; 80-characters-per-line is a de-facto standard for viewing code. Readers of your code who rely on that standard, and have their terminal or editor sized to 80 characters wide, can fit more on the screen by placing windows side-by-side.<p>This is one of the silliest practices to still be enforced or even considered in 2024. âReadersâ should get a modern IDE&#x2F;text editor and&#x2F;or modern hardware.</div><br/><div id="40413348" class="c"><input type="checkbox" id="c-40413348" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40413338">parent</a><span>|</span><a href="#40413491">next</a><span>|</span><label class="collapse" for="c-40413348">[-]</label><label class="expand" for="c-40413348">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using modern IDE and 32&quot; 4K display yet I still support this rule. One example where it&#x27;s particularly convenient is 3-way merge. Also if we&#x27;re talking about IDE&#x27;s, they often use horizontal space for things like files tree (project explorer) and other tool windows.</div><br/></div></div><div id="40413491" class="c"><input type="checkbox" id="c-40413491" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40413338">parent</a><span>|</span><a href="#40413348">prev</a><span>|</span><a href="#40413548">next</a><span>|</span><label class="collapse" for="c-40413491">[-]</label><label class="expand" for="c-40413491">[1 more]</label></div><br/><div class="children"><div class="content">The rule is a bit silly sure, but OTH I typically have multiple editors tabs open side by side (I don&#x27;t restrict myself to a hard 80 char line width though, but I have vertical rulers set at 80 and 120 characters in the editor as visual guidance).</div><br/></div></div><div id="40413548" class="c"><input type="checkbox" id="c-40413548" checked=""/><div class="controls bullet"><span class="by">xipix</span><span>|</span><a href="#40413338">parent</a><span>|</span><a href="#40413491">prev</a><span>|</span><a href="#40413391">next</a><span>|</span><label class="collapse" for="c-40413548">[-]</label><label class="expand" for="c-40413548">[1 more]</label></div><br/><div class="children"><div class="content">A proportional font really helps ergonomics too.</div><br/></div></div><div id="40413391" class="c"><input type="checkbox" id="c-40413391" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#40413338">parent</a><span>|</span><a href="#40413548">prev</a><span>|</span><a href="#40413355">next</a><span>|</span><label class="collapse" for="c-40413391">[-]</label><label class="expand" for="c-40413391">[1 more]</label></div><br/><div class="children"><div class="content">au contraire! considering programming involves a lot of reading, it overlaps (or even comes from) with. best practices from ye olde tradition of typesetting <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Line_length#:~:text=Traditional%20line%20length%20research%2C%20limited,(including%20letters%20and%20spaces)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Line_length#:~:text=Traditio...</a>. Aside books and print magazines and newspapers, we still respect that on web sites when reading is involved, why should programming be exempt of ergonomy?</div><br/></div></div><div id="40413355" class="c"><input type="checkbox" id="c-40413355" checked=""/><div class="controls bullet"><span class="by">hkwerf</span><span>|</span><a href="#40413338">parent</a><span>|</span><a href="#40413391">prev</a><span>|</span><a href="#40413402">next</a><span>|</span><label class="collapse" for="c-40413355">[-]</label><label class="expand" for="c-40413355">[1 more]</label></div><br/><div class="children"><div class="content">The part you quoted has the one argument against yours right at the end. It&#x27;s not about hardware or IDEs or text editors, it&#x27;s about workspace layout.</div><br/></div></div><div id="40413402" class="c"><input type="checkbox" id="c-40413402" checked=""/><div class="controls bullet"><span class="by">jonathanstrange</span><span>|</span><a href="#40413338">parent</a><span>|</span><a href="#40413355">prev</a><span>|</span><a href="#40413362">next</a><span>|</span><label class="collapse" for="c-40413402">[-]</label><label class="expand" for="c-40413402">[1 more]</label></div><br/><div class="children"><div class="content">There is a reason why books have only between 45 to 75 characters per line. It greatly enhances readability.</div><br/></div></div></div></div><div id="40413381" class="c"><input type="checkbox" id="c-40413381" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40413338">prev</a><span>|</span><label class="collapse" for="c-40413381">[-]</label><label class="expand" for="c-40413381">[1 more]</label></div><br/><div class="children"><div class="content">While I don&#x27;t agree every single point (see below), one thing great about this document is that the author tried to really elaborate one&#x27;s opinion. That makes a good point to start the discussion regardless of my own opinion. Thus I&#x27;ll contribute back by giving my own judgement for every single item here:<p>Absolute agreement<p><pre><code>  * Always develop and compile with all warnings (and more) on
  * #include the definition of everything you use
  * Provide include guards for all headers to prevent double inclusion
  * Always comment `#endif`s of large conditional sections
  * Declare variables as late as possible
  * Be consistent in your variable names across functions
  * Minimize the scope of variables
  * Use `assert` everywhere your program would fail otherwise
  * Repeat `assert` calls; don&#x27;t `&amp;&amp;` them together
  * C isn&#x27;t object-oriented, and you shouldn&#x27;t pretend it is
</code></pre>
Strong agreement with some obvious exceptions<p><pre><code>  * Use `&#x2F;&#x2F;` comments everywhere, never `&#x2F;* ... *&#x2F;`
  * Comment non-standard-library `#include`s to say what symbols you use from them
  * No global or static variables if you can help it (you probably can)
  * Minimize what you expose; declare top-level names static where you can
  * Use `double` rather than `float`, unless you have a specific reason otherwise
  * Avoid non-pure or non-trivial function calls in expressions
  * Simple constant expressions can be easier to read than variables
  * Initialize strings as arrays, and use sizeof for byte size
  * Where possible, use `sizeof` on the variable; not the type
  * Document your struct invariants, and provide invariant checkers
  * Avoid `void *` because it harms type safety
  * If you have a `void *`, assign it to a typed variable as soon as possible
  * Only use pointers in structs for nullity, dynamic arrays or incomplete types
  * Avoid getters and setters
</code></pre>
Agreed but you need a few more words<p><pre><code>  * Don&#x27;t be afraid of short variable names [if the scope fits on a screen]
  * Explicitly compare values; don&#x27;t rely on truthiness
    [unless values themselves are boolean]
  * Use parentheses for expressions where the operator precedence isn&#x27;t obvious
    [but `&amp;foo-&gt;bar` *is* obvious]
  * Separate functions and struct definitions with two lines
    [can use comments instead]
  * If a macro is specific to a function, `#define` it in the body [and `#undef` ASAP]
  * Only typedef structs; never basic types or pointers
    [or make them distinct enough, but ISO C stole a `_t` suffix]
</code></pre>
I do so or I see why but that&#x27;s really a problem of C and its ecosystem instead<p><pre><code>  * Use GCC&#x27;s and Clang&#x27;s `-M` to automatically generate object file dependencies
  * Avoid unified headers
  * Immutability saves lives: use `const` everywhere you can
  * Use `bool` from `stdbool.h` whenever you have a boolean value
  * Avoid unsigned types because the integer conversion rules are complicated
  * Prefer compound literals to superfluous variables
  * Never use array syntax for function arguments definitions
  * Don&#x27;t use variable-length arrays
  * Use C11&#x27;s anonymous structs and unions rather mutually-exclusive fields
  * Give structs TitleCase names, and typedef them
  * Never begin names with `_` or end them with `_t`: they&#x27;re reserved for standards
  * Only use pointer arguments for nullity, arrays or modifications
  * Prefer to return a value rather than modifying pointers
  * Always use designated initializers in struct literals
</code></pre>
I do so but am not sure<p><pre><code>  * Write to the most modern standard you can [we have no choice for many cases]
  * Program in American English [only applicable for native speakers]
</code></pre>
I see why but I think you are mislead<p><pre><code>  * Don&#x27;t write argument names in function prototypes if they just repeat the type
    [such case is very, very rare]
  * Use `+= 1` and `-= 1` over `++` and `--`
    [`++`&#x2F;`--` should be read as succ&#x2F;pred and should be exclusively used for pointers]
  * Don&#x27;t use `switch`, and avoid complicated conditionals
    [switch is okay once you have enabled enough warnings]
  * Only upper-case a macro if will act differently than a function call
    [agreed in principle, but should define &quot;differently&quot; more broadly]
  * Always prefer array indexing over pointer arithmetic
    [and then you will be biten by index variable types, remember `ptrdiff_t`]
</code></pre>
That&#x27;s really just a personal preference<p><pre><code>  * We can&#x27;t get tabs right, so use spaces everywhere
    [as long as mechanically enforcable, the choice itself is irrelevant]
  * Always put `const` on the right and read types right-to-left [too eyesore]
  * Use one line per variable definition; don&#x27;t bunch same types together
    [will agree with some significant exceptions though]
  * Never change state within an expression (e.g. with assignments or `++`)
    [absolutely avoid functions, but `++` has its uses]
  * Always use brackets, even for single-statement block
    [rather a read-write trade-off; this may make some codes harder to read]
  * Never use or provide macros that wrap control structures like `for`
    [the example is very tame in comparison to actually problematic macros]
  * Don&#x27;t typecast unless you have to (you probably don&#x27;t)
    [while many typecasts can be easily removed, excess doesn&#x27;t do actual harm]
  * Give enums `UPPERCASE_SNAKE` names, and lowercase their values
    [I would rather avoid enums for various reasons]
  * Use structs to name functions&#x27; optional arguments
    [maybe the author tried to say &quot;avoid too many arguments&quot; instead?]
  * If you&#x27;re providing allocation and free functions only for a struct member,
    allocate memory for the whole struct
    [that complicates using struct as a value]
</code></pre>
Just no.<p><pre><code>  * Never have more than 79 characters per line
    [100 or 120 do work equally well, you do need some limit though]
  * Define a constant for the size of every enum
    [would imply that all enum values are sequential, and that&#x27;s not true!]</code></pre></div><br/></div></div></div></div></div></div></div></body></html>