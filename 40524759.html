<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717146073707" as="style"/><link rel="stylesheet" href="styles.css?v=1717146073707"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.assembled.com/blog/better-rag-results-with-reciprocal-rank-fusion-and-hybrid-search">Better RAG Results with Reciprocal Rank Fusion and Hybrid Search</a> <span class="domain">(<a href="https://www.assembled.com">www.assembled.com</a>)</span></div><div class="subtext"><span>johnjwang</span> | <span>41 comments</span></div><br/><div><div id="40527925" class="c"><input type="checkbox" id="c-40527925" checked=""/><div class="controls bullet"><span class="by">pamelafox</span><span>|</span><a href="#40530785">next</a><span>|</span><label class="collapse" for="c-40527925">[-]</label><label class="expand" for="c-40527925">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re looking for an example of RRF + Hybrid Search with PostgreSQL, I&#x27;ve put together a FastAPI app here that uses RAG with those options:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Azure-Samples&#x2F;rag-postgres-openai-python&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;Azure-Samples&#x2F;rag-postgres-openai-python&#x2F;</a><p>Here&#x27;s the RRF+Hybrid part:
<a href="https:&#x2F;&#x2F;github.com&#x2F;Azure-Samples&#x2F;rag-postgres-openai-python&#x2F;blob&#x2F;e30ea96ca11ca6578ca38d3428594bd98d704900&#x2F;src&#x2F;fastapi_app&#x2F;postgres_searcher.py#L38">https:&#x2F;&#x2F;github.com&#x2F;Azure-Samples&#x2F;rag-postgres-openai-python&#x2F;...</a><p>That&#x27;s largely based off a sample from the pgvector repo, with a few tweaks.<p>Agreed that Hybrid is the way to go, it&#x27;s what the Azure AI Search team also recommends, based off their research:<p><a href="https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;ai-azure-ai-services-blog&#x2F;azure-ai-search-outperforming-vector-search-with-hybrid&#x2F;ba-p&#x2F;3929167" rel="nofollow">https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;ai-azure-ai-services-...</a></div><br/></div></div><div id="40530785" class="c"><input type="checkbox" id="c-40530785" checked=""/><div class="controls bullet"><span class="by">yingfeng</span><span>|</span><a href="#40527925">prev</a><span>|</span><a href="#40525320">next</a><span>|</span><label class="collapse" for="c-40530785">[-]</label><label class="expand" for="c-40530785">[2 more]</label></div><br/><div class="children"><div class="content">RRF is a simple and effective means of fused ranking for multiple recall.
Within our open source RAG product RAGFlow(<a href="https:&#x2F;&#x2F;github.com&#x2F;infiniflow&#x2F;ragflow">https:&#x2F;&#x2F;github.com&#x2F;infiniflow&#x2F;ragflow</a>), Elasticsearch is currently used instead of other general vector databases, because it can provide hybrid search right now. Under the default cases, embedding based reranker is not required, just RRF is enough, while even if reranker is used, keywords based retrieval is also a MUST to be hybridized with embedding based retrieval, that&#x27;s just what RAGFlow&#x27;s latest 0.7 release has provided.<p>On the other hand let me introduce another database we developed, Infinity(<a href="https:&#x2F;&#x2F;github.com&#x2F;infiniflow&#x2F;infinity">https:&#x2F;&#x2F;github.com&#x2F;infiniflow&#x2F;infinity</a>), which can provide the hybrid search, you can see the performance here(<a href="https:&#x2F;&#x2F;github.com&#x2F;infiniflow&#x2F;infinity&#x2F;blob&#x2F;main&#x2F;docs&#x2F;references&#x2F;benchmark.md">https:&#x2F;&#x2F;github.com&#x2F;infiniflow&#x2F;infinity&#x2F;blob&#x2F;main&#x2F;docs&#x2F;refere...</a>), both vector search and full-text search could perform much faster than other open source alternatives.<p>From the next version(weeks later), Infinity will also provide more comprehensive hybrid search capabilities, what you have mentioned the 3-way recalls(dense vector, sparse vector, keyword search) could be provided within single request.</div><br/><div id="40532447" class="c"><input type="checkbox" id="c-40532447" checked=""/><div class="controls bullet"><span class="by">testfoo444</span><span>|</span><a href="#40530785">parent</a><span>|</span><a href="#40525320">next</a><span>|</span><label class="collapse" for="c-40532447">[-]</label><label class="expand" for="c-40532447">[1 more]</label></div><br/><div class="children"><div class="content">Elastic Search is publishing a lot of interesting posts on this topic although with a bit of marketing for ex <a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;search-labs&#x2F;blog&#x2F;semantic-reranking-with-retrievers" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;search-labs&#x2F;blog&#x2F;semantic-reranking-w...</a></div><br/></div></div></div></div><div id="40525320" class="c"><input type="checkbox" id="c-40525320" checked=""/><div class="controls bullet"><span class="by">edude03</span><span>|</span><a href="#40530785">prev</a><span>|</span><a href="#40529079">next</a><span>|</span><label class="collapse" for="c-40525320">[-]</label><label class="expand" for="c-40525320">[6 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, I like the approach and it makes a lot of sense for the problem space. Especially using existing products vs building&#x2F;hosting your own.<p>I was however tripped up by this sentence close to the beginning:<p>&gt; we encountered a significant challenge with RAG: relying solely on vector search (even using both dense and sparse vectors) doesn’t always deliver satisfactory results for certain queries.<p>Not to be overly pedantic, but that&#x27;s a problem with vector similarity, not RAG as a concept.<p>Although the author is clearly aware of that - I have had numerous conversations in the past few months alone of people essentially saying &quot;RAG doesn&#x27;t work because I use pg_vector (or whatever) and it never finds what I&#x27;m looking for&quot; not realizing 1) it&#x27;s not the only way to do RAG, and 2) there is often a fair difference between the embeddings and the vectorized query, and with awareness of why that is you can figure out how to fix it.<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;@cdg2718&#x2F;why-your-rag-doesnt-work-9755726dd1e9" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@cdg2718&#x2F;why-your-rag-doesnt-work-9755726...</a> basically says everything I often say to people with RAG&#x2F;vector search problems but again, seems like the assembled team has it handled :)</div><br/><div id="40531282" class="c"><input type="checkbox" id="c-40531282" checked=""/><div class="controls bullet"><span class="by">visarga</span><span>|</span><a href="#40525320">parent</a><span>|</span><a href="#40525374">next</a><span>|</span><label class="collapse" for="c-40531282">[-]</label><label class="expand" for="c-40531282">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not to be overly pedantic, but that&#x27;s a problem with vector similarity, not RAG as a concept.<p>Vector similarity has a surprising failure mode. It only indexes explicit information, missing out the implicit one.
For example &quot;The second word of this phrase, decremented by one&quot; is &quot;first&quot;, do you think these strings will embed the same? Calculated results don&#x27;t retrieve well. Also, deductions in general.<p>How about &quot;I agree with what John said, but I&#x27;d rather apply Victor&#x27;s solution&quot;? It won&#x27;t embed like the answer you seek. Multi-hop information seeking questions don&#x27;t retrieve well.<p>The obvious fix is to pre-ingest all the RAG text into a LLM and calculate these deductions before embedding.</div><br/></div></div><div id="40525374" class="c"><input type="checkbox" id="c-40525374" checked=""/><div class="controls bullet"><span class="by">johnjwang</span><span>|</span><a href="#40525320">parent</a><span>|</span><a href="#40531282">prev</a><span>|</span><a href="#40529079">next</a><span>|</span><label class="collapse" for="c-40525374">[-]</label><label class="expand" for="c-40525374">[4 more]</label></div><br/><div class="children"><div class="content">Author here: you&#x27;re for sure right -- it&#x27;s not a problem with RAG the theoretical concept. In fact, I think RAG implementations should likely be specific to their use cases (e.g. our hybrid search approach works well for customer support, but I&#x27;m not sure if it would work as well in other contexts, say for legal bots).<p>I&#x27;ve seen the whole gamut of RAG implementations as well, and the implementation, specifically prompting and the document search has a lot to do with the end quality.</div><br/><div id="40526282" class="c"><input type="checkbox" id="c-40526282" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40525320">root</a><span>|</span><a href="#40525374">parent</a><span>|</span><a href="#40529079">next</a><span>|</span><label class="collapse" for="c-40526282">[-]</label><label class="expand" for="c-40526282">[3 more]</label></div><br/><div class="children"><div class="content">re: legal, I saw a post on this idea where their RAG system was designed to return the actual text from the document rather than a LLM response or summary. The LLM played a role in turning the query into the search params, but the insight was that for certain kinds of documents, you want the actual source because of the existing, human written summary or the detailed nuances therein</div><br/><div id="40529191" class="c"><input type="checkbox" id="c-40529191" checked=""/><div class="controls bullet"><span class="by">gradys</span><span>|</span><a href="#40525320">root</a><span>|</span><a href="#40526282">parent</a><span>|</span><a href="#40529079">next</a><span>|</span><label class="collapse" for="c-40529191">[-]</label><label class="expand" for="c-40529191">[2 more]</label></div><br/><div class="children"><div class="content">Sounds more like Generation Augmented Retrieval in that case.</div><br/><div id="40532195" class="c"><input type="checkbox" id="c-40532195" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40525320">root</a><span>|</span><a href="#40529191">parent</a><span>|</span><a href="#40529079">next</a><span>|</span><label class="collapse" for="c-40532195">[-]</label><label class="expand" for="c-40532195">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t this GAR post, I remember them calling out legal docs explicitly, might have seen it on Twitter<p><a href="https:&#x2F;&#x2F;blog.luk.sh&#x2F;rag-vs-gar" rel="nofollow">https:&#x2F;&#x2F;blog.luk.sh&#x2F;rag-vs-gar</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40529079" class="c"><input type="checkbox" id="c-40529079" checked=""/><div class="controls bullet"><span class="by">thefourthchime</span><span>|</span><a href="#40525320">prev</a><span>|</span><a href="#40528130">next</a><span>|</span><label class="collapse" for="c-40529079">[-]</label><label class="expand" for="c-40529079">[4 more]</label></div><br/><div class="children"><div class="content">I also found pure RAG with vector search to not work. I was creating a bot that could find answers to questions about things by looking at Slack discussions.<p>At first, I downloaded entire channels, loaded them into a vector DB, and did RAG. The results sucked. Vector searches don&#x27;t understand things very well, and in this world, specific keywords and error messages are very searchable.<p>Instead, I take the user&#x27;s query, ask an LLM (Claude &#x2F; Bedrock) to find keywords, then search Slack using the API, get results, and use an LLM to filter for discussions that are relevant, then summarize them all in a response.<p>This is slow, of course, so it&#x27;s very multi-threaded. A typical response will be within 30 seconds.</div><br/><div id="40532639" class="c"><input type="checkbox" id="c-40532639" checked=""/><div class="controls bullet"><span class="by">qeternity</span><span>|</span><a href="#40529079">parent</a><span>|</span><a href="#40529308">next</a><span>|</span><label class="collapse" for="c-40532639">[-]</label><label class="expand" for="c-40532639">[1 more]</label></div><br/><div class="children"><div class="content">Are you doing this for a product or for internal usage?</div><br/></div></div><div id="40529308" class="c"><input type="checkbox" id="c-40529308" checked=""/><div class="controls bullet"><span class="by">siquick</span><span>|</span><a href="#40529079">parent</a><span>|</span><a href="#40532639">prev</a><span>|</span><a href="#40530710">next</a><span>|</span><label class="collapse" for="c-40529308">[-]</label><label class="expand" for="c-40529308">[1 more]</label></div><br/><div class="children"><div class="content">When you’re creating your embedding you can store keywords from the content (using an LLM) in the metadata of each chunk which would positively increase the relevancy of results turned from the retrieval.<p>LlamaIndex does this out of the box.</div><br/></div></div><div id="40530710" class="c"><input type="checkbox" id="c-40530710" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40529079">parent</a><span>|</span><a href="#40529308">prev</a><span>|</span><a href="#40528130">next</a><span>|</span><label class="collapse" for="c-40530710">[-]</label><label class="expand" for="c-40530710">[1 more]</label></div><br/><div class="children"><div class="content">Zero shot key phrase extraction is a reasonably well-studied field. I don’t know what the current SOTA is, but the one that was pretty hot shit last time I needed one was kbir-inspec which is on HuggingFace and you can test it right on the page.<p>Might be worth a shot if performance is a tricky spot in your setup.</div><br/></div></div></div></div><div id="40528130" class="c"><input type="checkbox" id="c-40528130" checked=""/><div class="controls bullet"><span class="by">pmc00</span><span>|</span><a href="#40529079">prev</a><span>|</span><a href="#40531978">next</a><span>|</span><label class="collapse" for="c-40528130">[-]</label><label class="expand" for="c-40528130">[1 more]</label></div><br/><div class="children"><div class="content">For another set of measurements that support RRF + Hybrid &gt; vectors, we (Azure AI Search team) did a bunch of evaluations a few months ago: <a href="https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;ai-azure-ai-services-blog&#x2F;azure-ai-search-outperforming-vector-search-with-hybrid&#x2F;ba-p&#x2F;3929167" rel="nofollow">https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;ai-azure-ai-services-...</a><p>We also included supporting data in that write up showing you can improve significantly on top of Hybrid&#x2F;RRF using a reranking stage (assuming you have a good reranker model), so we shipped one as an optional step as part of our search engine.</div><br/></div></div><div id="40531978" class="c"><input type="checkbox" id="c-40531978" checked=""/><div class="controls bullet"><span class="by">owen-elliott</span><span>|</span><a href="#40528130">prev</a><span>|</span><a href="#40527219">next</a><span>|</span><label class="collapse" for="c-40531978">[-]</label><label class="expand" for="c-40531978">[1 more]</label></div><br/><div class="children"><div class="content">The composability of RRF is definitely one of its most appealing characteristics. It doesn&#x27;t matter what algorithm or vendor you have, you can just fuse with ranks alone. I&#x27;ve seen it shine when fusing lexical and vector search results where semantic attributes like styles and exact attributes like quantities are mixed together in queries, e.g., &quot;modern formal watch with 40mm face&quot;.<p>While it&#x27;s not such a problem in RAG, one downside is that it complicates pagination for results (there are a few different ways to tackle this).</div><br/></div></div><div id="40527219" class="c"><input type="checkbox" id="c-40527219" checked=""/><div class="controls bullet"><span class="by">throwaway115</span><span>|</span><a href="#40531978">prev</a><span>|</span><a href="#40532017">next</a><span>|</span><label class="collapse" for="c-40527219">[-]</label><label class="expand" for="c-40527219">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve implemented a very similar RAG hybrid solution, and it has improved LLM responses enormously. There are other things you can do too that have huge improvements, like destructuring your data and placing it into a graph structure, with queryable edge relationships. I think we&#x27;re just scratching the surface.</div><br/><div id="40527846" class="c"><input type="checkbox" id="c-40527846" checked=""/><div class="controls bullet"><span class="by">Mkengine</span><span>|</span><a href="#40527219">parent</a><span>|</span><a href="#40532017">next</a><span>|</span><label class="collapse" for="c-40527846">[-]</label><label class="expand" for="c-40527846">[1 more]</label></div><br/><div class="children"><div class="content">This is really interesting, do you have other recommendations for improvements (gladly with sources I you have any)? I have to build a RAG solution for my job and right now I am collecting information to determine the best way to go ahead.</div><br/></div></div></div></div><div id="40532017" class="c"><input type="checkbox" id="c-40532017" checked=""/><div class="controls bullet"><span class="by">cricketlover</span><span>|</span><a href="#40527219">prev</a><span>|</span><a href="#40527737">next</a><span>|</span><label class="collapse" for="c-40532017">[-]</label><label class="expand" for="c-40532017">[1 more]</label></div><br/><div class="children"><div class="content">Pardon my ignorance but I was hung up on this line.<p>&gt;  Out-of-sync document stores could lead to subtle bugs, such as a document being present in one store but not another.<p>But then the article suggests to upload synchronously in S3&#x2F;DDB and then sync asynchronously to actual document stores. How does this solve out of sync issue? 
It doesn&#x27;t. It can&#x27;t be solved is what I&#x27;m thinking.<p>&gt; Data, numbers<p>How much data are we talking about?</div><br/></div></div><div id="40527737" class="c"><input type="checkbox" id="c-40527737" checked=""/><div class="controls bullet"><span class="by">retakeming</span><span>|</span><a href="#40532017">prev</a><span>|</span><a href="#40529014">next</a><span>|</span><label class="collapse" for="c-40527737">[-]</label><label class="expand" for="c-40527737">[1 more]</label></div><br/><div class="children"><div class="content">pg_search (full text search Postgres extension) can be used with pgvector for hybrid search over Postgres tables. It comes with a helpful hybrid search function that uses relative score fusion. Whereas rank fusion considers just the order of the results, relative score fusion uses the actual metrics outputted by text&#x2F;vector search.</div><br/></div></div><div id="40529014" class="c"><input type="checkbox" id="c-40529014" checked=""/><div class="controls bullet"><span class="by">cheesyFish</span><span>|</span><a href="#40527737">prev</a><span>|</span><a href="#40529391">next</a><span>|</span><label class="collapse" for="c-40529014">[-]</label><label class="expand" for="c-40529014">[1 more]</label></div><br/><div class="children"><div class="content">RRF is alright, but I&#x27;ve had better results with relative score, or distribution-based scoring.<p>LlamaIndex has a module for exactly this<p><a href="https:&#x2F;&#x2F;docs.llamaindex.ai&#x2F;en&#x2F;stable&#x2F;examples&#x2F;retrievers&#x2F;relative_score_dist_fusion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.llamaindex.ai&#x2F;en&#x2F;stable&#x2F;examples&#x2F;retrievers&#x2F;rel...</a></div><br/></div></div><div id="40529391" class="c"><input type="checkbox" id="c-40529391" checked=""/><div class="controls bullet"><span class="by">janalsncm</span><span>|</span><a href="#40529014">prev</a><span>|</span><a href="#40526551">next</a><span>|</span><label class="collapse" for="c-40529391">[-]</label><label class="expand" for="c-40529391">[1 more]</label></div><br/><div class="children"><div class="content">Reciprocal rank scoring is just one way of forcing scores into a fixed distribution: in this case, decaying with the reciprocal of its rank. But it also assumes fixed weight from all components, i.e. the top ranked keyword match has equal relevance to the top ranked semantic match.<p>There are a couple ways around this. Either learning the relative importance based on the query, and&#x2F;or using a separate reranking function (usually a DNN) that also takes user behavior into account.</div><br/></div></div><div id="40526551" class="c"><input type="checkbox" id="c-40526551" checked=""/><div class="controls bullet"><span class="by">SomewhatLikely</span><span>|</span><a href="#40529391">prev</a><span>|</span><a href="#40528199">next</a><span>|</span><label class="collapse" for="c-40526551">[-]</label><label class="expand" for="c-40526551">[3 more]</label></div><br/><div class="children"><div class="content">Both of your references use RRF=1&#x2F;(60+Rank)<p>So I&#x27;m not sure why the article uses 1&#x2F;Rank alone.  Did you test both and find that the smoothing didn&#x27;t help? My understanding is that it has been pretty important for the best results.</div><br/><div id="40526867" class="c"><input type="checkbox" id="c-40526867" checked=""/><div class="controls bullet"><span class="by">johnjwang</span><span>|</span><a href="#40526551">parent</a><span>|</span><a href="#40526876">next</a><span>|</span><label class="collapse" for="c-40526867">[-]</label><label class="expand" for="c-40526867">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good call out -- we use smoothing parameters that are closer to what you see in the academic articles (they&#x27;re tuned slightly, but not much).<p>We used 1&#x2F;Rank in the article for simplicity purposes, though I can see why this might be confusing to an astute reader.</div><br/></div></div></div></div><div id="40528199" class="c"><input type="checkbox" id="c-40528199" checked=""/><div class="controls bullet"><span class="by">treprinum</span><span>|</span><a href="#40526551">prev</a><span>|</span><a href="#40528507">next</a><span>|</span><label class="collapse" for="c-40528199">[-]</label><label class="expand" for="c-40528199">[1 more]</label></div><br/><div class="children"><div class="content">Hybrid might work for English but where are you going to get sparse embeddings like SPLADE or ELSERv2 for most other languages? Vector search with ada-002 or text-003-large capped to the first 500-1000 dimensions will give you a support for 100+ languages for free. If you are using BM25, then you need to train BM25 on every single separate knowledge base which is annoying and expensive.</div><br/></div></div><div id="40528507" class="c"><input type="checkbox" id="c-40528507" checked=""/><div class="controls bullet"><span class="by">mtbarta3</span><span>|</span><a href="#40528199">prev</a><span>|</span><a href="#40528361">next</a><span>|</span><label class="collapse" for="c-40528507">[-]</label><label class="expand" for="c-40528507">[1 more]</label></div><br/><div class="children"><div class="content">Great article. Hybrid search works well for a lot of scenarios.<p>The tradeoffs of using existing systems vs building your own resonate with me. What we eventually experienced, however, is that periods of bad search performance often correlated to out-of-date search indices.<p>I&#x27;d be interested in another article detailing how you monitor search. It can be tricky to keep an entire search system moving.</div><br/></div></div><div id="40528361" class="c"><input type="checkbox" id="c-40528361" checked=""/><div class="controls bullet"><span class="by">gregnr</span><span>|</span><a href="#40528507">prev</a><span>|</span><a href="#40528581">next</a><span>|</span><label class="collapse" for="c-40528361">[-]</label><label class="expand" for="c-40528361">[1 more]</label></div><br/><div class="children"><div class="content">In case you just want a single Postgres function that does RRF (pgvector+fts):
<a href="https:&#x2F;&#x2F;supabase.com&#x2F;docs&#x2F;guides&#x2F;ai&#x2F;hybrid-search">https:&#x2F;&#x2F;supabase.com&#x2F;docs&#x2F;guides&#x2F;ai&#x2F;hybrid-search</a><p>(disclaimer: supabase dev who went down the rabbit hole with hybrid search)</div><br/></div></div><div id="40528581" class="c"><input type="checkbox" id="c-40528581" checked=""/><div class="controls bullet"><span class="by">ko_pivot</span><span>|</span><a href="#40528361">prev</a><span>|</span><a href="#40527329">next</a><span>|</span><label class="collapse" for="c-40528581">[-]</label><label class="expand" for="c-40528581">[1 more]</label></div><br/><div class="children"><div class="content">Meilisearch has a really clean implementation of this. Can easily adjust keyword vs vector weighting per query.</div><br/></div></div><div id="40527329" class="c"><input type="checkbox" id="c-40527329" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40528581">prev</a><span>|</span><a href="#40528158">next</a><span>|</span><label class="collapse" for="c-40527329">[-]</label><label class="expand" for="c-40527329">[3 more]</label></div><br/><div class="children"><div class="content">1. Does anyone know a postgres reranking extension, to go beyond RRF through ML models or at least custom code?<p>2. If anyone is observing significant gains from incorporating knowledge graphs into the retrieval step, what kind of a knowledge graph are you working with, what is your retrieval algorithm, and what technology are you using to store it?</div><br/><div id="40529063" class="c"><input type="checkbox" id="c-40529063" checked=""/><div class="controls bullet"><span class="by">pamelafox</span><span>|</span><a href="#40527329">parent</a><span>|</span><a href="#40528158">next</a><span>|</span><label class="collapse" for="c-40529063">[-]</label><label class="expand" for="c-40529063">[2 more]</label></div><br/><div class="children"><div class="content">Re 1) pgvector has an example in the repo that uses a model for re-ranking:
<a href="https:&#x2F;&#x2F;github.com&#x2F;pgvector&#x2F;pgvector-python&#x2F;blob&#x2F;master&#x2F;examples&#x2F;hybrid_search.py">https:&#x2F;&#x2F;github.com&#x2F;pgvector&#x2F;pgvector-python&#x2F;blob&#x2F;master&#x2F;exam...</a><p>I&#x27;m not using that in my own experiments since I don&#x27;t want to worry about the performance of running a model on production, but seems worth a try.</div><br/><div id="40529226" class="c"><input type="checkbox" id="c-40529226" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40527329">root</a><span>|</span><a href="#40529063">parent</a><span>|</span><a href="#40528158">next</a><span>|</span><label class="collapse" for="c-40529226">[-]</label><label class="expand" for="c-40529226">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s outside the database, though. This is closer to what I had in mind: <a href="https:&#x2F;&#x2F;postgresml.org&#x2F;blog&#x2F;how-to-improve-search-results-with-machine-learning" rel="nofollow">https:&#x2F;&#x2F;postgresml.org&#x2F;blog&#x2F;how-to-improve-search-results-wi...</a></div><br/></div></div></div></div></div></div><div id="40528158" class="c"><input type="checkbox" id="c-40528158" checked=""/><div class="controls bullet"><span class="by">ndricca</span><span>|</span><a href="#40527329">prev</a><span>|</span><a href="#40527135">next</a><span>|</span><label class="collapse" for="c-40528158">[-]</label><label class="expand" for="c-40528158">[1 more]</label></div><br/><div class="children"><div class="content">May I ask you if you tried hybrid search directly on Pinecone, using Bm25 or splade?</div><br/></div></div><div id="40527135" class="c"><input type="checkbox" id="c-40527135" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#40528158">prev</a><span>|</span><a href="#40526093">next</a><span>|</span><label class="collapse" for="c-40527135">[-]</label><label class="expand" for="c-40527135">[7 more]</label></div><br/><div class="children"><div class="content">Any tips on accomplishing this in Postgres with pg_vector?</div><br/><div id="40529056" class="c"><input type="checkbox" id="c-40529056" checked=""/><div class="controls bullet"><span class="by">pamelafox</span><span>|</span><a href="#40527135">parent</a><span>|</span><a href="#40527209">next</a><span>|</span><label class="collapse" for="c-40529056">[-]</label><label class="expand" for="c-40529056">[1 more]</label></div><br/><div class="children"><div class="content">I commented above with a pgvector example that does it-<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40527925">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40527925</a></div><br/></div></div><div id="40527209" class="c"><input type="checkbox" id="c-40527209" checked=""/><div class="controls bullet"><span class="by">flexzuu</span><span>|</span><a href="#40527135">parent</a><span>|</span><a href="#40529056">prev</a><span>|</span><a href="#40527580">next</a><span>|</span><label class="collapse" for="c-40527209">[-]</label><label class="expand" for="c-40527209">[3 more]</label></div><br/><div class="children"><div class="content">Supabase has some good examples on their website, search for hybrid search. I needed to tune the function they have there but it should show you how to approach it.</div><br/><div id="40529123" class="c"><input type="checkbox" id="c-40529123" checked=""/><div class="controls bullet"><span class="by">kiwicopple</span><span>|</span><a href="#40527135">root</a><span>|</span><a href="#40527209">parent</a><span>|</span><a href="#40527332">next</a><span>|</span><label class="collapse" for="c-40529123">[-]</label><label class="expand" for="c-40529123">[1 more]</label></div><br/><div class="children"><div class="content">Here is our doc with RRF:<p><a href="https:&#x2F;&#x2F;supabase.com&#x2F;docs&#x2F;guides&#x2F;ai&#x2F;hybrid-search">https:&#x2F;&#x2F;supabase.com&#x2F;docs&#x2F;guides&#x2F;ai&#x2F;hybrid-search</a></div><br/></div></div><div id="40527332" class="c"><input type="checkbox" id="c-40527332" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#40527135">root</a><span>|</span><a href="#40527209">parent</a><span>|</span><a href="#40529123">prev</a><span>|</span><a href="#40527580">next</a><span>|</span><label class="collapse" for="c-40527332">[-]</label><label class="expand" for="c-40527332">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually doing something like that already, I&#x27;m mostly referring to the Reciprocal Rank Fusion (RRF) part of this to squeeze more out.</div><br/></div></div></div></div><div id="40527580" class="c"><input type="checkbox" id="c-40527580" checked=""/><div class="controls bullet"><span class="by">evv555</span><span>|</span><a href="#40527135">parent</a><span>|</span><a href="#40527209">prev</a><span>|</span><a href="#40526093">next</a><span>|</span><label class="collapse" for="c-40527580">[-]</label><label class="expand" for="c-40527580">[2 more]</label></div><br/><div class="children"><div class="content">Llamaindex rerank module</div><br/><div id="40527955" class="c"><input type="checkbox" id="c-40527955" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#40527135">root</a><span>|</span><a href="#40527580">parent</a><span>|</span><a href="#40526093">next</a><span>|</span><label class="collapse" for="c-40527955">[-]</label><label class="expand" for="c-40527955">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Not using Python, but this is still really useful.</div><br/></div></div></div></div></div></div><div id="40526093" class="c"><input type="checkbox" id="c-40526093" checked=""/><div class="controls bullet"><span class="by">yding</span><span>|</span><a href="#40527135">prev</a><span>|</span><label class="collapse" for="c-40526093">[-]</label><label class="expand" for="c-40526093">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely makes sense!</div><br/></div></div></div></div></div></div></div></body></html>