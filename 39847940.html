<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711789269389" as="style"/><link rel="stylesheet" href="styles.css?v=1711789269389"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.multicians.org/thvv/hellandizing.html">Hellandizing (1998)</a>Â <span class="domain">(<a href="https://www.multicians.org">www.multicians.org</a>)</span></div><div class="subtext"><span>redeemed</span> | <span>7 comments</span></div><br/><div><div id="39867266" class="c"><input type="checkbox" id="c-39867266" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#39868532">next</a><span>|</span><label class="collapse" for="c-39867266">[-]</label><label class="expand" for="c-39867266">[3 more]</label></div><br/><div class="children"><div class="content">I wrote something similar in the past.<p>It was credit card terminal application. It was supposed to behave correctly regardless of when in the process of transaction something happened. Something could be application crash, power cycle, etc. Users were frequently impatient with the slower communication methods (we had land line and GPRS modems back then) and would frequently power cycle the terminal if it took a moment too long to do something.<p>I designed the application in such a way that it always moves transactionally between series of well defined states with no observable states in between. Then I put test points between the states to crash the  application at random. Many of these points were put in places in code which would be extremely difficult to test other way (it was extremely unlikely a power cycle would happen naturally at that exact point in time, between those two exact instructions).<p>The application had capability to crash at literally any point and simply continue operation once power cycled.</div><br/><div id="39868593" class="c"><input type="checkbox" id="c-39868593" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#39867266">parent</a><span>|</span><a href="#39868532">next</a><span>|</span><label class="collapse" for="c-39868593">[-]</label><label class="expand" for="c-39868593">[2 more]</label></div><br/><div class="children"><div class="content">Fascinating. Was it able to do this by constantly writing to persistent storage?</div><br/><div id="39868786" class="c"><input type="checkbox" id="c-39868786" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#39867266">root</a><span>|</span><a href="#39868593">parent</a><span>|</span><a href="#39868532">next</a><span>|</span><label class="collapse" for="c-39868786">[-]</label><label class="expand" for="c-39868786">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I wrote append-only database for the device. I started with the database because I needed a transactional storage but the device used flash chips without wear levelling. This and requirement for constant memory usage basically disqualified any existing database. The device was very limited in memory, only about 1MB available to the application of which 600kB was used up by OpenSSL.<p>The database I implemented did not allocate any memory and used a constant amount of stack which was important for me to ensure the application can be verified statically.<p>So the database worked by having two files allocated. The application would append data to one file, then when it was full it would copy live entries to the other and start appending there and so on.<p>This might sound wasteful but in reality write magnification was very low. There was very little data that needed to be copied, most records were created and then promptly deleted when it was reconciled with the server.<p>All sorts of data was written to the storage. I started by writing just basic transaction information but then I discovered that I can also log other information (UI state, etc.) to recover state in case of power failure. This was extremely efficient, most UI operations would result in only a single byte written to the flash. This was important as the flash had quite limited durability and was typically a limiting factor for the longevity of the device.<p>**<p>Now that I remember, there were other fun tricks I did.<p>One of them was for the OpenSSL. This super underpowered device took no less than 9 seconds to open SSL connection over GPRS.<p>That was fine when the device was first designed and we deployed lots of them. Initially, we did not need SSL and we did not need to open any connections to complete the transaction. We only did that later, once a day, to send all of the information and reconcile with the server.<p>But at some point we had to deploy ability to do online check with the bank and also required to have all connections secured with SSL. 9 seconds for the client to wait on the transaction was definitely not acceptable.<p>While we could try to keep the connection open, in many cases the device would be deployed in places with poor connectivity and it was just unreasonable expectation.<p>I saved the company A TON of cash by figuring out I can gut the OpenSSL library to be able to manually save and restore cryptographic state of the connection (symmetric cryptography). I did the same for the system that terminated connections on the server.<p>The application would connect to the server, skip entire handshake communication (not even a single handshake packet) and would immediately, speculatively switch to the stored symmetric key.<p>The server kept a database of all most recent cryptographic states with each of the known terminals and would try to match the communication with its own stored cryptographic state. If this worked, it would continue as if nothing happened. If it did not, it would close the connection. The terminal would then restart the connection with the complete handshake from scratch. But it very rarely had to. As it was very successful, we had to add a functionality to force to clear the state every night so that it we knew there is at least one fresh connection every day.<p>This cut down almost all of the overhead of OpenSSL.</div><br/></div></div></div></div></div></div><div id="39868532" class="c"><input type="checkbox" id="c-39868532" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#39867266">prev</a><span>|</span><a href="#39869173">next</a><span>|</span><label class="collapse" for="c-39868532">[-]</label><label class="expand" for="c-39868532">[1 more]</label></div><br/><div class="children"><div class="content">Did something like and unlike this a while ago. Payment processing system, multiple microservices written in Java on a cloud platform. Tool runs on a developer machine, uses the cloud tools to SSH into a running container and run jdb. It can add a breakpoint, wait for it to get hit, then do a selected thing - resume immediately, delay a while then resume, throw an exception, hang forever, etc.<p>The main tool can also manage the platform, so start the app, kill individual containers, etc. And inject payment messages, and wait for payments to be sent out.<p>So you could write test plans like &quot;add a breakpoint in ValidateAccount::isValidSortCode, inject a payment from customer A, wait for the breakpoint to get hit, inject a payment from customer B, throw a NullPointerException, then check that the payment from customer B gets delivered&quot;.<p>We didn&#x27;t do systematic testing of failure at every point, as in the article, but it was very nice to be able to automate testing of error cases without having to have special code in the app for it.</div><br/></div></div><div id="39869173" class="c"><input type="checkbox" id="c-39869173" checked=""/><div class="controls bullet"><span class="by">jdblair</span><span>|</span><a href="#39868532">prev</a><span>|</span><a href="#39867040">next</a><span>|</span><label class="collapse" for="c-39869173">[-]</label><label class="expand" for="c-39869173">[1 more]</label></div><br/><div class="children"><div class="content">A question about how nonstop worked:<p>If both processors are running the same process in the same state, why won&#x27;t both processors hit the same error condition at the same time?<p>I understand there are random hardware faults that can happen, bits can flip, etc., but logic errors should be bug-for-bug the same on both processors.<p>So, were those random faults so frequent that the redundancy was worth it? Or am I missing something?</div><br/></div></div><div id="39867040" class="c"><input type="checkbox" id="c-39867040" checked=""/><div class="controls bullet"><span class="by">tiahura</span><span>|</span><a href="#39869173">prev</a><span>|</span><label class="collapse" for="c-39867040">[-]</label><label class="expand" for="c-39867040">[1 more]</label></div><br/><div class="children"><div class="content">TIL NonStop lives.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NonStop_(server_computers)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NonStop_(server_computers)</a><p><a href="https:&#x2F;&#x2F;www.hpe.com&#x2F;us&#x2F;en&#x2F;compute&#x2F;nonstop-servers.html" rel="nofollow">https:&#x2F;&#x2F;www.hpe.com&#x2F;us&#x2F;en&#x2F;compute&#x2F;nonstop-servers.html</a></div><br/></div></div></div></div></div></div></div></body></html>