<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722762051907" as="style"/><link rel="stylesheet" href="styles.css?v=1722762051907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://relistan.com/parsing-protobuf-files-with-treesitter">Parsing Protobuf Definitions with Tree-sitter</a> <span class="domain">(<a href="https://relistan.com">relistan.com</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>19 comments</span></div><br/><div><div id="41149576" class="c"><input type="checkbox" id="c-41149576" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41149745">next</a><span>|</span><label class="collapse" for="c-41149576">[-]</label><label class="expand" for="c-41149576">[6 more]</label></div><br/><div class="children"><div class="content">I need to get around to playing with tree-sitter. The approach in this article is neat.<p>Here&#x27;s another approach. The AST of a .proto file is itself a protobuf. That&#x27;s how the codegen plugins work. Protobuf also has a canonical mapping to JSON, so...<p>What you can do is use protoc to parse the .proto file, spit it out as JSON, and then process that data using your favorite pattern matching language. I wrote a [tool][1] that helps with that. For example, here&#x27;s some [js code][2] that translates protobuf message definitions into &quot;types&quot; for use in an ORM.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dgoffredo&#x2F;protojson">https:&#x2F;&#x2F;github.com&#x2F;dgoffredo&#x2F;protojson</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dgoffredo&#x2F;okra&#x2F;blob&#x2F;master&#x2F;lib&#x2F;proto2types.js">https:&#x2F;&#x2F;github.com&#x2F;dgoffredo&#x2F;okra&#x2F;blob&#x2F;master&#x2F;lib&#x2F;proto2type...</a></div><br/><div id="41149759" class="c"><input type="checkbox" id="c-41149759" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#41149576">parent</a><span>|</span><a href="#41149616">next</a><span>|</span><label class="collapse" for="c-41149759">[-]</label><label class="expand" for="c-41149759">[1 more]</label></div><br/><div class="children"><div class="content">Writing a protoc plugin would have been 5x easier, but its harder to get a blog article out of it.<p>Also, this reads like they might not have seen the newer proto3 optional keyword, or know about the well-known wrapper types.</div><br/></div></div><div id="41149616" class="c"><input type="checkbox" id="c-41149616" checked=""/><div class="controls bullet"><span class="by">superb_dev</span><span>|</span><a href="#41149576">parent</a><span>|</span><a href="#41149759">prev</a><span>|</span><a href="#41150244">next</a><span>|</span><label class="collapse" for="c-41149616">[-]</label><label class="expand" for="c-41149616">[1 more]</label></div><br/><div class="children"><div class="content">Oh my god… this might’ve made some tools I’m developing a lot easier</div><br/></div></div><div id="41150244" class="c"><input type="checkbox" id="c-41150244" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#41149576">parent</a><span>|</span><a href="#41149616">prev</a><span>|</span><a href="#41151306">next</a><span>|</span><label class="collapse" for="c-41150244">[-]</label><label class="expand" for="c-41150244">[1 more]</label></div><br/><div class="children"><div class="content">I highly recommend it. The docs describe it as a zen-like experience, and I fully agree. Once you get the hang of it, it makes it so easy to tweak the syntax of whatever language you’re building. I love it.</div><br/></div></div><div id="41151306" class="c"><input type="checkbox" id="c-41151306" checked=""/><div class="controls bullet"><span class="by">lelandbatey</span><span>|</span><a href="#41149576">parent</a><span>|</span><a href="#41150244">prev</a><span>|</span><a href="#41149745">next</a><span>|</span><label class="collapse" for="c-41151306">[-]</label><label class="expand" for="c-41151306">[2 more]</label></div><br/><div class="children"><div class="content">I found that some parts of a protobuf aren&#x27;t captured well by protoc; specifically annotations were not well exposed to Go libraries for writing protoc plugins in 2016. I ended up having to write my own basic protobuf parser to reliably extract annotations and comments for code and documentation generation:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;metaverse&#x2F;truss&#x2F;blame&#x2F;master&#x2F;svcdef&#x2F;svcdef.go">https:&#x2F;&#x2F;github.com&#x2F;metaverse&#x2F;truss&#x2F;blame&#x2F;master&#x2F;svcdef&#x2F;svcde...</a></div><br/><div id="41151406" class="c"><input type="checkbox" id="c-41151406" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41149576">root</a><span>|</span><a href="#41151306">parent</a><span>|</span><a href="#41149745">next</a><span>|</span><label class="collapse" for="c-41151406">[-]</label><label class="expand" for="c-41151406">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I ended up having to write my own basic protobuf parser (...)<p>Wouldn&#x27;t it have been far more efficient to contribute back to protoc? Certainly posting a patch to a parser takes far fewer work than writing an alternative implementation of the same parser.</div><br/></div></div></div></div></div></div><div id="41149745" class="c"><input type="checkbox" id="c-41149745" checked=""/><div class="controls bullet"><span class="by">grumbles</span><span>|</span><a href="#41149576">prev</a><span>|</span><a href="#41149764">next</a><span>|</span><label class="collapse" for="c-41149745">[-]</label><label class="expand" for="c-41149745">[3 more]</label></div><br/><div class="children"><div class="content">Huh. tree-sitter seems neat, but I don’t really get why the author thinks processing the descriptor set is so hard. Seems equally difficult to learn a bunch of new abstractions in the form of tree-sitter vs just learning protobuf’s own ones.<p>Also, if you’re parsing .proto files directly, you have to deal with a bunch of annoying issues like include paths, how you package sets of them to move around, etc. descriptor sets seem like a better solution to me.</div><br/><div id="41151004" class="c"><input type="checkbox" id="c-41151004" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#41149745">parent</a><span>|</span><a href="#41150290">next</a><span>|</span><label class="collapse" for="c-41151004">[-]</label><label class="expand" for="c-41151004">[1 more]</label></div><br/><div class="children"><div class="content">Came to the comments to say this. FileDescriptors have been so simple to work with that I am so surprised the author is touting TS for this use case.<p>The other nice thing about all the descriptors is their schemas are protobufs, so language agnostic and easily serialized&#x2F;deserialized.</div><br/></div></div><div id="41150290" class="c"><input type="checkbox" id="c-41150290" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41149745">parent</a><span>|</span><a href="#41151004">prev</a><span>|</span><a href="#41149764">next</a><span>|</span><label class="collapse" for="c-41150290">[-]</label><label class="expand" for="c-41150290">[1 more]</label></div><br/><div class="children"><div class="content">OTOH, if you can get treesitter to work, all the best editors will gain Protobuf support.</div><br/></div></div></div></div><div id="41149764" class="c"><input type="checkbox" id="c-41149764" checked=""/><div class="controls bullet"><span class="by">pcj-github</span><span>|</span><a href="#41149745">prev</a><span>|</span><a href="#41149195">next</a><span>|</span><label class="collapse" for="c-41149764">[-]</label><label class="expand" for="c-41149764">[1 more]</label></div><br/><div class="children"><div class="content">From the docs &quot;The protocol compiler can output a FileDescriptorSet containing the .proto files it parses.&quot; (<a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;src&#x2F;google&#x2F;protobuf&#x2F;descriptor.proto">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;src&#x2F;go...</a>)<p>I don&#x27;t understand the point of using tree-sitter to repeat that work (almost certainly having bugs doing so).  Am I missing something?</div><br/></div></div><div id="41149195" class="c"><input type="checkbox" id="c-41149195" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41149764">prev</a><span>|</span><a href="#41149824">next</a><span>|</span><label class="collapse" for="c-41149195">[-]</label><label class="expand" for="c-41149195">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it. Why not just use a better Protobuf model? Go&#x27;s serialization format for protobufs is not the most brilliant one, but it&#x27;s reasonable.<p>E.g. just use `string` instead of `StringValue`.</div><br/><div id="41150063" class="c"><input type="checkbox" id="c-41150063" checked=""/><div class="controls bullet"><span class="by">ahtihn</span><span>|</span><a href="#41149195">parent</a><span>|</span><a href="#41149824">next</a><span>|</span><label class="collapse" for="c-41150063">[-]</label><label class="expand" for="c-41150063">[6 more]</label></div><br/><div class="children"><div class="content">StringValue let&#x27;s you differentiate empty string vs no value.</div><br/><div id="41150119" class="c"><input type="checkbox" id="c-41150119" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41149195">root</a><span>|</span><a href="#41150063">parent</a><span>|</span><a href="#41149824">next</a><span>|</span><label class="collapse" for="c-41150119">[-]</label><label class="expand" for="c-41150119">[5 more]</label></div><br/><div class="children"><div class="content">But do you actually need that? Like, really?<p>If you absolutely do need it, then in addition to &quot;name&quot; you can also add a field &quot;hasName&quot;. If you feel fancy, you can even do that in a code generator.</div><br/><div id="41151886" class="c"><input type="checkbox" id="c-41151886" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#41149195">root</a><span>|</span><a href="#41150119">parent</a><span>|</span><a href="#41150200">next</a><span>|</span><label class="collapse" for="c-41151886">[-]</label><label class="expand" for="c-41151886">[1 more]</label></div><br/><div class="children"><div class="content">That’s an extra field, with no consistency validation, and does not play well with JSON. A field can be either &quot;&quot; or null, and that’s two different cases.<p>Also the wrappers are known to most protobuf code generators, that can then use language features for better ergonomics. E.g. in Rust all wrappers to allow nullability of values will be turned in Option. Like the StringValue will turn into Option&lt;String&gt;.<p>As for the need, yes, it is needed. This carries intent, which is a good thing in customer facing APIs. An update endpoint will have all fields optional to distinguish between a field needing to be overridden or not, without the need to re-send the value when it does not need to be changed (à la PUT). Having additional boolean fields gets unwieldy quickly.</div><br/></div></div><div id="41150200" class="c"><input type="checkbox" id="c-41150200" checked=""/><div class="controls bullet"><span class="by">parthdesai</span><span>|</span><a href="#41149195">root</a><span>|</span><a href="#41150119">parent</a><span>|</span><a href="#41151886">prev</a><span>|</span><a href="#41149824">next</a><span>|</span><label class="collapse" for="c-41150200">[-]</label><label class="expand" for="c-41150200">[3 more]</label></div><br/><div class="children"><div class="content">You need it when an empty string is a valid value in your domain.<p>A better example is Int32Value. By default, protobuf will serialize int32 to 0 if it&#x27;s not present.</div><br/><div id="41150388" class="c"><input type="checkbox" id="c-41150388" checked=""/><div class="controls bullet"><span class="by">anytime5704</span><span>|</span><a href="#41149195">root</a><span>|</span><a href="#41150200">parent</a><span>|</span><a href="#41149824">next</a><span>|</span><label class="collapse" for="c-41150388">[-]</label><label class="expand" for="c-41150388">[2 more]</label></div><br/><div class="children"><div class="content">I think the other commenter’s point is you can use 2 fields to distinguish between the first field being specified as empty vs absent (or whatever terms you prefer).<p>E.g.<p>- type.specified =&gt; “”<p>- type.unspecified =&gt; empty<p>The same technique can be used to disambiguate between 0 and empty.</div><br/><div id="41151461" class="c"><input type="checkbox" id="c-41151461" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#41149195">root</a><span>|</span><a href="#41150388">parent</a><span>|</span><a href="#41149824">next</a><span>|</span><label class="collapse" for="c-41151461">[-]</label><label class="expand" for="c-41151461">[1 more]</label></div><br/><div class="children"><div class="content">Worth noting that it’s not quite equivalent due to allowing for a malformed message that includes foo = value and hasFoo = false, opening the door to varied client interpretation.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41149824" class="c"><input type="checkbox" id="c-41149824" checked=""/><div class="controls bullet"><span class="by">Arainach</span><span>|</span><a href="#41149195">prev</a><span>|</span><label class="collapse" for="c-41149824">[-]</label><label class="expand" for="c-41149824">[1 more]</label></div><br/><div class="children"><div class="content">Like others, I don&#x27;t understand the author&#x27;s issues getting the stock proto reflection behavior to extract this information.<p>I&#x27;m not as familiar with the Go reflection tools, but getting the information the author wants is trivial in Java reflection.</div><br/></div></div></div></div></div></div></div></body></html>