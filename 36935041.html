<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690794075142" as="style"/><link rel="stylesheet" href="styles.css?v=1690794075142"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.bitecode.dev/p/whats-up-python-the-gil-removed-a">What&#x27;s up, Python? The GIL removed, a new compiler, optparse deprecated</a> <span class="domain">(<a href="https://www.bitecode.dev">www.bitecode.dev</a>)</span></div><div class="subtext"><span>BiteCode_dev</span> | <span>207 comments</span></div><br/><div><div id="36939872" class="c"><input type="checkbox" id="c-36939872" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36936017">next</a><span>|</span><label class="collapse" for="c-36939872">[-]</label><label class="expand" for="c-36939872">[1 more]</label></div><br/><div class="children"><div class="content">Recent and related:<p><i>Intent to approve PEP 703: making the GIL optional</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36913328">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36913328</a> - July 2023 (488 comments)</div><br/></div></div><div id="36936017" class="c"><input type="checkbox" id="c-36936017" checked=""/><div class="controls bullet"><span class="by">wmwmwm</span><span>|</span><a href="#36939872">prev</a><span>|</span><a href="#36938594">next</a><span>|</span><label class="collapse" for="c-36936017">[-]</label><label class="expand" for="c-36936017">[107 more]</label></div><br/><div class="children"><div class="content">Historically I’ve written several services that load up some big datastructure (10s or 100s of GB), then expose an HTTP API on top of it. Every time I’ve done a quick implementation in Python of a service that then became popular (within a firm, so 100s or 1000s of clients) I’ve often ended up having to rewrite in Java so I can throw more threads at servicing the requests (often CPU heavy). I may have missed something but I couldn’t figure out how to get the multi-threaded performance out of Python but of course no-GIL looks interesting for this!</div><br/><div id="36939356" class="c"><input type="checkbox" id="c-36939356" checked=""/><div class="controls bullet"><span class="by">iknownothow</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936693">next</a><span>|</span><label class="collapse" for="c-36939356">[-]</label><label class="expand" for="c-36939356">[1 more]</label></div><br/><div class="children"><div class="content">I would consider the following optimizations first before attempting to rewrite an HTTP API since you already did the hard part:<p>1. For multiples processes use `gunicorn` [1]. Runs your app across multiple processes without you having to touch your code much. It&#x27;s the same as having the n instances of the same backend app where n being the number of CPU cores you&#x27;re willing to throw at it. One backend process per core, full isolation.<p>2. For multiple threads use `gunicorn` + `gevent` workers [2]. Provides multiprocessing + multithreaded functionality out of the box if you have IO intensive. It&#x27;s not perfect but works very well in some situations.<p>3. Lastly, if CPU is where you have a bottleneck, that means you have some memory to spare (even if it&#x27;s not much). Throw some LRU cache or cachetools [3] over functions that return the same result or functions that do expensive I&#x2F;O.<p>[1]: <a href="https:&#x2F;&#x2F;www.joelsleppy.com&#x2F;blog&#x2F;gunicorn-sync-workers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.joelsleppy.com&#x2F;blog&#x2F;gunicorn-sync-workers&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;www.joelsleppy.com&#x2F;blog&#x2F;gunicorn-async-workers-with-gevent&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.joelsleppy.com&#x2F;blog&#x2F;gunicorn-async-workers-with-...</a><p>[3]: <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;cachetools&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;cachetools&#x2F;</a></div><br/></div></div><div id="36936693" class="c"><input type="checkbox" id="c-36936693" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36939356">prev</a><span>|</span><a href="#36936272">next</a><span>|</span><label class="collapse" for="c-36936693">[-]</label><label class="expand" for="c-36936693">[45 more]</label></div><br/><div class="children"><div class="content">&gt; I may have missed something but I couldn’t figure out how to get the multi-threaded performance out of Python<p>Multiprocessing. The answer is to use the python multiprocessing module, or to spin up multiple processes behind wsgi or whatever.<p>&gt; Historically I’ve written several services that load up some big datastructure (10s or 100s of GB), then expose an HTTP API on top of it.<p>Use the python multiprocessing module. If you&#x27;ve already written it with the multithreading module, it is a drop in replacement. Your data structure will live in shared memory and can be accessed by all processes concurrently without incurring the wrath of the GIL.<p>Obviously this does not fix the issue of Python just being super slow in general. It just lets you max out all your CPU cores instead of having just one core at 100% all the time.</div><br/><div id="36939963" class="c"><input type="checkbox" id="c-36939963" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937221">next</a><span>|</span><label class="collapse" for="c-36939963">[-]</label><label class="expand" for="c-36939963">[1 more]</label></div><br/><div class="children"><div class="content">I want to warn people against multiprocessing in python though.<p>If you&#x27;re thinking about parallelizing your Python process, chances are your Python code is CPU-bound. That&#x27;s when you should stop and think, is Python really the right tool for this job?<p>From experience, translating a Python program into C++ or Rust often gives a speed-up of around 100x, without introducing threads. Go probably has a similar level of speed-up. So while you can throw a lot of time fighting Python to get it to consume 16x the compute resources for a 10x speed-up, you could often instead spend a similar amount of time rewriting the program for a 100x speed-up with the same compute resources. And <i>then</i> you could parallelize your Go&#x2F;Rust&#x2F;C++ program for another 10x, if necessary.<p>Of course, this is highly dependent on what you&#x27;re actually doing. Maybe your Python code isn&#x27;t the bottleneck, maybe your code spends 99% of its time in datastructure operations implemented in C and you need to parallelize it. Or maybe your use-case is one where you could use pypy and get the required speed-up. I just recognize from my own experience the temptation of parallelizing some Python code because it&#x27;s slow, only to find that the parallelized version isn&#x27;t <i>that</i> much faster (my computer is just hotter and louder), and then giving in and rewriting the code in C++.</div><br/></div></div><div id="36937221" class="c"><input type="checkbox" id="c-36937221" checked=""/><div class="controls bullet"><span class="by">RayVR</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36939963">prev</a><span>|</span><a href="#36940118">next</a><span>|</span><label class="collapse" for="c-36937221">[-]</label><label class="expand" for="c-36937221">[12 more]</label></div><br/><div class="children"><div class="content">Multiprocessing is not a real solution, it’s a break-glass procedure when you just need to throw some cores at something without any hope for reliability. Unless something has changed since I used python, it is essentially a wrapper on Fork.<p>This means you need to deal with stuck&#x2F;dead processes. I’ve used multiprocessing extensively and once you hit a certain amount of usage, even in a pool, you just get hangs and unresponsive processes.<p>I’ve also written a huge amount of Cython wrapped c++ code which releases the GIL. This never hangs and I can multithread there all I want without issue.</div><br/><div id="36937776" class="c"><input type="checkbox" id="c-36937776" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937221">parent</a><span>|</span><a href="#36937371">next</a><span>|</span><label class="collapse" for="c-36937776">[-]</label><label class="expand" for="c-36937776">[7 more]</label></div><br/><div class="children"><div class="content">Why would they get stuck&#x2F;dead and why wouldn&#x27;t that happen with threads which might be even worse as they&#x27;re more tightly bound?  At least with zombies or inactive processes you can detect and kill them externally - if needs be.<p>Haven&#x27;t played with multiprocess at scale, so am genuinely interested.</div><br/><div id="36938004" class="c"><input type="checkbox" id="c-36938004" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937776">parent</a><span>|</span><a href="#36937371">next</a><span>|</span><label class="collapse" for="c-36938004">[-]</label><label class="expand" for="c-36938004">[6 more]</label></div><br/><div class="children"><div class="content">If subprocesses die (segfault maybe) it isn&#x27;t uncommon for them to not be cleaned up and&#x2F;or cause the parent process to hang while it waits for the zombie to respond. That&#x27;s one I experienced last week on Python 3.9. A thread that experienced that would likely kill the parent process or maybe even exit with a stacktrace. Way easier to debug, and doesn&#x27;t require me to search through running tasks and manually kill them after each debug cycle.<p>My impression is that the multiprocessing module is a heroic effort, but unfortunately making the whole system work transparently across multiple OSs and architectures is a nearly insurmountable problem.</div><br/><div id="36938125" class="c"><input type="checkbox" id="c-36938125" checked=""/><div class="controls bullet"><span class="by">empthought</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938004">parent</a><span>|</span><a href="#36938766">next</a><span>|</span><label class="collapse" for="c-36938125">[-]</label><label class="expand" for="c-36938125">[4 more]</label></div><br/><div class="children"><div class="content">You may be interested in the concurrent.futures library, available for over a decade now. It keeps you from shooting yourself in the foot like that.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;concurrent.futures.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;concurrent.futures.html</a></div><br/><div id="36938571" class="c"><input type="checkbox" id="c-36938571" checked=""/><div class="controls bullet"><span class="by">KolenCh</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938125">parent</a><span>|</span><a href="#36938766">next</a><span>|</span><label class="collapse" for="c-36938571">[-]</label><label class="expand" for="c-36938571">[3 more]</label></div><br/><div class="children"><div class="content">Why do you think it would help?<p>It provides a nice interface but is using multiprocessing or multi threading under the hood depending on which executioner you use:<p>&gt; The ProcessPoolExecutor class is an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed and returned.</div><br/><div id="36938830" class="c"><input type="checkbox" id="c-36938830" checked=""/><div class="controls bullet"><span class="by">empthought</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938571">parent</a><span>|</span><a href="#36938766">next</a><span>|</span><label class="collapse" for="c-36938830">[-]</label><label class="expand" for="c-36938830">[2 more]</label></div><br/><div class="children"><div class="content">Your trouble seems to involve not understanding how to set up signal handlers, which ProcessPoolExecutor handles for you and exposes via a BrokenProcessPool exception.</div><br/><div id="36939571" class="c"><input type="checkbox" id="c-36939571" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938830">parent</a><span>|</span><a href="#36938766">next</a><span>|</span><label class="collapse" for="c-36939571">[-]</label><label class="expand" for="c-36939571">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Derived from BrokenExecutor (formerly RuntimeError), this exception class is raised when one of the workers of a ProcessPoolExecutor has terminated in a non-clean fashion (for example, if it was killed from the outside).<p>What if it hangs?</div><br/></div></div></div></div></div></div></div></div><div id="36938766" class="c"><input type="checkbox" id="c-36938766" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938004">parent</a><span>|</span><a href="#36938125">prev</a><span>|</span><a href="#36937371">next</a><span>|</span><label class="collapse" for="c-36938766">[-]</label><label class="expand" for="c-36938766">[1 more]</label></div><br/><div class="children"><div class="content">Always setting a timeout on every IPC or network  operation helps immensely. IIRC multiprocessing module allows that everywhere, but defaults to waiting forever in a couple of places.</div><br/></div></div></div></div></div></div><div id="36937371" class="c"><input type="checkbox" id="c-36937371" checked=""/><div class="controls bullet"><span class="by">jjoonathan</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937221">parent</a><span>|</span><a href="#36937776">prev</a><span>|</span><a href="#36937440">next</a><span>|</span><label class="collapse" for="c-36937371">[-]</label><label class="expand" for="c-36937371">[1 more]</label></div><br/><div class="children"><div class="content">Yep, multiprocessing is a cope.<p>If processes were a universal substitute for threads we wouldn&#x27;t have threads. That reasoning only gets stronger when you apply python&#x27;s heavy limitations, but it gets the most strength when you experience the awkwardness of multiprocessing firsthand.</div><br/></div></div><div id="36937440" class="c"><input type="checkbox" id="c-36937440" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937221">parent</a><span>|</span><a href="#36937371">prev</a><span>|</span><a href="#36937364">next</a><span>|</span><label class="collapse" for="c-36937440">[-]</label><label class="expand" for="c-36937440">[1 more]</label></div><br/><div class="children"><div class="content">multiprocessing is very good solution for scatter-and-gather (or map&#x2F;reduce) type workloads:
for example ssh to 1000 machines, run some commands, grab output, analyze output, done some action based on output, etc<p>if you are managing a fleet of machines and have some tasks to do on each machine, then multiprocessing is the life saver.</div><br/></div></div><div id="36937364" class="c"><input type="checkbox" id="c-36937364" checked=""/><div class="controls bullet"><span class="by">toasted-subs</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937221">parent</a><span>|</span><a href="#36937440">prev</a><span>|</span><a href="#36940118">next</a><span>|</span><label class="collapse" for="c-36937364">[-]</label><label class="expand" for="c-36937364">[2 more]</label></div><br/><div class="children"><div class="content">I’m not a huge fan of Cython and the like. It seems to be more natural to open a tcp connection to a c&#x2F;c++ program and let that do the heavy lifting. Anything else seems like not a proper UNIX style solution.</div><br/><div id="36938579" class="c"><input type="checkbox" id="c-36938579" checked=""/><div class="controls bullet"><span class="by">KolenCh</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937364">parent</a><span>|</span><a href="#36940118">next</a><span>|</span><label class="collapse" for="c-36938579">[-]</label><label class="expand" for="c-36938579">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not natural at all. Eg pybind11 is more natural.</div><br/></div></div></div></div></div></div><div id="36940118" class="c"><input type="checkbox" id="c-36940118" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937221">prev</a><span>|</span><a href="#36937630">next</a><span>|</span><label class="collapse" for="c-36940118">[-]</label><label class="expand" for="c-36940118">[1 more]</label></div><br/><div class="children"><div class="content">Loading 100GB into RAM and then calling fork() is just painting a giant OOM Killer target on your back. It&#x27;ll work until something breaks the CoWs or the parent gets restarted while some forks still linger or other fun things like that.<p>Threads make it transparent to the OS that this memory really must be shared between compute tasks.</div><br/></div></div><div id="36937630" class="c"><input type="checkbox" id="c-36937630" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36940118">prev</a><span>|</span><a href="#36937474">next</a><span>|</span><label class="collapse" for="c-36937630">[-]</label><label class="expand" for="c-36937630">[7 more]</label></div><br/><div class="children"><div class="content">Nowadays multiprocessing is rarely the answer. Between all the gotchas (memory usage can be horrific, have to be careful what you modify, etc.) it&#x27;s almost never the right answer.<p>Nowadays numba is usually a better solution for when you want to run some computationally expensive python code that itself calls numpy, etc.<p>For the parent commenter&#x27;s use case though that wouldn&#x27;t be a great solution either. In general, Python does not have an optimal way of operating on a shared  data structure across OS threads and certainly not in a way that doesn&#x27;t require forking the interpreter.</div><br/><div id="36938102" class="c"><input type="checkbox" id="c-36938102" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937630">parent</a><span>|</span><a href="#36937474">next</a><span>|</span><label class="collapse" for="c-36938102">[-]</label><label class="expand" for="c-36938102">[6 more]</label></div><br/><div class="children"><div class="content">You have to be <i>much</i> more careful about what you modify when using multithreading, so I&#x27;m not sure what you mean by that.<p>A lot of people here mention that sharing data is much easier with multithreading, but doing this without races is not easy.<p>You can&#x27;t just use the values from difference threads like you would in normal code, you need to synchronize access with locks, which can be difficult to do correctly and can harm performance in a lot of cases.<p>I think a lot of the people who complain about the GIL are going to become acutely aware of why it was useful when they attempt to use GIL-less multithreading, and realize that removing it wasn&#x27;t as great as it sounded at first!<p>In my experience, most problems are inherently synchronous with lots of mutable state and complex data dependencies, or inherently parallel with lots of tasks that can run independently. Problems that can be easily parallelized already work fine with multiprocessing! Problems that can&#x27;t be easily parallelized are not something you can just slap some threading on to get more performance, and will require a lot of work to keep state synced!<p>This is just my opinion though and I&#x27;m sure there are plenty of domains that I don&#x27;t have experience with that will benefit from no-GIL python!</div><br/><div id="36939932" class="c"><input type="checkbox" id="c-36939932" checked=""/><div class="controls bullet"><span class="by">mvncleaninst</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938102">parent</a><span>|</span><a href="#36938182">next</a><span>|</span><label class="collapse" for="c-36939932">[-]</label><label class="expand" for="c-36939932">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Problems that can be easily parallelized already work fine with multiprocessing!<p>Yeah, except afaik you pay more in context switches, sharing is more cumbersome. Also language runtime of a single process is likely working with less information, you end up using more memory on multiple language runtime instances<p>Frankly I&#x27;d just use Java or Go at that point and not even bother</div><br/></div></div><div id="36938182" class="c"><input type="checkbox" id="c-36938182" checked=""/><div class="controls bullet"><span class="by">thrashh</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938102">parent</a><span>|</span><a href="#36939932">prev</a><span>|</span><a href="#36939428">next</a><span>|</span><label class="collapse" for="c-36938182">[-]</label><label class="expand" for="c-36938182">[1 more]</label></div><br/><div class="children"><div class="content">Multithreading is hard but once you have been doing it a while, it becomes easy and most importantly, it’s stable.<p>When you have to deal with processes, there’s a lot of external factors out of your control because processes are much more visible and carry a lot of extra baggage.<p>Hard multithreading problems are fun. Hard multi-process problems are just tedious.</div><br/></div></div><div id="36939428" class="c"><input type="checkbox" id="c-36939428" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938102">parent</a><span>|</span><a href="#36938182">prev</a><span>|</span><a href="#36937474">next</a><span>|</span><label class="collapse" for="c-36939428">[-]</label><label class="expand" for="c-36939428">[3 more]</label></div><br/><div class="children"><div class="content">&gt;I think a lot of the people who complain about the GIL are going to become acutely aware of why it was useful when they attempt to use GIL-less multithreading, and realize that removing it wasn&#x27;t as great as it sounded at first!<p>There is no such thing as &quot;GIL-less multithreading. The GIL does not do what you think it does. It does not synchronize your multithreaded code at all. It only synchronizes code that was single threaded to begin with.<p>Also... Your argument about locking being harmful to performance while arguing in favour of a global lock  makes you look like a novice who has less than a month of software development experience.</div><br/><div id="36939864" class="c"><input type="checkbox" id="c-36939864" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36939428">parent</a><span>|</span><a href="#36939723">next</a><span>|</span><label class="collapse" for="c-36939864">[-]</label><label class="expand" for="c-36939864">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean to pile on to what ghshephard already posted, but I&#x27;m afraid you&#x27;ve been breaking the site guidelines repeatedly lately - not just here but these:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36923922">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36923922</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36921060">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36921060</a><p>... as well as others. Can you please not do this? We&#x27;re trying for something different here. If you wouldn&#x27;t mind reviewing <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a> and taking the intended spirit of the site more to heart, we&#x27;d be grateful.</div><br/></div></div><div id="36939723" class="c"><input type="checkbox" id="c-36939723" checked=""/><div class="controls bullet"><span class="by">ghshephard</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36939428">parent</a><span>|</span><a href="#36939864">prev</a><span>|</span><a href="#36937474">next</a><span>|</span><label class="collapse" for="c-36939723">[-]</label><label class="expand" for="c-36939723">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a><p>&gt; Be kind. Don&#x27;t be snarky. Converse curiously; don&#x27;t cross-examine. Edit out swipes.<p>&gt; When disagreeing, please reply to the argument instead of calling names. &quot;That is idiotic; 1 + 1 is 2, not 3&quot; can be shortened to &quot;1 + 1 is 2, not 3.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="36937474" class="c"><input type="checkbox" id="c-36937474" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937630">prev</a><span>|</span><a href="#36936989">next</a><span>|</span><label class="collapse" for="c-36937474">[-]</label><label class="expand" for="c-36937474">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Use the python multiprocessing module. If you&#x27;ve already written it with the multithreading module, it is a drop in replacement. Your data structure will live in shared memory</i><p>Only if it can be immutable. So it can&#x27;t be shared and changed by multiple processes as needed (with synchronization).<p>And even if you can have it mostly immutable, if you need to refresh it (e.g. after some time read a newer large file from disk to load into your data structure), you can&#x27;t without restarting the whole server and processes.<p>So, it could work for this case, but it&#x27;s hardly a general solution for the problem.</div><br/><div id="36939340" class="c"><input type="checkbox" id="c-36939340" checked=""/><div class="controls bullet"><span class="by">felipetrz</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937474">parent</a><span>|</span><a href="#36936989">next</a><span>|</span><label class="collapse" for="c-36939340">[-]</label><label class="expand" for="c-36939340">[2 more]</label></div><br/><div class="children"><div class="content">For this use case it would be better to put the data in a shared SQLite database than relying on multiprocessing CoW.<p>Even accessing objects from the shared memory would cause the reference counter to increment and the data would be copied, causing a memory usage explosion.</div><br/><div id="36940061" class="c"><input type="checkbox" id="c-36940061" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36939340">parent</a><span>|</span><a href="#36936989">next</a><span>|</span><label class="collapse" for="c-36940061">[-]</label><label class="expand" for="c-36940061">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>For this use case it would be better to put the data in a shared SQLite database than relying on multiprocessing CoW</i><p>In Python yes. In Java you could take advantage of shared memory and get spared the overhead of SQLite.</div><br/></div></div></div></div></div></div><div id="36936989" class="c"><input type="checkbox" id="c-36936989" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937474">prev</a><span>|</span><a href="#36938786">next</a><span>|</span><label class="collapse" for="c-36936989">[-]</label><label class="expand" for="c-36936989">[6 more]</label></div><br/><div class="children"><div class="content">Over quite some time I&#x27;ve become convinced multiprocessing module is better than an optional GIL removal.<p>It may leave many useful bits on the table (compared to pure multithreaded coding, like C++&#x2F;pthreads) but I&#x27;ve still been able to get it to scale my application performance (CPU-bound, large-memory) to the number of cores of even large boxes (96+ vCPUs).  IIRC the future&#x2F;concurrent library was key to being productive.<p>20 years ago I would said different, as at the time, IronPython demonstrated a real alternative to CPython that was faster, and fully multitrhreaded (including the container classes).</div><br/><div id="36939942" class="c"><input type="checkbox" id="c-36939942" checked=""/><div class="controls bullet"><span class="by">apelapan</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936989">parent</a><span>|</span><a href="#36938452">next</a><span>|</span><label class="collapse" for="c-36939942">[-]</label><label class="expand" for="c-36939942">[1 more]</label></div><br/><div class="children"><div class="content">Sure, with multiprocessing you can get 96 python processes running at 100% CPU while sharing a large dataset.<p>Only problem is that 99% of that CPU usage is for serializing&#x2F;deserializing IPC messages and total throughput would have been higher using a single process.<p>There <i>are</i> use-cases for multiprocessing. As long as data sharing between processes is insignificant, it can be quite performant. Just like using a bash-wrapper script that orchestrates a bunch of python (or other) processes.</div><br/></div></div><div id="36938452" class="c"><input type="checkbox" id="c-36938452" checked=""/><div class="controls bullet"><span class="by">OkGoDoIt</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936989">parent</a><span>|</span><a href="#36939942">prev</a><span>|</span><a href="#36938786">next</a><span>|</span><label class="collapse" for="c-36938452">[-]</label><label class="expand" for="c-36938452">[4 more]</label></div><br/><div class="children"><div class="content">Whatever happened to ironpython? I used to do a lot of C# development and remember dabbling with ironpython back in the day. It seemed like it was important to Microsoft, .Net added the whole concept of dynamic data types mostly to support ironpython and ironruby. But I never really used python much until recently, so of course when I finally needed to do python I looked for ironpython and it doesn’t appear to be a thing anymore.</div><br/><div id="36938865" class="c"><input type="checkbox" id="c-36938865" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938452">parent</a><span>|</span><a href="#36938620">next</a><span>|</span><label class="collapse" for="c-36938865">[-]</label><label class="expand" for="c-36938865">[1 more]</label></div><br/><div class="children"><div class="content">It looks like Microsoft abandoned these dynamic language implementations in 2010.  Maintaining parallel implementations of two complex, mature scripting languages is a huge feat.  It would take some very expensive talent.  That said, IronPython was loved by those who used it, which means it captured them in the DotNet ecosystem.  Perhaps that win was not enough for Microsoft to continue the project.  Ideally, Python foundation should &quot;own&quot; (and fund) Jython and IronPython development, but that takes (a lot of) money.  (Sorry, I&#x27;m much less familiar with Ruby and IronRuby.)</div><br/></div></div><div id="36938620" class="c"><input type="checkbox" id="c-36938620" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938452">parent</a><span>|</span><a href="#36938865">prev</a><span>|</span><a href="#36938786">next</a><span>|</span><label class="collapse" for="c-36938620">[-]</label><label class="expand" for="c-36938620">[2 more]</label></div><br/><div class="children"><div class="content">It is still a thing, but it&#x27;s open source now instead of maintained by Microsoft.  There was a release that finally supports Python 3 in December last year.<p>I don&#x27;t know how useful it is really, if you really want performance then you probably shouldn&#x27;t choose Python to begin with, or you use the libraries which may not be compatible with IronPython.  These days it barely takes me longer to build a simple script in C# than in Python either.</div><br/><div id="36939030" class="c"><input type="checkbox" id="c-36939030" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938620">parent</a><span>|</span><a href="#36938786">next</a><span>|</span><label class="collapse" for="c-36939030">[-]</label><label class="expand" for="c-36939030">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so so.
Pythons core value is it&#x27;s huge stack of lib&#x27;s. And most important fall down with IP due to them using c and so on.<p>When we needed python c# interop it was better to use python.net and integrate that way. Annoying to setup but when it works you can get both to work seamlessly</div><br/></div></div></div></div></div></div></div></div><div id="36938786" class="c"><input type="checkbox" id="c-36938786" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36936989">prev</a><span>|</span><a href="#36939090">next</a><span>|</span><label class="collapse" for="c-36938786">[-]</label><label class="expand" for="c-36938786">[1 more]</label></div><br/><div class="children"><div class="content">Multiprocessing is great. But then every process keeps its own copy of hundreds of gigabytes of stuff. May be okay, depending on how many processes you spawn.<p>If the bulk of the data is immutable (or at least never mutated), it can be safely shared though, via shared memory.</div><br/></div></div><div id="36939090" class="c"><input type="checkbox" id="c-36939090" checked=""/><div class="controls bullet"><span class="by">amrx101</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36938786">prev</a><span>|</span><a href="#36936819">next</a><span>|</span><label class="collapse" for="c-36939090">[-]</label><label class="expand" for="c-36939090">[1 more]</label></div><br/><div class="children"><div class="content">I dont really partake in programming &quot;wars&quot;, but the idea of launching a set of separate processes instead of separate threads to do a bunch of IOs has always seem to be weird to me. Yes, I have built software using Python. Yes, I have done things as you suggest. Now I use asyncio, since the syntax has matured and I finally understand coroutines, runners, tasks etc. Lets see where the GIL less Python takes us.</div><br/></div></div><div id="36936819" class="c"><input type="checkbox" id="c-36936819" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36939090">prev</a><span>|</span><a href="#36937959">next</a><span>|</span><label class="collapse" for="c-36936819">[-]</label><label class="expand" for="c-36936819">[1 more]</label></div><br/><div class="children"><div class="content">This exists, but one of two things happen, which still significantly slows things down. Either 1) you generate multiple python instances or 2) you push the code to a different language. Both are cumbersome and have significant effects. The latter is more common in computational libraries like numpy or pytorch, but in this respect it is more akin to python being a wrapper for C&#x2F;C++&#x2F;Cuda. Your performance is directly related to the percentage of time your code spends within those computation blocks otherwise you get hammered by IO operations.</div><br/></div></div><div id="36937959" class="c"><input type="checkbox" id="c-36937959" checked=""/><div class="controls bullet"><span class="by">scrozart</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36936819">prev</a><span>|</span><a href="#36937004">next</a><span>|</span><label class="collapse" for="c-36937959">[-]</label><label class="expand" for="c-36937959">[1 more]</label></div><br/><div class="children"><div class="content">Yup. I work at the Space Telescope Science Institute, where we maintain pipelines for astronomical data that move petabytes, among other things. All of the heavy lifting is done in Python.</div><br/></div></div><div id="36937004" class="c"><input type="checkbox" id="c-36937004" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937959">prev</a><span>|</span><a href="#36938764">next</a><span>|</span><label class="collapse" for="c-36937004">[-]</label><label class="expand" for="c-36937004">[1 more]</label></div><br/><div class="children"><div class="content">You have to manually set up shared memory with its own API that has its own limitations, right? I thought some seamless integration was a new feature, but AFAICT, transfers between multiprocesses still leads to things being pickled and copied. Am I wrong?</div><br/></div></div><div id="36938764" class="c"><input type="checkbox" id="c-36938764" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937004">prev</a><span>|</span><a href="#36937464">next</a><span>|</span><label class="collapse" for="c-36938764">[-]</label><label class="expand" for="c-36938764">[1 more]</label></div><br/><div class="children"><div class="content">Python is also going to get a JIT eventually, so they’re fixing that too! One of the concerns with no gil was that it would make certain optimisations harder for the JIT, but it’s very cool to see both being worked on.</div><br/></div></div><div id="36937464" class="c"><input type="checkbox" id="c-36937464" checked=""/><div class="controls bullet"><span class="by">whywhywhydude</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36938764">prev</a><span>|</span><a href="#36937671">next</a><span>|</span><label class="collapse" for="c-36937464">[-]</label><label class="expand" for="c-36937464">[5 more]</label></div><br/><div class="children"><div class="content">If you have a non trivial application, multiprocessing just takes a lot of memory. Every child process that you create duplicates the parent memory. There are some interesting hacks like gc.freeze that exploits the copy on write feature of forks to reduce memory, but ultimately you can just create a few hundred of processes compared to thousands of threads because of memory consumption.</div><br/><div id="36937491" class="c"><input type="checkbox" id="c-36937491" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937464">parent</a><span>|</span><a href="#36937671">next</a><span>|</span><label class="collapse" for="c-36937491">[-]</label><label class="expand" for="c-36937491">[4 more]</label></div><br/><div class="children"><div class="content">&gt;<i>If you have a non trivial application, multiprocessing just takes a lot of memory. Every child process that you create duplicates the parent memory.</i><p>Not really, unless you want to alter it. The OS uses copy on write behind the scenes for forked processes, so will use the same memory locations already loaded until&#x2F;if you modify that. So parent memory isn&#x27;t really duplicated.<p>As for any new memory allocated by each child process, that&#x27;s its own.</div><br/><div id="36937704" class="c"><input type="checkbox" id="c-36937704" checked=""/><div class="controls bullet"><span class="by">whywhywhydude</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937491">parent</a><span>|</span><a href="#36937542">next</a><span>|</span><label class="collapse" for="c-36937704">[-]</label><label class="expand" for="c-36937704">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, python garbage collector messes up copy on write. Here’s a blog from instagram on how they fixed it - <a href="https:&#x2F;&#x2F;instagram-engineering.com&#x2F;copy-on-write-friendly-python-garbage-collection-ad6ed5233ddf" rel="nofollow noreferrer">https:&#x2F;&#x2F;instagram-engineering.com&#x2F;copy-on-write-friendly-pyt...</a></div><br/></div></div><div id="36937542" class="c"><input type="checkbox" id="c-36937542" checked=""/><div class="controls bullet"><span class="by">sgeisenh</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937491">parent</a><span>|</span><a href="#36937704">prev</a><span>|</span><a href="#36938036">next</a><span>|</span><label class="collapse" for="c-36937542">[-]</label><label class="expand" for="c-36937542">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately the generational GC modifies bits all over the heap, so you have to use some tricks to really leverage copy on write (as the commenter alludes to).</div><br/></div></div><div id="36938036" class="c"><input type="checkbox" id="c-36938036" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937491">parent</a><span>|</span><a href="#36937542">prev</a><span>|</span><a href="#36937671">next</a><span>|</span><label class="collapse" for="c-36938036">[-]</label><label class="expand" for="c-36938036">[1 more]</label></div><br/><div class="children"><div class="content">Fork&#x27;s copy on write does not mix well with garbage collection.</div><br/></div></div></div></div></div></div><div id="36937671" class="c"><input type="checkbox" id="c-36937671" checked=""/><div class="controls bullet"><span class="by">jgalt212</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937464">prev</a><span>|</span><a href="#36938293">next</a><span>|</span><label class="collapse" for="c-36937671">[-]</label><label class="expand" for="c-36937671">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Multiprocessing. The answer is to use the python multiprocessing module, or to spin up multiple processes behind wsgi or whatever.<p>I assume mod_wsgi under apache was not the answer here due to memory constraints.  That being said, why not serve from disk and use redis for a cache.  This should work well unless the queries had high cardinality.</div><br/><div id="36939040" class="c"><input type="checkbox" id="c-36939040" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937671">parent</a><span>|</span><a href="#36938293">next</a><span>|</span><label class="collapse" for="c-36939040">[-]</label><label class="expand" for="c-36939040">[1 more]</label></div><br/><div class="children"><div class="content">Serve what from disk? If they are using python, they are almost certainly writing am api server, not static files.</div><br/></div></div></div></div><div id="36938293" class="c"><input type="checkbox" id="c-36938293" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936693">parent</a><span>|</span><a href="#36937671">prev</a><span>|</span><a href="#36936272">next</a><span>|</span><label class="collapse" for="c-36938293">[-]</label><label class="expand" for="c-36938293">[1 more]</label></div><br/><div class="children"><div class="content">Or just use a language that was actually designed to be something other than a scripting language?</div><br/></div></div></div></div><div id="36936272" class="c"><input type="checkbox" id="c-36936272" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936693">prev</a><span>|</span><a href="#36936317">next</a><span>|</span><label class="collapse" for="c-36936272">[-]</label><label class="expand" for="c-36936272">[5 more]</label></div><br/><div class="children"><div class="content">No, that’s about right.<p>The response, which isn’t technically wrong, is “unless you’re CPU bound, your application should be parallized with a WSGI. You shouldn’t be loading all that up in memory so it shouldn’t matter that you run 5 Python processes that each handle many many  concurrent I&#x2F;O bound requests.”<p>And this is kinda true… I’ve done it a lot. But it’s very inflexible.   I hate programming architectures&#x2F;patterns&#x2F;whatnot where the answer is “no you’re doing it wrong. You shouldn’t be needing gigs of memory for your web server. Go learn task queues or whatever.” They’re not always wrong, but very regularly it’s the wrong time to worry about such “anti patterns.”</div><br/><div id="36939414" class="c"><input type="checkbox" id="c-36939414" checked=""/><div class="controls bullet"><span class="by">dotnet00</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936272">parent</a><span>|</span><a href="#36940038">next</a><span>|</span><label class="collapse" for="c-36939414">[-]</label><label class="expand" for="c-36939414">[3 more]</label></div><br/><div class="children"><div class="content">Yes, this is even more the case in languages that are popular with more &quot;applied&quot; programming audiences, like scientific computing. Telling them &quot;no you should be using this complicated DBMS&quot; (or whatever other acronym) is not productive.<p>It tends to get them exceptionally mad because their concern isn&#x27;t the ideal way to write the code and architect the system, they simply want to write just enough code to continue their research, and even if they did care about proper architecture, they don&#x27;t have the time or interest in learning&#x2F;testing a new library for every little thing. They&#x27;d rather be putting that time reading up on their field of research.</div><br/><div id="36939733" class="c"><input type="checkbox" id="c-36939733" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36939414">parent</a><span>|</span><a href="#36940038">next</a><span>|</span><label class="collapse" for="c-36939733">[-]</label><label class="expand" for="c-36939733">[2 more]</label></div><br/><div class="children"><div class="content">This stance always rubbed me the wrong way a bit. Effectively, code is one of the tools a researcher uses to do their work. As soon as their work interacts with other people, for example when publishing a purportedly reproducible study or supplying novel algorithms to developers, they have a responsibility to deliver proper work that can be used and understood by other people. This is something we expect of every other profession, yet scientists appear to somehow have no concern for such lowly ambitions.<p>To be clear, I’m not advocating for data scientists to write production-grade webapps. But I absolutely think they should be bothered to write code that fulfills minimal requirements, is reproducible, documented, and mostly bug-free.</div><br/><div id="36940115" class="c"><input type="checkbox" id="c-36940115" checked=""/><div class="controls bullet"><span class="by">dotnet00</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36939733">parent</a><span>|</span><a href="#36940038">next</a><span>|</span><label class="collapse" for="c-36940115">[-]</label><label class="expand" for="c-36940115">[1 more]</label></div><br/><div class="children"><div class="content">I think data scientists tend to have a lot of overlap with computer people so expectations for them may be a bit higher, my experience comes mainly from physicists.<p>Reproducible, documented and bug free is fine, they care plenty about those things too, the issue is the &quot;no you&#x27;re doing it the wrong way, use this entirely different technology instead&quot; being based almost entirely on ideological reasons.<p>If we take C multithreading as an example, with my superivising scientist, multithreading is fine, he&#x27;s willing to put some time into learning how it works because it&#x27;s valuable and has had a stable interface backed by a reliable body for a while now. But if tomorrow you came up to him and insisted that doing multithreading was wrong without a solid technical reason (eg actual bugs and an explanation of how the only way to fix it is to dump the existing code and spend a few months redesigning) you&#x27;d get shot down.</div><br/></div></div></div></div></div></div><div id="36940038" class="c"><input type="checkbox" id="c-36940038" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936272">parent</a><span>|</span><a href="#36939414">prev</a><span>|</span><a href="#36936317">next</a><span>|</span><label class="collapse" for="c-36940038">[-]</label><label class="expand" for="c-36940038">[1 more]</label></div><br/><div class="children"><div class="content">Well, it&#x27;s like showing your plan for painting a room, and asking &quot;I seem to get stuck here after painting all but the corner, how do I get out of the corner?&quot;. The answer actually is &quot;don&#x27;t leave the corner for last&quot;.<p>Or like the martial arts student asking the master &quot;how do I fight a guy 100m away with a rifle?&quot; - &quot;don&#x27;t be there&quot;.</div><br/></div></div></div></div><div id="36936317" class="c"><input type="checkbox" id="c-36936317" checked=""/><div class="controls bullet"><span class="by">threatripper</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936272">prev</a><span>|</span><a href="#36939228">next</a><span>|</span><label class="collapse" for="c-36936317">[-]</label><label class="expand" for="c-36936317">[10 more]</label></div><br/><div class="children"><div class="content">You have a single big data structure that can&#x27;t be shared easily between multiple processes. Can&#x27;t you use multiprocessing with that? Maybe mapping the data structure to a file and mmapping that in multiple processes? Maybe wrapping the whole thing in database instead of just using one huge nested dictionary? To me multi-threading sounds so much less painful than all the alternatives that I could imagine. Just adding multi-threading could give you &gt;10x improvement on current hardware without much extra work if your data structure plays nice.</div><br/><div id="36936418" class="c"><input type="checkbox" id="c-36936418" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936317">parent</a><span>|</span><a href="#36939880">next</a><span>|</span><label class="collapse" for="c-36936418">[-]</label><label class="expand" for="c-36936418">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You have a single big data structure that can&#x27;t be shared easily between multiple processes. Can&#x27;t you use multiprocessing with that? Maybe mapping the data structure to a file and mmapping that in multiple processes? Maybe wrapping the whole thing in database instead of just using one huge nested dictionary?<p>ton of additional complexity, not worth it for many use-cases and anything on the line of &quot;using multiple processes or threads to increase python performance&quot; does have (or at least did have) quite a bunch of additional foot guns in python<p>In that context porting a very trivial ad-hoc application to Java (or C# or Rust, depending on what knowhow exist in the Team) would faster or at least not much slower to do. But it would be reliable estimable by reducing the chance for any unexpected issues, like less perf then expected.<p>Basically the moment &quot;use mmap&quot; or &quot;use multi-processing&quot; is a reasonable recommendation for something ad-hocish there is something rally wrong with the tools you use IMHO.</div><br/><div id="36938862" class="c"><input type="checkbox" id="c-36938862" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936418">parent</a><span>|</span><a href="#36936457">next</a><span>|</span><label class="collapse" for="c-36938862">[-]</label><label class="expand" for="c-36938862">[1 more]</label></div><br/><div class="children"><div class="content">How good is support for numpy &#x2F; scipy &#x2F; pandas or equivalents, if they exist, outside Python?<p>Actually the resulting structure should of course be dumped into an RDBMS or a graph DB and served from there more readily. Doing that takes skill and time though, which often are worth applying elsewhere.</div><br/></div></div><div id="36936457" class="c"><input type="checkbox" id="c-36936457" checked=""/><div class="controls bullet"><span class="by">threatripper</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936418">parent</a><span>|</span><a href="#36938862">prev</a><span>|</span><a href="#36936839">next</a><span>|</span><label class="collapse" for="c-36936457">[-]</label><label class="expand" for="c-36936457">[1 more]</label></div><br/><div class="children"><div class="content">The use case I&#x27;m thinking about is very simple: One big data structure that is mostly read from and sometimes written to. Use a single mutex with a shared lock for reading and an exclusive lock for writing. Then the readers are safe and would only block during updates when one writer is active. Everything else beside the data structure can be per-thread and wouldn&#x27;t interfere.<p>The problem why we wouldn&#x27;t want to port this application to another language is 100k lines of existing code that is best written in Python and no resources to rewrite all that.</div><br/></div></div><div id="36936839" class="c"><input type="checkbox" id="c-36936839" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936418">parent</a><span>|</span><a href="#36936457">prev</a><span>|</span><a href="#36939880">next</a><span>|</span><label class="collapse" for="c-36936839">[-]</label><label class="expand" for="c-36936839">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Basically the moment &quot;use mmap&quot; or &quot;use multi-processing&quot; is a reasonable recommendation for something ad-hocish there is something rally wrong with the tools you use IMHO.</i><p>Hmm. So you&#x27;re saying only languages which bury lock and mutex over shared data are appropriate to use for async parallelism over shared data? Because calling explicit lock() and releae() isn&#x27;t that hard. However it does incur a function call overhead. I suppose some explicit in language support could minimise that partially.</div><br/><div id="36937561" class="c"><input type="checkbox" id="c-36937561" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936839">parent</a><span>|</span><a href="#36939880">next</a><span>|</span><label class="collapse" for="c-36937561">[-]</label><label class="expand" for="c-36937561">[1 more]</label></div><br/><div class="children"><div class="content">no I never said that</div><br/></div></div></div></div></div></div><div id="36939880" class="c"><input type="checkbox" id="c-36939880" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936317">parent</a><span>|</span><a href="#36936418">prev</a><span>|</span><a href="#36936491">next</a><span>|</span><label class="collapse" for="c-36939880">[-]</label><label class="expand" for="c-36939880">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d go for a db, yeah, or if that&#x27;s a really painful mapping, this, erm, is actually the sort of thing Go is pretty good at it, and it&#x27;s not too hard to write a fairly simple program that will traverse your data structure and communicate via a JSON api or something. That&#x27;s a useful technique in general - separate the big heavy awkward thing from your main web processes.<p>While I hate how verbose and inexpressive it is, Go does hit a sweet spot of fairly good performance, even multi-core, while still being GCed so it&#x27;s not nearly as foreign for a native python user.</div><br/></div></div><div id="36936491" class="c"><input type="checkbox" id="c-36936491" checked=""/><div class="controls bullet"><span class="by">kroolik</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936317">parent</a><span>|</span><a href="#36939880">prev</a><span>|</span><a href="#36939228">next</a><span>|</span><label class="collapse" for="c-36936491">[-]</label><label class="expand" for="c-36936491">[3 more]</label></div><br/><div class="children"><div class="content">One annoying part with multiprocessing in Python is that you could abuse the COW mechanism to save on loading time when forking. But Python stores ref counters together with objects so every single read will bust your COW cache.<p>Now, you wanted it simple, but got to fight with the memory model of a language that wasn&#x27;t designed with performance in mind, for programs whose focus wasn&#x27;t performance.</div><br/><div id="36937022" class="c"><input type="checkbox" id="c-36937022" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936491">parent</a><span>|</span><a href="#36939228">next</a><span>|</span><label class="collapse" for="c-36937022">[-]</label><label class="expand" for="c-36937022">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s gc.freeze for that now <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;gc.html#gc.freeze" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;gc.html#gc.freeze</a><p>If you load something big before forking workers, there&#x27;s no CoW issue with that big structure anymore.</div><br/><div id="36938280" class="c"><input type="checkbox" id="c-36938280" checked=""/><div class="controls bullet"><span class="by">justinc-md</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937022">parent</a><span>|</span><a href="#36939228">next</a><span>|</span><label class="collapse" for="c-36938280">[-]</label><label class="expand" for="c-36938280">[1 more]</label></div><br/><div class="children"><div class="content">gc.freeze prevents considering the objects in gc, but doesn’t disable reference counting so you’ll still have CoW issues. PEP 683 introduces a way to make an object immortal which disables reference counting, which will address that issue.</div><br/></div></div></div></div></div></div></div></div><div id="36939228" class="c"><input type="checkbox" id="c-36939228" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936317">prev</a><span>|</span><a href="#36936116">next</a><span>|</span><label class="collapse" for="c-36939228">[-]</label><label class="expand" for="c-36939228">[1 more]</label></div><br/><div class="children"><div class="content">It sounds I&#x2F;O heavy, but you mention it being CPU-heavy in which case I’d say Python is just not the right tool for the job although you may be able to cope with multiprocessing.</div><br/></div></div><div id="36936116" class="c"><input type="checkbox" id="c-36936116" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36939228">prev</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36936116">[-]</label><label class="expand" for="c-36936116">[16 more]</label></div><br/><div class="children"><div class="content">Similar experience. Even with multi process and threads python is slow, very slow. Java, Go and .NET all provide a very performant out of box experience.</div><br/><div id="36937095" class="c"><input type="checkbox" id="c-36937095" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936116">parent</a><span>|</span><a href="#36937370">next</a><span>|</span><label class="collapse" for="c-36937095">[-]</label><label class="expand" for="c-36937095">[8 more]</label></div><br/><div class="children"><div class="content">Python is both an interpreter, and quite dynamic.  Both of these lead to lower performance when compared to less dynamic, compiled solutions.  All of Java, Go, and .NET are compiled and (much) less dynamic.<p>This is absolutely an expected outcome.</div><br/><div id="36937309" class="c"><input type="checkbox" id="c-36937309" checked=""/><div class="controls bullet"><span class="by">mike_ivanov</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937095">parent</a><span>|</span><a href="#36937829">next</a><span>|</span><label class="collapse" for="c-36937309">[-]</label><label class="expand" for="c-36937309">[3 more]</label></div><br/><div class="children"><div class="content">&quot;absolutely an expected outcome.&quot;<p>Good day. Is it the right time to talk to you about Common Lisp?</div><br/><div id="36939075" class="c"><input type="checkbox" id="c-36939075" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937309">parent</a><span>|</span><a href="#36937827">next</a><span>|</span><label class="collapse" for="c-36939075">[-]</label><label class="expand" for="c-36939075">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, if you use CL in a similarly dynamic way as Python (don&#x27;t compile anything, don&#x27;t add any declarations etc) it won&#x27;t be that much faster. You&#x27;ll get some boost out of the stdlib stuff being compiled already, but otherwise it will incur similar performance penalties.</div><br/></div></div><div id="36937827" class="c"><input type="checkbox" id="c-36937827" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937309">parent</a><span>|</span><a href="#36939075">prev</a><span>|</span><a href="#36937829">next</a><span>|</span><label class="collapse" for="c-36937827">[-]</label><label class="expand" for="c-36937827">[1 more]</label></div><br/><div class="children"><div class="content">Always a good time.</div><br/></div></div></div></div><div id="36937829" class="c"><input type="checkbox" id="c-36937829" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937095">parent</a><span>|</span><a href="#36937309">prev</a><span>|</span><a href="#36937200">next</a><span>|</span><label class="collapse" for="c-36937829">[-]</label><label class="expand" for="c-36937829">[2 more]</label></div><br/><div class="children"><div class="content">These days even elisp can be compiled. I think python need to be dragged kicking and screaming into cutting edge &#x27;80s dynamic compilation technology.</div><br/><div id="36937902" class="c"><input type="checkbox" id="c-36937902" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937829">parent</a><span>|</span><a href="#36937200">next</a><span>|</span><label class="collapse" for="c-36937902">[-]</label><label class="expand" for="c-36937902">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure skilled volunteers would be very welcome.<p>There are numerous active, moderately serious efforts to both optimize and&#x2F;or JIT Python bytecode.  I think AOT compilation is mostly out-of-scope for 100% compatibility, but again, there&#x27;s lots of different efforts to compile either subset languages or subsets of programs.<p>&quot;Kicking and screaming&quot; suggests some reluctance to embrace this, but I think that&#x27;s probably unfair: it&#x27;s just hard.</div><br/></div></div></div></div><div id="36937200" class="c"><input type="checkbox" id="c-36937200" checked=""/><div class="controls bullet"><span class="by">cypress66</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937095">parent</a><span>|</span><a href="#36937829">prev</a><span>|</span><a href="#36937370">next</a><span>|</span><label class="collapse" for="c-36937200">[-]</label><label class="expand" for="c-36937200">[2 more]</label></div><br/><div class="children"><div class="content">Node is pretty performant for anything IO related, not compiled and reasonably dynamic.</div><br/><div id="36937863" class="c"><input type="checkbox" id="c-36937863" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937200">parent</a><span>|</span><a href="#36937370">next</a><span>|</span><label class="collapse" for="c-36937863">[-]</label><label class="expand" for="c-36937863">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s worth the clarification that Javascript is usually JITed; (C)Python isn&#x27;t.<p>And that CPython&#x27;s I&#x2F;O isn&#x27;t really the problem: some of its async event loop implementations are fairly competitive with Node.<p>But still ... yes.<p>Javascript has benefited from two decades of intensive, well-funded work by the best people in the business, with clear focus on performance as a high priority goal.  Not to take away from those who work on Python, but I think it&#x27;s fair to say the effort has had orders of magnitude difference.<p>I don&#x27;t have a deep enough understanding to say whether the nature of Python or Javascript makes one better suited for performance optimization than the other.  Python is perhaps able to benefit from seeing what&#x27;s been done with Javascript, although of course Javascript has stood on the shoulders of its own giants.</div><br/></div></div></div></div></div></div><div id="36937370" class="c"><input type="checkbox" id="c-36937370" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936116">parent</a><span>|</span><a href="#36937095">prev</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36937370">[-]</label><label class="expand" for="c-36937370">[7 more]</label></div><br/><div class="children"><div class="content">3.11 and on should be comparable to Java for most use cases with multiprocessing (set up correctly of course)</div><br/><div id="36937801" class="c"><input type="checkbox" id="c-36937801" checked=""/><div class="controls bullet"><span class="by">geysersam</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937370">parent</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36937801">[-]</label><label class="expand" for="c-36937801">[6 more]</label></div><br/><div class="children"><div class="content">How do you mean? 3.11 is something like 10-20% faster than earlier Python releases. Why should that make it comparable to Java? Typically Java is still several times faster than Python, and this is totally natural since Java performance benefits from static type declarations and the language is generally less dynamic than Python.<p>That said I still use Python  for CPU intensive tasks since in my experience  Numpy&#x2F;Scipy&#x2F;Numba etc does a good job speeding up the CPU intensive parts of Python code.</div><br/><div id="36938044" class="c"><input type="checkbox" id="c-36938044" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937801">parent</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36938044">[-]</label><label class="expand" for="c-36938044">[5 more]</label></div><br/><div class="children"><div class="content">Static type declarations don&#x27;t make Java fast. The compiler does. Dynamically typed languages with no type declarations can be very fast if the compiler can infer the types.<p>That&#x27;s not to say that Python will ever get there. My understanding is that the design of the language and leaky implementation details make generally compiling Python to fast machine code nearly impossible.</div><br/><div id="36938153" class="c"><input type="checkbox" id="c-36938153" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938044">parent</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36938153">[-]</label><label class="expand" for="c-36938153">[4 more]</label></div><br/><div class="children"><div class="content">Well, we already have a mature, real-world Python JIT in PyPy, with impressive performance.<p>I dunno if Python is ever gonna be as fast as Java or C#, but we know it can be much better.</div><br/><div id="36938552" class="c"><input type="checkbox" id="c-36938552" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938153">parent</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36938552">[-]</label><label class="expand" for="c-36938552">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t find any benchmarks of PyPy vs OpenJDK or GraalVM, but unless I&#x27;m mistaken it&#x27;s still more than 100% difference, and maybe much, much more for pure-Python vs. Java.</div><br/><div id="36938948" class="c"><input type="checkbox" id="c-36938948" checked=""/><div class="controls bullet"><span class="by">mattip</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938552">parent</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36938948">[-]</label><label class="expand" for="c-36938948">[2 more]</label></div><br/><div class="children"><div class="content">Here ya go. On these sometimes one is faster, sometimes the other. <a href="https:&#x2F;&#x2F;github.com&#x2F;kostya&#x2F;jit-benchmarks&#x2F;blob&#x2F;master&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;kostya&#x2F;jit-benchmarks&#x2F;blob&#x2F;master&#x2F;README....</a>
Personally i don’t like such comparisons. Benchmarking is hard and far from objective. Much of what makes python popular is the developer experience. Generic benchmarks will only give a rough guide about what to expect in your application. If you are in a niche like the OP, you will have to figure out how to handle your bottlenecks.</div><br/><div id="36938993" class="c"><input type="checkbox" id="c-36938993" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938948">parent</a><span>|</span><a href="#36939834">next</a><span>|</span><label class="collapse" for="c-36938993">[-]</label><label class="expand" for="c-36938993">[1 more]</label></div><br/><div class="children"><div class="content">Eagerly awaiting no-Gil Flask vs. Dropwizard performance analysis.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36939834" class="c"><input type="checkbox" id="c-36939834" checked=""/><div class="controls bullet"><span class="by">lfkdev</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936116">prev</a><span>|</span><a href="#36936866">next</a><span>|</span><label class="collapse" for="c-36939834">[-]</label><label class="expand" for="c-36939834">[1 more]</label></div><br/><div class="children"><div class="content">You could have just use gunicorn and spawn multiple workers maybe</div><br/></div></div><div id="36936866" class="c"><input type="checkbox" id="c-36936866" checked=""/><div class="controls bullet"><span class="by">strictfp</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36939834">prev</a><span>|</span><a href="#36936539">next</a><span>|</span><label class="collapse" for="c-36936866">[-]</label><label class="expand" for="c-36936866">[5 more]</label></div><br/><div class="children"><div class="content">My tip for this is Node.js and some stream processing lib like Highland. You can get <i>ridiculous</i> IO parallelism with a very little code and a nice API.<p>Python just scales terribly, no matter if you use multi-process or not. Java can get pretty good perf, but you&#x27;ll need some libs or quite a bit of code to get nonblocking IO sending working well, or you&#x27;re going to eat huge amounts of resources for moderate returns.<p>Node really excels at this use case. You can saturate the lines pretty easily.</div><br/><div id="36937664" class="c"><input type="checkbox" id="c-36937664" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936866">parent</a><span>|</span><a href="#36938138">next</a><span>|</span><label class="collapse" for="c-36937664">[-]</label><label class="expand" for="c-36937664">[1 more]</label></div><br/><div class="children"><div class="content">0_o<p>Did I miss something?  Does nodes&#x2F;highland have good shared memory semantics these days?<p>I&#x27;ve always felt the best analogy to python concurrency was (node)js, but I admittedly haven&#x27;t kept up all that well.</div><br/></div></div><div id="36938138" class="c"><input type="checkbox" id="c-36938138" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936866">parent</a><span>|</span><a href="#36937664">prev</a><span>|</span><a href="#36938676">next</a><span>|</span><label class="collapse" for="c-36938138">[-]</label><label class="expand" for="c-36938138">[1 more]</label></div><br/><div class="children"><div class="content">I think they mentioned CPU intensive work, which I&#x27;m taking to imply that it&#x27;s more CPU bound than I&#x2F;O bound. So unless you&#x27;re suggesting they use Node&#x27;s web workers implementation for parallelism, the default single threaded async concurrency model probably won&#x27;t serve them well.</div><br/></div></div><div id="36938676" class="c"><input type="checkbox" id="c-36938676" checked=""/><div class="controls bullet"><span class="by">pid-1</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936866">parent</a><span>|</span><a href="#36938138">prev</a><span>|</span><a href="#36938872">next</a><span>|</span><label class="collapse" for="c-36938676">[-]</label><label class="expand" for="c-36938676">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Node single threaded, just like Python?</div><br/></div></div><div id="36938872" class="c"><input type="checkbox" id="c-36938872" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936866">parent</a><span>|</span><a href="#36938676">prev</a><span>|</span><a href="#36936539">next</a><span>|</span><label class="collapse" for="c-36938872">[-]</label><label class="expand" for="c-36938872">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t Elixir or Go be better for this use case? Node still blocks on compute heavy tasks.</div><br/></div></div></div></div><div id="36936539" class="c"><input type="checkbox" id="c-36936539" checked=""/><div class="controls bullet"><span class="by">rrishi</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936866">prev</a><span>|</span><a href="#36936463">next</a><span>|</span><label class="collapse" for="c-36936539">[-]</label><label class="expand" for="c-36936539">[11 more]</label></div><br/><div class="children"><div class="content">I am not too deeply experienced with Python so forgive my ignorance.<p>But I am curious to understand why you were not able to utilize the concurrency tools provided in Python.<p>A quick google search gave me these relevant resources<p>1. An intro to threading in Python (<a href="https:&#x2F;&#x2F;realpython.com&#x2F;intro-to-python-threading&#x2F;#conclusion-threading-in-python" rel="nofollow noreferrer">https:&#x2F;&#x2F;realpython.com&#x2F;intro-to-python-threading&#x2F;#conclusion...</a>)<p>2. Speed Up Your Python Program With Concurrency (<a href="https:&#x2F;&#x2F;realpython.com&#x2F;python-concurrency&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;realpython.com&#x2F;python-concurrency&#x2F;</a>)<p>3. Async IO in Python: A Complete Walkthrough (<a href="https:&#x2F;&#x2F;realpython.com&#x2F;async-io-python&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;realpython.com&#x2F;async-io-python&#x2F;</a>)<p>Forgive me for my naivety. This topic has been bothering me for quite a while.<p>Several people complain about the lack of threading in Python but I run into plenty of blogs and books on concurrency in Python.<p>Clearly there is a lack in my understanding of things.</div><br/><div id="36936814" class="c"><input type="checkbox" id="c-36936814" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936539">parent</a><span>|</span><a href="#36936665">next</a><span>|</span><label class="collapse" for="c-36936814">[-]</label><label class="expand" for="c-36936814">[5 more]</label></div><br/><div class="children"><div class="content">Re (3): asyncio does not give you a boost for CPU bound tasks. It&#x27;s a single-threaded, cooperative multi-tasking system that can (if you&#x27;re IO bound) give you a performance boost.</div><br/><div id="36937642" class="c"><input type="checkbox" id="c-36937642" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936814">parent</a><span>|</span><a href="#36936665">next</a><span>|</span><label class="collapse" for="c-36937642">[-]</label><label class="expand" for="c-36937642">[4 more]</label></div><br/><div class="children"><div class="content">Ehhh I mean you&#x27;re not wrong, but I wouldn&#x27;t say you&#x27;re fully right either.<p>You can absolutely send stuff to a thread pool executor or process pool executor and then never await the returned value&#x2F;never have it &quot;return until interrupted, but the issues with shared memory (or really, the lack thereof in comparison to ex C) are still present to my understanding.<p>Then again, I mean you can always spin up a sqllite server or something on the same machine, but that&#x27;s stupid heavy and more of a workaround than a solution.  Super excited for nogil.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;concurrent.futures.html#co...</a></div><br/><div id="36937937" class="c"><input type="checkbox" id="c-36937937" checked=""/><div class="controls bullet"><span class="by">mypalmike</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937642">parent</a><span>|</span><a href="#36936665">next</a><span>|</span><label class="collapse" for="c-36937937">[-]</label><label class="expand" for="c-36937937">[3 more]</label></div><br/><div class="children"><div class="content">Not sure why you mention &quot;thread pool executor&quot;, which of course does not get you concurrency due to the gil.</div><br/><div id="36938781" class="c"><input type="checkbox" id="c-36938781" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937937">parent</a><span>|</span><a href="#36936665">next</a><span>|</span><label class="collapse" for="c-36938781">[-]</label><label class="expand" for="c-36938781">[2 more]</label></div><br/><div class="children"><div class="content">Pedantic nerd nitpick: it gives you concurrency but not parallelism. (Concurrent threads can be time sliced on one core)</div><br/><div id="36939703" class="c"><input type="checkbox" id="c-36939703" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36938781">parent</a><span>|</span><a href="#36936665">next</a><span>|</span><label class="collapse" for="c-36939703">[-]</label><label class="expand" for="c-36939703">[1 more]</label></div><br/><div class="children"><div class="content">It was clear from the context that he meant concurrently <i>running</i> not concurrently in progress. I wish nerds would give up on this parallelism&#x2F;concurrency pedantry or at least choose some new nomenclature that didn&#x27;t conflict so massively with the English meaning of &quot;concurrent&quot;.<p>I mean it&#x27;s not even right. Most parallel&#x2F;concurrent pedants would consider multithreaded code to be &quot;parallel&quot; even if it is running on a single core.<p>I think the best thing is to talk about threads, because then you can distinguish e.g. OS threads and hardware threads.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36936665" class="c"><input type="checkbox" id="c-36936665" checked=""/><div class="controls bullet"><span class="by">wmwmwm</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936539">parent</a><span>|</span><a href="#36936814">prev</a><span>|</span><a href="#36936621">next</a><span>|</span><label class="collapse" for="c-36936665">[-]</label><label class="expand" for="c-36936665">[1 more]</label></div><br/><div class="children"><div class="content">You can throw python threads at it, but if each request traverses the big old datastructure using python code and serialises a result then you’re stuck with only one live thread at a time (due to the GIL).  In Java it’s so much easier especially if the datastructure is read only or is updated periodically in an atomic fashion. Every attempt to do something like this in python has led me to having to abandon nice pythonic datastructures, fiddle around with shared memory binary formats, before sighing and reaching for java! Especially annoying if the service makes use of handy libraries like numpy&#x2F;pandas&#x2F;scipy etc!</div><br/></div></div><div id="36936621" class="c"><input type="checkbox" id="c-36936621" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936539">parent</a><span>|</span><a href="#36936665">prev</a><span>|</span><a href="#36936616">next</a><span>|</span><label class="collapse" for="c-36936621">[-]</label><label class="expand" for="c-36936621">[1 more]</label></div><br/><div class="children"><div class="content">The whole point of the GIL is that even if you use Python&#x27;s threading or asyncio, you don&#x27;t get any benefits from scaling beyond a single CPU core, because all of your threads (or coroutines) are competing for a single lock. They run &quot;concurrently&quot;, but not actually in parallel. The pages you linked explain this in more detail.<p>In theory, multiprocessing could allow you to distribute the workload, but in a situation like OP describes -- just serving API requests based on a data structure -- the overhead of dispatching requests would likely be bigger than the cost of just handling the request in the first place. And your main server process is still a bottleneck for actually parsing the incoming requests and sending responses. So you&#x27;re unlikely to see a significant benefit.</div><br/></div></div><div id="36936616" class="c"><input type="checkbox" id="c-36936616" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936539">parent</a><span>|</span><a href="#36936621">prev</a><span>|</span><a href="#36938470">next</a><span>|</span><label class="collapse" for="c-36936616">[-]</label><label class="expand" for="c-36936616">[1 more]</label></div><br/><div class="children"><div class="content">Threading in Python is fine if your threads are io bound or spend their time in a C extension which releases the GIL, if you are bound then the GIL means effectively one thread can run at a time and you gain no advantage from multiple threads.</div><br/></div></div><div id="36938470" class="c"><input type="checkbox" id="c-36938470" checked=""/><div class="controls bullet"><span class="by">indeedmug</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936539">parent</a><span>|</span><a href="#36936616">prev</a><span>|</span><a href="#36936658">next</a><span>|</span><label class="collapse" for="c-36938470">[-]</label><label class="expand" for="c-36938470">[1 more]</label></div><br/><div class="children"><div class="content">I had this misunderstanding for a long time until I saw Go explain the difference: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;waza-talk" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;waza-talk</a><p>The confusion here is parallelism vs concurrency. Parallelism is executing multiple tasks at once and concurrency is the composition of multiple tasks.<p>For example, imagine there is a woodshop with multiple people and there is only one hammer. The people would be working on their projects such as a chair, a table, etc. Everyone needs to use the hammer to continue their project.<p>If someone needed a hammer, they would take the single hammer and use it. There are still other projects going on but everyone else would have to wait until the hammer is free. This is concurrency but not parallelism.<p>If there are multiple hammers, then multiple people could use the hammer at the same time and their project continues. This is parallelism and concurrency.<p>The hammer here is the CPU and the multiple projects are threads. When you have Python concurrency, you are sharing the hammer across different projects, but it&#x27;s still one hammer. This is useful for dealing with blocking I&#x2F;O but not computing bottlenecks.<p>Let&#x27;s say that one of the projects needs wood from another place. There is no point in this project to hold on to the hammer when waiting for wood. This is what those Python concurrency libraries are solving for. In real life, you have tasks waiting on other services such as getting customer info from a database. You don&#x27;t want the task to be wasting the CPU cycles doing nothing, so we can pass the CPU to another task.<p>But this doesn&#x27;t mean that we are using more of the CPU. We are still stuck with a single core. If we have a compute bottleneck such as calculating a lot of numbers, then the concurrency libraries don&#x27;t help.<p>You might be wondering why Python only allows for a single hammer&#x2F;CPU core. It&#x27;s because it&#x27;s very hard to get parallelism properly working, you can end up with your program stalling easily if you don&#x27;t do it correctly. The underlying data structures of Python were never designed with that in mind because it was meant to be a scripting language where performance wasn&#x27;t key. Python grew massive and people started to apply Python to areas where performance was key. It&#x27;s amazing that Python got so far even with GIL IMO.<p>As an aside, you might read about &quot;multiprocessing&quot; Python where you can use multiple CPU cores. This is true but there are heavy overhead costs to this. This is like building brand-new workshops with single hammers to handle more projects. This post would get even longer if I explained what is a &quot;process&quot; but to put it shortly, it is how the OS, such as Windows or Linux, manages tasks. There is a lot of overhead with it because it is meant to work with all sorts of different programs written in different languages.</div><br/></div></div></div></div><div id="36936463" class="c"><input type="checkbox" id="c-36936463" checked=""/><div class="controls bullet"><span class="by">wood_spirit</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936539">prev</a><span>|</span><a href="#36936113">next</a><span>|</span><label class="collapse" for="c-36936463">[-]</label><label class="expand" for="c-36936463">[1 more]</label></div><br/><div class="children"><div class="content">That’s right.<p>In the past, for read-only data, I’ve used a disk file and relied on the the OS page cache to keep it performant.<p>For read-write, using a raw file safely gets risky quickly.  And alternative languages with parallelism runs rings around python.<p>So getting rid of the GIL and allowing parallelism will be a big boon.</div><br/></div></div><div id="36936113" class="c"><input type="checkbox" id="c-36936113" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936463">prev</a><span>|</span><a href="#36937610">next</a><span>|</span><label class="collapse" for="c-36936113">[-]</label><label class="expand" for="c-36936113">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I may have missed something<p>You did not miss anything. The GIL prevents parallel multi threading.</div><br/></div></div><div id="36936388" class="c"><input type="checkbox" id="c-36936388" checked=""/><div class="controls bullet"><span class="by">brightball</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36937610">prev</a><span>|</span><a href="#36938040">next</a><span>|</span><label class="collapse" for="c-36936388">[-]</label><label class="expand" for="c-36936388">[4 more]</label></div><br/><div class="children"><div class="content">This is actually one of the reasons I was drawn to Ruby over Python. Ruby also has the GIL but jRuby is an excellent option when needed.</div><br/><div id="36936588" class="c"><input type="checkbox" id="c-36936588" checked=""/><div class="controls bullet"><span class="by">antod</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936388">parent</a><span>|</span><a href="#36938040">next</a><span>|</span><label class="collapse" for="c-36936588">[-]</label><label class="expand" for="c-36936588">[3 more]</label></div><br/><div class="children"><div class="content">I wonder what lead to JRuby attracting support while Jython not? I know the Jython creator went on to other things (was it eg IronPython for dotnet?). I suppose it was the inverse with dotnet - eg IronPython surviving while IronRuby seems dead.<p>Is it just down to corporate sponsorship?</div><br/><div id="36937049" class="c"><input type="checkbox" id="c-36937049" checked=""/><div class="controls bullet"><span class="by">brightball</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936588">parent</a><span>|</span><a href="#36938137">next</a><span>|</span><label class="collapse" for="c-36937049">[-]</label><label class="expand" for="c-36937049">[1 more]</label></div><br/><div class="children"><div class="content">JRuby has been pretty actively maintained for about 15 years and had a big release this year.<p>It’s an impressive project.</div><br/></div></div><div id="36938137" class="c"><input type="checkbox" id="c-36938137" checked=""/><div class="controls bullet"><span class="by">empthought</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36936588">parent</a><span>|</span><a href="#36937049">prev</a><span>|</span><a href="#36938040">next</a><span>|</span><label class="collapse" for="c-36938137">[-]</label><label class="expand" for="c-36938137">[1 more]</label></div><br/><div class="children"><div class="content">Twitter used JRuby and invested heavily for a time.</div><br/></div></div></div></div></div></div><div id="36938040" class="c"><input type="checkbox" id="c-36938040" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36936388">prev</a><span>|</span><a href="#36937219">next</a><span>|</span><label class="collapse" for="c-36938040">[-]</label><label class="expand" for="c-36938040">[1 more]</label></div><br/><div class="children"><div class="content">Spin up as many processes as you need, map connections 1:1 to processes if possible.</div><br/></div></div><div id="36937219" class="c"><input type="checkbox" id="c-36937219" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36936017">parent</a><span>|</span><a href="#36938040">prev</a><span>|</span><a href="#36938594">next</a><span>|</span><label class="collapse" for="c-36937219">[-]</label><label class="expand" for="c-36937219">[3 more]</label></div><br/><div class="children"><div class="content">Are you just reading from this data structure?  If so I wouldn&#x27;t do any locking or threading, I&#x27;d just use asyncio to serve up read requests to the data and it should scale quite well.  Multithreading&#x2F;processing is best for CPU limited workloads but this sounds like you&#x27;re really just IO-bound (limited by the very high IO of reading from that data structure in memory).<p>If you&#x27;re allowing writes to the shared data structure... I&#x27;d ask myself am I using the right tool for the job.  A proper database server like postgres will handle concurrent writers much, much better than you could code up hastily.  And it will handle failures, backups, storage, security, configuration, etc. far better than an ad hoc solution.</div><br/><div id="36939114" class="c"><input type="checkbox" id="c-36939114" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937219">parent</a><span>|</span><a href="#36937366">next</a><span>|</span><label class="collapse" for="c-36939114">[-]</label><label class="expand" for="c-36939114">[1 more]</label></div><br/><div class="children"><div class="content">Reading from memory is really not IO. Perhaps you&#x27;re suggesting doing something like mmapping a file to memory, putting the data structure in that memory, and then using asyncio on the file to serve things, but this would only work if you can compute byte ranges inside the file to serve ahead of time, in which case there are much simpler solutions anyway. Most likely, when receiving a query they need to actually search through the datastructure based on the query, and it&#x27;s very likely that this is the bottleneck, not just reading some memory.</div><br/></div></div><div id="36937366" class="c"><input type="checkbox" id="c-36937366" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36936017">root</a><span>|</span><a href="#36937219">parent</a><span>|</span><a href="#36939114">prev</a><span>|</span><a href="#36938594">next</a><span>|</span><label class="collapse" for="c-36937366">[-]</label><label class="expand" for="c-36937366">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d just use asyncio to serve up read requests to the data and it should scale quite well.<p>Quoting GP:<p>&gt;&gt; often CPU heavy<p>We have to take their word for it that it&#x27;s actually CPU heavy work, but if they&#x27;re not lying and not mistaken then asyncio would do nothing for them.</div><br/></div></div></div></div></div></div><div id="36938594" class="c"><input type="checkbox" id="c-36938594" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#36936017">prev</a><span>|</span><a href="#36935970">next</a><span>|</span><label class="collapse" for="c-36938594">[-]</label><label class="expand" for="c-36938594">[6 more]</label></div><br/><div class="children"><div class="content">When it was an in dev project, I felt the consensus on HN was that it was amazing work and a shame that it looked like the steering committee wouldn’t adopt it.<p>Now they have and everyone seems to hate it.</div><br/><div id="36940161" class="c"><input type="checkbox" id="c-36940161" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#36938594">parent</a><span>|</span><a href="#36939338">next</a><span>|</span><label class="collapse" for="c-36940161">[-]</label><label class="expand" for="c-36940161">[1 more]</label></div><br/><div class="children"><div class="content">It is probably language design enthusiasts push all these backwards incompatibilities into Python because they are not the users of the language.<p>They are a different group from those having their code broken in a never ending incompatibility churn.<p>Well atleast it gives us jobs ...</div><br/></div></div><div id="36939338" class="c"><input type="checkbox" id="c-36939338" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36938594">parent</a><span>|</span><a href="#36940161">prev</a><span>|</span><a href="#36939785">next</a><span>|</span><label class="collapse" for="c-36939338">[-]</label><label class="expand" for="c-36939338">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the eternal pendulum:<p>- take no risk, and people will blame the project for being static.<p>- take risks, and people will blame the project for being reckless.<p>E.G:<p>- don&#x27;t adopt a new feature, and your language is old, becoming irrelevant, and a wave of comments will tell you how they just can&#x27;t use it for X because they don&#x27;t have it.<p>- break compat, and you will have a horde stating you don&#x27;t care about users that need stability. You got one comment in this thread talking about &quot;the python treadmill&quot;!<p>And all that for an open source project most don&#x27;t contribute to and never paid a dime for.</div><br/><div id="36939573" class="c"><input type="checkbox" id="c-36939573" checked=""/><div class="controls bullet"><span class="by">antupis</span><span>|</span><a href="#36938594">root</a><span>|</span><a href="#36939338">parent</a><span>|</span><a href="#36939785">next</a><span>|</span><label class="collapse" for="c-36939573">[-]</label><label class="expand" for="c-36939573">[1 more]</label></div><br/><div class="children"><div class="content">World would need one more language which would have very barebone core something like very minimal go or python but strong metaprogramming features so you could expand language if you need.</div><br/></div></div></div></div><div id="36939785" class="c"><input type="checkbox" id="c-36939785" checked=""/><div class="controls bullet"><span class="by">smcl</span><span>|</span><a href="#36938594">parent</a><span>|</span><a href="#36939338">prev</a><span>|</span><a href="#36938611">next</a><span>|</span><label class="collapse" for="c-36939785">[-]</label><label class="expand" for="c-36939785">[1 more]</label></div><br/><div class="children"><div class="content">Well these likely will be entirely different groups of people voicing their opinions at different times. I don&#x27;t imagine those who were enthusiastic about the project originally have done an about-face and now hate it.</div><br/></div></div><div id="36938611" class="c"><input type="checkbox" id="c-36938611" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36938594">parent</a><span>|</span><a href="#36939785">prev</a><span>|</span><a href="#36935970">next</a><span>|</span><label class="collapse" for="c-36938611">[-]</label><label class="expand" for="c-36938611">[1 more]</label></div><br/><div class="children"><div class="content">My guess, it&#x27;s easier to dismiss the downsides of something likely to fail, and likewise focus on the positives. Now that the unexpected has happened reality demands more consideration for both.</div><br/></div></div></div></div><div id="36935970" class="c"><input type="checkbox" id="c-36935970" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#36938594">prev</a><span>|</span><a href="#36940065">next</a><span>|</span><label class="collapse" for="c-36935970">[-]</label><label class="expand" for="c-36935970">[15 more]</label></div><br/><div class="children"><div class="content">Still not encouraged by the no-GIL, &quot;We don&#x27;t want another Python 2-&gt;3 situation&quot;, yet very little proffered on how to avoid that scenario. More documentation on writing thread-safe code, suggested tooling to lint for race conditions (for whatever it is worth), discussions with popular C libraries, dedicated support channels for top tier packages, what about the enormous long-tail of abandoned extensions which still work today, etc.</div><br/><div id="36936250" class="c"><input type="checkbox" id="c-36936250" checked=""/><div class="controls bullet"><span class="by">doctoboggan</span><span>|</span><a href="#36935970">parent</a><span>|</span><a href="#36936144">next</a><span>|</span><label class="collapse" for="c-36936250">[-]</label><label class="expand" for="c-36936250">[7 more]</label></div><br/><div class="children"><div class="content">The big and obvious difference is that all the GIL vs no-GIL stuff happens in the background and your average python dev can just ignore it if they want to. The interpreter will note if you have C extensions that don&#x27;t opt in to no-GIL and then will give you the GIL version.<p>This is _very_ different to the 2-to-3 transition where absolutely every single person, even those who couldn&#x27;t care less, had to change their code if they wanted to use python 3.</div><br/><div id="36938748" class="c"><input type="checkbox" id="c-36938748" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36936250">parent</a><span>|</span><a href="#36938257">next</a><span>|</span><label class="collapse" for="c-36938748">[-]</label><label class="expand" for="c-36938748">[4 more]</label></div><br/><div class="children"><div class="content">But you need to pick your horse. In 5 years time, Python will either be GIL or no GIL, and it is hard to tell which. It might be a setting (which might be more ideal).<p>If you assume nogil, you need to choose dependencies that support that. You may need to trade off: eschew dependencies that aren&#x27;t looking like they will be nogil compatible by the deadline. You are stuck on Python 3.18 maintenance branch or whatever, rather than the 3.19 (in reality .. 4.0) version.<p>Or choose gil then you can use everything. But is there a prisoners dilemma - everyone picks gil, uses whatever dependencies, library maintainers assuming this don&#x27;t bother to add nogil support, and then the decision becomes to stick to gil, which if you suspect will happen makes you reason even harder not to support nogil.</div><br/><div id="36938767" class="c"><input type="checkbox" id="c-36938767" checked=""/><div class="controls bullet"><span class="by">doctoboggan</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36938748">parent</a><span>|</span><a href="#36938257">next</a><span>|</span><label class="collapse" for="c-36938767">[-]</label><label class="expand" for="c-36938767">[3 more]</label></div><br/><div class="children"><div class="content">I don’t really understand this. Unless I am missing something you should always pick the “no GIL” version as that will work with or without a GIL. Thread safe No GIL code would be totally fine to run on python compiled with the GIL with zero modifications.<p>Because of this I don’t expect there to be multiple versions of any library. Once a library does the (admittedly heavy) lift to no GIL it will just be the main version of that library going forward.</div><br/><div id="36938790" class="c"><input type="checkbox" id="c-36938790" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36938767">parent</a><span>|</span><a href="#36938257">next</a><span>|</span><label class="collapse" for="c-36938790">[-]</label><label class="expand" for="c-36938790">[2 more]</label></div><br/><div class="children"><div class="content">Each library maintainer (probably mostly volunteers) has to decide whether to put effort into making their code thread safe. Clearly it won&#x27;t be 100% of libraries that &quot;upgrade&quot;.<p>Then on top of that, they know their effort might be for nothing if the decision is made to keep Python GIL-only all along (one of the possible 3 outcomes at the end of the 5 years: [&quot;gil&quot;, &quot;nogil&quot;, &quot;both supported&quot;).</div><br/><div id="36938859" class="c"><input type="checkbox" id="c-36938859" checked=""/><div class="controls bullet"><span class="by">doctoboggan</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36938790">parent</a><span>|</span><a href="#36938257">next</a><span>|</span><label class="collapse" for="c-36938859">[-]</label><label class="expand" for="c-36938859">[1 more]</label></div><br/><div class="children"><div class="content">That’s true. I was more thinking from the perspective of a library user not library dev. I suspect for some classes of problem going no GIL will be so tantalizing that the work will definitely be done. Either in the incumbent library or an upstart will come out and take over the community with no GIL support.</div><br/></div></div></div></div></div></div></div></div><div id="36938257" class="c"><input type="checkbox" id="c-36938257" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36936250">parent</a><span>|</span><a href="#36938748">prev</a><span>|</span><a href="#36936144">next</a><span>|</span><label class="collapse" for="c-36938257">[-]</label><label class="expand" for="c-36938257">[2 more]</label></div><br/><div class="children"><div class="content">But at least after the transition you could stop caring. NoGIL makes maintainers’ lives worse permanently because now you have to care about it <i>forever</i> if you publish a library.</div><br/><div id="36938403" class="c"><input type="checkbox" id="c-36938403" checked=""/><div class="controls bullet"><span class="by">doctoboggan</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36938257">parent</a><span>|</span><a href="#36936144">next</a><span>|</span><label class="collapse" for="c-36938403">[-]</label><label class="expand" for="c-36938403">[1 more]</label></div><br/><div class="children"><div class="content">Why? Once you make your code thread safe it can be run as-is on python compiled with a GIL.</div><br/></div></div></div></div></div></div><div id="36936144" class="c"><input type="checkbox" id="c-36936144" checked=""/><div class="controls bullet"><span class="by">LexiMax</span><span>|</span><a href="#36935970">parent</a><span>|</span><a href="#36936250">prev</a><span>|</span><a href="#36936529">next</a><span>|</span><label class="collapse" for="c-36936144">[-]</label><label class="expand" for="c-36936144">[5 more]</label></div><br/><div class="children"><div class="content">In a past life I hacked on PHP for a living, and in the time it took Python 2 to ride off into the sunset, PHP got two major migrations under its belt in 5.2 to 5.3, and then again 5.6 to 7.0.<p>It was amazing to see the contrast between the two languages.  PHP gave you plenty of reasons to upgrade, and the amount of incompatible breaking changes was kept to a minimum, often paired with a way to easily shim older code to continue working.<p>I really hope to see no-GIL make it into Python, but in the back of my mind I also worry about what lessons were learned from the 2 to 3 transition.  Does the Python team have a more effective plan this time around?</div><br/><div id="36936246" class="c"><input type="checkbox" id="c-36936246" checked=""/><div class="controls bullet"><span class="by">charrondev</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36936144">parent</a><span>|</span><a href="#36936529">next</a><span>|</span><label class="collapse" for="c-36936246">[-]</label><label class="expand" for="c-36936246">[4 more]</label></div><br/><div class="children"><div class="content">I’ve taken an application codebase from PHP 5.3 to 8.2 now and it was relatively easy the whole way.<p>The real key to minimize the pain was writing effective integration tests with high coverage. We didn’t have a good test suite to start but once we added some utilities to easily call our various endpoints (and internal API client if you will)  and make assertions about the coverage came quickly.<p>Popular frameworks like Laravel offer such test utilities out of the box now.<p>That combined with static analysis tools like psalm make it so we can fearlessly move past major upgrades.<p>One thing I was surprised at was just how much crap PHP allowed with just a notice (not even a warning for a long time). A lot of that stuff still works (although over time some notices have progressed to warnings or errors gradually). We have our test suite convert any notices or warnings to exceptions and fail the test case.</div><br/><div id="36936990" class="c"><input type="checkbox" id="c-36936990" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36936246">parent</a><span>|</span><a href="#36936529">next</a><span>|</span><label class="collapse" for="c-36936990">[-]</label><label class="expand" for="c-36936990">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The real key to minimize the pain was writing effective integration tests with high coverage<p>I think this makes it really hard to do comparisons: I’ve done Python 2 to 3 migrations which took an hour or two because the code had tests and was well-maintained, and PHP migrations which were painful slogs without tests and sloppy code (“is this ignored error new or something we should have fixed in the 2000s?”). Most developers don’t have enough data points to say whether the experience they had was due to the language or the culture.</div><br/><div id="36937911" class="c"><input type="checkbox" id="c-36937911" checked=""/><div class="controls bullet"><span class="by">charrondev</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36936990">parent</a><span>|</span><a href="#36936529">next</a><span>|</span><label class="collapse" for="c-36937911">[-]</label><label class="expand" for="c-36937911">[2 more]</label></div><br/><div class="children"><div class="content">I’m not familiar enough with the python transition to say much. I can think of a few things that the PHP developers did that helped make the transition easier:<p>- multibyte aware string functions were implemented as a separate (and optional) extension with separately named functions (prefixed with mb) and there was a popular community polyfill from the Symfony project (and is for many new language functions).
- Weird sloppy behaviours (like performing array access on a Boolean, or trying to access a property on null, and many more than would silently just turn into null&#x2F;false) had lengthy deprecation periods and if you had error logging turned on you could clean these up relatively easily even without a big test suite.</div><br/><div id="36937933" class="c"><input type="checkbox" id="c-36937933" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#36935970">root</a><span>|</span><a href="#36937911">parent</a><span>|</span><a href="#36936529">next</a><span>|</span><label class="collapse" for="c-36937933">[-]</label><label class="expand" for="c-36937933">[1 more]</label></div><br/><div class="children"><div class="content">&gt; multibyte aware string functions were implemented as a separate (and optional) extension with separately named functions (prefixed with mb)<p>Python had a different take on this with some interesting psychology: you had a new string type which had to explicitly be converted (i.e. concatenating a Unicode string with a byte string causes an exception), which had a stark divide. Projects which had previously handled Unicode correctly converted almost trivially, but the projects which had been sloppy were a morass trying to figure out where Unicode was desirable and where you really needed raw bytes. Almost all of the code I saw where this was a problem didn’t handle Unicode properly but the developers _hated_ the idea of the language forcing them to fix those bugs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36936529" class="c"><input type="checkbox" id="c-36936529" checked=""/><div class="controls bullet"><span class="by">threatripper</span><span>|</span><a href="#36935970">parent</a><span>|</span><a href="#36936144">prev</a><span>|</span><a href="#36937853">next</a><span>|</span><label class="collapse" for="c-36936529">[-]</label><label class="expand" for="c-36936529">[1 more]</label></div><br/><div class="children"><div class="content">I was assuming that no-GIL will only be enabled if all imported libraries support it. That means that they are marked as no-GIL ready and otherwise the import would throw an exception. Not sure how it is implemented now but that sounded very reasonable to me. The no-GIL compatible code would start with the core libraries and then expand from that. Using legacy libraries just means that you have to revert back to GIL-mode. Any no-GIL enabled library should 100% still function in GIL-mode, so I don&#x27;t expect the Python 2-&gt;3 transition situation to repeat.</div><br/></div></div><div id="36937853" class="c"><input type="checkbox" id="c-36937853" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#36935970">parent</a><span>|</span><a href="#36936529">prev</a><span>|</span><a href="#36940065">next</a><span>|</span><label class="collapse" for="c-36937853">[-]</label><label class="expand" for="c-36937853">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  what about the enormous long-tail of abandoned extensions which still work today, etc.<p>I mean there they&#x27;re talking about keeping GIL in (and I imagine that will be the case for many many years) so those would still keep working. The fear is if some libraries just drop GIL-ful support, but there too I am hopeful for that not to be the case.</div><br/></div></div></div></div><div id="36940065" class="c"><input type="checkbox" id="c-36940065" checked=""/><div class="controls bullet"><span class="by">nico_h</span><span>|</span><a href="#36935970">prev</a><span>|</span><a href="#36935093">next</a><span>|</span><label class="collapse" for="c-36940065">[-]</label><label class="expand" for="c-36940065">[1 more]</label></div><br/><div class="children"><div class="content">The tenses in the headline and the article are very iffy.<p>It’s more like there will be work to remove the GIL that will start after a particular PEP will be approved.<p>The main reason we are still writing some stuff in java at our shop is because parallel processing sucks with multiprocessing, and trivial in java.<p>I look forward to a future where it as trivial in or even simpler in python.</div><br/></div></div><div id="36935093" class="c"><input type="checkbox" id="c-36935093" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36940065">prev</a><span>|</span><a href="#36936660">next</a><span>|</span><label class="collapse" for="c-36935093">[-]</label><label class="expand" for="c-36935093">[2 more]</label></div><br/><div class="children"><div class="content">Summary:<p>- Python without the GIL, for good<p>- LPython: a new Python Compiler<p>- Pydantic 2 is getting usable<p>- PEP 387 defines &quot;Soft Deprecation&quot;, getopt and optparse soft deprecated<p>- Cython 3.0 released with better pure Python support<p>- PEP 722 – Dependency specification for single-file scripts<p>- Python VSCode support gets faster<p>- Paint in the terminal</div><br/><div id="36938263" class="c"><input type="checkbox" id="c-36938263" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#36935093">parent</a><span>|</span><a href="#36936660">next</a><span>|</span><label class="collapse" for="c-36938263">[-]</label><label class="expand" for="c-36938263">[1 more]</label></div><br/><div class="children"><div class="content">great recap thanks!</div><br/></div></div></div></div><div id="36936660" class="c"><input type="checkbox" id="c-36936660" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36935093">prev</a><span>|</span><a href="#36937554">next</a><span>|</span><label class="collapse" for="c-36936660">[-]</label><label class="expand" for="c-36936660">[4 more]</label></div><br/><div class="children"><div class="content">The title says &quot;GIL removed&quot;, but the article says &quot;This means in the coming years, Python will have its GIL removed.&quot;<p>I&#x27;m assuming the article is correct and the GIL has not been removed yet (but there is a plan to remove it in the future). If that&#x27;s not the case, please correct me!</div><br/><div id="36940025" class="c"><input type="checkbox" id="c-36940025" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36936660">parent</a><span>|</span><a href="#36936725">next</a><span>|</span><label class="collapse" for="c-36940025">[-]</label><label class="expand" for="c-36940025">[1 more]</label></div><br/><div class="children"><div class="content">Yes.<p>I tried to come up with something that would convey in a few words that the GIL was going to be removed for sure this time. But as a Frenchmen, I couldn&#x27;t find better.<p>&quot;GIL will be removed&quot; was the closest, but it&#x27;s very long, and it sounds like all those times we had the promise it would be, but it never did.<p>So the Prophetic perfect tense is the best compromise: it asserts near certainty, it&#x27;s short, and worst case scenario the article remove ambiguity.<p>Plus the news popped up this week in HN front page, so a lot of people knew the context.</div><br/></div></div><div id="36936725" class="c"><input type="checkbox" id="c-36936725" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36936660">parent</a><span>|</span><a href="#36940025">prev</a><span>|</span><a href="#36938298">next</a><span>|</span><label class="collapse" for="c-36936725">[-]</label><label class="expand" for="c-36936725">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not been removed. PEP 703 has been accepted and they&#x27;ve got a path forward to no-GIL. No-GIL versions will be available as experimental versions starting with 3.13 or 3.14.<p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;</a><p><a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython&#x2F;30474" rel="nofollow noreferrer">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;a-steering-council-notice-about...</a></div><br/></div></div><div id="36938298" class="c"><input type="checkbox" id="c-36938298" checked=""/><div class="controls bullet"><span class="by">john-radio</span><span>|</span><a href="#36936660">parent</a><span>|</span><a href="#36936725">prev</a><span>|</span><a href="#36937554">next</a><span>|</span><label class="collapse" for="c-36938298">[-]</label><label class="expand" for="c-36938298">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the use of past tense in the title here is clickbaity beyond all reason.</div><br/></div></div></div></div><div id="36937554" class="c"><input type="checkbox" id="c-36937554" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#36936660">prev</a><span>|</span><a href="#36939794">next</a><span>|</span><label class="collapse" for="c-36937554">[-]</label><label class="expand" for="c-36937554">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  tools like pip-run already support running a script for which you have the deps described with such comments<p>&gt; Packages are installed in a temporary virtual env and deleted after the run, like npx used to do for the JS world.<p>Is it efficient? Download packages, install them only to delete several seconds later. Wastes precious SSD cells.</div><br/><div id="36937650" class="c"><input type="checkbox" id="c-36937650" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36937554">parent</a><span>|</span><a href="#36939794">next</a><span>|</span><label class="collapse" for="c-36937650">[-]</label><label class="expand" for="c-36937650">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a massive amount of developers who unfortunately either don&#x27;t know or don&#x27;t care about efficiency. They&#x27;ll blindly run commands with huge resource consumption with no second thought (or even an idea that such a thing is happening.)<p>It wasn&#x27;t long ago that a developer I was working with seemed to have entirely not comprehended the idea when I asked why he was searching for and downloading a dozen-MB PDF just to open (i.e. delete when closed) every time he wanted to look up one thing in it! I accumulate documentation for a project and keep most of it open throughout; I thought that was a usual thing to do, but apparently others will go online to search for that information every single time, then close the browser and reopen it whenver they need to look up something else.<p>More publicly, it&#x27;s also not long ago that Docker, and more relevantly, PyPI, have been getting worried about their bandwidth usage: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24262757">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24262757</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27205586">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27205586</a></div><br/></div></div></div></div><div id="36939794" class="c"><input type="checkbox" id="c-36939794" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#36937554">prev</a><span>|</span><a href="#36939774">next</a><span>|</span><label class="collapse" for="c-36939794">[-]</label><label class="expand" for="c-36939794">[1 more]</label></div><br/><div class="children"><div class="content">For the record, I have found that on LPython&#x27;s homepage, there is a pretty complete list of all &quot;compilers&quot; for Python. Really interesting list.</div><br/></div></div><div id="36939774" class="c"><input type="checkbox" id="c-36939774" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#36939794">prev</a><span>|</span><a href="#36936234">next</a><span>|</span><label class="collapse" for="c-36939774">[-]</label><label class="expand" for="c-36939774">[1 more]</label></div><br/><div class="children"><div class="content">Is LPython comparable to Nuitka ?</div><br/></div></div><div id="36936234" class="c"><input type="checkbox" id="c-36936234" checked=""/><div class="controls bullet"><span class="by">cvnmalk</span><span>|</span><a href="#36939774">prev</a><span>|</span><a href="#36935750">next</a><span>|</span><label class="collapse" for="c-36936234">[-]</label><label class="expand" for="c-36936234">[5 more]</label></div><br/><div class="children"><div class="content">Which, except for optparse, was all on the front page yesterday. So optparse is deprecated. More work I guess apart from auditing extensions for threading.<p>Life is great in the Python treadmill.</div><br/><div id="36937010" class="c"><input type="checkbox" id="c-36937010" checked=""/><div class="controls bullet"><span class="by">maxnoe</span><span>|</span><a href="#36936234">parent</a><span>|</span><a href="#36937308">next</a><span>|</span><label class="collapse" for="c-36937010">[-]</label><label class="expand" for="c-36937010">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, optparse was going to be be removed in 3.5(?) but outcry was large .<p>It has a depreciation warning in the docs since 3.2.<p>It was in the &quot;please just use argparse instead&quot; state for a long time, this &quot;just&quot; adds an actual code warning.</div><br/></div></div><div id="36937308" class="c"><input type="checkbox" id="c-36937308" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#36936234">parent</a><span>|</span><a href="#36937010">prev</a><span>|</span><a href="#36935750">next</a><span>|</span><label class="collapse" for="c-36937308">[-]</label><label class="expand" for="c-36937308">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried to love argparse but it is so complicated. I always have to read the docs each time I use it.<p>getopt has its own brutal simplicity.</div><br/><div id="36940154" class="c"><input type="checkbox" id="c-36940154" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36936234">root</a><span>|</span><a href="#36937308">parent</a><span>|</span><a href="#36939597">next</a><span>|</span><label class="collapse" for="c-36940154">[-]</label><label class="expand" for="c-36940154">[1 more]</label></div><br/><div class="children"><div class="content">I think argparse works fine. What worries me is that it&#x27;s also &quot;soft-deprecated&quot;, because devs have said it should get no further development. I hope it stays around, because I use it by default as a no-dependencies solution that I know how it works.</div><br/></div></div><div id="36939597" class="c"><input type="checkbox" id="c-36939597" checked=""/><div class="controls bullet"><span class="by">moonshinefe</span><span>|</span><a href="#36936234">root</a><span>|</span><a href="#36937308">parent</a><span>|</span><a href="#36940154">prev</a><span>|</span><a href="#36935750">next</a><span>|</span><label class="collapse" for="c-36939597">[-]</label><label class="expand" for="c-36939597">[1 more]</label></div><br/><div class="children"><div class="content">If you aren&#x27;t averse to using a third party package, on my personal projects I always found <a href="https:&#x2F;&#x2F;github.com&#x2F;docopt&#x2F;docopt">https:&#x2F;&#x2F;github.com&#x2F;docopt&#x2F;docopt</a> to be nice.<p>You can kill 2 birds with one stone by documenting your scripts while also providing the argument structure &#x2F; parsing.</div><br/></div></div></div></div></div></div><div id="36935750" class="c"><input type="checkbox" id="c-36935750" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36936234">prev</a><span>|</span><a href="#36938521">next</a><span>|</span><label class="collapse" for="c-36935750">[-]</label><label class="expand" for="c-36935750">[36 more]</label></div><br/><div class="children"><div class="content">From reading the thread on HN the other day, it sounds like removing the GIL isn&#x27;t really of much value. Maybe for somewhat obscure multithreading cases.<p>Is that right?</div><br/><div id="36935861" class="c"><input type="checkbox" id="c-36935861" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935958">next</a><span>|</span><label class="collapse" for="c-36935861">[-]</label><label class="expand" for="c-36935861">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe for somewhat obscure multithreading cases.<p>They&#x27;re only &quot;somewhat obscure&quot; because currently you can&#x27;t do it at all, so you don&#x27;t do it and you do something else: it&#x27;s of value for any case where you&#x27;re multithreading for computational parallelism (as opposed to IO concurrency). The PEP also outlines a bunch of other situations where using process-based parallelism is problematic: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#motivation" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#motivation</a><p>With the proviso that while it will work for all pure-python code out of the box[0] loading any <i>native</i> package which has not opted into &quot;no gil&quot; mode will re-enable the GIL: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#py-mod-gil-slot" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#py-mod-gil-slot</a><p>[0] modulo new race conditions where the code relied on the GIL for correctness, something which isn&#x27;t <i>strictly</i> correct and can already break when the scheduler logic changes</div><br/></div></div><div id="36935958" class="c"><input type="checkbox" id="c-36935958" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935861">prev</a><span>|</span><a href="#36935803">next</a><span>|</span><label class="collapse" for="c-36935958">[-]</label><label class="expand" for="c-36935958">[5 more]</label></div><br/><div class="children"><div class="content">That discussion was amusing. Removing the GIL opens up the possibility of actually getting a real performance benefit from multithreaded Python code. That&#x27;s the value. Given every modern desktop and server is multicore (and increasingly getting to tens of cores if not hundreds), multithreading in Python unhampered by the GIL will be a useful thing. And no, multiprocessing is not a good alternative to multithreading. It&#x27;s just an alternative, but it&#x27;s slower, uses more memory, and coordination between processes is slower than between threads.</div><br/><div id="36937854" class="c"><input type="checkbox" id="c-36937854" checked=""/><div class="controls bullet"><span class="by">amomchilov</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36935958">parent</a><span>|</span><a href="#36938358">next</a><span>|</span><label class="collapse" for="c-36937854">[-]</label><label class="expand" for="c-36937854">[1 more]</label></div><br/><div class="children"><div class="content">Heck, even my watch is dual-core.<p>Now i doubt I’ll be writing Python for it any time soon, but to call multithreading obscure is… really odd.</div><br/></div></div><div id="36938358" class="c"><input type="checkbox" id="c-36938358" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36935958">parent</a><span>|</span><a href="#36937854">prev</a><span>|</span><a href="#36935803">next</a><span>|</span><label class="collapse" for="c-36938358">[-]</label><label class="expand" for="c-36938358">[3 more]</label></div><br/><div class="children"><div class="content">Python is not a language for writing fast code. Python is a relaxed language for things that don’t have to be fast. If you need something to be fast you are supposed to use a C extension and <i>control</i> it with Python - that’s been the dogma for as long as I can remember to avoid exactly this kind of pathological race to performance in a language that was never designed for it.<p>By using Python you are already leaving a ton of performance on the table in single-threaded code compared to a fast, compiled language.</div><br/><div id="36939968" class="c"><input type="checkbox" id="c-36939968" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36938358">parent</a><span>|</span><a href="#36939858">prev</a><span>|</span><a href="#36935803">next</a><span>|</span><label class="collapse" for="c-36939968">[-]</label><label class="expand" for="c-36939968">[1 more]</label></div><br/><div class="children"><div class="content">Yup. I don&#x27;t know why you would insist on having multiple Python threads, especially given the high risks. Python is only suitable for coordinating&#x2F;scripting large libraries written in other languages or for quick and easy development. Python programs should not reach the stage where their use in production is hampered by lack of multi-threading.</div><br/></div></div></div></div></div></div><div id="36935803" class="c"><input type="checkbox" id="c-36935803" checked=""/><div class="controls bullet"><span class="by">FartyMcFarter</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935958">prev</a><span>|</span><a href="#36935817">next</a><span>|</span><label class="collapse" for="c-36935803">[-]</label><label class="expand" for="c-36935803">[1 more]</label></div><br/><div class="children"><div class="content">I would disagree with that.<p>The GIL means you can&#x27;t use Python multithreading in order to take advantage of more CPU time by parallelism. Obviously getting rid of the GIL makes that a real option, just as it is in other languages.</div><br/></div></div><div id="36935817" class="c"><input type="checkbox" id="c-36935817" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935803">prev</a><span>|</span><a href="#36935819">next</a><span>|</span><label class="collapse" for="c-36935817">[-]</label><label class="expand" for="c-36935817">[1 more]</label></div><br/><div class="children"><div class="content">Currently, yes that&#x27;s kind of true. But it&#x27;s really only considered obscure because the GIL makes it so you either have to do some weird non thread pattern or go with a different language, and people often go with a different language.<p>Kind of a Catch-22 of &quot;Well no one uses it that way, so why should we make it possible to use it that way? Well, no one uses it that way because it&#x27;s impossible to use it that way&quot;</div><br/></div></div><div id="36935819" class="c"><input type="checkbox" id="c-36935819" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935817">prev</a><span>|</span><a href="#36935980">next</a><span>|</span><label class="collapse" for="c-36935819">[-]</label><label class="expand" for="c-36935819">[10 more]</label></div><br/><div class="children"><div class="content">Well Python doesn&#x27;t really do proper multi-threading currently thanks to GIL blocking any additional execution threads. So removing it would enable making Python code that is actually multi-threaded without resorting to extra processes and their overhead.<p>So if you are writing small single process Python script then removing GIL shouldn&#x27;t really change much. If you are doing some heavier computing or eg. running server back-end, then there are significant performance gains available with this change.</div><br/><div id="36935840" class="c"><input type="checkbox" id="c-36935840" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36935819">parent</a><span>|</span><a href="#36935980">next</a><span>|</span><label class="collapse" for="c-36935840">[-]</label><label class="expand" for="c-36935840">[9 more]</label></div><br/><div class="children"><div class="content">You don’t have to use separate processes to get the benefit of multithreading in Python today — you can also call into a library written in native code that drops the GIL (e.g. Numpy or Pytorch).</div><br/><div id="36935886" class="c"><input type="checkbox" id="c-36935886" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36935840">parent</a><span>|</span><a href="#36936241">next</a><span>|</span><label class="collapse" for="c-36935886">[-]</label><label class="expand" for="c-36935886">[7 more]</label></div><br/><div class="children"><div class="content">Even then the GIL can cause issues, concerns of PyTorch are specifically one of the motivations of the PEP, and one of the reasons Meta &#x2F; FB really really wants this:<p>&gt; In PyTorch, Python is commonly used to orchestrate ~8 GPUs and ~64 CPU threads, growing to 4k GPUs and 32k CPU threads for big models. While the heavy lifting is done outside of Python, the speed of GPUs makes even just the orchestration in Python not scalable. We often end up with 72 processes in place of one because of the GIL. Logging, debugging, and performance tuning are orders-of-magnitude more difficult in this regime, continuously causing lower developer productivity.</div><br/><div id="36936075" class="c"><input type="checkbox" id="c-36936075" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36935886">parent</a><span>|</span><a href="#36936241">next</a><span>|</span><label class="collapse" for="c-36936075">[-]</label><label class="expand" for="c-36936075">[6 more]</label></div><br/><div class="children"><div class="content">I feel like orchestrating thousands of GPUs is such a niche use case that it’s fair to expect the people wanting to do it to learn a more suited language, rather than ruining Python for everyone else.</div><br/><div id="36939990" class="c"><input type="checkbox" id="c-36939990" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936075">parent</a><span>|</span><a href="#36937264">next</a><span>|</span><label class="collapse" for="c-36939990">[-]</label><label class="expand" for="c-36939990">[1 more]</label></div><br/><div class="children"><div class="content">You are completely right. Why don&#x27;t they write their stuff in another language? They&#x27;ve got the resources. Now the rest of the world will suffer the consequences, one of which may be that the devs of native libs will simply abandon the work, or that those libs will become too difficult to use for the casual or starting programmer, completely defeating the purpose.<p>I&#x27;m fine with two builds, but not a single non-GIL build.</div><br/></div></div><div id="36937264" class="c"><input type="checkbox" id="c-36937264" checked=""/><div class="controls bullet"><span class="by">ctoth</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936075">parent</a><span>|</span><a href="#36939990">prev</a><span>|</span><a href="#36936538">next</a><span>|</span><label class="collapse" for="c-36937264">[-]</label><label class="expand" for="c-36937264">[3 more]</label></div><br/><div class="children"><div class="content">I notice you used the strong emotional word &quot;ruining&quot; when talking about the effect on Python of this change.
Why do you believe an obscure runtime concurrency detail which will make more things possible will &quot;ruin&quot; the language?<p>Now match and :=? Those definitely ruin the language. ;-)<p>But seriously, relax, nothing bad is happening here. It&#x27;s not just people who have to use the torch launcher who have been bitten by Python&#x27;s currently-terrible multicore story. I&#x27;ve been a Python programmer for 15 years and I think this is a wonderful change.</div><br/><div id="36937618" class="c"><input type="checkbox" id="c-36937618" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36937264">parent</a><span>|</span><a href="#36936538">next</a><span>|</span><label class="collapse" for="c-36937618">[-]</label><label class="expand" for="c-36937618">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why do you believe an obscure runtime concurrency detail<p>It is not obscure. It will make it much more difficult to write native-code extensions which is IMO the whole point of Python.</div><br/><div id="36939175" class="c"><input type="checkbox" id="c-36939175" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36937618">parent</a><span>|</span><a href="#36936538">next</a><span>|</span><label class="collapse" for="c-36939175">[-]</label><label class="expand" for="c-36939175">[1 more]</label></div><br/><div class="children"><div class="content">The point of Python in your opinion is to write non-Python code?</div><br/></div></div></div></div></div></div><div id="36936538" class="c"><input type="checkbox" id="c-36936538" checked=""/><div class="controls bullet"><span class="by">sidlls</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936075">parent</a><span>|</span><a href="#36937264">prev</a><span>|</span><a href="#36936241">next</a><span>|</span><label class="collapse" for="c-36936538">[-]</label><label class="expand" for="c-36936538">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s (likely) much less expensive (in many ways, not just financially) to employ a larger number of python programmers than a smaller number of them skilled in a language more appropriate for the use case. Engineer flexibility, salary costs, maintenance&#x2F;correctness concerns with implications for development time, etc., are all factors here. The technical choice of &quot;python or not python&quot; is rarely the only--or even most important--choice to make.</div><br/></div></div></div></div></div></div><div id="36936241" class="c"><input type="checkbox" id="c-36936241" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36935840">parent</a><span>|</span><a href="#36935886">prev</a><span>|</span><a href="#36935980">next</a><span>|</span><label class="collapse" for="c-36936241">[-]</label><label class="expand" for="c-36936241">[1 more]</label></div><br/><div class="children"><div class="content">That only works in some cases, if the boundary between Python and native code is absolute. In many cases users want to extend&#x2F;configure the behavior of that native code, e.g. through callbacks or subclassing, and the GIL makes the behavior prohibitively slow (needing to lock&#x2F;unlock to serialize at any of these potential Python&lt;-&gt;native boundaries) or unsafe (deadlocks&#x2F;corruption if the GIL isn&#x27;t handled).<p>There&#x27;s a lot of C++ code bound in python (e.g. via pybind11) where the GIL currently imposes a hard bound on how users can employ parallelism, even in &quot;nominally&quot; native code.</div><br/></div></div></div></div></div></div><div id="36935980" class="c"><input type="checkbox" id="c-36935980" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935819">prev</a><span>|</span><a href="#36936104">next</a><span>|</span><label class="collapse" for="c-36935980">[-]</label><label class="expand" for="c-36935980">[1 more]</label></div><br/><div class="children"><div class="content">That was the opinion of a handful of vocal posters. The overhead of using multiprocessing and&#x2F;or some network service is extremely high for a lot of applications.</div><br/></div></div><div id="36936104" class="c"><input type="checkbox" id="c-36936104" checked=""/><div class="controls bullet"><span class="by">csmpltn</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36935980">prev</a><span>|</span><a href="#36937294">next</a><span>|</span><label class="collapse" for="c-36936104">[-]</label><label class="expand" for="c-36936104">[10 more]</label></div><br/><div class="children"><div class="content">There are plenty of other Python VMs that don&#x27;t have a GIL and can be used already today, out of the box (examples include Jython and IronPython). Despite that fact - CPython remains the most popular Python VM out there (it utilizes a GIL).<p>Instead of waiting for the GIL to be removed out of CPython - take your fancy Python code and just run it using a different VM. It&#x27;s literally as simple as that.<p>If the GIL was such a bottleneck as people make it out to be - people would move off of CPython a long time ago. But they won&#x27;t, despite having the options. This only serves to prove that 95%+ of the workflows people build with Python can be satisfied regardless of GIL, often using some of the other parallelism mechanisms available in Python today (multiprocessing, asyncio, etc).<p>Most of the stuff people build with Python are CRUD apps, Jupyter notebooks, automations, tinkering, small hacks, etc. If you&#x27;re okay with not utilizing all of your 64k CPUs at home - Python&#x27;s multiprocessing and asyncio libraries should serve you just fine.<p>The whole GIL&#x2F;No-GIL conversation is a complete waste of time and a distraction. People have all the options they need already here and now - but slinging crap at eachother over an issue tracker is so much fun that people can&#x27;t help it.</div><br/><div id="36936215" class="c"><input type="checkbox" id="c-36936215" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936104">parent</a><span>|</span><a href="#36936217">next</a><span>|</span><label class="collapse" for="c-36936215">[-]</label><label class="expand" for="c-36936215">[3 more]</label></div><br/><div class="children"><div class="content">People stay on CPython due to the performance of C extensions and the vast ecosystem based on them. The fact that people have stuck with CPython isn&#x27;t at all evidence that they like the GIL or that it doesn&#x27;t lead to significant technical problems.<p>Besides the C extension issue, Jython is based on Python 2.7 and IronPython appears to be on 3.4. These aren&#x27;t serious alternatives.</div><br/><div id="36939552" class="c"><input type="checkbox" id="c-36939552" checked=""/><div class="controls bullet"><span class="by">sideeffffect</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936215">parent</a><span>|</span><a href="#36936217">next</a><span>|</span><label class="collapse" for="c-36939552">[-]</label><label class="expand" for="c-36939552">[2 more]</label></div><br/><div class="children"><div class="content">Not true. They&#x27;re is GraalPython, which is for Python 3 and supports also native code extensions.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython</a></div><br/><div id="36939854" class="c"><input type="checkbox" id="c-36939854" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36939552">parent</a><span>|</span><a href="#36936217">next</a><span>|</span><label class="collapse" for="c-36939854">[-]</label><label class="expand" for="c-36939854">[1 more]</label></div><br/><div class="children"><div class="content">What is not true? I don’t see what this is supposed to address in my post. I cited Jython and IronPython because that’s what the person I was responding to mentioned.<p>GraalPy looks neat, but is experimental&#x2F;young still. Notably, it has a GIL specifically to be compatible with CPython.</div><br/></div></div></div></div></div></div><div id="36936217" class="c"><input type="checkbox" id="c-36936217" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936104">parent</a><span>|</span><a href="#36936215">prev</a><span>|</span><a href="#36936170">next</a><span>|</span><label class="collapse" for="c-36936217">[-]</label><label class="expand" for="c-36936217">[5 more]</label></div><br/><div class="children"><div class="content">Would a large codebase seemlessly run on another interpreter?</div><br/><div id="36940029" class="c"><input type="checkbox" id="c-36940029" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936217">parent</a><span>|</span><a href="#36936804">next</a><span>|</span><label class="collapse" for="c-36940029">[-]</label><label class="expand" for="c-36940029">[1 more]</label></div><br/><div class="children"><div class="content">I think you underestimate the problems that will occur in a large code base when the GIL is gone. It&#x27;ll play out like this:<p>Test will be fine, but production will have some weird bugs. Nobody understands it. The devs end up adding locks everywhere, bringing down performance, or creating dead locks. In the end, they migrate back to Python 3.16.<p>Here&#x27;s free lesson number 1: start adding stress tests now.</div><br/></div></div><div id="36936804" class="c"><input type="checkbox" id="c-36936804" checked=""/><div class="controls bullet"><span class="by">bafe</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936217">parent</a><span>|</span><a href="#36940029">prev</a><span>|</span><a href="#36936170">next</a><span>|</span><label class="collapse" for="c-36936804">[-]</label><label class="expand" for="c-36936804">[3 more]</label></div><br/><div class="children"><div class="content">Not likely, particularly if you depend on modules written (partly) in C like numpy&#x2F;scipy etc</div><br/><div id="36936869" class="c"><input type="checkbox" id="c-36936869" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936804">parent</a><span>|</span><a href="#36936170">next</a><span>|</span><label class="collapse" for="c-36936869">[-]</label><label class="expand" for="c-36936869">[2 more]</label></div><br/><div class="children"><div class="content">I just did some searching around PyPy and that seems to be the case. IronPython is out of support now but the looks of it. Which is a shame. I heard of it 10 years ago, but assumed it was some &quot;Microsoftized Python&quot; and not at all a compatible thing :-)</div><br/><div id="36937141" class="c"><input type="checkbox" id="c-36937141" checked=""/><div class="controls bullet"><span class="by">bafe</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936869">parent</a><span>|</span><a href="#36936170">next</a><span>|</span><label class="collapse" for="c-36937141">[-]</label><label class="expand" for="c-36937141">[1 more]</label></div><br/><div class="children"><div class="content">The same happened to jython which is all but dead and stuck forever at python 2.7<p>If you stick to &quot;pure Python&quot; there&#x27;s a larger chance you can use any python runtime and be able to run your code</div><br/></div></div></div></div></div></div></div></div><div id="36936170" class="c"><input type="checkbox" id="c-36936170" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36936104">parent</a><span>|</span><a href="#36936217">prev</a><span>|</span><a href="#36937294">next</a><span>|</span><label class="collapse" for="c-36936170">[-]</label><label class="expand" for="c-36936170">[1 more]</label></div><br/><div class="children"><div class="content">If you have a lot of code, there’s plenty of Internet drama to be had in moving to another runtime, too.</div><br/></div></div></div></div><div id="36937294" class="c"><input type="checkbox" id="c-36937294" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36936104">prev</a><span>|</span><a href="#36937341">next</a><span>|</span><label class="collapse" for="c-36937294">[-]</label><label class="expand" for="c-36937294">[3 more]</label></div><br/><div class="children"><div class="content">Correct, it will help with CPU-limited, embarrassingly parallelizable problems... which are much less common than you think.</div><br/><div id="36937685" class="c"><input type="checkbox" id="c-36937685" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36937294">parent</a><span>|</span><a href="#36939299">next</a><span>|</span><label class="collapse" for="c-36937685">[-]</label><label class="expand" for="c-36937685">[1 more]</label></div><br/><div class="children"><div class="content">Embarrassingly parallelizable problems are <i>extremely</i> common in my life.  I end up breaking out of python to use gnu-parallel, which is fine but annoying.</div><br/></div></div><div id="36939299" class="c"><input type="checkbox" id="c-36939299" checked=""/><div class="controls bullet"><span class="by">Nursie</span><span>|</span><a href="#36935750">root</a><span>|</span><a href="#36937294">parent</a><span>|</span><a href="#36937685">prev</a><span>|</span><a href="#36937341">next</a><span>|</span><label class="collapse" for="c-36939299">[-]</label><label class="expand" for="c-36939299">[1 more]</label></div><br/><div class="children"><div class="content">You don’t need embarrassingly parallel problems, you just need code doing lots of the same thing at the same time for this to be a win.</div><br/></div></div></div></div><div id="36937341" class="c"><input type="checkbox" id="c-36937341" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36937294">prev</a><span>|</span><a href="#36936631">next</a><span>|</span><label class="collapse" for="c-36937341">[-]</label><label class="expand" for="c-36937341">[1 more]</label></div><br/><div class="children"><div class="content">The big thing that is driving no GIL is the speed up of processing data for ML, which afaik cannot be done with multiprocessing.</div><br/></div></div><div id="36936151" class="c"><input type="checkbox" id="c-36936151" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36935750">parent</a><span>|</span><a href="#36936631">prev</a><span>|</span><a href="#36938521">next</a><span>|</span><label class="collapse" for="c-36936151">[-]</label><label class="expand" for="c-36936151">[1 more]</label></div><br/><div class="children"><div class="content">Right now multi-threading makes your Python code (that isn&#x27;t really C) slower. The only real use of it is time slicing so you don&#x27;t starve more important code like the web server or UI thread. You still have all the concurrency issues because your threads can still still be paused and resumed at arbitrary times. It does allow some operations in Python to be atomic but I, maybe naively, assume that those cases will be guarded by new, not whole interpreter, locks.<p>With no-gil your multithreading code can, with no change to your code, take advantage of multiple cores and actually speed up your program. If</div><br/></div></div></div></div><div id="36938521" class="c"><input type="checkbox" id="c-36938521" checked=""/><div class="controls bullet"><span class="by">Whoopee7177</span><span>|</span><a href="#36935750">prev</a><span>|</span><a href="#36936204">next</a><span>|</span><label class="collapse" for="c-36938521">[-]</label><label class="expand" for="c-36938521">[9 more]</label></div><br/><div class="children"><div class="content">Why has the Python community not removed the GIL when migrating from Python 2 to Python 3?</div><br/><div id="36938542" class="c"><input type="checkbox" id="c-36938542" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#36938521">parent</a><span>|</span><a href="#36939721">next</a><span>|</span><label class="collapse" for="c-36938542">[-]</label><label class="expand" for="c-36938542">[6 more]</label></div><br/><div class="children"><div class="content">Because at the time of the 2-3 migration, parallelism wasn’t viewed as being as important as it is today.</div><br/><div id="36938614" class="c"><input type="checkbox" id="c-36938614" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#36938521">root</a><span>|</span><a href="#36938542">parent</a><span>|</span><a href="#36939721">next</a><span>|</span><label class="collapse" for="c-36938614">[-]</label><label class="expand" for="c-36938614">[5 more]</label></div><br/><div class="children"><div class="content">Is that really true? We already had multicore machines, and Herb Sutter&#x27;s &quot;The free lunch is over&quot; article had been published for years by then.</div><br/><div id="36940144" class="c"><input type="checkbox" id="c-36940144" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36938521">root</a><span>|</span><a href="#36938614">parent</a><span>|</span><a href="#36938882">next</a><span>|</span><label class="collapse" for="c-36940144">[-]</label><label class="expand" for="c-36940144">[1 more]</label></div><br/><div class="children"><div class="content">Python is used much more widely and for more data tasks now than it was then, I think. Besides, we&#x27;ve all slowly adapted to using parallelism everywhere, it was not overnight.</div><br/></div></div><div id="36938882" class="c"><input type="checkbox" id="c-36938882" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#36938521">root</a><span>|</span><a href="#36938614">parent</a><span>|</span><a href="#36940144">prev</a><span>|</span><a href="#36940017">next</a><span>|</span><label class="collapse" for="c-36938882">[-]</label><label class="expand" for="c-36938882">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is that really true?<p>For Python by Guido (this was still in the BDfL era)? Yes. For scripting languages generally? Also yes. For computing as a whole? While parallelism was more important than in either of the preceding contexts, it was still far less important than today, so, again, yes.<p>&gt; We already had multicore machines, and Herb Sutter&#x27;s &quot;The free lunch is over&quot; article had been published for years by then.<p>Barely, unless you are talking about multi-CPU SMP machines (which existed for PCs back to the 386 era); the first multicore x86 processors were released in May 2005 (And Sutter’s article was in March) about a year before the major decisions about Python 3.0 (published April 2006.)</div><br/></div></div><div id="36940017" class="c"><input type="checkbox" id="c-36940017" checked=""/><div class="controls bullet"><span class="by">Jiocus</span><span>|</span><a href="#36938521">root</a><span>|</span><a href="#36938614">parent</a><span>|</span><a href="#36938882">prev</a><span>|</span><a href="#36938836">next</a><span>|</span><label class="collapse" for="c-36940017">[-]</label><label class="expand" for="c-36940017">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure parallelism was understood and worked towards in computing at large and within certain programming languages. The then contemporary and popular use-cases for Python (which were they?) might have had very different challenges solved by other means.<p>(I&#x27;m just guessing here)</div><br/></div></div><div id="36938836" class="c"><input type="checkbox" id="c-36938836" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36938521">root</a><span>|</span><a href="#36938614">parent</a><span>|</span><a href="#36940017">prev</a><span>|</span><a href="#36939721">next</a><span>|</span><label class="collapse" for="c-36938836">[-]</label><label class="expand" for="c-36938836">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Herb Sutter&#x27;s &quot;The free lunch is over&quot; article had been published for years by then.<p>Python 3.0 was released in 2008 with the work starting in early 2006 (maybe earlier, going by PEP 3000 which was published in April 2006). Herb Sutter&#x27;s &quot;The Free Lunch is Over&quot; was first published in 2005. I don&#x27;t think a year between its publishing and the work on Python 3 beginning qualifies as &quot;years&quot;.</div><br/></div></div></div></div></div></div><div id="36939721" class="c"><input type="checkbox" id="c-36939721" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#36938521">parent</a><span>|</span><a href="#36938542">prev</a><span>|</span><a href="#36936204">next</a><span>|</span><label class="collapse" for="c-36939721">[-]</label><label class="expand" for="c-36939721">[2 more]</label></div><br/><div class="children"><div class="content">The guy who was smart enough&#x2F;motivated to do it showed up only a couple of years ago.</div><br/><div id="36939841" class="c"><input type="checkbox" id="c-36939841" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36938521">root</a><span>|</span><a href="#36939721">parent</a><span>|</span><a href="#36936204">next</a><span>|</span><label class="collapse" for="c-36939841">[-]</label><label class="expand" for="c-36939841">[1 more]</label></div><br/><div class="children"><div class="content">That guy shows up every couple of years, almost like a prophecy<p><a href="https:&#x2F;&#x2F;github.com&#x2F;larryhastings&#x2F;gilectomy">https:&#x2F;&#x2F;github.com&#x2F;larryhastings&#x2F;gilectomy</a></div><br/></div></div></div></div></div></div><div id="36936204" class="c"><input type="checkbox" id="c-36936204" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#36938521">prev</a><span>|</span><a href="#36935989">next</a><span>|</span><label class="collapse" for="c-36936204">[-]</label><label class="expand" for="c-36936204">[1 more]</label></div><br/><div class="children"><div class="content">And alternative C APIs are being proposed, which is as exciting as all of the above</div><br/></div></div><div id="36935989" class="c"><input type="checkbox" id="c-36935989" checked=""/><div class="controls bullet"><span class="by">devwastaken</span><span>|</span><a href="#36936204">prev</a><span>|</span><a href="#36936138">next</a><span>|</span><label class="collapse" for="c-36935989">[-]</label><label class="expand" for="c-36935989">[2 more]</label></div><br/><div class="children"><div class="content">This is exactly what I have been looking forward to. Allow me to do no-gil, let me the developer make that choice. There are issues with that certainly, but I am conscious of this fact and given an analysis of no-gil benefits it is significantly more beneficial to have no-gil for certain use cases.<p>One of the most significant of these cases to me is threading outside an Operating system context. What if I want to use both of the cores to a Cortex M0? Multiprocessing can&#x27;t help me, there are no processes. If I need locking, I will impliment it using the platform I have available to me.<p>The second is the fact that CPU&#x27;s are increasingly scaling in core count. When I have to use multiprocessing the program becomes far more complex than one would expect. Why am I doing message passing and shared memory when the OS and CPU supplies better tools already? It also pollutes the process ID&#x27;s. Imagine if we built every application in Python - there would be hundreds of thousands of individual processes all to use multiple cores. Because this is a problem mostly unique to python we often end up having to build applications in other languages that otherwise would have been better in Python.<p>I want a world where I can say &quot;just use python&quot; to almost anything. Telling new coders to drop their favorite language and use any other language to get the result they want immedietely kills the innovation they are working on. Instead of spending time creating the idea, they&#x27;re spending time learning a languages I believe are unnecessary.</div><br/><div id="36937410" class="c"><input type="checkbox" id="c-36937410" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#36935989">parent</a><span>|</span><a href="#36936138">next</a><span>|</span><label class="collapse" for="c-36937410">[-]</label><label class="expand" for="c-36937410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; let me the developer make that choice.<p>The final push towards making no-GIL as the only option is the big issue here. An optional no-GIL is ok (although a waste of time), making it default is bad.<p>&gt;What if I want to use both of the cores to a Cortex M0<p>The solution to anything performant in Python is writing the C extension, just like Numpy did. Python isn&#x27;t meant to be a performant language. The GIL allows you to write code without thinking about complexities of parallelism.</div><br/></div></div></div></div><div id="36936138" class="c"><input type="checkbox" id="c-36936138" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#36935989">prev</a><span>|</span><a href="#36936090">next</a><span>|</span><label class="collapse" for="c-36936138">[-]</label><label class="expand" for="c-36936138">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s been a little too happy to hard-deprecate things for my liking, so this soft-deprecation sounds pretty good.</div><br/></div></div><div id="36936090" class="c"><input type="checkbox" id="c-36936090" checked=""/><div class="controls bullet"><span class="by">hanniabu</span><span>|</span><a href="#36936138">prev</a><span>|</span><a href="#36937707">next</a><span>|</span><label class="collapse" for="c-36936090">[-]</label><label class="expand" for="c-36936090">[10 more]</label></div><br/><div class="children"><div class="content">Will writing multithreaded code become easier? Or will the developer UX remain the same?</div><br/><div id="36936156" class="c"><input type="checkbox" id="c-36936156" checked=""/><div class="controls bullet"><span class="by">dpedu</span><span>|</span><a href="#36936090">parent</a><span>|</span><a href="#36937336">next</a><span>|</span><label class="collapse" for="c-36936156">[-]</label><label class="expand" for="c-36936156">[8 more]</label></div><br/><div class="children"><div class="content">The opposite, writing multithreaded code will get harder because you&#x27;ll likely need to handle concurrency issues yourself that the GIL previously avoided. But, the tradeoff is that multithreaded programs could now actually achieve multithreaded performance gains.</div><br/><div id="36936281" class="c"><input type="checkbox" id="c-36936281" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36936156">parent</a><span>|</span><a href="#36936276">next</a><span>|</span><label class="collapse" for="c-36936281">[-]</label><label class="expand" for="c-36936281">[6 more]</label></div><br/><div class="children"><div class="content">&gt; writing multithreaded code will get harder because you&#x27;ll likely need to handle concurrency issues yourself<p>I&#x27;d phrase this differently: Writing <i>correct</i> multithreaded code will be just as challenging (or not, depending on the person and their comfort with concurrent and parallel code development) as before, but now you won&#x27;t be able to get away with <i>sloppy</i> multithreaded code that relied on the GIL to not break.</div><br/><div id="36936428" class="c"><input type="checkbox" id="c-36936428" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36936281">parent</a><span>|</span><a href="#36937703">next</a><span>|</span><label class="collapse" for="c-36936428">[-]</label><label class="expand" for="c-36936428">[4 more]</label></div><br/><div class="children"><div class="content">It was correctly written to the invariant promises of the platform at the time. If Python is altering the deal, that does not suddenly make the library writer at fault.</div><br/><div id="36936585" class="c"><input type="checkbox" id="c-36936585" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36936428">parent</a><span>|</span><a href="#36937703">next</a><span>|</span><label class="collapse" for="c-36936585">[-]</label><label class="expand" for="c-36936585">[3 more]</label></div><br/><div class="children"><div class="content">There seems to be some confusion here. The GIL is not an invariant of Python that makes your code thread safe. Python is not altering the deal. You can still use threads to write concurrent code in Python today, and you&#x27;ll still run into all of the classic concurrency related bugs.<p>People just mostly don&#x27;t bother writing threaded code in Python today because it provides no performance benefit. That may change, and it very likely will expose many threading bugs that already exist in many libraries that just have never been found.</div><br/><div id="36937418" class="c"><input type="checkbox" id="c-36937418" checked=""/><div class="controls bullet"><span class="by">dpedu</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36936585">parent</a><span>|</span><a href="#36937703">next</a><span>|</span><label class="collapse" for="c-36937418">[-]</label><label class="expand" for="c-36937418">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, the GIL certainly doesn&#x27;t automatically make all code thread-safe. However, it does make some operations that would normally be problematic in a multithreaded context thread-safe. Such as: appending to a list, updating a dict, modifying object attributes, and others.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;faq&#x2F;library.html#what-kinds-of-global-value-mutation-are-thread-safe" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;faq&#x2F;library.html#what-kinds-of-glo...</a></div><br/><div id="36937875" class="c"><input type="checkbox" id="c-36937875" checked=""/><div class="controls bullet"><span class="by">angus_gh</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36937418">parent</a><span>|</span><a href="#36937703">next</a><span>|</span><label class="collapse" for="c-36937875">[-]</label><label class="expand" for="c-36937875">[1 more]</label></div><br/><div class="children"><div class="content">The no-gil fork of Python makes the builtin collections thread-safe, so that will remain not an issue (see the &quot;Collection thread-safety&quot; section of the design doc <a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0&#x2F;edit?usp=drivesdk" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;18CXhDb1ygxg-YXNBJNzfzZsD...</a> )</div><br/></div></div></div></div></div></div></div></div><div id="36937703" class="c"><input type="checkbox" id="c-36937703" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36936281">parent</a><span>|</span><a href="#36936428">prev</a><span>|</span><a href="#36936276">next</a><span>|</span><label class="collapse" for="c-36937703">[-]</label><label class="expand" for="c-36937703">[1 more]</label></div><br/><div class="children"><div class="content">Why do you say code relying on the GIL is incorrect? The GIL is a documented part of Python.</div><br/></div></div></div></div><div id="36936276" class="c"><input type="checkbox" id="c-36936276" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#36936090">root</a><span>|</span><a href="#36936156">parent</a><span>|</span><a href="#36936281">prev</a><span>|</span><a href="#36937336">next</a><span>|</span><label class="collapse" for="c-36936276">[-]</label><label class="expand" for="c-36936276">[1 more]</label></div><br/><div class="children"><div class="content">A single Go thread still replaces 10 Python threads, speaking very roughly. It&#x27;s a quite particular narrow set of problems noGIL would solve.</div><br/></div></div></div></div><div id="36937336" class="c"><input type="checkbox" id="c-36937336" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36936090">parent</a><span>|</span><a href="#36936156">prev</a><span>|</span><a href="#36937707">next</a><span>|</span><label class="collapse" for="c-36937336">[-]</label><label class="expand" for="c-36937336">[1 more]</label></div><br/><div class="children"><div class="content">No it will be the same level of skill and difficulty to do correct shared memory multithreaded programming.  You&#x27;ll have to manually manage locks and reason about potential for deadlock or other race conditions.<p>If anything it will be harder as the implicit serialization of the GIL being removed means libraries might suddenly develop race conditions that you&#x27;ve never experienced or seen before, likely causing spectacular crashes and undefined behavior or bugs.</div><br/></div></div></div></div><div id="36937707" class="c"><input type="checkbox" id="c-36937707" checked=""/><div class="controls bullet"><span class="by">keithalewis</span><span>|</span><a href="#36936090">prev</a><span>|</span><a href="#36938178">next</a><span>|</span><label class="collapse" for="c-36937707">[-]</label><label class="expand" for="c-36937707">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes there is no bandaid big enough to cover up a fundamental design decision in a language. Stick to solving problems it was designed for instead of crapping it up. Python isn&#x27;t the only language , unless it&#x27;s the only language you know.</div><br/></div></div></div></div></div></div></div></body></html>