<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710579650748" as="style"/><link rel="stylesheet" href="styles.css?v=1710579650748"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xeiaso.net/talks/2024/nix-docker-build/">Nix is a better Docker image builder than Docker&#x27;s image builder</a> <span class="domain">(<a href="https://xeiaso.net">xeiaso.net</a>)</span></div><div class="subtext"><span>tosh</span> | <span>156 comments</span></div><br/><div><div id="39723701" class="c"><input type="checkbox" id="c-39723701" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#39723150">next</a><span>|</span><label class="collapse" for="c-39723701">[-]</label><label class="expand" for="c-39723701">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried again and again to like Nix, but at this point I have to throw in the towel.<p>I have 2 systems running Nix, and I&#x27;m afraid to touch them. I&#x27;ve already broken both of them enough that I had to reinstall from scratch in the past (yes yes - it&#x27;s supposed to be impossible I know), and now I&#x27;ve forgotten most of it. In theory, Nix is idempotent and deterministic, but the problem is &quot;deterministic in what way?&quot; Unless you intimately understand what every dependent part is doing, you&#x27;re going to get strange results and absolutely bizarre and unhelpful errors (or far more likely: nothing at all, with no feedback). Nix feels more like alchemy than science. Like trying to get random Lisp packages to play nice together.<p>Documentation is just plain AWFUL (as in: complete and technically accurate, but maddeningly obtuse), and tutorials only get you part of the way. The moment you step off the 80% path, you&#x27;re in for a world of hurt, because the underlying components are just not built to support anything else. Sure, you can always &quot;build your own&quot;, but this requires years of experiential knowledge and layers upon layers of frustration that I just don&#x27;t want to deal with anymore (which is also why I left Gentoo all those years ago). And woe unto you if you want to use a more modern version than the distribution supports!<p>The strength of Docker is the chaos itself. You can easily build pretty much anything, without needing much more than a cursory understanding of the shell and your distro&#x27;s package manager. Or you can mix and match whatever the hell you want! When things break, it&#x27;s MUCH easier to diagnose and fix the problems because all of the tooling has been around for decades, which makes it mature enough to handle edge cases (and breakage is almost ALWAYS about edge cases).<p>Nix is more like Emacs: It can do absolutely anything if you have the patience for it and the deep, arcane knowledge to keep it from exploding in a brilliant flash of octarine. You either go full-in and drink the kool aid, or you keep it at arm&#x27;s length - smiling and nodding as you back slowly towards the door whenever an enthusiast speaks.</div><br/><div id="39724197" class="c"><input type="checkbox" id="c-39724197" checked=""/><div class="controls bullet"><span class="by">fuzzy2</span><span>|</span><a href="#39723701">parent</a><span>|</span><a href="#39723948">next</a><span>|</span><label class="collapse" for="c-39724197">[-]</label><label class="expand" for="c-39724197">[1 more]</label></div><br/><div class="children"><div class="content">It’s really not <i>that</i> bad. However, with a standard NixOS setup, you still have a tremendous amount of non-reproducible state, both inside user accounts and in the system. I’m running a “Erase your darlings” setup, it mostly gets rid of non-reproducible state outside my user account. It’s a bit of a pain, but then what isn’t on NixOS.<p><a href="https:&#x2F;&#x2F;grahamc.com&#x2F;blog&#x2F;erase-your-darlings&#x2F;" rel="nofollow">https:&#x2F;&#x2F;grahamc.com&#x2F;blog&#x2F;erase-your-darlings&#x2F;</a><p>Inside my user account, I don’t bother. I don’t like Home Manager.</div><br/></div></div><div id="39723948" class="c"><input type="checkbox" id="c-39723948" checked=""/><div class="controls bullet"><span class="by">orbital-decay</span><span>|</span><a href="#39723701">parent</a><span>|</span><a href="#39724197">prev</a><span>|</span><a href="#39723888">next</a><span>|</span><label class="collapse" for="c-39723948">[-]</label><label class="expand" for="c-39723948">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt;Documentation is just plain AWFUL (as in: complete and technically accurate, but maddeningly obtuse)</i><p>Documentation is often just plain erroneous, especially for the new CLI and flakes, not even edge cases. I remember spending some time trying to understand why nix develop doesn&#x27;t work like described and how to make it work like it should. I feel like nobody ever actually used it for its intended purpose. Turns out that by default it doesn&#x27;t just drop you into the build-time environment like the docs claim (hermetically sealed with stdenv scripts available), it&#x27;s not sealed by default and the commandline options have confusing naming, you need to fish out the knowledge from the sources to make it work. Plenty of little things like this.<p><i>&gt;In theory, Nix is idempotent and deterministic</i><p>I surely wish they talked more about edge cases that break reproducibility. Things like floating point code being sensitive to the order of operations with state potentially leaking from OS preemption, and all that. Which might be obvious, but not saying obvious things explicitly is how you get people shoot themselves in the foot.</div><br/></div></div><div id="39723888" class="c"><input type="checkbox" id="c-39723888" checked=""/><div class="controls bullet"><span class="by">janjongboom</span><span>|</span><a href="#39723701">parent</a><span>|</span><a href="#39723948">prev</a><span>|</span><a href="#39724272">next</a><span>|</span><label class="collapse" for="c-39723888">[-]</label><label class="expand" for="c-39723888">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve gone down the same path. I love deterministic builds, and I think Docker&#x27;s biggest fault is that to the average developer a Dockerfile _looks_ deterministic - and it even is for a while (build a container twice in a row on the same machine =&gt; same output), but then packages get updated in the package manager, base images get updated w&#x2F; the same tag, and when you rebuild a month later you get something completely different. Do that times 40 (the number of containers my team manages) and now fixing containers is a significant part of your job.<p>So in theory Nix would be perfect. But it&#x27;s not, because it&#x27;s so different. Get a tool from a vendor =&gt; won&#x27;t work on Nix. Get an error =&gt; impossible to quickly find a solution on the web.<p>Anyway, out of that frustration I&#x27;ve funded <a href="https:&#x2F;&#x2F;www.stablebuild.com" rel="nofollow">https:&#x2F;&#x2F;www.stablebuild.com</a>. Deterministic builds w&#x2F; Docker, but with containers built on Ubuntu, Debian or Alpine. Currently consists of an immutable Docker Hub pull-through cache, full daily copies of the Ubuntu&#x2F;Debian&#x2F;Alpine package registries, full daily copies of most popular PPAs, daily copies of the PyPI index (we do a lot of ML), and arbitrary immutable file&#x2F;URL cache.<p>So far it&#x27;s been the best of both worlds in my day job: easy to write, easy to debug, wide software compatibility, and we have seen 0 issues due to non-determinism in containers that we moved over to StableBuild in my day job.</div><br/><div id="39724278" class="c"><input type="checkbox" id="c-39724278" checked=""/><div class="controls bullet"><span class="by">keybits</span><span>|</span><a href="#39723701">root</a><span>|</span><a href="#39723888">parent</a><span>|</span><a href="#39724213">next</a><span>|</span><label class="collapse" for="c-39724278">[-]</label><label class="expand" for="c-39724278">[1 more]</label></div><br/><div class="children"><div class="content">The pricing page for StableBuild says<p>Free …<p>Number of Users 1<p>Number of Users 15GB<p>Is that a mistake or if not can you explain please?<p><a href="https:&#x2F;&#x2F;www.stablebuild.com&#x2F;pricing" rel="nofollow">https:&#x2F;&#x2F;www.stablebuild.com&#x2F;pricing</a></div><br/></div></div><div id="39724213" class="c"><input type="checkbox" id="c-39724213" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#39723701">root</a><span>|</span><a href="#39723888">parent</a><span>|</span><a href="#39724278">prev</a><span>|</span><a href="#39724216">next</a><span>|</span><label class="collapse" for="c-39724213">[-]</label><label class="expand" for="c-39724213">[1 more]</label></div><br/><div class="children"><div class="content">Just pin the dependencies and your mostly fine right?</div><br/></div></div><div id="39724216" class="c"><input type="checkbox" id="c-39724216" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39723701">root</a><span>|</span><a href="#39723888">parent</a><span>|</span><a href="#39724213">prev</a><span>|</span><a href="#39724272">next</a><span>|</span><label class="collapse" for="c-39724216">[-]</label><label class="expand" for="c-39724216">[1 more]</label></div><br/><div class="children"><div class="content">But also Nix solves more problems than Docker. For example if you need to use different versions of software for different projects. Nix lets you pick and choose the software that is visible in your current environment without having to build a new Docker image for every combination, which leads to a combinatorial explosion of images and is not practical.<p>But I also agree with all the flaws of Nix people are pointing out here.</div><br/></div></div></div></div><div id="39724272" class="c"><input type="checkbox" id="c-39724272" checked=""/><div class="controls bullet"><span class="by">laerus</span><span>|</span><a href="#39723701">parent</a><span>|</span><a href="#39723888">prev</a><span>|</span><a href="#39723941">next</a><span>|</span><label class="collapse" for="c-39724272">[-]</label><label class="expand" for="c-39724272">[1 more]</label></div><br/><div class="children"><div class="content">Give a try to Fedora Atomic (immutable). At this point I have pretty much played around and used every distro package maneger there is and I have broken all of them in one way or another even without doing something exotic (pacman I am looking at you). My Fedora Kinoite is still going strong even with adding&#x2F;removing different layers, daily updates, and a rebase from Silverblue. Imho rpm-ostree will obsolete Nix.</div><br/></div></div><div id="39724076" class="c"><input type="checkbox" id="c-39724076" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39723701">parent</a><span>|</span><a href="#39723941">prev</a><span>|</span><a href="#39723150">next</a><span>|</span><label class="collapse" for="c-39724076">[-]</label><label class="expand" for="c-39724076">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The strength of Docker is the chaos itself.<p>That depends whether you are okay with chaos.<p>It appears that you are, so it is suitable tool for you. Choose the right tool for the right job.<p>---<p>Docker is a poor choice for people who are interested in deterministic&#x2F;reproducible builds.</div><br/><div id="39724268" class="c"><input type="checkbox" id="c-39724268" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#39723701">root</a><span>|</span><a href="#39724076">parent</a><span>|</span><a href="#39723150">next</a><span>|</span><label class="collapse" for="c-39724268">[-]</label><label class="expand" for="c-39724268">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure exactly why this is being downvoted. It seems pretty fair to want your container builds to not fail because of the “chaos” with docker images and how they change quite a lot. This isn’t about the freedom to build how you want, it’s about securing your build pipelines so that they don’t break at 4am because docker only builds 99% of the time.<p>I’ll use docker, I like docker, but I can see the point of how it’s not necessarily advantageous if stability is your main goal.</div><br/></div></div></div></div></div></div><div id="39723150" class="c"><input type="checkbox" id="c-39723150" checked=""/><div class="controls bullet"><span class="by">jossephus01</span><span>|</span><a href="#39723701">prev</a><span>|</span><a href="#39721435">next</a><span>|</span><label class="collapse" for="c-39723150">[-]</label><label class="expand" for="c-39723150">[14 more]</label></div><br/><div class="children"><div class="content">My experience with building Docker images for Java applications using Nix wasn&#x27;t very pleasant though. After the deprecation of gradle2nix, there doesn&#x27;t seem to be a clear alternative method for building Docker images for Gradle-based Java applications. I challenged a friend to create the smallest possible Docker image for a simple Spring Boot application some time ago. While I was using Nix, the resulting image was twice the size of the image built without Nix. You can check out the code for yourself here: <a href="https:&#x2F;&#x2F;github.com&#x2F;jossephus&#x2F;Docker_challenge&#x2F;blob&#x2F;main&#x2F;flake.nix">https:&#x2F;&#x2F;github.com&#x2F;jossephus&#x2F;Docker_challenge&#x2F;blob&#x2F;main&#x2F;flak...</a> .</div><br/><div id="39723551" class="c"><input type="checkbox" id="c-39723551" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#39723150">parent</a><span>|</span><a href="#39723554">next</a><span>|</span><label class="collapse" for="c-39723551">[-]</label><label class="expand" for="c-39723551">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because you&#x27;re including two JDKs, zulu and the one that gradle includes via its jdk argument. Look for gradleGen in nixpkgs to see what I mean.<p>And sorry for gradle2nix, I&#x27;m working on an improvement that&#x27;s less of a hack.</div><br/><div id="39723870" class="c"><input type="checkbox" id="c-39723870" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723551">parent</a><span>|</span><a href="#39723613">next</a><span>|</span><label class="collapse" for="c-39723870">[-]</label><label class="expand" for="c-39723870">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And sorry for gradle2nix, I&#x27;m working on an improvement that&#x27;s less of a hack.<p>Don&#x27;t be. Thanks for your work. Excited to learn about the improvement. Can you tell more about what you have in mind?</div><br/></div></div><div id="39723613" class="c"><input type="checkbox" id="c-39723613" checked=""/><div class="controls bullet"><span class="by">jossephus01</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723551">parent</a><span>|</span><a href="#39723870">prev</a><span>|</span><a href="#39723554">next</a><span>|</span><label class="collapse" for="c-39723613">[-]</label><label class="expand" for="c-39723613">[1 more]</label></div><br/><div class="children"><div class="content">Thanks tadfisher, I will check it out. This is by no means meant to be a dunk on gradle2nix. Love your work on android-nixpkgs and I will be looking for the alternative. Thanks.</div><br/></div></div></div></div><div id="39723554" class="c"><input type="checkbox" id="c-39723554" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39723150">parent</a><span>|</span><a href="#39723551">prev</a><span>|</span><a href="#39724133">next</a><span>|</span><label class="collapse" for="c-39723554">[-]</label><label class="expand" for="c-39723554">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used java in over a decade so won&#x27;t be able to help much with that, but for example I was able to get my application to fit in just 70MB container including python and all dependencies + busybox and tini<p>It looked something like this: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;takeda&#x2F;17b6b645ad4758d5aaf472b84447bb7c" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;takeda&#x2F;17b6b645ad4758d5aaf472b84447b...</a><p>So what I did was:<p>- link everything with musl<p>- compile python and disable all packages that I didn&#x27;t use in my application<p>- trim boto3&#x2F;botocore, to remove all stuff I did not use, that sucker on it&#x27;s own is over 100MB<p>The thing is what you need to understand is that the packages are primarily targeting the NixOS operating system, where in normal situation you have plenty of disk space, and you rather want all features to be available (because why not?). So you end up with bunch of dependencies, that you don&#x27;t need. Alpine image for example was designed to be for docker, so the goal with all packages is to disable extra bells and whistles.<p>This is why your result is bigger.<p>To build a small image you will need to use override and disable all that unnecessary shit. Look at zulu for example:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;development&#x2F;compilers&#x2F;zulu&#x2F;common.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;developmen...</a><p>you add alsa, fontconfig (probably comes with entire X11), freetype, xorg (oh, nvm fontconfig, it&#x27;s added explicitly), cups, gtk, cairo and ffmpeg)<p>Notice how your friend carefully extracts and places only needed files in the container, while you just bundle the entire zulu package with all of its dependencies in your project.<p>Edit: tadfisher seems to be more familiar with it than me, so I would start with that advice and modify code so it  only includes a single jdk. Then things that I mentioned could cut the size of jdk further.<p>Edit2: noticed another comment from tadfisher about openjdk_headless, so things might be even simpler than I thought.</div><br/><div id="39723586" class="c"><input type="checkbox" id="c-39723586" checked=""/><div class="controls bullet"><span class="by">jossephus01</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723554">parent</a><span>|</span><a href="#39724133">next</a><span>|</span><label class="collapse" for="c-39723586">[-]</label><label class="expand" for="c-39723586">[2 more]</label></div><br/><div class="children"><div class="content">You are correct. I havent done any trimming. Thanks for the suggestions and the gist. Thanks</div><br/><div id="39723629" class="c"><input type="checkbox" id="c-39723629" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723586">parent</a><span>|</span><a href="#39724133">next</a><span>|</span><label class="collapse" for="c-39723629">[-]</label><label class="expand" for="c-39723629">[1 more]</label></div><br/><div class="children"><div class="content">I found this discussion and contains code fragments and links that might help.<p><a href="https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;how-to-create-a-docker-image-with-minimal-jdk-11-there-is-no-jre11-headless&#x2F;11849" rel="nofollow">https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;how-to-create-a-docker-image-w...</a></div><br/></div></div></div></div></div></div><div id="39724133" class="c"><input type="checkbox" id="c-39724133" checked=""/><div class="controls bullet"><span class="by">markelliot</span><span>|</span><a href="#39723150">parent</a><span>|</span><a href="#39723554">prev</a><span>|</span><a href="#39723594">next</a><span>|</span><label class="collapse" for="c-39724133">[-]</label><label class="expand" for="c-39724133">[1 more]</label></div><br/><div class="children"><div class="content">Hard to beat jib (<a href="https:&#x2F;&#x2F;github.com&#x2F;GoogleContainerTools&#x2F;jib&#x2F;tree&#x2F;master&#x2F;jib-gradle-plugin">https:&#x2F;&#x2F;github.com&#x2F;GoogleContainerTools&#x2F;jib&#x2F;tree&#x2F;master&#x2F;jib-...</a>) for minimal Java OCI containers.</div><br/></div></div><div id="39723594" class="c"><input type="checkbox" id="c-39723594" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#39723150">parent</a><span>|</span><a href="#39724133">prev</a><span>|</span><a href="#39723505">next</a><span>|</span><label class="collapse" for="c-39723594">[-]</label><label class="expand" for="c-39723594">[3 more]</label></div><br/><div class="children"><div class="content">Oh, and openjdk_headless skips the GTK and X dependencies that you won&#x27;t need for Spring.</div><br/><div id="39723684" class="c"><input type="checkbox" id="c-39723684" checked=""/><div class="controls bullet"><span class="by">okr</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723594">parent</a><span>|</span><a href="#39723505">next</a><span>|</span><label class="collapse" for="c-39723684">[-]</label><label class="expand" for="c-39723684">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting. We have some applications, that produce PDFs, which use fonts, which usually requires a non-headless (headfull?) jdk. At AWS i wonder, what the default alpine jdk contains. And how much space could be saved, if people were more aware, that they can use a headless one.</div><br/><div id="39724256" class="c"><input type="checkbox" id="c-39724256" checked=""/><div class="controls bullet"><span class="by">hawk_</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723684">parent</a><span>|</span><a href="#39723505">next</a><span>|</span><label class="collapse" for="c-39724256">[-]</label><label class="expand" for="c-39724256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; headfull?<p>Wonder if there is a good term for this. I have been jokingly referring to this as &#x27;headed&#x27; and headless as &#x27;beheaded&#x27;.</div><br/></div></div></div></div></div></div><div id="39723505" class="c"><input type="checkbox" id="c-39723505" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39723150">parent</a><span>|</span><a href="#39723594">prev</a><span>|</span><a href="#39723568">next</a><span>|</span><label class="collapse" for="c-39723505">[-]</label><label class="expand" for="c-39723505">[2 more]</label></div><br/><div class="children"><div class="content">&gt; While I was using Nix, the resulting image was twice the size of the image built without Nix.<p>I would be very interested to know where the difference is; is nix including things it doesn&#x27;t need to? Is the non-nix build not including things it should?</div><br/><div id="39723590" class="c"><input type="checkbox" id="c-39723590" checked=""/><div class="controls bullet"><span class="by">jossephus01</span><span>|</span><a href="#39723150">root</a><span>|</span><a href="#39723505">parent</a><span>|</span><a href="#39723568">next</a><span>|</span><label class="collapse" for="c-39723590">[-]</label><label class="expand" for="c-39723590">[1 more]</label></div><br/><div class="children"><div class="content">I have included the result of running dive on the resulting image. You can check it out on <a href="https:&#x2F;&#x2F;github.com&#x2F;jossephus&#x2F;Docker_challenge&#x2F;wiki">https:&#x2F;&#x2F;github.com&#x2F;jossephus&#x2F;Docker_challenge&#x2F;wiki</a>.<p>As stated above, I havent done any trimming on the resulting image, so There&#x27;s too many stuff in the image.</div><br/></div></div></div></div><div id="39723568" class="c"><input type="checkbox" id="c-39723568" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#39723150">parent</a><span>|</span><a href="#39723505">prev</a><span>|</span><a href="#39721435">next</a><span>|</span><label class="collapse" for="c-39723568">[-]</label><label class="expand" for="c-39723568">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t you just stick the JAR in?</div><br/></div></div></div></div><div id="39721435" class="c"><input type="checkbox" id="c-39721435" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#39723150">prev</a><span>|</span><a href="#39722261">next</a><span>|</span><label class="collapse" for="c-39721435">[-]</label><label class="expand" for="c-39721435">[12 more]</label></div><br/><div class="children"><div class="content">I spent last 2-3 days trying to get Docker images built on Darwin and I feel that this article is a universe making fun of me.<p>Nix is absolutely the best tool for what I want to achieve but it has those dark forsaken corners that just suck your soul out dry.<p>I love it but sometimes it feels like being a Morty on Rick’s adventure to the compilerland.</div><br/><div id="39723282" class="c"><input type="checkbox" id="c-39723282" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39721435">parent</a><span>|</span><a href="#39722493">next</a><span>|</span><label class="collapse" for="c-39723282">[-]</label><label class="expand" for="c-39723282">[1 more]</label></div><br/><div class="children"><div class="content">The big problem is how docker was designed. It is essentially a jail that is supposed to contain a Linux binary.<p>Things are straight forward on Linux. You build your binary, place in a docker container and you are done. The nix code will also be straight forward. If you can build your code, then creating a container is just one more operation away.<p>Unfortunately docker requires Linux binary and you are on Mac. So the docker desktop actually runs a Linux VM and performs all operations on it, abstracting this away from you.<p>Nix doesn&#x27;t do that and you have two options:<p>1. Do cross compilation, the problem is that for this to work you need to be able to cross compile down to glibc, the problem is that while this will work for most community used dependencies you might get some package where the author didn&#x27;t put effort making sure it cross compile. To make things worse the Hydra that populates standard caches that nix uses, doesn&#x27;t do cross compile builds, so you will run into lengthy processes that might potentially end with a failure.<p>2. You can have a Linux builder, that you add to your Mac and configure to send build jobs for x86_64-linux to that builder. Now you could have a physical box, create a VM, or even have a NixOS docker container (after all docker ion Mac runs inside of the VM).<p>The #1 seems like the proper way, while #2 is more of a practical way.<p>I think you are running into issues, because you&#x27;re likely trying #1, and that requires a lot of experience not only with Nix, but also with cross compiling. I wish Nix&#x27;s Hydra would also build Darwin to Linux cross compilation as that would not only provide caches, but also help making sure the cross compilation doesn&#x27;t break, but that would also increase costs for them.<p>I think you should try the #2 solution.<p>Edit: looks like there might have been an official solution to this problem: <a href="https:&#x2F;&#x2F;ryantm.github.io&#x2F;nixpkgs&#x2F;builders&#x2F;special&#x2F;darwin-builder&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ryantm.github.io&#x2F;nixpkgs&#x2F;builders&#x2F;special&#x2F;darwin-bui...</a> I haven&#x27;t used it yet.</div><br/></div></div><div id="39722493" class="c"><input type="checkbox" id="c-39722493" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#39721435">parent</a><span>|</span><a href="#39723282">prev</a><span>|</span><a href="#39723165">next</a><span>|</span><label class="collapse" for="c-39722493">[-]</label><label class="expand" for="c-39722493">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;gytis-ivaskevicius&#x2F;high-quality-nix-content&#x2F;blob&#x2F;master&#x2F;memes&#x2F;nix-20min-adventure.png">https:&#x2F;&#x2F;github.com&#x2F;gytis-ivaskevicius&#x2F;high-quality-nix-conte...</a><p>This sort of twenty-minute adventure?</div><br/></div></div><div id="39723165" class="c"><input type="checkbox" id="c-39723165" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#39721435">parent</a><span>|</span><a href="#39722493">prev</a><span>|</span><a href="#39722455">next</a><span>|</span><label class="collapse" for="c-39723165">[-]</label><label class="expand" for="c-39723165">[1 more]</label></div><br/><div class="children"><div class="content">macOS is a definitely rougher. I use colima there, and it does alright. There are one or two bugs with it, but I think those are primarily around volumes. But it does alright with building Docker images.<p>The rougher part is the speed of it; it&#x27;s a one-two punch between the hardware &amp; the fact that Docker has to emulate a Linux VM.</div><br/></div></div><div id="39722455" class="c"><input type="checkbox" id="c-39722455" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#39721435">parent</a><span>|</span><a href="#39723165">prev</a><span>|</span><a href="#39722234">next</a><span>|</span><label class="collapse" for="c-39722455">[-]</label><label class="expand" for="c-39722455">[3 more]</label></div><br/><div class="children"><div class="content">In Docker, the dark corners have dust.  In Nix, the dark corners have a grue.</div><br/><div id="39722552" class="c"><input type="checkbox" id="c-39722552" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#39721435">root</a><span>|</span><a href="#39722455">parent</a><span>|</span><a href="#39722234">next</a><span>|</span><label class="collapse" for="c-39722552">[-]</label><label class="expand" for="c-39722552">[2 more]</label></div><br/><div class="children"><div class="content">100% this.   Nix may seem better, until something goes wrong and you have to waste your weekend digging into it&#x27;s depths.</div><br/><div id="39723327" class="c"><input type="checkbox" id="c-39723327" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#39721435">root</a><span>|</span><a href="#39722552">parent</a><span>|</span><a href="#39722234">next</a><span>|</span><label class="collapse" for="c-39723327">[-]</label><label class="expand" for="c-39723327">[1 more]</label></div><br/><div class="children"><div class="content">On the flip side, once you have fixed the problem it has a very strong tendency to stay fixed. More importantly, the fix does not typically require me to remember that fix months later.<p>If something does break, rollbacks are free and an integral part of Nix.</div><br/></div></div></div></div></div></div><div id="39722234" class="c"><input type="checkbox" id="c-39722234" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#39721435">parent</a><span>|</span><a href="#39722455">prev</a><span>|</span><a href="#39722261">next</a><span>|</span><label class="collapse" for="c-39722234">[-]</label><label class="expand" for="c-39722234">[5 more]</label></div><br/><div class="children"><div class="content">I use Orbstack and it works flawlessly to do this. Really good tool. I use Docker to cross-compile for {aarch64,amd64} x {linux,darwin} since not all the cross-compiling is super robust across our stacks (I&#x27;m using a specific glibc for one Linux part, etc.). Just a bunch of docker on my Darwin aarch64 and it compiles everything. Good experience.</div><br/><div id="39722284" class="c"><input type="checkbox" id="c-39722284" checked=""/><div class="controls bullet"><span class="by">e40</span><span>|</span><a href="#39721435">root</a><span>|</span><a href="#39722234">parent</a><span>|</span><a href="#39722424">next</a><span>|</span><label class="collapse" for="c-39722284">[-]</label><label class="expand" for="c-39722284">[3 more]</label></div><br/><div class="children"><div class="content">I installed Orbstack and found that I didn&#x27;t really need it, so I removed the directory in &#x2F;Applications.  Wow, for weeks and weeks I found remnants of it in a lot of places.  Very disappointing that it left so much cruft around.  They should have an uninstaller.  It left a really bad taste and I&#x27;m unlikely to try it again.<p>Before someone asks.  I&#x27;ve been using macOS for a long time.  I&#x27;ve never seen remnants like this from a program.  Sure, there are often directories left in ~&#x2F;Library&#x2F;Application Support&#x2F;, but this was more than that.  Unfortunately, I didn&#x27;t write down the details, but I ran across the bits in at least 3-4 places.</div><br/><div id="39724236" class="c"><input type="checkbox" id="c-39724236" checked=""/><div class="controls bullet"><span class="by">kdrag0n</span><span>|</span><a href="#39721435">root</a><span>|</span><a href="#39722284">parent</a><span>|</span><a href="#39722356">next</a><span>|</span><label class="collapse" for="c-39724236">[-]</label><label class="expand" for="c-39724236">[1 more]</label></div><br/><div class="children"><div class="content">Dev here — I&#x27;ve been meaning to update the Homebrew cask to be more complete on zap, but there&#x27;s a good reason that all of these are needed:<p>- ~&#x2F;.orbstack<p>- Docker context that points to OrbStack (for CLI)<p>- &quot;source ~&#x2F;.orbstack&#x2F;shell&#x2F;init.zsh&quot; in .zprofile&#x2F;bash_profile (to add CLI tools to PATH)<p>- ~&#x2F;.ssh&#x2F;config (for convenient SSH to OrbStack&#x27;s Linux machines)<p>- Symlinks to CLI tools in ~&#x2F;.local&#x2F;bin, ~&#x2F;bin, or &#x2F;usr&#x2F;local&#x2F;bin depending on what&#x27;s available (to add CLI tools to existing shells on first install — only one of these is used, not all)<p>- Standard macOS paths (~&#x2F;Library&#x2F;{Application Support, Preferences, Caches, HTTPStorages, Saved Application State, WebKit})<p>- Keychain items (for secure storage)<p>- ~&#x2F;OrbStack (empty dir for mounting shared files)<p>- &#x2F;Library&#x2F;PrivilegedHelperTools (to create symlinks for compatibility)<p>Not sure what the best solution is for people who don&#x27;t use Homebrew to uninstall it. I&#x27;ve never liked separate uninstaller apps, and it&#x27;s not possible to detect removal from &#x2F;Applications when the app isn&#x27;t running.</div><br/></div></div><div id="39722356" class="c"><input type="checkbox" id="c-39722356" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39721435">root</a><span>|</span><a href="#39722284">parent</a><span>|</span><a href="#39724236">prev</a><span>|</span><a href="#39722424">next</a><span>|</span><label class="collapse" for="c-39722356">[-]</label><label class="expand" for="c-39722356">[1 more]</label></div><br/><div class="children"><div class="content">I’ve found this to be the norm for ‘Docker Desktop alternatives’. Not to say that Orbstack isn’t uniquely messy.</div><br/></div></div></div></div><div id="39722424" class="c"><input type="checkbox" id="c-39722424" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#39721435">root</a><span>|</span><a href="#39722234">parent</a><span>|</span><a href="#39722284">prev</a><span>|</span><a href="#39722261">next</a><span>|</span><label class="collapse" for="c-39722424">[-]</label><label class="expand" for="c-39722424">[1 more]</label></div><br/><div class="children"><div class="content">I’m also on Orbstack mostly for performance.<p>But unfortunately cross compiling quickly broke when I started doing mild customization (and one reasons I’m doing this is a complex setup that’s very sensitive to version changes).<p>In the end solution was to “simply” get darwin.linux-builder up but that pulled a lot of weight behind it.<p>It works, but it’s not the first time I spent my time on nix-ventures.</div><br/></div></div></div></div></div></div><div id="39722261" class="c"><input type="checkbox" id="c-39722261" checked=""/><div class="controls bullet"><span class="by">tuananh</span><span>|</span><a href="#39721435">prev</a><span>|</span><a href="#39720765">next</a><span>|</span><label class="collapse" for="c-39722261">[-]</label><label class="expand" for="c-39722261">[29 more]</label></div><br/><div class="children"><div class="content">as platform engineer, i want to like nix. but it&#x27;s not easy for everyone else.<p>and the dx is still pretty bad IMO.<p>for example, i prefer devbox DX just because i can add pkg like this `devbox add python@3.11`.<p>also, looking at 120 lines flake.nix. it&#x27;s not exactly &quot;easier&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Xe&#x2F;douglas-adams-quotes&#x2F;blob&#x2F;main&#x2F;flake.nix">https:&#x2F;&#x2F;github.com&#x2F;Xe&#x2F;douglas-adams-quotes&#x2F;blob&#x2F;main&#x2F;flake.n...</a></div><br/><div id="39722522" class="c"><input type="checkbox" id="c-39722522" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#39722261">parent</a><span>|</span><a href="#39722540">next</a><span>|</span><label class="collapse" for="c-39722522">[-]</label><label class="expand" for="c-39722522">[15 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kind of an unfair comparison. The flake you linked:<p>1. Defines a Go binary (i.e., how to build it)<p>2. Defines a Docker image that uses said Go binary as an entry point<p>3. Defines a NixOS module that creates a systemd service that runs the Go binary (only relevant on NixOS)<p>4. Defines a NixOS test for the module that ensures that the NixOS module actually creates a systemd service that runs the Go binary as expected. The NixOS test framework is actually quite impressive - tests run in a QEMU VM that also runs NixOS :)<p>Note that only (1) and (2) are relevant to the linked article (+ some of the surrounding boilerplate).</div><br/><div id="39723445" class="c"><input type="checkbox" id="c-39723445" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722522">parent</a><span>|</span><a href="#39722710">next</a><span>|</span><label class="collapse" for="c-39723445">[-]</label><label class="expand" for="c-39723445">[7 more]</label></div><br/><div class="children"><div class="content">Does Nix make it difficult to properly modularise nix files (flakes or not)?<p>Because it certainly looks like the things you listed are separate&#x2F;orthogonal and should be in separate modules&#x2F;files.<p>Having many years of Java experience this is the reason why I stick to Maven (not moving to Gradle) - it is opinionated and strongly encourages fine grained modularisation.</div><br/><div id="39723509" class="c"><input type="checkbox" id="c-39723509" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723445">parent</a><span>|</span><a href="#39723535">next</a><span>|</span><label class="collapse" for="c-39723509">[-]</label><label class="expand" for="c-39723509">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Because it certainly looks like the things you listed are separate&#x2F;orthogonal and should be in separate modules&#x2F;files.<p>Nix absolutely allows that, to the point where I&#x27;m surprised that the linked example doesn&#x27;t separate them. Most of my flakes have a flake.nix that&#x27;s just a thin wrapper around a block that looks like<p><pre><code>    devShell = import .&#x2F;shell.nix { inherit pkgs; };
    defaultPackage = import .&#x2F;default.nix { inherit pkgs; };
    ...</code></pre></div><br/><div id="39723546" class="c"><input type="checkbox" id="c-39723546" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723509">parent</a><span>|</span><a href="#39723535">next</a><span>|</span><label class="collapse" for="c-39723546">[-]</label><label class="expand" for="c-39723546">[4 more]</label></div><br/><div class="children"><div class="content">And what&#x27;s the story with generic libraries that can later be used in your nix files to produce desired output?<p>I am aware of flake-parts that are supposed to offer that but the ecosystem of flake-parts is on the smaller side of things...</div><br/><div id="39724027" class="c"><input type="checkbox" id="c-39724027" checked=""/><div class="controls bullet"><span class="by">lkjdsklf</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723546">parent</a><span>|</span><a href="#39723535">next</a><span>|</span><label class="collapse" for="c-39724027">[-]</label><label class="expand" for="c-39724027">[3 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m not understanding your question, but this is what the inputs of flakes are for.<p>You can pull in arbitrary code from pretty much anywhere as an input</div><br/><div id="39724228" class="c"><input type="checkbox" id="c-39724228" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39724027">parent</a><span>|</span><a href="#39723535">next</a><span>|</span><label class="collapse" for="c-39724228">[-]</label><label class="expand" for="c-39724228">[2 more]</label></div><br/><div class="children"><div class="content">The question is if there actually _is_ a rich ecosystem of such libraries - similar to the rich ecosystem of Maven plugins.</div><br/><div id="39724302" class="c"><input type="checkbox" id="c-39724302" checked=""/><div class="controls bullet"><span class="by">georgyo</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39724228">parent</a><span>|</span><a href="#39723535">next</a><span>|</span><label class="collapse" for="c-39724302">[-]</label><label class="expand" for="c-39724302">[1 more]</label></div><br/><div class="children"><div class="content">I think something got lost along the way. Nix does not replace maven, you call maven from nix.<p><a href="https:&#x2F;&#x2F;ryantm.github.io&#x2F;nixpkgs&#x2F;languages-frameworks&#x2F;maven&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ryantm.github.io&#x2F;nixpkgs&#x2F;languages-frameworks&#x2F;maven&#x2F;</a><p>nix is a build tool a similae way that docker is a build tool. You define build scripts that call the tools you already use. The major difference is that a docker file gives you no way tl be sure you can reproduce that build in the future. A flake on the other hand gives you a high degree of trust.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39723535" class="c"><input type="checkbox" id="c-39723535" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723445">parent</a><span>|</span><a href="#39723509">prev</a><span>|</span><a href="#39722710">next</a><span>|</span><label class="collapse" for="c-39723535">[-]</label><label class="expand" for="c-39723535">[1 more]</label></div><br/><div class="children"><div class="content">Yes, to the point where it can become more confusing than helpful. The fact that Nix handles merging data structures for you makes it easy to fall into over modularization.</div><br/></div></div></div></div><div id="39722710" class="c"><input type="checkbox" id="c-39722710" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722522">parent</a><span>|</span><a href="#39723445">prev</a><span>|</span><a href="#39722540">next</a><span>|</span><label class="collapse" for="c-39722710">[-]</label><label class="expand" for="c-39722710">[7 more]</label></div><br/><div class="children"><div class="content">I agree that it&#x27;s not a fair comparison, but I will add that this is a big barrier to newcomers. Everyone experienced with nix builds their own ivory tower of a nix flake (myself included), so it&#x27;s hard to find actually good examples of how to do basic things without wading through a bunch of other bullshit.</div><br/><div id="39722959" class="c"><input type="checkbox" id="c-39722959" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722710">parent</a><span>|</span><a href="#39723295">next</a><span>|</span><label class="collapse" for="c-39722959">[-]</label><label class="expand" for="c-39722959">[3 more]</label></div><br/><div class="children"><div class="content">Newcomer here. Could anyone tell if std [0] is a good way to bring more sanity into flake design, esp. in avoiding ivory towery custom approaches? Using devenv.sh is another option, but I liked emphasis on creating a common mental picture of the architecture and focus on SLDC that std provides.<p>[0] <a href="https:&#x2F;&#x2F;std.divnix.com" rel="nofollow">https:&#x2F;&#x2F;std.divnix.com</a></div><br/><div id="39723023" class="c"><input type="checkbox" id="c-39723023" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722959">parent</a><span>|</span><a href="#39723295">next</a><span>|</span><label class="collapse" for="c-39723023">[-]</label><label class="expand" for="c-39723023">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used std, but I would like to point you at what I think is the ideal way to organize a lot of nix: readTree from the virus lounge[0].<p>It doesn&#x27;t add kitschy terms like &quot;Cell&quot; and &quot;growOn&quot;, it&#x27;s just a way to standardize attribute names according to where things live in the filesystem.<p>So in their repo, &#x2F;foo&#x2F;bar&#x2F;baz.nix has the attribute path depot.foo.bar.baz<p>I will say that to understand how it works you need to have a solid grasp of the nix language. But once established I think it&#x27;s a pattern that noobs could learn in a very quick and superficial way.<p>[0]: <a href="https:&#x2F;&#x2F;cs.tvl.fyi&#x2F;depot&#x2F;-&#x2F;blob&#x2F;nix&#x2F;readTree&#x2F;README.md" rel="nofollow">https:&#x2F;&#x2F;cs.tvl.fyi&#x2F;depot&#x2F;-&#x2F;blob&#x2F;nix&#x2F;readTree&#x2F;README.md</a></div><br/><div id="39723078" class="c"><input type="checkbox" id="c-39723078" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723023">parent</a><span>|</span><a href="#39723295">next</a><span>|</span><label class="collapse" for="c-39723078">[-]</label><label class="expand" for="c-39723078">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I already bumped into the virus lounge, with their TVIX project [0] that I found quite interesting.<p>[0] <a href="https:&#x2F;&#x2F;code.tvl.fyi&#x2F;about&#x2F;tvix" rel="nofollow">https:&#x2F;&#x2F;code.tvl.fyi&#x2F;about&#x2F;tvix</a></div><br/></div></div></div></div></div></div><div id="39723295" class="c"><input type="checkbox" id="c-39723295" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722710">parent</a><span>|</span><a href="#39722959">prev</a><span>|</span><a href="#39722826">next</a><span>|</span><label class="collapse" for="c-39723295">[-]</label><label class="expand" for="c-39723295">[1 more]</label></div><br/><div class="children"><div class="content">I thought I was weird for my bespoke ivory tower monorepo flake.nix, glad to hear I&#x27;m not the only one. It has been a tremendous help in managing my homelab.</div><br/></div></div><div id="39722826" class="c"><input type="checkbox" id="c-39722826" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722710">parent</a><span>|</span><a href="#39723295">prev</a><span>|</span><a href="#39722540">next</a><span>|</span><label class="collapse" for="c-39722826">[-]</label><label class="expand" for="c-39722826">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a beginner myself and have been trying my best to keep things simple. But I do agree that the complexity creep is quite tempting with Nix. Not sure why though..</div><br/><div id="39723053" class="c"><input type="checkbox" id="c-39723053" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722826">parent</a><span>|</span><a href="#39722540">next</a><span>|</span><label class="collapse" for="c-39723053">[-]</label><label class="expand" for="c-39723053">[1 more]</label></div><br/><div class="children"><div class="content">I think nix has a fair amount of gravity - once you&#x27;ve started, assuming like it, you will quickly want to use it for everything.<p>I don&#x27;t think most people&#x27;s flakes are more complex than the alternative (which would be, I don&#x27;t know, a bunch of different script, maybe some ansible playbooks?) but it is a bit daunting when all that complexity is wrangled into a single abstraction.</div><br/></div></div></div></div></div></div></div></div><div id="39722540" class="c"><input type="checkbox" id="c-39722540" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#39722261">parent</a><span>|</span><a href="#39722522">prev</a><span>|</span><a href="#39723102">next</a><span>|</span><label class="collapse" for="c-39722540">[-]</label><label class="expand" for="c-39722540">[11 more]</label></div><br/><div class="children"><div class="content">Those 120 lines are not exactly representative. For example if I was writing this for a single service, I wouldn&#x27;t bother making a new module and would inline it instead. Then, you&#x27;ve got many lines which would map 1:1 to an inlined systemd service description, so you&#x27;re not getting rid of those whatever the system you choose. There&#x27;s also a fancy way to declare multiple systems with an override.<p>This example is a &quot;let&#x27;s do a trivial thing the way you&#x27;d do a big serious thing&quot;. If you wanted to treat it as a one-off, I&#x27;m sure you could cut it down to 40 lines or so.</div><br/><div id="39722813" class="c"><input type="checkbox" id="c-39722813" checked=""/><div class="controls bullet"><span class="by">whydoineedthis</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722540">parent</a><span>|</span><a href="#39723102">next</a><span>|</span><label class="collapse" for="c-39722813">[-]</label><label class="expand" for="c-39722813">[10 more]</label></div><br/><div class="children"><div class="content">So I can write a Dockerfile using 17 verbs (13, actually), and it&#x27;s understandable language to a 4th grader...    or I can write 120 lines of complete abstract nix code that means nothing to someone doing software for 20 years.<p>Hrmmmm...this is such a TOUGH decision.</div><br/><div id="39722955" class="c"><input type="checkbox" id="c-39722955" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722813">parent</a><span>|</span><a href="#39723174">next</a><span>|</span><label class="collapse" for="c-39722955">[-]</label><label class="expand" for="c-39722955">[7 more]</label></div><br/><div class="children"><div class="content">I would like to mention one pet peeve of mine wrt docker...<p>cramming everything into one RUN line to save space in a layer.<p>I really wish instead of:<p><pre><code>  RUN foo &amp;&amp; \
      bar &amp;&amp; \
      bletch
</code></pre>
You could do:<p><pre><code>  LAYER
  RUN foo
  RUN bar
  RUN bletch
  LAYER
</code></pre>
or something similar.<p>maybe even during development you could do:<p><pre><code>  docker build --ignore-layer .
</code></pre>
then at the end:<p><pre><code>  docker build .</code></pre></div><br/><div id="39724291" class="c"><input type="checkbox" id="c-39724291" checked=""/><div class="controls bullet"><span class="by">sre2</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722955">parent</a><span>|</span><a href="#39723192">next</a><span>|</span><label class="collapse" for="c-39724291">[-]</label><label class="expand" for="c-39724291">[1 more]</label></div><br/><div class="children"><div class="content">Heredocs (described in the docs[1] under &quot;shell form&quot;) was introduced 3 years ago[1]. The flag &#x27;--squash&#x27; has been in podman for quite a while[2]. It might be time for you to upgrade your tooling.<p>[0]: <a href="https:&#x2F;&#x2F;docs.docker.com&#x2F;reference&#x2F;dockerfile&#x2F;#shell-form" rel="nofollow">https:&#x2F;&#x2F;docs.docker.com&#x2F;reference&#x2F;dockerfile&#x2F;#shell-form</a><p>[1]: <a href="https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;introduction-to-heredocs-in-dockerfiles&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;introduction-to-heredocs-in-dock...</a><p>[2]: <a href="https:&#x2F;&#x2F;docs.podman.io&#x2F;en&#x2F;latest&#x2F;markdown&#x2F;podman-build.1.html#squash" rel="nofollow">https:&#x2F;&#x2F;docs.podman.io&#x2F;en&#x2F;latest&#x2F;markdown&#x2F;podman-build.1.htm...</a></div><br/></div></div><div id="39723192" class="c"><input type="checkbox" id="c-39723192" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722955">parent</a><span>|</span><a href="#39724291">prev</a><span>|</span><a href="#39723174">next</a><span>|</span><label class="collapse" for="c-39723192">[-]</label><label class="expand" for="c-39723192">[5 more]</label></div><br/><div class="children"><div class="content">Cramming things into one layer can save gigabytes in size. Even if it saves a 100MB, it adds up between multiple CI runs and in deployment latencies.<p>Docker should address it one day, but until then, we just have to do it in real world scenarios.</div><br/><div id="39723290" class="c"><input type="checkbox" id="c-39723290" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723192">parent</a><span>|</span><a href="#39723520">next</a><span>|</span><label class="collapse" for="c-39723290">[-]</label><label class="expand" for="c-39723290">[2 more]</label></div><br/><div class="children"><div class="content">Parent comment agrees with you, is just asking for more ergonomic syntax</div><br/><div id="39723307" class="c"><input type="checkbox" id="c-39723307" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723290">parent</a><span>|</span><a href="#39723520">next</a><span>|</span><label class="collapse" for="c-39723307">[-]</label><label class="expand" for="c-39723307">[1 more]</label></div><br/><div class="children"><div class="content">I get it, just providing more context. Should&#x27;ve phrased it nicer.</div><br/></div></div></div></div><div id="39723520" class="c"><input type="checkbox" id="c-39723520" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723192">parent</a><span>|</span><a href="#39723290">prev</a><span>|</span><a href="#39723174">next</a><span>|</span><label class="collapse" for="c-39723520">[-]</label><label class="expand" for="c-39723520">[2 more]</label></div><br/><div class="children"><div class="content">An alternative solution... for some definition of the term... is to write a &quot;naive&quot; Dockerfile like<p><pre><code>    RUN foo
    RUN bar
    RUN baz
</code></pre>
and then just build it with something like... I think kaniko did this last I looked?... that smashes the whole thing into a single layer. Obviously that has other tradeoffs (no reuse of layers) but depending on your usecase it can be a good trade to make (why yes, I did cut my teeth in an environment where very few images shared a base layer, why do you ask?).</div><br/><div id="39724233" class="c"><input type="checkbox" id="c-39724233" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39723520">parent</a><span>|</span><a href="#39723174">next</a><span>|</span><label class="collapse" for="c-39724233">[-]</label><label class="expand" for="c-39724233">[1 more]</label></div><br/><div class="children"><div class="content">Docker itself can do that now too.</div><br/></div></div></div></div></div></div></div></div><div id="39723174" class="c"><input type="checkbox" id="c-39723174" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722813">parent</a><span>|</span><a href="#39722955">prev</a><span>|</span><a href="#39722928">next</a><span>|</span><label class="collapse" for="c-39723174">[-]</label><label class="expand" for="c-39723174">[1 more]</label></div><br/><div class="children"><div class="content">I addressed the 120 lines already and they&#x27;re not completely abstract. You seem uncomfortable with an alternative approach and that&#x27;s fine. But this is not a good intentions argument.</div><br/></div></div><div id="39722928" class="c"><input type="checkbox" id="c-39722928" checked=""/><div class="controls bullet"><span class="by">xena</span><span>|</span><a href="#39722261">root</a><span>|</span><a href="#39722813">parent</a><span>|</span><a href="#39723174">prev</a><span>|</span><a href="#39723102">next</a><span>|</span><label class="collapse" for="c-39722928">[-]</label><label class="expand" for="c-39722928">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used this app for like four different talks over the years, I could clean it up, but then I break code samples in my talks.</div><br/></div></div></div></div></div></div><div id="39723102" class="c"><input type="checkbox" id="c-39723102" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#39722261">parent</a><span>|</span><a href="#39722540">prev</a><span>|</span><a href="#39722288">next</a><span>|</span><label class="collapse" for="c-39723102">[-]</label><label class="expand" for="c-39723102">[1 more]</label></div><br/><div class="children"><div class="content">its 120 lines of code to deal with a binary and its systemd setup.<p>That binary + config file are effectively as close as we&#x27;re going to get to a &quot;flat pack&quot; on linux.<p>Im not sure what is the forest and where are the trees but this example shows exactly what we have lost sight of.</div><br/></div></div><div id="39722288" class="c"><input type="checkbox" id="c-39722288" checked=""/><div class="controls bullet"><span class="by">klntsky</span><span>|</span><a href="#39722261">parent</a><span>|</span><a href="#39723102">prev</a><span>|</span><a href="#39720765">next</a><span>|</span><label class="collapse" for="c-39722288">[-]</label><label class="expand" for="c-39722288">[1 more]</label></div><br/><div class="children"><div class="content">These 120 lines do quite a lot more, don&#x27;t they?</div><br/></div></div></div></div><div id="39720765" class="c"><input type="checkbox" id="c-39720765" checked=""/><div class="controls bullet"><span class="by">operator-name</span><span>|</span><a href="#39722261">prev</a><span>|</span><a href="#39723085">next</a><span>|</span><label class="collapse" for="c-39720765">[-]</label><label class="expand" for="c-39720765">[4 more]</label></div><br/><div class="children"><div class="content">This is great if you&#x27;ve already adopted Nix, and I&#x27;d love for nothing than more declarative package management solutions like Nix or Guix to take off.<p>If you&#x27;re already using Docker but want to gradually adopt Nix, there is an alternative approach outlined by this talk: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;l17oRkhgqHE" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;l17oRkhgqHE</a>. Instead of migrating both the configuration AND container building to Nix straight away, you can keep the Dockerfile to build the nix configuration.<p>The biggest downside is that you don&#x27;t take advantage of layers at all, but the upside is that you can gradually adapt your Dockerfiles, and reuse any Docker infrastructure or automation you already use.</div><br/><div id="39722129" class="c"><input type="checkbox" id="c-39722129" checked=""/><div class="controls bullet"><span class="by">FiberBundle</span><span>|</span><a href="#39720765">parent</a><span>|</span><a href="#39723336">next</a><span>|</span><label class="collapse" for="c-39722129">[-]</label><label class="expand" for="c-39722129">[1 more]</label></div><br/><div class="children"><div class="content">[1] also uses this approach.<p>[1] <a href="https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;nix-with-dockerfiles" rel="nofollow">https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;nix-with-dockerfiles</a></div><br/></div></div><div id="39723336" class="c"><input type="checkbox" id="c-39723336" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39720765">parent</a><span>|</span><a href="#39722129">prev</a><span>|</span><a href="#39723085">next</a><span>|</span><label class="collapse" for="c-39723336">[-]</label><label class="expand" for="c-39723336">[2 more]</label></div><br/><div class="children"><div class="content">So one of the pillars of the article is that docker builds aren&#x27;t reproducible, but Nix is.<p>But... is a lot of that irreproducibiity (apologies for that word) because there&#x27;s no guarantee one of the docker layers will be available?<p>And... does Nix have some guarantee to the end of the universe that package versions will stay in the repository?</div><br/><div id="39724259" class="c"><input type="checkbox" id="c-39724259" checked=""/><div class="controls bullet"><span class="by">operator-name</span><span>|</span><a href="#39720765">root</a><span>|</span><a href="#39723336">parent</a><span>|</span><a href="#39723085">next</a><span>|</span><label class="collapse" for="c-39724259">[-]</label><label class="expand" for="c-39724259">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d give this article a read, as it can explain it more clearly than I can: <a href="https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;what-is-nix" rel="nofollow">https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;what-is-nix</a><p>But to briefly answer your specific questions: Docker files are commonly not reproducible because they contain arbitary stateful commands like `apt-get update`, `curl`, etc. For a layer with these kinds of commands to be reproducible you would need a mechanism to version and verify the result.<p>Nix provides such a mechanism, and a community package repository with versioned dependancies between packages. These are defined in a domain specific language called Nix (text files) and kept into a git repository. This should be familiar if you&#x27;ve used a package manager with lock files before.<p>You can guarentee the package version will stay in the repository by pinning your build to an exact commit hash in the repository.</div><br/></div></div></div></div></div></div><div id="39723085" class="c"><input type="checkbox" id="c-39723085" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#39720765">prev</a><span>|</span><a href="#39721470">next</a><span>|</span><label class="collapse" for="c-39723085">[-]</label><label class="expand" for="c-39723085">[27 more]</label></div><br/><div class="children"><div class="content">I keep reading about Nix and I still don&#x27;t understand what it does better than Docker, all the example in the post are trivial to do in a Dockerfile so where is the added value?<p>Docker build are deterministic and easily reproductible, you use a tagged image, that&#x27;s it, it set in stone.<p>The 0.01% of Dockerfile that don&#x27;t work, what does it even means, what does not work?<p>The other thing is about that buildGoModule module so now you need somehow a third party tool to use or build Go in a Docker image, when using a Dockerfile you just use regular Go commands such as go build and you know exactly what is going on and what args you use to build the binary.<p>As for the thing about using Ubuntu 18 which is out of date and not finding it, most orgs have docker image cache especially since docker hub closed access to large downloads, but more importantly there is a reason that&#x27;s its not there anymore, it&#x27;s not secure to use it, it&#x27;s like wanting to use the JVM 6, you should not use something that is out of date security wise.</div><br/><div id="39724309" class="c"><input type="checkbox" id="c-39724309" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#39723085">parent</a><span>|</span><a href="#39723157">next</a><span>|</span><label class="collapse" for="c-39724309">[-]</label><label class="expand" for="c-39724309">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I still don&#x27;t understand what it does better than Docker<p>It doesn&#x27;t break as you scale. If you don&#x27;t need that, then keep using Docker. (Personally, for me &quot;scale&quot; starts at &quot;3 PC&#x27;s in the home&quot;, so I eventually switched all of them to NixOS. I don&#x27;t have time to babysit these computers.)<p>&gt; Docker build are deterministic and easily reproductible<p>No, they definitely aren&#x27;t. You don&#x27;t really want to go down this rabbit hole, because at the end you realize Nix is still the simplest and most mature solution.</div><br/></div></div><div id="39723157" class="c"><input type="checkbox" id="c-39723157" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#39723085">parent</a><span>|</span><a href="#39724309">prev</a><span>|</span><a href="#39723154">next</a><span>|</span><label class="collapse" for="c-39723157">[-]</label><label class="expand" for="c-39723157">[1 more]</label></div><br/><div class="children"><div class="content">Most Docker builds are not <i>remotely</i> deterministic or reproducible, as most of them pull in floating versions of their dependencies. This means that the same Dockerfile is likely to produce different results today than it did yesterday.</div><br/></div></div><div id="39723154" class="c"><input type="checkbox" id="c-39723154" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#39723085">parent</a><span>|</span><a href="#39723157">prev</a><span>|</span><a href="#39723906">next</a><span>|</span><label class="collapse" for="c-39723154">[-]</label><label class="expand" for="c-39723154">[10 more]</label></div><br/><div class="children"><div class="content">Aren’t Nix builds actually deterministic in that they’ll build the same each time? Docker doesn’t have that, you’re just using prebuilt images everywhere. Determinism has a computer science definition, it’s not “build once run anywhere,” it’s more like “builds the exact same binary each time.”</div><br/><div id="39723560" class="c"><input type="checkbox" id="c-39723560" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723154">parent</a><span>|</span><a href="#39723313">next</a><span>|</span><label class="collapse" for="c-39723560">[-]</label><label class="expand" for="c-39723560">[6 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t conflate using &quot;apt-get&quot; in a Dockerfile with what &quot;docker build&quot; does.</div><br/><div id="39723677" class="c"><input type="checkbox" id="c-39723677" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723560">parent</a><span>|</span><a href="#39723599">next</a><span>|</span><label class="collapse" for="c-39723677">[-]</label><label class="expand" for="c-39723677">[1 more]</label></div><br/><div class="children"><div class="content">You can absolutely build a reproducible image in Dockerfile if you have discipline and follow specific patterns of doing.<p>But you can achieve the same result if you use similar techniques with a bash script.</div><br/></div></div><div id="39723599" class="c"><input type="checkbox" id="c-39723599" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723560">parent</a><span>|</span><a href="#39723677">prev</a><span>|</span><a href="#39723635">next</a><span>|</span><label class="collapse" for="c-39723599">[-]</label><label class="expand" for="c-39723599">[3 more]</label></div><br/><div class="children"><div class="content">Docker doesn&#x27;t give you the proper tooling to <i>not</i> have to use e.g. apt-get in your Dockerfiles. For that reason, one might as well conflate them.</div><br/><div id="39724231" class="c"><input type="checkbox" id="c-39724231" checked=""/><div class="controls bullet"><span class="by">vergessenmir</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723599">parent</a><span>|</span><a href="#39723788">next</a><span>|</span><label class="collapse" for="c-39724231">[-]</label><label class="expand" for="c-39724231">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that this is a Docker problem but you do have a point. I&#x27;ve used docker from the very beginning and it always surprised me that users opted to use package managers over downloading the dependencies and then using ADD in the docker file.<p>Using this approach you get something reproducible. Using apt-get in a docker file is an antipattern</div><br/></div></div><div id="39723788" class="c"><input type="checkbox" id="c-39723788" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723599">parent</a><span>|</span><a href="#39724231">prev</a><span>|</span><a href="#39723635">next</a><span>|</span><label class="collapse" for="c-39723788">[-]</label><label class="expand" for="c-39723788">[1 more]</label></div><br/><div class="children"><div class="content">Docker doesn&#x27;t give you the tooling to build a package and opts for you to bring the toolchain of your choice.
Docker executes your toolchain, and does not prescribe one to you except for how it is executed.<p>Nix <i>is</i> the toolchain, which of course has its advantages.</div><br/></div></div></div></div><div id="39723635" class="c"><input type="checkbox" id="c-39723635" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723560">parent</a><span>|</span><a href="#39723599">prev</a><span>|</span><a href="#39723313">next</a><span>|</span><label class="collapse" for="c-39723635">[-]</label><label class="expand" for="c-39723635">[1 more]</label></div><br/><div class="children"><div class="content">Uh, I never even mentioned apt. Docker and nix are, likewise, very different. In not super familiar with either but I do know docker isn’t reproducible by design whereas nix is. I’m not sure nix is always deterministic, though i know docker (and apt) certainly aren’t, nor are they reproducible by design.</div><br/></div></div></div></div><div id="39723313" class="c"><input type="checkbox" id="c-39723313" checked=""/><div class="controls bullet"><span class="by">jhanoncomm</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723154">parent</a><span>|</span><a href="#39723560">prev</a><span>|</span><a href="#39723906">next</a><span>|</span><label class="collapse" for="c-39723313">[-]</label><label class="expand" for="c-39723313">[3 more]</label></div><br/><div class="children"><div class="content">Is this about timestamps or is there more to it?</div><br/><div id="39723686" class="c"><input type="checkbox" id="c-39723686" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723313">parent</a><span>|</span><a href="#39723351">next</a><span>|</span><label class="collapse" for="c-39723686">[-]</label><label class="expand" for="c-39723686">[1 more]</label></div><br/><div class="children"><div class="content">The Nix idea is to start building with a known state of the system and list every dependency explicitly (nothing is implicit, or downloaded over net during build).<p>This is achieved by building inside of a chroot, with blocked network access etc. Only the dependencies that are explicitly listed in the derivation are available.</div><br/></div></div><div id="39723351" class="c"><input type="checkbox" id="c-39723351" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723313">parent</a><span>|</span><a href="#39723686">prev</a><span>|</span><a href="#39723906">next</a><span>|</span><label class="collapse" for="c-39723351">[-]</label><label class="expand" for="c-39723351">[1 more]</label></div><br/><div class="children"><div class="content">The timestamps thing is part of ensuring that archives will have the correct hash. Nix ensures that the inputs to a build, that being the compiler, environment, dependencies, file system, are exactly the same. The idea being then that the compiler will produce an identical output. Hash&#x27;s are used throughout the process to ensure this is actually the case, they are also used to identify specific outputs.</div><br/></div></div></div></div></div></div><div id="39723906" class="c"><input type="checkbox" id="c-39723906" checked=""/><div class="controls bullet"><span class="by">janjongboom</span><span>|</span><a href="#39723085">parent</a><span>|</span><a href="#39723154">prev</a><span>|</span><a href="#39723145">next</a><span>|</span><label class="collapse" for="c-39723906">[-]</label><label class="expand" for="c-39723906">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the interesting bit about Dockerfiles. They look _looks_ deterministic, and they even are for a while while you&#x27;re looking at it as a developer. I&#x27;ve done a detailed writeup of how it&#x27;s not deterministic in <a href="https:&#x2F;&#x2F;docs.stablebuild.com&#x2F;why-stablebuild" rel="nofollow">https:&#x2F;&#x2F;docs.stablebuild.com&#x2F;why-stablebuild</a></div><br/></div></div><div id="39723145" class="c"><input type="checkbox" id="c-39723145" checked=""/><div class="controls bullet"><span class="by">TeeMassive</span><span>|</span><a href="#39723085">parent</a><span>|</span><a href="#39723906">prev</a><span>|</span><a href="#39721470">next</a><span>|</span><label class="collapse" for="c-39723145">[-]</label><label class="expand" for="c-39723145">[13 more]</label></div><br/><div class="children"><div class="content">Docker builds are not deterministic, I don&#x27;t get where you get that idea. I can&#x27;t count the hours lost because the last guy who left one year ago built the image using duck tape and sed commands everywhere. The <i>image</i> is set in stone, but so is a zip file, there&#x27;s nothing special here.<p>Building an image using nix solves many problems regarding not only reproducible environments that can be tested outside a container but also fully horizontal dependency management where each dependency gets a layer that&#x27;s not stacked on one another like a typical apt&#x2F;npm&#x2F;cargo&#x2F;pip command. And I don&#x27;t have to reverse engineer the world just to see what files changed in the filesystem since everything has its place and has a systematic BOM.</div><br/><div id="39723330" class="c"><input type="checkbox" id="c-39723330" checked=""/><div class="controls bullet"><span class="by">jhanoncomm</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723145">parent</a><span>|</span><a href="#39721470">next</a><span>|</span><label class="collapse" for="c-39723330">[-]</label><label class="expand" for="c-39723330">[12 more]</label></div><br/><div class="children"><div class="content">So is it right, to make docker reproducible it needs to either build dependencies from source from say a git hash or use other package managers that are reproducible or rely on base images that are reproducible.<p>And that all relies on discipline.
Just like using a dynamically typed programming language can in theory have no type errors at run time, if you are careful enough.</div><br/><div id="39723553" class="c"><input type="checkbox" id="c-39723553" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723330">parent</a><span>|</span><a href="#39723621">next</a><span>|</span><label class="collapse" for="c-39723553">[-]</label><label class="expand" for="c-39723553">[9 more]</label></div><br/><div class="children"><div class="content">Right; you <i>could</i> write a Dockerfile that went something like<p><pre><code>    FROM base-image@e70197813aa3b7c86586e6ecbbf0e18d2643dfc8a788aac79e8c906b9e2b0785
    RUN pkg install foo=1.2.3 bar=2.3.4
    RUN git clone https:&#x2F;&#x2F;some&#x2F;source.git &amp;&amp; cd source &amp;&amp; git checkout f8b02f5809843d97553a1df02997a5896ba3c1c6
    RUN gcc --reproducible-flags source&#x2F;foo.c -o foo
</code></pre>
but that&#x27;s (IME) really rare; you&#x27;re more likely to find `FROM debian:10` (which isn&#x27;t <i>too</i> likely to change but is <i>not</i> pinned) and `RUN git clone -b v1.2.3 repo.git` (which is <i>probably</i> fixed but could change)...<p>And then there&#x27;s the Dockerfiles that just `RUN git clone repo.git` and run with whatever happened to be in the latest commit at the moment...</div><br/><div id="39723909" class="c"><input type="checkbox" id="c-39723909" checked=""/><div class="controls bullet"><span class="by">janjongboom</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723553">parent</a><span>|</span><a href="#39723962">next</a><span>|</span><label class="collapse" for="c-39723909">[-]</label><label class="expand" for="c-39723909">[1 more]</label></div><br/><div class="children"><div class="content">And that assumes that `foo` and `bar` are not overwritten or deleted in your package repository, and that the git repository remains available.</div><br/></div></div><div id="39723962" class="c"><input type="checkbox" id="c-39723962" checked=""/><div class="controls bullet"><span class="by">nullify88</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723553">parent</a><span>|</span><a href="#39723909">prev</a><span>|</span><a href="#39723567">next</a><span>|</span><label class="collapse" for="c-39723962">[-]</label><label class="expand" for="c-39723962">[1 more]</label></div><br/><div class="children"><div class="content">Maintaining something like that is a pain unless you have tooling like Renovate to inform and update the digests and versions.</div><br/></div></div><div id="39723567" class="c"><input type="checkbox" id="c-39723567" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723553">parent</a><span>|</span><a href="#39723962">prev</a><span>|</span><a href="#39723621">next</a><span>|</span><label class="collapse" for="c-39723567">[-]</label><label class="expand" for="c-39723567">[6 more]</label></div><br/><div class="children"><div class="content">It is likely just as rare for someone to use nix for this, though.</div><br/><div id="39723580" class="c"><input type="checkbox" id="c-39723580" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723567">parent</a><span>|</span><a href="#39723608">next</a><span>|</span><label class="collapse" for="c-39723580">[-]</label><label class="expand" for="c-39723580">[1 more]</label></div><br/><div class="children"><div class="content">Possible; I don&#x27;t have a feel for the relative likelihoods. I think the thing nix has going for it is that you can write a nix package definition without having to actually hardcode anything in and nix itself will give you the defaults to make ex. compilers be deterministic&#x2F;reproducible, and automate handling flake.lock so you don&#x27;t have to actually pay attention to the pins yourself. Or put differently; you can make either one reproducible, but nix is designed to help you do that while docker really doesn&#x27;t care.</div><br/></div></div><div id="39723608" class="c"><input type="checkbox" id="c-39723608" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723567">parent</a><span>|</span><a href="#39723580">prev</a><span>|</span><a href="#39723645">next</a><span>|</span><label class="collapse" for="c-39723608">[-]</label><label class="expand" for="c-39723608">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually how nix works by default. When you pull in a dependency, you are actually pulling in a full description of how to build it. And it pulls in full descriptions of how to build its dependencies and so on.<p>The only reason nix isn&#x27;t dog slow is that it has really strong caching so it doesn&#x27;t have to build everything from source.</div><br/></div></div><div id="39723645" class="c"><input type="checkbox" id="c-39723645" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723567">parent</a><span>|</span><a href="#39723608">prev</a><span>|</span><a href="#39723628">next</a><span>|</span><label class="collapse" for="c-39723645">[-]</label><label class="expand" for="c-39723645">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using Nix, that is what you are ultimately producing, it&#x27;s buried under significant amounts of boilerplate and sensible defaults. Ultimately the output of Nix (called a derivation) reads a lot like a pile of references, build instructions, and checksums.</div><br/><div id="39724264" class="c"><input type="checkbox" id="c-39724264" checked=""/><div class="controls bullet"><span class="by">isbvhodnvemrwvn</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723645">parent</a><span>|</span><a href="#39723628">next</a><span>|</span><label class="collapse" for="c-39724264">[-]</label><label class="expand" for="c-39724264">[1 more]</label></div><br/><div class="children"><div class="content">I think their point was that number of people who use nix is a rounding error, perhaps due to poor user experience.</div><br/></div></div></div></div></div></div></div></div><div id="39723621" class="c"><input type="checkbox" id="c-39723621" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723330">parent</a><span>|</span><a href="#39723553">prev</a><span>|</span><a href="#39721470">next</a><span>|</span><label class="collapse" for="c-39723621">[-]</label><label class="expand" for="c-39723621">[2 more]</label></div><br/><div class="children"><div class="content">You can also use a hammer to put a screw in the wall.<p>Dockerfiles being at their core a set of instructions for producing a container image could of course be used to make a reproducible image. Although you&#x27;d have to be painfully verbose to ensure that you got the exact same output. You would actually likely need 2 files, the first being the build environment that the second actually get built in.<p>Or you could use Nix that is actually intended to do this and provides the necessary framework for reproducibility.</div><br/><div id="39724319" class="c"><input type="checkbox" id="c-39724319" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#39723085">root</a><span>|</span><a href="#39723621">parent</a><span>|</span><a href="#39721470">next</a><span>|</span><label class="collapse" for="c-39724319">[-]</label><label class="expand" for="c-39724319">[1 more]</label></div><br/><div class="children"><div class="content">fun fact: there actually is a class of impact driver[1] that couples longitudinal force to rotation to prevent cam-out on screws like the Phillips head when high torque is required<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Impact_driver#Manual_impact_drivers" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Impact_driver#Manual_impact_dr...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39721470" class="c"><input type="checkbox" id="c-39721470" checked=""/><div class="controls bullet"><span class="by">whazor</span><span>|</span><a href="#39723085">prev</a><span>|</span><a href="#39722595">next</a><span>|</span><label class="collapse" for="c-39721470">[-]</label><label class="expand" for="c-39721470">[8 more]</label></div><br/><div class="children"><div class="content">This blog post is missing the reasoning on why shared docker layers are useful. It is because of caching. The more images are sharing the same layers the better, as it allows you to cache more stuff. Better caching means faster startup of containers.<p>Why is docker bad at this? In order to enjoy the caching benefit, each time you build a docker image you want it to output as much existing layers as possible. So running apt-get install python3 today should result in the exact same layer as yesterday, if there are no new updates. But this requires the all the files to be exactly the same, including the metadata like creation time. As docker layers are cached by hashing the files.<p>Now, Nix already does storing dependencies by hash. So the layers will always be the same with the same version and same configuration.</div><br/><div id="39721919" class="c"><input type="checkbox" id="c-39721919" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#39721470">parent</a><span>|</span><a href="#39722740">next</a><span>|</span><label class="collapse" for="c-39721919">[-]</label><label class="expand" for="c-39721919">[5 more]</label></div><br/><div class="children"><div class="content">In Docker, if the layers are cached, the layer with apt-get won&#x27;t be automatically invalidated (unless --no-cache or any changes to the upper layers).</div><br/><div id="39723673" class="c"><input type="checkbox" id="c-39723673" checked=""/><div class="controls bullet"><span class="by">whazor</span><span>|</span><a href="#39721470">root</a><span>|</span><a href="#39721919">parent</a><span>|</span><a href="#39722121">next</a><span>|</span><label class="collapse" for="c-39723673">[-]</label><label class="expand" for="c-39723673">[1 more]</label></div><br/><div class="children"><div class="content">I am thinking more about pipelines that run daily. Also, this ‘docker cache’ effectively means not running the step. So you might miss important security updates. Via Nix you can ensure that your dependencies are updated. And no updates means same hash.<p>When said caching, I meant on the nodes that run the containers. With Nix you can also update only one layer, while keeping the other layers the same.</div><br/></div></div><div id="39722121" class="c"><input type="checkbox" id="c-39722121" checked=""/><div class="controls bullet"><span class="by">raffraffraff</span><span>|</span><a href="#39721470">root</a><span>|</span><a href="#39721919">parent</a><span>|</span><a href="#39723673">prev</a><span>|</span><a href="#39722740">next</a><span>|</span><label class="collapse" for="c-39722121">[-]</label><label class="expand" for="c-39722121">[3 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s what I would expect to happen. I don&#x27;t see a problem.</div><br/><div id="39722249" class="c"><input type="checkbox" id="c-39722249" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#39721470">root</a><span>|</span><a href="#39722121">parent</a><span>|</span><a href="#39722386">next</a><span>|</span><label class="collapse" for="c-39722249">[-]</label><label class="expand" for="c-39722249">[1 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t get invalidated even if what &quot;apt-get install python3&quot; does changes - the cache is only based on the syntax of the RUN string plus the previous layer hash, IIRC.  (COPY actually invalidates if the file being copied changes, so maybe there&#x27;s a way to fetch a hash of the repo and stash it where copy will notice, or something, but then it seems you need external tooling to do that bit?)</div><br/></div></div><div id="39722386" class="c"><input type="checkbox" id="c-39722386" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#39721470">root</a><span>|</span><a href="#39722121">parent</a><span>|</span><a href="#39722249">prev</a><span>|</span><a href="#39722740">next</a><span>|</span><label class="collapse" for="c-39722386">[-]</label><label class="expand" for="c-39722386">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t claim there is a problem. The original comment made it sound as if docker will expire a cached layer because the (potential) result of apt-get is different, which isn&#x27;t the case.</div><br/></div></div></div></div></div></div><div id="39722740" class="c"><input type="checkbox" id="c-39722740" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#39721470">parent</a><span>|</span><a href="#39721919">prev</a><span>|</span><a href="#39722595">next</a><span>|</span><label class="collapse" for="c-39722740">[-]</label><label class="expand" for="c-39722740">[2 more]</label></div><br/><div class="children"><div class="content">I would rephrase this as:<p>The Dockerfile format imposes a hierarchical relationship between layers. This quickly becomes very annoying, since dependencies usually form dependency graphs, not dependency trees.<p>Alternative tools, like nix (probably bazel too), are not bound in the same way. They can achieve fine grained caching by mapping their dependency graph to docker layers, which is something that can not be expressed with a Dockerfile.</div><br/><div id="39723577" class="c"><input type="checkbox" id="c-39723577" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#39721470">root</a><span>|</span><a href="#39722740">parent</a><span>|</span><a href="#39722595">next</a><span>|</span><label class="collapse" for="c-39723577">[-]</label><label class="expand" for="c-39723577">[1 more]</label></div><br/><div class="children"><div class="content">Steps in a stage are hierarchical.<p>The final result need not be.
You can build a bunch of things then merge the results in a final stage without any hierarchy (this is &quot;COPY --link&quot; in a Dockerfile).</div><br/></div></div></div></div></div></div><div id="39722595" class="c"><input type="checkbox" id="c-39722595" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#39721470">prev</a><span>|</span><a href="#39724221">next</a><span>|</span><label class="collapse" for="c-39722595">[-]</label><label class="expand" for="c-39722595">[5 more]</label></div><br/><div class="children"><div class="content">I spent a half a day or so relatively recently trying to build our CI base image with Nix (at the recommendation of our infra team), but it was huge, and some stuff didn&#x27;t work because of linking issues.<p>One issue that really bugged me was to build multi-arch images, it actually wants to execute stuff as the other architecture, and only supports using qemu with hardware virtualization for that.  My build machine (and workstation) is a VM, so I don&#x27;t have that.  I do have binfmt-misc, though, so if you just happened to fork and exec the arm64 &quot;mkdir&quot; to &quot;mkdir &#x2F;tmp&quot;, it would have worked.  Of course, this implementation is a travesty when docker layers are just tar files, and you can make the directory like this:<p><pre><code>    echo &quot;tmp uid=0 gid=0 time=0 mode=0755 type=dir&quot; | bsdtar -cf - @-
</code></pre>
(As an aside, I&#x27;m sure this exact layer already exists somewhere.  So users probably don&#x27;t even have to download it.)<p>Every time I try nix, I feel like it&#x27;s just a few months away from being something I&#x27;d use regularly.  nixpkgs has a lot of packages, everything you could ever want.  They all install OK onto my workstation.  But &quot;I need bash, python, build-essential, and Bazel&quot; doesn&#x27;t seem like something they&#x27;re targeting the docker image builder at.  I guess people just want to put their go binary in a docker image and ... you don&#x27;t need nix for that.  Pull distroless, stick your application in a tar file, and there&#x27;s your container.  (I personally use `rules_oci` with Bazel... but that&#x27;s all it does behind the scenes.  It just has some smarts about knowing how to build different binaries for different architectures and assembling and image index yaml file to push to your registry.)</div><br/><div id="39724298" class="c"><input type="checkbox" id="c-39724298" checked=""/><div class="controls bullet"><span class="by">operator-name</span><span>|</span><a href="#39722595">parent</a><span>|</span><a href="#39723217">next</a><span>|</span><label class="collapse" for="c-39724298">[-]</label><label class="expand" for="c-39724298">[1 more]</label></div><br/><div class="children"><div class="content">What did your final Nix and Docker file look like, and did you have to use `buildFHSEnv` at all to support the odd 3rd party binaries?<p>I think Nix really needs some articles outlining how to play well and smoothly transition from an existing system piece by piece.</div><br/></div></div><div id="39723217" class="c"><input type="checkbox" id="c-39723217" checked=""/><div class="controls bullet"><span class="by">l0b0</span><span>|</span><a href="#39722595">parent</a><span>|</span><a href="#39724298">prev</a><span>|</span><a href="#39722702">next</a><span>|</span><label class="collapse" for="c-39723217">[-]</label><label class="expand" for="c-39723217">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt;  I spent a half a day or so relatively recently trying to build our CI base image with Nix (at the recommendation of our infra team), but it was huge, and some stuff didn&#x27;t work because of linking issues.
</code></pre>
You must be talking about the official Nix Docker image[1], which indeed is huge. I&#x27;ve been using it for years for a handful of projects, but if the size is an issue you can use the method mentioned in the article and build a very minimal image with only the stuff you specify.<p>[1] <a href="https:&#x2F;&#x2F;hub.docker.com&#x2F;r&#x2F;nixos&#x2F;nix&#x2F;tags" rel="nofollow">https:&#x2F;&#x2F;hub.docker.com&#x2F;r&#x2F;nixos&#x2F;nix&#x2F;tags</a></div><br/></div></div><div id="39722702" class="c"><input type="checkbox" id="c-39722702" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#39722595">parent</a><span>|</span><a href="#39723217">prev</a><span>|</span><a href="#39722769">next</a><span>|</span><label class="collapse" for="c-39722702">[-]</label><label class="expand" for="c-39722702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; to build multi-arch images, it actually wants to execute stuff as the other architecture<p>You should be able to cross compile binaries for other architectures without actually running them. As long as the package&#x27;s build files support it of course.<p>&gt; and only supports using qemu with hardware virtualization for that<p>That doesn&#x27;t sound right. You can use qemu for architectures that be only software emulated too.<p>The minimal example is discussed here:<p><a href="https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;how-do-i-get-a-shell-nix-with-cross-compiler-and-qemu&#x2F;7658" rel="nofollow">https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;how-do-i-get-a-shell-nix-with-...</a><p>I don&#x27;t want to say it should be as simple as using pkgCross (<a href="https:&#x2F;&#x2F;nix.dev&#x2F;tutorials&#x2F;cross-compilation.html" rel="nofollow">https:&#x2F;&#x2F;nix.dev&#x2F;tutorials&#x2F;cross-compilation.html</a>), but... are some specific issues with the usual process that you&#x27;re running into?</div><br/></div></div><div id="39722769" class="c"><input type="checkbox" id="c-39722769" checked=""/><div class="controls bullet"><span class="by">bfrog</span><span>|</span><a href="#39722595">parent</a><span>|</span><a href="#39722702">prev</a><span>|</span><a href="#39724221">next</a><span>|</span><label class="collapse" for="c-39722769">[-]</label><label class="expand" for="c-39722769">[1 more]</label></div><br/><div class="children"><div class="content">Hmm? Cross compiling to docker images is exactly what I used nix for. I even had musl being used, it was the smallest image I could build with any tool and built the images quickly and consistently in ci with caching working well.<p>I never saw went being used so im a bit confused where that came into play for you</div><br/></div></div></div></div><div id="39724221" class="c"><input type="checkbox" id="c-39724221" checked=""/><div class="controls bullet"><span class="by">ildjarn</span><span>|</span><a href="#39722595">prev</a><span>|</span><a href="#39724082">next</a><span>|</span><label class="collapse" for="c-39724221">[-]</label><label class="expand" for="c-39724221">[2 more]</label></div><br/><div class="children"><div class="content">What the post misses is that lots of packages are not available on Nix, but everything is available on Docker automatically.<p>If what you need is available, however, then it can be so much better.</div><br/><div id="39724270" class="c"><input type="checkbox" id="c-39724270" checked=""/><div class="controls bullet"><span class="by">georgyo</span><span>|</span><a href="#39724221">parent</a><span>|</span><a href="#39724082">next</a><span>|</span><label class="collapse" for="c-39724270">[-]</label><label class="expand" for="c-39724270">[1 more]</label></div><br/><div class="children"><div class="content">What is automatic about docker? Do you mean other people have already put in the work? Or do you mean that it&#x27;s more trivial to pip&#x2F;npm&#x2F;cargo install stuff?</div><br/></div></div></div></div><div id="39724082" class="c"><input type="checkbox" id="c-39724082" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#39724221">prev</a><span>|</span><a href="#39723030">next</a><span>|</span><label class="collapse" for="c-39724082">[-]</label><label class="expand" for="c-39724082">[1 more]</label></div><br/><div class="children"><div class="content">I wanted to love nix. It seems like something I would like. I tried to compile rust using nix on my mac. Didn&#x27;t work, known bug. I reinstalled my desktop to use nixos. I got lost between flakes, nixpkgs, homemanager. I managed to get vscode installed but when I added the nix extension (declared in nix) it would refuse to run vscode... It&#x27;s just not a good experience so I reinstalled arch</div><br/></div></div><div id="39723030" class="c"><input type="checkbox" id="c-39723030" checked=""/><div class="controls bullet"><span class="by">denysvitali</span><span>|</span><a href="#39724082">prev</a><span>|</span><a href="#39721155">next</a><span>|</span><label class="collapse" for="c-39723030">[-]</label><label class="expand" for="c-39723030">[4 more]</label></div><br/><div class="children"><div class="content">Unfortunately the result of a Nix Docker image is an image that is 100+ MB for no particular reason :(</div><br/><div id="39723159" class="c"><input type="checkbox" id="c-39723159" checked=""/><div class="controls bullet"><span class="by">l0b0</span><span>|</span><a href="#39723030">parent</a><span>|</span><a href="#39723155">next</a><span>|</span><label class="collapse" for="c-39723159">[-]</label><label class="expand" for="c-39723159">[2 more]</label></div><br/><div class="children"><div class="content">Where on Earth are you getting that result from? [1] gives an 11 MB image.<p>[1] <a href="https:&#x2F;&#x2F;nix.dev&#x2F;tutorials&#x2F;nixos&#x2F;building-and-running-docker-images.html#build-your-first-container" rel="nofollow">https:&#x2F;&#x2F;nix.dev&#x2F;tutorials&#x2F;nixos&#x2F;building-and-running-docker-...</a></div><br/><div id="39723883" class="c"><input type="checkbox" id="c-39723883" checked=""/><div class="controls bullet"><span class="by">denysvitali</span><span>|</span><a href="#39723030">root</a><span>|</span><a href="#39723159">parent</a><span>|</span><a href="#39723155">next</a><span>|</span><label class="collapse" for="c-39723883">[-]</label><label class="expand" for="c-39723883">[1 more]</label></div><br/><div class="children"><div class="content">From experience - but I&#x27;m more than happy to be proven wrong as I would love to build all the Docker images with Nix.<p>What you linked is the equivalent of:<p>FROM scratch<p>COPY hello-world &#x2F;hello-world<p>Of course that&#x27;s small (hello-world is statically linked).
Try to add coreutils (or any other small package) and you&#x27;ll see what I mean. In my experience the size of a Docker image built with some nix packages is greater than the Debian counterpart. I don&#x27;t know why though.</div><br/></div></div></div></div><div id="39723155" class="c"><input type="checkbox" id="c-39723155" checked=""/><div class="controls bullet"><span class="by">TeeMassive</span><span>|</span><a href="#39723030">parent</a><span>|</span><a href="#39723159">prev</a><span>|</span><a href="#39721155">next</a><span>|</span><label class="collapse" for="c-39723155">[-]</label><label class="expand" for="c-39723155">[1 more]</label></div><br/><div class="children"><div class="content">There are ways to properly build a nix container image so this kind of things doesn&#x27;t happen. You&#x27;ll find plenty of projects on GitHub dedicated to only that.</div><br/></div></div></div></div><div id="39721155" class="c"><input type="checkbox" id="c-39721155" checked=""/><div class="controls bullet"><span class="by">j-bos</span><span>|</span><a href="#39723030">prev</a><span>|</span><a href="#39721223">next</a><span>|</span><label class="collapse" for="c-39721155">[-]</label><label class="expand" for="c-39721155">[2 more]</label></div><br/><div class="children"><div class="content">I like the article but had a hard time following the specifics of the configs and commamds. Feels like it&#x27;s more meant for people already familiar with nix, or sufficiently interested to study up while reading</div><br/><div id="39722612" class="c"><input type="checkbox" id="c-39722612" checked=""/><div class="controls bullet"><span class="by">earthling8118</span><span>|</span><a href="#39721155">parent</a><span>|</span><a href="#39721223">next</a><span>|</span><label class="collapse" for="c-39722612">[-]</label><label class="expand" for="c-39722612">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very interesting, because as someone familiar with nix my take was that this was information I considered to be aimed at people who weren&#x27;t familiar.</div><br/></div></div></div></div><div id="39721223" class="c"><input type="checkbox" id="c-39721223" checked=""/><div class="controls bullet"><span class="by">febed</span><span>|</span><a href="#39721155">prev</a><span>|</span><a href="#39720629">next</a><span>|</span><label class="collapse" for="c-39721223">[-]</label><label class="expand" for="c-39721223">[3 more]</label></div><br/><div class="children"><div class="content">I didn’t fully grok how this works - what is the base image for the generated image? Also wouldn’t the image size be large if the glibc is copied over again</div><br/><div id="39721300" class="c"><input type="checkbox" id="c-39721300" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39721223">parent</a><span>|</span><a href="#39720629">next</a><span>|</span><label class="collapse" for="c-39721300">[-]</label><label class="expand" for="c-39721300">[2 more]</label></div><br/><div class="children"><div class="content">&gt; what is the base image for the generated image?<p>Default is none (i.e. like &quot;FROM scratch&quot; in a Dockerfile); you can specify a baseImage if needed, but I haven&#x27;t had to yet.  It works by copying parts of the nix store into the image as needed, but see also below.<p>&gt; wouldn’t the image size be large if the glibc is copied over again<p>The original Nix docker-tools buildImage did suffer from poor reuse of common dependencies.  Docker already has a way to reuse parts of images (e.g. if you build 7 images where the first N lines of a Dockerfile are the same, the 7 images will use a shared store for the results of running the first N lines). There are several backends for Docker storage that accomplish this in various ways (e.g. FS overlays, tricks with ZFS&#x2F;btrfs snapshots).<p>Nix docker-tools now has a &quot;buildLayeredImage&quot; that uses this ability of Docker to share much of the storage for the dependencies, so if you build several images that all rely on glibc, you only pay the cost of storing glibc in docker once.</div><br/><div id="39721441" class="c"><input type="checkbox" id="c-39721441" checked=""/><div class="controls bullet"><span class="by">febed</span><span>|</span><a href="#39721223">root</a><span>|</span><a href="#39721300">parent</a><span>|</span><a href="#39720629">next</a><span>|</span><label class="collapse" for="c-39721441">[-]</label><label class="expand" for="c-39721441">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, that made the article clearer for me</div><br/></div></div></div></div></div></div><div id="39720629" class="c"><input type="checkbox" id="c-39720629" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39721223">prev</a><span>|</span><a href="#39720622">next</a><span>|</span><label class="collapse" for="c-39720629">[-]</label><label class="expand" for="c-39720629">[3 more]</label></div><br/><div class="children"><div class="content">No discussion about Nix-built containers is complete without mentioning nix2container:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nlewo&#x2F;nix2container">https:&#x2F;&#x2F;github.com&#x2F;nlewo&#x2F;nix2container</a><p>It is <i>truly magical</i> for handling large, multi-layered containers. Instead of building the container archives themselves and storing them in the nix store, it builds a JSON manifest that is consumed by a lightly patched version of skopeo that streams the layers directly to either your local container engine or the registry.<p>This means you never rebuild or reupload a container layer that is unchanged.<p>Disclosure: I contributed a change in nix2container that allows cheaply pulling non-Nix layers into the build, just using the content hashes from their registry manifests.</div><br/><div id="39722311" class="c"><input type="checkbox" id="c-39722311" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#39720629">parent</a><span>|</span><a href="#39720622">next</a><span>|</span><label class="collapse" for="c-39722311">[-]</label><label class="expand" for="c-39722311">[2 more]</label></div><br/><div class="children"><div class="content">Nixpkgs&#x27; streamDockerImage does something similar, instead of storing a multi-layer tarball it produces a script that cats them all together on demand, ready to feed into `docker load` or whatever.</div><br/><div id="39723366" class="c"><input type="checkbox" id="c-39723366" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39720629">root</a><span>|</span><a href="#39722311">parent</a><span>|</span><a href="#39720622">next</a><span>|</span><label class="collapse" for="c-39723366">[-]</label><label class="expand" for="c-39723366">[1 more]</label></div><br/><div class="children"><div class="content">In that case streamDockerImage produces script that you run then you pipe output to skopeo or docker.<p>nix2container wraps all of that and it automatically runs it in behind the scenes when you call nix run.<p>The whole image generation is much more efficient as well. In the standard streamDockerImage you get a script that generates a docker layers and the image. In nix2container all layers are stored in nix cache so subsequent run doesn&#x27;t regenerate them. I believe that was the main goal behind this solution.<p>Another benefit (and I think it is even better than  the caching) is that it also allows you manually specify what dependencies go to each layer.<p>The automatic way that the code offers, is nice in theory, but because docker has a limit of 128 layers, in practice it starts nicely then the last layer is a clump of remaining dependencies that didn&#x27;t fit in previous layers.<p>With nix2container I managed for example to create the first layer which contains just Python and all of its dependencies, then the next layer are my application dependencies (Python packages) the last layer is my application.<p>With this approach a simple bugfix in the application only replaces the last layer that&#x27;s the size of a few kb. Only a change of Python version will rebuild the whole thing.</div><br/></div></div></div></div></div></div><div id="39720622" class="c"><input type="checkbox" id="c-39720622" checked=""/><div class="controls bullet"><span class="by">madjam002</span><span>|</span><a href="#39720629">prev</a><span>|</span><a href="#39723884">next</a><span>|</span><label class="collapse" for="c-39720622">[-]</label><label class="expand" for="c-39720622">[4 more]</label></div><br/><div class="children"><div class="content">Does anyone here have any experience using <a href="https:&#x2F;&#x2F;github.com&#x2F;pdtpartners&#x2F;nix-snapshotter">https:&#x2F;&#x2F;github.com&#x2F;pdtpartners&#x2F;nix-snapshotter</a> ?<p>I build a lot of Docker images using Nix, and while yes it’s generally more pleasant than using Dockerfiles, the 128 layer limit is really annoying and easy to hit when you start building images with Nix. The workaround of grouping store paths makes poor use of storage and bandwidth.</div><br/><div id="39721608" class="c"><input type="checkbox" id="c-39721608" checked=""/><div class="controls bullet"><span class="by">hinshun</span><span>|</span><a href="#39720622">parent</a><span>|</span><a href="#39720654">next</a><span>|</span><label class="collapse" for="c-39721608">[-]</label><label class="expand" for="c-39721608">[2 more]</label></div><br/><div class="children"><div class="content">Author of nix-snapshotter here.<p>Yes, one of the main downsides of Docker images using Nix is the 128 layer limit. It means we have to use a heuristic to combine packages into the same layer and losing Nix’s package granularity. When building containers with Nix packages already on a Nix binary cache you also have to transform the Nix packages into layer tarballs effectively doubling the storage requirements.<p>Nix-snapshotter brings native understanding of Nix packages to the container ecosystem so the runtime prepares the container root filesystem directly from the Nix store. This means docker pull == Nix substitution and also at Nix package granularity. It goes a bit further with Kubernetes integration that you can read about in the repo.<p>Let me know if you have any other questions!</div><br/><div id="39724020" class="c"><input type="checkbox" id="c-39724020" checked=""/><div class="controls bullet"><span class="by">k8svet</span><span>|</span><a href="#39720622">root</a><span>|</span><a href="#39721608">parent</a><span>|</span><a href="#39720654">next</a><span>|</span><label class="collapse" for="c-39724020">[-]</label><label class="expand" for="c-39724020">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the state of deployment for something like nix-snapshotter nowadays (with the realization that the answer depends on which of N k8s install methods might be in use)?<p>I assume it&#x27;s mostly in the field of ... &quot;you&#x27;re making a semi-large investment on this enough that you&#x27;re doing semi-custom kubernetes deployments with custom containerd?&quot;<p>Or maybe the thought is nix-snapshotter users are running k8s&#x2F;kubelet with nixos anyway so its not a big deal to swapout&#x2F;add containerd config?</div><br/></div></div></div></div><div id="39720654" class="c"><input type="checkbox" id="c-39720654" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39720622">parent</a><span>|</span><a href="#39721608">prev</a><span>|</span><a href="#39723884">next</a><span>|</span><label class="collapse" for="c-39720654">[-]</label><label class="expand" for="c-39720654">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t tried it yet as I need to produce containers that can work on public cloud k8s, but it definitely looks like the way to go. All the existing methods for grouping store paths into layers are finnicky, brittle, and non-optimal.</div><br/></div></div></div></div><div id="39723884" class="c"><input type="checkbox" id="c-39723884" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#39720622">prev</a><span>|</span><a href="#39720745">next</a><span>|</span><label class="collapse" for="c-39723884">[-]</label><label class="expand" for="c-39723884">[1 more]</label></div><br/><div class="children"><div class="content">I like nspawn over docker because it doesn&#x27;t use the layered file system thing.<p>Instead, it&#x27;s just a simple root directory placed somewhere and you run the container on that.  Much more straightforward.</div><br/></div></div><div id="39720745" class="c"><input type="checkbox" id="c-39720745" checked=""/><div class="controls bullet"><span class="by">tetris11</span><span>|</span><a href="#39723884">prev</a><span>|</span><a href="#39723808">next</a><span>|</span><label class="collapse" for="c-39720745">[-]</label><label class="expand" for="c-39720745">[6 more]</label></div><br/><div class="children"><div class="content">Guix is also pretty good at this, only lacking up to date packages that one would want to build an image with</div><br/><div id="39722457" class="c"><input type="checkbox" id="c-39722457" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39720745">parent</a><span>|</span><a href="#39720811">next</a><span>|</span><label class="collapse" for="c-39722457">[-]</label><label class="expand" for="c-39722457">[4 more]</label></div><br/><div class="children"><div class="content">It is very easy to overload package versions locally for your needs, and it&#x27;s quite easy to push that upstream to Guix so that others may benefit as well :)</div><br/><div id="39723474" class="c"><input type="checkbox" id="c-39723474" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#39720745">root</a><span>|</span><a href="#39722457">parent</a><span>|</span><a href="#39720811">next</a><span>|</span><label class="collapse" for="c-39723474">[-]</label><label class="expand" for="c-39723474">[3 more]</label></div><br/><div class="children"><div class="content">Can you explain (or point to an explanation) of exactly how to do that?  The Guix versions of Erlang and Elixir are way out of date, and I would like to push a fix.</div><br/><div id="39723555" class="c"><input type="checkbox" id="c-39723555" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39720745">root</a><span>|</span><a href="#39723474">parent</a><span>|</span><a href="#39720811">next</a><span>|</span><label class="collapse" for="c-39723555">[-]</label><label class="expand" for="c-39723555">[2 more]</label></div><br/><div class="children"><div class="content">See here[0] for pushing a fix, here[1] for the anatomy of a package definition (often you only need to bump the version number and update the hash, but compilers may be a bit more involved). It may be useful to define package variants[2], which is what I do for some packages locally. You can also see this page[3] for using ad-hoc package variants using command line flags. Hope this helps :)<p>[0] <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Contributing.html" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Contributing....</a><p>[1] <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Defining-Packages.html" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Defining-Pack...</a><p>[2] <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Defining-Package-Variants.html" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Defining-Pack...</a><p>[3] <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Package-Transformation-Options.html" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;devel&#x2F;en&#x2F;html_node&#x2F;Package-Trans...</a></div><br/><div id="39723681" class="c"><input type="checkbox" id="c-39723681" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#39720745">root</a><span>|</span><a href="#39723555">parent</a><span>|</span><a href="#39720811">next</a><span>|</span><label class="collapse" for="c-39723681">[-]</label><label class="expand" for="c-39723681">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the info, I will look into these links and see if I can push an update to Erlang and Elixir in the coming days.  :)</div><br/></div></div></div></div></div></div></div></div><div id="39720811" class="c"><input type="checkbox" id="c-39720811" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#39720745">parent</a><span>|</span><a href="#39722457">prev</a><span>|</span><a href="#39723808">next</a><span>|</span><label class="collapse" for="c-39720811">[-]</label><label class="expand" for="c-39720811">[1 more]</label></div><br/><div class="children"><div class="content">This is my one gripe with Guix.  Alas, we (apparently) can&#x27;t have it all!</div><br/></div></div></div></div><div id="39723808" class="c"><input type="checkbox" id="c-39723808" checked=""/><div class="controls bullet"><span class="by">asmor</span><span>|</span><a href="#39720745">prev</a><span>|</span><a href="#39720792">next</a><span>|</span><label class="collapse" for="c-39723808">[-]</label><label class="expand" for="c-39723808">[1 more]</label></div><br/><div class="children"><div class="content">Little known (possibly unintended) feature, but you can put the `toplevel` attribute of a nixosSystem into docker image `contents`, which lets you use NixOS modules to set things up. Just be sure to import the minimal preset, because those images get large.<p>Unfortunately booting the entire system with &#x2F;init is largely broken, especially without --privileged. This would be an amazing feature if it didn&#x27;t require so much extra tinkering.</div><br/></div></div><div id="39720792" class="c"><input type="checkbox" id="c-39720792" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#39723808">prev</a><span>|</span><a href="#39723477">next</a><span>|</span><label class="collapse" for="c-39720792">[-]</label><label class="expand" for="c-39720792">[1 more]</label></div><br/><div class="children"><div class="content">I just wanted to chime in here and say that Guix also has a nice and easy-to-use Docker option with &quot;guix pack -f docker&quot; [1].  Guix also has the advantage of using an already-used language (Guile&#x2F;Scheme) rather than its own bespoke one. :)<p>[1] <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;en&#x2F;html_node&#x2F;Invoking-guix-pack.html" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;manual&#x2F;en&#x2F;html_node&#x2F;Invoking-guix-pack....</a></div><br/></div></div><div id="39723477" class="c"><input type="checkbox" id="c-39723477" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39720792">prev</a><span>|</span><a href="#39720954">next</a><span>|</span><label class="collapse" for="c-39723477">[-]</label><label class="expand" for="c-39723477">[5 more]</label></div><br/><div class="children"><div class="content">I really like Bazel (rules_oci) for building containers.<p>It&#x27;s the way building containers &quot;&quot;should&quot;&quot; be.<p>Here&#x27;s my base image, here&#x27;s my files, here&#x27;s my command, write the into an image.</div><br/><div id="39723951" class="c"><input type="checkbox" id="c-39723951" checked=""/><div class="controls bullet"><span class="by">kmarc</span><span>|</span><a href="#39723477">parent</a><span>|</span><a href="#39723780">next</a><span>|</span><label class="collapse" for="c-39723951">[-]</label><label class="expand" for="c-39723951">[2 more]</label></div><br/><div class="children"><div class="content">As many bazel rules, rules_oci&#x27;s predecessor (rules_docker) was an unmaintained spagetti of hell, now we are pushed to rules_oci, and it&#x27;s rpmtree recommended way of installing rpms which then in turn don&#x27;t support post install script...<p>All this bazel-is-our-savior complex burns down when we want to build a tiny bit complicated thing with it. And we unfortunately do try to do that (our devbox image), which with full caching takes long minutes to an hour, and it&#x27;s a freaking thousands pine mess instead of using a lined dockerfioe with pinned versions.<p>I absolutely hate bazel and its broken unmaintained Google-abandoned rulesets and I wish we either used either Docker or Buck2 for everything.</div><br/><div id="39724042" class="c"><input type="checkbox" id="c-39724042" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39723477">root</a><span>|</span><a href="#39723951">parent</a><span>|</span><a href="#39723780">next</a><span>|</span><label class="collapse" for="c-39724042">[-]</label><label class="expand" for="c-39724042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unmaintained spagetti of hell,<p>rules_docker was fundamentally flawed -- and overreaching in scope -- in ways that rules_oci is not.<p>&gt; broken unmaintained Google-abandoned rulesets<p>rules_oci last commit was 12 hours ago, and it&#x27;s been actively maintained for years.<p>(This criticism is even weirder from someone pushing <i>Buck2</i>. Like, it&#x27;s a great tool. But, apparently it warranted a complete rewrite too, eh?)<p>&gt; instead of using a lined dockerfioe with pinned versions<p>You&#x27;ll pin every transitive version?<p>&gt; All this bazel-is-our-savior complex burns down when we want to build a tiny bit complicated thing with it.<p>Let me rephrase. I would not use Bazel to build images from rpm or deb packages.<p>But....<i>would you use Nix for installing rpm or deb packages?????</i> I believe you&#x27;ve lost the thread.</div><br/></div></div></div></div><div id="39723780" class="c"><input type="checkbox" id="c-39723780" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#39723477">parent</a><span>|</span><a href="#39723951">prev</a><span>|</span><a href="#39720954">next</a><span>|</span><label class="collapse" for="c-39723780">[-]</label><label class="expand" for="c-39723780">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much how building on nix works, except you don&#x27;t need base image or your application file, you specify what command to run from which package and it will be placed in the container with all runtime dependencies automatically.<p>Of course you can customize the container further if needed.</div><br/><div id="39724055" class="c"><input type="checkbox" id="c-39724055" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39723477">root</a><span>|</span><a href="#39723780">parent</a><span>|</span><a href="#39720954">next</a><span>|</span><label class="collapse" for="c-39724055">[-]</label><label class="expand" for="c-39724055">[1 more]</label></div><br/><div class="children"><div class="content">Yes, similar idea. With the objective of reproducible software.<p>(Also, you don&#x27;t need a base image for rules_oci either; most people choose to start with one.)</div><br/></div></div></div></div></div></div><div id="39720954" class="c"><input type="checkbox" id="c-39720954" checked=""/><div class="controls bullet"><span class="by">Nonoyesnoyes</span><span>|</span><a href="#39723477">prev</a><span>|</span><a href="#39720617">next</a><span>|</span><label class="collapse" for="c-39720954">[-]</label><label class="expand" for="c-39720954">[3 more]</label></div><br/><div class="children"><div class="content">The article lost me somewhere. Long intro and than just assuming too much.<p>That&#x27;s just possible due to nix being more granular? Is that right?<p>Can I really build nix from 5 years ago? No src gone? No cache server gone? Nothing?<p>I mean yeah Ubuntu as a base is shitty.</div><br/><div id="39721317" class="c"><input type="checkbox" id="c-39721317" checked=""/><div class="controls bullet"><span class="by">xena</span><span>|</span><a href="#39720954">parent</a><span>|</span><a href="#39722459">next</a><span>|</span><label class="collapse" for="c-39721317">[-]</label><label class="expand" for="c-39721317">[1 more]</label></div><br/><div class="children"><div class="content">The text is written to be spoken, it works better when I present it. I&#x27;ll have the video edited next week, that may flow better for you.</div><br/></div></div><div id="39722459" class="c"><input type="checkbox" id="c-39722459" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#39720954">parent</a><span>|</span><a href="#39721317">prev</a><span>|</span><a href="#39720617">next</a><span>|</span><label class="collapse" for="c-39722459">[-]</label><label class="expand" for="c-39722459">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like Ubuntu or Debian as a base image for docker, but it&#x27;s typically my go-to if I need glibc stuff or browser emulation.<p>Is there a better alternative like Alpine but with glibc that isn&#x27;t Debian?</div><br/></div></div></div></div><div id="39720789" class="c"><input type="checkbox" id="c-39720789" checked=""/><div class="controls bullet"><span class="by">debuggerpk</span><span>|</span><a href="#39720617">prev</a><span>|</span><a href="#39723593">next</a><span>|</span><label class="collapse" for="c-39720789">[-]</label><label class="expand" for="c-39720789">[7 more]</label></div><br/><div class="children"><div class="content">horrible, horrible font on the website!</div><br/><div id="39721257" class="c"><input type="checkbox" id="c-39721257" checked=""/><div class="controls bullet"><span class="by">mmh0000</span><span>|</span><a href="#39720789">parent</a><span>|</span><a href="#39722629">next</a><span>|</span><label class="collapse" for="c-39721257">[-]</label><label class="expand" for="c-39721257">[5 more]</label></div><br/><div class="children"><div class="content">What a weird thing to complain about.<p>Just override the font if you dislike it that much. That&#x27;s the great thing about the interwebs, it&#x27;s all just text, you can format it however you want.<p>Assuming you&#x27;re using something based off chrome: <a href="https:&#x2F;&#x2F;chromewebstore.google.com&#x2F;detail&#x2F;font-changer&#x2F;obgkjikcnonokgaiablbenkgjcdbknna" rel="nofollow">https:&#x2F;&#x2F;chromewebstore.google.com&#x2F;detail&#x2F;font-changer&#x2F;obgkji...</a><p>Or Firefox:
<a href="https:&#x2F;&#x2F;addons.mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;addon&#x2F;refont&#x2F;" rel="nofollow">https:&#x2F;&#x2F;addons.mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;addon&#x2F;refont&#x2F;</a></div><br/><div id="39722290" class="c"><input type="checkbox" id="c-39722290" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#39720789">root</a><span>|</span><a href="#39721257">parent</a><span>|</span><a href="#39722499">next</a><span>|</span><label class="collapse" for="c-39722290">[-]</label><label class="expand" for="c-39722290">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually a smooth readable (but tall-and-skinny) font on my personal laptop, and a pixelated mess on my work laptop; I&#x27;ve never figured out why... Oh, huh, they&#x27;re using a custom font: <a href="https:&#x2F;&#x2F;xeiaso.net&#x2F;blog&#x2F;iaso-fonts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xeiaso.net&#x2F;blog&#x2F;iaso-fonts&#x2F;</a> so that should actually be consistent. (After the weekend I&#x27;ll poke at it on the other laptop and see what&#x27;s up.)<p>What I&#x27;m getting at is that they might (unintentionally) be complaining about a rendering bug and not the actual font...</div><br/><div id="39722766" class="c"><input type="checkbox" id="c-39722766" checked=""/><div class="controls bullet"><span class="by">xena</span><span>|</span><a href="#39720789">root</a><span>|</span><a href="#39722290">parent</a><span>|</span><a href="#39722499">next</a><span>|</span><label class="collapse" for="c-39722766">[-]</label><label class="expand" for="c-39722766">[2 more]</label></div><br/><div class="children"><div class="content">What browser?</div><br/><div id="39724336" class="c"><input type="checkbox" id="c-39724336" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#39720789">root</a><span>|</span><a href="#39722766">parent</a><span>|</span><a href="#39722499">next</a><span>|</span><label class="collapse" for="c-39724336">[-]</label><label class="expand" for="c-39724336">[1 more]</label></div><br/><div class="children"><div class="content">google chrome in both cases.</div><br/></div></div></div></div></div></div><div id="39722499" class="c"><input type="checkbox" id="c-39722499" checked=""/><div class="controls bullet"><span class="by">mrd3v0</span><span>|</span><a href="#39720789">root</a><span>|</span><a href="#39721257">parent</a><span>|</span><a href="#39722290">prev</a><span>|</span><a href="#39722629">next</a><span>|</span><label class="collapse" for="c-39722499">[-]</label><label class="expand" for="c-39722499">[1 more]</label></div><br/><div class="children"><div class="content">What a neat reply I am going to use whenever valid criticism about he readability or accessibility of my websites arises.<p>&quot;Just use an extension that changes the website bro!&quot;</div><br/></div></div></div></div><div id="39722629" class="c"><input type="checkbox" id="c-39722629" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#39720789">parent</a><span>|</span><a href="#39721257">prev</a><span>|</span><a href="#39723593">next</a><span>|</span><label class="collapse" for="c-39722629">[-]</label><label class="expand" for="c-39722629">[1 more]</label></div><br/><div class="children"><div class="content">The font is a custom build of Iosevka, which is almost certainly inspired by the commercial font Pragmata Pro (<a href="https:&#x2F;&#x2F;fsd.it&#x2F;shop&#x2F;fonts&#x2F;pragmatapro&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fsd.it&#x2F;shop&#x2F;fonts&#x2F;pragmatapro&#x2F;</a>). When Pragmata Pro was first released a little over 10 years ago, it sold for around $400 (I know this because I and many, many others bought a copy back then).<p>As another commenter points out, you may have some rendering issue. Alternatively, you may just not like the font. Can&#x27;t please everyone.</div><br/></div></div></div></div><div id="39723593" class="c"><input type="checkbox" id="c-39723593" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#39720789">prev</a><span>|</span><label class="collapse" for="c-39723593">[-]</label><label class="expand" for="c-39723593">[1 more]</label></div><br/><div class="children"><div class="content">Having the author do this for a service written in Go is a mistake. Your first address for containerizing Go services should be ko: <a href="https:&#x2F;&#x2F;ko.build&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ko.build&#x2F;</a> , and similar solutions like Jib in the Java ecosystem: <a href="https:&#x2F;&#x2F;github.com&#x2F;GoogleContainerTools&#x2F;jib">https:&#x2F;&#x2F;github.com&#x2F;GoogleContainerTools&#x2F;jib</a> . No need to require everyone to install something heavy like Nix, no need for privileged containers in CI to connect to a Docker daemon so that actual commands can be executed to determine filesystem contents, just the absolute bare minimum of a manifest defining a base layer + the compiled artifacts copied into the tarball at the correct positions. More languages should support this kind of model - when you see that pnpm&#x27;s recipe (<a href="https:&#x2F;&#x2F;pnpm.io&#x2F;docker" rel="nofollow">https:&#x2F;&#x2F;pnpm.io&#x2F;docker</a>), ultimately, is to pick a pre-existing node base image, then copy artifacts in and set some manifest settings, there&#x27;s really no technical reason why something like &quot;pnpm build-container-image&quot;, without a dependency on a Docker daemon, hasn&#x27;t been implemented yet.<p>Using nix, or Dockerfile, or similar systems are, today, fundamentally additional complications to support building containerized systems that are not pure Go or pure Java etc. So we should stop recommending them as the default.</div><br/></div></div></div></div></div></div></div></body></html>