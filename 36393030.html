<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687251655311" as="style"/><link rel="stylesheet" href="styles.css?v=1687251655311"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/SubscriberLink/934940/3abb2d4086680b78/">PostgreSQL reconsiders its process-based model</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>255 comments</span></div><br/><div><div id="36394560" class="c"><input type="checkbox" id="c-36394560" checked=""/><div class="controls bullet"><span class="by">eclipticplane</span><span>|</span><a href="#36395574">next</a><span>|</span><label class="collapse" for="c-36394560">[-]</label><label class="expand" for="c-36394560">[41 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    For the record, I think this will be a disaster.  There is far too much
    code that will get broken, largely silently, and much of it is not
    under our control.
        regards, tom lane
</code></pre>
(via <a href="https:&#x2F;&#x2F;lwn.net&#x2F;ml&#x2F;pgsql-hackers&#x2F;4178104.1685978307@sss.pgh.pa.us&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lwn.net&#x2F;ml&#x2F;pgsql-hackers&#x2F;4178104.1685978307@sss.pgh....</a>)<p>If Tom Lane says it will be a disaster, I believe it will be a disaster.</div><br/><div id="36397841" class="c"><input type="checkbox" id="c-36397841" checked=""/><div class="controls bullet"><span class="by">abhibeckert</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36400056">next</a><span>|</span><label class="collapse" for="c-36397841">[-]</label><label class="expand" for="c-36397841">[19 more]</label></div><br/><div class="children"><div class="content">Reminds me of PHP 6...<p>For those who don&#x27;t follow PHP closely - that version was an attempted refactor of the string implementation which essentially shut down nearly all work on PHP for a decade, stagnating the language until it became pretty terrible compared to other options. They finally gave up and started work on PHP 7 which uses the (perfectly good) PHP 5 strings.<p>Ten years of wasted time by the best internal PHP developers crippled the project - I&#x27;m amazed it survived at all.</div><br/><div id="36400355" class="c"><input type="checkbox" id="c-36400355" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36397841">parent</a><span>|</span><a href="#36398678">next</a><span>|</span><label class="collapse" for="c-36400355">[-]</label><label class="expand" for="c-36400355">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, there&#x27;s also the case of the Lunar Module guidance software that was hard-coded to run exactly every two seconds. If the previous subroutine call was still running when the next one was due, the previous one was harshly terminated (with weird side effects).<p>One of the main programmers suggested making it so that the next guidance routine wouldn&#x27;t run until the previous one was done. This would make the code less sensitive to race conditions and allow more useful functionality for the pilots (who were the actual users and did seem to want it). However everyone assumed the two-second constant was implicitly embedded everywhere.<p>It wasn&#x27;t -- only in a few places -- and with that fixed the code got more general and the proof of concept ran better than ever in about every simulator available. The amount of control it gave pilots was years ahead of the curve. But it never got a chance to fly on a real mission because what was there was &quot;good enough&quot; and nobody bothered to try.<p>In our combined comments there&#x27;s a lesson about growing experiments and figuring out how to achieve failure quickly.</div><br/></div></div><div id="36398678" class="c"><input type="checkbox" id="c-36398678" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36397841">parent</a><span>|</span><a href="#36400355">prev</a><span>|</span><a href="#36398126">next</a><span>|</span><label class="collapse" for="c-36398678">[-]</label><label class="expand" for="c-36398678">[13 more]</label></div><br/><div class="children"><div class="content"><i>Things You Should Never Do</i><p><a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-never-do-part-i&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-...</a><p>An oldie but a goodie</div><br/><div id="36399569" class="c"><input type="checkbox" id="c-36399569" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36398678">parent</a><span>|</span><a href="#36399638">next</a><span>|</span><label class="collapse" for="c-36399569">[-]</label><label class="expand" for="c-36399569">[2 more]</label></div><br/><div class="children"><div class="content">I think this is a great article that takes a maximalist point and that’s its flaw.<p>You should rewrite code only when the cost of adding a new feature (one that is actually necessary) to the old codebase becomes comparable to designing your entire system from scratch to allow for that feature to be added easily. That is to say that the cost of the rewrite should become comparable to the cost of continuing development. I have been a part of a couple of rewrites like that, one of them quite complex, and yes they were warranted and yes they worked.<p>But having said that you should absolutely be conservative with rewriting code. It’s a bad habit to always jump to a rewrite.</div><br/><div id="36399958" class="c"><input type="checkbox" id="c-36399958" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399569">parent</a><span>|</span><a href="#36399638">next</a><span>|</span><label class="collapse" for="c-36399958">[-]</label><label class="expand" for="c-36399958">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s very dependent on how you use words like “rewrite” or “refactor”. The point the author makes about the two page function, and all the bug-fixes (lessons learned) makes sense only if you “rewrite” from scratch without looking at the history. You can absolutely “rewrite” the function in a manner that is “refactoring”, but will often get called “rewrite” in the real world. This may be because “refactor” is sort of this English CS term that doesn’t have a real translation or usage in many languages and “rewrite” is sort of universal for changing text, but in CS is sort of “rebuilding” things.<p>I don’t think you necessarily need to be conservative about rewriting things. We do it all the time in fact. We build something to get it out there and see the usage, and then we build it better and then we do it again. Which often involves a lot of “rewriting” but thanks to principles like SOLID’s single responsibility makes this rather easy to both do and maintain (we write a lot of semi-functional code and try to avoid using OOP unless necessary, so we don’t really use all the parts of SOLID religiously).<p>I do agree that it’s never a good idea to get into things with the mind-set of “we can do this better if we start from scratch” because you can’t.</div><br/></div></div></div></div><div id="36399638" class="c"><input type="checkbox" id="c-36399638" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36398678">parent</a><span>|</span><a href="#36399569">prev</a><span>|</span><a href="#36399596">next</a><span>|</span><label class="collapse" for="c-36399638">[-]</label><label class="expand" for="c-36399638">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Well, yes. They did. They did it by making the single worst strategic mistake that any software company can make:<p>&gt; They decided to rewrite the code from scratch.<p>Absolutely not what&#x27;s being proposed for Postgres.</div><br/><div id="36399693" class="c"><input type="checkbox" id="c-36399693" checked=""/><div class="controls bullet"><span class="by">yxre</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399638">parent</a><span>|</span><a href="#36399596">next</a><span>|</span><label class="collapse" for="c-36399693">[-]</label><label class="expand" for="c-36399693">[3 more]</label></div><br/><div class="children"><div class="content">Process isolation affects so many things in C. The strategy change is going to require changes to so many modules that it will either be a re-write or buggy.<p>In practical terms, if every line needs to be audited and updated, it is a re-write</div><br/><div id="36399812" class="c"><input type="checkbox" id="c-36399812" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399693">parent</a><span>|</span><a href="#36400057">next</a><span>|</span><label class="collapse" for="c-36399812">[-]</label><label class="expand" for="c-36399812">[1 more]</label></div><br/><div class="children"><div class="content">What makes you think that it will require that many changes? There will be some widespread mechanical changes (which can be verified to be complete with a bit of low level work, like a script using objdump&#x2F;nm to look for non-TLS mutable variables) and some areas changing more heavily (e.g. connection establishment, crash detection, signal handling, minor details of the locking code). But large portions of the code won&#x27;t need to change. Note that we&#x2F;postgres already shares a lot of state across processes.</div><br/></div></div><div id="36400057" class="c"><input type="checkbox" id="c-36400057" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399693">parent</a><span>|</span><a href="#36399812">prev</a><span>|</span><a href="#36399596">next</a><span>|</span><label class="collapse" for="c-36400057">[-]</label><label class="expand" for="c-36400057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; either be a re-write or buggy<p>A large refactor at best. It will touch lots of parts of the code base, but the vast majority of the source code would remain intact. Otherwise they could just Rewrite it in Rust™ while they’re at it<p>&gt; if every line needs to be audited and updated, it is a re-write<p>I’m not sure why you believe every line needs to be updated. Most code is thread agnostic.</div><br/></div></div></div></div></div></div><div id="36399596" class="c"><input type="checkbox" id="c-36399596" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36398678">parent</a><span>|</span><a href="#36399638">prev</a><span>|</span><a href="#36398126">next</a><span>|</span><label class="collapse" for="c-36399596">[-]</label><label class="expand" for="c-36399596">[6 more]</label></div><br/><div class="children"><div class="content">The issue here isn&#x27;t &quot;rewriting&quot; per se but &quot;stopping development&quot;.<p>You shouldn&#x27;t stop development on your important products.<p>Letting a couple of your talented programmers loose on a greenfield reimplementation is a perfectly sane strategic move.<p>Stopping development on important products because you are 100% certain that the reimplementation will be successful by $DEADLINE is a foolish gamble.</div><br/><div id="36400854" class="c"><input type="checkbox" id="c-36400854" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399596">parent</a><span>|</span><a href="#36399745">next</a><span>|</span><label class="collapse" for="c-36400854">[-]</label><label class="expand" for="c-36400854">[1 more]</label></div><br/><div class="children"><div class="content">The big problem there is that the people you are letting loose on the alternative, are lost from the original, so O loses steam that A gains. You still have to produce bug fixes and features to _both_ O and A to keep them in sync. So you essentially have a doubled required production rate to be delivered using the same staff.<p>So in order for there to be a net gain, the gang working on the alternative have to be able to find such big wins as to being neigh impossible.<p>This is a very very hard problem in our domain. 99% of the time, we have to simply resist the urge to _just rewrite the sucker_. No! Don&#x27;t do it! (And this is incredibly hard because we all want to.)</div><br/></div></div><div id="36399745" class="c"><input type="checkbox" id="c-36399745" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399596">parent</a><span>|</span><a href="#36400854">prev</a><span>|</span><a href="#36399969">next</a><span>|</span><label class="collapse" for="c-36399745">[-]</label><label class="expand" for="c-36399745">[2 more]</label></div><br/><div class="children"><div class="content">The problem is if it snowballs</div><br/><div id="36399876" class="c"><input type="checkbox" id="c-36399876" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399745">parent</a><span>|</span><a href="#36399969">next</a><span>|</span><label class="collapse" for="c-36399876">[-]</label><label class="expand" for="c-36399876">[1 more]</label></div><br/><div class="children"><div class="content">Any project, whether it&#x27;s a &quot;rewrite&quot; or not, can succumb to scope creep and poor project management.</div><br/></div></div></div></div><div id="36399969" class="c"><input type="checkbox" id="c-36399969" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399596">parent</a><span>|</span><a href="#36399745">prev</a><span>|</span><a href="#36398126">next</a><span>|</span><label class="collapse" for="c-36399969">[-]</label><label class="expand" for="c-36399969">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t that how you end up with Python 2 and 3 though?</div><br/><div id="36400591" class="c"><input type="checkbox" id="c-36400591" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36399969">parent</a><span>|</span><a href="#36398126">next</a><span>|</span><label class="collapse" for="c-36400591">[-]</label><label class="expand" for="c-36400591">[1 more]</label></div><br/><div class="children"><div class="content">Python3 changes were many &quot;little&quot; things; some more fundamental than other (unicode str). So I guess they were able to split the work in tiny pieces and, ultimately, were able to manage the project...</div><br/></div></div></div></div></div></div></div></div><div id="36398126" class="c"><input type="checkbox" id="c-36398126" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36397841">parent</a><span>|</span><a href="#36398678">prev</a><span>|</span><a href="#36398394">next</a><span>|</span><label class="collapse" for="c-36398126">[-]</label><label class="expand" for="c-36398126">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used PHP in the past (PHP 4 and 5), as well as some simple templated projects in PHP 7. I try to keep up on news with what is happening in the PHP world, and it&#x27;s difficult because of the hate for the language. Is the solution to Unicode strings still to just use the &quot;mb_*&quot; functions?<p>I got my real professional start using PHP, and have built even financial systems in the language (since ported to .NET 6 for my ease of maintenance, and better number handling). I&#x27;m still very interested in the language itself, in case I ever have the need to freelance or provide a solution to a client that can&#x27;t afford what I can build in .NET (although to be honest, at this point I&#x27;m roughly able to code at the same speed in .NET as in PHP, but with the added type-safety, although I know PHP has really stepped up in providing this).</div><br/><div id="36399873" class="c"><input type="checkbox" id="c-36399873" checked=""/><div class="controls bullet"><span class="by">Hayvok</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36398126">parent</a><span>|</span><a href="#36398394">next</a><span>|</span><label class="collapse" for="c-36399873">[-]</label><label class="expand" for="c-36399873">[1 more]</label></div><br/><div class="children"><div class="content">I believe so - most (all?) string functions have an mb_ equivalent, for working on multibyte strings.<p>Regular PHP strings are actually pretty great, since you can treat them like byte arrays. Fun fact: PHPs streaming API has an “in-memory” option and it’s… just a string under the hood.<p>Just don’t forget to use multibyte functions when you’re handling things like user input.</div><br/></div></div></div></div><div id="36398394" class="c"><input type="checkbox" id="c-36398394" checked=""/><div class="controls bullet"><span class="by">robomc</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36397841">parent</a><span>|</span><a href="#36398126">prev</a><span>|</span><a href="#36400056">next</a><span>|</span><label class="collapse" for="c-36398394">[-]</label><label class="expand" for="c-36398394">[2 more]</label></div><br/><div class="children"><div class="content">I have the &quot;Professional PHP6&quot; book which I feel like should be a collectors item or something.<p>Weird book IMO, because it has <i>a lot</i> of content that&#x27;s just about general software development, rather than anything to do with PHP specifically, or the theoretical PHP6 APIs in particular.</div><br/><div id="36400055" class="c"><input type="checkbox" id="c-36400055" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36398394">parent</a><span>|</span><a href="#36400056">next</a><span>|</span><label class="collapse" for="c-36400055">[-]</label><label class="expand" for="c-36400055">[1 more]</label></div><br/><div class="children"><div class="content">PHP used to be the first computer language learned by people wanting to create a scripted web page. This was more true in the 90s but maybe it stuck. So it would be OK to add some general guidance about writing software and organizing projects.</div><br/></div></div></div></div></div></div><div id="36400056" class="c"><input type="checkbox" id="c-36400056" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36397841">prev</a><span>|</span><a href="#36400477">next</a><span>|</span><label class="collapse" for="c-36400056">[-]</label><label class="expand" for="c-36400056">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    I don&#x27;t expect you or others to buy into any particular code change at 
    this point, or to contribute time into it. Just to accept that it&#x27;s a 
    worthwhile goal. If the implementation turns out to be a disaster, then 
    it won&#x27;t be accepted, of course. But I&#x27;m optimistic.
</code></pre>
The reply is much more reasonable than this blanket assertion of a disaster.</div><br/></div></div><div id="36400477" class="c"><input type="checkbox" id="c-36400477" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36400056">prev</a><span>|</span><a href="#36400238">next</a><span>|</span><label class="collapse" for="c-36400477">[-]</label><label class="expand" for="c-36400477">[1 more]</label></div><br/><div class="children"><div class="content">Feel like the PostgreSQL Core Team should just build a new database from scratch using what they have learned from experience instead of attempting such a fundamental architectural migration. It would give them more freedom to change things also. Call it &quot;postgendb&quot; and provide a data migrator.</div><br/></div></div><div id="36400238" class="c"><input type="checkbox" id="c-36400238" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36400477">prev</a><span>|</span><a href="#36396720">next</a><span>|</span><label class="collapse" for="c-36400238">[-]</label><label class="expand" for="c-36400238">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.<p>Without being familiar with the Postgres source, this seems to be what I call a &quot;somersault problem&quot;: hard to break down into sub-goals. I have heard that the Postgres codebase is solid which makes it easier but it&#x27;s still mature and highly complex. It doesn&#x27;t sound feasible to me.<p><a href="https:&#x2F;&#x2F;kristiandupont.medium.com&#x2F;somersault-problems-69c478199dfe" rel="nofollow noreferrer">https:&#x2F;&#x2F;kristiandupont.medium.com&#x2F;somersault-problems-69c478...</a></div><br/></div></div><div id="36396720" class="c"><input type="checkbox" id="c-36396720" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36400238">prev</a><span>|</span><a href="#36395661">next</a><span>|</span><label class="collapse" for="c-36396720">[-]</label><label class="expand" for="c-36396720">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an awful message with the only sensible reply.</div><br/></div></div><div id="36395661" class="c"><input type="checkbox" id="c-36395661" checked=""/><div class="controls bullet"><span class="by">gremlinsinc</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36396720">prev</a><span>|</span><a href="#36395679">next</a><span>|</span><label class="collapse" for="c-36395661">[-]</label><label class="expand" for="c-36395661">[3 more]</label></div><br/><div class="children"><div class="content">Maybe a better option would be finding a team to create nugres, aka a fork for this and other experiments. So that mainline remains stable.</div><br/><div id="36397840" class="c"><input type="checkbox" id="c-36397840" checked=""/><div class="controls bullet"><span class="by">mattashii</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395661">parent</a><span>|</span><a href="#36395679">next</a><span>|</span><label class="collapse" for="c-36397840">[-]</label><label class="expand" for="c-36397840">[2 more]</label></div><br/><div class="children"><div class="content">There are several forks of PostgreSQL, in various levels of license, additional features and activity. However, maintaining a fork in addition to a main project is inherently more expensive than maintaining just a single project, so adding features to new major releases of the main project is generally preferred over forking every release into its own, newly named, project. After all, that is what we have major (feature) releases and stabalization windows (beta releases) for.</div><br/><div id="36399751" class="c"><input type="checkbox" id="c-36399751" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36397840">parent</a><span>|</span><a href="#36395679">next</a><span>|</span><label class="collapse" for="c-36399751">[-]</label><label class="expand" for="c-36399751">[1 more]</label></div><br/><div class="children"><div class="content">This won&#x27;t work well for a multiyear project.. Either you have to stall the release process, divide it into smaller parts or fork.</div><br/></div></div></div></div></div></div><div id="36395679" class="c"><input type="checkbox" id="c-36395679" checked=""/><div class="controls bullet"><span class="by">datavirtue</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36395661">prev</a><span>|</span><a href="#36395590">next</a><span>|</span><label class="collapse" for="c-36395679">[-]</label><label class="expand" for="c-36395679">[1 more]</label></div><br/><div class="children"><div class="content">This should be considered a research effort, assuming it will be a complete rewrite. In light of that, you should not draw down resources from the established code base to work on it.<p>Ignoring the above, first state the explicit requirements driving this change and let people weigh in on those. This sounds like a geeky dev itch.</div><br/></div></div><div id="36395590" class="c"><input type="checkbox" id="c-36395590" checked=""/><div class="controls bullet"><span class="by">idiomaticrust</span><span>|</span><a href="#36394560">parent</a><span>|</span><a href="#36395679">prev</a><span>|</span><a href="#36395574">next</a><span>|</span><label class="collapse" for="c-36395590">[-]</label><label class="expand" for="c-36395590">[13 more]</label></div><br/><div class="children"><div class="content">He is right. Such rewrites cause a lot of problems if your compiler doesn&#x27;t help you with avoiding data races.<p>But there is another way.</div><br/><div id="36395636" class="c"><input type="checkbox" id="c-36395636" checked=""/><div class="controls bullet"><span class="by">hnarn</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395590">parent</a><span>|</span><a href="#36397875">next</a><span>|</span><label class="collapse" for="c-36395636">[-]</label><label class="expand" for="c-36395636">[10 more]</label></div><br/><div class="children"><div class="content">&gt; But there is another way.<p>Ok?</div><br/><div id="36395673" class="c"><input type="checkbox" id="c-36395673" checked=""/><div class="controls bullet"><span class="by">carstenhag</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395636">parent</a><span>|</span><a href="#36395660">next</a><span>|</span><label class="collapse" for="c-36395673">[-]</label><label class="expand" for="c-36395673">[5 more]</label></div><br/><div class="children"><div class="content">The person probably implied that Postgres should switch to another toolchain that guarantees more things at compile time, so probably Rust.</div><br/><div id="36396151" class="c"><input type="checkbox" id="c-36396151" checked=""/><div class="controls bullet"><span class="by">blincoln</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395673">parent</a><span>|</span><a href="#36396328">next</a><span>|</span><label class="collapse" for="c-36396151">[-]</label><label class="expand" for="c-36396151">[1 more]</label></div><br/><div class="children"><div class="content">If the existing code is old-school enough to use thousands of global variables in a thread-unsafe way, seems like changing it enough to compile as safe Rust code would push the &quot;non-trivial&quot; envelope pretty far.</div><br/></div></div><div id="36396328" class="c"><input type="checkbox" id="c-36396328" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395673">parent</a><span>|</span><a href="#36396151">prev</a><span>|</span><a href="#36395660">next</a><span>|</span><label class="collapse" for="c-36396328">[-]</label><label class="expand" for="c-36396328">[3 more]</label></div><br/><div class="children"><div class="content">You can take a chunk of code and just rewrite it in Rust.  You&#x27;ll learn a lot quickly by this.</div><br/><div id="36396653" class="c"><input type="checkbox" id="c-36396653" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36396328">parent</a><span>|</span><a href="#36396595">next</a><span>|</span><label class="collapse" for="c-36396653">[-]</label><label class="expand" for="c-36396653">[1 more]</label></div><br/><div class="children"><div class="content">The boundaries within database code are not clear. There are too many interlocking parts to take a nontrivial chunk and rewrite it Rust.</div><br/></div></div><div id="36396595" class="c"><input type="checkbox" id="c-36396595" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36396328">parent</a><span>|</span><a href="#36396653">prev</a><span>|</span><a href="#36395660">next</a><span>|</span><label class="collapse" for="c-36396595">[-]</label><label class="expand" for="c-36396595">[1 more]</label></div><br/><div class="children"><div class="content">It’s sort of like the inverse of the Matrix when Neo learns kung fu. You realize that you actually don’t know how to program :)</div><br/></div></div></div></div></div></div><div id="36395660" class="c"><input type="checkbox" id="c-36395660" checked=""/><div class="controls bullet"><span class="by">mycall</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395636">parent</a><span>|</span><a href="#36395673">prev</a><span>|</span><a href="#36395674">next</a><span>|</span><label class="collapse" for="c-36395660">[-]</label><label class="expand" for="c-36395660">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft SQL Server has SQLOS which is another way [0].<p>[0] <a href="https:&#x2F;&#x2F;www.thegeekdiary.com&#x2F;what-is-sql-server-operating-system-sqlos&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.thegeekdiary.com&#x2F;what-is-sql-server-operating-sy...</a></div><br/></div></div><div id="36395674" class="c"><input type="checkbox" id="c-36395674" checked=""/><div class="controls bullet"><span class="by">chc</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395636">parent</a><span>|</span><a href="#36395660">prev</a><span>|</span><a href="#36395986">next</a><span>|</span><label class="collapse" for="c-36395674">[-]</label><label class="expand" for="c-36395674">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s meant to imply the solution given in their username (&quot;idiomatic Rust&quot;).</div><br/><div id="36400824" class="c"><input type="checkbox" id="c-36400824" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395674">parent</a><span>|</span><a href="#36395986">next</a><span>|</span><label class="collapse" for="c-36400824">[-]</label><label class="expand" for="c-36400824">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I think it&#x27;s meant to imply the solution given in their username (&quot;idiomatic Rust&quot;).<p>I think &quot;Idiom: a tic (Rust)&quot; can also fit if I squint hard enough and decide it looks like a definition from an online dictionary :-)</div><br/></div></div></div></div><div id="36395986" class="c"><input type="checkbox" id="c-36395986" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395636">parent</a><span>|</span><a href="#36395674">prev</a><span>|</span><a href="#36397875">next</a><span>|</span><label class="collapse" for="c-36395986">[-]</label><label class="expand" for="c-36395986">[1 more]</label></div><br/><div class="children"><div class="content">Don’t mind the gimmick gallery (username).</div><br/></div></div></div></div><div id="36397875" class="c"><input type="checkbox" id="c-36397875" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#36394560">root</a><span>|</span><a href="#36395590">parent</a><span>|</span><a href="#36395636">prev</a><span>|</span><a href="#36396703">next</a><span>|</span><label class="collapse" for="c-36397875">[-]</label><label class="expand" for="c-36397875">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, Zig is a nice language for this</div><br/></div></div></div></div></div></div><div id="36395574" class="c"><input type="checkbox" id="c-36395574" checked=""/><div class="controls bullet"><span class="by">rburhum</span><span>|</span><a href="#36394560">prev</a><span>|</span><a href="#36393217">next</a><span>|</span><label class="collapse" for="c-36395574">[-]</label><label class="expand" for="c-36395574">[24 more]</label></div><br/><div class="children"><div class="content">Sorry if I offend anybody, but this sounds like such a bad idea. I have been running various versions of postgres in production for 15 years with thousands of processes on super beefy machines, and I can tell you without a doubt that sometimes those processes crash - specially if you are running any of the extensions. Nevertheless, Postgres has 99% of the time proven to be resilient. The idea that a bad client can bring the whole cluster down because it hit a bug sounds scary. Every try creating a spatial index on thousands&#x2F;millions of records that have nasty overly complex or badly digitized geometries? Sadly, crashes are part of that workflow, and changing this from process to threading would mean all the other clients also crashing and cutting connections. This as a potential problem because I want to avoid context switching overhead or cache misses, no thanks.</div><br/><div id="36395747" class="c"><input type="checkbox" id="c-36395747" checked=""/><div class="controls bullet"><span class="by">zeroimpl</span><span>|</span><a href="#36395574">parent</a><span>|</span><a href="#36399674">next</a><span>|</span><label class="collapse" for="c-36395747">[-]</label><label class="expand" for="c-36395747">[12 more]</label></div><br/><div class="children"><div class="content">However, it&#x27;s already the case that if a postgres process crashes, the whole cluster gets restarted. I&#x27;ve occasionally seen this message:<p><pre><code>    WARNING: terminating connection because of crash of another server process
    DETAIL: The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.
    HINT: In a moment you should be able to reconnect to the database and repeat your command.
    LOG: all server processes terminated; reinitializing</code></pre></div><br/><div id="36400852" class="c"><input type="checkbox" id="c-36400852" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395747">parent</a><span>|</span><a href="#36395972">next</a><span>|</span><label class="collapse" for="c-36400852">[-]</label><label class="expand" for="c-36400852">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  However, it&#x27;s already the case that if a postgres process crashes, the whole cluster gets restarted. I&#x27;ve occasionally seen this message:<p>Sure, but the blast radius of corruption is limited to that shared memory, not all the memory of all the processes. You can at least use the fact that a process has crashed to ensure that the corruption doesn&#x27;t spread.<p>(This is why it restarts: there is no guarantee that the shared memory is valid, so the other processes are stopped before they attempt to use that potentially invalid memory)<p>With threads, <i>all</i> memory is shared memory. A single thread that crashes can make other threads data invalid <i>before</i> the detection of the crash.</div><br/></div></div><div id="36395972" class="c"><input type="checkbox" id="c-36395972" checked=""/><div class="controls bullet"><span class="by">niccl</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395747">parent</a><span>|</span><a href="#36400852">prev</a><span>|</span><a href="#36399674">next</a><span>|</span><label class="collapse" for="c-36395972">[-]</label><label class="expand" for="c-36395972">[10 more]</label></div><br/><div class="children"><div class="content">yes, but postmaster is still running to roll back the transaction. If you crash a single multi-threaded process, you may lose postmaster as well and then sadness would ensue</div><br/><div id="36396112" class="c"><input type="checkbox" id="c-36396112" checked=""/><div class="controls bullet"><span class="by">mattashii</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36396058">next</a><span>|</span><label class="collapse" for="c-36396112">[-]</label><label class="expand" for="c-36396112">[2 more]</label></div><br/><div class="children"><div class="content">The threaded design wouldn&#x27;t necessarily be single-process, it would just not have 1 process for every connection. Things like crash detection could still be handled in a separate process. The reason to use threading in most cases is to reduce communication and switching overhead, but for low-traffic backends like a crash handler the overhead of it being a process is quite limited - when it gets triggered context switching overhead is the least of your problems.</div><br/><div id="36396632" class="c"><input type="checkbox" id="c-36396632" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36396112">parent</a><span>|</span><a href="#36396058">next</a><span>|</span><label class="collapse" for="c-36396632">[-]</label><label class="expand" for="c-36396632">[1 more]</label></div><br/><div class="children"><div class="content">Seconded. For instance, Firefox&#x27; crash reporter has always been a separate process, even at the time Firefox was mostly single-process, single-threaded. Last time I checked, this was still the case.</div><br/></div></div></div></div><div id="36396058" class="c"><input type="checkbox" id="c-36396058" checked=""/><div class="controls bullet"><span class="by">jtc331</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36396112">prev</a><span>|</span><a href="#36396415">next</a><span>|</span><label class="collapse" for="c-36396058">[-]</label><label class="expand" for="c-36396058">[1 more]</label></div><br/><div class="children"><div class="content">If you read the thread you’d see the discussion includes still having e.g. postmaster as a separate process.</div><br/></div></div><div id="36396415" class="c"><input type="checkbox" id="c-36396415" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36396058">prev</a><span>|</span><a href="#36396433">next</a><span>|</span><label class="collapse" for="c-36396415">[-]</label><label class="expand" for="c-36396415">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL can recover from abruptly aborted transactions (think &quot;pulled the power cord&quot;) by replaying the journal. This is not going to change anyway.</div><br/></div></div><div id="36396433" class="c"><input type="checkbox" id="c-36396433" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36396415">prev</a><span>|</span><a href="#36396457">next</a><span>|</span><label class="collapse" for="c-36396433">[-]</label><label class="expand" for="c-36396433">[2 more]</label></div><br/><div class="children"><div class="content">Transaction roll back is a part of the WAL.  Databases write to the disk an intent to change things, what should be changed, and a &quot;commit&quot; of the change when finished so that all changes happen as a unit.  If the DB process is interrupted during that log write then all changes associated with that transaction are rolled back.<p>Threaded vs process won&#x27;t affect that.</div><br/><div id="36396764" class="c"><input type="checkbox" id="c-36396764" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36396433">parent</a><span>|</span><a href="#36396457">next</a><span>|</span><label class="collapse" for="c-36396764">[-]</label><label class="expand" for="c-36396764">[1 more]</label></div><br/><div class="children"><div class="content">Running the whole DBMS as a bunch of threads in single process changes how fast is the recovery from some kind of temporary inconsistency. In the ideal world, this should not happen, but in reality it does and you do not want to bring the whole thing down because of some superficial data corruption.<p>On the other hand, all cases of fixable corrupted data in PostgreSQL I have seen were result of somebody doing something totally dumb (rsyncing live cluster, even between architectures), while on InnoDB it seems to happen somewhat randomly without any obvious reason of somebody doing stupid things.</div><br/></div></div></div></div><div id="36396457" class="c"><input type="checkbox" id="c-36396457" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36396433">prev</a><span>|</span><a href="#36397268">next</a><span>|</span><label class="collapse" for="c-36396457">[-]</label><label class="expand" for="c-36396457">[1 more]</label></div><br/><div class="children"><div class="content">We would still have a separate process doing that part of postmaster&#x27;s work.</div><br/></div></div><div id="36397268" class="c"><input type="checkbox" id="c-36397268" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36396457">prev</a><span>|</span><a href="#36396023">next</a><span>|</span><label class="collapse" for="c-36397268">[-]</label><label class="expand" for="c-36397268">[1 more]</label></div><br/><div class="children"><div class="content">You can still have a master control process separate from the client connections.</div><br/></div></div><div id="36396023" class="c"><input type="checkbox" id="c-36396023" checked=""/><div class="controls bullet"><span class="by">moonchrome</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36395972">parent</a><span>|</span><a href="#36397268">prev</a><span>|</span><a href="#36399674">next</a><span>|</span><label class="collapse" for="c-36396023">[-]</label><label class="expand" for="c-36396023">[1 more]</label></div><br/><div class="children"><div class="content">Restart on crash doesn&#x27;t sound that difficult to do.</div><br/></div></div></div></div></div></div><div id="36399674" class="c"><input type="checkbox" id="c-36399674" checked=""/><div class="controls bullet"><span class="by">Shorel</span><span>|</span><a href="#36395574">parent</a><span>|</span><a href="#36395747">prev</a><span>|</span><a href="#36396436">next</a><span>|</span><label class="collapse" for="c-36399674">[-]</label><label class="expand" for="c-36399674">[8 more]</label></div><br/><div class="children"><div class="content">Reading your comment makes me think it is not only a good idea, it is a necessity.<p>Relying on crashing as a bug recovery system is a good idea?  Crashing is just part of the workflow?   That&#x27;s insane, and a good argument against PostgreSQL in any production system.<p>It is possible PostgreSQL doesn&#x27;t migrate to a thread based model, and I am not arguing they should.<p>But debug and patch the causes of these crashes?  Absolutely yes, and the sooner, the better.</div><br/><div id="36399757" class="c"><input type="checkbox" id="c-36399757" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36400822">next</a><span>|</span><label class="collapse" for="c-36399757">[-]</label><label class="expand" for="c-36399757">[1 more]</label></div><br/><div class="children"><div class="content">Cars are designed with airbags?!<p>Like, they are <i>supposed</i> to crash?!?</div><br/></div></div><div id="36400822" class="c"><input type="checkbox" id="c-36400822" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36399757">prev</a><span>|</span><a href="#36399729">next</a><span>|</span><label class="collapse" for="c-36400822">[-]</label><label class="expand" for="c-36400822">[1 more]</label></div><br/><div class="children"><div class="content">A database has to handle situations outside its control, e.g. someone cutting the power to the server. That should not result in a corrupted database, and with Postgres it doesn&#x27;t.<p>The fundamental problem is that when you&#x27;re sharing memory, you cannot safely just stop a single process when encountering an unexpected error. You do not know the current state of your shared data, and if it could lead to further corruption. So restarting everything is the only safe choice in this case.</div><br/></div></div><div id="36399729" class="c"><input type="checkbox" id="c-36399729" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36400822">prev</a><span>|</span><a href="#36400426">next</a><span>|</span><label class="collapse" for="c-36399729">[-]</label><label class="expand" for="c-36399729">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Relying on crashing as a bug recovery system is a good idea? Crashing is just part of the workflow? That&#x27;s insane<p>Erlang users don&#x27;t seem to agree with you</div><br/></div></div><div id="36400426" class="c"><input type="checkbox" id="c-36400426" checked=""/><div class="controls bullet"><span class="by">dialogbox</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36399729">prev</a><span>|</span><a href="#36399843">next</a><span>|</span><label class="collapse" for="c-36400426">[-]</label><label class="expand" for="c-36400426">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s all about trade off.<p>Building a database which is never gonna crash might be possible but at what cost? Can you name any single real world system archived that? Also, there can be a regression. More tests? Sure but again, at what cost?<p>While we are trying to get there, having a crash proof architecture is also a very practical approach.</div><br/></div></div><div id="36399843" class="c"><input type="checkbox" id="c-36399843" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36400426">prev</a><span>|</span><a href="#36400243">next</a><span>|</span><label class="collapse" for="c-36399843">[-]</label><label class="expand" for="c-36399843">[1 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t want stuff to crash. But we also want data integrity to be maintained. We also want things to work. In a world with extensions written in C to support a lot of cool things with Postgres, you want to walk and chew bubblegum on this front.<p>Though to your point, a C extension can totally destroy your data in other ways, and there are likely ways to add more barriers. And hey, we should fix bugs!</div><br/></div></div><div id="36400243" class="c"><input type="checkbox" id="c-36400243" checked=""/><div class="controls bullet"><span class="by">mindwok</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36399843">prev</a><span>|</span><a href="#36399780">next</a><span>|</span><label class="collapse" for="c-36400243">[-]</label><label class="expand" for="c-36400243">[1 more]</label></div><br/><div class="children"><div class="content">They are still debugging and patching the causes. The crash detection is just to try and prevent a single bug from bringing down the whole system.</div><br/></div></div><div id="36399780" class="c"><input type="checkbox" id="c-36399780" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36399674">parent</a><span>|</span><a href="#36400243">prev</a><span>|</span><a href="#36396436">next</a><span>|</span><label class="collapse" for="c-36399780">[-]</label><label class="expand" for="c-36399780">[1 more]</label></div><br/><div class="children"><div class="content">We do fix crashes etc, even if the postgres manages to restart.<p>I think the post upthread references an out-of-core extension we don&#x27;t control, which in turn depends on many external libraries it doesn&#x27;t control either...</div><br/></div></div></div></div><div id="36396436" class="c"><input type="checkbox" id="c-36396436" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#36395574">parent</a><span>|</span><a href="#36399674">prev</a><span>|</span><a href="#36396307">next</a><span>|</span><label class="collapse" for="c-36396436">[-]</label><label class="expand" for="c-36396436">[2 more]</label></div><br/><div class="children"><div class="content">Is the actual number you got 99%? Seems low to me but I don’t really know about Postgres. That’s 3 and a half days of downtime per year, or an hour and a half per week.</div><br/><div id="36396895" class="c"><input type="checkbox" id="c-36396895" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#36395574">root</a><span>|</span><a href="#36396436">parent</a><span>|</span><a href="#36396307">next</a><span>|</span><label class="collapse" for="c-36396895">[-]</label><label class="expand" for="c-36396895">[1 more]</label></div><br/><div class="children"><div class="content">Well, hour and half per week is the amount of downtime that you need for modestly sized database (units of TB) accessed by legacy clients that have ridiculously long running transactions that interfere with autovacuum.</div><br/></div></div></div></div><div id="36396307" class="c"><input type="checkbox" id="c-36396307" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#36395574">parent</a><span>|</span><a href="#36396436">prev</a><span>|</span><a href="#36393217">next</a><span>|</span><label class="collapse" for="c-36396307">[-]</label><label class="expand" for="c-36396307">[1 more]</label></div><br/><div class="children"><div class="content">Also, reducing context switching overhead (or any other CPU overhead) is probably not gonna fix the garbage I&#x2F;O performance.</div><br/></div></div></div></div><div id="36393217" class="c"><input type="checkbox" id="c-36393217" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#36395574">prev</a><span>|</span><a href="#36394840">next</a><span>|</span><label class="collapse" for="c-36393217">[-]</label><label class="expand" for="c-36393217">[55 more]</label></div><br/><div class="children"><div class="content">I&#x27;m honestly surprised it took them so long to reach this conclusion.<p>&gt; That idea quickly loses its appeal, though, when one considers trying to create and maintain a 2,000-member structure, so the project is unlikely to go this way.<p>As repulsive as this might sound at first, I&#x27;ve seen structures of hundreds of fields work fine if the hierarchy inside them is well organized and they&#x27;re not just flat. Still, I have no real knowledge of the complexity of the code and wish the Postgres devs all the luck in the world to get this working smoothly.</div><br/><div id="36393950" class="c"><input type="checkbox" id="c-36393950" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36393311">next</a><span>|</span><label class="collapse" for="c-36393950">[-]</label><label class="expand" for="c-36393950">[10 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m honestly surprised it took them so long to reach this conclusion.<p>I&#x27;m not.  You can get a long way with conventional IPC, and OS processes provide a lot of value.  For most PostgreSQL instances the TLB flush penalty is <i>at least</i> 3rd or 4th on the list of performance concerns, <i>far</i> below prevailing storage and network bottlenecks.<p>I share the concerns cited in this LWN story.  Reworking this massive code base around multithreading carries a large amount of risk.  PostgreSQL developers will have to level up substantially to pull it off.<p>A PostgreSQL endorsed &quot;second-system&quot; with the (likely impossible, but close enough that it wouldn&#x27;t matter) goal of 100% client compatibility could be a better approach.  Adopting a memory safe language would make this both tractable and attractive (to both developers and users.)  The home truth is that any &quot;new process model&quot; effort would actually play out exactly this way, so why not be deliberate about it?</div><br/><div id="36394225" class="c"><input type="checkbox" id="c-36394225" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393950">parent</a><span>|</span><a href="#36394173">next</a><span>|</span><label class="collapse" for="c-36394225">[-]</label><label class="expand" for="c-36394225">[7 more]</label></div><br/><div class="children"><div class="content">From what I gather postgres isn&#x27;t doing conventional IPC but instead it uses shared memory, which means the same mechanism threads use but with way higher complexity</div><br/><div id="36395178" class="c"><input type="checkbox" id="c-36395178" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394225">parent</a><span>|</span><a href="#36396251">next</a><span>|</span><label class="collapse" for="c-36395178">[-]</label><label class="expand" for="c-36395178">[4 more]</label></div><br/><div class="children"><div class="content">As does Oracle, and others.  I&#x27;m aware.<p>IPC, to me, includes the conventional shared memory resources (memory segments, locks, semaphores, condition variable, etc.) used by these systems: resources acquired by processes for the purpose of communication with other processes.<p>I get it though.  The most general concept of shared memory is not coupled to an OS &quot;process.&quot;  You made me question whether my concept of term IPC was valid, however.  So what does one do when a question appears?  Stop thinking immediately and consult a language model!<p>Q: Is shared memory considered a form of interprocess communication?<p>GPT-4: Yes, shared memory is indeed considered a form of interprocess communication (IPC). It&#x27;s one of the several mechanisms provided by an operating system to allow processes to share and exchange data.<p>...<p>Why does citing ChatGPT make me feel so ugly inside?</div><br/><div id="36395389" class="c"><input type="checkbox" id="c-36395389" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395178">parent</a><span>|</span><a href="#36399463">next</a><span>|</span><label class="collapse" for="c-36395389">[-]</label><label class="expand" for="c-36395389">[1 more]</label></div><br/><div class="children"><div class="content">I always understood IPC, &quot;interprocess communication&quot;, in general sense, as anything and everything that can be used by processes to communicate with each other - of course with a narrowing provision that common use of the term refers to those means that are typically used for that purpose, are relatively efficient, and the process in question run on the same machine.<p>In that view, I always saw shared memory as IPC, in that it is a tool commonly used to exchange data between processes, but of course it is not strictly tied to any process in particular. This is similar to files, which if you squint are a form of IPC too, and are also not tied to any specific process.<p>&gt; <i>Why does citing ChatGPT make me feel so ugly inside?</i><p>That&#x27;s probably because, in cases like this, it&#x27;s not much different to stating it yourself, but is more noisy.</div><br/></div></div><div id="36399463" class="c"><input type="checkbox" id="c-36399463" checked=""/><div class="controls bullet"><span class="by">pritambarhate</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395178">parent</a><span>|</span><a href="#36395389">prev</a><span>|</span><a href="#36396045">next</a><span>|</span><label class="collapse" for="c-36399463">[-]</label><label class="expand" for="c-36399463">[1 more]</label></div><br/><div class="children"><div class="content">Without a credible source to reconfirm what ChatGPT said, one can’t really assume what ChatGPT says is correct.</div><br/></div></div><div id="36396045" class="c"><input type="checkbox" id="c-36396045" checked=""/><div class="controls bullet"><span class="by">faangsticle</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395178">parent</a><span>|</span><a href="#36399463">prev</a><span>|</span><a href="#36396251">next</a><span>|</span><label class="collapse" for="c-36396045">[-]</label><label class="expand" for="c-36396045">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why does citing ChatGPT make me feel so ugly inside?<p>Its the modern let me Google that for you. Just like people don&#x27;t care what the #1 result on Google is, they also don&#x27;t care what ChatGPT has to say about it. If they did, they&#x27;d ask it themselves.</div><br/></div></div></div></div><div id="36396251" class="c"><input type="checkbox" id="c-36396251" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394225">parent</a><span>|</span><a href="#36395178">prev</a><span>|</span><a href="#36396043">next</a><span>|</span><label class="collapse" for="c-36396251">[-]</label><label class="expand" for="c-36396251">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. Man  3 shmem if you want a journey back to some bad ideas.</div><br/></div></div><div id="36396043" class="c"><input type="checkbox" id="c-36396043" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394225">parent</a><span>|</span><a href="#36396251">prev</a><span>|</span><a href="#36394173">next</a><span>|</span><label class="collapse" for="c-36396043">[-]</label><label class="expand" for="c-36396043">[1 more]</label></div><br/><div class="children"><div class="content">What do you think IPC is?</div><br/></div></div></div></div><div id="36394173" class="c"><input type="checkbox" id="c-36394173" checked=""/><div class="controls bullet"><span class="by">atonse</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393950">parent</a><span>|</span><a href="#36394225">prev</a><span>|</span><a href="#36393311">next</a><span>|</span><label class="collapse" for="c-36394173">[-]</label><label class="expand" for="c-36394173">[2 more]</label></div><br/><div class="children"><div class="content">Would this basically be a new front end? Like the part that handles sockets and input?<p>Or more if a rewrite of subsystems? Like the query planner or storage engine etc?</div><br/><div id="36394515" class="c"><input type="checkbox" id="c-36394515" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394173">parent</a><span>|</span><a href="#36393311">next</a><span>|</span><label class="collapse" for="c-36394515">[-]</label><label class="expand" for="c-36394515">[1 more]</label></div><br/><div class="children"><div class="content">Both, I&#x27;d imagine.<p>With regard to client compatibility there are related precedents for this already; the PostgreSQL wire protocol has emerged as a de facto standard.  Cockroachdb and ClickHouse are two examples that come to mind.</div><br/></div></div></div></div></div></div><div id="36393311" class="c"><input type="checkbox" id="c-36393311" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36393950">prev</a><span>|</span><a href="#36394155">next</a><span>|</span><label class="collapse" for="c-36393311">[-]</label><label class="expand" for="c-36393311">[15 more]</label></div><br/><div class="children"><div class="content">Yeah.  I think as a straightforward, easily correct transition from 2000 globals, a giant structure isn&#x27;t an awful idea.  It&#x27;s not like the globals were organized before! You&#x27;re just making the ambient state (awful as it is) explicit.</div><br/><div id="36395091" class="c"><input type="checkbox" id="c-36395091" checked=""/><div class="controls bullet"><span class="by">cakoose</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393311">parent</a><span>|</span><a href="#36396786">next</a><span>|</span><label class="collapse" for="c-36395091">[-]</label><label class="expand" for="c-36395091">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I think as a straightforward, easily correct transition from 2000 globals, a giant structure isn&#x27;t an awful idea.<p>Agree.<p>&gt; It&#x27;s not like the globals were organized before!<p>Using a struct with 2000 fields loses some encapsulation.<p>When a global is defined in a &quot;.c&quot; file (and not exported via a &quot;.h&quot; file), it can only be accessed in that one &quot;.c&quot; file, sort of like a &quot;private&quot; field in a class.<p>Switching to a single struct would mean that all globals can be accessed by all code.<p>There&#x27;s probably a way to define things that allows you to regain some encapsulation, though. For example, some spin on the opaque type pattern: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;29121847&#x2F;163832" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;29121847&#x2F;163832</a></div><br/><div id="36395786" class="c"><input type="checkbox" id="c-36395786" checked=""/><div class="controls bullet"><span class="by">pasc1878</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395091">parent</a><span>|</span><a href="#36396786">next</a><span>|</span><label class="collapse" for="c-36395786">[-]</label><label class="expand" for="c-36395786">[5 more]</label></div><br/><div class="children"><div class="content">No that is what a static in a .c file is for.<p>A plain global can be accessed from other compiled units - agreed with no .h entry it is my=uch more error prone e.g. you don&#x27;t know the type but the variables name is exposed to other objects</div><br/><div id="36397325" class="c"><input type="checkbox" id="c-36397325" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395786">parent</a><span>|</span><a href="#36396786">next</a><span>|</span><label class="collapse" for="c-36397325">[-]</label><label class="expand" for="c-36397325">[4 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t those statics also be slated for removal with this change?</div><br/><div id="36398039" class="c"><input type="checkbox" id="c-36398039" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36397325">parent</a><span>|</span><a href="#36396786">next</a><span>|</span><label class="collapse" for="c-36398039">[-]</label><label class="expand" for="c-36398039">[3 more]</label></div><br/><div class="children"><div class="content">At most they&#x27;d be determined to be read only constants that are inlined during constant folding. This includes most integral sized &#x2F; typed scalar values that fit into registers for the most part, and nothing you&#x27;ve taken the address of either - those remain as static data.</div><br/><div id="36399014" class="c"><input type="checkbox" id="c-36399014" checked=""/><div class="controls bullet"><span class="by">cakoose</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36398039">parent</a><span>|</span><a href="#36396786">next</a><span>|</span><label class="collapse" for="c-36399014">[-]</label><label class="expand" for="c-36399014">[2 more]</label></div><br/><div class="children"><div class="content">I think there might be a terminology mix-up here. In C, a global variable with the `static` keyword is is still mutable. So it typically can&#x27;t be constant-folded&#x2F;inlined.<p>The `static` modifier in that context just means that the symbol is not exported, so other &quot;.c&quot; files can&#x27;t access it.</div><br/><div id="36399742" class="c"><input type="checkbox" id="c-36399742" checked=""/><div class="controls bullet"><span class="by">bourgeoismedia</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36399014">parent</a><span>|</span><a href="#36396786">next</a><span>|</span><label class="collapse" for="c-36399742">[-]</label><label class="expand" for="c-36399742">[1 more]</label></div><br/><div class="children"><div class="content">A static variable in C is mutable in the same sense that a local variable is, but since it&#x27;s not visible outside the current compilation unit the optimizer is allowed to observe that it&#x27;s never actually modified or published and constant fold it away.<p>Check out the generated assembly for this simple program, notice that kBase is folded even though it&#x27;s not marked const: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;h45vYo5x5" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;h45vYo5x5</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36396786" class="c"><input type="checkbox" id="c-36396786" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393311">parent</a><span>|</span><a href="#36395091">prev</a><span>|</span><a href="#36393532">next</a><span>|</span><label class="collapse" for="c-36396786">[-]</label><label class="expand" for="c-36396786">[1 more]</label></div><br/><div class="children"><div class="content">We did this with a project I worked on. I came on after the code was mature.<p>While we didn&#x27;t have 2000 globals, we did have a non-trivial amount, spread over about 300kLOC of C++.<p>We started by just stuffing them into a &quot;context&quot; struct, and every function that accessed a global thus needed to take a context instance as a new parameter. This was tedious but easy.<p>However the upside was that this highlighted poor architecture. Over time we refactored those bits and the main context struct shrunk significantly.<p>The result was better and more modular code, and overall well worth the effort in our case, in my opinion.</div><br/></div></div><div id="36393532" class="c"><input type="checkbox" id="c-36393532" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393311">parent</a><span>|</span><a href="#36396786">prev</a><span>|</span><a href="#36394770">next</a><span>|</span><label class="collapse" for="c-36393532">[-]</label><label class="expand" for="c-36393532">[3 more]</label></div><br/><div class="children"><div class="content">Exactly, if you&#x27;re now forced to put everything in one place you&#x27;re forced to acknowledge and understand the complexity of your state, and might have incentives to simplify it.</div><br/><div id="36393734" class="c"><input type="checkbox" id="c-36393734" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393532">parent</a><span>|</span><a href="#36394770">next</a><span>|</span><label class="collapse" for="c-36393734">[-]</label><label class="expand" for="c-36393734">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s MySQL&#x27;s all-session-globals-in-one-place-class: <a href="https:&#x2F;&#x2F;github.com&#x2F;mysql&#x2F;mysql-server&#x2F;blob&#x2F;8.0&#x2F;sql&#x2F;sql_class.h#L927">https:&#x2F;&#x2F;github.com&#x2F;mysql&#x2F;mysql-server&#x2F;blob&#x2F;8.0&#x2F;sql&#x2F;sql_class...</a><p>I believe I can safely say that nobody acknowledges and understands the complexity of all state within that class, and that whatever incentives there may be to simplify it are not enough for that to actually happen.<p>(It ends on line 4692)</div><br/><div id="36394703" class="c"><input type="checkbox" id="c-36394703" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393734">parent</a><span>|</span><a href="#36394770">next</a><span>|</span><label class="collapse" for="c-36394703">[-]</label><label class="expand" for="c-36394703">[1 more]</label></div><br/><div class="children"><div class="content">Right but that would still be true if they were globals instead. Putting all the globals in a class doesn&#x27;t make any difference to how much state you have.</div><br/></div></div></div></div></div></div><div id="36394770" class="c"><input type="checkbox" id="c-36394770" checked=""/><div class="controls bullet"><span class="by">stingraycharles</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393311">parent</a><span>|</span><a href="#36393532">prev</a><span>|</span><a href="#36396480">next</a><span>|</span><label class="collapse" for="c-36394770">[-]</label><label class="expand" for="c-36394770">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it’s the most pragmatic and it’s only “awful” because it makes the actual problem visible. And would likely encourage slowly refactoring code to handle its state in a more sane way, until you’re only left with the really gnarly stuff, which shouldn’t be too much anymore and you can put them in individual thread local storages.<p>It’s an easy transition path.</div><br/></div></div><div id="36396480" class="c"><input type="checkbox" id="c-36396480" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393311">parent</a><span>|</span><a href="#36394770">prev</a><span>|</span><a href="#36394155">next</a><span>|</span><label class="collapse" for="c-36396480">[-]</label><label class="expand" for="c-36396480">[3 more]</label></div><br/><div class="children"><div class="content">I think my bigger fear is around security.  A process per connection keeps things pretty secure for that connection regardless of what the global variables are doing (somewhat hard to mess that up with no concurrency going on in a process).<p>Merge all that into one process with many threads and it becomes a nightmare problem to ensure some random addon didn&#x27;t decide to change a global var mid processing (which causes wrong data to be read).</div><br/><div id="36397002" class="c"><input type="checkbox" id="c-36397002" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36396480">parent</a><span>|</span><a href="#36394155">next</a><span>|</span><label class="collapse" for="c-36397002">[-]</label><label class="expand" for="c-36397002">[2 more]</label></div><br/><div class="children"><div class="content">All postgres processes run under the same system user and all the access checking happens completely in userspace.</div><br/><div id="36397146" class="c"><input type="checkbox" id="c-36397146" checked=""/><div class="controls bullet"><span class="by">fdr</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36397002">parent</a><span>|</span><a href="#36394155">next</a><span>|</span><label class="collapse" for="c-36397146">[-]</label><label class="expand" for="c-36397146">[1 more]</label></div><br/><div class="children"><div class="content">Access checking, yes, but the scope of memory corruption does increase unavoidably, given the main thing the pgsql-hackers investigating threads want: one virtual memory context when toggling between concurrent work.<p>Of course, there&#x27;s a huge amount of shared space already, so a willful corruption can already do virtually anything. But, more is more.</div><br/></div></div></div></div></div></div></div></div><div id="36394155" class="c"><input type="checkbox" id="c-36394155" checked=""/><div class="controls bullet"><span class="by">comboy</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36393311">prev</a><span>|</span><a href="#36393531">next</a><span>|</span><label class="collapse" for="c-36394155">[-]</label><label class="expand" for="c-36394155">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never really been limited by CPU when running postgres (few TB instances). The bottleneck is always IO. Do others have different experience? Plus there&#x27;s elegance and a feeling of being in control when you know query is associated with specific process which you can deal with and monitor just like any other process.<p>But I&#x27;m very much clueless about internals, so this is a question rather than an opinion.</div><br/><div id="36394500" class="c"><input type="checkbox" id="c-36394500" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394155">parent</a><span>|</span><a href="#36394404">next</a><span>|</span><label class="collapse" for="c-36394500">[-]</label><label class="expand" for="c-36394500">[2 more]</label></div><br/><div class="children"><div class="content">I see postgres become CPU bound regularly: Lots of hash joins, copy from or to CSV, index or materialized view rebuild. Postgis eats CPU. Tds_fdw tends to spend a lot of time doing charset conversion, more than actually networking to mssql.<p>I was surprised when starting with postgres.  Then again, I have smaller databases (A few TB) and the cache hit ratio tends to be about 95%.  Combine that with SSDs, and it becomes understandable.<p>Even so, I am wary of this change. Postgres is very reliable, and I have no problem throwing some extra hardware to it in return.  But these people have proven they know what they are doing, so I&#x27;ll go with their opinion.</div><br/><div id="36394725" class="c"><input type="checkbox" id="c-36394725" checked=""/><div class="controls bullet"><span class="by">aetherson</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394500">parent</a><span>|</span><a href="#36394404">next</a><span>|</span><label class="collapse" for="c-36394725">[-]</label><label class="expand" for="c-36394725">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also definitely seen a lot of CPU bounding on postgres.</div><br/></div></div></div></div><div id="36394404" class="c"><input type="checkbox" id="c-36394404" checked=""/><div class="controls bullet"><span class="by">Diggsey</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394155">parent</a><span>|</span><a href="#36394500">prev</a><span>|</span><a href="#36395413">next</a><span>|</span><label class="collapse" for="c-36394404">[-]</label><label class="expand" for="c-36394404">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just CPU - memory usage is also higher. In particular, idle connections still consume signficant memory, and this is why PostgreSQL has so much lower connection limits than eg. MySQL. Pooling can help in some cases, but pooling also breaks some important PostgreSQL features (like prepared statements...) since poolers generally can&#x27;t preserve session state. Other features (eg. notify) are just incompatible with pooling. And pooling cannot help with connections that are idle but inside a transaction.<p>That said, many of these things are solvable without a full switch to a threaded model (eg. by having pooling built-in and session-state-aware).</div><br/><div id="36395611" class="c"><input type="checkbox" id="c-36395611" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394404">parent</a><span>|</span><a href="#36397967">next</a><span>|</span><label class="collapse" for="c-36395611">[-]</label><label class="expand" for="c-36395611">[1 more]</label></div><br/><div class="children"><div class="content">&gt; solvable without a full switch to a threaded model (eg. by having pooling built-in and session-state-aware).<p>Yeeeeesssss, but solving that is solving the hardest part of switching to a threaded model. It requires the team to come terms with the global state and encapsulating session state in a non-global struct.</div><br/></div></div><div id="36397967" class="c"><input type="checkbox" id="c-36397967" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394404">parent</a><span>|</span><a href="#36395611">prev</a><span>|</span><a href="#36395413">next</a><span>|</span><label class="collapse" for="c-36397967">[-]</label><label class="expand" for="c-36397967">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That said, many of these things are solvable without a full switch to a threaded model (eg. by having pooling built-in and session-state-aware).<p>The thing is that that&#x27;s a lot easier with threads. Much of the session state lives in process private memory (prepared statements etc), and it can&#x27;t be statically sized ahead of time. If you move all that state into dynamically allocated shared memory, you&#x27;ve basically paid all the price for threading already, except you can&#x27;t use any tooling for threads.</div><br/></div></div></div></div><div id="36395413" class="c"><input type="checkbox" id="c-36395413" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394155">parent</a><span>|</span><a href="#36394404">prev</a><span>|</span><a href="#36395129">next</a><span>|</span><label class="collapse" for="c-36395413">[-]</label><label class="expand" for="c-36395413">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve generally had buffer-cache hit rates in the 99.9% range, which ends up being minimal read I&#x2F;O. (This is on AWS Aurora, where these bo disk cache and so shared_buffers is the primary cache, but an equivalent measure for vanilla postgres exists.)<p>In those scenarios,there&#x27;s very little read I&#x2F;O. CPU is the primary bottleneck. That&#x27;s why we run up as many as 10 Aurora readers (autoscaled with traffic).</div><br/></div></div><div id="36395129" class="c"><input type="checkbox" id="c-36395129" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394155">parent</a><span>|</span><a href="#36395413">prev</a><span>|</span><a href="#36394395">next</a><span>|</span><label class="collapse" for="c-36395129">[-]</label><label class="expand" for="c-36395129">[4 more]</label></div><br/><div class="children"><div class="content">&gt;I&#x27;ve never really been limited by CPU when running postgres (few TB instances). The bottleneck is always IO.<p>Throw a few NVMe drives at it and it might.</div><br/><div id="36397100" class="c"><input type="checkbox" id="c-36397100" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395129">parent</a><span>|</span><a href="#36394395">next</a><span>|</span><label class="collapse" for="c-36397100">[-]</label><label class="expand" for="c-36397100">[3 more]</label></div><br/><div class="children"><div class="content">Throw a ridiculous amount of RAM at it is more correct assessment. NVMe reads are still an “I&#x2F;O” and that is slow. And for at least 10 years buying enough RAM to have all off the interesting parts of OLTP psql database either in shared_buffers or in the OS-level buffer cache is completely feasible.</div><br/><div id="36397387" class="c"><input type="checkbox" id="c-36397387" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36397100">parent</a><span>|</span><a href="#36398654">next</a><span>|</span><label class="collapse" for="c-36397387">[-]</label><label class="expand" for="c-36397387">[1 more]</label></div><br/><div class="children"><div class="content">&gt; NVMe reads are still an “I&#x2F;O” and that is slow<p>It&#x27;s orders of magnitude faster than SAS&#x2F;SATA SSDs and you can throw 10 of them into 1U server. It&#x27;s nowhere near  &quot;slow&quot; and still easy enough to be CPU bottlenecked before you get IO bottlenecked.<p>But yes, pair of 1TB RAM servers gotta cost you less than half year&#x27;s worth of developer salary</div><br/></div></div><div id="36398654" class="c"><input type="checkbox" id="c-36398654" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36397100">parent</a><span>|</span><a href="#36397387">prev</a><span>|</span><a href="#36394395">next</a><span>|</span><label class="collapse" for="c-36398654">[-]</label><label class="expand" for="c-36398654">[1 more]</label></div><br/><div class="children"><div class="content">an array of modern SSDs can get to a similar bandwidth to RAM, albeit with significantly worse latency still. It&#x27;s not that hard to push the bottleneck elsewhere in a lot of workloads. High performance fileservers, for example, need pretty beefy CPUs to keep up.</div><br/></div></div></div></div></div></div><div id="36394395" class="c"><input type="checkbox" id="c-36394395" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394155">parent</a><span>|</span><a href="#36395129">prev</a><span>|</span><a href="#36394340">next</a><span>|</span><label class="collapse" for="c-36394395">[-]</label><label class="expand" for="c-36394395">[1 more]</label></div><br/><div class="children"><div class="content">Depends on your queries.<p>If you push a lot of work into the database including JSON and have a lot of buffer memory...CPU can easily be limiting.</div><br/></div></div><div id="36394340" class="c"><input type="checkbox" id="c-36394340" checked=""/><div class="controls bullet"><span class="by">sargun</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36394155">parent</a><span>|</span><a href="#36394395">prev</a><span>|</span><a href="#36393531">next</a><span>|</span><label class="collapse" for="c-36394340">[-]</label><label class="expand" for="c-36394340">[1 more]</label></div><br/><div class="children"><div class="content">With modern SSDs that can push 1M IOPs+, you can get into a situation where I&#x2F;O latency starts to become a problem, but in my experience, they far outpace what the CPU can do. Even the I&#x2F;O stack can be optimized further in some of these cases, but often it comes with the trade off of shifting more work into the CPU.</div><br/></div></div></div></div><div id="36393531" class="c"><input type="checkbox" id="c-36393531" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36394155">prev</a><span>|</span><a href="#36393397">next</a><span>|</span><label class="collapse" for="c-36393531">[-]</label><label class="expand" for="c-36393531">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m honestly surprised it took them so long to reach this conclusion.<p>On the contrary, it&#x27;s been discussed for ages. But it&#x27;s a huge change, with only modest advantages.<p>I&#x27;m skeptical of the ROI to be honest. Not that is doesn&#x27;t have value, but that it has more value than the effort.</div><br/><div id="36394322" class="c"><input type="checkbox" id="c-36394322" checked=""/><div class="controls bullet"><span class="by">36364949thrw</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393531">parent</a><span>|</span><a href="#36395760">next</a><span>|</span><label class="collapse" for="c-36394322">[-]</label><label class="expand" for="c-36394322">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s a huge change, with only modest advantages<p>+significant and unknown set of new problems, including new bugs.<p>This reminds me of the time they lifted entire streets in Chicago by 14 feet to address new urban requirements. Chicago, we can safely assume, did not have the option of just starting a brand new city a few miles away.<p>The interesting question here is should a system design that works quite well upto a certain scale be abandoned in order to extend its market reach.</div><br/></div></div><div id="36395760" class="c"><input type="checkbox" id="c-36395760" checked=""/><div class="controls bullet"><span class="by">datavirtue</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393531">parent</a><span>|</span><a href="#36394322">prev</a><span>|</span><a href="#36393397">next</a><span>|</span><label class="collapse" for="c-36395760">[-]</label><label class="expand" for="c-36395760">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and you will run headlong into other unforseen real world issues. You may never reach the performance goals.</div><br/></div></div></div></div><div id="36393397" class="c"><input type="checkbox" id="c-36393397" checked=""/><div class="controls bullet"><span class="by">saulrh</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36393531">prev</a><span>|</span><a href="#36393718">next</a><span>|</span><label class="collapse" for="c-36393397">[-]</label><label class="expand" for="c-36393397">[2 more]</label></div><br/><div class="children"><div class="content">Also, even if a 2k-member structure is obnoxious, consider the alternative - having to think about and manage 2k global variables is probably even worse!</div><br/><div id="36394873" class="c"><input type="checkbox" id="c-36394873" checked=""/><div class="controls bullet"><span class="by">megous</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393397">parent</a><span>|</span><a href="#36393718">next</a><span>|</span><label class="collapse" for="c-36394873">[-]</label><label class="expand" for="c-36394873">[1 more]</label></div><br/><div class="children"><div class="content">Each set of globals is in a module it relates to, not in some central file where everything has to be in one struct.<p>If anything, it&#x27;s probably easier to understand.</div><br/></div></div></div></div><div id="36393718" class="c"><input type="checkbox" id="c-36393718" checked=""/><div class="controls bullet"><span class="by">shepardrtc</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36393397">prev</a><span>|</span><a href="#36396220">next</a><span>|</span><label class="collapse" for="c-36393718">[-]</label><label class="expand" for="c-36393718">[3 more]</label></div><br/><div class="children"><div class="content">I think this is a situation where a message-passing Actor-based model would do well. Maybe pass variable updates to a single writer process&#x2F;thread through channels or a queue.<p>Years ago I wrote an algorithmic trader in Python (and Cython for the hotspots) using Multiprocessing and I was able to get away with a lot using that approach.  I had one process receiving websocket updates from the exchange, another process writing them to an order book that used a custom data structure, and multiple other processes reading from that data structure.  Ran well enough that trade decisions could be made in a few thousand nanoseconds on an average EC2 instance.  Not sure what their latency requirements are, though I imagine they may need to be faster.<p>Obviously mutexes are the bottleneck for them at this point, and while my idea might be a bit slower than a low-load situation, perhaps it would be faster when you start getting to higher load.</div><br/><div id="36395145" class="c"><input type="checkbox" id="c-36395145" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393718">parent</a><span>|</span><a href="#36394341">next</a><span>|</span><label class="collapse" for="c-36395145">[-]</label><label class="expand" for="c-36395145">[1 more]</label></div><br/><div class="children"><div class="content">That would most likely be several times slower than current model</div><br/></div></div><div id="36394341" class="c"><input type="checkbox" id="c-36394341" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393718">parent</a><span>|</span><a href="#36395145">prev</a><span>|</span><a href="#36396220">next</a><span>|</span><label class="collapse" for="c-36394341">[-]</label><label class="expand" for="c-36394341">[1 more]</label></div><br/><div class="children"><div class="content">I think the Actor model is fine if you start there, but I can&#x27;t imagine incrementally adopting it in a large, preexisting code base.</div><br/></div></div></div></div><div id="36396220" class="c"><input type="checkbox" id="c-36396220" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36393718">prev</a><span>|</span><a href="#36397080">next</a><span>|</span><label class="collapse" for="c-36396220">[-]</label><label class="expand" for="c-36396220">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  I&#x27;m honestly surprised it took them so long to reach this conclusion.<p>Oracle also uses a process model on Linux. At some point (I think starting with 12.x), it can now be configured on Linux to use a threaded model, but the default is still a process-per-connection model.<p>Why does everybody think it&#x27;s a bad thing in Postgres, but nobody thinks it&#x27;s a bad thing in Oracle.</div><br/><div id="36397552" class="c"><input type="checkbox" id="c-36397552" checked=""/><div class="controls bullet"><span class="by">patmorgan23</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36396220">parent</a><span>|</span><a href="#36397080">next</a><span>|</span><label class="collapse" for="c-36397552">[-]</label><label class="expand" for="c-36397552">[1 more]</label></div><br/><div class="children"><div class="content">Well for one Postgress is open source and widely used. So anyone can pick it up and look at its internals, that&#x27;s not the case for Oracle DB .</div><br/></div></div></div></div><div id="36397080" class="c"><input type="checkbox" id="c-36397080" checked=""/><div class="controls bullet"><span class="by">rsaxvc</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36396220">prev</a><span>|</span><a href="#36395407">next</a><span>|</span><label class="collapse" for="c-36397080">[-]</label><label class="expand" for="c-36397080">[1 more]</label></div><br/><div class="children"><div class="content">This is how I made my fork of libtcc lock-free.<p>Mainline has a lock so that all backends can use global variables, but only one instance can do codegen at a time.<p>It was a giant refactoring Especially fun was when multiple compilation units used the same static variable name, but it all worked in the end.</div><br/></div></div><div id="36395407" class="c"><input type="checkbox" id="c-36395407" checked=""/><div class="controls bullet"><span class="by">FooBarWidget</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36397080">prev</a><span>|</span><a href="#36393836">next</a><span>|</span><label class="collapse" for="c-36395407">[-]</label><label class="expand" for="c-36395407">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it. How is a 2000-member structure any different from having 2000 global variables? How is maintaining the struct possibly harder than maintaining the globals? Refactoring globals to struct members is semantically nearly identical, it may as well just be a mechanical, cosmetic change, while also giving the possibility to move to a threaded architecture.</div><br/><div id="36395750" class="c"><input type="checkbox" id="c-36395750" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395407">parent</a><span>|</span><a href="#36393836">next</a><span>|</span><label class="collapse" for="c-36395750">[-]</label><label class="expand" for="c-36395750">[2 more]</label></div><br/><div class="children"><div class="content">Because global variables can be confined to individual cpp files, exclusively visible in that compilation unit. It makes them far easier to reason with than hoisting them to the &quot;global and globally visible&quot; option if you just use a gargantuan struct. Which is why a more invasive refactor might be required.</div><br/><div id="36396725" class="c"><input type="checkbox" id="c-36396725" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36395750">parent</a><span>|</span><a href="#36393836">next</a><span>|</span><label class="collapse" for="c-36396725">[-]</label><label class="expand" for="c-36396725">[1 more]</label></div><br/><div class="children"><div class="content">Just use thread local variables.<p>I abuse them for ridiculous things.</div><br/></div></div></div></div></div></div><div id="36393836" class="c"><input type="checkbox" id="c-36393836" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#36393217">parent</a><span>|</span><a href="#36395407">prev</a><span>|</span><a href="#36394840">next</a><span>|</span><label class="collapse" for="c-36393836">[-]</label><label class="expand" for="c-36393836">[2 more]</label></div><br/><div class="children"><div class="content">&gt; if the hierarchy inside them is well organized<p>is this another way to say &quot;in a 2000 member structure, only 10 have significant voting power&quot;?</div><br/><div id="36395277" class="c"><input type="checkbox" id="c-36395277" checked=""/><div class="controls bullet"><span class="by">Ankhers</span><span>|</span><a href="#36393217">root</a><span>|</span><a href="#36393836">parent</a><span>|</span><a href="#36394840">next</a><span>|</span><label class="collapse" for="c-36395277">[-]</label><label class="expand" for="c-36395277">[1 more]</label></div><br/><div class="children"><div class="content">This statement is not about people, it is about a C struct.</div><br/></div></div></div></div></div></div><div id="36394840" class="c"><input type="checkbox" id="c-36394840" checked=""/><div class="controls bullet"><span class="by">wielebny</span><span>|</span><a href="#36393217">prev</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36394840">[-]</label><label class="expand" for="c-36394840">[14 more]</label></div><br/><div class="children"><div class="content">Having been using and administering a lot of PostgreSQL servers, I hope they don&#x27;t lose any stability over this.<p>I&#x27;ve seen (and reported) bugs that caused panics&#x2F;segfaults in specific psql processes. Not just connections, also processes related to wal writing or replication. The way it&#x27;s  built right now, a child process can be just forced to quit and it does not affect other processes. Hopefully switching into thread won&#x27;t force whole PostgreSQL to panic and shut down.</div><br/><div id="36397331" class="c"><input type="checkbox" id="c-36397331" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#36394840">parent</a><span>|</span><a href="#36396088">next</a><span>|</span><label class="collapse" for="c-36397331">[-]</label><label class="expand" for="c-36397331">[1 more]</label></div><br/><div class="children"><div class="content">Most likely, the postmaster will maintain a separate process, much like today with pg, or similar to Firefox or Chrome&#x27;s control process that can catch the panic&#x27;d process, cleanup and restart them.  The WAL can be recovered as well if there were broken transactions in flight.</div><br/></div></div><div id="36396088" class="c"><input type="checkbox" id="c-36396088" checked=""/><div class="controls bullet"><span class="by">jtc331</span><span>|</span><a href="#36394840">parent</a><span>|</span><a href="#36397331">prev</a><span>|</span><a href="#36395872">next</a><span>|</span><label class="collapse" for="c-36396088">[-]</label><label class="expand" for="c-36396088">[1 more]</label></div><br/><div class="children"><div class="content">Because of shared memory most panics and seg faults in a worker process take down the entire server already (this wasn’t always the case, but not doing so was a bug).</div><br/></div></div><div id="36395872" class="c"><input type="checkbox" id="c-36395872" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36394840">parent</a><span>|</span><a href="#36396088">prev</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36395872">[-]</label><label class="expand" for="c-36395872">[11 more]</label></div><br/><div class="children"><div class="content">Of course it will. That&#x27;s better than continue working with damaged memory structures and unpredictable consequences. For database it&#x27;s more important than ever. Imagine writing corrupted data because other thread went crazy.</div><br/><div id="36396001" class="c"><input type="checkbox" id="c-36396001" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36395872">parent</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36396001">[-]</label><label class="expand" for="c-36396001">[10 more]</label></div><br/><div class="children"><div class="content">You&#x27;re implying that only an OS can provide memory separation between units of execution - at least in .NET AppDomains give you the same protection within a single process, so why couldn&#x27;t postgres have its own such mechanism?
I&#x27;d also think with a database engine shared state is not just in-memory - i.e. one process can potentially corrupt the behaviour of another by what it writes to disk, so moving to a single-process model doesn&#x27;t necessarily introduce problems that could never have existed previously (but, yes, would arguably make them more likely)</div><br/><div id="36396926" class="c"><input type="checkbox" id="c-36396926" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396001">parent</a><span>|</span><a href="#36400256">next</a><span>|</span><label class="collapse" for="c-36396926">[-]</label><label class="expand" for="c-36396926">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know .NET enough to comment here, but I&#x27;m pretty sure that if you would manage to run bare metal C inside your .NET app (should be possible), it&#x27;ll destroy all your domains easily. RAM is RAM. The only memory protection that we have is across process boundary (even that protection is not perfect with shared memory, but at least it allows to protect private memory).<p>At least I&#x27;m not aware of any way to protect private thread memory from other threads.<p>Postgres is C and that&#x27;s not going to change ever.</div><br/><div id="36397068" class="c"><input type="checkbox" id="c-36397068" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396926">parent</a><span>|</span><a href="#36400256">next</a><span>|</span><label class="collapse" for="c-36397068">[-]</label><label class="expand" for="c-36397068">[1 more]</label></div><br/><div class="children"><div class="content">I certainly wasn&#x27;t suggesting it would make sense to rewrite Postgres to run on .NET (using any language, even managed C++, assuming anyone still uses that).
Yes, it&#x27;s inherent in the C&#x2F;C++ language that it&#x27;s able to randomly access any memory that a process has access to, and obviously on that basis OS-provided process-separation is the &quot;best&quot; protection you can get, just pointing out that it&#x27;s not the only possibility.</div><br/></div></div></div></div><div id="36400256" class="c"><input type="checkbox" id="c-36400256" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396001">parent</a><span>|</span><a href="#36396926">prev</a><span>|</span><a href="#36396519">next</a><span>|</span><label class="collapse" for="c-36400256">[-]</label><label class="expand" for="c-36400256">[1 more]</label></div><br/><div class="children"><div class="content">For a decades old codebase probably only the OS can.<p>Point is it getting worse if this is changed.</div><br/></div></div><div id="36396519" class="c"><input type="checkbox" id="c-36396519" checked=""/><div class="controls bullet"><span class="by">SigmundA</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396001">parent</a><span>|</span><a href="#36400256">prev</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36396519">[-]</label><label class="expand" for="c-36396519">[6 more]</label></div><br/><div class="children"><div class="content">No AppDomains are not as good as processes, I have tried to go that route before, you cannot stop unruly code reliably in an app domain (you must use thread.abort() which is not good) and memory can still leak in any native code used there.<p>The only reliable way to stop bad code like say an infinite loop is to run in another process even in .Net.<p>They also removed Appdomain in later versions of .Net because they had little benefit and weak protections compared to a a full process.</div><br/><div id="36396651" class="c"><input type="checkbox" id="c-36396651" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396519">parent</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36396651">[-]</label><label class="expand" for="c-36396651">[5 more]</label></div><br/><div class="children"><div class="content">Not claiming they&#x27;re as good, just noting that there are alternative ways to provide memory barriers, though obviously if it&#x27;s not enforced at the language&#x2F;runtime level, it requires either super strong developer disciple or the use of some other tool to do so.
I can&#x27;t find anything suggesting AppDomains have been removed completely though, just they&#x27;re not fully supported on non-Windows platforms, which is interesting, I wonder if that means they do have OS-level support.</div><br/><div id="36396726" class="c"><input type="checkbox" id="c-36396726" checked=""/><div class="controls bullet"><span class="by">SigmundA</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396651">parent</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36396726">[-]</label><label class="expand" for="c-36396726">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.appdomain?view=net-7.0" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.appdomai...</a><p>&quot;On .NET Core, the AppDomain implementation is limited by design and does not provide isolation, unloading, or security boundaries. For .NET Core, there is exactly one AppDomain. Isolation and unloading are provided through AssemblyLoadContext. Security boundaries should be provided by process boundaries and appropriate remoting techniques.&quot;<p>AppDomains pretty much only allowed you to load unload assemblies and provided little else. If you wanted to stop bad code you still used Thread.Abort which left your runtime in a potentially bad state due to no isolation between threads.<p>The only way to do something like an AppDomain to replace process isolation would be to re-write the whole OS in a memory safe language similar to <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Midori_(operating_system)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Midori_(operating_system)</a> &#x2F; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Singularity_(operating_system)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Singularity_(operating_system)</a></div><br/><div id="36397108" class="c"><input type="checkbox" id="c-36397108" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36396726">parent</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36397108">[-]</label><label class="expand" for="c-36397108">[3 more]</label></div><br/><div class="children"><div class="content">Is that saying global variables are shared between AppDomains on .NET core then? Scary if so, we have a bunch of .NET framework code we&#x27;re looking at porting to .NET core in the near future, and I know it relies on AppDomain separation currently. It&#x27;s not the first framework-&gt;Core conversation I&#x27;ve done, but I don&#x27;t remember changes in AppDomain behaviour causing any issues the first time.<p>As it happens I already know there are bits of code currently not working &quot;as expected&quot; exactly because of AppDomain separation - i.e. attempting to use a shared-memory cache to improve performance and in one or two cases in an attempt to share state, and I got the impression whoever wrote that code didn&#x27;t understand that there even were two AppDomains involved, and used various ugly hacks to &quot;fall back&quot; to alternative means of state-sharing, but in fact the fall-back is the only thing that actually ever works.</div><br/><div id="36397541" class="c"><input type="checkbox" id="c-36397541" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36397108">parent</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36397541">[-]</label><label class="expand" for="c-36397541">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Is that saying global variables are shared between AppDomains on .NET core then?<p>No, you can&#x27;t create a second AppDomain <i>at all</i>. AppDomains are dead and buried; you would need to remove all of that from your code in order to migrate to current .NET. The class only remains to serve a couple ancillary functions that don&#x27;t involve actually creating additional AppDomains.</div><br/><div id="36397714" class="c"><input type="checkbox" id="c-36397714" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#36394840">root</a><span>|</span><a href="#36397541">parent</a><span>|</span><a href="#36393528">next</a><span>|</span><label class="collapse" for="c-36397714">[-]</label><label class="expand" for="c-36397714">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re not creating them ourselves, they&#x27;re created by IIS.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36393528" class="c"><input type="checkbox" id="c-36393528" checked=""/><div class="controls bullet"><span class="by">BoardsOfCanada</span><span>|</span><a href="#36394840">prev</a><span>|</span><a href="#36400296">next</a><span>|</span><label class="collapse" for="c-36393528">[-]</label><label class="expand" for="c-36393528">[13 more]</label></div><br/><div class="children"><div class="content">I recently looked through the source code of postgresql and every source files starts with a (really good) description of what the file is supposed to do, which made it really easy to get in to the code compared to other open source projects I&#x27;ve seen. So thanks for that.</div><br/><div id="36394175" class="c"><input type="checkbox" id="c-36394175" checked=""/><div class="controls bullet"><span class="by">Alekhine</span><span>|</span><a href="#36393528">parent</a><span>|</span><a href="#36398918">next</a><span>|</span><label class="collapse" for="c-36394175">[-]</label><label class="expand" for="c-36394175">[11 more]</label></div><br/><div class="children"><div class="content">I have no idea why that isn&#x27;t standard practice in every codebase. I should be able to figure out your code without having to ask, or dig through issues or commit messages. Just tell me what it&#x27;s for!</div><br/><div id="36394744" class="c"><input type="checkbox" id="c-36394744" checked=""/><div class="controls bullet"><span class="by">SoylentOrange</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36394175">parent</a><span>|</span><a href="#36397091">next</a><span>|</span><label class="collapse" for="c-36394744">[-]</label><label class="expand" for="c-36394744">[8 more]</label></div><br/><div class="children"><div class="content">Because it takes a lot of time and because the comments can get outdated. I also want this for all my code bases. But do I always do this myself? No, especially on green field projects. I will sometimes go back and annotate them later.</div><br/><div id="36395036" class="c"><input type="checkbox" id="c-36395036" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36394744">parent</a><span>|</span><a href="#36395386">next</a><span>|</span><label class="collapse" for="c-36395036">[-]</label><label class="expand" for="c-36395036">[1 more]</label></div><br/><div class="children"><div class="content">They can get outdated but they usually don&#x27;t. It&#x27;s a good litmus test for if a file is too big &#x2F; small if it&#x27;s purpose is hard to nail down.</div><br/></div></div><div id="36395386" class="c"><input type="checkbox" id="c-36395386" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36394744">parent</a><span>|</span><a href="#36395036">prev</a><span>|</span><a href="#36395608">next</a><span>|</span><label class="collapse" for="c-36395386">[-]</label><label class="expand" for="c-36395386">[1 more]</label></div><br/><div class="children"><div class="content">Trying to understand what I previously wrote and why I wrote it takes more time than I ever care to spend.  I&#x27;d much rather have the comments,  plus at this point,  by making them a &quot;first class&quot; part of my code,  I find them much easier to write and I find the narrative style I use incredibly useful in laying out a new structure but also in refactoring old ones.</div><br/></div></div><div id="36395608" class="c"><input type="checkbox" id="c-36395608" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36394744">parent</a><span>|</span><a href="#36395386">prev</a><span>|</span><a href="#36397091">next</a><span>|</span><label class="collapse" for="c-36395608">[-]</label><label class="expand" for="c-36395608">[5 more]</label></div><br/><div class="children"><div class="content">Even outdated comments can tell you the original purpose of the code, which helps if you&#x27;re looking for a bug. Especially if you&#x27;re looking for a bug.<p>If someone didn&#x27;t take the time to update the comments and the reviewers didn&#x27;t point it out, then you&#x27;ve probably found the bug because someone was cowboying some shitty code.</div><br/><div id="36396158" class="c"><input type="checkbox" id="c-36396158" checked=""/><div class="controls bullet"><span class="by">alex_reg</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36395608">parent</a><span>|</span><a href="#36397091">next</a><span>|</span><label class="collapse" for="c-36396158">[-]</label><label class="expand" for="c-36396158">[4 more]</label></div><br/><div class="children"><div class="content">I have the opposite experience.<p>Outdated comments are often way worse than no comments, because they can give you wrong ideas that aren&#x27;t true anymore, and send you off in the wrong direction before you finally figure out the comment was wrong.</div><br/><div id="36396236" class="c"><input type="checkbox" id="c-36396236" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36396158">parent</a><span>|</span><a href="#36397091">next</a><span>|</span><label class="collapse" for="c-36396236">[-]</label><label class="expand" for="c-36396236">[3 more]</label></div><br/><div class="children"><div class="content">Indeed. I recently found this piece of code:<p><pre><code>    if (X) assert(false); &#x2F;&#x2F; we never do X, ever, anywhere.
</code></pre>
Then I look over to the other pane, where I have a different, but related file open:<p><pre><code>    if (exact same X) { do_useful_stuff(); }
</code></pre>
It got a chuckle out of me.</div><br/><div id="36399732" class="c"><input type="checkbox" id="c-36399732" checked=""/><div class="controls bullet"><span class="by">jgilias</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36396236">parent</a><span>|</span><a href="#36397091">next</a><span>|</span><label class="collapse" for="c-36399732">[-]</label><label class="expand" for="c-36399732">[2 more]</label></div><br/><div class="children"><div class="content">Did you update the comment? :-)</div><br/><div id="36400333" class="c"><input type="checkbox" id="c-36400333" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36399732">parent</a><span>|</span><a href="#36397091">next</a><span>|</span><label class="collapse" for="c-36400333">[-]</label><label class="expand" for="c-36400333">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;&#x2F; there are two kinds of mutually exclusive commentors<p>enum kinds { writers; readers; updaters; }</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36397091" class="c"><input type="checkbox" id="c-36397091" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36394175">parent</a><span>|</span><a href="#36394744">prev</a><span>|</span><a href="#36395628">next</a><span>|</span><label class="collapse" for="c-36397091">[-]</label><label class="expand" for="c-36397091">[1 more]</label></div><br/><div class="children"><div class="content">the average programmer thinks they are writting significantly above average clean code, so no need to document it :-)</div><br/></div></div><div id="36395628" class="c"><input type="checkbox" id="c-36395628" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36393528">root</a><span>|</span><a href="#36394175">parent</a><span>|</span><a href="#36397091">prev</a><span>|</span><a href="#36398918">next</a><span>|</span><label class="collapse" for="c-36395628">[-]</label><label class="expand" for="c-36395628">[1 more]</label></div><br/><div class="children"><div class="content">It kind of is in rust now, with module-level documentation given its own specific AST representation instead of just being a comment at the top of the file (a file is a module).</div><br/></div></div></div></div><div id="36398918" class="c"><input type="checkbox" id="c-36398918" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#36393528">parent</a><span>|</span><a href="#36394175">prev</a><span>|</span><a href="#36400296">next</a><span>|</span><label class="collapse" for="c-36398918">[-]</label><label class="expand" for="c-36398918">[1 more]</label></div><br/><div class="children"><div class="content">Uncle Bob hates this.</div><br/></div></div></div></div><div id="36400296" class="c"><input type="checkbox" id="c-36400296" checked=""/><div class="controls bullet"><span class="by">neilwilson</span><span>|</span><a href="#36393528">prev</a><span>|</span><a href="#36395782">next</a><span>|</span><label class="collapse" for="c-36400296">[-]</label><label class="expand" for="c-36400296">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always amazed me with databases why they don&#x27;t go the other way.<p>Create an operating system specifically for the database and make it so you boot the database.<p>Databases seem to spend most of their time working around the operating system abstractions. So why not look at the OS, and streamline it for database use - dropping all the stuff a database will never need.<p>That then is a completely separate project which is far easier to get started rather than shoehorning the database into an operating system thread model that is already a hack of the process model.</div><br/><div id="36401192" class="c"><input type="checkbox" id="c-36401192" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36400296">parent</a><span>|</span><a href="#36400384">next</a><span>|</span><label class="collapse" for="c-36401192">[-]</label><label class="expand" for="c-36401192">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Create an operating system specifically for the database and make it so you boot the database.<p>(Others downthread have pointed out unikernels and I agree with the criticisms)<p>This proposal is an excellent Phd project for someone like me :-)<p>It ticks all of the things I like to work on the most[1]:<p>Will involve writing low-level OS code<p>Get to hyper-focus on performance<p>Writing a language parser and executor<p>Implement scheduler, threads, processes, etc.<p>Implement the listening protocol in the kernel.<p>I have to say, though, it might be easier to start off with a rump kernel (netBSD), then add in a specific RAW disk access that bypasses the OS (no, or fewer, syscalls to use it), create a kernel module for accepting a limited type of task and executing that task in-kernel (avoiding a context-swtich on every syscall)[2].<p>Programs in userspace must have the lowest priority (using starvation-prevention mechanisms to ensure that user input would <i>eventually</i> get processed).<p>I&#x27;d expect a non-insignificant speedup by doing all the work in the kernel.<p>The way it is now,<p>userspace requests read() on a socket (context-switch to kernel),<p>gets data (context-switch to userspace),<p>parses a query,<p>requests read on disk (multiple context-switches to kernel for open, stat, etc, multiple switches back to userspace after each call is complete). This latency is probably fairly well mitigated with mmap, though.<p>logs diagnostic (multiple context-switches to and from kernel)<p>requests write on client socket (context switch to kernel back and forth until all data is written).<p>The goal of the DBOS would be to remove almost all the context-switching between userspace and kernel.<p>[1] My side projects include a bootable (but unfinished) x86 OS, various programming languages, performant (or otherwise) C libraries.<p>[2] Similar to the way RealTime Linux calls work (caller shares a memory buffer with rt kernel module, populates the buffer and issues a call, kernel only returns when that task is complete). The BPF mechanism works the same. It&#x27;s the only way to reduce latency to the absolute physical minimum.</div><br/></div></div><div id="36400384" class="c"><input type="checkbox" id="c-36400384" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#36400296">parent</a><span>|</span><a href="#36401192">prev</a><span>|</span><a href="#36400789">next</a><span>|</span><label class="collapse" for="c-36400384">[-]</label><label class="expand" for="c-36400384">[3 more]</label></div><br/><div class="children"><div class="content">That was&#x2F;is part of the promise of the whole unikernel thing, no?<p><a href="https:&#x2F;&#x2F;mirage.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mirage.io&#x2F;</a> or similar could then let you boot your database. That said, it&#x27;s not really taken off from what I can tell, so I&#x27;m guessing there&#x27;s more to it than that.</div><br/><div id="36400478" class="c"><input type="checkbox" id="c-36400478" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36400296">root</a><span>|</span><a href="#36400384">parent</a><span>|</span><a href="#36400789">next</a><span>|</span><label class="collapse" for="c-36400478">[-]</label><label class="expand" for="c-36400478">[2 more]</label></div><br/><div class="children"><div class="content">Imo unikernels are a complicated solution in search of a problem, which turns out to not exist.<p>There certainly are times OSs get in the way. But it&#x27;s hard enough to write a good database, we don&#x27;t need to maintain a third of an OS in addition.</div><br/><div id="36400583" class="c"><input type="checkbox" id="c-36400583" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#36400296">root</a><span>|</span><a href="#36400478">parent</a><span>|</span><a href="#36400789">next</a><span>|</span><label class="collapse" for="c-36400583">[-]</label><label class="expand" for="c-36400583">[1 more]</label></div><br/><div class="children"><div class="content">Yeah indeed, that was my feeling on it as well. As much as Linux et al might get in ones way at times, what we get for free by relying on them is too useful to ignore for most tasks I think.<p>That said, perhaps at AWS or Google scale that would be different? I wonder if they&#x27;ve looked at this stuff internally.</div><br/></div></div></div></div></div></div><div id="36400789" class="c"><input type="checkbox" id="c-36400789" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#36400296">parent</a><span>|</span><a href="#36400384">prev</a><span>|</span><a href="#36400379">next</a><span>|</span><label class="collapse" for="c-36400789">[-]</label><label class="expand" for="c-36400789">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Create an operating system specifically for the database and make it so you boot the database.<p>I have the impression that this is similar to the adhoc filesystem idea; this seems in principle very advantageous (why employing two layers that do approximately the same thing on top of each other?), but in reality, when implemented (by Oracle), it lead to only a minor improvement (a few % points, AFAIR).</div><br/></div></div><div id="36400379" class="c"><input type="checkbox" id="c-36400379" checked=""/><div class="controls bullet"><span class="by">dialogbox</span><span>|</span><a href="#36400296">parent</a><span>|</span><a href="#36400789">prev</a><span>|</span><a href="#36400461">next</a><span>|</span><label class="collapse" for="c-36400379">[-]</label><label class="expand" for="c-36400379">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you mean by OS.
If you mean a whole new kernel, it will take decades. They can support only small number of HW. If you mean a specialized linux distro, many companies does that already.<p>I don&#x27;t know how that can make it easier the process based &#x2F; thread based problem.</div><br/><div id="36400625" class="c"><input type="checkbox" id="c-36400625" checked=""/><div class="controls bullet"><span class="by">rossmohax</span><span>|</span><a href="#36400296">root</a><span>|</span><a href="#36400379">parent</a><span>|</span><a href="#36400461">next</a><span>|</span><label class="collapse" for="c-36400625">[-]</label><label class="expand" for="c-36400625">[1 more]</label></div><br/><div class="children"><div class="content">This project could borrow a lot from unikernels. If they mandate running it as a VM, there is no HW to support.</div><br/></div></div></div></div><div id="36400461" class="c"><input type="checkbox" id="c-36400461" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#36400296">parent</a><span>|</span><a href="#36400379">prev</a><span>|</span><a href="#36400628">next</a><span>|</span><label class="collapse" for="c-36400461">[-]</label><label class="expand" for="c-36400461">[1 more]</label></div><br/><div class="children"><div class="content">You mean like Microsoft SQL Server, which basically runs a small OS on top of Windows or Linux?<p>This is actually part of the reason why Microsoft was able to port SQL Server to Linux fairly easily, if I recall correctly.</div><br/></div></div><div id="36400628" class="c"><input type="checkbox" id="c-36400628" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#36400296">parent</a><span>|</span><a href="#36400461">prev</a><span>|</span><a href="#36395782">next</a><span>|</span><label class="collapse" for="c-36400628">[-]</label><label class="expand" for="c-36400628">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like IBM OS&#x2F;400.</div><br/></div></div></div></div><div id="36395782" class="c"><input type="checkbox" id="c-36395782" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#36400296">prev</a><span>|</span><a href="#36393663">next</a><span>|</span><label class="collapse" for="c-36395782">[-]</label><label class="expand" for="c-36395782">[7 more]</label></div><br/><div class="children"><div class="content">This reminds me of this poster: &quot;You must be this tall...&quot;<p><a href="https:&#x2F;&#x2F;bholley.net&#x2F;blog&#x2F;2015&#x2F;must-be-this-tall-to-write-multi-threaded-code.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;bholley.net&#x2F;blog&#x2F;2015&#x2F;must-be-this-tall-to-write-mul...</a><p>Back about a decade ago I was &quot;auditing&quot; someone else&#x27;s threaded code.  And couldn&#x27;t figure it out.  But he was the company&#x27;s &quot;golden child&quot; so by default it must be working code because he wrote it.<p>And then it started causing deadlocks in prod.<p>&quot;What do you want me to do about it?  It&#x27;s the golden child&#x27;s code.  He&#x27;s not even gonna show up til 2pm today.&quot;</div><br/><div id="36396753" class="c"><input type="checkbox" id="c-36396753" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#36395782">parent</a><span>|</span><a href="#36393663">next</a><span>|</span><label class="collapse" for="c-36396753">[-]</label><label class="expand" for="c-36396753">[6 more]</label></div><br/><div class="children"><div class="content">The thing is... multi-process with a bespoke shared memory system isn&#x27;t better than multithreading; it&#x27;s much worse.</div><br/><div id="36401224" class="c"><input type="checkbox" id="c-36401224" checked=""/><div class="controls bullet"><span class="by">citrin_ru</span><span>|</span><a href="#36395782">root</a><span>|</span><a href="#36396753">parent</a><span>|</span><a href="#36398310">next</a><span>|</span><label class="collapse" for="c-36401224">[-]</label><label class="expand" for="c-36401224">[1 more]</label></div><br/><div class="children"><div class="content">The difference is between everything shared (threads) and some parts are shared explicitly (processes with shared memory). I&#x27;m not sure 2nd is worse.</div><br/></div></div><div id="36398310" class="c"><input type="checkbox" id="c-36398310" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36395782">root</a><span>|</span><a href="#36396753">parent</a><span>|</span><a href="#36401224">prev</a><span>|</span><a href="#36398561">next</a><span>|</span><label class="collapse" for="c-36398310">[-]</label><label class="expand" for="c-36398310">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if I&#x27;d judge it as harshly, but you have a good point: A lot of debugging &#x2F; validation tooling understands threads, but not memory shared between processes.</div><br/></div></div><div id="36398561" class="c"><input type="checkbox" id="c-36398561" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#36395782">root</a><span>|</span><a href="#36396753">parent</a><span>|</span><a href="#36398310">prev</a><span>|</span><a href="#36399779">next</a><span>|</span><label class="collapse" for="c-36398561">[-]</label><label class="expand" for="c-36398561">[1 more]</label></div><br/><div class="children"><div class="content">In Linux, multi process with shared memory regions is basically just threads. The kernel doesn’t know anything about threads, it knows about processes and it lets you share memory regions between those processes if you so desire.</div><br/></div></div><div id="36399779" class="c"><input type="checkbox" id="c-36399779" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36395782">root</a><span>|</span><a href="#36396753">parent</a><span>|</span><a href="#36398561">prev</a><span>|</span><a href="#36398546">next</a><span>|</span><label class="collapse" for="c-36399779">[-]</label><label class="expand" for="c-36399779">[1 more]</label></div><br/><div class="children"><div class="content">It kinda is though. The process barrier is better at enforcing careful deliberate interactions</div><br/></div></div><div id="36398546" class="c"><input type="checkbox" id="c-36398546" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#36395782">root</a><span>|</span><a href="#36396753">parent</a><span>|</span><a href="#36399779">prev</a><span>|</span><a href="#36393663">next</a><span>|</span><label class="collapse" for="c-36398546">[-]</label><label class="expand" for="c-36398546">[1 more]</label></div><br/><div class="children"><div class="content">By bespoke you mean using standard interfaces to create shared memory pools?<p>They do roll some of their own locking primitives, but that&#x27;s not particularly unusual in a large portable program (and quite likely what they wanted is&#x2F;was not available in glibc or other standard libraries, at least when first written).</div><br/></div></div></div></div></div></div><div id="36393663" class="c"><input type="checkbox" id="c-36393663" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36395782">prev</a><span>|</span><a href="#36399517">next</a><span>|</span><label class="collapse" for="c-36393663">[-]</label><label class="expand" for="c-36393663">[17 more]</label></div><br/><div class="children"><div class="content">Oracle has similar problems.<p>On UNIX systems, Oracle uses a multi-process model, and you can see these:<p><pre><code>  $ ps -ef | grep smon

  USER      PID  PPID  STARTED   TIME %CPU %MEM COMMAND
  oracle  22131     1   Mar 28   3:09  0.0  4.0 ora_smon_yourdb
</code></pre>
Windows forks processes about 100x slower than Linux, so Oracle runs threaded on that platform in one great big PID.<p>Sybase was the first major database that fully adopted threads from an architectural perspective, and Microsoft SQL Server has certainly retained and improved on that model.</div><br/><div id="36394001" class="c"><input type="checkbox" id="c-36394001" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#36393663">parent</a><span>|</span><a href="#36395650">next</a><span>|</span><label class="collapse" for="c-36394001">[-]</label><label class="expand" for="c-36394001">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Windows forks processes about 100x slower than Linux...<p>I work with a Windows-based COTS webapp that uses Postgres w&#x2F;o any connection pooling. It&#x27;s nearly excruciating to use because it spins-up new Postgres processes for each page load. If not for the fact that the Postgres install is &quot;turnkey&quot; with the app I&#x27;d just move Postgres over to a Linux machine.</div><br/><div id="36396386" class="c"><input type="checkbox" id="c-36396386" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394001">parent</a><span>|</span><a href="#36396006">next</a><span>|</span><label class="collapse" for="c-36396386">[-]</label><label class="expand" for="c-36396386">[1 more]</label></div><br/><div class="children"><div class="content">If you run postgres under WSLv1 (now available on Server Edition as well), the WSL subsystem handles processes and virtual memory in a way that has been specifically  designed to optimize process initialization as compared to the traditional Win32 approach.</div><br/></div></div><div id="36396006" class="c"><input type="checkbox" id="c-36396006" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394001">parent</a><span>|</span><a href="#36396386">prev</a><span>|</span><a href="#36394080">next</a><span>|</span><label class="collapse" for="c-36396006">[-]</label><label class="expand" for="c-36396006">[1 more]</label></div><br/><div class="children"><div class="content">It would not be difficult to simply &quot;pg_dump&quot; all the data to Postgres on a Linux machine, then quietly set the clients to use the new server.</div><br/></div></div><div id="36394080" class="c"><input type="checkbox" id="c-36394080" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394001">parent</a><span>|</span><a href="#36396006">prev</a><span>|</span><a href="#36395650">next</a><span>|</span><label class="collapse" for="c-36394080">[-]</label><label class="expand" for="c-36394080">[7 more]</label></div><br/><div class="children"><div class="content">Use pgbouncer</div><br/><div id="36394281" class="c"><input type="checkbox" id="c-36394281" checked=""/><div class="controls bullet"><span class="by">ethbr0</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394080">parent</a><span>|</span><a href="#36395742">next</a><span>|</span><label class="collapse" for="c-36394281">[-]</label><label class="expand" for="c-36394281">[5 more]</label></div><br/><div class="children"><div class="content">Was curious about this as an architectural solution as well.<p>We&#x27;re really talking about X-per-client as the primary reason to move away from processes, right?<p>So if you can get most of the benefit via pooling... why inherit the pain of porting?<p>Presumably latency jitter would be a difficult problem with pools, but it seems easier (and safer) than porting processes -&gt; threads.<p>Disclaimer: High performance &#x2F; low latency DB code is pretty far outside my wheelhouse.</div><br/><div id="36395193" class="c"><input type="checkbox" id="c-36395193" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394281">parent</a><span>|</span><a href="#36398347">next</a><span>|</span><label class="collapse" for="c-36395193">[-]</label><label class="expand" for="c-36395193">[2 more]</label></div><br/><div class="children"><div class="content">The reasons are explained in article. Read the article</div><br/><div id="36398171" class="c"><input type="checkbox" id="c-36398171" checked=""/><div class="controls bullet"><span class="by">ethbr0</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36395193">parent</a><span>|</span><a href="#36398347">next</a><span>|</span><label class="collapse" for="c-36398171">[-]</label><label class="expand" for="c-36398171">[1 more]</label></div><br/><div class="children"><div class="content">I appear to have missed them, then.<p>Could you point out, aside from the large numbers of clients I mentioned (and the development overhead of implementing multi-process memory management code), what the article mentions is a primary drawback of using processes over threads?</div><br/></div></div></div></div><div id="36398347" class="c"><input type="checkbox" id="c-36398347" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394281">parent</a><span>|</span><a href="#36395193">prev</a><span>|</span><a href="#36394826">next</a><span>|</span><label class="collapse" for="c-36398347">[-]</label><label class="expand" for="c-36398347">[1 more]</label></div><br/><div class="children"><div class="content">pgbouncer is not transparent, you loose features, particularly when using the pooling mode actually allowing a larger number of active concurrent connections. Solving those issues is a <i>lot</i> easier with threads than with processes.</div><br/></div></div><div id="36394826" class="c"><input type="checkbox" id="c-36394826" checked=""/><div class="controls bullet"><span class="by">ddorian43</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394281">parent</a><span>|</span><a href="#36398347">prev</a><span>|</span><a href="#36395742">next</a><span>|</span><label class="collapse" for="c-36394826">[-]</label><label class="expand" for="c-36394826">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We&#x27;re really talking about X-per-client as the primary reason to move away from processes, right?<p>Many other things too. Like better sharing of caches. Lower overhead of thread instead of process. Etc. (read the thread)</div><br/></div></div></div></div><div id="36395742" class="c"><input type="checkbox" id="c-36395742" checked=""/><div class="controls bullet"><span class="by">treis</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36394080">parent</a><span>|</span><a href="#36394281">prev</a><span>|</span><a href="#36395650">next</a><span>|</span><label class="collapse" for="c-36395742">[-]</label><label class="expand" for="c-36395742">[1 more]</label></div><br/><div class="children"><div class="content">That helps a lot but it&#x27;s not a replacement for large number of persistent connections.  If you had that you could simplify things in the application layer and do interesting things with the DB.</div><br/></div></div></div></div></div></div><div id="36395650" class="c"><input type="checkbox" id="c-36395650" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#36393663">parent</a><span>|</span><a href="#36394001">prev</a><span>|</span><a href="#36399517">next</a><span>|</span><label class="collapse" for="c-36395650">[-]</label><label class="expand" for="c-36395650">[6 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t Oracle switch to threaded model in 12c - at least on Linux I remember there being a parameter to do that - it dropped the number of processes significantly.</div><br/><div id="36396046" class="c"><input type="checkbox" id="c-36396046" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36395650">parent</a><span>|</span><a href="#36396243">next</a><span>|</span><label class="collapse" for="c-36396046">[-]</label><label class="expand" for="c-36396046">[4 more]</label></div><br/><div class="children"><div class="content">No, I ran that on v19.<p><pre><code>  $ ps -ef | grep smon
  UID        PID  PPID  C STIME TTY          TIME CMD
  oracle   22131     1  0 Mar28 ?        00:03:09 ora_smon_yourdb

  $ $ORACLE_HOME&#x2F;bin&#x2F;sqlplus -silent &#x27;&#x2F; as sysdba&#x27;
  select version_full from v$instance;

  VERSION_FULL
  -----------------
  19.18.0.0.0</code></pre></div><br/><div id="36396176" class="c"><input type="checkbox" id="c-36396176" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36396046">parent</a><span>|</span><a href="#36396243">next</a><span>|</span><label class="collapse" for="c-36396176">[-]</label><label class="expand" for="c-36396176">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;oracle-base.com&#x2F;articles&#x2F;12c&#x2F;multithreaded-model-using-threaded_execution_12cr1" rel="nofollow noreferrer">https:&#x2F;&#x2F;oracle-base.com&#x2F;articles&#x2F;12c&#x2F;multithreaded-model-usi...</a><p>Probably still requires the parameter to be set.</div><br/><div id="36396278" class="c"><input type="checkbox" id="c-36396278" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36396176">parent</a><span>|</span><a href="#36396243">next</a><span>|</span><label class="collapse" for="c-36396278">[-]</label><label class="expand" for="c-36396278">[2 more]</label></div><br/><div class="children"><div class="content">Contrast this to Microsoft SQL Server:<p><pre><code>  $ systemctl status mssql-server
  ● mssql-server.service - Microsoft SQL Server Database Engine
     Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;mssql-server.service; disabled; vendor preset: disabled)
     Active: active (running) since Mon 2023-06-19 15:48:05 CDT; 1min 18s ago
       Docs: https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;linux
   Main PID: 2125 (sqlservr)
      Tasks: 123
     CGroup: &#x2F;system.slice&#x2F;mssql-server.service
             ├─2125 &#x2F;opt&#x2F;mssql&#x2F;bin&#x2F;sqlservr
             └─2156 &#x2F;opt&#x2F;mssql&#x2F;bin&#x2F;sqlservr</code></pre></div><br/><div id="36396421" class="c"><input type="checkbox" id="c-36396421" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36396278">parent</a><span>|</span><a href="#36396243">next</a><span>|</span><label class="collapse" for="c-36396421">[-]</label><label class="expand" for="c-36396421">[1 more]</label></div><br/><div class="children"><div class="content">Yeah multiprocess isn&#x27;t Microsoft&#x27;s style given how expensive creating processes is on Windows.<p>Oracle - never had a scalability issue on very big Linux, Solaris and HPUX systems though - they do it well in my experience.</div><br/></div></div></div></div></div></div></div></div><div id="36396243" class="c"><input type="checkbox" id="c-36396243" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#36393663">root</a><span>|</span><a href="#36395650">parent</a><span>|</span><a href="#36396046">prev</a><span>|</span><a href="#36399517">next</a><span>|</span><label class="collapse" for="c-36396243">[-]</label><label class="expand" for="c-36396243">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Didn&#x27;t Oracle switch to threaded model in 12c<p>It&#x27;s optional, and the default is still a process model on Linux.</div><br/></div></div></div></div></div></div><div id="36399517" class="c"><input type="checkbox" id="c-36399517" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#36393663">prev</a><span>|</span><a href="#36395082">next</a><span>|</span><label class="collapse" for="c-36399517">[-]</label><label class="expand" for="c-36399517">[6 more]</label></div><br/><div class="children"><div class="content">A close to impossible task, if anyone can do it&#x27;s probably Heikki though.<p>Unfortunately I expect this to go the way of zheap et al. Fundamental design changes like this have just had such a rough time of succeeding thus far.<p>I think for such a change to work it probably needs not just the support of Neon but also of say Microsoft (current stewards of Citus) that have larger engineering resources to throw at the problem and grind out all the bugs.</div><br/><div id="36399568" class="c"><input type="checkbox" id="c-36399568" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36399517">parent</a><span>|</span><a href="#36399688">next</a><span>|</span><label class="collapse" for="c-36399568">[-]</label><label class="expand" for="c-36399568">[2 more]</label></div><br/><div class="children"><div class="content">I know that at least people from EDB (Robert) and Microsoft (Thomas, me) are quite interested in eventually making this transition, it&#x27;s not just Heikki. Personally I won&#x27;t have a lot of cycles for the next release or two, but after that...</div><br/><div id="36399816" class="c"><input type="checkbox" id="c-36399816" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#36399517">root</a><span>|</span><a href="#36399568">parent</a><span>|</span><a href="#36399688">next</a><span>|</span><label class="collapse" for="c-36399816">[-]</label><label class="expand" for="c-36399816">[1 more]</label></div><br/><div class="children"><div class="content">That gives me some faith, I hope everyone is able to come together to make it happen.</div><br/></div></div></div></div><div id="36399688" class="c"><input type="checkbox" id="c-36399688" checked=""/><div class="controls bullet"><span class="by">rashidujang</span><span>|</span><a href="#36399517">parent</a><span>|</span><a href="#36399568">prev</a><span>|</span><a href="#36395082">next</a><span>|</span><label class="collapse" for="c-36399688">[-]</label><label class="expand" for="c-36399688">[3 more]</label></div><br/><div class="children"><div class="content">Hey I&#x27;m fairly new to the who&#x27;s who in the PostgreSQL world, would you mind telling why Heikki might be able to pull this off?</div><br/><div id="36399840" class="c"><input type="checkbox" id="c-36399840" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36399517">root</a><span>|</span><a href="#36399688">parent</a><span>|</span><a href="#36395082">next</a><span>|</span><label class="collapse" for="c-36399840">[-]</label><label class="expand" for="c-36399840">[2 more]</label></div><br/><div class="children"><div class="content">Not who you asked, but: He is a longtime contributor who has written&#x2F;resigned important parts of postgres (WAL format, concurrent WAL insertion, 2PC support, parts of SSI support, much more). And he is just a nice person to work with.</div><br/><div id="36400791" class="c"><input type="checkbox" id="c-36400791" checked=""/><div class="controls bullet"><span class="by">rashidujang</span><span>|</span><a href="#36399517">root</a><span>|</span><a href="#36399840">parent</a><span>|</span><a href="#36395082">next</a><span>|</span><label class="collapse" for="c-36400791">[-]</label><label class="expand" for="c-36400791">[1 more]</label></div><br/><div class="children"><div class="content">Cool! He seems like a powerhouse in this space - thank you for the answer</div><br/></div></div></div></div></div></div></div></div><div id="36395082" class="c"><input type="checkbox" id="c-36395082" checked=""/><div class="controls bullet"><span class="by">mynonameaccount</span><span>|</span><a href="#36399517">prev</a><span>|</span><a href="#36394511">next</a><span>|</span><label class="collapse" for="c-36395082">[-]</label><label class="expand" for="c-36395082">[5 more]</label></div><br/><div class="children"><div class="content">&quot;the benefits would not justify the cost&quot;. PostgreSQL, like any software, at some point in it&#x27;s life need to be refactored. Why not refactor with a thread model. Of course there will be bugs. Of course it will be difficult. But I think it is a worthwhile endeavor. Doesn&#x27;t sound like this will happen but a new project would be cool.</div><br/><div id="36395318" class="c"><input type="checkbox" id="c-36395318" checked=""/><div class="controls bullet"><span class="by">timtom39</span><span>|</span><a href="#36395082">parent</a><span>|</span><a href="#36395332">next</a><span>|</span><label class="collapse" for="c-36395318">[-]</label><label class="expand" for="c-36395318">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  like any software, at some point in it&#x27;s life need to be refactored.<p>This is simply not true for most software. Software has a product life cycle like everything else and major refactors&#x2F;rewrites should be weighed carefully against cost&#x2F;risk of the refactor. Many traditional engineering fields do much better at this analysis.<p>Although, because I run a contracting shop, I have personally profited greatly by clients thinking this is true and being unable to convince them otherwise.</div><br/></div></div><div id="36395332" class="c"><input type="checkbox" id="c-36395332" checked=""/><div class="controls bullet"><span class="by">smsm42</span><span>|</span><a href="#36395082">parent</a><span>|</span><a href="#36395318">prev</a><span>|</span><a href="#36395373">next</a><span>|</span><label class="collapse" for="c-36395332">[-]</label><label class="expand" for="c-36395332">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Difficult&quot; doesn&#x27;t even begin to do it justice. Making a code which has 2k global variables and probably order of magnitude as many underlying assumptions (the code should know that now every time you touch X you may be influenced or influence all other threads that may touch X) is a gargantuan task, and will absolutely for sure involve many iterations which any sane person would never let anywhere near valuable data (and how long would it take until you&#x27;d consider it safe enough?). And making this all performant - given that shared-state code requires completely different approach to thinking about workload distribution, something that performs when running in isolated processes may very well get bogged down in locking or cache races hell when sharing the state - would be even harder. I am not doubting Postgres has some very smart people - much, much smarter than me, in any case - but I&#x27;d say it could be more practical to write new core from scratch than trying to &quot;refactor&quot; the core that organically grew for decades with assumptions of share-nothing model.</div><br/></div></div><div id="36395373" class="c"><input type="checkbox" id="c-36395373" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#36395082">parent</a><span>|</span><a href="#36395332">prev</a><span>|</span><a href="#36395703">next</a><span>|</span><label class="collapse" for="c-36395373">[-]</label><label class="expand" for="c-36395373">[1 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re talking about is a rewrite, not a refactor.</div><br/></div></div><div id="36395703" class="c"><input type="checkbox" id="c-36395703" checked=""/><div class="controls bullet"><span class="by">gremlinsinc</span><span>|</span><a href="#36395082">parent</a><span>|</span><a href="#36395373">prev</a><span>|</span><a href="#36394511">next</a><span>|</span><label class="collapse" for="c-36395703">[-]</label><label class="expand" for="c-36395703">[1 more]</label></div><br/><div class="children"><div class="content">a better option would just create an experimental fork that has a different name and is obviously a different product but based on the original source. That way pg gets updates and remains stable and if they fail, they fail and it doesn&#x27;t hurt all the pg in production.</div><br/></div></div></div></div><div id="36394511" class="c"><input type="checkbox" id="c-36394511" checked=""/><div class="controls bullet"><span class="by">levkk</span><span>|</span><a href="#36395082">prev</a><span>|</span><a href="#36393362">next</a><span>|</span><label class="collapse" for="c-36394511">[-]</label><label class="expand" for="c-36394511">[8 more]</label></div><br/><div class="children"><div class="content">Pretty sure Tom Lane said this will be a disaster in that same pgsql-hackers thread. Not entirely sure what benefits the multi-threaded model will have when you can easily saturate the entire CPU with just 128 connections and a pooler. So I doubt there is consensus or even strong desire from the community to undertake this boil the ocean project.<p>On the other hand, having the ability to shut down and cleanup the entire memory space of a single connection by just disconnecting is really nice, especially if you have extensions that do interesting things.</div><br/><div id="36394923" class="c"><input type="checkbox" id="c-36394923" checked=""/><div class="controls bullet"><span class="by">BoardsOfCanada</span><span>|</span><a href="#36394511">parent</a><span>|</span><a href="#36395158">next</a><span>|</span><label class="collapse" for="c-36394923">[-]</label><label class="expand" for="c-36394923">[6 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; Tom Lane said: &quot;I think this will be a disaster. There is far too much code that will get broken&quot;. He added later that the cost of this change would be &quot;enormous&quot;, it would create &quot;more than one security-grade bug&quot;, and that the benefits would not justify the cost.</div><br/><div id="36397104" class="c"><input type="checkbox" id="c-36397104" checked=""/><div class="controls bullet"><span class="by">timcobb</span><span>|</span><a href="#36394511">root</a><span>|</span><a href="#36394923">parent</a><span>|</span><a href="#36395158">next</a><span>|</span><label class="collapse" for="c-36397104">[-]</label><label class="expand" for="c-36397104">[5 more]</label></div><br/><div class="children"><div class="content">You can think of this as an opportunity to rewrite in Rust.</div><br/><div id="36397413" class="c"><input type="checkbox" id="c-36397413" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#36394511">root</a><span>|</span><a href="#36397104">parent</a><span>|</span><a href="#36395158">next</a><span>|</span><label class="collapse" for="c-36397413">[-]</label><label class="expand" for="c-36397413">[4 more]</label></div><br/><div class="children"><div class="content">AfterPostgres</div><br/><div id="36399118" class="c"><input type="checkbox" id="c-36399118" checked=""/><div class="controls bullet"><span class="by">krylon</span><span>|</span><a href="#36394511">root</a><span>|</span><a href="#36397413">parent</a><span>|</span><a href="#36395158">next</a><span>|</span><label class="collapse" for="c-36399118">[-]</label><label class="expand" for="c-36399118">[3 more]</label></div><br/><div class="children"><div class="content">May I humbly suggest PostPostgres, or Post²gres?</div><br/><div id="36399561" class="c"><input type="checkbox" id="c-36399561" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#36394511">root</a><span>|</span><a href="#36399118">parent</a><span>|</span><a href="#36395158">next</a><span>|</span><label class="collapse" for="c-36399561">[-]</label><label class="expand" for="c-36399561">[2 more]</label></div><br/><div class="children"><div class="content">2Post2Furigres</div><br/><div id="36400282" class="c"><input type="checkbox" id="c-36400282" checked=""/><div class="controls bullet"><span class="by">moi2388</span><span>|</span><a href="#36394511">root</a><span>|</span><a href="#36399561">parent</a><span>|</span><a href="#36395158">next</a><span>|</span><label class="collapse" for="c-36400282">[-]</label><label class="expand" for="c-36400282">[1 more]</label></div><br/><div class="children"><div class="content">Postgr3s: Tokyo Thread</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36395158" class="c"><input type="checkbox" id="c-36395158" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36394511">parent</a><span>|</span><a href="#36394923">prev</a><span>|</span><a href="#36393362">next</a><span>|</span><label class="collapse" for="c-36395158">[-]</label><label class="expand" for="c-36395158">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Not entirely sure what benefits the multi-threaded model will have when you can easily saturate the entire CPU with just 128 connections and a pooler.<p>That the all of those would work faster because of performance benefits, as mentioned in article</div><br/></div></div></div></div><div id="36393362" class="c"><input type="checkbox" id="c-36393362" checked=""/><div class="controls bullet"><span class="by">lukeschlather</span><span>|</span><a href="#36394511">prev</a><span>|</span><a href="#36395586">next</a><span>|</span><label class="collapse" for="c-36393362">[-]</label><label class="expand" for="c-36393362">[16 more]</label></div><br/><div class="children"><div class="content">This sounds like a problem that would border on the complexity of replacing the GIL in Ruby or Python. The performance benefits are obvious but it seems like the correctness problems would be myriad and a constant source of (unpleasant) surprises.</div><br/><div id="36393699" class="c"><input type="checkbox" id="c-36393699" checked=""/><div class="controls bullet"><span class="by">cactusfrog</span><span>|</span><a href="#36393362">parent</a><span>|</span><a href="#36400553">next</a><span>|</span><label class="collapse" for="c-36393699">[-]</label><label class="expand" for="c-36393699">[9 more]</label></div><br/><div class="children"><div class="content">This is different because there isn’t a whole ecosystem of packages that depend on access to a thread unsafe C API. Getting the GIL out of core Python isn’t too challenging. Getting all of the packages that depend on Python’s C API working is.</div><br/><div id="36393770" class="c"><input type="checkbox" id="c-36393770" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393699">parent</a><span>|</span><a href="#36393944">next</a><span>|</span><label class="collapse" for="c-36393770">[-]</label><label class="expand" for="c-36393770">[5 more]</label></div><br/><div class="children"><div class="content">An other component of the Gil story is that removing the Gil require adding fine grained locks, which (aside from making VM development more complicated) significantly increases lock traffic and thus runtime costs, which noticeably impacts single-threaded performance, which is of major import.<p>Postgres starts from a share-nothing architecture, it’s quite a bit easier to evaluate the addition of sharing.</div><br/><div id="36396629" class="c"><input type="checkbox" id="c-36396629" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393770">parent</a><span>|</span><a href="#36395669">next</a><span>|</span><label class="collapse" for="c-36396629">[-]</label><label class="expand" for="c-36396629">[1 more]</label></div><br/><div class="children"><div class="content">Postgres already shares a lot of state between processes via shared memory. There&#x27;s not a whole lot that would initially change from a concurrency perspective.</div><br/></div></div><div id="36395669" class="c"><input type="checkbox" id="c-36395669" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393770">parent</a><span>|</span><a href="#36396629">prev</a><span>|</span><a href="#36396064">next</a><span>|</span><label class="collapse" for="c-36395669">[-]</label><label class="expand" for="c-36395669">[1 more]</label></div><br/><div class="children"><div class="content">&gt; which (aside from making VM development more complicated) significantly increases lock traffic and thus runtime costs, which noticeably impacts single-threaded performance, which is of major import.<p>I don&#x27;t think that&#x27;s a fair characterization of the trade offs. Acquiring uncontended mutexes is basically free (and fairly side-effect free) so single-threaded performance will not be noticeably impacted.<p>Every large C project I&#x27;m aware of (read: kernels) that has publicly switched from coarse locks to fine-grained locks has considered it to be a huge win with little to no impact on single-threaded performance. You can even gain performance if you chop up objects or allocations into finer-grained blobs to fit your finer-grained locking strategy because it can play nicer with cache friendliness (accessing one bit of code doesn&#x27;t kick the other bits of code out of the cache).</div><br/></div></div><div id="36396064" class="c"><input type="checkbox" id="c-36396064" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393770">parent</a><span>|</span><a href="#36395669">prev</a><span>|</span><a href="#36393944">next</a><span>|</span><label class="collapse" for="c-36396064">[-]</label><label class="expand" for="c-36396064">[2 more]</label></div><br/><div class="children"><div class="content">&gt; which noticeably impacts single-threaded performance, which is of major import.<p>1) I don&#x27;t buy this a priori.  Almost everybody who removed a gigantic lock suddenly realizes that there was more contention than they thought and that atomizing it made performance improve.<p>2) Had Python bitten the bullet and removed the GIL back at Python 3.0, the performance would likely already be back to normal or better.  You can&#x27;t optimize hypothetically.  Optimization on something like Python is an accumulation of lots of small wins.</div><br/><div id="36400020" class="c"><input type="checkbox" id="c-36400020" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36396064">parent</a><span>|</span><a href="#36393944">next</a><span>|</span><label class="collapse" for="c-36400020">[-]</label><label class="expand" for="c-36400020">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t buy this a priori.<p>You don’t have to buy anything, that’s been the result of every attempt so far and a big reason for their rejection. The latest effort only gained some traction because the backers also did optimisation work which compensated (and then was merged separately).<p>&gt; Almost everybody who removed a gigantic lock<p>See that’s the issue with your response, you’re not actually reading the comment you’re replying to.<p>And the “almost” is a big tell.<p>&gt; suddenly realizes that there was more contention than they thought and that atomizing it made performance improve.<p>There is no contention on the gil in single threaded workloads.<p>&gt; Had Python bitten the bullet and removed the GIL back at Python 3.0<p>It would have taken several more years and been completely DOA.</div><br/></div></div></div></div></div></div><div id="36393944" class="c"><input type="checkbox" id="c-36393944" checked=""/><div class="controls bullet"><span class="by">erikpukinskis</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393699">parent</a><span>|</span><a href="#36393770">prev</a><span>|</span><a href="#36400553">next</a><span>|</span><label class="collapse" for="c-36393944">[-]</label><label class="expand" for="c-36393944">[3 more]</label></div><br/><div class="children"><div class="content">&gt; there isn’t a whole ecosystem of packages that depend on access to a thread unsafe C API<p>They mentioned a similar issue for Postgres extensions, no?<p>&gt; Haas, though, is not convinced that it would ever be possible to remove support for the process-based mode. Threads might not perform better for all use cases, or some important extensions may never gain support for running in threads.</div><br/><div id="36394276" class="c"><input type="checkbox" id="c-36394276" checked=""/><div class="controls bullet"><span class="by">scolby33</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393944">parent</a><span>|</span><a href="#36400553">next</a><span>|</span><label class="collapse" for="c-36394276">[-]</label><label class="expand" for="c-36394276">[2 more]</label></div><br/><div class="children"><div class="content">I question how important an extension is if there’s not enough incentive to port it to the new paradigm, at least eventually.</div><br/><div id="36396398" class="c"><input type="checkbox" id="c-36396398" checked=""/><div class="controls bullet"><span class="by">abalashov</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36394276">parent</a><span>|</span><a href="#36400553">next</a><span>|</span><label class="collapse" for="c-36396398">[-]</label><label class="expand" for="c-36396398">[1 more]</label></div><br/><div class="children"><div class="content">Well. The thing with that is just that there are a lot of extensions. Like, a lot!</div><br/></div></div></div></div></div></div></div></div><div id="36400553" class="c"><input type="checkbox" id="c-36400553" checked=""/><div class="controls bullet"><span class="by">dialogbox</span><span>|</span><a href="#36393362">parent</a><span>|</span><a href="#36393699">prev</a><span>|</span><a href="#36393508">next</a><span>|</span><label class="collapse" for="c-36400553">[-]</label><label class="expand" for="c-36400553">[1 more]</label></div><br/><div class="children"><div class="content">Even the performance benefits are not big enough compare to the GIL.<p>Biggest problem of the process model might be the cost of having too many DB connections. Each client need a dedicated server process. Memory usage and the context switching overhead. Or if there is no connection pool, connection time overhead is very high.<p>This problem has been well addressed with a connection pool. Or having a middle ware instead of exposing the DB directly. That works very well so far.<p>Oracle has been supporting the thread based model and it&#x27;s been usable for decades. I remember I tried the thread based configuration option (MTS or shared server) in 1990s. But no one likes that at least within my Oracle DBA network.<p>It would be a great research project but it would be a big problem if the community pushs this too early.</div><br/></div></div><div id="36393508" class="c"><input type="checkbox" id="c-36393508" checked=""/><div class="controls bullet"><span class="by">narrator</span><span>|</span><a href="#36393362">parent</a><span>|</span><a href="#36400553">prev</a><span>|</span><a href="#36393866">next</a><span>|</span><label class="collapse" for="c-36393508">[-]</label><label class="expand" for="c-36393508">[3 more]</label></div><br/><div class="children"><div class="content">The correctness problem should be handled by a suite of automated tests which PostgreSQL has.  If all tests pass, the application must work correctly.  The project is too big, and has too many developers to make much progress without full test coverage.  Where else would up-to-date documentation regarding the correct behavior of PostgreSQL exist? In some developers head?  SQLite is pretty famous for there extreme approach to testing including out of memory conditions, and other rare circumstances: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html</a></div><br/><div id="36393714" class="c"><input type="checkbox" id="c-36393714" checked=""/><div class="controls bullet"><span class="by">lukeschlather</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393508">parent</a><span>|</span><a href="#36396426">next</a><span>|</span><label class="collapse" for="c-36393714">[-]</label><label class="expand" for="c-36393714">[1 more]</label></div><br/><div class="children"><div class="content">Parallelism is often incredibly hard to write automated tests for, and this will most likely create parallelism issues that were not dreamed of by the authors of the test suite.</div><br/></div></div><div id="36396426" class="c"><input type="checkbox" id="c-36396426" checked=""/><div class="controls bullet"><span class="by">abalashov</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393508">parent</a><span>|</span><a href="#36393714">prev</a><span>|</span><a href="#36393866">next</a><span>|</span><label class="collapse" for="c-36396426">[-]</label><label class="expand" for="c-36396426">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If all tests pass, the application must work correctly.<p>These are &quot;famous last words&quot; in many contexts, but when talking about difficult-to-reproduce parallelism issues, I just don&#x27;t think it&#x27;s a particularly applicable viewpoint at all. No disrespect. :)</div><br/></div></div></div></div><div id="36393866" class="c"><input type="checkbox" id="c-36393866" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#36393362">parent</a><span>|</span><a href="#36393508">prev</a><span>|</span><a href="#36395586">next</a><span>|</span><label class="collapse" for="c-36393866">[-]</label><label class="expand" for="c-36393866">[2 more]</label></div><br/><div class="children"><div class="content">Does GIL stand for Global Interpreter Lock?</div><br/><div id="36394022" class="c"><input type="checkbox" id="c-36394022" checked=""/><div class="controls bullet"><span class="by">Yujf</span><span>|</span><a href="#36393362">root</a><span>|</span><a href="#36393866">parent</a><span>|</span><a href="#36395586">next</a><span>|</span><label class="collapse" for="c-36394022">[-]</label><label class="expand" for="c-36394022">[1 more]</label></div><br/><div class="children"><div class="content">yes</div><br/></div></div></div></div></div></div><div id="36395586" class="c"><input type="checkbox" id="c-36395586" checked=""/><div class="controls bullet"><span class="by">jasonhansel</span><span>|</span><a href="#36393362">prev</a><span>|</span><a href="#36395916">next</a><span>|</span><label class="collapse" for="c-36395586">[-]</label><label class="expand" for="c-36395586">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m rather surprised that their focus is on improving vertical scalability, rather than on adding more features for scaling Postgres horizontally.</div><br/><div id="36397459" class="c"><input type="checkbox" id="c-36397459" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#36395586">parent</a><span>|</span><a href="#36395916">next</a><span>|</span><label class="collapse" for="c-36397459">[-]</label><label class="expand" for="c-36397459">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re more interested in horizontal scaling, you may want to look into CockroachDB, which has a Postgres compatible protocol, but still quite different.  There are a lot more limitations with CDB over Pg though.<p>With the changes suggested, I&#x27;m not sure it&#x27;s the best idea from where Postgres is... if might be an opportunity to rewrite bits in Rust, but even then, there is a <i>LOT</i> that can go wrong.  The use of shared memory is apparently already in place, and the separate process and inter-process communication isn&#x27;t the most dangerous part... it&#x27;s the presumption, variables and other contextual bits that are currently process globals that wouldn&#x27;t be in the &quot;after&quot; version.<p>The overall surface is just massive... That doesn&#x27;t even get into plugin compatibility.</div><br/></div></div></div></div><div id="36395916" class="c"><input type="checkbox" id="c-36395916" checked=""/><div class="controls bullet"><span class="by">mastax</span><span>|</span><a href="#36395586">prev</a><span>|</span><a href="#36393516">next</a><span>|</span><label class="collapse" for="c-36395916">[-]</label><label class="expand" for="c-36395916">[7 more]</label></div><br/><div class="children"><div class="content">It would be interesting to have something between threads and processes. I&#x27;ll call them heavy-threads for sake of discussion.<p>Like light-threads, heavy-threads would share the same process-security-boundary and therefore switching between them would be cheap. No need to flush TLB, I$, D$.<p>Like processes, heavy-threads would have mostly-separate address spaces by default. Similar to forking a process, they could share read-only mappings for shared libraries, code, COW global variables, and explicitly defined shared writable memory regions.<p>Like processes, heavy-threads would isolate failure states. A C++ exception, UNIX signal, segfault, etc. would kill only the heavy-thread responsible.</div><br/><div id="36396284" class="c"><input type="checkbox" id="c-36396284" checked=""/><div class="controls bullet"><span class="by">mattashii</span><span>|</span><a href="#36395916">parent</a><span>|</span><a href="#36396866">next</a><span>|</span><label class="collapse" for="c-36396284">[-]</label><label class="expand" for="c-36396284">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No need to flush TLB<p>TLB isn&#x27;t &quot;flushed&quot; so much as it is useless across different memory address spaces. Switching processes means switching address spaces, which means you have to switch the contents of the TLB to the new process&#x27; TLB entries, which eventually indeed flushes the TLB, but that is only over time, not necessarily the moment you switch processes.<p>&gt; Like processes, heavy-threads would have mostly-separate address spaces by default.<p>This thus conflicts with the need to not flush TLBs. You can&#x27;t not change TLB contents across address spaces.</div><br/></div></div><div id="36396866" class="c"><input type="checkbox" id="c-36396866" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36395916">parent</a><span>|</span><a href="#36396284">prev</a><span>|</span><a href="#36397891">next</a><span>|</span><label class="collapse" for="c-36396866">[-]</label><label class="expand" for="c-36396866">[1 more]</label></div><br/><div class="children"><div class="content">There are some problems.<p>1. Mostly separate address spaces requires changing the TLB on context switch (modern hw lets it be partial). You could use MPKs to share a single address space with fast protection switches.<p>2. Threads share the global heap, but your heavy threads would require explicitly defined shared writeable memory regions, so presumably each one has its own heap. That&#x27;s a fair bit of overhead.<p>3. Failure isolation is more complicated than deciding what to kill.<p>The expand on the last point, Postgres <i>doesn&#x27;t</i> isolate failures to a single process because they do share memory and might corrupt those shared memory regions. But even if you don&#x27;t have shared memory failure recovery isn&#x27;t always easy. Software has to be written specifically to plan for it. You can kill processes because everything in the OS is written around allowing for that possibility, for example, shells know what to do if a sub-process is killed unexpectedly. Killing a heavy thread (=process) is no good if the parent process is going to wait for a reply from it forever because it wasn&#x27;t written to handle the process going away.</div><br/></div></div><div id="36397891" class="c"><input type="checkbox" id="c-36397891" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36395916">parent</a><span>|</span><a href="#36396866">prev</a><span>|</span><a href="#36396138">next</a><span>|</span><label class="collapse" for="c-36397891">[-]</label><label class="expand" for="c-36397891">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Like light-threads, heavy-threads would share the same process-security-boundary and therefore switching between them would be cheap. No need to flush TLB, I$, D$.<p>&gt; Like processes, heavy-threads would have mostly-separate address spaces by default. Similar to forking a process, they could share read-only mappings for shared libraries, code, COW global variables, and explicitly defined shared writable memory regions.<p>I don&#x27;t think you realistically can have separate address spaces and not have TLB etc impact. If they&#x27;re separate address spaces, you need separate TLB entries =&gt; lower TLB hit ratio.</div><br/></div></div><div id="36396138" class="c"><input type="checkbox" id="c-36396138" checked=""/><div class="controls bullet"><span class="by">dasyatidprime</span><span>|</span><a href="#36395916">parent</a><span>|</span><a href="#36397891">prev</a><span>|</span><a href="#36396140">next</a><span>|</span><label class="collapse" for="c-36396138">[-]</label><label class="expand" for="c-36396138">[1 more]</label></div><br/><div class="children"><div class="content">So what would be different between those and forked processes?</div><br/></div></div><div id="36396140" class="c"><input type="checkbox" id="c-36396140" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#36395916">parent</a><span>|</span><a href="#36396138">prev</a><span>|</span><a href="#36396274">next</a><span>|</span><label class="collapse" for="c-36396140">[-]</label><label class="expand" for="c-36396140">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been pondering &#x2F; ruminating with this too; I&#x27;ve been somewhat surprised that few operating systems have played with reserving per-thread address space as thread-local storage, or requiring something akin to a &#x27;far&#x27; pointer to access commonly-addressed shared memory.</div><br/></div></div><div id="36396274" class="c"><input type="checkbox" id="c-36396274" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#36395916">parent</a><span>|</span><a href="#36396140">prev</a><span>|</span><a href="#36393516">next</a><span>|</span><label class="collapse" for="c-36396274">[-]</label><label class="expand" for="c-36396274">[1 more]</label></div><br/><div class="children"><div class="content">You cannot COW and share the TLB state. The caches aren&#x27;t flushed in process changes either: it&#x27;s that the data is different so evictions happen.</div><br/></div></div></div></div><div id="36393516" class="c"><input type="checkbox" id="c-36393516" checked=""/><div class="controls bullet"><span class="by">tragomaskhalos</span><span>|</span><a href="#36395916">prev</a><span>|</span><a href="#36394484">next</a><span>|</span><label class="collapse" for="c-36393516">[-]</label><label class="expand" for="c-36393516">[3 more]</label></div><br/><div class="children"><div class="content">Worked on a codebase which was separate processes, each of which has a shedload of global variables. It was a nightmare working out what was going on, not helped by the fact that there was no naming convention for the globals, plus they were not declared in a single place. I believe their use was a performance move, ie having the linker pin a var to a specific memory location rather than copying it to the stack as a variable and referencing it by offset the whole time. Premature optimisation? Optimisation at all? Who knows, but there&#x27;s a good reason coding standards typically militate against globals.</div><br/><div id="36398230" class="c"><input type="checkbox" id="c-36398230" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#36393516">parent</a><span>|</span><a href="#36394476">next</a><span>|</span><label class="collapse" for="c-36398230">[-]</label><label class="expand" for="c-36398230">[1 more]</label></div><br/><div class="children"><div class="content">Per discussion on this very page, in the headlined article, and in the mailing list discussion it references, PostgreSQL is not in that category.  It has lots of <i>static storage duration</i> variables, which <i>do not</i> necessarily have external linkage.<p>Robert Haas pointed out in one message that an implementation pattern was to use things like file-scope static storage duration variables to provide session-local state for individual components.  This is why they&#x27;ve been arguing against a single giant structure declared in &quot;session.h&quot; as an approach, as it requires every future addition to session state to touch the central core of the entire program.<p>They want to keep the advantage of the fact that these variables are in fact <i>not global</i>.  They are local; and the problem is rather that they have static storage duration and are not per-thread, and thus are not per-session in a thread-per-session model.</div><br/></div></div><div id="36394476" class="c"><input type="checkbox" id="c-36394476" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#36393516">parent</a><span>|</span><a href="#36398230">prev</a><span>|</span><a href="#36394484">next</a><span>|</span><label class="collapse" for="c-36394476">[-]</label><label class="expand" for="c-36394476">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s something to be said for globals whose access is well-managed, though.<p>IMO: if the variable is _truly_ global, i.e. code all over the codebase cares about it, then it should just be global instead of pretending like it&#x27;s not with some fancy architecture.<p>The tricky part is reacting to changes to a global variable. Writing a bunch of &quot;on update&quot; logic leads to madness. The ideal solution is for there to be some sort of one-directional flow for updates, like when a React component tree is re-rendered... but that&#x27;s very hard to build in an application that doesn&#x27;t start out using a library like React in the first place.</div><br/></div></div></div></div><div id="36394484" class="c"><input type="checkbox" id="c-36394484" checked=""/><div class="controls bullet"><span class="by">chucky_z</span><span>|</span><a href="#36393516">prev</a><span>|</span><a href="#36399669">next</a><span>|</span><label class="collapse" for="c-36394484">[-]</label><label class="expand" for="c-36394484">[1 more]</label></div><br/><div class="children"><div class="content">I wish they would do some kind of easy shared storage instead, or in addition too.  This sounds like an odd solution, however I’ve scaled pgsql since 9 on very, very large machines and doing 1 pgsql cluster per physical socket ended up doing near-linear scaling even on 100+ total core machines with TB+ of memory.<p>The challenge with this setup is that you need to do 1 writer and multiple reader clusters so you end up doing localhost replication which is super weird.  If that requirement was somehow removed that’d be awesome for scaling really huge clusters.</div><br/></div></div><div id="36399669" class="c"><input type="checkbox" id="c-36399669" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36394484">prev</a><span>|</span><a href="#36395200">next</a><span>|</span><label class="collapse" for="c-36399669">[-]</label><label class="expand" for="c-36399669">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day, this doesn&#x27;t solve any problems. Small setups use postgres directly just fine, and large setups use pgbouncer, and having process isolation with extensions is a good thing and probably simplifies things a lot.<p>My $0.02</div><br/></div></div><div id="36395200" class="c"><input type="checkbox" id="c-36395200" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#36399669">prev</a><span>|</span><a href="#36393229">next</a><span>|</span><label class="collapse" for="c-36395200">[-]</label><label class="expand" for="c-36395200">[1 more]</label></div><br/><div class="children"><div class="content">So compromise. Take the current process model, add threading and shared memory, with feature flags to limit number of processes and number of threads.<p>Want to run an extension that isn&#x27;t threadsafe? Run with 10 processes, 1 threads. Want to run high-performance? Run with 1 process, 10 threads. Afraid of &quot;stability issues&quot;? Run with 1 process, 1 thread.<p>Will it be hard to do? Sure. Impossible? Not at all. Plan for it, give a very long runway, throw all your new features into the next major version branch, and tell people everything else is off the table for the next few years. If you&#x27;re <i>really sure</i> threading is going to be increasingly necessary, better to start now than to wait until it&#x27;s too late. But this idea of &quot;oh it&#x27;s hard&quot;, &quot;oh it&#x27;s dangerous&quot;, &quot;too complicated&quot;, etc is bullshit. We&#x27;ve built fucking spaceships that visit other planets. We can make a database with threads that doesn&#x27;t break. Otherwise we admit that basic software development using practices from the past 30 years is too much for us to figure out.</div><br/></div></div><div id="36393229" class="c"><input type="checkbox" id="c-36393229" checked=""/><div class="controls bullet"><span class="by">Icathian</span><span>|</span><a href="#36395200">prev</a><span>|</span><a href="#36398708">next</a><span>|</span><label class="collapse" for="c-36393229">[-]</label><label class="expand" for="c-36393229">[1 more]</label></div><br/><div class="children"><div class="content">Some interesting discussion on this here also: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36284487">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36284487</a></div><br/></div></div><div id="36398708" class="c"><input type="checkbox" id="c-36398708" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36393229">prev</a><span>|</span><a href="#36396889">next</a><span>|</span><label class="collapse" for="c-36398708">[-]</label><label class="expand" for="c-36398708">[5 more]</label></div><br/><div class="children"><div class="content">I know I’m probably being naive about this, but is it stupid to ask if there’s a way to make multi process work better on Linux - rather than “fixing” PG?<p>I feel like the thread vs process thing is one of those pendulums&#x2F;fads that comes and goes. I’d hate to see PG go down a rabbit hole only to discover the OS could be modified to make things go better.<p>(I understand not all PG instances run on Linux, just using it as an example)</div><br/><div id="36398831" class="c"><input type="checkbox" id="c-36398831" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#36398708">parent</a><span>|</span><a href="#36398806">next</a><span>|</span><label class="collapse" for="c-36398831">[-]</label><label class="expand" for="c-36398831">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;ll likely be an even bigger task, and harder to get into mainline kernel.<p>Linux multi-process is already pretty efficient compared to Windows. However, multi-process is inherently less efficient than multi-thread due to more safety predicates &#x2F; isolation guaranteed by the kernel, I feel lowering it might lead to more security issues, similar to how Hyper Threading triggered a bunch of issues with Intel Processors.</div><br/><div id="36399248" class="c"><input type="checkbox" id="c-36399248" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36398708">root</a><span>|</span><a href="#36398831">parent</a><span>|</span><a href="#36398806">next</a><span>|</span><label class="collapse" for="c-36399248">[-]</label><label class="expand" for="c-36399248">[2 more]</label></div><br/><div class="children"><div class="content">Right - yeah I was really just wondering if some of the safety predicates could be reduced when there is a relationship between processes, such as the mitigations against cache attacks. I think the cache misses caused by multi-process were one of the reasons given that it&#x27;s slower than threading. But I don&#x27;t understand why this is necessarily the case given that the shared memory and executable text ultimately refer to the same data. But I suppose this would need to work with processor affinity and other elements to prevent the cache being knocked around by non-PG processes, and I guess this is one place where it starts getting complicated.<p>That said, please understand that I&#x27;m just being curious - I really don&#x27;t know what I&#x27;m talking about, I haven&#x27;t built a Linux kernel or dabbled in Unix internals in like 20 years, but thanks for replying :) Postgresql is my favourite open source project and I&#x27;m spooked by the threading naysayers.</div><br/><div id="36399346" class="c"><input type="checkbox" id="c-36399346" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36398708">root</a><span>|</span><a href="#36399248">parent</a><span>|</span><a href="#36398806">next</a><span>|</span><label class="collapse" for="c-36399346">[-]</label><label class="expand" for="c-36399346">[1 more]</label></div><br/><div class="children"><div class="content">The TLB is basically keyed by (address space, virtual address % granularity), or needs to be flushed entirely when switching between different views of the address space (e.g. switching between processes). Unless your address space is exactly the same, you&#x27;re at least going to duplicate TLB contents. Leading to a lower hit rate.<p>This isn&#x27;t really an OS issue, more a hardware one, although potential hardware improvements would likely have to be explicitly utilized by operating systems.<p>Note that the TLB issue is different from the data &#x2F; instruction cache situation.</div><br/></div></div></div></div></div></div><div id="36398806" class="c"><input type="checkbox" id="c-36398806" checked=""/><div class="controls bullet"><span class="by">chmod775</span><span>|</span><a href="#36398708">parent</a><span>|</span><a href="#36398831">prev</a><span>|</span><a href="#36396889">next</a><span>|</span><label class="collapse" for="c-36398806">[-]</label><label class="expand" for="c-36398806">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I feel like the thread vs process thing is one of those pendulums&#x2F;fads that comes and goes.<p>In this context threads can be understood as processes that share the same address space and vice-versa processes as threads with separate address space.<p>One gives you isolation, the other convenience and performance. Either can be desirable.<p>What would you change about this?</div><br/></div></div></div></div><div id="36397534" class="c"><input type="checkbox" id="c-36397534" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#36396889">prev</a><span>|</span><a href="#36395382">next</a><span>|</span><label class="collapse" for="c-36397534">[-]</label><label class="expand" for="c-36397534">[1 more]</label></div><br/><div class="children"><div class="content">I think an interesting point of comparison is the latest incarnation of SQL Server. You can&#x27;t even point at 1 specific machine anymore with their hyperscale architecture.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;azure-sql&#x2F;database&#x2F;hyperscale-architecture?view=azuresql" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;azure-sql&#x2F;database&#x2F;h...</a></div><br/></div></div><div id="36395382" class="c"><input type="checkbox" id="c-36395382" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#36397534">prev</a><span>|</span><a href="#36399302">next</a><span>|</span><label class="collapse" for="c-36395382">[-]</label><label class="expand" for="c-36395382">[2 more]</label></div><br/><div class="children"><div class="content">A big advantage of the process-based model is its resilience against many classes of errors.<p>If a bug in PostgreSQL (or in an extension) causes the server to crash, then only that process will crash. Postmaster will detect the child process termination, and send an error message to the client. The connection will be lost, but other connections will be unaffected.<p>It&#x27;s not foolproof (there are ways to bring the whole server down), but it does protect against many error conditions.<p>It is possible to trap on some exceptions in a threaded environment, but cleaning up after eg. an attempted NULL pointer dereference is going to be very difficult or impossible.</div><br/><div id="36396644" class="c"><input type="checkbox" id="c-36396644" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36395382">parent</a><span>|</span><a href="#36399302">next</a><span>|</span><label class="collapse" for="c-36396644">[-]</label><label class="expand" for="c-36396644">[1 more]</label></div><br/><div class="children"><div class="content">We would still have a separate supervisor process of we moved connections to threads.</div><br/></div></div></div></div><div id="36399302" class="c"><input type="checkbox" id="c-36399302" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#36395382">prev</a><span>|</span><a href="#36394399">next</a><span>|</span><label class="collapse" for="c-36399302">[-]</label><label class="expand" for="c-36399302">[2 more]</label></div><br/><div class="children"><div class="content">Not sure what&#x27;s going on here, but one connection per process seems... ancient.<p>Using threaded model is difficult, how about pre-fork? Some connections per process is a good improvement.</div><br/><div id="36399621" class="c"><input type="checkbox" id="c-36399621" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36399302">parent</a><span>|</span><a href="#36394399">next</a><span>|</span><label class="collapse" for="c-36399621">[-]</label><label class="expand" for="c-36399621">[1 more]</label></div><br/><div class="children"><div class="content">The issue is costlier (runtime, complexity, memory) resource sharing, not the cost of the fork itself. Pre-forking isn&#x27;t going to help with any of that.</div><br/></div></div></div></div><div id="36394399" class="c"><input type="checkbox" id="c-36394399" checked=""/><div class="controls bullet"><span class="by">sargun</span><span>|</span><a href="#36399302">prev</a><span>|</span><a href="#36398696">next</a><span>|</span><label class="collapse" for="c-36394399">[-]</label><label class="expand" for="c-36394399">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if they can take advantage of vfork &#x2F; CLONE_VM, to get the benefits of sharing memory and lower overhead context switches, with the trade of still getting benefits from the scheduler, and sysadmin-friendliness.<p>The other thing that might be interesting is FUTEX_SWAP &#x2F; UMCG. Although it doesn&#x27;t remove the overhead induced by context switches entirely (specifically, you would still deal with TLB misses), you can avoid dealing with things like speculative execution exploit mitigations.</div><br/><div id="36394944" class="c"><input type="checkbox" id="c-36394944" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#36394399">parent</a><span>|</span><a href="#36394718">next</a><span>|</span><label class="collapse" for="c-36394944">[-]</label><label class="expand" for="c-36394944">[1 more]</label></div><br/><div class="children"><div class="content">Per the article, Postgres has many, many global variables, many of which track per-session state; much session state is “freed” via process exit rather than being explicitly cleaned up. Switching to CLONE_VM requires these problems to all be solved.</div><br/></div></div><div id="36394718" class="c"><input type="checkbox" id="c-36394718" checked=""/><div class="controls bullet"><span class="by">why-el</span><span>|</span><a href="#36394399">parent</a><span>|</span><a href="#36394944">prev</a><span>|</span><a href="#36398696">next</a><span>|</span><label class="collapse" for="c-36394718">[-]</label><label class="expand" for="c-36394718">[1 more]</label></div><br/><div class="children"><div class="content">what about support for Windows?</div><br/></div></div></div></div><div id="36398696" class="c"><input type="checkbox" id="c-36398696" checked=""/><div class="controls bullet"><span class="by">MR4D</span><span>|</span><a href="#36394399">prev</a><span>|</span><a href="#36399368">next</a><span>|</span><label class="collapse" for="c-36398696">[-]</label><label class="expand" for="c-36398696">[1 more]</label></div><br/><div class="children"><div class="content">Changing the entire architecture of PG to suit the 0.1% of edge cases seems like a poor trade off.<p>Are there a much larger percentage of users that really need this?</div><br/></div></div><div id="36399368" class="c"><input type="checkbox" id="c-36399368" checked=""/><div class="controls bullet"><span class="by">georgewfraser</span><span>|</span><a href="#36398696">prev</a><span>|</span><a href="#36396405">next</a><span>|</span><label class="collapse" for="c-36399368">[-]</label><label class="expand" for="c-36399368">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if it would be easier to create a C virtual machine that emulates all the OS interaction, then recompile Postgres and the extensions to run on this. Perhaps TruffleC would work?<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;2647508.2647528" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;2647508.2647528</a></div><br/><div id="36399608" class="c"><input type="checkbox" id="c-36399608" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36399368">parent</a><span>|</span><a href="#36396405">next</a><span>|</span><label class="collapse" for="c-36399608">[-]</label><label class="expand" for="c-36399608">[1 more]</label></div><br/><div class="children"><div class="content">Hard to believe that would provide any benefit without also causing massive slowdowns.</div><br/></div></div></div></div><div id="36396405" class="c"><input type="checkbox" id="c-36396405" checked=""/><div class="controls bullet"><span class="by">papito</span><span>|</span><a href="#36399368">prev</a><span>|</span><a href="#36396259">next</a><span>|</span><label class="collapse" for="c-36396405">[-]</label><label class="expand" for="c-36396405">[1 more]</label></div><br/><div class="children"><div class="content">This has Python 3 vibes.</div><br/></div></div><div id="36396259" class="c"><input type="checkbox" id="c-36396259" checked=""/><div class="controls bullet"><span class="by">waselighis</span><span>|</span><a href="#36396405">prev</a><span>|</span><a href="#36397117">next</a><span>|</span><label class="collapse" for="c-36396259">[-]</label><label class="expand" for="c-36396259">[1 more]</label></div><br/><div class="children"><div class="content">It sounds to me like migrating to a fully multi-threaded architecture may not be worth the effort. Simply reducing the number of processes from thousands to hundreds would be a huge win and likely much more feasible than a complete re-architecture.</div><br/></div></div><div id="36397117" class="c"><input type="checkbox" id="c-36397117" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36396259">prev</a><span>|</span><label class="collapse" for="c-36397117">[-]</label><label class="expand" for="c-36397117">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like the specific concerns here are actually around buffer pool management performance in and around the TLB: <i>&quot;Once you have a significant number of connections we end up spending a *lot* of time in TLB misses, and that&#x27;s inherent to the process model, because you can&#x27;t share the TLB across processes. &quot;</i><p>Many of the comments here seem to be missing this and talking about CPU-boundedness generally and thread-per-request vs process etc models, but this seems orthogonal to that, and is actually quite specific about the VM subsystem and seems like a legitimate bottleneck with the approach Postgres has to take for buffer&#x2F;page mgmt with the process model it has now.<p>I&#x27;m no Postgres hacker (or a Linux kernel hacker), and I only did a 6 month stint doing DB internals, but it <i>feels</i> to me like perhaps the right answer here is that instead of Postgres getting deep down in the weeds refactoring and rewriting to a thread based model -- with all the risks in that that people have pointed out -- some assistance could be reached for by working on specific targeted patches in the Linux kernel?<p>The addition of e.g. userfaultfd shows that there is room for innovation and acceptance of changes in and around kernel re: page management. Some new flags for mmap, shm_open, etc. to handle some specific targeted use cases to help Postgres out?<p>Also wouldn&#x27;t be the first time that people have done custom kernel patches or tuning parameters to crank performance out of a database.</div><br/><div id="36400322" class="c"><input type="checkbox" id="c-36400322" checked=""/><div class="controls bullet"><span class="by">thesnide</span><span>|</span><a href="#36397117">parent</a><span>|</span><label class="collapse" for="c-36400322">[-]</label><label class="expand" for="c-36400322">[2 more]</label></div><br/><div class="children"><div class="content">Exactly my thinking. If the problem is TLB evictions, why not improve these? PG isn&#x27;t the only software that is hit by those.<p>And if you carefully craft your CPU scheduling and address spaces mapping, you can reduce them by a lot.<p>Yet rewrites are always easier and more sexy. At first.</div><br/><div id="36400458" class="c"><input type="checkbox" id="c-36400458" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36397117">root</a><span>|</span><a href="#36400322">parent</a><span>|</span><label class="collapse" for="c-36400458">[-]</label><label class="expand" for="c-36400458">[1 more]</label></div><br/><div class="children"><div class="content">The TLB issue are more a hardware issue than a software&#x2F;OS one. To my knowledge neither x86 nor arm provide a way to <i>partially</i> share TLB contents between processes&#x2F;entities. Tlb entries can be tagged with a process context identifier, but that&#x27;s an all or nothing thing. Either the entire address space is shared, or it&#x27;s not.<p>&gt; Yet rewrites are always easier and more sexy. At first.<p>Moving to threads would not at all be a rewrite.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>