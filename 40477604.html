<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716714051253" as="style"/><link rel="stylesheet" href="styles.css?v=1716714051253"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://orlp.net/blog/taming-float-sums/">Taming floating-point sums</a> <span class="domain">(<a href="https://orlp.net">orlp.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>37 comments</span></div><br/><div><div id="40478363" class="c"><input type="checkbox" id="c-40478363" checked=""/><div class="controls bullet"><span class="by">Infinity315</span><span>|</span><a href="#40478255">next</a><span>|</span><label class="collapse" for="c-40478363">[-]</label><label class="expand" for="c-40478363">[7 more]</label></div><br/><div class="children"><div class="content">A method which this article doesn&#x27;t mention is stochastic rounding or probabilistic rounding.<p>Rather than striving for exact values for every computation, we make it so that the expected value is exact.  For example, suppose our number system was restricted to the integers and we have incoming value 1.1, with stochastic rounding we&#x27;d round down to 1 90% of the time and 2 10% of the time giving an expected value of 1.1!<p>Further reading:<p><a href="https:&#x2F;&#x2F;nhigham.com&#x2F;2020&#x2F;07&#x2F;07&#x2F;what-is-stochastic-rounding&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nhigham.com&#x2F;2020&#x2F;07&#x2F;07&#x2F;what-is-stochastic-rounding&#x2F;</a></div><br/><div id="40478719" class="c"><input type="checkbox" id="c-40478719" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#40478363">parent</a><span>|</span><a href="#40479553">next</a><span>|</span><label class="collapse" for="c-40478719">[-]</label><label class="expand" for="c-40478719">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really related, but that reminds me of how some games handled slow moving objects on the Mattel Intellivision console.<p>Your code that runs every frame to update the graphics logically wants to do something like this:<p><pre><code>  X += Vx
  Y += Vy
</code></pre>
where (X, Y) is the location of the object at the start of the frame, and (Vx, Vy) is x and y velocities of the object in pixels&#x2F;frame.<p>To allow for velocities that aren&#x27;t an integer number of pixels per frame and that are slower than 1 pixel per frame  you&#x27;d want to actually store X in a fixed point format, say (Xi, Xf) where Xi is the integer part of the X position, and Xf is the fractional part times 256, so X = Xi + Xf&#x2F;256. Similarly for Y. The object only actually moves on the screen when Xi or Yi changes.<p>Similarly velocity would also be in that format: Vx = Vxi + Vxf&#x2F;256, and similar for Vy.<p>With that, the position update in your loop would be something like this:<p><pre><code>  Xf += Vxf
  if that wrapped
    Xi += 1
  Xi += Vxi
</code></pre>
and similar for Y.<p>For each object you end up needing 8 bytes (1 byte for each of Xi, Xf, Yi, Yf, Vxi, Vxf, Vyi, Vyf). That doesn&#x27;t sound like much but the Intellivision only had something like 240 bytes in the console available. (If you couldn&#x27;t get your RAM requirements down to that it was possible to have extra RAM in the cartridge but that would raise the cost).<p>So someone figured out that you didn&#x27;t actually need to store Xf and Yf. Just generate then at random as needed! The loop then becomes something like this:<p><pre><code>  rb = random_unsigned_byte()
  if Vxf + rb wraps
    Xi += 1
  Xi += Vxi
</code></pre>
and similar for Y.<p>That turns out to work quite reasonably. Essentially it is interpreting Vxf as meaning that the object has a Vxf&#x2F;256 chance of crossing a pixel boundary on a given frame. Thinking of it that way then suggests getting rid of the addition of the random byte with a wrap check and just doing a compare instead:<p><pre><code>  if Vxf &gt; random_unsigned_byte()
    Xi += 1
  Xi += Vxi
</code></pre>
and similar for Y.<p>Net result: we&#x27;ve cut the RAM for storing position and velocity from 8 bytes per object to 6, at the cost of needing to generate 2 random bytes per object per frame.</div><br/></div></div><div id="40479553" class="c"><input type="checkbox" id="c-40479553" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40478363">parent</a><span>|</span><a href="#40478719">prev</a><span>|</span><a href="#40478375">next</a><span>|</span><label class="collapse" for="c-40479553">[-]</label><label class="expand" for="c-40479553">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this essentially what dithering in ADCs[1][2] is all about?<p>[1]: <a href="https:&#x2F;&#x2F;www.allaboutcircuits.com&#x2F;technical-articles&#x2F;what-is-dithering-using-noise-dithering-for-eliminating-the-quantization-distortion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.allaboutcircuits.com&#x2F;technical-articles&#x2F;what-is-...</a><p>[2]: <a href="https:&#x2F;&#x2F;www.analog.com&#x2F;en&#x2F;resources&#x2F;analog-dialogue&#x2F;articles&#x2F;adc-input-noise.html" rel="nofollow">https:&#x2F;&#x2F;www.analog.com&#x2F;en&#x2F;resources&#x2F;analog-dialogue&#x2F;articles...</a></div><br/></div></div><div id="40478375" class="c"><input type="checkbox" id="c-40478375" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40478363">parent</a><span>|</span><a href="#40479553">prev</a><span>|</span><a href="#40478537">next</a><span>|</span><label class="collapse" for="c-40478375">[-]</label><label class="expand" for="c-40478375">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, I haven&#x27;t seen that before in the context of numerics.<p>It is used all the time however in audio and image processing, where it is called dithering.</div><br/></div></div><div id="40478537" class="c"><input type="checkbox" id="c-40478537" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40478363">parent</a><span>|</span><a href="#40478375">prev</a><span>|</span><a href="#40478255">next</a><span>|</span><label class="collapse" for="c-40478537">[-]</label><label class="expand" for="c-40478537">[3 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t that require a call to generate a random number for every floating point number you encounter? That seems expensive...</div><br/><div id="40478697" class="c"><input type="checkbox" id="c-40478697" checked=""/><div class="controls bullet"><span class="by">KMnO4</span><span>|</span><a href="#40478363">root</a><span>|</span><a href="#40478537">parent</a><span>|</span><a href="#40478255">next</a><span>|</span><label class="collapse" for="c-40478697">[-]</label><label class="expand" for="c-40478697">[2 more]</label></div><br/><div class="children"><div class="content">A lot of hardware has built in RNGs, but even using a software algorithm (eg Xorshift) is extremely inexpensive.<p>Also, sometimes you’re not limited by processing speed, but by the destination data structure (eg quantized to integers).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Xorshift" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Xorshift</a></div><br/><div id="40478826" class="c"><input type="checkbox" id="c-40478826" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40478363">root</a><span>|</span><a href="#40478697">parent</a><span>|</span><a href="#40478255">next</a><span>|</span><label class="collapse" for="c-40478826">[-]</label><label class="expand" for="c-40478826">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware of fast RNGs, but even compared to HW floating point operations, I believe they&#x27;re still more expensive than Khan summation. HW circuits <i>maybe</i> could do well. I see that most of the interest is around LLMs and doing quantized sums (gathering from the fact that Intel has shipped this in their accelerator), but this came up in the WiFi positioning code I was working on 10 years ago (we were using &quot;classical&quot; f64).</div><br/></div></div></div></div></div></div></div></div><div id="40478255" class="c"><input type="checkbox" id="c-40478255" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#40478363">prev</a><span>|</span><a href="#40478519">next</a><span>|</span><label class="collapse" for="c-40478255">[-]</label><label class="expand" for="c-40478255">[2 more]</label></div><br/><div class="children"><div class="content">I recommend the &quot;Handbook of Floating-point Arithmetic&quot; if this piques interest. I think it&#x27;s freely available on HAL.</div><br/><div id="40478373" class="c"><input type="checkbox" id="c-40478373" checked=""/><div class="controls bullet"><span class="by">greenyoda</span><span>|</span><a href="#40478255">parent</a><span>|</span><a href="#40478519">next</a><span>|</span><label class="collapse" for="c-40478373">[-]</label><label class="expand" for="c-40478373">[1 more]</label></div><br/><div class="children"><div class="content">I found the link to it on HAL, but clicking &quot;Consult the full text&quot; only seems download the table of contents and preface: <a href="https:&#x2F;&#x2F;hal.science&#x2F;hal-01766584" rel="nofollow">https:&#x2F;&#x2F;hal.science&#x2F;hal-01766584</a><p>A new copy costs $112 on Amazon: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Handbook-Floating-Point-Arithmetic-Jean-Michel-Muller&#x2F;dp&#x2F;3319765256" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Handbook-Floating-Point-Arithmetic-Je...</a></div><br/></div></div></div></div><div id="40478519" class="c"><input type="checkbox" id="c-40478519" checked=""/><div class="controls bullet"><span class="by">ashpil</span><span>|</span><a href="#40478255">prev</a><span>|</span><a href="#40479046">next</a><span>|</span><label class="collapse" for="c-40478519">[-]</label><label class="expand" for="c-40478519">[6 more]</label></div><br/><div class="children"><div class="content">Another alternative that the author omitted is just casting everything to doubles and summing naively (or vectorized) in double precision, then casting the final result back to a float. Would be curious to see how this compares to the other methods and whether it’s on the Pareto frontier.</div><br/><div id="40478583" class="c"><input type="checkbox" id="c-40478583" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40478519">parent</a><span>|</span><a href="#40479046">next</a><span>|</span><label class="collapse" for="c-40478583">[-]</label><label class="expand" for="c-40478583">[5 more]</label></div><br/><div class="children"><div class="content">I omitted this because you only have this option for f32, not for f64. I only really chose f32 as the focus point of my article because it makes the numbers a bit more readable.<p>That said, I should have included it, because it is on the Pareto frontier. On my machine it is ~28.9 GB&#x2F;s, with 0 error (note that this doesn&#x27;t mean it <i>always</i> produces a correctly-rounded sum, just in this benchmark test input).<p>I&#x27;ll add it to the article tomorrow or the day after.</div><br/><div id="40480167" class="c"><input type="checkbox" id="c-40480167" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40478519">root</a><span>|</span><a href="#40478583">parent</a><span>|</span><a href="#40478755">next</a><span>|</span><label class="collapse" for="c-40480167">[-]</label><label class="expand" for="c-40480167">[1 more]</label></div><br/><div class="children"><div class="content">On x86 you have the option of using 80 bit long doubles for the accumulator. Performance is till quite decent. Not sure if rust supports them though.</div><br/></div></div><div id="40478755" class="c"><input type="checkbox" id="c-40478755" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#40478519">root</a><span>|</span><a href="#40478583">parent</a><span>|</span><a href="#40480167">prev</a><span>|</span><a href="#40479046">next</a><span>|</span><label class="collapse" for="c-40478755">[-]</label><label class="expand" for="c-40478755">[3 more]</label></div><br/><div class="children"><div class="content">Does rust have float128 support? This is probably memory bound anyway, so software (rather than hardware) support might be fine(?).</div><br/><div id="40478850" class="c"><input type="checkbox" id="c-40478850" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40478519">root</a><span>|</span><a href="#40478755">parent</a><span>|</span><a href="#40479046">next</a><span>|</span><label class="collapse" for="c-40478850">[-]</label><label class="expand" for="c-40478850">[2 more]</label></div><br/><div class="children"><div class="content">No, it doesn&#x27;t. Regardless, without hardware support, adding together intermediate f128s would basically be the same as Kahan summation, except performing even more work to convert the representations around.</div><br/><div id="40480102" class="c"><input type="checkbox" id="c-40480102" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#40478519">root</a><span>|</span><a href="#40478850">parent</a><span>|</span><a href="#40479046">next</a><span>|</span><label class="collapse" for="c-40480102">[-]</label><label class="expand" for="c-40480102">[1 more]</label></div><br/><div class="children"><div class="content">There is some support behind feature flag: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;primitive.f128.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;primitive.f128.html</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40479046" class="c"><input type="checkbox" id="c-40479046" checked=""/><div class="controls bullet"><span class="by">kardos</span><span>|</span><a href="#40478519">prev</a><span>|</span><a href="#40480239">next</a><span>|</span><label class="collapse" for="c-40479046">[-]</label><label class="expand" for="c-40479046">[4 more]</label></div><br/><div class="children"><div class="content">How does it compare to converting each number to a large fixed-point integer (implemented as N 64-bit integers), summing them with exact integer math (order-invariant), and converting back to floating point at the end?<p>The sum part can be done with AVX-512 [1] if N=8, and N=8 is probably enough for a lot of real world summations. The conversion back to floating point at the end is only done once so not very costly.<p>The conversion to fixed point is probably the worst part. Is there a faster way to do it than a loop that extracts one 64-bit integer per iteration? If not we could convert several input numbers at a time with SIMD. But it would be nifty to be able to convert one double to N integers with SIMD instead of a loop.<p>[1] <a href="http:&#x2F;&#x2F;www.numberworld.org&#x2F;y-cruncher&#x2F;internals&#x2F;addition.html#ks_add" rel="nofollow">http:&#x2F;&#x2F;www.numberworld.org&#x2F;y-cruncher&#x2F;internals&#x2F;addition.htm...</a></div><br/><div id="40479414" class="c"><input type="checkbox" id="c-40479414" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40479046">parent</a><span>|</span><a href="#40480091">next</a><span>|</span><label class="collapse" for="c-40479414">[-]</label><label class="expand" for="c-40479414">[1 more]</label></div><br/><div class="children"><div class="content">see xsum <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;radfordneal&#x2F;xsum" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;radfordneal&#x2F;xsum</a></div><br/></div></div><div id="40480091" class="c"><input type="checkbox" id="c-40480091" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#40479046">parent</a><span>|</span><a href="#40479414">prev</a><span>|</span><a href="#40479398">next</a><span>|</span><label class="collapse" for="c-40480091">[-]</label><label class="expand" for="c-40480091">[1 more]</label></div><br/><div class="children"><div class="content">N=5 should cover easily single precision float range. Doubles are more tricky, you&#x27;d need N=33</div><br/></div></div></div></div><div id="40480239" class="c"><input type="checkbox" id="c-40480239" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40479046">prev</a><span>|</span><a href="#40479063">next</a><span>|</span><label class="collapse" for="c-40480239">[-]</label><label class="expand" for="c-40480239">[1 more]</label></div><br/><div class="children"><div class="content">Use doubles, use Kahan summation, use 2Sum algo, use larger precision floating point library?</div><br/></div></div><div id="40479063" class="c"><input type="checkbox" id="c-40479063" checked=""/><div class="controls bullet"><span class="by">floxy</span><span>|</span><a href="#40480239">prev</a><span>|</span><a href="#40479095">next</a><span>|</span><label class="collapse" for="c-40479063">[-]</label><label class="expand" for="c-40479063">[3 more]</label></div><br/><div class="children"><div class="content">Seems like there is a rust priority queue (<a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;binary_heap&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;binary_heap&#x2F;index....</a>).  Would be interesting to see a version where you pop off the two smallest values, and push the sum back, until there is only one element left.</div><br/><div id="40479181" class="c"><input type="checkbox" id="c-40479181" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#40479063">parent</a><span>|</span><a href="#40479095">next</a><span>|</span><label class="collapse" for="c-40479181">[-]</label><label class="expand" for="c-40479181">[2 more]</label></div><br/><div class="children"><div class="content">That works just great if your numbers are positive, but if they are both positive and negative, and in almost but not quite equal pairings it will fail to give the best answer even if you prioritise by magnitude.</div><br/></div></div></div></div><div id="40479095" class="c"><input type="checkbox" id="c-40479095" checked=""/><div class="controls bullet"><span class="by">kardos</span><span>|</span><a href="#40479063">prev</a><span>|</span><a href="#40478517">next</a><span>|</span><label class="collapse" for="c-40479095">[-]</label><label class="expand" for="c-40479095">[4 more]</label></div><br/><div class="children"><div class="content">Why is pairwise summation 1&#x2F;5th as fast as naive? I would expect these to be essentially the same speed, there is only one more addition and a logic operation which is surely negligible ..</div><br/><div id="40479128" class="c"><input type="checkbox" id="c-40479128" checked=""/><div class="controls bullet"><span class="by">pixelesque</span><span>|</span><a href="#40479095">parent</a><span>|</span><a href="#40478517">next</a><span>|</span><label class="collapse" for="c-40479128">[-]</label><label class="expand" for="c-40479128">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a lot more asm instructions than the tight loop of the naive one, as it&#x27;s got to track more state (working out the middle of the slice, etc)...<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;917o7oT8r" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;917o7oT8r</a></div><br/><div id="40479179" class="c"><input type="checkbox" id="c-40479179" checked=""/><div class="controls bullet"><span class="by">kardos</span><span>|</span><a href="#40479095">root</a><span>|</span><a href="#40479128">parent</a><span>|</span><a href="#40478517">next</a><span>|</span><label class="collapse" for="c-40479179">[-]</label><label class="expand" for="c-40479179">[2 more]</label></div><br/><div class="children"><div class="content">Aha. So it could be optimized into two tight loops. The linked wikipedia on pairwise says the numpy implementation is same speed as naive</div><br/><div id="40480596" class="c"><input type="checkbox" id="c-40480596" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40479095">root</a><span>|</span><a href="#40479179">parent</a><span>|</span><a href="#40478517">next</a><span>|</span><label class="collapse" for="c-40480596">[-]</label><label class="expand" for="c-40480596">[1 more]</label></div><br/><div class="children"><div class="content">Numpy also uses blocked pairwise summation, with a block size of 128: <a href="https:&#x2F;&#x2F;github.com&#x2F;numpy&#x2F;numpy&#x2F;blob&#x2F;a6e9dc7152098182b45ecd6effa15223890d663e&#x2F;numpy&#x2F;_core&#x2F;src&#x2F;umath&#x2F;loops_utils.h.src#L55">https:&#x2F;&#x2F;github.com&#x2F;numpy&#x2F;numpy&#x2F;blob&#x2F;a6e9dc7152098182b45ecd6e...</a> .</div><br/></div></div></div></div></div></div></div></div><div id="40478517" class="c"><input type="checkbox" id="c-40478517" checked=""/><div class="controls bullet"><span class="by">screcth</span><span>|</span><a href="#40479095">prev</a><span>|</span><a href="#40480385">next</a><span>|</span><label class="collapse" for="c-40478517">[-]</label><label class="expand" for="c-40478517">[2 more]</label></div><br/><div class="children"><div class="content">You could also use SIMD to compute N independent Kahan sums in parallel and reduce them at the end.</div><br/><div id="40478587" class="c"><input type="checkbox" id="c-40478587" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40478517">parent</a><span>|</span><a href="#40480385">next</a><span>|</span><label class="collapse" for="c-40478587">[-]</label><label class="expand" for="c-40478587">[1 more]</label></div><br/><div class="children"><div class="content">I tried this, it was the same speed as orlp_sum with worse accuracy.</div><br/></div></div></div></div><div id="40480385" class="c"><input type="checkbox" id="c-40480385" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40478517">prev</a><span>|</span><a href="#40478369">next</a><span>|</span><label class="collapse" for="c-40480385">[-]</label><label class="expand" for="c-40480385">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t sorting (smallest first) then summing another method, distinct from the ones given?</div><br/></div></div><div id="40478369" class="c"><input type="checkbox" id="c-40478369" checked=""/><div class="controls bullet"><span class="by">caturopath</span><span>|</span><a href="#40480385">prev</a><span>|</span><label class="collapse" for="c-40478369">[-]</label><label class="expand" for="c-40478369">[6 more]</label></div><br/><div class="children"><div class="content">The motivating example is a mess. 15_000_000 would have been a less distracting example, as this one has more-visible problems unrelated to the problem they&#x27;re trying to solve. (Further, with default options, the opening example won&#x27;t have the result shown: it will crash your program.)</div><br/><div id="40478398" class="c"><input type="checkbox" id="c-40478398" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40478369">parent</a><span>|</span><label class="collapse" for="c-40478398">[-]</label><label class="expand" for="c-40478398">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t follow. Why is 15_000_000 less distracting? What problems unrelated to what we&#x27;re trying to solve? And what &#x27;default options&#x27; are you referring to?</div><br/><div id="40478596" class="c"><input type="checkbox" id="c-40478596" checked=""/><div class="controls bullet"><span class="by">exmadscientist</span><span>|</span><a href="#40478369">root</a><span>|</span><a href="#40478398">parent</a><span>|</span><a href="#40479251">next</a><span>|</span><label class="collapse" for="c-40478596">[-]</label><label class="expand" for="c-40478596">[3 more]</label></div><br/><div class="children"><div class="content">The motivating examples read like nonsense to me. (I don&#x27;t really speak Rust, but I think I&#x27;m reading them correctly? I don&#x27;t know.) They seem to be saying that 1 + 1,000,000 = 1,000,000; or 1 + 100,000,000 is 16,777,216? With no remark? That&#x27;s not right even for 32-bit floats.</div><br/><div id="40478609" class="c"><input type="checkbox" id="c-40478609" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40478369">root</a><span>|</span><a href="#40478596">parent</a><span>|</span><a href="#40479251">next</a><span>|</span><label class="collapse" for="c-40478609">[-]</label><label class="expand" for="c-40478609">[2 more]</label></div><br/><div class="children"><div class="content">vec![1.0; 1_000_000_000] is Rust notation for an array that contains 1.0 one billion times. I can understand it&#x27;s a bit confusing&#x2F;frustrating if you&#x27;re unfamiliar with Rust syntax, sorry.</div><br/><div id="40478631" class="c"><input type="checkbox" id="c-40478631" checked=""/><div class="controls bullet"><span class="by">exmadscientist</span><span>|</span><a href="#40478369">root</a><span>|</span><a href="#40478609">parent</a><span>|</span><a href="#40479251">next</a><span>|</span><label class="collapse" for="c-40478631">[-]</label><label class="expand" for="c-40478631">[1 more]</label></div><br/><div class="children"><div class="content">That makes things make a lot more sense, thanks!<p>Kind of unfortunate that that syntax is so trivial to misread, but it is what it is.</div><br/></div></div></div></div></div></div><div id="40479251" class="c"><input type="checkbox" id="c-40479251" checked=""/><div class="controls bullet"><span class="by">caturopath</span><span>|</span><a href="#40478369">root</a><span>|</span><a href="#40478398">parent</a><span>|</span><a href="#40478596">prev</a><span>|</span><label class="collapse" for="c-40479251">[-]</label><label class="expand" for="c-40479251">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I misread the ; as a ,.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>