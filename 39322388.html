<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707555659427" as="style"/><link rel="stylesheet" href="styles.css?v=1707555659427"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://raelize.com/blog/espressif-systems-esp32-breaking-hw-aes-with-power-analysis/">Espressif ESP32: Breaking HW AES with Power Analysis (2023)</a> <span class="domain">(<a href="https://raelize.com">raelize.com</a>)</span></div><div class="subtext"><span>transpute</span> | <span>14 comments</span></div><br/><div><div id="39324345" class="c"><input type="checkbox" id="c-39324345" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39324020">next</a><span>|</span><label class="collapse" for="c-39324345">[-]</label><label class="expand" for="c-39324345">[5 more]</label></div><br/><div class="children"><div class="content">To what degree does the unknown key extraction rely on the knowledge of exactly when the AES engine is engaged? They use a trigger (on pin 26 of the ESP32) to tell their acquisition hardware when the AES engine is running to zoom in on the sample that carries the most information about the key bits.<p>In the &#x27;unknown key&#x27; example it seems as though that trick is still used as well, but the text isn&#x27;t very clear around that part - at least, not to me, but in the code it looks clearly as though that pin is still cycled around the AES encryption call. In a real world attack you wouldn&#x27;t have that information, you&#x27;d have to figure out some way of determining when the AES engine is operational first. And then this attack would suddenly become a lot harder.</div><br/><div id="39324404" class="c"><input type="checkbox" id="c-39324404" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#39324345">parent</a><span>|</span><a href="#39324020">next</a><span>|</span><label class="collapse" for="c-39324404">[-]</label><label class="expand" for="c-39324404">[4 more]</label></div><br/><div class="children"><div class="content">Spotting the em fingerprint I guess. Why would it be hard?</div><br/><div id="39324457" class="c"><input type="checkbox" id="c-39324457" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39324345">root</a><span>|</span><a href="#39324404">parent</a><span>|</span><a href="#39324020">next</a><span>|</span><label class="collapse" for="c-39324457">[-]</label><label class="expand" for="c-39324457">[3 more]</label></div><br/><div class="children"><div class="content">It would be hard(er) because that&#x27;s not what is demonstrated here, if it would be easy you wouldn&#x27;t need all that scaffolding to focus on &#x27;sample 410 of a block of samples that occurs exactly after a self generated trigger point&#x27;. That reduces the search space considerably, in the real world you don&#x27;t have that luxury. Intercepting the powerline is easy, spotting the EM signature of the AES engine in a bunch of software is arguably a harder problem than the one that they&#x27;ve solved here, my guess is that if it was that easy they would have shown just that and then that pin 26 magic wouldn&#x27;t be there.<p>In essence, as far as I can follow the article what they&#x27;ve done is to first identify a sample in a block of samples taken after their own trigger goes off that has a high likelihood of leaking bits from the key by using a known key and running analysis to verify that that sample is the one to focus on. They then proceed to monitor <i>just that one sample</i> to retrieve an unknown key (this had a very high likelihood of working).<p>But that&#x27;s - to me - the same as knowing exactly where in the haystack the needle is buried and then to proceed to prove this by uncovering it. Whether the needle was known or unknown doesn&#x27;t matter any more at that point it&#x27;s simply a way of proving that the extraction itself can work. But the hard part is to find an unknown needle <i>in an unknown location</i> and identifying the location without knowing the key would be a lot harder. The article reads as if you can extract any key from any ESP32 in a couple of seconds but I don&#x27;t think it is quite that simple. Keep in mind that normally the flash of the ESP32 would be encrypted so you wouldn&#x27;t be able to conveniently patch in a helpful trigger event around the encryption engine.</div><br/><div id="39324672" class="c"><input type="checkbox" id="c-39324672" checked=""/><div class="controls bullet"><span class="by">AnarchismIsCool</span><span>|</span><a href="#39324345">root</a><span>|</span><a href="#39324457">parent</a><span>|</span><a href="#39324501">next</a><span>|</span><label class="collapse" for="c-39324672">[-]</label><label class="expand" for="c-39324672">[1 more]</label></div><br/><div class="children"><div class="content">Even if it&#x27;s finding a needle in a haystack, it&#x27;s still a way smaller haystack that cracking the key.  Let&#x27;s say you can force a decryption operation somewhere in one billion samples you only need to try decryption with, worst case, just under a billion keys as you shift your way through the sample stream until you get something with low entropy.  That&#x27;s literally nothing compared to the time complexity of AES.</div><br/></div></div><div id="39324501" class="c"><input type="checkbox" id="c-39324501" checked=""/><div class="controls bullet"><span class="by">glass9180</span><span>|</span><a href="#39324345">root</a><span>|</span><a href="#39324457">parent</a><span>|</span><a href="#39324672">prev</a><span>|</span><a href="#39324020">next</a><span>|</span><label class="collapse" for="c-39324501">[-]</label><label class="expand" for="c-39324501">[1 more]</label></div><br/><div class="children"><div class="content">When attacking an encrypted flash, the idea is to trigger the sampling based on the activity of the external SPI flash signals.<p>This is detailed in the paper that inspired this article, or in in this more recent blog post: <a href="https:&#x2F;&#x2F;courk.cc&#x2F;breaking-flash-encryption-of-espressif-parts" rel="nofollow">https:&#x2F;&#x2F;courk.cc&#x2F;breaking-flash-encryption-of-espressif-part...</a></div><br/></div></div></div></div></div></div></div></div><div id="39324020" class="c"><input type="checkbox" id="c-39324020" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39324345">prev</a><span>|</span><a href="#39323879">next</a><span>|</span><label class="collapse" for="c-39324020">[-]</label><label class="expand" for="c-39324020">[3 more]</label></div><br/><div class="children"><div class="content">I found this interesting but not actually very informative and walked away really learning nothing from having read the article submitted itself. It’s all “we used this tool” and “we followed this guide” with no explanation of theory or process. (The links provided, I’m sure, are more helpful.)<p>There wasn’t even a discussion on why the particular AES configuration deployed was used or how it affects the process.</div><br/><div id="39324427" class="c"><input type="checkbox" id="c-39324427" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39324020">parent</a><span>|</span><a href="#39324102">next</a><span>|</span><label class="collapse" for="c-39324427">[-]</label><label class="expand" for="c-39324427">[1 more]</label></div><br/><div class="children"><div class="content">The chip should not be leaking this much information but the scaffolding around the attack is such that I doubt whether this could be pulled off so easily on a random ESP32 with its flash encryption enabled.</div><br/></div></div><div id="39324102" class="c"><input type="checkbox" id="c-39324102" checked=""/><div class="controls bullet"><span class="by">graphe</span><span>|</span><a href="#39324020">parent</a><span>|</span><a href="#39324427">prev</a><span>|</span><a href="#39323879">next</a><span>|</span><label class="collapse" for="c-39324102">[-]</label><label class="expand" for="c-39324102">[1 more]</label></div><br/><div class="children"><div class="content">You really learned nothing?<p>&gt;Therefore, we decided, in similar fashion as Ledger’s scaffold, to make our own custom board where all the relevant signals are routed to dedicated pins.<p>Explaination or theory: someone else did it the same way.<p>&gt;Throughout our research we used two acquisition techniques that are supported by our oscilloscope: normal block mode and rapid block mode. We used Picoscope’s Python bindings to communicate with the oscilloscope. We used their ps3000aRapidBlockExample.py as a reference to integrate rapid block mode into Riscure’s FiPy.<p>Sounds like they used what worked on their hardware.</div><br/></div></div></div></div><div id="39323879" class="c"><input type="checkbox" id="c-39323879" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#39324020">prev</a><span>|</span><a href="#39323606">next</a><span>|</span><label class="collapse" for="c-39323879">[-]</label><label class="expand" for="c-39323879">[1 more]</label></div><br/><div class="children"><div class="content">Very nice analysis. I found the setup to be pretty neat, and of course if you break a key that is distributed with all the chips ...<p>It is an interesting challenge to secure chips, and something I don&#x27;t think anyone has a really excellent response to. Always interested in papers along this area.</div><br/></div></div><div id="39323606" class="c"><input type="checkbox" id="c-39323606" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#39323879">prev</a><span>|</span><a href="#39323815">next</a><span>|</span><label class="collapse" for="c-39323606">[-]</label><label class="expand" for="c-39323606">[2 more]</label></div><br/><div class="children"><div class="content">The article just mentions firmware encryption, it looks like secure boot is compromised as well?<p>Both features depend on HW AES keys.</div><br/><div id="39323805" class="c"><input type="checkbox" id="c-39323805" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#39323606">parent</a><span>|</span><a href="#39323815">next</a><span>|</span><label class="collapse" for="c-39323805">[-]</label><label class="expand" for="c-39323805">[1 more]</label></div><br/><div class="children"><div class="content">Secure boot uses asymmetric crypto for authentication.</div><br/></div></div></div></div><div id="39323815" class="c"><input type="checkbox" id="c-39323815" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#39323606">prev</a><span>|</span><label class="collapse" for="c-39323815">[-]</label><label class="expand" for="c-39323815">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think anyone uses ECB mode for anything. At least CTR mode is used when an AEAD is not required. CTR mode would defeat this attack. Still, I really like seeing how this is done.</div><br/><div id="39324038" class="c"><input type="checkbox" id="c-39324038" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39323815">parent</a><span>|</span><label class="collapse" for="c-39324038">[-]</label><label class="expand" for="c-39324038">[1 more]</label></div><br/><div class="children"><div class="content">CTR is just as vulnerable to side channels as ECB, although it might be mildly less convenient to collect the traces.</div><br/></div></div></div></div></div></div></div></div></div></body></html>