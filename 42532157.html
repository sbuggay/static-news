<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735462849312" as="style"/><link rel="stylesheet" href="styles.css?v=1735462849312"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yosefk.com/blog/my-history-with-forth-stack-machines.html">My history with Forth and stack machines (2010)</a>Â <span class="domain">(<a href="https://yosefk.com">yosefk.com</a>)</span></div><div class="subtext"><span>homebrewer</span> | <span>25 comments</span></div><br/><div><div id="42533324" class="c"><input type="checkbox" id="c-42533324" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#42535904">next</a><span>|</span><label class="collapse" for="c-42533324">[-]</label><label class="expand" for="c-42533324">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll agree with a lot of his critiques, but one of his small ones that surprisingly echoed a lot of frustration was the dictum to prefer small definitions.<p>&gt; Quoting Chuck Moore:<p>&gt; Forth is highly factored code. I don&#x27;t know anything else to say except that Forth is definitions. If you have a lot of small definitions you are writing Forth. In order to write a lot of small definitions you have to have a stack.<p>It seemed like apologetics and a making a virtue out of necessity, given the fact that I don&#x27;t have the capability to do stack acrobatics in my head live. The only way to be able to read a function in my head, without taking a pencil to paper _was_ small functions. But I found that clashed with the ways some algorithms and procedures naturally expressed themselves in longer multi-step style, and actually ending up being more verbose and tangled with multiple top-level definitions.<p>It turns out that local variables that compile to C-style indirect (SP + i) accesses are only mildly more expensive than stack acrobatics, but still gave the flexibility of Forth-style metaprogramming. [1]<p>Ultimately, the author&#x27;s points about the &quot;Forth philosophy&quot; but not Forth-the-language itself (and extremely spare code) ring true to me.<p>Given my limitations, life is too short to work to have as minimalist an implementation as you&#x27;d like, and to desire to have a interactive development environment in &lt;128k. For me, it&#x27;s hard enough to implement the &quot;subject&quot; that I&#x27;m programming algorithmically&#x2F;data-driven-ly&#x2F;amortizing-computation-ly efficiently.<p>[1] <a href="https:&#x2F;&#x2F;www.novabbs.com&#x2F;devel&#x2F;article-flat.php?id=26347&amp;group=comp.lang.forth#26347" rel="nofollow">https:&#x2F;&#x2F;www.novabbs.com&#x2F;devel&#x2F;article-flat.php?id=26347&amp;grou...</a></div><br/><div id="42534817" class="c"><input type="checkbox" id="c-42534817" checked=""/><div class="controls bullet"><span class="by">nalsirety</span><span>|</span><a href="#42533324">parent</a><span>|</span><a href="#42535904">next</a><span>|</span><label class="collapse" for="c-42534817">[-]</label><label class="expand" for="c-42534817">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easier to approach Forth as assembly-like than C-like.<p>That is, why are you factoring the code to use the stack when you have globals?<p>(Mumble mumble structured program, recursion, reuse)<p>If you move towards a global-first approach(which is what Chuck Moore seems to have moved towards, from anecdote), what changes is that you can substitute the word defining the variable for another word, later down the line, that adds the context, indirection and error handling you need. The mechanism can be added without changing how the word is being used, and you can still write a divide-and-conquer kind of algorithm in this way, it&#x27;s just more classically imperative in style, with more setting of mutable global temporaries and every byte of bookkeeping directly accounted for.<p>Part of the minimalist freedom in Forth is that it is agnostic to whether you&#x27;re using the stack or the dictionary. If you want the word to be unambiguously about a particular space in memory it makes sense to define it first in terms of &quot;it accesses this static location&quot; instead of &quot;it consumes three things on the stack and shuffles them around and indirects one to a memory location and adds the other two&quot;, because that inclines all the words to be about the stack. Take the primitive approach - the one that maps well to assembly - first and see how far it goes. You stay in control of how you&#x27;re extending the language that way. C preempts that because the compiler hides the stack manipulation, so the semantics of the function will default towards locals, and then further extension is guided around fitting it into that.<p>(And it&#x27;s true that the compiler gets you to an answer faster, and black-boxes the interface, so you can use code without reading code - and that is coming at the expense of precision around details like this. Forth is probably not the right way, if it&#x27;s Conway&#x27;s law that you&#x27;re up against.)</div><br/><div id="42536145" class="c"><input type="checkbox" id="c-42536145" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#42533324">root</a><span>|</span><a href="#42534817">parent</a><span>|</span><a href="#42535904">next</a><span>|</span><label class="collapse" for="c-42536145">[-]</label><label class="expand" for="c-42536145">[1 more]</label></div><br/><div class="children"><div class="content">In most assembly languages, accessing local variables on the stack is easy, plus you have multiple registers for temporary data. Forth feels extremely limiting compared to that.<p>On an architecture without those features, like the 6502, Forth <i>may</i> be a good idea, and possibly faster than C - but only if it&#x27;s compiled to machine code with some peephole optimizations, so that e.g. &quot;123 MY-VAR C!&quot; translates into &quot;LDA #123 ; STA MY-VAR&quot;, instead of a naive implementation where the address and constant would first be pushed onto the stack.<p>And any more complicated optimizations would probably require first &quot;decompiling&quot; the Forth code back into a higher level of abstraction. It&#x27;s practically the same as assembler macros otherwise.<p><i>edit:</i> fixed order of operands. I originally wrote &quot;MY-VAR 123 C!&quot;, but then remembered that the address to store to has to be on top of stack. IMHO, infix notation is less confusing, and writing a recursive-descent parser to handle it isn&#x27;t that hard compared to everything else in implementing a compiler. And of course in an infix language, &quot;123 := MYVAR&quot; would be a syntax error, instead of storing (the low byte of) the address of MYVAR into memory location 123.</div><br/></div></div></div></div></div></div><div id="42535904" class="c"><input type="checkbox" id="c-42535904" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#42533324">prev</a><span>|</span><a href="#42537527">next</a><span>|</span><label class="collapse" for="c-42535904">[-]</label><label class="expand" for="c-42535904">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate Yossi&#x27;s plain honesty in this article, and it&#x27;s a fun and interesting read; I&#x27;ve read it before.<p>I can relate to, but not endorse, designing a CPU and dialect for an interesting language you&#x27;ve never properly used.  This turned out to be very painful, and Yossi argues convincingly that it is essentially not practical to use Forth at all, debating Jeff Fox&#x27;s position.  However, there is some evidence[1] that Forth actually might be practical, and it certainly seemed to have a niche in the 80&#x27;s.<p>Yossi made some errors I&#x27;ve seen among new Forth programmers.  A lot of people, before writing real programs, think Forth is like lisp from another universe.  They visualise Forth primarily as a sort-of functional, concatenative, highly refactor-focused language.  They likewise tend to throw out all the normal Forth defining words and use Forth as &#x27;lisp without parentheses&#x27;.  They try and put all their data on the stack, &#x27;point-free&#x27;, rather than using variables.  And often their projects eventually devolve into C envy, every line with stack comments and equivalent C code to help, as shown in the article.<p>But go look at real, working, classic Forth code, of which there is much, and you&#x27;ll see that there is a prevailing style that&#x27;s easy to read and not actually that &#x27;smart&#x27;, or &#x27;academic&#x27;.  No more than 1-2 stack items need to be mentally &#x27;juggled&#x27; for 99% of code, lots of variables and buffers are used whenever it&#x27;s easier.  Yes the classic variables are &#x27;global&#x27;, but it doesn&#x27;t matter if the relevant code isn&#x27;t recursing or touched in interrupts, and is only used by a cluster of related words.  Newer Forths do have local variables, in spite of Jeff Fox&#x27;s disapproval!<p>The classic code I&#x27;m talking about matches what I think Jeff Fox is trying to coerce you towards.  Ultimately I disagree with Yossi&#x27;s views because I think if he had actually tried to implement what Jeff Fox proposes, and got some practice first on a more realistic project, he would have had a much better shot.  It&#x27;s impressive how well the project turned out in spite of the approach, and how Yossi wrote a backend for his architecture in a week: a testament to both his skills and LLVM&#x27;s design; but it&#x27;s worth reflecting as engineers how arrogant (yet relatable) it is to make a CPU and compiler for a language you&#x27;ve never properly used.<p>[1] <a href="https:&#x2F;&#x2F;www.hardware-x.com&#x2F;article&#x2F;S2468-0672(22)00025-6&#x2F;fulltext" rel="nofollow">https:&#x2F;&#x2F;www.hardware-x.com&#x2F;article&#x2F;S2468-0672(22)00025-6&#x2F;ful...</a></div><br/></div></div><div id="42537527" class="c"><input type="checkbox" id="c-42537527" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42535904">prev</a><span>|</span><a href="#42536849">next</a><span>|</span><label class="collapse" for="c-42537527">[-]</label><label class="expand" for="c-42537527">[1 more]</label></div><br/><div class="children"><div class="content">Stack machines are a place where hardware goes to die.  We have this book at my Uni library<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Stack-Computers-Wave-Philip-Koopman&#x2F;dp&#x2F;B0BW2VKNY3" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Stack-Computers-Wave-Philip-Koopman&#x2F;d...</a><p>but in 1989 these were not a new wave at all,  but another CPU without a future like the Lisp machines.</div><br/></div></div><div id="42536849" class="c"><input type="checkbox" id="c-42536849" checked=""/><div class="controls bullet"><span class="by">OldGuyInTheClub</span><span>|</span><a href="#42537527">prev</a><span>|</span><a href="#42534648">next</a><span>|</span><label class="collapse" for="c-42536849">[-]</label><label class="expand" for="c-42536849">[3 more]</label></div><br/><div class="children"><div class="content">I have read this article many times, usually whenever I look at Forth for whatever reason.  As a non-computer scientist I learn a little about language design every time I look at it.  But,I can never figure out what the author actually thinks about Forth.  It seems like he is interested by it and sometimes amazed by it but has concerns and ultimately decides it is not for him.  I could be way off on multiple axes though.</div><br/><div id="42537341" class="c"><input type="checkbox" id="c-42537341" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42536849">parent</a><span>|</span><a href="#42534648">next</a><span>|</span><label class="collapse" for="c-42537341">[-]</label><label class="expand" for="c-42537341">[2 more]</label></div><br/><div class="children"><div class="content">He thinks he&#x27;s not smart enough for it.<p>He describes the good Forth programmers as people who are so smart they can focus on nothing but the problem. To such people, programming languages, operating systems, libraries, even the chips that run all this stuff, they are all non-problems, to be reduced or eliminated. And to do that, it requires that the mind be able to compensate for all the comfort all of those layers would have afforded.<p>&gt; Why pay this cost? <i>[The cost of adding junk you don&#x27;t actually need]</i><p>&gt; Because I don&#x27;t do algorithms, other people do, so I have to trust them and respect their judgment to a large extent.<p>&gt; Because you need superhuman abilities to work without layers.<p>&gt; The Forth way of focusing on just the problem you need to solve seems to more or less require that the same person or a very tightly united group focus on all three of these things, and pick the right algorithms, the right computer architecture, the right language, the right word size, etc.<p>&gt; I don&#x27;t know how to make this work.<p>&gt; having people being able to do what at least 3 people in their respective areas normally do, and concentrating on those 3 things at the same time<p>&gt; Doing the cross-layer global optimization.<p>A sufficiently smart person is capable of analyzing and optimizing the problem from the requirements all the way to the literal chip running the software. They come up with custom unconventional algorithms and implement weird chips with 18 bit words.<p>These are people who are smart enough to modify standard engineering equations. Those things weren&#x27;t sacred to them, they understood them to the point they felt confident enough to change them in such a way that they could be efficiently implemented in some weirdly minimal custom chips[1]. And this somehow yielded more efficient algorithms which were easy to implement in Forth.<p>I share their enthusiasm for minimalism and eliminating the dependencies and the &quot;junk&quot;. It always ends with me learning everything I can about the junk and doing it myself, maybe even reimagining it, hopefully better and smaller this time. I can only hope to one day be half as smart as some of these folks seem to be, though. Every time I try to get into hardware, I discover my limits.<p>[1]: The Yamaha DX7 is an example. People understood things and reframed the problems until the solution fit the available resources. They needed a sine wave...<p><a href="https:&#x2F;&#x2F;www.righto.com&#x2F;2021&#x2F;12&#x2F;yamaha-dx7-reverse-engineering-part-iii.html" rel="nofollow">https:&#x2F;&#x2F;www.righto.com&#x2F;2021&#x2F;12&#x2F;yamaha-dx7-reverse-engineerin...</a><p>&gt; multiplying the sine wave by the envelope level yields the output<p>&gt; However, fast multiplication required too much hardware in the 1980s, so the DX7 uses a mathematical shortcut: adding logarithms is equivalent to multiplying the values.<p>&gt; The obvious problem is that computing logarithms is harder than multiplying, but the trick is to store the (negated) logarithm of the sine wave in the lookup table (below) instead of the sine wave.<p>&gt; This provides the logarithm for free.<p>&gt; The implementation takes advantage of the symmetry of the sine wave so only a quarter-wave needs to be stored.</div><br/><div id="42537444" class="c"><input type="checkbox" id="c-42537444" checked=""/><div class="controls bullet"><span class="by">OldGuyInTheClub</span><span>|</span><a href="#42536849">root</a><span>|</span><a href="#42537341">parent</a><span>|</span><a href="#42534648">next</a><span>|</span><label class="collapse" for="c-42537444">[-]</label><label class="expand" for="c-42537444">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for clarifying!  In that case, he and I have the same &quot;problem&quot; although at very different levels. I&#x27;ve written in other posts about Forth and Lisp that I would very much like to get over the hump of changing how I think about problems.  Unfortunately, I have never been able to do it.<p>There are times where I see how Moore and McCarthy are using a language to define itself. I can sort-of understand how Moore creates a custom language in Forth to tackle something.  But, damned if I can explain it or apply that to even a toy problem.  I am thankful that there are people out there who can think differently.</div><br/></div></div></div></div></div></div><div id="42534648" class="c"><input type="checkbox" id="c-42534648" checked=""/><div class="controls bullet"><span class="by">vok</span><span>|</span><a href="#42536849">prev</a><span>|</span><a href="#42535329">next</a><span>|</span><label class="collapse" for="c-42534648">[-]</label><label class="expand" for="c-42534648">[1 more]</label></div><br/><div class="children"><div class="content">I think that &quot;Good Forth programmers arrange things so that they flow on the stack&quot; has analogs in other languages.  For example, arranging things in J so that short tacit expressions naturally provide the functions you need.</div><br/></div></div><div id="42535329" class="c"><input type="checkbox" id="c-42535329" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#42534648">prev</a><span>|</span><a href="#42533260">next</a><span>|</span><label class="collapse" for="c-42535329">[-]</label><label class="expand" for="c-42535329">[3 more]</label></div><br/><div class="children"><div class="content">I feel like Forth will always have a place in embedded contexts. And it&#x27;s a good language to start with when learning how to write interpreters&#x2F;compilers.<p>The second you start building higher level apps in Forth, you lose most of its advantages from my experience.<p>While usable as an in-app scripting language, I would pick Lisp any day.</div><br/><div id="42535932" class="c"><input type="checkbox" id="c-42535932" checked=""/><div class="controls bullet"><span class="by">vdupras</span><span>|</span><a href="#42535329">parent</a><span>|</span><a href="#42533260">next</a><span>|</span><label class="collapse" for="c-42535932">[-]</label><label class="expand" for="c-42535932">[2 more]</label></div><br/><div class="children"><div class="content">The opinion that Forth doesn&#x27;t climb the abstraction ladder well is popular, but I&#x27;d be tempted to qualify it as a misconception.<p>My own attempt[1] at a Forth that climbs that ladder is, I think, a good counter example. In my opinion, its HAL compares favorably to, for example, SBCL&#x27;s native code compiler. Its almost-C compiler compares favorably to, I think, Tiny CC.<p>This misconception stems, I think, from the fact that you can very well reap the rewards of Forth in a low level environment without needing to &quot;think in Forth&quot;. For example, by mastering immediate mechanics.<p>Someone who hasn&#x27;t invested the effort to twist their mind to Forth-think will, yes, end up having troubles climbing the abstraction ladder.<p>This is not unlike, I think, &quot;macro heavy&quot; lisp, which many lispers actively avoid. But at the same time, much of lisp&#x27;s power comes from it.<p>[1]: <a href="http:&#x2F;&#x2F;duskos.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;duskos.org&#x2F;</a></div><br/><div id="42537247" class="c"><input type="checkbox" id="c-42537247" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#42535329">root</a><span>|</span><a href="#42535932">parent</a><span>|</span><a href="#42533260">next</a><span>|</span><label class="collapse" for="c-42537247">[-]</label><label class="expand" for="c-42537247">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not so much tools as convenient abstractions I feel are missing.
Nice, but an OS is about as low level as they come.</div><br/></div></div></div></div></div></div><div id="42533260" class="c"><input type="checkbox" id="c-42533260" checked=""/><div class="controls bullet"><span class="by">romforth</span><span>|</span><a href="#42535329">prev</a><span>|</span><a href="#42536874">next</a><span>|</span><label class="collapse" for="c-42533260">[-]</label><label class="expand" for="c-42533260">[6 more]</label></div><br/><div class="children"><div class="content">I have ported Forth to a dozen small microcontrollers and my experience
writing much of the bootstrap code in Forth tells me that you are better off
coding Forth in a &quot;vertical&quot; style (ie one word per line with stack picture 
comments), rather than the terse &quot;horizontal&quot; code of &quot;everything on one line&quot;
that many of the folks using Forth (including @yosefk, the author) seem to prefer.<p>Given how close Forth is to assembly (seen from an implementer&#x27;s point of view)
it makes sense to write Forth in a &quot;vertical&quot; style which reflects the
&quot;vertical&quot; style in which assembly code is written. This has the advantage that
the &quot;stack picture comments&quot; on each line of code can stand in for Hoare triplets
so that the code and its - I&#x27;ll call it - &quot;proof&quot; can be written hand in hand
at the same time.<p>This is how all of the Forth code that I&#x27;ve written in
<a href="https:&#x2F;&#x2F;github.com&#x2F;romforth&#x2F;romforth">https:&#x2F;&#x2F;github.com&#x2F;romforth&#x2F;romforth</a> is structured.<p>It does make the code appear less compact though so you are not going to win
any code golf prizes.</div><br/><div id="42533765" class="c"><input type="checkbox" id="c-42533765" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#42533260">parent</a><span>|</span><a href="#42534969">next</a><span>|</span><label class="collapse" for="c-42533765">[-]</label><label class="expand" for="c-42533765">[4 more]</label></div><br/><div class="children"><div class="content">Is there any editor&#x2F;IDE support for stack state visualisation?<p>A text display with an auto pretty printed view would serve people who like both code styles well.<p>A newline per stack reducing operation with the next line indented by stack depth would make it close to your style and could be quite automatic.</div><br/><div id="42534925" class="c"><input type="checkbox" id="c-42534925" checked=""/><div class="controls bullet"><span class="by">romforth</span><span>|</span><a href="#42533260">root</a><span>|</span><a href="#42533765">parent</a><span>|</span><a href="#42535076">next</a><span>|</span><label class="collapse" for="c-42534925">[-]</label><label class="expand" for="c-42534925">[1 more]</label></div><br/><div class="children"><div class="content">Something like an automated proof assistant to help annotate the stack
while coding would be awesome, but I&#x27;m not aware of any.<p>These might be famous last words, but if switching between compile&#x2F;interpret
modes is ignored, I think it shouldn&#x27;t be too hard to implement it though.</div><br/></div></div><div id="42535076" class="c"><input type="checkbox" id="c-42535076" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42533260">root</a><span>|</span><a href="#42533765">parent</a><span>|</span><a href="#42534925">prev</a><span>|</span><a href="#42534969">next</a><span>|</span><label class="collapse" for="c-42535076">[-]</label><label class="expand" for="c-42535076">[2 more]</label></div><br/><div class="children"><div class="content">Adjacent rather than a Forth, but take a look at Factor.<p><a href="https:&#x2F;&#x2F;factorcode.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;factorcode.org&#x2F;</a></div><br/><div id="42536721" class="c"><input type="checkbox" id="c-42536721" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#42533260">root</a><span>|</span><a href="#42535076">parent</a><span>|</span><a href="#42534969">next</a><span>|</span><label class="collapse" for="c-42536721">[-]</label><label class="expand" for="c-42536721">[1 more]</label></div><br/><div class="children"><div class="content">Also 8th. I find the free version fun to play with as a modern desktop forth with built-in support for things like databases, odbc, json, matrices...etc. The commercial aspect won&#x27;t be most people&#x27;s cup of tea of course, but I still think it&#x27;s neat and 8th is probably the most approachable way to write a desktop app with forth.<p><a href="https:&#x2F;&#x2F;8th-dev.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;8th-dev.com&#x2F;</a><p><a href="https:&#x2F;&#x2F;8th-dev.com&#x2F;manual.html" rel="nofollow">https:&#x2F;&#x2F;8th-dev.com&#x2F;manual.html</a></div><br/></div></div></div></div></div></div><div id="42534969" class="c"><input type="checkbox" id="c-42534969" checked=""/><div class="controls bullet"><span class="by">volemo</span><span>|</span><a href="#42533260">parent</a><span>|</span><a href="#42533765">prev</a><span>|</span><a href="#42536874">next</a><span>|</span><label class="collapse" for="c-42534969">[-]</label><label class="expand" for="c-42534969">[1 more]</label></div><br/><div class="children"><div class="content">We removed explicit arguments from the language so you can write comments with arguments after every function call. :D</div><br/></div></div></div></div><div id="42536874" class="c"><input type="checkbox" id="c-42536874" checked=""/><div class="controls bullet"><span class="by">GlenTheMachine</span><span>|</span><a href="#42533260">prev</a><span>|</span><a href="#42535114">next</a><span>|</span><label class="collapse" for="c-42536874">[-]</label><label class="expand" for="c-42536874">[2 more]</label></div><br/><div class="children"><div class="content">I desperately wish I had been introduced to Forth when I was learning assembly circa 1984 on my Commodore. Would have changed my life.</div><br/><div id="42537780" class="c"><input type="checkbox" id="c-42537780" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#42536874">parent</a><span>|</span><a href="#42535114">next</a><span>|</span><label class="collapse" for="c-42537780">[-]</label><label class="expand" for="c-42537780">[1 more]</label></div><br/><div class="children"><div class="content">I had Forth for my TI&#x2F;99-4A but at age 14 I lacked the background and context to be able to understand it or a mentor to get me started. I took a couple of stabs at it but the book I was using was just over my head, when all I had for comparison was programming I had done in BASIC. No internet in those days of course.</div><br/></div></div></div></div><div id="42535114" class="c"><input type="checkbox" id="c-42535114" checked=""/><div class="controls bullet"><span class="by">abrax3141</span><span>|</span><a href="#42536874">prev</a><span>|</span><a href="#42533103">next</a><span>|</span><label class="collapse" for="c-42535114">[-]</label><label class="expand" for="c-42535114">[1 more]</label></div><br/><div class="children"><div class="content">You want to be truly amazed, check out Newellâs IPL-V, which is a machine language for a stack machine, developed in the 1950s and used to implement the first AIs. It had every idea n Lisp except the parens.</div><br/></div></div><div id="42533103" class="c"><input type="checkbox" id="c-42533103" checked=""/><div class="controls bullet"><span class="by">mud_dauber</span><span>|</span><a href="#42535114">prev</a><span>|</span><a href="#42532954">next</a><span>|</span><label class="collapse" for="c-42533103">[-]</label><label class="expand" for="c-42533103">[1 more]</label></div><br/><div class="children"><div class="content">I got a taste for this years ago at Harris Semi. Grokking their RTX microcontrollers was a ton of fun. (Not so much for customers, who&#x27;d never seen such a thing.)</div><br/></div></div><div id="42532954" class="c"><input type="checkbox" id="c-42532954" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#42533103">prev</a><span>|</span><a href="#42535334">next</a><span>|</span><label class="collapse" for="c-42532954">[-]</label><label class="expand" for="c-42532954">[1 more]</label></div><br/><div class="children"><div class="content">I just posted some historical info about Chuck Moore&#x27;s work for HOMER and Associates on a real time visual mixing console that produced many music videos that ran endlessly on MTV back when they actually played music videos, and special effects for blockbuster films like RoboCop and Total Recall to the discussion about abstractions:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42532404">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42532404</a></div><br/></div></div><div id="42535334" class="c"><input type="checkbox" id="c-42535334" checked=""/><div class="controls bullet"><span class="by">hlehmann</span><span>|</span><a href="#42532954">prev</a><span>|</span><label class="collapse" for="c-42535334">[-]</label><label class="expand" for="c-42535334">[1 more]</label></div><br/><div class="children"><div class="content">I had a job in 1982 or so that involved programming in Forth.  It kinda made sense at the time to my young impressionable self, and one of the old timers thought it was ideal for what we were working on at the time.  It all ran on a single thread; I don&#x27;t even recall it having interrupts.  I can&#x27;t imagine using it for anything practical today.</div><br/></div></div></div></div></div></div></div></body></html>