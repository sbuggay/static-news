<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730278864118" as="style"/><link rel="stylesheet" href="styles.css?v=1730278864118"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.timescale.com/blog/vector-databases-are-the-wrong-abstraction/">Vector databases are the wrong abstraction</a> <span class="domain">(<a href="https://www.timescale.com">www.timescale.com</a>)</span></div><div class="subtext"><span>jascha_eng</span> | <span>57 comments</span></div><br/><div><div id="41991160" class="c"><input type="checkbox" id="c-41991160" checked=""/><div class="controls bullet"><span class="by">whakim</span><span>|</span><a href="#41989496">next</a><span>|</span><label class="collapse" for="c-41991160">[-]</label><label class="expand" for="c-41991160">[3 more]</label></div><br/><div class="children"><div class="content">This is actually really cool, and despite what I&#x27;m sure will come off as (constructive) criticism, I am very impressed!<p>First, I think you oversell the overhead of keeping data in sync and the costs of not doing so in a timely manner. Almost any distributed system that is using multiple databases already needs to have a strategy for dealing with inconsistent data. As far as this problem goes, inconsistent embeddings are a pretty minor issue given that (1) most embedding-based workflows don&#x27;t do a lot of updating&#x2F;deletion; and (2) the sheer volume of embeddings from only a small corpus of data means that in practice you&#x27;re unlikely to notice consistency issues. In most cases you can get away with doing much less than is described in this post. That being said, I want to emphasize that I still think not having to worrying about syncing data is indeed cool.<p>Second, IME the most significant drawback to putting your embeddings in a Postgres database with all your other data is that the workload looks so different. To take one example, HNSW indices using pgvector consume a <i>ton</i> of resources - even a small index of tens of millions of embeddings may be hundreds of gigabytes on disk and requires very aggressive vacuuming to perform optimally. It&#x27;s very easy to run into resource contention issues when you effectively have an index that will consume all the available system resources. The canonical solution is to move your data into another database, but then you&#x27;ve recreated the consistency problem that your solution purports to solve.<p>Third, a question: how does this interact with filtering? Can you take advantage of partial indices on the underlying data? Are some of the limitations in pgvector&#x27;s HNSW implementation (as far as filtering goes) still present?</div><br/><div id="41991216" class="c"><input type="checkbox" id="c-41991216" checked=""/><div class="controls bullet"><span class="by">avthar</span><span>|</span><a href="#41991160">parent</a><span>|</span><a href="#41989496">next</a><span>|</span><label class="collapse" for="c-41991216">[-]</label><label class="expand" for="c-41991216">[2 more]</label></div><br/><div class="children"><div class="content">Post co-author here. Really appreciate the feedback.<p>Your point about HNSW being resource intensive is one we&#x27;ve heard. Our team actually built another extension called pgvectorscale [1] which helps scale vector search on Postgres with a new index type (StreamingDiskANN). It has BQ out the box and can also store vectors on disk vs only in memory.<p>Another practice I&#x27;ve seen work well is for teams use to use a read replica to service application queries and reduce load on the primary database.<p>To answer your third question, if you combine Pgai Vectorizer with pgvectorscale, the limitations around filtered search in pgvector HNSW are actually no longer present. Pgvectorscale implements streaming filtering, ensuring more accurate filtered search with Postgres. See [2] for details.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;pgvectorscale">https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;pgvectorscale</a>
[2]: <a href="https:&#x2F;&#x2F;www.timescale.com&#x2F;blog&#x2F;how-we-made-postgresql-as-fast-as-pinecone-for-vector-data&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.timescale.com&#x2F;blog&#x2F;how-we-made-postgresql-as-fas...</a></div><br/><div id="41991933" class="c"><input type="checkbox" id="c-41991933" checked=""/><div class="controls bullet"><span class="by">whakim</span><span>|</span><a href="#41991160">root</a><span>|</span><a href="#41991216">parent</a><span>|</span><a href="#41989496">next</a><span>|</span><label class="collapse" for="c-41991933">[-]</label><label class="expand" for="c-41991933">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your answer. I hear you on using a read-replica to serve embedding-based queries, but I worry there are lots of cases where that breaks down in practice: presumably you still need to do a bunch of IO on the primary to support insertion, and presumably reconstituting an index (e.g. to test out new hyperparameters) isn&#x27;t cheap; at least you can offload the memory requirements of reading big chunks of your graph into memory onto the follower though.<p>Cool to see the pgvectorscale stuff; it sounds like the approach for filtering is not dissimilar to the direction that the pgvector team are taking with 0.8.0, although the much-denser graph (relative to HNSW) may mean the approach works even better in practice?</div><br/></div></div></div></div></div></div><div id="41989496" class="c"><input type="checkbox" id="c-41989496" checked=""/><div class="controls bullet"><span class="by">morgango</span><span>|</span><a href="#41991160">prev</a><span>|</span><a href="#41992481">next</a><span>|</span><label class="collapse" for="c-41989496">[-]</label><label class="expand" for="c-41989496">[11 more]</label></div><br/><div class="children"><div class="content">Great point!<p>(Disclaimer: I work for Elastic)<p>Elasticsearch has recently added a data type called semantic_text, which automatically chunks text, calculates embeddings, and stores the chunks with sensible defaults.<p>Queries are similarly simplified, where vectors are calculated and compared internally, which makes a lot less I&#x2F;O and a lot simpler client code.<p><a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;search-labs&#x2F;blog&#x2F;semantic-search-simplified-semantic-text" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;search-labs&#x2F;blog&#x2F;semantic-search-simp...</a></div><br/><div id="41990008" class="c"><input type="checkbox" id="c-41990008" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#41989496">parent</a><span>|</span><a href="#41989795">next</a><span>|</span><label class="collapse" for="c-41990008">[-]</label><label class="expand" for="c-41990008">[5 more]</label></div><br/><div class="children"><div class="content">I made something similar, but used duckDB as the vector store (and query engine)! It’s impressively fast<p><a href="https:&#x2F;&#x2F;github.com&#x2F;patricktrainer&#x2F;duckdb-embedding-search">https:&#x2F;&#x2F;github.com&#x2F;patricktrainer&#x2F;duckdb-embedding-search</a></div><br/><div id="41993050" class="c"><input type="checkbox" id="c-41993050" checked=""/><div class="controls bullet"><span class="by">barrenko</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41990008">parent</a><span>|</span><a href="#41991062">next</a><span>|</span><label class="collapse" for="c-41993050">[-]</label><label class="expand" for="c-41993050">[1 more]</label></div><br/><div class="children"><div class="content">Amy specific reason to use dDB?<p>I&#x27;ve got a crapload of json q &amp; a formatted discussions on a topic, and am trying to figure out if I just store it somewhere and query it, or do I also do vector embeddings, kinda lost with all the possible options.</div><br/></div></div><div id="41991062" class="c"><input type="checkbox" id="c-41991062" checked=""/><div class="controls bullet"><span class="by">ekianjo</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41990008">parent</a><span>|</span><a href="#41993050">prev</a><span>|</span><a href="#41989795">next</a><span>|</span><label class="collapse" for="c-41991062">[-]</label><label class="expand" for="c-41991062">[3 more]</label></div><br/><div class="children"><div class="content">There is vector type data available in duckdb now?</div><br/><div id="41991535" class="c"><input type="checkbox" id="c-41991535" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41991062">parent</a><span>|</span><a href="#41991643">next</a><span>|</span><label class="collapse" for="c-41991535">[-]</label><label class="expand" for="c-41991535">[1 more]</label></div><br/><div class="children"><div class="content">They call it a fixed size array type but, yes. It was added earlier this year. Works really great<p><a href="https:&#x2F;&#x2F;duckdb.org&#x2F;2024&#x2F;05&#x2F;03&#x2F;vector-similarity-search-vss.html" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;2024&#x2F;05&#x2F;03&#x2F;vector-similarity-search-vss.h...</a></div><br/></div></div><div id="41991643" class="c"><input type="checkbox" id="c-41991643" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41991062">parent</a><span>|</span><a href="#41991535">prev</a><span>|</span><a href="#41989795">next</a><span>|</span><label class="collapse" for="c-41991643">[-]</label><label class="expand" for="c-41991643">[1 more]</label></div><br/><div class="children"><div class="content">Yep! It was added in v0.10.0 - which was released a month or two after I made this.<p>This is using v0.9.1</div><br/></div></div></div></div></div></div><div id="41989795" class="c"><input type="checkbox" id="c-41989795" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#41989496">parent</a><span>|</span><a href="#41990008">prev</a><span>|</span><a href="#41992481">next</a><span>|</span><label class="collapse" for="c-41989795">[-]</label><label class="expand" for="c-41989795">[5 more]</label></div><br/><div class="children"><div class="content">How does their embedding model compare in terms of retrieval accuracy to, say `text-embedding-3-small` and `text-embedding-3-large`?</div><br/><div id="41990109" class="c"><input type="checkbox" id="c-41990109" checked=""/><div class="controls bullet"><span class="by">splike</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41989795">parent</a><span>|</span><a href="#41990028">next</a><span>|</span><label class="collapse" for="c-41990109">[-]</label><label class="expand" for="c-41990109">[1 more]</label></div><br/><div class="children"><div class="content">You can use openai embeddings in elastic if you don&#x27;t want to use their elser sparse embeddings</div><br/></div></div><div id="41990028" class="c"><input type="checkbox" id="c-41990028" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41989795">parent</a><span>|</span><a href="#41990109">prev</a><span>|</span><a href="#41992481">next</a><span>|</span><label class="collapse" for="c-41990028">[-]</label><label class="expand" for="c-41990028">[3 more]</label></div><br/><div class="children"><div class="content">It’s impossible to answer that question without knowing what content&#x2F;query domain you are embedding.  Checkout MTEB leaderboard, dig into the retrieval benchmark, and look for analogous datasets.</div><br/><div id="41990567" class="c"><input type="checkbox" id="c-41990567" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41990028">parent</a><span>|</span><a href="#41992481">next</a><span>|</span><label class="collapse" for="c-41990567">[-]</label><label class="expand" for="c-41990567">[2 more]</label></div><br/><div class="children"><div class="content">So we&#x27;re talking maximizing embedding model per use case? Medical dats would require differnet model than say sales data? Sounds very fragmented approach.</div><br/><div id="41991080" class="c"><input type="checkbox" id="c-41991080" checked=""/><div class="controls bullet"><span class="by">ekianjo</span><span>|</span><a href="#41989496">root</a><span>|</span><a href="#41990567">parent</a><span>|</span><a href="#41992481">next</a><span>|</span><label class="collapse" for="c-41991080">[-]</label><label class="expand" for="c-41991080">[1 more]</label></div><br/><div class="children"><div class="content">The answer lies with a validation dataset that you create for testing.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41992481" class="c"><input type="checkbox" id="c-41992481" checked=""/><div class="controls bullet"><span class="by">_bramses</span><span>|</span><a href="#41989496">prev</a><span>|</span><a href="#41985494">next</a><span>|</span><label class="collapse" for="c-41992481">[-]</label><label class="expand" for="c-41992481">[1 more]</label></div><br/><div class="children"><div class="content">Clever!<p>A method that has worked well for me: divorced databases.<p>The first database is a plaintext database that stores rows: id, data, and metadata and the second database is a vector database that stores id, embedding. whenever a new row is added the first database makes a POST request to the second database. The second database embeds the data and returns the id of its row. The first database uses that ID to store the plain text.<p>When searching, the second database is optimized for cosine sim with an HNSW index. It returns the IDs to the first database, which fetch the plaintext to return to the user.<p>The advantages of this are that the plaintext data can be A&#x2F;B tested across multiple embedding models without affecting the source, and each database can be provisioned for a specific task. Also lowers hosting costs and security because there only needs to be one central vector database and small provisioned plaintext databases.</div><br/></div></div><div id="41985494" class="c"><input type="checkbox" id="c-41985494" checked=""/><div class="controls bullet"><span class="by">avthar</span><span>|</span><a href="#41992481">prev</a><span>|</span><a href="#41989773">next</a><span>|</span><label class="collapse" for="c-41985494">[-]</label><label class="expand" for="c-41985494">[9 more]</label></div><br/><div class="children"><div class="content">Hey HN! Post co-author here, excited to share our new open-source PostgreSQL tool that re-imagines vector embeddings as database indexes. It&#x27;s not literally an index but it functions like one to update embeddings as source data gets added, deleted or changed.<p>Right now the system only supports OpenAI as an embedding provider, but we plan to extend with local and OSS model support soon.<p>Eager to hear your feedback and reactions. If you&#x27;d like to leave an issue or better yet a PR, you can do so here [1]<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;pgai">https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;pgai</a></div><br/><div id="41989806" class="c"><input type="checkbox" id="c-41989806" checked=""/><div class="controls bullet"><span class="by">hhdhdbdb</span><span>|</span><a href="#41985494">parent</a><span>|</span><a href="#41992058">next</a><span>|</span><label class="collapse" for="c-41989806">[-]</label><label class="expand" for="c-41989806">[3 more]</label></div><br/><div class="children"><div class="content">Pretty smart. Why is the DB api the abstraction layer though? Why not two columns and a microservice. I assume you are making async calls to get the embeddings?<p>I say that because it seems n
unsual. Index would suit sync better. But async things like embeddings, geo for an address, is this email considered a spammer etc. feel like app level stuff.</div><br/><div id="41990209" class="c"><input type="checkbox" id="c-41990209" checked=""/><div class="controls bullet"><span class="by">cevian</span><span>|</span><a href="#41985494">root</a><span>|</span><a href="#41989806">parent</a><span>|</span><a href="#41992058">next</a><span>|</span><label class="collapse" for="c-41990209">[-]</label><label class="expand" for="c-41990209">[2 more]</label></div><br/><div class="children"><div class="content">(post co-author here)<p>The DB is the right layer from a interface point of view -- because that&#x27;s where the data properties should be defined. We also use the DB for bookkeeping what needs to be done because we can leverage transactions and triggers to make sure we never miss any data. From an implementation point of view, the actual embedding does happen outside the database in a python worker or cloud functions.<p>Merging the embeddings and the original data into a single view allows the full feature set of SQL rather than being constrained by a REST API.</div><br/><div id="41991139" class="c"><input type="checkbox" id="c-41991139" checked=""/><div class="controls bullet"><span class="by">hhdhdbdb</span><span>|</span><a href="#41985494">root</a><span>|</span><a href="#41990209">parent</a><span>|</span><a href="#41992058">next</a><span>|</span><label class="collapse" for="c-41991139">[-]</label><label class="expand" for="c-41991139">[1 more]</label></div><br/><div class="children"><div class="content">That is arguable because while it is a calculated field, it is not a pure one (IO is required), and not necessarily idempotent, not atomic and not guaranteed to succeed.<p>It is certainly convenient for the end user, but it hides things. What if the API calls to open AI fail or get rate limited. How is that surfaced. Will I see that in my observability. Will queries just silently miss results.<p>If the DB does the embedding itself synchronously within the write it would make sense. That would be more like elastic search or a typical full text index.</div><br/></div></div></div></div></div></div><div id="41992058" class="c"><input type="checkbox" id="c-41992058" checked=""/><div class="controls bullet"><span class="by">TechDebtDevin</span><span>|</span><a href="#41985494">parent</a><span>|</span><a href="#41989806">prev</a><span>|</span><a href="#41991112">next</a><span>|</span><label class="collapse" for="c-41992058">[-]</label><label class="expand" for="c-41992058">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m doing something similar with go + postgres</div><br/></div></div><div id="41991112" class="c"><input type="checkbox" id="c-41991112" checked=""/><div class="controls bullet"><span class="by">metalwhale</span><span>|</span><a href="#41985494">parent</a><span>|</span><a href="#41992058">prev</a><span>|</span><a href="#41991845">next</a><span>|</span><label class="collapse" for="c-41991112">[-]</label><label class="expand" for="c-41991112">[3 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing this! I have one question: Is there any plan to add support for local LLM &#x2F; embeddings models?</div><br/><div id="41991132" class="c"><input type="checkbox" id="c-41991132" checked=""/><div class="controls bullet"><span class="by">motoxpro</span><span>|</span><a href="#41985494">root</a><span>|</span><a href="#41991112">parent</a><span>|</span><a href="#41991845">next</a><span>|</span><label class="collapse" for="c-41991132">[-]</label><label class="expand" for="c-41991132">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Right now the system only supports OpenAI as an embedding provider, but we plan to extend with local and OSS model support soon.&quot;<p>In the post you responded to</div><br/><div id="41991227" class="c"><input type="checkbox" id="c-41991227" checked=""/><div class="controls bullet"><span class="by">metalwhale</span><span>|</span><a href="#41985494">root</a><span>|</span><a href="#41991132">parent</a><span>|</span><a href="#41991845">next</a><span>|</span><label class="collapse" for="c-41991227">[-]</label><label class="expand" for="c-41991227">[1 more]</label></div><br/><div class="children"><div class="content">Haha I feel so dumb now. Thank you!</div><br/></div></div></div></div></div></div><div id="41991845" class="c"><input type="checkbox" id="c-41991845" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#41985494">parent</a><span>|</span><a href="#41991112">prev</a><span>|</span><a href="#41989773">next</a><span>|</span><label class="collapse" for="c-41991845">[-]</label><label class="expand" for="c-41991845">[1 more]</label></div><br/><div class="children"><div class="content">This is super cool! One suggestion for the blog: I would put &quot;re-imagines vector embeddings as database indexes. It&#x27;s not literally an index but it functions like one to update embeddings as source data gets added, deleted or changed.&quot; as a tl&#x2F;dr at the top.<p>It wasn&#x27;t clear to me why this was significantly different than using pg_vector until I read that. That makes the rest of the post (e.g. why this you need the custom methods in a `SELECT`) make a lot more sense in context</div><br/></div></div></div></div><div id="41989773" class="c"><input type="checkbox" id="c-41989773" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#41985494">prev</a><span>|</span><a href="#41992340">next</a><span>|</span><label class="collapse" for="c-41989773">[-]</label><label class="expand" for="c-41989773">[2 more]</label></div><br/><div class="children"><div class="content">Whats wrong with using FAISS as your single db?<p>Its like sqlite for vector embeddings, and you can store metadata (the <i>primary</i> data, foreign keys, etc) along with the vectors, preserving the relationship.<p>Not sure if the metadata is indexxed but at least iirc it&#x27;s more or less trivial to update the embeddings when your data changes (tho i haven&#x27;t used it in a while so not sure).</div><br/><div id="41989987" class="c"><input type="checkbox" id="c-41989987" checked=""/><div class="controls bullet"><span class="by">avthar</span><span>|</span><a href="#41989773">parent</a><span>|</span><a href="#41992340">next</a><span>|</span><label class="collapse" for="c-41989987">[-]</label><label class="expand" for="c-41989987">[1 more]</label></div><br/><div class="children"><div class="content">Good q. For most standalone vector search use cases, FAISS or a library like it is good.<p>However, FAISS is not a database. It can store metadata alongside vectors, but it doesn&#x27;t have things you&#x27;d want in your app db like ACID compliance, non-vector indexing, and proper backup&#x2F;recovery mechanisms. You&#x27;re basically giving up all the DBMS capabilities.<p>For new RAG and search apps, many teams prefer just using a single app db with vector search capabilities included (Postgres, Mongo, MySQL etc) vs managing an app db and a separate vector db.</div><br/></div></div></div></div><div id="41992340" class="c"><input type="checkbox" id="c-41992340" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#41989773">prev</a><span>|</span><a href="#41990652">next</a><span>|</span><label class="collapse" for="c-41992340">[-]</label><label class="expand" for="c-41992340">[1 more]</label></div><br/><div class="children"><div class="content">Or you can use Cassandra &#x2F; DataStax Astra to store the original text, the metadata and the embedding in a single table and then do hybrid queries against them (with pre- or post-filtering, optimized automatically).</div><br/></div></div><div id="41990652" class="c"><input type="checkbox" id="c-41990652" checked=""/><div class="controls bullet"><span class="by">bryantwolf</span><span>|</span><a href="#41992340">prev</a><span>|</span><a href="#41989204">next</a><span>|</span><label class="collapse" for="c-41990652">[-]</label><label class="expand" for="c-41990652">[5 more]</label></div><br/><div class="children"><div class="content">Hey, this looks great! I&#x27;m a huge fan of vectors in Postgres or wherever your data lives, and this seems like a great abstraction.<p>When I write a sql query that includes a vector search and some piece of logic, like:
```
select name from users where age &gt; 21 order by &lt;vector_similarity(users.bio, &quot;I like long walks on the beach&quot;)&gt; limit 10;
```
Does it filter by age first or second? I&#x27;ve liked the DX of pg_vector, but they do vector search, followed by filtering. It seems like that slows down what should be the superpower of a setup like this.<p>Here&#x27;s a bit more of a complicated example of what I&#x27;m talking about: <a href="https:&#x2F;&#x2F;blog.bawolf.com&#x2F;p&#x2F;embeddings-are-a-good-starting-point" rel="nofollow">https:&#x2F;&#x2F;blog.bawolf.com&#x2F;p&#x2F;embeddings-are-a-good-starting-poi...</a></div><br/><div id="41990952" class="c"><input type="checkbox" id="c-41990952" checked=""/><div class="controls bullet"><span class="by">cevian</span><span>|</span><a href="#41990652">parent</a><span>|</span><a href="#41990659">next</a><span>|</span><label class="collapse" for="c-41990952">[-]</label><label class="expand" for="c-41990952">[1 more]</label></div><br/><div class="children"><div class="content">(post co-author here)<p>It could do either depending on on what the planner decides. In pgvector it usually does post-filtering in practice (filter after vector search).<p>pgvector HNSW has the problem that there is a cutoff of retrieving some constant C results and if none of them match the filter than it won&#x27;t find results. I believe newer version of pgvector address that. Also pgvectorscale&#x27;s StreamingDiskANN[1] doesn&#x27;t have that problem to begin with.<p>[1]: <a href="https:&#x2F;&#x2F;www.timescale.com&#x2F;blog&#x2F;how-we-made-postgresql-as-fast-as-pinecone-for-vector-data&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.timescale.com&#x2F;blog&#x2F;how-we-made-postgresql-as-fas...</a></div><br/></div></div><div id="41990659" class="c"><input type="checkbox" id="c-41990659" checked=""/><div class="controls bullet"><span class="by">jeffchuber</span><span>|</span><a href="#41990652">parent</a><span>|</span><a href="#41990952">prev</a><span>|</span><a href="#41989204">next</a><span>|</span><label class="collapse" for="c-41990659">[-]</label><label class="expand" for="c-41990659">[3 more]</label></div><br/><div class="children"><div class="content">pg_vector does post-filtering, not pre-filtering</div><br/><div id="41990965" class="c"><input type="checkbox" id="c-41990965" checked=""/><div class="controls bullet"><span class="by">brewii</span><span>|</span><a href="#41990652">root</a><span>|</span><a href="#41990659">parent</a><span>|</span><a href="#41989204">next</a><span>|</span><label class="collapse" for="c-41990965">[-]</label><label class="expand" for="c-41990965">[2 more]</label></div><br/><div class="children"><div class="content">timescaledbs pg_vector_scale extension does pre-filtering thankfully. shame i cant get it in RDS though</div><br/><div id="41991155" class="c"><input type="checkbox" id="c-41991155" checked=""/><div class="controls bullet"><span class="by">akulkarni</span><span>|</span><a href="#41990652">root</a><span>|</span><a href="#41990965">parent</a><span>|</span><a href="#41989204">next</a><span>|</span><label class="collapse" for="c-41991155">[-]</label><label class="expand" for="c-41991155">[1 more]</label></div><br/><div class="children"><div class="content">You can request it for RDS</div><br/></div></div></div></div></div></div></div></div><div id="41989204" class="c"><input type="checkbox" id="c-41989204" checked=""/><div class="controls bullet"><span class="by">dinobones</span><span>|</span><a href="#41990652">prev</a><span>|</span><a href="#41989536">next</a><span>|</span><label class="collapse" for="c-41989204">[-]</label><label class="expand" for="c-41989204">[3 more]</label></div><br/><div class="children"><div class="content">Wow, actually a good point I haven&#x27;t seen anyone make.<p>Taking raw embeddings and then storing them into vector databases, would be like if you took raw n-grams of your text and put them into a database for search.<p>Storing documents makes much more sense.</div><br/><div id="41989406" class="c"><input type="checkbox" id="c-41989406" checked=""/><div class="controls bullet"><span class="by">choilive</span><span>|</span><a href="#41989204">parent</a><span>|</span><a href="#41989536">next</a><span>|</span><label class="collapse" for="c-41989406">[-]</label><label class="expand" for="c-41989406">[2 more]</label></div><br/><div class="children"><div class="content">Been using pgvector for a while, and to me it was kind of obvious that the source document and the embeddings are fundamentally linked so we always stored them &quot;together&quot;. Basically anyone doing embeddings at scale is doing something similar to what Pgai Vectorizer is doing and is certainly a nice abstraction.</div><br/><div id="41989816" class="c"><input type="checkbox" id="c-41989816" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#41989204">root</a><span>|</span><a href="#41989406">parent</a><span>|</span><a href="#41989536">next</a><span>|</span><label class="collapse" for="c-41989816">[-]</label><label class="expand" for="c-41989816">[1 more]</label></div><br/><div class="children"><div class="content">I used FAISS as it also allowed me to trivially store them together.<p>Idk how well it scales though, it&#x27;s just doing it&#x27;s job on my hobby project scale<p>For my few 100&#x27;000s embeddings I must say the performance was satisfactory.</div><br/></div></div></div></div></div></div><div id="41989536" class="c"><input type="checkbox" id="c-41989536" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41989204">prev</a><span>|</span><a href="#41990713">next</a><span>|</span><label class="collapse" for="c-41989536">[-]</label><label class="expand" for="c-41989536">[3 more]</label></div><br/><div class="children"><div class="content">I’m using sqlite-vec along with FTS5 in (you guessed it) SQLite and it’s pretty cool. :)</div><br/><div id="41992320" class="c"><input type="checkbox" id="c-41992320" checked=""/><div class="controls bullet"><span class="by">xyc</span><span>|</span><a href="#41989536">parent</a><span>|</span><a href="#41992318">next</a><span>|</span><label class="collapse" for="c-41992320">[-]</label><label class="expand" for="c-41992320">[1 more]</label></div><br/><div class="children"><div class="content">what&#x27;s your experience with sqlite-vec? I&#x27;m considering using sqlite-vec in addition to&#x2F;or replace qdrant vector db for a project (recurse.chat), since I&#x27;m moving all the data to sqlite. I love everything SQLite so far, but haven&#x27;t got to try out sqlite-vec yet.</div><br/></div></div></div></div><div id="41990713" class="c"><input type="checkbox" id="c-41990713" checked=""/><div class="controls bullet"><span class="by">keithwhor</span><span>|</span><a href="#41989536">prev</a><span>|</span><a href="#41990798">next</a><span>|</span><label class="collapse" for="c-41990713">[-]</label><label class="expand" for="c-41990713">[1 more]</label></div><br/><div class="children"><div class="content">I agree.<p>Similar to blog post, instead of at the extension layer I built a PostgreSQL ORM for Node.js based on ActiveRecord + Django&#x27;s ORM that includes the concept of vector fields [0][1] that lets you write code like this:<p><pre><code>    &#x2F;&#x2F; Stores the `title` and `content` fields together as a vector
    &#x2F;&#x2F; in the `content_embedding` vector field
    BlogPost.vectorizes(
      &#x27;content_embedding&#x27;,
      (title, content) =&gt; `Title: ${title}\n\nBody: ${content}`
    );

    &#x2F;&#x2F; Find the top 10 blog posts matching &quot;blog posts about dogs&quot;
    &#x2F;&#x2F; Automatically converts query to a vector
    let searchBlogPosts = await BlogPost.query()
      .search(&#x27;content_embedding&#x27;, &#x27;blog posts about dogs&#x27;)
      .limit(10)
      .select();
</code></pre>
I find it tremendously useful; you can query the underlying data or the embedding content, and you can define how the fields in the model get stored as embeddings in the first place.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;instant-dev&#x2F;orm?tab=readme-ov-file#using-vector-fields">https:&#x2F;&#x2F;github.com&#x2F;instant-dev&#x2F;orm?tab=readme-ov-file#using-...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;instant-dev&#x2F;orm?tab=readme-ov-file#using-vector-fields">https:&#x2F;&#x2F;github.com&#x2F;instant-dev&#x2F;orm?tab=readme-ov-file#using-...</a></div><br/></div></div><div id="41990798" class="c"><input type="checkbox" id="c-41990798" checked=""/><div class="controls bullet"><span class="by">gillesjacobs</span><span>|</span><a href="#41990713">prev</a><span>|</span><a href="#41990243">next</a><span>|</span><label class="collapse" for="c-41990798">[-]</label><label class="expand" for="c-41990798">[1 more]</label></div><br/><div class="children"><div class="content">Safe to say that if you&#x27;re using off-the-shelf character-based chunking, your AI app is not past PoC.</div><br/></div></div><div id="41990243" class="c"><input type="checkbox" id="c-41990243" checked=""/><div class="controls bullet"><span class="by">ok123456</span><span>|</span><a href="#41990798">prev</a><span>|</span><a href="#41989677">next</a><span>|</span><label class="collapse" for="c-41990243">[-]</label><label class="expand" for="c-41990243">[3 more]</label></div><br/><div class="children"><div class="content">Yes. Materialized Views are good.</div><br/><div id="41990318" class="c"><input type="checkbox" id="c-41990318" checked=""/><div class="controls bullet"><span class="by">unholyguy001</span><span>|</span><a href="#41990243">parent</a><span>|</span><a href="#41990311">next</a><span>|</span><label class="collapse" for="c-41990318">[-]</label><label class="expand" for="c-41990318">[1 more]</label></div><br/><div class="children"><div class="content">That was just what I was thinking. This approach will have the same issues that materialized views have as well</div><br/></div></div><div id="41990311" class="c"><input type="checkbox" id="c-41990311" checked=""/><div class="controls bullet"><span class="by">cevian</span><span>|</span><a href="#41990243">parent</a><span>|</span><a href="#41990318">prev</a><span>|</span><a href="#41989677">next</a><span>|</span><label class="collapse" for="c-41990311">[-]</label><label class="expand" for="c-41990311">[1 more]</label></div><br/><div class="children"><div class="content">haha. We had a good internal debate as to whether this is more like indexes or more like Materialized Views. It&#x27;s kinda a mixture of the two.</div><br/></div></div></div></div><div id="41989677" class="c"><input type="checkbox" id="c-41989677" checked=""/><div class="controls bullet"><span class="by">mattxxx</span><span>|</span><a href="#41990243">prev</a><span>|</span><a href="#41990676">next</a><span>|</span><label class="collapse" for="c-41989677">[-]</label><label class="expand" for="c-41989677">[3 more]</label></div><br/><div class="children"><div class="content">This reads solely as a sales pitch, which quickly cuts to the &quot;we&#x27;re selling this product so you don&#x27;t have to think about it.&quot;<p>...when you actually do want to think about it (in 2024).<p>Right now, we&#x27;re collectively still figuring out:<p><pre><code>  1. Best chunking strategies for documents
  2. Best ways to add context around chunks of documents
  3. How to mix and match similarity search with hybrid search
  4. Best way to version and update your embeddings</code></pre></div><br/><div id="41992486" class="c"><input type="checkbox" id="c-41992486" checked=""/><div class="controls bullet"><span class="by">torsstei</span><span>|</span><a href="#41989677">parent</a><span>|</span><a href="#41989830">next</a><span>|</span><label class="collapse" for="c-41992486">[-]</label><label class="expand" for="c-41992486">[1 more]</label></div><br/><div class="children"><div class="content">Points 2-4 are clear pointers to a real database as the home for vector data &amp; search.</div><br/></div></div><div id="41989830" class="c"><input type="checkbox" id="c-41989830" checked=""/><div class="controls bullet"><span class="by">cevian</span><span>|</span><a href="#41989677">parent</a><span>|</span><a href="#41992486">prev</a><span>|</span><a href="#41990676">next</a><span>|</span><label class="collapse" for="c-41989830">[-]</label><label class="expand" for="c-41989830">[1 more]</label></div><br/><div class="children"><div class="content">(post co-author here)<p>We agree a lot of stuff still needs to be figured out. Which is why we made vectorizer very configurable. You can configure chunking strategies, formatting (which is a way to add context back into chunks). You can mix semantic and lexical search on the results. That handles your 1,2,3. Versioning can mean a different version of the data (in which case the versioning info lives with the source data) OR a different embedding config, which we also support[1].<p>Admittedly, right now we have predefined chunking strategies. But we plan to add custom-code options very soon.<p>Our broader point is that the things you highlight above are the right things to worry about, not the data workflow ops and babysitting your lambda jobs. That&#x27;s what we want to handle for you.<p>[1]: <a href="https:&#x2F;&#x2F;www.timescale.com&#x2F;blog&#x2F;which-rag-chunking-and-formatting-strategy-is-best&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.timescale.com&#x2F;blog&#x2F;which-rag-chunking-and-format...</a></div><br/></div></div></div></div><div id="41990676" class="c"><input type="checkbox" id="c-41990676" checked=""/><div class="controls bullet"><span class="by">jeffchuber</span><span>|</span><a href="#41989677">prev</a><span>|</span><a href="#41990330">next</a><span>|</span><label class="collapse" for="c-41990676">[-]</label><label class="expand" for="c-41990676">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Vector databases treat embeddings as independent data, divorced from the source data from which embeddings are created<p>With the exception of Pinecone: Chroma, Qdrant, Weaviate, Elastic, Mongo, and many others store the chunk&#x2F;document alongside the embedding.<p>This is intentional misinformation.</div><br/><div id="41990788" class="c"><input type="checkbox" id="c-41990788" checked=""/><div class="controls bullet"><span class="by">avthar</span><span>|</span><a href="#41990676">parent</a><span>|</span><a href="#41990330">next</a><span>|</span><label class="collapse" for="c-41990788">[-]</label><label class="expand" for="c-41990788">[6 more]</label></div><br/><div class="children"><div class="content">Post co-author here. The point is a little nuanced, so let me explain:<p>You are correct in saying that that you can store embeddings and source data together in many vectordbs. We actually point this out in the post. The main point is that they are not linked but merely stored alongside each other. If one changes, the other one does not automatically change, making the relationship between the two stale.<p>The idea behind Pgai Vectorizer is that it actually links embeddings with underlying source data so that changes in source data are automatically reflected in embeddings. This is a better abstraction and it removes the burden of the engineer to ensure embeddings are in sync as their data changes.</div><br/><div id="41990867" class="c"><input type="checkbox" id="c-41990867" checked=""/><div class="controls bullet"><span class="by">jeffchuber</span><span>|</span><a href="#41990676">root</a><span>|</span><a href="#41990788">parent</a><span>|</span><a href="#41990330">next</a><span>|</span><label class="collapse" for="c-41990867">[-]</label><label class="expand" for="c-41990867">[5 more]</label></div><br/><div class="children"><div class="content">i know it is the case in chroma this is supported out of the box with 0 lines of code. i’m pretty sure it’s supported everywhere else in no more than 3 lines of code.</div><br/><div id="41991611" class="c"><input type="checkbox" id="c-41991611" checked=""/><div class="controls bullet"><span class="by">spmurrayzzz</span><span>|</span><a href="#41990676">root</a><span>|</span><a href="#41990867">parent</a><span>|</span><a href="#41990921">next</a><span>|</span><label class="collapse" for="c-41991611">[-]</label><label class="expand" for="c-41991611">[1 more]</label></div><br/><div class="children"><div class="content">This is also the case with weaviate (as you assumed). If you update the value of any previously vectorized property, weaviate generates new vectors automatically for you.</div><br/></div></div><div id="41990921" class="c"><input type="checkbox" id="c-41990921" checked=""/><div class="controls bullet"><span class="by">cevian</span><span>|</span><a href="#41990676">root</a><span>|</span><a href="#41990867">parent</a><span>|</span><a href="#41991611">prev</a><span>|</span><a href="#41990330">next</a><span>|</span><label class="collapse" for="c-41990921">[-]</label><label class="expand" for="c-41990921">[3 more]</label></div><br/><div class="children"><div class="content">as far as I can tell Chroma can only store chunks, not the original documents. This is from your docs `If the documents are too large to embed using the chosen embedding function, an exception will be raised`.<p>In addition it seems that embeddings happen at ingest time. So, if, for example, the OpenAI endpoint is down the insert will fail. That, in turn means your users need to use a retry mechanism and a queuing system. All the complexity we describe in our blog.<p>Obviously, I am not an expert in Chroma. So apologies in advance if I got anything wrong. Just trying to get to the heart of the differences between the two systems.</div><br/><div id="41991713" class="c"><input type="checkbox" id="c-41991713" checked=""/><div class="controls bullet"><span class="by">spmurrayzzz</span><span>|</span><a href="#41990676">root</a><span>|</span><a href="#41990921">parent</a><span>|</span><a href="#41990330">next</a><span>|</span><label class="collapse" for="c-41991713">[-]</label><label class="expand" for="c-41991713">[2 more]</label></div><br/><div class="children"><div class="content">Chroma certainly doesn&#x27;t have the most advanced API in this area, but you can for sure store chunks or documents, its up to you. If your document size is too large to generate embeddings in a single forward pass, then yes you do need to chunk in that scenario.<p>Oftentimes though, even if the document does fit, you choose to chunk anyways or further transform the data with abstractive&#x2F;extractive summarization techniques to improve your search dynamics. This is why I&#x27;m not sure the complexity noted in the article is relevant in anything beyond a &quot;naive RAG&quot; stack. How its stored or linked is an issue to some degree, but the greater more complex smell is in what happens before you even get to that point of inserting the data.<p>For more production-grade RAG, just blindly inserting embeddings wholesale for full documents is rarely going to get you great results (this varies a lot between document sizes and domains). So as a result, you&#x27;re almost always going to be doing ahead-of-time chunking (or summarization&#x2F;NER&#x2F;etc) not because you have to due to document size, but because your search performance demands it. Frequently this involves more than one embeddings model for capturing different semantics or supporting different tasks, not to mention reranking after the initial sweep.<p>That&#x27;s the complexity that I think is worth tackling in a paid product offering, but the current state of the module described in the article isn&#x27;t really competitive with the rest of the field in that respect IMHO.</div><br/><div id="41993039" class="c"><input type="checkbox" id="c-41993039" checked=""/><div class="controls bullet"><span class="by">cevian</span><span>|</span><a href="#41990676">root</a><span>|</span><a href="#41991713">parent</a><span>|</span><a href="#41990330">next</a><span>|</span><label class="collapse" for="c-41993039">[-]</label><label class="expand" for="c-41993039">[1 more]</label></div><br/><div class="children"><div class="content">(Post co author) We absolutely agree that chunking is critical for good RAG. What I think you missed in our post is that the vectorizer allows you to configure a chunking strategy of your choice. So you store the full doc but then the system well chunk and embed it for you. We don’t blindly embed the full document.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41990330" class="c"><input type="checkbox" id="c-41990330" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41990676">prev</a><span>|</span><a href="#41991726">next</a><span>|</span><label class="collapse" for="c-41990330">[-]</label><label class="expand" for="c-41990330">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the responsibility for generating and updating them as the underlying data changes can be handed over to the database management system<p>And now we shift ever more slightly back towards logic in the DB. I for one am thrilled; there’s no reason other than unfamiliarity to not let RDBMS perform functions it’s designed to do. As long as these offloads are documented in code, embrace not needing to handle it in your app.</div><br/></div></div><div id="41991726" class="c"><input type="checkbox" id="c-41991726" checked=""/><div class="controls bullet"><span class="by">dmezzetti</span><span>|</span><a href="#41990330">prev</a><span>|</span><a href="#41985534">next</a><span>|</span><label class="collapse" for="c-41991726">[-]</label><label class="expand" for="c-41991726">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been in the vector database space for a while (primary author of txtai). I do think vector indexing in traditional databases with tools like pgvector is a good option.<p>txtai has long had SQLite + Faiss support to enable metadata filtering with vector search. That pattern can take you farther than you think.<p>The design decisions I&#x27;ve made is to make it easy to plug different backends in for metadata and vectors. For example, txtai supports storing both in Postgres (w&#x2F; pgvector). It also supports sqlite-vec and DuckDB.<p>I&#x27;m not sure there is a one-size-fits-all approach. Flexibility and options seems like a win to me. Different situations warrant different solutions.</div><br/></div></div></div></div></div></div></div></body></html>