<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733475653505" as="style"/><link rel="stylesheet" href="styles.css?v=1733475653505"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://artificialworlds.net/blog/2024/12/04/message-order-in-matrix/">Message order in Matrix: right now, we are deliberately inconsistent</a> <span class="domain">(<a href="https://artificialworlds.net">artificialworlds.net</a>)</span></div><div class="subtext"><span>whereistimbo</span> | <span>92 comments</span></div><br/><div><div id="42325737" class="c"><input type="checkbox" id="c-42325737" checked=""/><div class="controls bullet"><span class="by">timokoesters</span><span>|</span><a href="#42337716">next</a><span>|</span><label class="collapse" for="c-42325737">[-]</label><label class="expand" for="c-42325737">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the author of the spec issue this blog post is based on: <a href="https:&#x2F;&#x2F;github.com&#x2F;matrix-org&#x2F;matrix-spec&#x2F;issues&#x2F;852">https:&#x2F;&#x2F;github.com&#x2F;matrix-org&#x2F;matrix-spec&#x2F;issues&#x2F;852</a><p>In my implementation for the Conduit Matrix server, the &#x2F;sync order is used for everything. The timeline is just one list that grows on one end for incoming events and on the other end for backfilled events.<p>I think it&#x27;s important that the message order does not change, because that&#x27;s very difficult to communicate to the user.</div><br/><div id="42325836" class="c"><input type="checkbox" id="c-42325836" checked=""/><div class="controls bullet"><span class="by">Fizzadar</span><span>|</span><a href="#42325737">parent</a><span>|</span><a href="#42337716">next</a><span>|</span><label class="collapse" for="c-42325836">[-]</label><label class="expand" for="c-42325836">[1 more]</label></div><br/><div class="children"><div class="content">Oh that’s neat (TIL), am also working on a HS that also does this [1].<p>Not only does it feel like the most correct (I don’t think there is a perfect) behaviour for the user but also makes implementation much simpler. Synapse has a LOT of ordering foo and magic in the code I still don’t fully understand and I’ve gone fairly deep into synapse at times for work.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Beeper&#x2F;babbleserv">https:&#x2F;&#x2F;github.com&#x2F;Beeper&#x2F;babbleserv</a></div><br/></div></div></div></div><div id="42337716" class="c"><input type="checkbox" id="c-42337716" checked=""/><div class="controls bullet"><span class="by">amstan</span><span>|</span><a href="#42325737">prev</a><span>|</span><a href="#42324854">next</a><span>|</span><label class="collapse" for="c-42337716">[-]</label><label class="expand" for="c-42337716">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s infuriating how the client must be stateful and have local storage, for both the access_token and the last message recieved. That&#x27;s right you must remember as the client where the last events [1] you&#x27;ve seen (even if you already told the server to mark it as read) was or else the server will happily send you the same messages over and over again across restarts of your client.
I kind of miss making IRC bots where things were much simpler and ... quicker honestly (latency wise).<p>[1] <a href="https:&#x2F;&#x2F;uhoreg.gitlab.io&#x2F;matrix-tutorial&#x2F;sync.html#:~:text=w" rel="nofollow">https:&#x2F;&#x2F;uhoreg.gitlab.io&#x2F;matrix-tutorial&#x2F;sync.html#:~:text=w</a>...</div><br/></div></div><div id="42324854" class="c"><input type="checkbox" id="c-42324854" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42337716">prev</a><span>|</span><a href="#42325181">next</a><span>|</span><label class="collapse" for="c-42324854">[-]</label><label class="expand" for="c-42324854">[54 more]</label></div><br/><div class="children"><div class="content">This is something that many chat apps get wrong and I&#x27;m not sure this article is moving in the right direction. The UX is fairly clear in my mind:<p>1. All up-to-date clients should be displaying the same message order.
2. A single client should not send messages in the wrong order.<p>Yes a client may be out of date and therefore show something different, but once it becomes up to date it should be showing the same state even if that means amending history. Why? Because the humans reading it will be confused otherwise! An app getting more data is something we intuitively understand, but if my client shows something and yours shows something else, we will conclude different meanings from it.<p>Additionally there are some clients that treat each message input by the user as a retriable thing in isolation, which is also clearly incorrect. If I send two messages and the first fails to go through, I almost certainly don&#x27;t want to retry the second until the first has gone through, otherwise my client has literally sent out of order messages! I use Beeper for chat and this is one of the most frustrating things it does.</div><br/><div id="42335067" class="c"><input type="checkbox" id="c-42335067" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">parent</a><span>|</span><a href="#42325584">next</a><span>|</span><label class="collapse" for="c-42335067">[-]</label><label class="expand" for="c-42335067">[2 more]</label></div><br/><div class="children"><div class="content">Agreed, absolutely.  I was surprised by the author&#x27;s aside that mentioned a colleague that disagreed, claiming that it&#x27;s ok or even useful (what?) that two clients (or even the same client in different situations) could show different message orderings... and acknowledging that this point is debatable.<p>It&#x27;s not debatable!  There is, actually, in reality, one true message ordering (at this time I think we can safely ignore relativistic effects), and that message ordering should be the one that is always displayed.  Our technology and the nature of distributed systems may make it impossible to always faithfully determine what the true message ordering is, but at the very least, the implementation should decide on a single message ordering, and always present that same message ordering.  (This does mean that clients connected to different homeservers might see different orderings; this is unfortunate but probably unavoidable.  But clients connected to the same homeserver should all see the same ordering.)<p>Anything else is just terrible, awful, horrible UX, that will ultimately confuse users.  And it will also reduce user faith in the system as a whole: if they notice the inconsistent ordering, they will assume the system is buggy and unreliable.<p>At the risk of sounding way too absolutist: this is not debatable, and anyone who thinks it is, is wrong.</div><br/><div id="42337283" class="c"><input type="checkbox" id="c-42337283" checked=""/><div class="controls bullet"><span class="by">bostik</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42335067">parent</a><span>|</span><a href="#42325584">next</a><span>|</span><label class="collapse" for="c-42337283">[-]</label><label class="expand" for="c-42337283">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>clients connected to the same homeserver should all see the same ordering</i><p>Ideally, yes. In the real world you get to deal with such inconveniences as unreliable transport, slow networks, server-to-server communications, eventual consistency, routing glitches, reconnections, clock skew, queues, concurrency, retries, and always, ALWAYS the infuriatingly slow speed of light. Oh yes, also multiple client implementations. For the record, many years ago I was involved in writing both a chat server and a client. (Albeit those were two different projects.)<p>From pure UX standpoint, you want the client to always show any messages it has sent but has not received back. Even for a single server and two clients, all synchronised to the same clock, you can get ordering conflicts. Let&#x27;s say that you are sending a message at fixed two-second interval, and the other client is sending messages at non-fixed, power law distribution intervals. That&#x27;s your happy path.<p>Now consider the same with dozens, or hundreds of clients across hundreds of different networks, each with their own debatable quality.<p>You want to see the messages you&#x27;ve sent, so they need to be visible on your screen. Having your own messages disappear into the void and <i>only</i> appear once they have been sent back is terrible UX. So you keep a local order and interleave received messages as they come in. But once you receive the message back from the server, you obviously want to reorder the known quantities. With two clients you will the occasional &quot;jump&quot; where one of your messages is moved to its canonical position. With hundreds of clients each user will see those jumps constantly - and with sufficient volume a decent fraction of their own sent messages can &quot;disappear&quot; at any time from their screen as they are reordered and don&#x27;t fit on the screen.<p>Now add lots of bad networks and latency floor in hundreds of milliseconds. Network connections&#x2F;route fluctuate constantly, so even messages sent by the same client less than two seconds apart can arrive in different order at the server. (The client reconnected between the two, and the message sent over the first connection arrives several seconds later than the other one.) The user is confused, because the server is very clearly showing them their own messages in the wrong order.<p>For one inconvenienced user the server being wrong occasionally is mildly annoying. But when that can happen to any number of users, concurrently, at any time, the overall effect is outright infuriating.<p>&gt; <i>this is not debatable, and anyone who thinks it is, is wrong</i><p>Your server has a known order it sent the messages out. Any disagreement means the client must be wrong.<p>Each of the clients connected to your server has a known order in which they sent their messages out. Any disagreement means the server must be wrong.</div><br/></div></div></div></div><div id="42325584" class="c"><input type="checkbox" id="c-42325584" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#42324854">parent</a><span>|</span><a href="#42335067">prev</a><span>|</span><a href="#42329237">next</a><span>|</span><label class="collapse" for="c-42325584">[-]</label><label class="expand" for="c-42325584">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Yes a client may be out of date and therefore show something different, but once it becomes up to date it should be showing the same state even if that means amending history. Why? Because the humans reading it will be confused otherwise! An app getting more data is something we intuitively understand, but if my client shows something and yours shows something else, we will conclude different meanings from it.<p>That&#x27;s interesting because I have the complete opposite take and would hard disagree with this. I intuitively understand that if we both write messages at the same time, we will see them in different order. Snail mail has worked this way for centuries, and I very much prefer this to an app silently altering the content as time goes. It is confusing when it happens under my eyes (something moved at the top of the screen while I was reading the bottom, what was it?) and easily leads to missed messages especially in group conversations (my buddy sent a message with a poor connection at 11am, it is retried and sent at 2pm and appears before the lengthy discussion others had at noon).</div><br/><div id="42325722" class="c"><input type="checkbox" id="c-42325722" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325584">parent</a><span>|</span><a href="#42335087">next</a><span>|</span><label class="collapse" for="c-42325722">[-]</label><label class="expand" for="c-42325722">[5 more]</label></div><br/><div class="children"><div class="content">Snail mail has never claimed that a history of all messages, with that history having a current state, exists. If you send a paper letter, you don&#x27;t have it yourself anymore. You might keep a copy, but that&#x27;s a _copy_, not the letter you sent.<p>Messenger apps claim that such a history exists by showing you, well, that history. In the same way, messengers claim that a message order exists, by showing you the messages in that order. If something exists, then it is independent of the viewer. So the assumption that the message order is the same for all viewers is founded in how two people look at physical objects.</div><br/><div id="42325862" class="c"><input type="checkbox" id="c-42325862" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325722">parent</a><span>|</span><a href="#42335087">next</a><span>|</span><label class="collapse" for="c-42325862">[-]</label><label class="expand" for="c-42325862">[4 more]</label></div><br/><div class="children"><div class="content">Messenger apps don&#x27;t claim that this history should be global and consistent. The order in which messages were sent and received by my device is a perfectly fine (and I&#x27;d say intuitive) history. It is the order people (and their records, if they have some) would have had in mind in the old time.<p>I take a different conclusion from the way people look at physical objects: since your device (or even my other device) is a different physical object than my device, I&#x27;d be wholly unsurprised to find a different order there.</div><br/><div id="42326130" class="c"><input type="checkbox" id="c-42326130" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325862">parent</a><span>|</span><a href="#42335152">next</a><span>|</span><label class="collapse" for="c-42326130">[-]</label><label class="expand" for="c-42326130">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Messenger apps don&#x27;t claim that this history should be global and consistent.<p>The fact that we&#x27;re talking about multiple people looking at the same chat - the fact that we do conceptualise it as &quot;the same chat&quot; and &quot;the history&quot; - implies that we think of it as a single thing. And I think messenger apps generally nudge us that way - e.g. setting the name of the chat usually sets it for everyone.<p>&gt; It is the order people (and their records, if they have some) would have had in mind in the old time.<p>I don&#x27;t think it is. If I pull my correspondence with person X out of my drawer or file, the only dates I have to order them by are the dates written on the letters - which are the letters they and I (if I keep carbons of the ones I send) wrote them on, not the dates I received them. If they sent me a postcard while on holiday and then a letter after returning that arrived sooner, I&#x27;ll read them in one order on receipt and in a different order when looking back. Likewise if I have a memo of a phone call with them, that may be from before I received a letter that is nevertheless dated earlier.</div><br/><div id="42326585" class="c"><input type="checkbox" id="c-42326585" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42326130">parent</a><span>|</span><a href="#42335152">next</a><span>|</span><label class="collapse" for="c-42326585">[-]</label><label class="expand" for="c-42326585">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think messenger apps generally nudge us that way - e.g. setting the name of the chat usually sets it for everyone.<p>That&#x27;s a good point - maybe it&#x27;s actually email that warped my mind.<p>&gt; I&#x27;ll read them in one order on receipt and in a different order when looking back<p>Also a good point, I was thinking more about business communication where the date the letter is received matters. Thinking back on it, I think the main difference is that the messenger apps might happily reorder message before (or while) I read them. And if only one order is to be available, the one of the most use to me for an instant messaging app is the one I received the messages in, but I get how for other use cases it would be different.</div><br/></div></div></div></div><div id="42335152" class="c"><input type="checkbox" id="c-42335152" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325862">parent</a><span>|</span><a href="#42326130">prev</a><span>|</span><a href="#42335087">next</a><span>|</span><label class="collapse" for="c-42335152">[-]</label><label class="expand" for="c-42335152">[1 more]</label></div><br/><div class="children"><div class="content">Well, this really depends on the protocol and architecture of the system.<p>If it&#x27;s a system where the server is merely store-and-forward, where it forgets its knowledge of messages after the recipients have received them, then sure, your stance is reasonable.  The client will decide on message ordering; it can either just display in the order received from the server, or use any timestamps stored in the messages to order them (including possibly reordering if messages arrive out of order).  The client has no other source of truth it can draw from, and so different clients may order things differently.  (Even in this case, though, for many systems like this I would expect the server to timestamp the messages, and for all clients to honor those timestamps, so in practice everyone should see the same ordering.)<p>But Matrix is not such a system: each homeserver is the system of record for what messages have been received, and what order they go in.  In this case, I would expect all users to see the same ordering, assuming all clients are able to query and receive the full history from the server.</div><br/></div></div></div></div></div></div><div id="42335087" class="c"><input type="checkbox" id="c-42335087" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325584">parent</a><span>|</span><a href="#42325722">prev</a><span>|</span><a href="#42329315">next</a><span>|</span><label class="collapse" for="c-42335087">[-]</label><label class="expand" for="c-42335087">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re arguing the same point.  I agree with you that when two people write a message at nearly the same time, they may (initially) see those messages in a different order.  But the server should decide what the ordering is, and inform the clients, which should update their view of the world.<p>The ordering the server decides may not be &quot;correct&quot; (for whatever definition of correct matters to you), but what is most important in this situation is consistency.</div><br/></div></div><div id="42329315" class="c"><input type="checkbox" id="c-42329315" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325584">parent</a><span>|</span><a href="#42335087">prev</a><span>|</span><a href="#42329237">next</a><span>|</span><label class="collapse" for="c-42329315">[-]</label><label class="expand" for="c-42329315">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I intuitively understand that if we both write messages at the same time, we will see them in different order.<p>I think you are thinking like a distributed systems designer. I would assume that if you asked 10 &quot;random Americans&quot; 9 of them would assume that someone managed to send their message first and would be surprised if their phone and their friends phone showed them messages in different orders.</div><br/><div id="42337405" class="c"><input type="checkbox" id="c-42337405" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42329315">parent</a><span>|</span><a href="#42336234">next</a><span>|</span><label class="collapse" for="c-42337405">[-]</label><label class="expand" for="c-42337405">[1 more]</label></div><br/><div class="children"><div class="content">I would assume 9 of them would not care either way.</div><br/></div></div><div id="42336234" class="c"><input type="checkbox" id="c-42336234" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42329315">parent</a><span>|</span><a href="#42337405">prev</a><span>|</span><a href="#42329237">next</a><span>|</span><label class="collapse" for="c-42336234">[-]</label><label class="expand" for="c-42336234">[1 more]</label></div><br/><div class="children"><div class="content">Many people have had the experience of &quot;I tried to call you, but you were calling me!&quot;; I don&#x27;t imagine they&#x27;d be surprised if &quot;something weird&quot; happened when you both tried to send a message at the &quot;same&quot; time.</div><br/></div></div></div></div></div></div><div id="42329237" class="c"><input type="checkbox" id="c-42329237" checked=""/><div class="controls bullet"><span class="by">RaftPeople</span><span>|</span><a href="#42324854">parent</a><span>|</span><a href="#42325584">prev</a><span>|</span><a href="#42324955">next</a><span>|</span><label class="collapse" for="c-42329237">[-]</label><label class="expand" for="c-42329237">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use these apps so maybe my solution wouldn&#x27;t work, but after reading the article, it seems that having a visual indicator of messages that are new but in the past would be a reasonable solution.<p>Especially if there were simple controls to flip into a mode that minimizes the ones already seen (collapsed and grey for example) while highlighting all of the ones inserted in the past.<p>Or, if there are many messages already seen and few inserted into hist, show the inserted ones with a small sampling of the already seen (so the user can anchor to already familiar data in the timeline) along with &quot;72 messages hidden that were previously seen&quot; type of thing in between the inserteds to condense the view.</div><br/></div></div><div id="42324955" class="c"><input type="checkbox" id="c-42324955" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">parent</a><span>|</span><a href="#42329237">prev</a><span>|</span><a href="#42325002">next</a><span>|</span><label class="collapse" for="c-42324955">[-]</label><label class="expand" for="c-42324955">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Additionally there are some clients that treat each message input by the user as a retriable thing in isolation, which is also clearly incorrect. If I send two messages and the first fails to go through, I almost certainly don&#x27;t want to retry the second until the first has gone through, otherwise my client has literally sent out of order messages!<p>I don&#x27;t think that&#x27;s clearly incorrect. If you sent two messages you presumably want them to be two messages and they should be retried as such. If what you wanted to send was a single, multi-line message, surely you would have just done that?</div><br/><div id="42325370" class="c"><input type="checkbox" id="c-42325370" checked=""/><div class="controls bullet"><span class="by">hks0</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324955">parent</a><span>|</span><a href="#42324979">next</a><span>|</span><label class="collapse" for="c-42325370">[-]</label><label class="expand" for="c-42325370">[2 more]</label></div><br/><div class="children"><div class="content">Human communications are more naunced than DB transactions. If I forget to mention something important I send a new message rather than editing the already sent one, to make sure I catch their attention. Edits can go unnoticed. Imagine this scenario:<p>[12:00 &#x2F; sent] Sell the house.<p>[12:05 &#x2F; failed] Please feed the baby.<p>[12:06 &#x2F; sent] Oh and the cat too.<p>Now the receiver&#x27;s going to sell my cat [example inspired by The Art of Multiprocessor Programming].</div><br/><div id="42325528" class="c"><input type="checkbox" id="c-42325528" checked=""/><div class="controls bullet"><span class="by">johnny22</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325370">parent</a><span>|</span><a href="#42324979">next</a><span>|</span><label class="collapse" for="c-42325528">[-]</label><label class="expand" for="c-42325528">[1 more]</label></div><br/><div class="children"><div class="content">They sure are, but I hate when slack combines my messages when I wanted two separate messages on purpose. If i send two messages, it&#x27;s because I did it on purpose.</div><br/></div></div></div></div><div id="42324979" class="c"><input type="checkbox" id="c-42324979" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324955">parent</a><span>|</span><a href="#42325370">prev</a><span>|</span><a href="#42335196">next</a><span>|</span><label class="collapse" for="c-42324979">[-]</label><label class="expand" for="c-42324979">[1 more]</label></div><br/><div class="children"><div class="content">Not at all. The separation of messages is part of communication, not me trying to game a network protocol. Maybe it&#x27;s to emphasise a point, maybe it&#x27;s to time a joke, maybe it&#x27;s to send a photo and a text message separately.</div><br/></div></div><div id="42335196" class="c"><input type="checkbox" id="c-42335196" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324955">parent</a><span>|</span><a href="#42324979">prev</a><span>|</span><a href="#42324990">next</a><span>|</span><label class="collapse" for="c-42335196">[-]</label><label class="expand" for="c-42335196">[1 more]</label></div><br/><div class="children"><div class="content">I think you are perhaps not aware of how people use messaging apps in the real world.  Many people (myself included, sometimes) will break sentences or sentence fragments into different messages.  If the messages are displayed out of order on the recipient&#x27;s side, it would be pretty hard to understand.<p>And even in the case where people do tend to send one complete thought per message, it still matters: like maybe I send a message, and then have an extra thought, and send a follow-up message that clarifies my first message.  If they are displayed out of order, that will be confusing.<p>Even if two messages are completely unrelated and completely separate thoughts (honestly this feels like a much less common case than the alternative), messages just should be displayed in the order they were sent, because that&#x27;s what reflects reality best.</div><br/></div></div><div id="42324990" class="c"><input type="checkbox" id="c-42324990" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324955">parent</a><span>|</span><a href="#42335196">prev</a><span>|</span><a href="#42324962">next</a><span>|</span><label class="collapse" for="c-42324990">[-]</label><label class="expand" for="c-42324990">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If what you wanted to send was a single, multi-line message, surely you would have just done that?<p>No. danpalmer is correct; the break between messages is an integral part of the communication.</div><br/></div></div><div id="42324962" class="c"><input type="checkbox" id="c-42324962" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324955">parent</a><span>|</span><a href="#42324990">prev</a><span>|</span><a href="#42325002">next</a><span>|</span><label class="collapse" for="c-42324962">[-]</label><label class="expand" for="c-42324962">[4 more]</label></div><br/><div class="children"><div class="content">I break up my messages, as do many people.</div><br/><div id="42324989" class="c"><input type="checkbox" id="c-42324989" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324962">parent</a><span>|</span><a href="#42325002">next</a><span>|</span><label class="collapse" for="c-42324989">[-]</label><label class="expand" for="c-42324989">[3 more]</label></div><br/><div class="children"><div class="content">Do you do so with the expectation that they might arrive out of order, or one fails?</div><br/><div id="42325190" class="c"><input type="checkbox" id="c-42325190" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42324989">parent</a><span>|</span><a href="#42325002">next</a><span>|</span><label class="collapse" for="c-42325190">[-]</label><label class="expand" for="c-42325190">[2 more]</label></div><br/><div class="children"><div class="content">Out of order no, failing and having to manually re-send which makes it out of order is acceptable.</div><br/><div id="42335211" class="c"><input type="checkbox" id="c-42335211" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325190">parent</a><span>|</span><a href="#42325002">next</a><span>|</span><label class="collapse" for="c-42335211">[-]</label><label class="expand" for="c-42335211">[1 more]</label></div><br/><div class="children"><div class="content">I find that unacceptable and frustrating, personally.  If a message fails to send, I want the client to hold back any later messages until the failed message is resolved somehow.  It should auto-retry and (hopefully) eventually succeed, or I can manually delete it and &quot;release&quot; the following messages.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42325002" class="c"><input type="checkbox" id="c-42325002" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">parent</a><span>|</span><a href="#42324955">prev</a><span>|</span><a href="#42325181">next</a><span>|</span><label class="collapse" for="c-42325002">[-]</label><label class="expand" for="c-42325002">[30 more]</label></div><br/><div class="children"><div class="content">How far back should you be able to amend history? What if a malicious client adds messages to a conversation that happened in the past? Imagine for example I&#x27;m at work and notice a critical mistake that I missed, and so I retroactively add messages to the old conversation to make it look like I&#x27;m not liable, should that be permitted by the protocol?</div><br/><div id="42336608" class="c"><input type="checkbox" id="c-42336608" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325002">parent</a><span>|</span><a href="#42325736">next</a><span>|</span><label class="collapse" for="c-42336608">[-]</label><label class="expand" for="c-42336608">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How far back should you be able to amend history?<p>If user U1 sends a message M1 at time T1, then U1 <i>must</i> be able to modify&#x2F;delete that message M1, in some reasonable sense, at any conceivable time from T1 forwards.<p>Any protocol that doesn&#x27;t support some reasonable form of message modification&#x2F;deletion in this sense, is a toy protocol, and will never be widely adopted.</div><br/></div></div><div id="42325736" class="c"><input type="checkbox" id="c-42325736" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325002">parent</a><span>|</span><a href="#42336608">prev</a><span>|</span><a href="#42335217">next</a><span>|</span><label class="collapse" for="c-42325736">[-]</label><label class="expand" for="c-42325736">[11 more]</label></div><br/><div class="children"><div class="content">&gt; How far back should you be able to amend history? What if a malicious client adds messages to a conversation that happened in the past? Imagine for example I&#x27;m at work and notice a critical mistake that I missed, and so I retroactively add messages to the old conversation to make it look like I&#x27;m not liable, should that be permitted by the protocol?<p>I believe that&#x27;s impossible? At least if you design it correctly.<p>For ordering&#x2F;interleaving purposes, what matters isn&#x27;t the time you claim to send the message, it&#x27;s the time the message is received by the server. If you want, you can display the claimed send timestamp beside the message (and prominently highlight it if it is e.g. out of order, or with a long delay, etc.), but that is irrelevant to the ordering.<p>The point here is that there should be a single consistent order on the server, and that&#x27;s what all clients ought be displaying. Any messages not yet acknowledged by the server should be displayed differently so that users are aware they haven&#x27;t been seen yet, and any messages that arrive before those are sent would obviously get inserted above those.</div><br/><div id="42329014" class="c"><input type="checkbox" id="c-42329014" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325736">parent</a><span>|</span><a href="#42326191">next</a><span>|</span><label class="collapse" for="c-42329014">[-]</label><label class="expand" for="c-42329014">[4 more]</label></div><br/><div class="children"><div class="content">Aside from the concerns with decentralized servers that the other poster mentioned, this has the disadvantage that your messages are going to get constantly reordered to not match the intended flow of the conversation when you have poor connectivity, which is a bad user experience</div><br/><div id="42329131" class="c"><input type="checkbox" id="c-42329131" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42329014">parent</a><span>|</span><a href="#42326191">next</a><span>|</span><label class="collapse" for="c-42329131">[-]</label><label class="expand" for="c-42329131">[3 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t the whole point here that the messages <i>wouldn&#x27;t</i> get reordered? There would be one definite order that everyone would see. Again, if the message isn&#x27;t timestamped by the sever, it would need to appear visually differently, so that everyone knows about this. And nobody says the server has to accept messages with arbitrarily delays either.</div><br/><div id="42329539" class="c"><input type="checkbox" id="c-42329539" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42329131">parent</a><span>|</span><a href="#42326191">next</a><span>|</span><label class="collapse" for="c-42329539">[-]</label><label class="expand" for="c-42329539">[2 more]</label></div><br/><div class="children"><div class="content">My point is that some limited reordering maybe should be allowed, but not too much. That is to say, the problem isn&#x27;t as simple as just doing it one way or another way. Every approach has some disadvantages.</div><br/><div id="42329886" class="c"><input type="checkbox" id="c-42329886" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42329539">parent</a><span>|</span><a href="#42326191">next</a><span>|</span><label class="collapse" for="c-42329886">[-]</label><label class="expand" for="c-42329886">[1 more]</label></div><br/><div class="children"><div class="content">I know you were trying to reach that conclusion, but my point was that the design I suggested neither seemed to have the problem you suggested, nor is reordering a necessary outcome, from what I can tell.</div><br/></div></div></div></div></div></div></div></div><div id="42326191" class="c"><input type="checkbox" id="c-42326191" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325736">parent</a><span>|</span><a href="#42329014">prev</a><span>|</span><a href="#42335217">next</a><span>|</span><label class="collapse" for="c-42326191">[-]</label><label class="expand" for="c-42326191">[6 more]</label></div><br/><div class="children"><div class="content">&gt; what matters isn&#x27;t the time you claim to send the message, it&#x27;s the time the message is received by the server<p>There&#x27;s no &quot;the&quot; server here. If you use the time the message is received by the server, you&#x27;ll get different views on different servers, and you may see messages from months ago appearing as new, if connectivity breaks down and is later restored.</div><br/><div id="42328717" class="c"><input type="checkbox" id="c-42328717" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42326191">parent</a><span>|</span><a href="#42335217">next</a><span>|</span><label class="collapse" for="c-42328717">[-]</label><label class="expand" for="c-42328717">[5 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no &quot;the&quot; server here.<p>Can&#x27;t you assign every conversation to a single authoritative server for handling?<p>Also, how large of a time skew are you imagining would exist between different <i>servers</i>? That stuff ought to be accurate to at least milliseconds if not micro...</div><br/><div id="42334360" class="c"><input type="checkbox" id="c-42334360" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42328717">parent</a><span>|</span><a href="#42335217">next</a><span>|</span><label class="collapse" for="c-42334360">[-]</label><label class="expand" for="c-42334360">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Can&#x27;t you assign every conversation to a single authoritative server for handling?<p>The whole point of Matrix is to be decentralised. In particular people should be able to keep talking when on different sides of a netsplit, by design.<p>&gt; Also, how large of a time skew are you imagining would exist between different servers? That stuff ought to be accurate to at least milliseconds if not micro...<p>The question isn&#x27;t how much time skew there can be between server A and server B, it&#x27;s how long they can be cut off from each other over the network, which could be hours at least. (And even when things are working well, a normal ping is a few hundred ms, which is enough to change the order of messages)</div><br/><div id="42334532" class="c"><input type="checkbox" id="c-42334532" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42334360">parent</a><span>|</span><a href="#42335217">next</a><span>|</span><label class="collapse" for="c-42334532">[-]</label><label class="expand" for="c-42334532">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The whole point of Matrix is to be decentralised. In particular people should be able to keep talking when on different sides of a netsplit, by design.<p>OK but I still don&#x27;t see the problem. Even with a fully decentralized system where the servers are just pure relays with no authority, you have two options:<p>1. Display messages in the order in which they claim to have been sent, or<p>2. Display messages in the order of arrival<p>Case #2 is the obvious&#x2F;uninteresting one, there&#x27;s nothing to say about it.<p>Case #1 is what people are saying is so impossible to achieve a global order for, but really, what&#x27;s the big deal? If a client claims to have sent a message at an unusual time (say, &gt; 10 seconds in the past, or after the app was already quit, or whatever criteria you want to set), then just insert it at that point in the conversation, <i>and visually indicate to the user the discrepancy</i>. And clock skews won&#x27;t really be much of a problem because messages can easily indicate prior messages in the conversation, so that a mere clock skew doesn&#x27;t insert them before preceding messages.<p>What&#x27;s so hard to make user-friendly&#x2F;intuitive here?</div><br/><div id="42334761" class="c"><input type="checkbox" id="c-42334761" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42334532">parent</a><span>|</span><a href="#42336706">next</a><span>|</span><label class="collapse" for="c-42334761">[-]</label><label class="expand" for="c-42334761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a client claims to have sent a message at an unusual time (say, &gt; 10 seconds in the past, or after the app was already quit, or whatever criteria you want to set), then just insert it at that point in the conversation, and visually indicate to the user the discrepancy.<p>I don&#x27;t know that OP would be happy with that, and certainly someone would need to a) actually design the UI for it b) figure out what information the client needs from the server to implement that, and whether it&#x27;s possible for the server to provide that information.<p>I think you&#x27;re probably right, FWIW, but someone needs to actually do the legwork of designing and implementing what you&#x27;re suggesting rather than just handwaving it.</div><br/></div></div><div id="42336706" class="c"><input type="checkbox" id="c-42336706" checked=""/><div class="controls bullet"><span class="by">2Gkashmiri</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42334532">parent</a><span>|</span><a href="#42334761">prev</a><span>|</span><a href="#42335217">next</a><span>|</span><label class="collapse" for="c-42336706">[-]</label><label class="expand" for="c-42336706">[1 more]</label></div><br/><div class="children"><div class="content">Why cant we have a sent time and the receipt time ?<p>The time the sender claims the client sent the message be appended to the message itself.<p>Let it reach 500ms or 2 seconds later.<p>If there is an acceptable skew between the sending time and receiving time, we just accept the sending time.<p>Edit: what this could do is, the sender when they sent the message, they were aware about x messages before and the clocks being in sync for existing messages, their message even if received 2 seconds later would be put in the origiNAL order of sender intention</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42335217" class="c"><input type="checkbox" id="c-42335217" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325002">parent</a><span>|</span><a href="#42325736">prev</a><span>|</span><a href="#42325095">next</a><span>|</span><label class="collapse" for="c-42335217">[-]</label><label class="expand" for="c-42335217">[1 more]</label></div><br/><div class="children"><div class="content">This shouldn&#x27;t be an issue for systems where a server mediates communication: the server should be timestamping messages, not the clients.<p>This could indeed be a potential problem for a decentralized system, or one where the server for some reason cannot (or cannot be trusted to) timestamp messages.  In that case, I think the best behavior for a client would be to always display messages in the order they&#x27;ve arrived, regardless of any timestamp provided by the sender.<p>But this problem shouldn&#x27;t exist for a system like Matrix.  Matrix is (somewhat) decentralized, but each homeserver can still decide on the message ordering it will present to its own clients.</div><br/></div></div><div id="42325095" class="c"><input type="checkbox" id="c-42325095" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325002">parent</a><span>|</span><a href="#42335217">prev</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42325095">[-]</label><label class="expand" for="c-42325095">[10 more]</label></div><br/><div class="children"><div class="content">You can amend displayed order for humans (what matters for 99% of usage), while still allowing anyone interested to see when the message actually arrived at the homeserver (making the suggested gambit impractical).</div><br/><div id="42335311" class="c"><input type="checkbox" id="c-42335311" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325095">parent</a><span>|</span><a href="#42325158">next</a><span>|</span><label class="collapse" for="c-42335311">[-]</label><label class="expand" for="c-42335311">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is really a problem, at least in the case of client-&gt;homeserver connections.  The homeserver should not be trusting the client&#x27;s sent timestamp.  The homeserver should consider the message sent at the time it receives it, and the client should know this and update the sent timestamp displayed to the user when it is finally able to connect to the homeserver, and the homeserver acknowledges receipt of the message.<p>The bigger problem is how to handle homeserver&lt;-&gt;homeserver comms.  My initial feeling is that the homeserver where a destination room is hosted (let&#x27;s call this one &quot;A&quot;) should have the final say, and if there are people on another homeserver (&quot;B&quot;) that have joined the room, and are chatting while there&#x27;s a break in connectivity between the two homeservers, then A should just append all the messages from B to the end of the record (with correspondingly &quot;later&quot; timestamps) to the &quot;official&quot; record, when B is able to communicate with A again.<p>But this feels messy too; presumably all of those new messages (a conversation that may have been going on for tens of minutes or hours) would be smooshed in to have their timestamps all appear nearly at the same time?  No, that&#x27;s not great either.<p>Or perhaps B just shouldn&#x27;t accept messages for that room while it can&#x27;t communicate with A?  That doesn&#x27;t seem great either.</div><br/></div></div><div id="42325158" class="c"><input type="checkbox" id="c-42325158" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325095">parent</a><span>|</span><a href="#42335311">prev</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42325158">[-]</label><label class="expand" for="c-42325158">[8 more]</label></div><br/><div class="children"><div class="content">Then instead imagine this: the user really is innocent and just happened to coincidentally send the message right after the start of a long period of poor connectivity (like a flight, or a road trip, etc). If you just allow it to go through after an arbitrary delay, with only a log of the received time for liability purposes, then the user wouldn&#x27;t have any indication of this scenario occurring.<p>Wouldn&#x27;t it be better in that case to show an error so that they can make sure the situation is addressed appropriately?</div><br/><div id="42326203" class="c"><input type="checkbox" id="c-42326203" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325158">parent</a><span>|</span><a href="#42325180">next</a><span>|</span><label class="collapse" for="c-42326203">[-]</label><label class="expand" for="c-42326203">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t it be better in that case to show an error so that they can make sure the situation is addressed appropriately?<p>If you want a single centralised server then you can set things up that way. Presumably if you&#x27;re using a setup with multiple servers, and took one of the servers on the flight&#x2F;road trip, you wanted the people on the flight&#x2F;road trip to be able to keep talking to each other over that server, even though that server is disconnected from the one in the office.</div><br/></div></div><div id="42325180" class="c"><input type="checkbox" id="c-42325180" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325158">parent</a><span>|</span><a href="#42326203">prev</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42325180">[-]</label><label class="expand" for="c-42325180">[6 more]</label></div><br/><div class="children"><div class="content">You have when the client claims it was sent (so where it goes in the displayed history) and can see when it was received. What else could you possibly do?</div><br/><div id="42325187" class="c"><input type="checkbox" id="c-42325187" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325180">parent</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42325187">[-]</label><label class="expand" for="c-42325187">[5 more]</label></div><br/><div class="children"><div class="content">For example, you could reject the message and show the user an error but only if there&#x27;s a discrepancy of &gt;X minutes. But how much discrepancy should be allowed? I don&#x27;t know, I only mean to show why I think the solution isn&#x27;t as simple as it appears</div><br/><div id="42326178" class="c"><input type="checkbox" id="c-42326178" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325187">parent</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42326178">[-]</label><label class="expand" for="c-42326178">[4 more]</label></div><br/><div class="children"><div class="content">&gt; you could reject the message and show the user an error but only if there&#x27;s a discrepancy of &gt;X minutes<p>No you can&#x27;t, not in a federated and decentralised system like this.<p>The sender can wait for a read receipt from a given receiver user, if the receiver is willing to make those public. But if the message left client A and didn&#x27;t arrive at client B, there&#x27;s no objective fact of the matter about whether the message &quot;was sent&quot; or not.</div><br/><div id="42330764" class="c"><input type="checkbox" id="c-42330764" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42326178">parent</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42330764">[-]</label><label class="expand" for="c-42330764">[3 more]</label></div><br/><div class="children"><div class="content">Seems like a design deficiency of Matrix then. When IRC federation breaks, everyone can see it, except for the rare people who aren&#x27;t in a shared channel with anyone on the other side of the break.</div><br/><div id="42334370" class="c"><input type="checkbox" id="c-42334370" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42330764">parent</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42334370">[-]</label><label class="expand" for="c-42334370">[2 more]</label></div><br/><div class="children"><div class="content">&gt; When IRC federation breaks, everyone can see it, except for the rare people who aren&#x27;t in a shared channel with anyone on the other side of the break.<p>Well sure, you could see that something was going on, if you were paying attention. But how does that solve the problem? Does your IRC client stop you from sending messages if it detects a netsplit?</div><br/><div id="42335274" class="c"><input type="checkbox" id="c-42335274" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42334370">parent</a><span>|</span><a href="#42325039">next</a><span>|</span><label class="collapse" for="c-42335274">[-]</label><label class="expand" for="c-42335274">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think IRC is a good analogy here because there&#x27;s no &quot;message resync&quot; that happens when the netsplit is resolved.  If there are two people on opposite sides of a split, and they both send messages to a channel while things are still split, they will not see the other&#x27;s messages when the split is over.<p>In the Matrix case, if a homeserver disappears for a while, it will sync any missed messages when it comes back online.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42325039" class="c"><input type="checkbox" id="c-42325039" checked=""/><div class="controls bullet"><span class="by">thomastay</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325002">parent</a><span>|</span><a href="#42325095">prev</a><span>|</span><a href="#42325089">next</a><span>|</span><label class="collapse" for="c-42325039">[-]</label><label class="expand" for="c-42325039">[3 more]</label></div><br/><div class="children"><div class="content">Obv it depends, but one way to &quot;solve&quot; this it is to show an edit history, or at least the latest edit timestamp along with some visual indicator that the message was edited recently</div><br/><div id="42325041" class="c"><input type="checkbox" id="c-42325041" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325039">parent</a><span>|</span><a href="#42325089">next</a><span>|</span><label class="collapse" for="c-42325041">[-]</label><label class="expand" for="c-42325041">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about edits, I&#x27;m talking about sending new messages which are backdated to appear as part of an older conversation</div><br/><div id="42325052" class="c"><input type="checkbox" id="c-42325052" checked=""/><div class="controls bullet"><span class="by">thomastay</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325041">parent</a><span>|</span><a href="#42325089">next</a><span>|</span><label class="collapse" for="c-42325052">[-]</label><label class="expand" for="c-42325052">[1 more]</label></div><br/><div class="children"><div class="content">icic, yeah that definitely shouldn&#x27;t be allowed</div><br/></div></div></div></div></div></div><div id="42325021" class="c"><input type="checkbox" id="c-42325021" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325002">parent</a><span>|</span><a href="#42325089">prev</a><span>|</span><a href="#42325181">next</a><span>|</span><label class="collapse" for="c-42325021">[-]</label><label class="expand" for="c-42325021">[2 more]</label></div><br/><div class="children"><div class="content">Matrix allow to edit weeks old messages, already.</div><br/><div id="42325030" class="c"><input type="checkbox" id="c-42325030" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#42324854">root</a><span>|</span><a href="#42325021">parent</a><span>|</span><a href="#42325181">next</a><span>|</span><label class="collapse" for="c-42325030">[-]</label><label class="expand" for="c-42325030">[1 more]</label></div><br/><div class="children"><div class="content">But there&#x27;s a flag which indicates they&#x27;ve been edited and you can see the edit history, right? So that&#x27;s not useful for this scenario.</div><br/></div></div></div></div></div></div></div></div><div id="42325181" class="c"><input type="checkbox" id="c-42325181" checked=""/><div class="controls bullet"><span class="by">Vanit</span><span>|</span><a href="#42324854">prev</a><span>|</span><a href="#42334948">next</a><span>|</span><label class="collapse" for="c-42325181">[-]</label><label class="expand" for="c-42325181">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m throwing some shade here, but this reeks of backend engineers not caring about UX.</div><br/><div id="42325748" class="c"><input type="checkbox" id="c-42325748" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42325181">parent</a><span>|</span><a href="#42334948">next</a><span>|</span><label class="collapse" for="c-42325748">[-]</label><label class="expand" for="c-42325748">[2 more]</label></div><br/><div class="children"><div class="content">this reeks of backend engineers not caring about UX designers who don&#x27;t understand the problem while the UI designers who do understand are barred from attending meetings for bad behavior. I&#x27;m not throwing shade.</div><br/><div id="42335332" class="c"><input type="checkbox" id="c-42335332" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42325181">root</a><span>|</span><a href="#42325748">parent</a><span>|</span><a href="#42334948">next</a><span>|</span><label class="collapse" for="c-42335332">[-]</label><label class="expand" for="c-42335332">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree.  There&#x27;s no technical reason why the different API endpoints can&#x27;t return the same ordering.  The current top comment here[0] is from someone who has implemented this (IMO) correctly in a different homeserver implementation.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42325737">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42325737</a></div><br/></div></div></div></div></div></div><div id="42334948" class="c"><input type="checkbox" id="c-42334948" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#42325181">prev</a><span>|</span><a href="#42330329">next</a><span>|</span><label class="collapse" for="c-42334948">[-]</label><label class="expand" for="c-42334948">[1 more]</label></div><br/><div class="children"><div class="content">My preference would be to avoid even <i>attempting</i> to force all into a single chronology. Instead, imagine something like the output of `git log --graph`, where the network split&#x2F;rejoin moments are also displayed by lines. It would allow people to tell that two independent conversations were going on, and that certain messages were written while another was not known.</div><br/></div></div><div id="42330329" class="c"><input type="checkbox" id="c-42330329" checked=""/><div class="controls bullet"><span class="by">Saris</span><span>|</span><a href="#42334948">prev</a><span>|</span><a href="#42324874">next</a><span>|</span><label class="collapse" for="c-42330329">[-]</label><label class="expand" for="c-42330329">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s something that Telegram always seems to get right, I&#x27;ve never seen messages out of order in different clients, and if I do something like upload a video then immediately send more text messages before it&#x27;s done, it will shove the video in between the messages where it should be when the upload is done.<p>I know it&#x27;s a much harder problem without a central server managing things. But consistency is very important for messages, out of order they could have a very different meaning and be very confusing.</div><br/><div id="42334426" class="c"><input type="checkbox" id="c-42334426" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#42330329">parent</a><span>|</span><a href="#42324874">next</a><span>|</span><label class="collapse" for="c-42334426">[-]</label><label class="expand" for="c-42334426">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I know it&#x27;s a much harder problem without a central server managing things.</i><p>In got example it is easy if the structures relating to the video and text contain some what to identify the source node, or just that they belong to the same lineage (you could have a per-thread-per-source-node value, produced from a salted hash of the real information, if source host Id is considered sensitive) and a timestamp taken at that node.<p>(Caveat: I know little of the specific protocols that are relevant here, so don&#x27;t know if they do contain any such datum)<p>Where message ordering gets difficult to the point of impracticality (if not impossibility) is where you are ordering messages from many different sources that may not have fully synchronised clocks. You can make it easier with &quot;in reply to&quot; and &quot;sent after&quot; priorities (in each case, the value being a message identifier) so any given message can be sorted by its context, but the order of sibling messages may still not have a single possible ordering. And you have to decide, if using a &quot;sent after&quot; value, if you have the last message received at the time of sending, the last message received before this message was stated, the latest opened messages, etc, all of which could give different results.<p>To a certain extent you have to get to a point where ordering is good enough and you give up on it being exact &amp; unambiguously consistent, or you&#x27;ll spend so much time working out the ordering and have no time to send you own messages :)</div><br/></div></div></div></div><div id="42324874" class="c"><input type="checkbox" id="c-42324874" checked=""/><div class="controls bullet"><span class="by">thomastay</span><span>|</span><a href="#42330329">prev</a><span>|</span><a href="#42324685">next</a><span>|</span><label class="collapse" for="c-42324874">[-]</label><label class="expand" for="c-42324874">[23 more]</label></div><br/><div class="children"><div class="content">Having dealt with this problem at work for several years now, I feel the pain of keeping different clients in sync - it&#x27;s extremely difficult. Not sure if it&#x27;s possible in Matrix, but consider having a message ID that increments by one on every message in a room. That lets the client know pretty quickly if there&#x27;s a gap or a misordering.<p>Not really getting this point though:<p><pre><code>  The &#x2F;sync API returns events in an order &quot;according to the arrival time of the event on the homeserver&quot;.

  The spec for &#x2F;messages says it returns events &quot;in chronological order. (The exact definition of chronological is dependent on the server implementation.)&quot;.
</code></pre>
Why would those two return different results? When does the chronological order of two messages differ from the arrival time of the event on the homeserver?</div><br/><div id="42324919" class="c"><input type="checkbox" id="c-42324919" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#42324874">parent</a><span>|</span><a href="#42324970">next</a><span>|</span><label class="collapse" for="c-42324919">[-]</label><label class="expand" for="c-42324919">[19 more]</label></div><br/><div class="children"><div class="content">What I think you&#x27;re missing is that Matrix runs as a distributed system. There&#x27;s no central authority to assign IDs to messages, and it&#x27;s possible for a single group chat to run in a split-brain configuration if two homeservers lose connectivity to each other. When those homeservers reconnect, users connected to each one will see messages appear &quot;in the past&quot; which were sent by users on the other side of the split.</div><br/><div id="42331804" class="c"><input type="checkbox" id="c-42331804" checked=""/><div class="controls bullet"><span class="by">wolrah</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42324919">parent</a><span>|</span><a href="#42328498">next</a><span>|</span><label class="collapse" for="c-42331804">[-]</label><label class="expand" for="c-42331804">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps I&#x27;m wrong about how Matrix works, but my understanding was that at least public rooms still had a &quot;primary&quot; homeserver, like for example I can connect to #debian:matrix.org from any number of federated servers but matrix.org is still where that room &quot;lives&quot;.<p>If that understanding is correct, then IMO the answer is simply that the canonical timeline is what that server says it is.  Poorly connected users or those on other servers experiencing issues or delays with federation may temporarily see a different sequence of events but once everyone&#x27;s had a chance to sync back up the state should generally be what the primary server for the room saw it as.<p>Perhaps there should be some sort of flag for &quot;this message has been reordered during a resync&quot; that clients which initially had a different state due to whatever reason could store to make it clear what happened, and likewise if the central homeserver receives messages with a timestamp significantly off real time it could flag those messages as possibly having been received out of order while still displaying them in the order they were received.</div><br/></div></div><div id="42328498" class="c"><input type="checkbox" id="c-42328498" checked=""/><div class="controls bullet"><span class="by">mycall</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42324919">parent</a><span>|</span><a href="#42331804">prev</a><span>|</span><a href="#42325022">next</a><span>|</span><label class="collapse" for="c-42328498">[-]</label><label class="expand" for="c-42328498">[1 more]</label></div><br/><div class="children"><div class="content">Split-brain scenarios can be resolved using an odd number of nodes (or voters) to achieve a majority consensus to agree on the state of the system, stopping the services on the minority side to prevent conflicting operations. Once communication is restored, the stopped nodes can rejoin the cluster and synchronize their data.  Vector clocks are a great abstraction for ensuring correct ordering as well.</div><br/></div></div><div id="42325022" class="c"><input type="checkbox" id="c-42325022" checked=""/><div class="controls bullet"><span class="by">thomastay</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42324919">parent</a><span>|</span><a href="#42328498">prev</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42325022">[-]</label><label class="expand" for="c-42325022">[7 more]</label></div><br/><div class="children"><div class="content">yeah, having eventual consistency for messages across homeservers makes the work on the client harder. I guess they just have to accept that messages will &quot;appear in the past&quot; as you said.<p>But at least for messages sent within the same homeserver, I would think that those two apis should return the same data</div><br/><div id="42325324" class="c"><input type="checkbox" id="c-42325324" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325022">parent</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42325324">[-]</label><label class="expand" for="c-42325324">[6 more]</label></div><br/><div class="children"><div class="content">I think you basically want a partial order for federated chat: messages should arrive after the messages that cause them but not necessarily after messages that didn’t cause them. In the case of a network partition, this allows people on either side of the partition to continue communicating at the cost of non-determinism when the partition is resolved.</div><br/><div id="42325381" class="c"><input type="checkbox" id="c-42325381" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325324">parent</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42325381">[-]</label><label class="expand" for="c-42325381">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d maintain that an important property is for the system to be eventually consistent with regards to history. You don&#x27;t want a transient network event to potentially result in two users permanently seeing messages in a different order.</div><br/><div id="42325660" class="c"><input type="checkbox" id="c-42325660" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325381">parent</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42325660">[-]</label><label class="expand" for="c-42325660">[4 more]</label></div><br/><div class="children"><div class="content">I don’t think you can prevent that without centralizing on a single server</div><br/><div id="42326223" class="c"><input type="checkbox" id="c-42326223" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325660">parent</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42326223">[-]</label><label class="expand" for="c-42326223">[3 more]</label></div><br/><div class="children"><div class="content">You can, but it results in the situation the article is complaining about.<p>During a netsplit, people chatting on opposite sides of the netsplit continue to be able to chat (by design), but will (obviously) see a different history from each other. So when the netsplit heals, you have a dilemma: either you splice the history from the other side in, giving eventual consistency at the cost of changing the history that people have already read, or you keep permanently different histories on servers that were on one side or the other.</div><br/><div id="42334004" class="c"><input type="checkbox" id="c-42334004" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42326223">parent</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42334004">[-]</label><label class="expand" for="c-42334004">[2 more]</label></div><br/><div class="children"><div class="content">You could put the other side into something that looks visually like a thread. Each side will have a different history. They will also have a marker that says the history was split here and click here to view the other side.</div><br/><div id="42334339" class="c"><input type="checkbox" id="c-42334339" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42334004">parent</a><span>|</span><a href="#42325001">next</a><span>|</span><label class="collapse" for="c-42334339">[-]</label><label class="expand" for="c-42334339">[1 more]</label></div><br/><div class="children"><div class="content">If you can come up with a good design for what a client that does that should look like, and what information it would need from the server to do that, please do write it up and publicise it. I think ultimately something like that has to be the solution, but it would have to be actually fleshed out into something that&#x27;s possible to implement.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42325001" class="c"><input type="checkbox" id="c-42325001" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42324919">parent</a><span>|</span><a href="#42325022">prev</a><span>|</span><a href="#42324970">next</a><span>|</span><label class="collapse" for="c-42325001">[-]</label><label class="expand" for="c-42325001">[9 more]</label></div><br/><div class="children"><div class="content">That makes the problem harder, but not impossible.</div><br/><div id="42325153" class="c"><input type="checkbox" id="c-42325153" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325001">parent</a><span>|</span><a href="#42325044">next</a><span>|</span><label class="collapse" for="c-42325153">[-]</label><label class="expand" for="c-42325153">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure this is actually impossible in a distributed system with independent operation, and if it were possible, it would be terrible UI anyway.<p>Problem one is if you want to order events chronologically, you need to precisely decide what the time of the event means. Probably not the time the client hit send, because you can only measure that on the client and client clocks are at best approximately accurate. You could consider the time the server received it, and assume your server times are accurate, but that&#x27;s still problematic because even in a well functioning system, if a user sends message A to server.wdc around the same time as a user sends message B to server.lax, users connected to server.wdc will get A then B, and users connected to server.lax will get B then A, and this leads to problem two:<p>Problem two is messages generally display in order of receipt. If you get a message that slots in earlier in the thread, you may need to scroll up to see it. In a busy theead, it&#x27;s going to be hard to read all the messages because of the back and forth. If you send a message, it may need to be reordered too. If you go back to the thread later, new messages may be in different places. This is <i>more</i> disorienting IMHO than different message orders for different viewers.<p>Problem two gets even worse when you don&#x27;t just have distance between servers, but also some network or other operational issues. If a server accepts a message, but is unable to forward it immediately, you probably want it to forward it whenever it can... if there&#x27;s a significant delay, now the message is again going to be displayed in a place where it&#x27;s difficult to see.<p>You can kind solve this by forcing messages to a group to go through a single queue which forces an ordering, but that makes accepting messages for a group a lot more difficult.</div><br/><div id="42336711" class="c"><input type="checkbox" id="c-42336711" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325153">parent</a><span>|</span><a href="#42327342">next</a><span>|</span><label class="collapse" for="c-42336711">[-]</label><label class="expand" for="c-42336711">[1 more]</label></div><br/><div class="children"><div class="content">Give up on the idea of &quot;the timestamp&quot; of an event. There is no such thing. Clocks are unreliable, and even if every clock in a system is perfectly in-sync (via atomic transponders or whatever) they&#x27;re still subject to speed-of-light discrepancies that make it impossible to define &quot;the time&quot; of any event.<p>Two nodes separated by 10000km require ~33ms to send information in one direction, and ~66ms to do a roundtrip. Send X=1 to node=A from a client that&#x27;s 5ms away from A at client-local time T1, and then send X=2 to node=B from a client that&#x27;s 4ms away from B at client-local time T1-1ms -- when were these values sent, and what is the value of X? There is no answer, X is both 1 and 2, depending on when and who you ask.<p>You can define a leader node C, which receives updates from child nodes A and B, and that leader node can serialize updates in a way that produces a single linearizable sequence of updates, sure. But then that sequence of updates as defined by C needs to be propagated to child nodes A and B, which takes (let&#x27;s say) 66ms round-trip minimum. So when your client sends X=1 to node=A, it has to wait for at least 66ms before it can make a correct read from that same node -- X may actually be 2!<p>Logical ordering of events in a distributed system is a solved problem. The solution is vector clocks (or something like them).</div><br/></div></div><div id="42327342" class="c"><input type="checkbox" id="c-42327342" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325153">parent</a><span>|</span><a href="#42336711">prev</a><span>|</span><a href="#42326062">next</a><span>|</span><label class="collapse" for="c-42327342">[-]</label><label class="expand" for="c-42327342">[1 more]</label></div><br/><div class="children"><div class="content">As long as the speed of light remains constant for all observers, who cares if everyone agrees on simultaneity? Distributed systems don&#x27;t need to know what <i>time</i> it is, just what <i>happened</i>.<p>Well known systems are implemented this way, and the UI is great, people barely even notice.</div><br/></div></div><div id="42326062" class="c"><input type="checkbox" id="c-42326062" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325153">parent</a><span>|</span><a href="#42327342">prev</a><span>|</span><a href="#42325634">next</a><span>|</span><label class="collapse" for="c-42326062">[-]</label><label class="expand" for="c-42326062">[1 more]</label></div><br/><div class="children"><div class="content">There are relatively straightforward decentralized consensus algorithms for ordering events if we assume cooperation. If we assume malicious peers, then we&#x27;re in the space of the byzantine generals problem, but there are solutions to that too.<p>Now there&#x27;s some property that you have to give up, for example an immutable ordering. You might think the message came in one order, then reconnect with the network and discover the order was flipped. So long as the UI can handle that an update, there are consensus algorithms that will deliver a consistent view even in the edge cases.<p>You don&#x27;t need a single timestamping queue.</div><br/></div></div><div id="42325634" class="c"><input type="checkbox" id="c-42325634" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325153">parent</a><span>|</span><a href="#42326062">prev</a><span>|</span><a href="#42325044">next</a><span>|</span><label class="collapse" for="c-42325634">[-]</label><label class="expand" for="c-42325634">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is more disorienting IMHO than different message orders for different viewers.<p>the parent post is arguing this is <i>less</i> disorienting, and I agree.</div><br/><div id="42329194" class="c"><input type="checkbox" id="c-42329194" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325634">parent</a><span>|</span><a href="#42325044">next</a><span>|</span><label class="collapse" for="c-42329194">[-]</label><label class="expand" for="c-42329194">[1 more]</label></div><br/><div class="children"><div class="content">I feel like when an important message comes in out of sequence, but you had already sent a response to the chat with what was visible at the time, it will be very confusing when that gets reordered.<p>Ex:<p>A@T0: User X is abusing our service, we should send them a sternly written letter.<p>B@T60: Yes, I&#x27;ll do it right away.<p>C@T2 (received later): No, we should just shadowban them.<p>When B sent their message, their intent was clear to them. But when they review their message after C&#x27;s message is received, if the display ordering is changed, the meaning of the communication has changed, and how can B show that sending the warning was reasonable when they clearly said they were going to shadowban the user. (Maybe this group should use something else with a guaranteed ordering to track abuse and response, but that&#x27;s a different question)<p>If C&#x27;s message is displayed earlier than B&#x27;s in some cases and not others, that makes for a confusing situation, but each person can look at their messages and easily see what they saw when they argue about a breakdown in communication in the aftermath.</div><br/></div></div></div></div></div></div><div id="42325044" class="c"><input type="checkbox" id="c-42325044" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325001">parent</a><span>|</span><a href="#42325153">prev</a><span>|</span><a href="#42324970">next</a><span>|</span><label class="collapse" for="c-42325044">[-]</label><label class="expand" for="c-42325044">[2 more]</label></div><br/><div class="children"><div class="content">It makes an incrementing message ID impossible.</div><br/><div id="42326076" class="c"><input type="checkbox" id="c-42326076" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42324874">root</a><span>|</span><a href="#42325044">parent</a><span>|</span><a href="#42324970">next</a><span>|</span><label class="collapse" for="c-42326076">[-]</label><label class="expand" for="c-42326076">[1 more]</label></div><br/><div class="children"><div class="content">Only if you&#x27;re not ok with eventual consistency and renumbering in the case of discovered conflicts or net splits.</div><br/></div></div></div></div></div></div></div></div><div id="42324970" class="c"><input type="checkbox" id="c-42324970" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42324874">parent</a><span>|</span><a href="#42324919">prev</a><span>|</span><a href="#42324911">next</a><span>|</span><label class="collapse" for="c-42324970">[-]</label><label class="expand" for="c-42324970">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s mysterious here? One ordering is dictated (arrival time), another left for the consideration of the server (likely allowing for stuff like pinned messages, etc, that break the strict ordering).<p>If a Matrix server allows to delete messages (by the poster or by a moderator), then increasing IDs with <i>no gaps</i> become impossible. If the server allows editing of existing messages, then a sequence with no gaps is not sufficient to reflect all changes. Ideally a server does not do either, but uses more messages to augment existing messages, or mark some as deleted; with that, a sequence with no gaps would suffice.</div><br/></div></div><div id="42324911" class="c"><input type="checkbox" id="c-42324911" checked=""/><div class="controls bullet"><span class="by">wkrp</span><span>|</span><a href="#42324874">parent</a><span>|</span><a href="#42324970">prev</a><span>|</span><a href="#42324899">next</a><span>|</span><label class="collapse" for="c-42324911">[-]</label><label class="expand" for="c-42324911">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;messages might be a legacy endpoint compared to a newer &#x2F;sync. I know Matrix has been working hard on their sliding sync api.</div><br/></div></div><div id="42324899" class="c"><input type="checkbox" id="c-42324899" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42324874">parent</a><span>|</span><a href="#42324911">prev</a><span>|</span><a href="#42324685">next</a><span>|</span><label class="collapse" for="c-42324899">[-]</label><label class="expand" for="c-42324899">[1 more]</label></div><br/><div class="children"><div class="content">Non-monotonic clocks?</div><br/></div></div></div></div><div id="42324685" class="c"><input type="checkbox" id="c-42324685" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42324874">prev</a><span>|</span><a href="#42324998">next</a><span>|</span><label class="collapse" for="c-42324685">[-]</label><label class="expand" for="c-42324685">[1 more]</label></div><br/><div class="children"><div class="content">In general we certainly want to be able to change things &quot;in the past&quot;. When there is unpleasant spam in a groupchat, you want a moderator to be able to remove or at least hide it, in a way that means people scrolling up won&#x27;t be exposed to it unless they explicitly want to. (You could argue for having the client deal with all of that, but I don&#x27;t think there&#x27;s much benefit).<p>And if, as in the example at the end, clients on different homeservers will inevitably see different views, then I don&#x27;t think always showing the same history to the same client, or clients on the same server, solves the &quot;gaslighting&quot; problem - if anything it could make it worse. Maybe clients should make it obvious when messages have been &quot;retconned&quot; into the scrollback, and maybe servers should have certain features to support that. But the idea of having a consistent linear timeline is one of those answers that&#x27;s clear, simple, and wrong.</div><br/></div></div><div id="42324998" class="c"><input type="checkbox" id="c-42324998" checked=""/><div class="controls bullet"><span class="by">throwaway14356</span><span>|</span><a href="#42324685">prev</a><span>|</span><a href="#42325406">next</a><span>|</span><label class="collapse" for="c-42324998">[-]</label><label class="expand" for="c-42324998">[1 more]</label></div><br/><div class="children"><div class="content">i had a hilarious argument with the significant other when my messages appeared a very lame response to messages i didn&#x27;t receive.<p>i think the mental model should be what is most useful in court. if a netsplit occurs the state of the room doesn&#x27;t exist anymore, conversation can continue but it should be a different room populated with working available clients. The main room can be restored and the missed convo can be a 3rd room</div><br/></div></div><div id="42325406" class="c"><input type="checkbox" id="c-42325406" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#42324998">prev</a><span>|</span><label class="collapse" for="c-42325406">[-]</label><label class="expand" for="c-42325406">[3 more]</label></div><br/><div class="children"><div class="content">This sounds like a pretty good use case for a consensus algorithm like Paxos or Raft</div><br/><div id="42325600" class="c"><input type="checkbox" id="c-42325600" checked=""/><div class="controls bullet"><span class="by">purpleidea</span><span>|</span><a href="#42325406">parent</a><span>|</span><a href="#42325598">next</a><span>|</span><label class="collapse" for="c-42325600">[-]</label><label class="expand" for="c-42325600">[1 more]</label></div><br/><div class="children"><div class="content">Those are CP which is impossible in a distributed messaging system where it has to obviously be AP. Otherwise you&#x27;d have to guarantee that everyone involved is always online (no partition) to make progress on sending messages!<p>I think I have this right anyways. (CAP theorem for anyone curious.)</div><br/></div></div><div id="42325598" class="c"><input type="checkbox" id="c-42325598" checked=""/><div class="controls bullet"><span class="by">evilotto</span><span>|</span><a href="#42325406">parent</a><span>|</span><a href="#42325600">prev</a><span>|</span><label class="collapse" for="c-42325598">[-]</label><label class="expand" for="c-42325598">[1 more]</label></div><br/><div class="children"><div class="content">I think the most important property to preserve is causality; that is, if a user sends a message B after they have read (i.e., received) a message A, then B should come after A for everyone, because B depends on A.  Basically use a Lamport clock.</div><br/></div></div></div></div></div></div></div></div></div></body></html>