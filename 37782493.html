<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696582867262" as="style"/><link rel="stylesheet" href="styles.css?v=1696582867262"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mazzo.li/posts/fast-pipes.html">How fast are Linux pipes anyway? (2022)</a> <span class="domain">(<a href="https://mazzo.li">mazzo.li</a>)</span></div><div class="subtext"><span>SEJeff</span> | <span>71 comments</span></div><br/><div><div id="37787151" class="c"><input type="checkbox" id="c-37787151" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#37785176">next</a><span>|</span><label class="collapse" for="c-37787151">[-]</label><label class="expand" for="c-37787151">[7 more]</label></div><br/><div class="children"><div class="content">So if I understand correctly, vmsplice is more of a mini shared memory mechanism between two processes, if used on both the reader and writer end simultaneously? Meaning both processes need to be exceptionally careful in when they read and write to the buffers and how it is returned after use. Hot, yet scary at the same time.<p>Other main takeaway, it’s a bit sad that the naive implementation everybody will write, is 20x slower than what is possible.<p>Exceptionally written article btw.</div><br/><div id="37787433" class="c"><input type="checkbox" id="c-37787433" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#37787151">parent</a><span>|</span><a href="#37785176">next</a><span>|</span><label class="collapse" for="c-37787433">[-]</label><label class="expand" for="c-37787433">[6 more]</label></div><br/><div class="children"><div class="content">And if you try to write the 20x faster version, your coworkers will think you are over-complicating and not being a team player.</div><br/><div id="37787623" class="c"><input type="checkbox" id="c-37787623" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#37787151">root</a><span>|</span><a href="#37787433">parent</a><span>|</span><a href="#37787965">next</a><span>|</span><label class="collapse" for="c-37787623">[-]</label><label class="expand" for="c-37787623">[1 more]</label></div><br/><div class="children"><div class="content">In the end they&#x27;ll just use a Lambda.</div><br/></div></div><div id="37787965" class="c"><input type="checkbox" id="c-37787965" checked=""/><div class="controls bullet"><span class="by">nikanj</span><span>|</span><a href="#37787151">root</a><span>|</span><a href="#37787433">parent</a><span>|</span><a href="#37787623">prev</a><span>|</span><a href="#37787621">next</a><span>|</span><label class="collapse" for="c-37787965">[-]</label><label class="expand" for="c-37787965">[2 more]</label></div><br/><div class="children"><div class="content">Your coworkers would prefer you splitting the thing into two microservices communicating over a REST api, aka the 200x slower version.</div><br/><div id="37788081" class="c"><input type="checkbox" id="c-37788081" checked=""/><div class="controls bullet"><span class="by">hgraves1991</span><span>|</span><a href="#37787151">root</a><span>|</span><a href="#37787965">parent</a><span>|</span><a href="#37787621">next</a><span>|</span><label class="collapse" for="c-37788081">[-]</label><label class="expand" for="c-37788081">[1 more]</label></div><br/><div class="children"><div class="content">We hate to see it</div><br/></div></div></div></div><div id="37787621" class="c"><input type="checkbox" id="c-37787621" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#37787151">root</a><span>|</span><a href="#37787433">parent</a><span>|</span><a href="#37787965">prev</a><span>|</span><a href="#37788190">next</a><span>|</span><label class="collapse" for="c-37787621">[-]</label><label class="expand" for="c-37787621">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. Good comments go a long way.</div><br/></div></div><div id="37788190" class="c"><input type="checkbox" id="c-37788190" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#37787151">root</a><span>|</span><a href="#37787433">parent</a><span>|</span><a href="#37787621">prev</a><span>|</span><a href="#37785176">next</a><span>|</span><label class="collapse" for="c-37788190">[-]</label><label class="expand" for="c-37788190">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s time to change your workplace, not everyone is meant to be petty&#x2F;incompetent.</div><br/></div></div></div></div></div></div><div id="37785176" class="c"><input type="checkbox" id="c-37785176" checked=""/><div class="controls bullet"><span class="by">jcrites</span><span>|</span><a href="#37787151">prev</a><span>|</span><a href="#37788370">next</a><span>|</span><label class="collapse" for="c-37785176">[-]</label><label class="expand" for="c-37785176">[4 more]</label></div><br/><div class="children"><div class="content">Are there good data handling libraries that provide abstractions over pipes, sockets, files, and memory and implement optimizations like these? I&#x27;d be interested in knowing if there are such libraries in C, C++, Rust, or other systems languages.<p>I wasn&#x27;t familiar with some of the APIs mentioned in the article like splice() and vmsplice(), so I wondered if there are libraries that I might use when building ~low-level applications that take advantage of these and related optimizations where possible automagically. (As another commenter mentioned: these APIs are hard to use and most programs don&#x27;t take advantage of them)<p>Do libraries like libuv, tokio, Netty handle this automatically on Linux? (From some brief research, it seems like probably they do)</div><br/><div id="37785821" class="c"><input type="checkbox" id="c-37785821" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37785176">parent</a><span>|</span><a href="#37785454">next</a><span>|</span><label class="collapse" for="c-37785821">[-]</label><label class="expand" for="c-37785821">[2 more]</label></div><br/><div class="children"><div class="content">This may go against the grain but this isn&#x27;t really worth abstracting over since it&#x27;s not portable. You&#x27;ll probably want to implement it by hand everywhere you need it.<p>Higher level code only uses them rarely because they&#x27;re pretty special purpose and they have to be specialized for Linux. If you&#x27;re shuffling data around without looking at it only on Linux, splice is useful. There&#x27;s not that many applications that have that property (something like say, TCP&#x2F;UDP proxies definitely need it - but your bog standard HTTP server? Not so much).<p>And if you are writing these apps then the buzzwords like &quot;zero copy&quot; come up often, and splice is one of the first results you&#x27;ll see.</div><br/><div id="37788173" class="c"><input type="checkbox" id="c-37788173" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#37785176">root</a><span>|</span><a href="#37785821">parent</a><span>|</span><a href="#37785454">next</a><span>|</span><label class="collapse" for="c-37788173">[-]</label><label class="expand" for="c-37788173">[1 more]</label></div><br/><div class="children"><div class="content">The main reason why people write abstractions over stuff like this is to make it portable. I&#x27;m sure there&#x27;s something similar to vmsplice on every relevant OS. The library can also fallback to write_read if you&#x27;re targeting some ancient platform</div><br/></div></div></div></div><div id="37785454" class="c"><input type="checkbox" id="c-37785454" checked=""/><div class="controls bullet"><span class="by">jeromegn</span><span>|</span><a href="#37785176">parent</a><span>|</span><a href="#37785821">prev</a><span>|</span><a href="#37788370">next</a><span>|</span><label class="collapse" for="c-37785454">[-]</label><label class="expand" for="c-37785454">[1 more]</label></div><br/><div class="children"><div class="content">There’s a crate for tokio, so it’s not automatic but might still be interesting: <a href="https:&#x2F;&#x2F;lib.rs&#x2F;crates&#x2F;tokio-splice" rel="nofollow noreferrer">https:&#x2F;&#x2F;lib.rs&#x2F;crates&#x2F;tokio-splice</a></div><br/></div></div></div></div><div id="37788370" class="c"><input type="checkbox" id="c-37788370" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#37785176">prev</a><span>|</span><a href="#37783448">next</a><span>|</span><label class="collapse" for="c-37788370">[-]</label><label class="expand" for="c-37788370">[2 more]</label></div><br/><div class="children"><div class="content">Why not simply use mmap judiciously in a program managed shared memory ring buffer? Then you can copy at roughly memory speed.</div><br/><div id="37788386" class="c"><input type="checkbox" id="c-37788386" checked=""/><div class="controls bullet"><span class="by">rostayob</span><span>|</span><a href="#37788370">parent</a><span>|</span><a href="#37783448">next</a><span>|</span><label class="collapse" for="c-37788386">[-]</label><label class="expand" for="c-37788386">[1 more]</label></div><br/><div class="children"><div class="content">This post is an excuse to explain VM concepts, rather than a tutorial, something I maybe could have made clearer.</div><br/></div></div></div></div><div id="37783448" class="c"><input type="checkbox" id="c-37783448" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#37788370">prev</a><span>|</span><a href="#37783611">next</a><span>|</span><label class="collapse" for="c-37783448">[-]</label><label class="expand" for="c-37783448">[18 more]</label></div><br/><div class="children"><div class="content">One surprising fact about Linux pipes I stumbled across 4 years ago is that using a pipe can create indeterministic behavior:<p><a href="https:&#x2F;&#x2F;www.gibney.org&#x2F;the_output_of_linux_pipes_can_be_indeter" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gibney.org&#x2F;the_output_of_linux_pipes_can_be_inde...</a></div><br/><div id="37783491" class="c"><input type="checkbox" id="c-37783491" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37784561">next</a><span>|</span><label class="collapse" for="c-37783491">[-]</label><label class="expand" for="c-37783491">[9 more]</label></div><br/><div class="children"><div class="content">Not surprising, the pipe you&#x27;ve created doesn&#x27;t transport any of the data you&#x27;ve echoed.<p><pre><code>    (echo red; echo green 1&gt;&amp;2) | echo blue
</code></pre>
This creates two subshells separated by the pipe | symbol.
A subshell is a child process of the current shell, and as such it inherits important properties of the current shell, notably including the open file descriptor table.<p>Since they are child processes, both subshells run concurrently, while their parent shell will simply wait() for all child processes to terminate. The order in which the childs get to run is to a large extent unpredictable, on a multi-core system they may run literally at the same time.<p>Now, before the subshells get to process their actual tasks, file redirections have to be performed. The left subshell gets its stdout redirected to the write end of the kernel pipe object that is &quot;created&quot; by the pipe symbol. Likewise, the right subshell gets stdin redirected to the read end of the pipe object.<p>The first subshell contains two processes (red and green) that run in sequence (&quot;;&quot;). &quot;Red&quot; is indeed printed to stdout and thus (because of the redirection) sent to the pipe. However, nothing is ever read out of the pipe: The only process that is connected to the read end of the pipe (&quot;echo blue&quot;) never reads anything, it is output only.<p>Unlike &quot;echo red&quot;, &quot;echo green &gt;&amp;2&quot; doesn&#x27;t have stdout connected to the pipe. Its stdout is redirected to whatever stderr is connected to. Here is the explanation what &quot;&gt;&amp;2&quot; (or equivalently, &quot;1&gt;&amp;2&quot;) means: For the execution of &quot;echo green&quot;, make stdout (1) point to the same object that stderr (2) points to. You can imagine it as being a simple assignment: <i>fd[1] = fd[2]</i>.<p>For &quot;echo blue&quot;, stdout isn&#x27;t explicitly redirected, so it gets run with stdout set to whatever it inherited from its parent shell, which is (probably) your terminal.<p>Seeing that both &quot;echo green&quot; and &quot;echo blue&quot; write directly to the same file (again, probably your terminal) we have a race -- who wins is basically a question of who gets scheduled to run first. For one reason or other, it seems that blue is more likely to win on your system. It might be due to the fact that the left subshell needs to finish the &quot;echo red&quot; first, which does print to the pipe, and that might introduce a delay &#x2F; a yield, or such.</div><br/><div id="37785557" class="c"><input type="checkbox" id="c-37785557" checked=""/><div class="controls bullet"><span class="by">tuatoru</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37783491">parent</a><span>|</span><a href="#37787190">next</a><span>|</span><label class="collapse" for="c-37785557">[-]</label><label class="expand" for="c-37785557">[3 more]</label></div><br/><div class="children"><div class="content">Thank you for taking the time to write this very detailed and lucid explanation.</div><br/><div id="37786904" class="c"><input type="checkbox" id="c-37786904" checked=""/><div class="controls bullet"><span class="by">jcrites</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37785557">parent</a><span>|</span><a href="#37787190">next</a><span>|</span><label class="collapse" for="c-37786904">[-]</label><label class="expand" for="c-37786904">[2 more]</label></div><br/><div class="children"><div class="content">For additional clarification, `echo` doesn’t read from stdin, so `… | echo xyz` doesn’t do what you probably assume. Try running `echo a | echo b` and you’ll see that only “b” is printed. That’s because `echo b` doesn’t read the “a” sent to it on stdin (and also doesn’t print it).<p>If you want a program to read from stdin and write to stdout, you can use the `cat`, e.g. `echo a | cat` will print “a”.<p>Lastly, be aware that `echo` is usually a shell builtin that functions like `print`. I’m not sure of all the ways that it might behave differently, but something to be aware of (that it’s not a child process like `cat`).</div><br/><div id="37787640" class="c"><input type="checkbox" id="c-37787640" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37786904">parent</a><span>|</span><a href="#37787190">next</a><span>|</span><label class="collapse" for="c-37787640">[-]</label><label class="expand" for="c-37787640">[1 more]</label></div><br/><div class="children"><div class="content">The way that shell builtins behave differently here is that SIGPIPE can take out the whole shell on the left side when echo is built-in.<p>When you &#x2F;bin&#x2F;echo red, then it&#x27;s a subprocess, and its parent shell continues on, so you <i>always</i> get green somewhere in the output.</div><br/></div></div></div></div></div></div><div id="37787190" class="c"><input type="checkbox" id="c-37787190" checked=""/><div class="controls bullet"><span class="by">rixed</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37783491">parent</a><span>|</span><a href="#37785557">prev</a><span>|</span><a href="#37786280">next</a><span>|</span><label class="collapse" for="c-37787190">[-]</label><label class="expand" for="c-37787190">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think your message (or others) does justice to the original blogpost.<p>Yes the pipe runs two subcommands in parallel but that is not why the blogpost is interesting (or its author surprised). It&#x27;s because &#x27;echo red&#x27; is supposed to <i>block</i>, thus introducing synchronization between the two branches of the pipe, yet it doesn&#x27;t!<p>And I must confess, when reading the command my first though was: &quot;Ok so that first echo will die with a SIGPIPE and stderr will be all about the broken pipe.&quot; And I was wrong, because of that small buffer.<p>I wonder what other unices do allow a write to a broken pipe to complete successfully?</div><br/><div id="37788294" class="c"><input type="checkbox" id="c-37788294" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37787190">parent</a><span>|</span><a href="#37787587">next</a><span>|</span><label class="collapse" for="c-37788294">[-]</label><label class="expand" for="c-37788294">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I noticed that only after finishing the work on my comment (which, strangely enough, is my most-upvoted comment ever). I had been under the impression that the command is a construction from a beginner trying to make sense of the shell, so I skipped over the blogpost too quickly.<p>But indeed the author wasn&#x27;t aware that readers and witers of the pipe aren&#x27;t fully synchronized because the buffer in between allows for some concurrency. My writeup wasn&#x27;t very explicit about that (at least not that writing to the pipe <i>can</i> block when the pipe is full) but I think it&#x27;s technically accurate and hope it can clear up some confusion -- a lot of readers probably do not understand well how the shell works.</div><br/></div></div><div id="37787587" class="c"><input type="checkbox" id="c-37787587" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37787190">parent</a><span>|</span><a href="#37788294">prev</a><span>|</span><a href="#37787522">next</a><span>|</span><label class="collapse" for="c-37787587">[-]</label><label class="expand" for="c-37787587">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s because &#x27;echo red&#x27; is supposed to <i>block</i>,<p>It is not actually supposed to block. Pipes block when they are full, but there&#x27;s not enough data here to fill a pipe buffer. When pipes are broken, SIGPIPE is sent to the writer. Pipes do not block just because nobody is reading from the read end--as long as the read end is still open somewhere, a process <i>could</i> read from it, and that is enough.<p>When you see &quot;blue&quot;, what happened is the left-hand side of the pipe got killed because the right-hand side already finished before &quot;echo red&quot;, which closed the read end completely, and then &quot;echo red&quot; got killed with SIGPIPE. That takes out &quot;echo green&quot; with it, because &quot;echo&quot; is a built-in, and so &quot;echo&quot; is not a subprocess. If you use &quot;&#x2F;bin&#x2F;echo red&quot; instead, then &quot;green&quot; will always be printed (because SIGPIPE is going to &#x2F;bin&#x2F;echo, and not the entire shell).<p>In other circumstances, the &quot;echo blue&quot; will never read stdin, but the kernel doesn&#x27;t know or care. As far as the kernel is concerned, &quot;echo blue&quot; <i>could possibly</i> read from stdin, as long as stdin is open.</div><br/></div></div><div id="37787522" class="c"><input type="checkbox" id="c-37787522" checked=""/><div class="controls bullet"><span class="by">thequux</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37787190">parent</a><span>|</span><a href="#37787587">prev</a><span>|</span><a href="#37786280">next</a><span>|</span><label class="collapse" for="c-37787522">[-]</label><label class="expand" for="c-37787522">[1 more]</label></div><br/><div class="children"><div class="content">The pipe isn&#x27;t broken, though; at least not until the second echo terminates. The kernel doesn&#x27;t know that echo will never read stdin, because echo is generally a very simple program that doesn&#x27;t bother closing unused file descriptors. Instead, the pipe is broken when there&#x27;s nothing with an open receiving end, i.e., when the rightmost echo process terminates. Until then, it&#x27;s just like any other pipe</div><br/></div></div></div></div><div id="37786280" class="c"><input type="checkbox" id="c-37786280" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37783491">parent</a><span>|</span><a href="#37787190">prev</a><span>|</span><a href="#37784561">next</a><span>|</span><label class="collapse" for="c-37786280">[-]</label><label class="expand" for="c-37786280">[1 more]</label></div><br/><div class="children"><div class="content">tl;dr Piped commands run in <i>parallel</i> not in <i>serial</i>.<p>(The data &quot;runs&quot; in serial.)</div><br/></div></div></div></div><div id="37784561" class="c"><input type="checkbox" id="c-37784561" checked=""/><div class="controls bullet"><span class="by">4death4</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37783491">prev</a><span>|</span><a href="#37784604">next</a><span>|</span><label class="collapse" for="c-37784561">[-]</label><label class="expand" for="c-37784561">[2 more]</label></div><br/><div class="children"><div class="content">That may have been surprising, but, if you think about it a little deeper, it makes perfect sense. Programs in a pipeline execute concurrently. If they didn’t, pipelines wouldn’t be useful. For instance a pipeline that downloads a tar file with curl and then untars it. If you wait for curl to finish before running tar, you run in to all sorts of problems. For instance, where do you store the intermediate tar file if it’s really large? Tar <i>needs</i> to run while curl is running to keep buffers small and make execution fast. The only control flow between pipeline programs is done via stdin and stdout. In your example program, you write to stderr so naturally that’s not part of the deterministic control flow.</div><br/><div id="37787461" class="c"><input type="checkbox" id="c-37787461" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37784561">parent</a><span>|</span><a href="#37784604">next</a><span>|</span><label class="collapse" for="c-37787461">[-]</label><label class="expand" for="c-37787461">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If they didn’t, pipelines wouldn’t be useful.<p>Pipes would still be a useful way to structure your program.  They would just be less useful.</div><br/></div></div></div></div><div id="37784604" class="c"><input type="checkbox" id="c-37784604" checked=""/><div class="controls bullet"><span class="by">xorcist</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37784561">prev</a><span>|</span><a href="#37786410">next</a><span>|</span><label class="collapse" for="c-37784604">[-]</label><label class="expand" for="c-37784604">[1 more]</label></div><br/><div class="children"><div class="content">It that surprising? What would you have guessed output would look like, and why? Perhaps that information would help straighten out any confusion.<p>The command, perhaps intentionally, looks unusual (any code reviewer would certainly be scratching their head):<p>There&#x27;s an &quot;echo red&quot; in there but it&#x27;s never sent anywhere (perhaps a joke with &quot;red herring&quot;?).<p>There&#x27;s an &quot;echo green&quot; sent to stderr, that will only be visible if it terminates before &quot;echo blue&quot;.<p>The exact order would be dependent on output buffering, which will depend on which time slice is sorted first, which will vary with number of cpus and their respective load. So yes, it will be indeterministic, but in the same way &quot;top&quot; is.</div><br/></div></div><div id="37786410" class="c"><input type="checkbox" id="c-37786410" checked=""/><div class="controls bullet"><span class="by">oldbbsnickname</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37784604">prev</a><span>|</span><a href="#37783592">next</a><span>|</span><label class="collapse" for="c-37786410">[-]</label><label class="expand" for="c-37786410">[1 more]</label></div><br/><div class="children"><div class="content">If one enjoys fast, 0-copy I&#x2F;O on Linux, here&#x27;s an article.[0]<p>PS: Precision of language to avoid confusion: &quot;Indeterministic&quot; is a philosophy term, while the CS term is &quot;nondeterministic&quot;.<p>0. <a href="https:&#x2F;&#x2F;blog.superpat.com&#x2F;zero-copy-in-linux-with-sendfile-and-splice" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.superpat.com&#x2F;zero-copy-in-linux-with-sendfile-a...</a></div><br/></div></div><div id="37783592" class="c"><input type="checkbox" id="c-37783592" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37786410">prev</a><span>|</span><a href="#37786046">next</a><span>|</span><label class="collapse" for="c-37783592">[-]</label><label class="expand" for="c-37783592">[1 more]</label></div><br/><div class="children"><div class="content">Are there cases where his causes real-world problems? Because to be honest this example seems rather artificial.</div><br/></div></div><div id="37786046" class="c"><input type="checkbox" id="c-37786046" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37783592">prev</a><span>|</span><a href="#37784876">next</a><span>|</span><label class="collapse" for="c-37786046">[-]</label><label class="expand" for="c-37786046">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m genuinely curious, how else could this work? It&#x27;s like spawning threads, it&#x27;s inherently indeterministic.</div><br/></div></div><div id="37784876" class="c"><input type="checkbox" id="c-37784876" checked=""/><div class="controls bullet"><span class="by">Racing0461</span><span>|</span><a href="#37783448">parent</a><span>|</span><a href="#37786046">prev</a><span>|</span><a href="#37783611">next</a><span>|</span><label class="collapse" for="c-37784876">[-]</label><label class="expand" for="c-37784876">[2 more]</label></div><br/><div class="children"><div class="content">Chatgpt was able to figure this out with a simple &quot;what does the following do&quot;. But it could also be a case of chatgpt being trained on your article.<p>&gt;&gt;&gt; Note: The ordering of &quot;green&quot; and &quot;blue&quot; in the output might vary because these streams (stdout and stderr) might be buffered differently by the shell or operating system. Most commonly, you will see the output as illustrated above.</div><br/><div id="37785995" class="c"><input type="checkbox" id="c-37785995" checked=""/><div class="controls bullet"><span class="by">leodag</span><span>|</span><a href="#37783448">root</a><span>|</span><a href="#37784876">parent</a><span>|</span><a href="#37783611">next</a><span>|</span><label class="collapse" for="c-37785995">[-]</label><label class="expand" for="c-37785995">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s wrong though, it&#x27;s got nothing to do with different buffering (which is usually done at the application level, by the way).</div><br/></div></div></div></div></div></div><div id="37783611" class="c"><input type="checkbox" id="c-37783611" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#37783448">prev</a><span>|</span><a href="#37783231">next</a><span>|</span><label class="collapse" for="c-37783611">[-]</label><label class="expand" for="c-37783611">[2 more]</label></div><br/><div class="children"><div class="content">(2022) Previous discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31592934">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31592934</a></div><br/><div id="37783881" class="c"><input type="checkbox" id="c-37783881" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37783611">parent</a><span>|</span><a href="#37783231">next</a><span>|</span><label class="collapse" for="c-37783881">[-]</label><label class="expand" for="c-37783881">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>How fast are Linux pipes anyway?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31592934">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31592934</a> - June 2022 (200 comments)</div><br/></div></div></div></div><div id="37783231" class="c"><input type="checkbox" id="c-37783231" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#37783611">prev</a><span>|</span><a href="#37787814">next</a><span>|</span><label class="collapse" for="c-37783231">[-]</label><label class="expand" for="c-37783231">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic article, I learned a lot despite pipes being a bread and butter user tool for me for a quarter century.</div><br/></div></div><div id="37787814" class="c"><input type="checkbox" id="c-37787814" checked=""/><div class="controls bullet"><span class="by">loondri</span><span>|</span><a href="#37783231">prev</a><span>|</span><a href="#37783954">next</a><span>|</span><label class="collapse" for="c-37787814">[-]</label><label class="expand" for="c-37787814">[4 more]</label></div><br/><div class="children"><div class="content">This article talks about making Linux pipes faster, but other methods like shared memory or message queues might still be quicker. For example, in systems that need to move a lot of data quickly, the extra steps with pipes could slow things down. Also, when many threads are sharing data, pipes might cause more problems than other methods. So, the improvements in the article might not help much in real-world situations where speed is crucial.</div><br/><div id="37788171" class="c"><input type="checkbox" id="c-37788171" checked=""/><div class="controls bullet"><span class="by">0d0a</span><span>|</span><a href="#37787814">parent</a><span>|</span><a href="#37788083">next</a><span>|</span><label class="collapse" for="c-37788171">[-]</label><label class="expand" for="c-37788171">[2 more]</label></div><br/><div class="children"><div class="content">Can you give some examples? When batching data, you benefit from picking something like io_uring. But for two-way communication, you still need to notify either side when data is ready (maybe you don&#x27;t want to consume cpu just polling), and it isn&#x27;t clear to me how those options handle that synchronization faster than pipes.</div><br/><div id="37788354" class="c"><input type="checkbox" id="c-37788354" checked=""/><div class="controls bullet"><span class="by">_trackno5</span><span>|</span><a href="#37787814">root</a><span>|</span><a href="#37788171">parent</a><span>|</span><a href="#37788083">next</a><span>|</span><label class="collapse" for="c-37788354">[-]</label><label class="expand" for="c-37788354">[1 more]</label></div><br/><div class="children"><div class="content">The main thing io_uring gives you is avoiding multiple syscalls.<p>With a pipe you can’t really avoid that. With a shared memory queue&#x2F;ring buffer you can write to the memory without any syscalls.<p>But you need to build synchronisation yourself (e.g., using semaphores for example). You don’t necessarily need to poll.</div><br/></div></div></div></div><div id="37788083" class="c"><input type="checkbox" id="c-37788083" checked=""/><div class="controls bullet"><span class="by">127</span><span>|</span><a href="#37787814">parent</a><span>|</span><a href="#37788171">prev</a><span>|</span><a href="#37783954">next</a><span>|</span><label class="collapse" for="c-37788083">[-]</label><label class="expand" for="c-37788083">[1 more]</label></div><br/><div class="children"><div class="content">Also the benefit of using a message queue library is that you don&#x27;t have to worry about multi-platform incompatibilities as much.</div><br/></div></div></div></div><div id="37783954" class="c"><input type="checkbox" id="c-37783954" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#37787814">prev</a><span>|</span><a href="#37786636">next</a><span>|</span><label class="collapse" for="c-37783954">[-]</label><label class="expand" for="c-37783954">[18 more]</label></div><br/><div class="children"><div class="content">TL;DR: Maximum pipe speed, assuming both programs are written as optimally as possible, is approximately the speed of what one core in your system can read&#x2F;write; this is because, essentially, the kernel maps the same physical memory page from one program&#x27;s stdout to the other&#x27;s stdin, thus making the operation a zerocopy (or a fast onecopy in slightly less optimal situations).<p>I&#x27;ve known this one for awhile, and it makes writing shell scripts that glue two (or more) things together with pipes to do extremely high performance operations both rewarding and hilarious. Certainly one of the most useful tools in the toolbox.</div><br/><div id="37784387" class="c"><input type="checkbox" id="c-37784387" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37783954">parent</a><span>|</span><a href="#37784374">next</a><span>|</span><label class="collapse" for="c-37784387">[-]</label><label class="expand" for="c-37784387">[3 more]</label></div><br/><div class="children"><div class="content">Pipes are zero copy only if you use splice or vmsplice. These linux specific syscalls are hard to use (particularly wmsplice) and the vast majority of programs and shell filters (with the notable exception of pv) don&#x27;t use them and pay for the cost of copying in and out of kernel memory.</div><br/><div id="37785421" class="c"><input type="checkbox" id="c-37785421" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784387">parent</a><span>|</span><a href="#37784374">next</a><span>|</span><label class="collapse" for="c-37785421">[-]</label><label class="expand" for="c-37785421">[2 more]</label></div><br/><div class="children"><div class="content">If you’re using Go it will automatically splice your reader&#x2F;writer when using io.Copy, etc</div><br/><div id="37788246" class="c"><input type="checkbox" id="c-37788246" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37785421">parent</a><span>|</span><a href="#37784374">next</a><span>|</span><label class="collapse" for="c-37788246">[-]</label><label class="expand" for="c-37788246">[1 more]</label></div><br/><div class="children"><div class="content">re: <a href="https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;net&#x2F;splice_linux.go" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;net&#x2F;splice_linux.go</a><p>very interesting, I didn&#x27;t know `io` was doing that on linux!</div><br/></div></div></div></div></div></div><div id="37784374" class="c"><input type="checkbox" id="c-37784374" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37783954">parent</a><span>|</span><a href="#37784387">prev</a><span>|</span><a href="#37784339">next</a><span>|</span><label class="collapse" for="c-37784374">[-]</label><label class="expand" for="c-37784374">[2 more]</label></div><br/><div class="children"><div class="content">AFAIK a severe limitation of pipes is that they can buffer only 64 KB &#x2F; 16 pages (on x86 Linux). Pretty sure it&#x27;s generally slower than core-to-memory bandwidth.</div><br/><div id="37784397" class="c"><input type="checkbox" id="c-37784397" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784374">parent</a><span>|</span><a href="#37784339">next</a><span>|</span><label class="collapse" for="c-37784397">[-]</label><label class="expand" for="c-37784397">[1 more]</label></div><br/><div class="children"><div class="content">64KB is the default, you can increase the buffer size using `fcntl`. You&#x27;re probably more limited by syscall overhead than anything</div><br/></div></div></div></div><div id="37784339" class="c"><input type="checkbox" id="c-37784339" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37783954">parent</a><span>|</span><a href="#37784374">prev</a><span>|</span><a href="#37784315">next</a><span>|</span><label class="collapse" for="c-37784339">[-]</label><label class="expand" for="c-37784339">[7 more]</label></div><br/><div class="children"><div class="content">This is why threads aren&#x27;t nearly as important as many programmers seem to think. Chances are, whatever application you&#x27;re building can be done in a cleaner way using pipes + processes or green&#x2F;user-space threads depending on the workload in question. It can be less <i>convenient</i>, but message passing is usually preferable to deadlock hell.</div><br/><div id="37784427" class="c"><input type="checkbox" id="c-37784427" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784339">parent</a><span>|</span><a href="#37787762">next</a><span>|</span><label class="collapse" for="c-37784427">[-]</label><label class="expand" for="c-37784427">[2 more]</label></div><br/><div class="children"><div class="content">Pipes are FIFO data buffers implemented in the kernel. For communication between threads of the same process, you can replace any pipe object by a userspace queue implementation protected by e.g. mutex + condition variable. It is functionally equivalent and has potential to be faster. And if you wrap all accesses in lock&#x2F;unlock pairs (without locking any other objects in between) there is no danger of introducing any more deadlocks compared to using kernel pipes.<p>Threads are an important structuring mechanism: You can assume that all your threads continue to run, or in the event of a crash, all your threads die.<p>Also, unidirectional pipes aren&#x27;t exactly sufficient for inter-process &#x2F; inter-thread synchronisation. They are ok for simple batch processing, but that&#x27;s about it.</div><br/><div id="37785188" class="c"><input type="checkbox" id="c-37785188" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784427">parent</a><span>|</span><a href="#37787762">next</a><span>|</span><label class="collapse" for="c-37785188">[-]</label><label class="expand" for="c-37785188">[1 more]</label></div><br/><div class="children"><div class="content">Incidentally you can use the exact same setup (plush mmap) for interprocess queues.<p>The advantage of threads is that you can pass pointers to your data through the queue, while that&#x27;s harder to do between processes and you have to resort to copying data in the queue instead.</div><br/></div></div></div></div><div id="37787762" class="c"><input type="checkbox" id="c-37787762" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784339">parent</a><span>|</span><a href="#37784427">prev</a><span>|</span><a href="#37784886">next</a><span>|</span><label class="collapse" for="c-37787762">[-]</label><label class="expand" for="c-37787762">[1 more]</label></div><br/><div class="children"><div class="content">The problems with pipes is that passing a message involves a kernel context switch, no matter how small the message is.<p>Passing a message in-process is orders of magnitude faster than passing a message out-of-process.</div><br/></div></div><div id="37784886" class="c"><input type="checkbox" id="c-37784886" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784339">parent</a><span>|</span><a href="#37787762">prev</a><span>|</span><a href="#37786045">next</a><span>|</span><label class="collapse" for="c-37784886">[-]</label><label class="expand" for="c-37784886">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is why threads aren&#x27;t nearly as important as many programmers seem to think. Chances are, whatever application you&#x27;re building can be done in a cleaner way using pipes + processes or green&#x2F;user-space threads depending on the workload in question.<p>I think you&#x27;re making wild claims based on putting up your overgeneralized strawman (i.e., &quot;threads aren&#x27;t nearly as important as many programmers seem to think&quot;) that afterwards you try to water down with weasel words (&quot;depending on the workload in question&quot;).<p>Threads are widely used because they bring most of the benefits of processes (concurrent control flow, and in multicore processors also performance) without the constraints and limitations they bring (exclusive memory space, slow creation, performance penalty caused by serialization in IPC, awkward API, etc).<p>In multithreaded apps, to get threads to communicate between each other all you need to do to  is point to the memory address of the object you instantiated. No serialization needed, no nothing. You simply cannot beat this in terms of &quot;clean way&quot; of doing things.<p>&gt; It can be less convenient, but (...)<p>That&#x27;s quite the euphemism, and overlooks why threads are largely preferred.</div><br/></div></div><div id="37786045" class="c"><input type="checkbox" id="c-37786045" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784339">parent</a><span>|</span><a href="#37784886">prev</a><span>|</span><a href="#37784399">next</a><span>|</span><label class="collapse" for="c-37786045">[-]</label><label class="expand" for="c-37786045">[1 more]</label></div><br/><div class="children"><div class="content">Like how Postfix works. That&#x27;s a fun architecture to look at. Multiple processes and file based queue. Meanwhile I panic if I don&#x27;t have PostgreSQL to save my data :&#x2F;</div><br/></div></div><div id="37784399" class="c"><input type="checkbox" id="c-37784399" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784339">parent</a><span>|</span><a href="#37786045">prev</a><span>|</span><a href="#37784315">next</a><span>|</span><label class="collapse" for="c-37784399">[-]</label><label class="expand" for="c-37784399">[1 more]</label></div><br/><div class="children"><div class="content">Message pass enough and you&#x27;ll easily deadlock as well.</div><br/></div></div></div></div><div id="37784315" class="c"><input type="checkbox" id="c-37784315" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37783954">parent</a><span>|</span><a href="#37784339">prev</a><span>|</span><a href="#37784108">next</a><span>|</span><label class="collapse" for="c-37784315">[-]</label><label class="expand" for="c-37784315">[2 more]</label></div><br/><div class="children"><div class="content">This is magic system stuff I don’t understand, does it have to go all the way up to the memory or will the caches save us from that trip?</div><br/><div id="37784689" class="c"><input type="checkbox" id="c-37784689" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784315">parent</a><span>|</span><a href="#37784108">next</a><span>|</span><label class="collapse" for="c-37784689">[-]</label><label class="expand" for="c-37784689">[1 more]</label></div><br/><div class="children"><div class="content">Depends entirely on the CPU architecture.<p>The most simple answer I can give is: yes, when its safe; when its not safe, that&#x27;s part of an entire category of meltdown&#x2F;spectre family exploits.</div><br/></div></div></div></div><div id="37784108" class="c"><input type="checkbox" id="c-37784108" checked=""/><div class="controls bullet"><span class="by">NortySpock</span><span>|</span><a href="#37783954">parent</a><span>|</span><a href="#37784315">prev</a><span>|</span><a href="#37787457">next</a><span>|</span><label class="collapse" for="c-37784108">[-]</label><label class="expand" for="c-37784108">[2 more]</label></div><br/><div class="children"><div class="content">I assume for heterogenous cores (power vs efficiency cores) it bottlenecks on the throughput of the slowest core?</div><br/><div id="37784642" class="c"><input type="checkbox" id="c-37784642" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#37783954">root</a><span>|</span><a href="#37784108">parent</a><span>|</span><a href="#37787457">next</a><span>|</span><label class="collapse" for="c-37784642">[-]</label><label class="expand" for="c-37784642">[1 more]</label></div><br/><div class="children"><div class="content">Surprisingly no. I&#x27;d expect similar performance.<p>In these designs, the actual memory controller that talks to the RAM is part of an internal fabric, and the fabric link between the core and the memory controller is (technically) your upper limit.<p>For both Intel and AMD, the size of the fabric link remains constant to the expected performance of the different cores, as the theoretical usage&#x2F;performance of the load&#x2F;store units remain otherwise constant in relation, no matter if it is a big core or a little core.<p>Also, notice: the maximum performance of load-store units is your actual upper limit, period. Some CPUs historically never achieved their maximum theoretical performance because the units were never engaged optimally; sometimes this is because some ports on the load&#x2F;store units are only accessible from certain instructions (often due to being reserved only for SIMD; this is why memcpy impls often use SSE&#x2F;AVX, just to exploit this fact).<p>That said, load-store performance usually approaches that core&#x27;s L2 theoretical maximum, which is greater than what any core generally can get out of its fabric link. Ergo, fabric link is often governing what you&#x27;re seeing in situations like this.<p>On Intel and AMD&#x27;s clusters, the memory controller serving their respective core cluster designs requires anywhere from 2 to 4 cores saturating their links to reach peak performance. Also, sibling threads on the same core will compete for access to that link, so it isn&#x27;t merely threads that get you there, but actual core saturation.<p>On a dummy benchmark like proposed in the linked article, the performance of a single process being piped to another process, either in the situation of &quot;both processes are actually on the same big core, simultaneously hyper-threading&quot;, or &quot;two sibling little cores in the same core cluster, being serviced by the same memory controller&quot;, the upper limit of performance should approximate optimal usage of memory bandwidth, but in some cases on some architectures this will actually approximate L3 bandwidth (a higher value).<p>Also, as a side note: little cores aren&#x27;t little. For a little bit more silicon usage, and a little bit less power usage, two little cores approximate one big core &#x2F;w two threads optimally executing, even in Intel&#x27;s surprisingly optimal small core design, but <i>very</i> much true in Zen4c. As in, I could buy a &quot;whoops, all little cores&quot; CPU of sufficient size for my desktop, and still be happy (or, possibly, even happier).</div><br/></div></div></div></div></div></div><div id="37786636" class="c"><input type="checkbox" id="c-37786636" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#37783954">prev</a><span>|</span><a href="#37785040">next</a><span>|</span><label class="collapse" for="c-37786636">[-]</label><label class="expand" for="c-37786636">[1 more]</label></div><br/><div class="children"><div class="content">pipes are great. is the other process on another cpu or another machine? honestly who cares.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nathants&#x2F;s4&#x2F;blob&#x2F;master&#x2F;examples&#x2F;nyc_taxi_bsv&#x2F;count_rides_by_date.sh">https:&#x2F;&#x2F;github.com&#x2F;nathants&#x2F;s4&#x2F;blob&#x2F;master&#x2F;examples&#x2F;nyc_taxi...</a></div><br/></div></div><div id="37785040" class="c"><input type="checkbox" id="c-37785040" checked=""/><div class="controls bullet"><span class="by">chris_armstrong</span><span>|</span><a href="#37786636">prev</a><span>|</span><a href="#37784500">next</a><span>|</span><label class="collapse" for="c-37785040">[-]</label><label class="expand" for="c-37785040">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely amazing, I know about page tables and the like but tying it to performance analysis with `perf` makes it clear how central it is to throughput</div><br/></div></div><div id="37784500" class="c"><input type="checkbox" id="c-37784500" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#37785040">prev</a><span>|</span><a href="#37783346">next</a><span>|</span><label class="collapse" for="c-37784500">[-]</label><label class="expand" for="c-37784500">[1 more]</label></div><br/><div class="children"><div class="content">Hah, nice article :) I remember fighting with Cygwin pipe implementations
to have decent performance from them. They are hella slower compared to Linux, but still usable, just tricky to pass data in&#x2F;out.</div><br/></div></div><div id="37783346" class="c"><input type="checkbox" id="c-37783346" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#37784500">prev</a><span>|</span><a href="#37783874">next</a><span>|</span><label class="collapse" for="c-37783346">[-]</label><label class="expand" for="c-37783346">[1 more]</label></div><br/><div class="children"><div class="content">Pipes are fast enough for iterating and composing cat sed awk cut grep uniq jq etc etc.</div><br/></div></div><div id="37783874" class="c"><input type="checkbox" id="c-37783874" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#37783346">prev</a><span>|</span><a href="#37784885">next</a><span>|</span><label class="collapse" for="c-37783874">[-]</label><label class="expand" for="c-37783874">[2 more]</label></div><br/><div class="children"><div class="content">How fast are they compared to raw memory throughput?<p>It&#x27;s interesting that memory mapping is so expensive. I&#x27;ve often wondered the price that everyone pays for multiple address spades. Is isolation really worth it?</div><br/><div id="37783944" class="c"><input type="checkbox" id="c-37783944" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#37783874">parent</a><span>|</span><a href="#37784885">next</a><span>|</span><label class="collapse" for="c-37783944">[-]</label><label class="expand" for="c-37783944">[1 more]</label></div><br/><div class="children"><div class="content">The relative performance cost of virtual memory was way higher in days past, but people considered it worth it for the increased system reliability.</div><br/></div></div></div></div><div id="37784885" class="c"><input type="checkbox" id="c-37784885" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37783874">prev</a><span>|</span><a href="#37786497">next</a><span>|</span><label class="collapse" for="c-37784885">[-]</label><label class="expand" for="c-37784885">[5 more]</label></div><br/><div class="children"><div class="content">Love the Edward Tuftian aesthetic of this site. Although above a certain viewport width I would imagine you want a `margin: 0 auto` to center the content block. On a 27&quot; display it is tough to read without resizing the window.</div><br/><div id="37785517" class="c"><input type="checkbox" id="c-37785517" checked=""/><div class="controls bullet"><span class="by">ldoughty</span><span>|</span><a href="#37784885">parent</a><span>|</span><a href="#37785735">next</a><span>|</span><label class="collapse" for="c-37785517">[-]</label><label class="expand" for="c-37785517">[3 more]</label></div><br/><div class="children"><div class="content">I have to agree... I really like the side-notes to get more details&#x2F;explanation. You can skip the side-notes to keep reading and stay on the main story, but get what normally would be included in parenthesis or otherwise as an in-line comment.... Best of both worlds here I think. If I actively maintained a blog, I&#x27;d probably steal this design! :-)</div><br/><div id="37786003" class="c"><input type="checkbox" id="c-37786003" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#37784885">root</a><span>|</span><a href="#37785517">parent</a><span>|</span><a href="#37785735">next</a><span>|</span><label class="collapse" for="c-37786003">[-]</label><label class="expand" for="c-37786003">[2 more]</label></div><br/><div class="children"><div class="content">Is there some standard css&#x2F;html way of pushing side notes or pics into the first column if viewing width is too small?<p>That would be the best of both worlds!</div><br/><div id="37786396" class="c"><input type="checkbox" id="c-37786396" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37784885">root</a><span>|</span><a href="#37786003">parent</a><span>|</span><a href="#37785735">next</a><span>|</span><label class="collapse" for="c-37786396">[-]</label><label class="expand" for="c-37786396">[1 more]</label></div><br/><div class="children"><div class="content">responsive design concepts would enable this</div><br/></div></div></div></div></div></div></div></div><div id="37786497" class="c"><input type="checkbox" id="c-37786497" checked=""/><div class="controls bullet"><span class="by">codercowmoo</span><span>|</span><a href="#37784885">prev</a><span>|</span><a href="#37783567">next</a><span>|</span><label class="collapse" for="c-37786497">[-]</label><label class="expand" for="c-37786497">[2 more]</label></div><br/><div class="children"><div class="content">Anyone see the stonks image hidden quite well behind the first table?<p>I could only see it because of my dark mode extension, otherwise I guarantee I wouldn&#x27;t have caught it.</div><br/></div></div><div id="37783567" class="c"><input type="checkbox" id="c-37783567" checked=""/><div class="controls bullet"><span class="by">sbjs</span><span>|</span><a href="#37786497">prev</a><span>|</span><label class="collapse" for="c-37783567">[-]</label><label class="expand" for="c-37783567">[1 more]</label></div><br/><div class="children"><div class="content">I remember using linux pipes for a shell-based irc client like 12 years ago. For most application uses, they&#x27;re plenty fast enough. Kinda wish I had the source code for that still.</div><br/></div></div></div></div></div></div></div></body></html>