<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1682672452493" as="style"/><link rel="stylesheet" href="styles.css?v=1682672452493"/><link rel="apple-touch-startup-image" href="https://png.pngtree.com/png-clipart/20210309/original/pngtree-a-squatting-tabby-cat-png-image_5803660.jpg"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://probablydance.com/2023/04/27/beautiful-branchless-binary-search/">Beautiful branchless binary search</a> <span class="domain">(<a href="https://probablydance.com">probablydance.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>65 comments</span></div><br/><div><div id="35738775" class="c"><input type="checkbox" id="c-35738775" checked=""/><div class="controls bullet"><span class="by">buybackoff</span><span>|</span><a href="#35738100">next</a><span>|</span><label class="collapse" for="c-35738775">[-]</label><label class="expand" for="c-35738775">[1 more]</label></div><br/><div class="children"><div class="content">Branchless or not in this case, it still touches memory in not so good pattern. I found that a significant speedup of a classic BS could be achieved by switching to vectorized search when the remaining range has a width of 3-4 SIMD lines (or maybe even a little more). The bounds of that range are likely already touched and in cache, then prefetching helps. It has high likelihood of finding the target on a single SIMD compare, then switch to linear search on small data that is already in L1. It gives 30-50% gain on 1K items array of integers, 10-25% on 1M items, depending on data distribution. Here is an example in C#: <a href="https:&#x2F;&#x2F;github.com&#x2F;Spreads&#x2F;Spreads&#x2F;blob&#x2F;main&#x2F;src&#x2F;Spreads.Core&#x2F;Algorithms&#x2F;VectorSearch.Specialized.tt#L69">https:&#x2F;&#x2F;github.com&#x2F;Spreads&#x2F;Spreads&#x2F;blob&#x2F;main&#x2F;src&#x2F;Spreads.Cor...</a></div><br/></div></div><div id="35738100" class="c"><input type="checkbox" id="c-35738100" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35738775">prev</a><span>|</span><a href="#35738299">next</a><span>|</span><label class="collapse" for="c-35738100">[-]</label><label class="expand" for="c-35738100">[9 more]</label></div><br/><div class="children"><div class="content">A cool related algorithm is <a href="https:&#x2F;&#x2F;algorithmica.org&#x2F;en&#x2F;eytzinger" rel="nofollow">https:&#x2F;&#x2F;algorithmica.org&#x2F;en&#x2F;eytzinger</a><p>In addition to being branchless, it also has better cache properties than a standard binary search tree.<p>If you&#x27;re doing a binary search in an array, you start in the middle, and then jump all the way to the midway point of one half, and so on. As a result, there&#x27;s a lot of distance between each read that you do in the array. Thus, each read is putting extra strain on the cache (or the reads won&#x27;t be cached).<p>The CPU cache performs much better if the values you want to read are close to each other. Enter the Eytzinger Binary Search. The idea is that, if you&#x27;re always going to be accessing the root of the tree, and then one of its two children--you should just put those children physically close to the root, so they&#x27;ll all be on the same cache line!</div><br/><div id="35738451" class="c"><input type="checkbox" id="c-35738451" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#35738100">parent</a><span>|</span><a href="#35738287">next</a><span>|</span><label class="collapse" for="c-35738451">[-]</label><label class="expand" for="c-35738451">[6 more]</label></div><br/><div class="children"><div class="content">Trying to figure this out myself. So cache line is 64 bytes. Ignoring pointers you can fit eight 8bit data&#x2F;key values, or sixteen 4bit data&#x2F;key values. Pointers are entirely implicit (thx user below)<p>This would save you 3 or 4 memory reads respectively.<p>The odds of this strategy helping past the first few layers seems unlikely. So for 100k elements binary tree, this should be a 21% or 31% performance improvement respectively. That’s 17 vs 14 and 17 vs 13 reads.<p>And this would not help much for string data values unless the strings are at most 8 characters long :-)<p>This same thinking can be used to optimize database queries. Given several table and index layouts how many 8kb disk reads will be needed in each case. Wish I could get a job doing that kind of design work!</div><br/><div id="35738646" class="c"><input type="checkbox" id="c-35738646" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#35738100">root</a><span>|</span><a href="#35738451">parent</a><span>|</span><a href="#35738474">next</a><span>|</span><label class="collapse" for="c-35738646">[-]</label><label class="expand" for="c-35738646">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t store data nodes, or pointers. You store the keys. If you need to store data, just store them at the same index in another array.<p>The pointers are <i>wholly implicit</i>. E.g. assuming you let the index 0 be empty, the left pointer for a node k is at 2k and the right node is at 2k+1.<p>In terms of benefit here, the main benefit appears to be that since you always know where the children will be, you can trade bandwidth for latency and trigger pre-fetching of the next step down before you&#x27;ve even decided if you&#x27;re going left or right.</div><br/><div id="35738793" class="c"><input type="checkbox" id="c-35738793" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#35738100">root</a><span>|</span><a href="#35738646">parent</a><span>|</span><a href="#35738949">next</a><span>|</span><label class="collapse" for="c-35738793">[-]</label><label class="expand" for="c-35738793">[1 more]</label></div><br/><div class="children"><div class="content">That’s what I meant re keys, but ya nice point about pointers. Forgetting details of my data structures classes. updated my post (used to count 1 bit per node for pointers)<p>Ya I agree re latency. In fact there’s no other option afaict. CPU always loads 64 bytes, just like Postgres always loads data in 8kb chunks (unless you compile Postgres to use different size)</div><br/></div></div><div id="35738949" class="c"><input type="checkbox" id="c-35738949" checked=""/><div class="controls bullet"><span class="by">WithinReason</span><span>|</span><a href="#35738100">root</a><span>|</span><a href="#35738646">parent</a><span>|</span><a href="#35738793">prev</a><span>|</span><a href="#35738474">next</a><span>|</span><label class="collapse" for="c-35738949">[-]</label><label class="expand" for="c-35738949">[1 more]</label></div><br/><div class="children"><div class="content">So binary search should actually not be binary but... octary?</div><br/></div></div></div></div><div id="35738474" class="c"><input type="checkbox" id="c-35738474" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#35738100">root</a><span>|</span><a href="#35738451">parent</a><span>|</span><a href="#35738646">prev</a><span>|</span><a href="#35738287">next</a><span>|</span><label class="collapse" for="c-35738474">[-]</label><label class="expand" for="c-35738474">[2 more]</label></div><br/><div class="children"><div class="content">The big advantage of the Eytzinger layout actually comes into play when your binary search <i>isn&#x27;t</i> branch-free.<p>In that case, the CPU will speculate loads reasonably far ahead, and because both choices tend to be in the same cacheline, this prefetch is rarely wasted.<p>In other words, the big win isn&#x27;t about reducing the number of cacheline fetched, it&#x27;s about reducing the effective latency of those fetches.<p>That said, using a similar layout with higher fan-out and SIMD ops doesn&#x27;t benefit from this effect and is probably still better.</div><br/><div id="35738840" class="c"><input type="checkbox" id="c-35738840" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#35738100">root</a><span>|</span><a href="#35738474">parent</a><span>|</span><a href="#35738287">next</a><span>|</span><label class="collapse" for="c-35738840">[-]</label><label class="expand" for="c-35738840">[1 more]</label></div><br/><div class="children"><div class="content">I think effective latency and reducing the number of cache lines is probably the exact same thing. The point is instead of fetching 5 cache lines to get to the 5th layer of the tree from memory, you fetch just 2 and access the mega root node via cache.</div><br/></div></div></div></div></div></div><div id="35738287" class="c"><input type="checkbox" id="c-35738287" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#35738100">parent</a><span>|</span><a href="#35738451">prev</a><span>|</span><a href="#35738561">next</a><span>|</span><label class="collapse" for="c-35738287">[-]</label><label class="expand" for="c-35738287">[1 more]</label></div><br/><div class="children"><div class="content">Do they publish if getting the tree&#x2F;array in shape initially or inserting an element is significantly different in speed to the plain sorted layout? The method is a nice read optimization and you&#x27;d need to check if it amortizes when sun together with the tree creation.</div><br/></div></div><div id="35738561" class="c"><input type="checkbox" id="c-35738561" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#35738100">parent</a><span>|</span><a href="#35738287">prev</a><span>|</span><a href="#35738299">next</a><span>|</span><label class="collapse" for="c-35738561">[-]</label><label class="expand" for="c-35738561">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that like storing a heap inside an array, with indices and values like this:<p><pre><code>    0: top of heap,
    1: left of top,
    2: right of top,
    3: left of left of top
    ...

?</code></pre></div><br/></div></div></div></div><div id="35738299" class="c"><input type="checkbox" id="c-35738299" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#35738100">prev</a><span>|</span><a href="#35738997">next</a><span>|</span><label class="collapse" for="c-35738299">[-]</label><label class="expand" for="c-35738299">[5 more]</label></div><br/><div class="children"><div class="content">Some information on the CMOV can be found on the Intel Optimization Reference Manual (<a href="https:&#x2F;&#x2F;cdrdv2-public.intel.com&#x2F;671488&#x2F;248966-046A-software-optimization-manual.pdf" rel="nofollow">https:&#x2F;&#x2F;cdrdv2-public.intel.com&#x2F;671488&#x2F;248966-046A-software-...</a>).<p>Torvalds was famously critical of it (<a href="https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;cmov.html);" rel="nofollow">https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;cmov.html);</a> part of the criticism is now moot though, due to low latencies on modern processors (it seems 1 cycle or less, although the instruction consumes internal flags).<p>His idea seems to be still applicable and consistent with Intel&#x27;s recommendation: make branches predictable, and only after, use CMOV for the remaining ones. His fundametnal assumption is that &quot;even if you were to know that something is unpredictable, it&#x27;s going to be very rare.&quot;.</div><br/><div id="35738345" class="c"><input type="checkbox" id="c-35738345" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35738299">parent</a><span>|</span><a href="#35738997">next</a><span>|</span><label class="collapse" for="c-35738345">[-]</label><label class="expand" for="c-35738345">[4 more]</label></div><br/><div class="children"><div class="content">This is one area where Profile-Guided Optimization (PGO) can help a lot! With PGO, you run your program on some sample input and it logs info like how many times each side of a branch was taken. From there, you can recompile your code. If the compiler sees that one side of the branch dominates, it can emit code to prioritize that branch. However if the branch counts are approximately even and the branch is hard to predict (n.b. this is technically distinct from having even branch counts), then the compiler can know that the CPU would have trouble predicting the branch, and can emit a cmov instruction instead.</div><br/><div id="35738413" class="c"><input type="checkbox" id="c-35738413" checked=""/><div class="controls bullet"><span class="by">berkut</span><span>|</span><a href="#35738299">root</a><span>|</span><a href="#35738345">parent</a><span>|</span><a href="#35738997">next</a><span>|</span><label class="collapse" for="c-35738413">[-]</label><label class="expand" for="c-35738413">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s mildly annoying there&#x27;s no (at least to my knowledge?) compiler hint like the &#x27;__builtin_expect&#x27; ones to tell compilers that the values are very unlikely going to be predictable with enough accuracy to allow the branch predictors to be useful in general, and to use a cmov instead of the traditional branching instructions because of this.</div><br/><div id="35738478" class="c"><input type="checkbox" id="c-35738478" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#35738299">root</a><span>|</span><a href="#35738413">parent</a><span>|</span><a href="#35738997">next</a><span>|</span><label class="collapse" for="c-35738478">[-]</label><label class="expand" for="c-35738478">[2 more]</label></div><br/><div class="children"><div class="content">clang has __builtin_unpredictable [0]<p>[0] <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LanguageExtensions.html#builtin-unpredictable" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;LanguageExtensions.html#builtin-...</a></div><br/><div id="35738484" class="c"><input type="checkbox" id="c-35738484" checked=""/><div class="controls bullet"><span class="by">berkut</span><span>|</span><a href="#35738299">root</a><span>|</span><a href="#35738478">parent</a><span>|</span><a href="#35738997">next</a><span>|</span><label class="collapse" for="c-35738484">[-]</label><label class="expand" for="c-35738484">[1 more]</label></div><br/><div class="children"><div class="content">Oooooh :)<p>Thanks!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35738997" class="c"><input type="checkbox" id="c-35738997" checked=""/><div class="controls bullet"><span class="by">Culonavirus</span><span>|</span><a href="#35738299">prev</a><span>|</span><a href="#35738147">next</a><span>|</span><label class="collapse" for="c-35738997">[-]</label><label class="expand" for="c-35738997">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Luckily that book is available to borrow online from the Internet Archive<p>Awesome. And sad that corpos want to ruin it.</div><br/></div></div><div id="35738147" class="c"><input type="checkbox" id="c-35738147" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#35738997">prev</a><span>|</span><a href="#35738737">next</a><span>|</span><label class="collapse" for="c-35738147">[-]</label><label class="expand" for="c-35738147">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Those spikes for std::lower_bound are on powers of two, where it is somehow much slower. I looked into it a little bit but can’t come up with an easy explanation<p>It’s been a long time since I looked into this, if I recall correctly binary search with close to power of 2 sized data is slower because of some interaction with the caches which causes the data to constantly have to be reloaded from memory.</div><br/><div id="35738297" class="c"><input type="checkbox" id="c-35738297" checked=""/><div class="controls bullet"><span class="by">coppsilgold</span><span>|</span><a href="#35738147">parent</a><span>|</span><a href="#35738577">next</a><span>|</span><label class="collapse" for="c-35738297">[-]</label><label class="expand" for="c-35738297">[1 more]</label></div><br/><div class="children"><div class="content">Cache associativity, conflict miss. When too many memory addresses 
 which are far apart map to the same cache lines while being used and reused in quick succession, causing cache evictions.<p>Scott Meyers had a very good talk which contained this information: &lt;<a href="https:&#x2F;&#x2F;youtu.be&#x2F;WDIkqP4JbkE?t=3614" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;WDIkqP4JbkE?t=3614</a>&gt;<p>This is an effect of access pattern rather than size, but some access patterns are dictated by size.</div><br/></div></div><div id="35738577" class="c"><input type="checkbox" id="c-35738577" checked=""/><div class="controls bullet"><span class="by">cocoflunchy</span><span>|</span><a href="#35738147">parent</a><span>|</span><a href="#35738297">prev</a><span>|</span><a href="#35738737">next</a><span>|</span><label class="collapse" for="c-35738577">[-]</label><label class="expand" for="c-35738577">[1 more]</label></div><br/><div class="children"><div class="content">I vaguely remembered reading something about this too. I think it&#x27;s a great use case for ChatGPT, I copy-pasted the blog post and asked: &quot;why could there be spikes for powers of 2?&quot;<p>&gt; The spikes in the performance for std::lower_bound at powers of 2 might be due to the nature of how binary search works and the specific implementation of std::lower_bound in the standard library.<p>&gt; Binary search works by continually halving the search space. When the size of the array is a power of 2, every subdivision during the binary search is a clean halving of the array. This could result in an idealized number of comparisons in theory.<p>&gt; However, in practice, modern CPU performance is heavily influenced by memory access patterns due to caching effects. When an array size is a power of 2, elements that are frequently compared may end up located at memory addresses that conflict in the CPU cache (a phenomenon known as &quot;cache aliasing&quot; or &quot;cache line collisions&quot;). The CPU cache works by storing data that is spatially and temporally close together, and it uses certain bits of the memory address to determine where in the cache to place that data.<p>&gt; When the size of the array is a power of 2, it&#x27;s more likely that two distinct memory locations will map to the same cache line, leading to cache eviction where one piece of data pushes out the other, causing a cache miss the next time that evicted location is accessed. This results in extra memory latency, slowing down the execution of the algorithm.<p>&gt; The performance spikes you see are likely a combination of these factors. While the algorithm is doing an optimal number of comparisons, the cache line collisions might be causing additional memory latency that slows down the overall performance.<p>&gt; This would also explain why the branchless binary search algorithm does not show the same performance spikes at powers of 2 - its memory access pattern is different and may not result in the same level of cache line collisions.</div><br/></div></div></div></div><div id="35738737" class="c"><input type="checkbox" id="c-35738737" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#35738147">prev</a><span>|</span><a href="#35738552">next</a><span>|</span><label class="collapse" for="c-35738737">[-]</label><label class="expand" for="c-35738737">[1 more]</label></div><br/><div class="children"><div class="content">The setup code to reduce the length to a 2-power can be avoided.
I&#x27;m curious how well the following code performs in comparison:<p><pre><code>    for (size_t length = end - begin; length != 0; length = (length + 1) &#x2F; 2)
    {
        size_t step = length &#x2F; 2;
        if (compare(begin[step], value))
            begin += step;
    }   
    return begin;
</code></pre>
For odd lengths like 5, this splits the array in an even part of length 2, and an odd part of length 3, and then searches either part with length 3. So again there is some redundancy for non-2-powers.<p>While this code is simpler, it does require an extra division and increment in each loop iteration, so presumably it performs a little worse.</div><br/></div></div><div id="35738552" class="c"><input type="checkbox" id="c-35738552" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#35738737">prev</a><span>|</span><a href="#35738823">next</a><span>|</span><label class="collapse" for="c-35738552">[-]</label><label class="expand" for="c-35738552">[9 more]</label></div><br/><div class="children"><div class="content">If being branchless is important property of the algorithm then it is better to enforce it. Or at least test for it. If his GCC version will get an update and it will stop producing assembly that he wants no-one will ever know.<p>Which brings us back to regular discussion: C ( and C++ ) does not match hardware anymore. There is no real control over important properties of generated code. Programmers need tools to control what they write. Plug and pray compilation is not a solid engineering approach.</div><br/><div id="35738943" class="c"><input type="checkbox" id="c-35738943" checked=""/><div class="controls bullet"><span class="by">Arnt</span><span>|</span><a href="#35738552">parent</a><span>|</span><a href="#35738677">next</a><span>|</span><label class="collapse" for="c-35738943">[-]</label><label class="expand" for="c-35738943">[1 more]</label></div><br/><div class="children"><div class="content">We lost that control when CPUs became increasingly multilayered and complicated, with 20-step pipelines, enough parallelism to run a hundred instructions at the same time, with micro-ops and microcode, with branch predictors good enough to unroll some loops completely. What programmer today understands the branch prediction logic used on production system? Well enough to understand what difference branchlessness makes?<p>And it doesn&#x27;t seem to hurt. I at least have both worked on systems where I can read and write assembly and on one where I can&#x27;t, and my &quot;need to control&quot; isn&#x27;t such that the lack of assembly knowledge makes a significant impact on my effectiveness on the latter platform.</div><br/></div></div><div id="35738677" class="c"><input type="checkbox" id="c-35738677" checked=""/><div class="controls bullet"><span class="by">TuringTest</span><span>|</span><a href="#35738552">parent</a><span>|</span><a href="#35738943">prev</a><span>|</span><a href="#35738633">next</a><span>|</span><label class="collapse" for="c-35738677">[-]</label><label class="expand" for="c-35738677">[2 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t C created to <i>avoid</i> matching hardware? I.e. not caring about word size, number of registers, instruction set, etc.<p>I thought the whole point of writing programs in C was originally being able to write portable software (and a portable OS) that could be executed at different machines? It only became specialized in giving machine-specific instructions when other languages took over.</div><br/><div id="35739004" class="c"><input type="checkbox" id="c-35739004" checked=""/><div class="controls bullet"><span class="by">mcv</span><span>|</span><a href="#35738552">root</a><span>|</span><a href="#35738677">parent</a><span>|</span><a href="#35738633">next</a><span>|</span><label class="collapse" for="c-35739004">[-]</label><label class="expand" for="c-35739004">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. I&#x27;d rather have a way that guarantees this algorithm to be branchless regardless of the compiler <i>and underlying hardware</i>. Although I suppose it depends on the underlying hardware whether or not being branchless offers any advantage at all.<p>Of course compilers should be optimising for the hardware they&#x27;re compiling for, but this article shows that can be very hit-and-miss.</div><br/></div></div></div></div><div id="35738633" class="c"><input type="checkbox" id="c-35738633" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35738552">parent</a><span>|</span><a href="#35738677">prev</a><span>|</span><a href="#35738629">next</a><span>|</span><label class="collapse" for="c-35738633">[-]</label><label class="expand" for="c-35738633">[4 more]</label></div><br/><div class="children"><div class="content">The myth that they match has been busted since at very least Pentium came to be.<p>A good read of Michael Abrash books explains that quite well, as does playing around Intel&#x27;s VTune.</div><br/><div id="35738794" class="c"><input type="checkbox" id="c-35738794" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#35738552">root</a><span>|</span><a href="#35738633">parent</a><span>|</span><a href="#35738709">next</a><span>|</span><label class="collapse" for="c-35738794">[-]</label><label class="expand" for="c-35738794">[2 more]</label></div><br/><div class="children"><div class="content">If that myth has been busted 20 years ago when I have started working close in time with Pentiums then HN crowd never got the memo.<p>Even right now i have two replies above yours that completely ignore the point of discussed article. Which is that algorithm is &#x27;branchless&#x27;.<p>PS. I agree with comment in this topic from &#x27;mgaunard&#x27; that algorithm should have been written as branchless explicitly.</div><br/><div id="35738885" class="c"><input type="checkbox" id="c-35738885" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35738552">root</a><span>|</span><a href="#35738794">parent</a><span>|</span><a href="#35738709">next</a><span>|</span><label class="collapse" for="c-35738885">[-]</label><label class="expand" for="c-35738885">[1 more]</label></div><br/><div class="children"><div class="content">HN crowd has never got the memo in many subjects, another one is how the game development culture differs from FOSS.</div><br/></div></div></div></div><div id="35738709" class="c"><input type="checkbox" id="c-35738709" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#35738552">root</a><span>|</span><a href="#35738633">parent</a><span>|</span><a href="#35738794">prev</a><span>|</span><a href="#35738629">next</a><span>|</span><label class="collapse" for="c-35738709">[-]</label><label class="expand" for="c-35738709">[1 more]</label></div><br/><div class="children"><div class="content">For those looking for it <a href="https:&#x2F;&#x2F;www.jagregory.com&#x2F;abrash-black-book" rel="nofollow">https:&#x2F;&#x2F;www.jagregory.com&#x2F;abrash-black-book</a><p>If some&#x2F;most of the actual tricks are not up to date (ahem) the whole book is filled with techniques, stories, concepts... It&#x27;s more than ever a Zen of optimization opus.<p>Can someone on HN close to him tell Michael Abrash, should he write again, whatever he wants, even gardening or vulkanstuff wrangling, he has guaranteed readers.</div><br/></div></div></div></div><div id="35738629" class="c"><input type="checkbox" id="c-35738629" checked=""/><div class="controls bullet"><span class="by">gsliepen</span><span>|</span><a href="#35738552">parent</a><span>|</span><a href="#35738633">prev</a><span>|</span><a href="#35738823">next</a><span>|</span><label class="collapse" for="c-35738629">[-]</label><label class="expand" for="c-35738629">[1 more]</label></div><br/><div class="children"><div class="content">What you gain is hardware independence. There is a lot of variation in CPUs, even if you stick with one vendor they will have in-order efficiency cores and out-of-order performance cores, and an algorithm optimized for one might not work as great on the other. I think it&#x27;s better if time is spent by compiler engineers to produce good assembly on all CPUs, instead of giving tools to programmers to optimize their code for one particular CPU.</div><br/></div></div></div></div><div id="35738823" class="c"><input type="checkbox" id="c-35738823" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#35738552">prev</a><span>|</span><a href="#35738082">next</a><span>|</span><label class="collapse" for="c-35738823">[-]</label><label class="expand" for="c-35738823">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug of my attempt at this: <a href="https:&#x2F;&#x2F;github.com&#x2F;ehrmann&#x2F;branchless-binary-search">https:&#x2F;&#x2F;github.com&#x2F;ehrmann&#x2F;branchless-binary-search</a></div><br/></div></div><div id="35738082" class="c"><input type="checkbox" id="c-35738082" checked=""/><div class="controls bullet"><span class="by">tuukkah</span><span>|</span><a href="#35738823">prev</a><span>|</span><a href="#35738715">next</a><span>|</span><label class="collapse" for="c-35738082">[-]</label><label class="expand" for="c-35738082">[1 more]</label></div><br/><div class="children"><div class="content">Another binary search called branchless: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23893366" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23893366</a></div><br/></div></div><div id="35738715" class="c"><input type="checkbox" id="c-35738715" checked=""/><div class="controls bullet"><span class="by">andreidd</span><span>|</span><a href="#35738082">prev</a><span>|</span><a href="#35738041">next</a><span>|</span><label class="collapse" for="c-35738715">[-]</label><label class="expand" for="c-35738715">[1 more]</label></div><br/><div class="children"><div class="content">Nice, but good luck debugging if cmp returns -1. This is C++ after all and there is no constraint&#x2F;concept to enforce the function to return bool. If you&#x27;re lucky you get a sign mismatch warning.</div><br/></div></div><div id="35738041" class="c"><input type="checkbox" id="c-35738041" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#35738715">prev</a><span>|</span><a href="#35738158">next</a><span>|</span><label class="collapse" for="c-35738041">[-]</label><label class="expand" for="c-35738041">[12 more]</label></div><br/><div class="children"><div class="content">Trusting the C++ compiler to emit a specific instruction for guaranteed performance - cute, but not realistic.</div><br/><div id="35738060" class="c"><input type="checkbox" id="c-35738060" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#35738041">parent</a><span>|</span><a href="#35738158">next</a><span>|</span><label class="collapse" for="c-35738060">[-]</label><label class="expand" for="c-35738060">[11 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is the instruction that makes the difference. Cmov is a branch either way.<p>Branches can be unpredictable and slow, no matter what instructions, (or tables, or whatever) are used to introduce the branch at question.<p>It is predictable nature of branching in this algo that makes the difference. Which makes me wonder...<p>EDIT: the cmov vs explicit branching story is a bit more complicated than just branch vs no branch.</div><br/><div id="35738115" class="c"><input type="checkbox" id="c-35738115" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738060">parent</a><span>|</span><a href="#35738158">next</a><span>|</span><label class="collapse" for="c-35738115">[-]</label><label class="expand" for="c-35738115">[10 more]</label></div><br/><div class="children"><div class="content">Cmov doesn&#x27;t branch. A branch refers specifically to the program counter ending up in more than one possible place after an instruction has executed. It is this behavior that mucks with the CPU state and slows everything down.<p>It&#x27;s true that the cmov instruction uses the CPU flags register (which I&#x27;m sure the CPU designers at Intel hate), but that doesn&#x27;t mean that it branches.<p>You can achieve the same effect as cmov by using bitwise operations and a subtraction, though it&#x27;d just be a few cycles slower--but it would be even more clear that it doesn&#x27;t branch.</div><br/><div id="35738285" class="c"><input type="checkbox" id="c-35738285" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738115">parent</a><span>|</span><a href="#35738178">next</a><span>|</span><label class="collapse" for="c-35738285">[-]</label><label class="expand" for="c-35738285">[1 more]</label></div><br/><div class="children"><div class="content">For the case of comparing integers, and you want to know if A - B &gt;= 0, you can take A - B, Arithmetic Shift Right 31 bits, then you have 0 if Greater Than or Equal and -1 if Less Than.  From there you can just AND that with your displacement.<p>Note that it&#x27;s not a comparison on A and B, it&#x27;s a comparison on A - B, which must not overflow.</div><br/></div></div><div id="35738178" class="c"><input type="checkbox" id="c-35738178" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738115">parent</a><span>|</span><a href="#35738285">prev</a><span>|</span><a href="#35738206">next</a><span>|</span><label class="collapse" for="c-35738178">[-]</label><label class="expand" for="c-35738178">[2 more]</label></div><br/><div class="children"><div class="content">Sure, it doesn&#x27;t change the PC. But it can introduce a branch indirectly, I.e. when there is a jump to an address MOVed by cmov.<p>Either way, it seems that the wisdom has change since the last time I wrote and read  assembly. Cmov used to be slow. It seems that the current answer is &quot;it depends&quot;.</div><br/><div id="35738226" class="c"><input type="checkbox" id="c-35738226" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738178">parent</a><span>|</span><a href="#35738206">next</a><span>|</span><label class="collapse" for="c-35738226">[-]</label><label class="expand" for="c-35738226">[1 more]</label></div><br/><div class="children"><div class="content">If what you&#x27;re saying is (roughly)<p><pre><code>        cmovne  rax, rdx
        jmp     rax
</code></pre>
that is, a cmov followed by an indirect jump to the address contained in rax, &quot;jmp rax&quot; is _always_ an indirect jump. It doesn&#x27;t matter whether rax was set via a conditional move instruction or not.</div><br/></div></div></div></div><div id="35738206" class="c"><input type="checkbox" id="c-35738206" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738115">parent</a><span>|</span><a href="#35738178">prev</a><span>|</span><a href="#35738158">next</a><span>|</span><label class="collapse" for="c-35738206">[-]</label><label class="expand" for="c-35738206">[6 more]</label></div><br/><div class="children"><div class="content">The main problem with branches in an algorithm like this is that they create a dependency, where not only do the future instructions depend on the possibly-mispredicted outcome of the previous instruction and need to get thrown out, but you may have started executing the wrong instructions.<p>A cmov doesn&#x27;t affect the instruction pointer, so that &#x27;executing the wrong instructions&#x27; condition is gone, but it still affects the output of all following instructions if they depend on the register it modifies. So you still have to worry about pipelined work being thrown away on a mispredict.<p>IMO, cmov was far more valuable back when it was new, because branches were more expensive then. IIRC it was added to x86 in something like the MMX or SSE1 era, so a very long time ago for very different processor architectures. It&#x27;s still a useful instruction category to have, if only because it lets you produce smaller code (and smaller code is usually faster), but I expect the value is less significant than it used to be.<p>Incidentally I am curious whether Linus&#x27;s position on cmov back in 2007 is one he still holds today, and whether his assertions hold up on a modern Intel or AMD CPU. <a href="https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;cmov.html" rel="nofollow">https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;cmov.html</a><p>I think the branchless search in this blog post is faster simply because the inner loop is much smaller. The observation that it sometimes does extra comparisons explains why it is slower for an expensive comparison operator, because the advantage of the smaller loop is gone. I don&#x27;t think it being &quot;branchless&quot; is terribly important in comparison. You could try to fudge an experiment to prove this by inserting extra instructions, but they would need to be ones that decode into actual executed uops, and you&#x27;d need to decide whether they should have dependencies or not.<p>In the bad old days when I got promoted to the programming team at a job they had me take a test, and one of the tasks was to write a transparent blit routine. The one I wrote was &quot;branchless&quot;, but because cmov intrinsics weren&#x27;t widely available I achieved this by using an array of pointers and selecting the array index based on the result of a comparison, something like:<p><pre><code>  unsigned char* src_dest[] = { src, dest };
  for (...; ...; src_dest[0]++, src_dest[1]++)
    *src_dest[1] = *src_dest[*src_dest[0] == transparent_value];
</code></pre>
the lead who reviewed the test had to come by and ask me to explain how it worked. Certainly, this was &quot;branchless&quot;, even without the presence of cmov, since it was just doing movs based on a 0&#x2F;1 produced by the comparison. But the actual source of the dependency here is the comparison, not a jmp or a cmov. The loop was faster than a branch on the CPUs of that era but these days it would probably be much slower.</div><br/><div id="35738559" class="c"><input type="checkbox" id="c-35738559" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738206">parent</a><span>|</span><a href="#35738262">next</a><span>|</span><label class="collapse" for="c-35738559">[-]</label><label class="expand" for="c-35738559">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IMO, cmov was far more valuable back when it was new, because branches were more expensive then.<p>Branches in general are cheaper now (since they are generally predicted better), but mispredicted branches are more expensive. They are similar in terms of cycles (IIRC Pentium 4 and Skylake are both typically around 20 cycles if you don&#x27;t get second-order effects tacked on), but you generally get a lot more done in those cycles on a newer CPU, so they are much more important than they used to be. And a binary search will, almost by definition, tend to have 50% mispredicted branches on the compare (i.e., entirely unpredictable, so no better than random chance).</div><br/></div></div><div id="35738262" class="c"><input type="checkbox" id="c-35738262" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738206">parent</a><span>|</span><a href="#35738559">prev</a><span>|</span><a href="#35738158">next</a><span>|</span><label class="collapse" for="c-35738262">[-]</label><label class="expand" for="c-35738262">[4 more]</label></div><br/><div class="children"><div class="content">For the given assembly from the blog post<p><pre><code>    loop:
        lea (%rdx,%rax,4),%rcx
        cmp (%rcx),%esi
        cmovg %rcx,%rdx
        shr %rax
        jne loop
</code></pre>
Here&#x27;s a simulated CPU trace on Intel skylake: <a href="https:&#x2F;&#x2F;uica.uops.info&#x2F;tmp&#x2F;2de9d862d05d482ebed576d7e3923b93_trace.html" rel="nofollow">https:&#x2F;&#x2F;uica.uops.info&#x2F;tmp&#x2F;2de9d862d05d482ebed576d7e3923b93_...</a><p>Note that this tracer makes the assumption that all memory loads are in cache (otherwise the memory lookup will dominate). So bear that in mind for this code, especially since memory reads will likely dominate the cost of a binary search.<p>Regardless, it appears that the cost of conditional move is not the source of bottleneck.</div><br/><div id="35738304" class="c"><input type="checkbox" id="c-35738304" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738262">parent</a><span>|</span><a href="#35738355">next</a><span>|</span><label class="collapse" for="c-35738304">[-]</label><label class="expand" for="c-35738304">[2 more]</label></div><br/><div class="children"><div class="content">How do you get such am image please?</div><br/><div id="35738352" class="c"><input type="checkbox" id="c-35738352" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738304">parent</a><span>|</span><a href="#35738355">next</a><span>|</span><label class="collapse" for="c-35738352">[-]</label><label class="expand" for="c-35738352">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;uops.info&#x2F;uiCA.html" rel="nofollow">https:&#x2F;&#x2F;uops.info&#x2F;uiCA.html</a> it&#x27;s really cool!!</div><br/></div></div></div></div><div id="35738355" class="c"><input type="checkbox" id="c-35738355" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#35738041">root</a><span>|</span><a href="#35738262">parent</a><span>|</span><a href="#35738304">prev</a><span>|</span><a href="#35738158">next</a><span>|</span><label class="collapse" for="c-35738355">[-]</label><label class="expand" for="c-35738355">[1 more]</label></div><br/><div class="children"><div class="content">Wow, the dispatch queue is so deep! The trace makes a lot of sense, thanks for sharing it. I must have been unclear if it sounded like I was saying cmov was a bottleneck - my argument is just that it&#x27;s not going to be especially faster than a branch in the general case.<p>Great point that memory reads are going to dominate a binary search - at that point the CPU will be spending a lot more time waiting for memory than it is spending executing your branches or cmovs.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="35738170" class="c"><input type="checkbox" id="c-35738170" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#35738158">prev</a><span>|</span><a href="#35737974">next</a><span>|</span><label class="collapse" for="c-35738170">[-]</label><label class="expand" for="c-35738170">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m all for supporting OSS, but the author having a tip button with &quot;recommended&quot; tips of 20 $ and 1,000 $ for people and business respectively is so laughable it took away from an otherwise good blog posts. Commercialisation of OSS 2.0 should be discouraged to this extend</div><br/><div id="35738247" class="c"><input type="checkbox" id="c-35738247" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#35738170">parent</a><span>|</span><a href="#35737974">next</a><span>|</span><label class="collapse" for="c-35738247">[-]</label><label class="expand" for="c-35738247">[1 more]</label></div><br/><div class="children"><div class="content">I bet it’s just for kicks, you’re reading way too much into this. This is just someone’s personal website and they’re experimenting with a donate button.</div><br/></div></div></div></div><div id="35737974" class="c"><input type="checkbox" id="c-35737974" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#35738170">prev</a><span>|</span><a href="#35738305">next</a><span>|</span><label class="collapse" for="c-35737974">[-]</label><label class="expand" for="c-35737974">[16 more]</label></div><br/><div class="children"><div class="content">Nice algorithm. I don&#x27;t agree that it is branchless however. Cmov is a branching instruction for sure. And it doesn&#x27;t really matter whether a branch can be well predicted. The reason you mainly want branchless code is for security reasons where a timing sidechannel could reveal information. Calling this algorithm branchless devalues the term into something meaningless.<p>Edit: Everybody in the comments is focusing on performance. For performance sensitive code the point is not that it&#x27;s branchless, the point is that it is fast, that some branchless code is faster than branching code is an implementation detail. During encryption the point is that it certain codepaths MUST be branchless.</div><br/><div id="35738013" class="c"><input type="checkbox" id="c-35738013" checked=""/><div class="controls bullet"><span class="by">berkut</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738547">next</a><span>|</span><label class="collapse" for="c-35738013">[-]</label><label class="expand" for="c-35738013">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;The reason you mainly want branchless code is for security reasons where a timing sidechannel could reveal information.&quot;<p>Erm, that likely depends on the industry you&#x27;re in?<p>In HPC, branchless algorithms are often needed to use wide architectures (SIMD &#x2F; GPUs) to their full capacity...</div><br/><div id="35738370" class="c"><input type="checkbox" id="c-35738370" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738013">parent</a><span>|</span><a href="#35738547">next</a><span>|</span><label class="collapse" for="c-35738370">[-]</label><label class="expand" for="c-35738370">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a requirement thing. For security the requirement is code needs to be branchless. In HPC the requirement is high performance, the branchless algorithm is an implementation detail. In fact branchless code is often much slower then the branching version.</div><br/><div id="35739012" class="c"><input type="checkbox" id="c-35739012" checked=""/><div class="controls bullet"><span class="by">Aissen</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738370">parent</a><span>|</span><a href="#35738547">next</a><span>|</span><label class="collapse" for="c-35739012">[-]</label><label class="expand" for="c-35739012">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t really want branchless in security. The requirement is constant-time and side-channel resistance. The branchless algorithm is an implementation detail.</div><br/></div></div></div></div></div></div><div id="35738547" class="c"><input type="checkbox" id="c-35738547" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738013">prev</a><span>|</span><a href="#35738026">next</a><span>|</span><label class="collapse" for="c-35738547">[-]</label><label class="expand" for="c-35738547">[2 more]</label></div><br/><div class="children"><div class="content">I just had it pointed out to me that CMOV can be simulated with subtraction and bitwise operators.<p>Specifically, subtraction, arithmetic shift right, and AND.  `((A-B) ASR 31) AND C`.  Your result is C if `A - B &lt; 0`, and your result is 0 if `A - B &gt;= 0`.</div><br/><div id="35738958" class="c"><input type="checkbox" id="c-35738958" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738547">parent</a><span>|</span><a href="#35738026">next</a><span>|</span><label class="collapse" for="c-35738958">[-]</label><label class="expand" for="c-35738958">[1 more]</label></div><br/><div class="children"><div class="content">In C, shifting signed integers is undefined behavior.</div><br/></div></div></div></div><div id="35738026" class="c"><input type="checkbox" id="c-35738026" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738547">prev</a><span>|</span><a href="#35738063">next</a><span>|</span><label class="collapse" for="c-35738026">[-]</label><label class="expand" for="c-35738026">[1 more]</label></div><br/><div class="children"><div class="content">Branchless algos (especially in the case where there truly are no explicit or implicit branches) is just as useful for performance purposes as it is for security. Having a branchless algo at hand is like being halfway to data-level parallelism either through SIMD or GPU.</div><br/></div></div><div id="35738063" class="c"><input type="checkbox" id="c-35738063" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738026">prev</a><span>|</span><a href="#35738216">next</a><span>|</span><label class="collapse" for="c-35738063">[-]</label><label class="expand" for="c-35738063">[1 more]</label></div><br/><div class="children"><div class="content">cmov (i.e. conditional move) doesn&#x27;t branch. By branch here, we mean &quot;at point at which the successor program counter value might be one of two locations.&quot; It&#x27;s true that this _does_ have security implications, however this is frequently used as a term of art by performance engineers (see <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=g-WPhYREFjk">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=g-WPhYREFjk</a> for example).<p>&gt; And it doesn&#x27;t really matter whether a branch can be well predicted.<p>I&#x27;m not so sure this is true. See <a href="https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2019&#x2F;10&#x2F;15&#x2F;mispredicted-branches-can-multiply-your-running-times&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2019&#x2F;10&#x2F;15&#x2F;mispredicted-branches-can-...</a> as an example.<p>A properly predicted branch can be _faster_ than a cmov instruction, however the important point is avoiding the branch mispredict. The fact that we&#x27;re using cmov is beside the point. We could achieve a similar effect by performing a subtraction and doing bitwise arithmetic to extract the sign bit (which, in effect, performs a comparison).</div><br/></div></div><div id="35738216" class="c"><input type="checkbox" id="c-35738216" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738063">prev</a><span>|</span><a href="#35738591">next</a><span>|</span><label class="collapse" for="c-35738216">[-]</label><label class="expand" for="c-35738216">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And it doesn&#x27;t really matter whether a branch can be well predicted<p>I guess we build branch predictors on our CPUs for fun?</div><br/></div></div><div id="35738591" class="c"><input type="checkbox" id="c-35738591" checked=""/><div class="controls bullet"><span class="by">frankreyes</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738216">prev</a><span>|</span><a href="#35738051">next</a><span>|</span><label class="collapse" for="c-35738591">[-]</label><label class="expand" for="c-35738591">[1 more]</label></div><br/><div class="children"><div class="content">Because in the context of security you associate &quot;branchless&quot; with the time it takes is always the same regardless of the data&#x2F;values, in order to mitigate a timing attack.<p>In this context, branchless means something different: the performance of the CPU is maximized for the given hardware, by not flushing the speculative execution of the CPU.</div><br/></div></div><div id="35738051" class="c"><input type="checkbox" id="c-35738051" checked=""/><div class="controls bullet"><span class="by">hmry</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738591">prev</a><span>|</span><a href="#35738053">next</a><span>|</span><label class="collapse" for="c-35738051">[-]</label><label class="expand" for="c-35738051">[1 more]</label></div><br/><div class="children"><div class="content">cmov doesn&#x27;t go through the branch predictor, and AFAIK it even loads both operands unconditionally every time before checking the condition. I see no reason to consider it a branch, and have never heard anybody else categorize it as one.</div><br/></div></div><div id="35738053" class="c"><input type="checkbox" id="c-35738053" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#35737974">parent</a><span>|</span><a href="#35738051">prev</a><span>|</span><a href="#35738305">next</a><span>|</span><label class="collapse" for="c-35738053">[-]</label><label class="expand" for="c-35738053">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The reason you mainly want branchless code is for security reasons<p>That just isn’t true.</div><br/><div id="35738128" class="c"><input type="checkbox" id="c-35738128" checked=""/><div class="controls bullet"><span class="by">latency-guy2</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738053">parent</a><span>|</span><a href="#35738305">next</a><span>|</span><label class="collapse" for="c-35738128">[-]</label><label class="expand" for="c-35738128">[4 more]</label></div><br/><div class="children"><div class="content">Which part isn&#x27;t true? I think the qualifier &#x27;mainly&#x27; definitely weakens the statement, but I&#x27;m struggling to think of how it could certainly be false statement.<p>This is certainly true for at minimum DDoS attacks, and I would absolutely consider that a security risk.</div><br/><div id="35738144" class="c"><input type="checkbox" id="c-35738144" checked=""/><div class="controls bullet"><span class="by">2102922286</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738128">parent</a><span>|</span><a href="#35738371">next</a><span>|</span><label class="collapse" for="c-35738144">[-]</label><label class="expand" for="c-35738144">[1 more]</label></div><br/><div class="children"><div class="content">When implementing cryptographic primitives, you want to avoid branching on secret values. The reason why is that the CPU&#x27;s branch predictor will attempt to predict the value that you&#x27;re branching on, and thus something about the values that you&#x27;re branching on gets revealed if you can see how long a CPU takes to run a task&#x2F;perform a function.<p>This is more than just a theoretical issue. These channel attacks have been demonstrated in practice, even if the victim CPU is running across the internet.</div><br/></div></div><div id="35738371" class="c"><input type="checkbox" id="c-35738371" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738128">parent</a><span>|</span><a href="#35738144">prev</a><span>|</span><a href="#35738305">next</a><span>|</span><label class="collapse" for="c-35738371">[-]</label><label class="expand" for="c-35738371">[2 more]</label></div><br/><div class="children"><div class="content">Branchless algos are all over the place outside of security.</div><br/><div id="35738392" class="c"><input type="checkbox" id="c-35738392" checked=""/><div class="controls bullet"><span class="by">latency-guy2</span><span>|</span><a href="#35737974">root</a><span>|</span><a href="#35738371">parent</a><span>|</span><a href="#35738305">next</a><span>|</span><label class="collapse" for="c-35738392">[-]</label><label class="expand" for="c-35738392">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t care, there&#x27;s a quote in the OP that this discussion is being limited to.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35738305" class="c"><input type="checkbox" id="c-35738305" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#35737974">prev</a><span>|</span><label class="collapse" for="c-35738305">[-]</label><label class="expand" for="c-35738305">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny how people struggle so much to write branchless code.<p>The code is clearly not branchless as written, and relies on non-trivial optimizations for it to happen.<p>Just write it correctly to begin with.</div><br/></div></div></div></div></div></div></div></body></html>