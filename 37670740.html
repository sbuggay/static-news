<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695805265369" as="style"/><link rel="stylesheet" href="styles.css?v=1695805265369"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nullprogram.com/blog/2023/09/27/">Arena allocator tips and tricks</a> <span class="domain">(<a href="https://nullprogram.com">nullprogram.com</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>21 comments</span></div><br/><div><div id="37671682" class="c"><input type="checkbox" id="c-37671682" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#37671166">next</a><span>|</span><label class="collapse" for="c-37671682">[-]</label><label class="expand" for="c-37671682">[1 more]</label></div><br/><div class="children"><div class="content">Zig has arena allocator in the standard library
<a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;heap&#x2F;arena_allocator.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;heap&#x2F;aren...</a></div><br/></div></div><div id="37671166" class="c"><input type="checkbox" id="c-37671166" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#37671682">prev</a><span>|</span><a href="#37671772">next</a><span>|</span><label class="collapse" for="c-37671166">[-]</label><label class="expand" for="c-37671166">[2 more]</label></div><br/><div class="children"><div class="content">A very old trick for running Lua in your PlayStation 2 game (where the PS2 is a machine with 32MB of RAM and no memory paging) is to hook Lua’s realloc function into the venerable Doug Lea’s Malloc (<a href="https:&#x2F;&#x2F;gee.cs.oswego.edu&#x2F;dl&#x2F;html&#x2F;malloc.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gee.cs.oswego.edu&#x2F;dl&#x2F;html&#x2F;malloc.html</a>) set up to run in arena mode (ONLY_MSPACES? It’s been a decade or two…). That way Lua can fragment the arena all it wants without making a mess of the rest of the tiny address space.</div><br/><div id="37671730" class="c"><input type="checkbox" id="c-37671730" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37671166">parent</a><span>|</span><a href="#37671772">next</a><span>|</span><label class="collapse" for="c-37671730">[-]</label><label class="expand" for="c-37671730">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; (where the PS2 is a machine with 32MB of RAM and no memory paging)</i><p>The PS2 hardware does have full support for memory paging (at least on the main cpu core). PS2 Linux makes full use of it.<p>But the default TLB configuration from the BIOS is just a single static 31MB page (the other 1MB is reserved for the BIOS) and the SDK doesn&#x27;t provide any tooling for dynamic pages.<p>And this is MIPS, so it&#x27;s a software managed TLB with 48 entries. I wouldn&#x27;t be surprised if some games did have dynamic paging, but they would need to provide their own TLB exception handler.</div><br/></div></div></div></div><div id="37671772" class="c"><input type="checkbox" id="c-37671772" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#37671166">prev</a><span>|</span><a href="#37671719">next</a><span>|</span><label class="collapse" for="c-37671772">[-]</label><label class="expand" for="c-37671772">[4 more]</label></div><br/><div class="children"><div class="content">Excellent article.<p>&gt; While you could make a big, global char[] array to back your arena, it’s technically not permitted (strict aliasing).<p>Aren&#x27;t char pointers&#x2F;arrays allowed to alias everything?<p>I used that technique in my programming language and its allocator. It&#x27;s freestanding so I couldn&#x27;t use malloc. I had to get memory from somewhere so I just statically allocated a big array of bytes. It worked perfectly but I do disable strict aliasing as a matter of course since in systems programming there&#x27;s aliasing everywhere.</div><br/><div id="37671966" class="c"><input type="checkbox" id="c-37671966" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37671772">parent</a><span>|</span><a href="#37671831">next</a><span>|</span><label class="collapse" for="c-37671966">[-]</label><label class="expand" for="c-37671966">[1 more]</label></div><br/><div class="children"><div class="content">char can alias everything, i.e. you can deference a char pointer with impunity, even if the actual dynamic type[1] of an object is a different type. The reverse is not true: if the dynamic type of an object is char, just by using the alias rules, you can&#x27;t deference it as an object of a different type.<p>In C++ you can just use placement new to change the dynamic type of (part of ) a char array (but beware of pointer provenance). In C is more complex: I don&#x27;t claim to understand this fully, but my understanding is you can&#x27;t change the type of a named object, but you should be able to change the type of anonymous memory (for example, what is allocated with malloc) by simply writing into it.<p>In practice at least GCC considers the full alias rules unimplementable and my understanding is that it uses a conservative model where every store can change the type of an object, and uses purely structural equivalence.<p>[1] of course most C implementations don&#x27;t actually track dynamic types at runtime.</div><br/></div></div><div id="37671831" class="c"><input type="checkbox" id="c-37671831" checked=""/><div class="controls bullet"><span class="by">dellorter</span><span>|</span><a href="#37671772">parent</a><span>|</span><a href="#37671966">prev</a><span>|</span><a href="#37671719">next</a><span>|</span><label class="collapse" for="c-37671831">[-]</label><label class="expand" for="c-37671831">[2 more]</label></div><br/><div class="children"><div class="content">If you overlay a struct in your buffer and derefrence a pointer to it you would be accessing something with a different type other than its declared type(char* as struct something *), so is strict aliasing violation<p>To do stay in the rules you could set up a void* to suitable region in a linkerscript</div><br/><div id="37672011" class="c"><input type="checkbox" id="c-37672011" checked=""/><div class="controls bullet"><span class="by">dkersten</span><span>|</span><a href="#37671772">root</a><span>|</span><a href="#37671831">parent</a><span>|</span><a href="#37671719">next</a><span>|</span><label class="collapse" for="c-37672011">[-]</label><label class="expand" for="c-37672011">[1 more]</label></div><br/><div class="children"><div class="content">char* is the one exception to strict aliasing, so it’s not a violation.<p>In C, from the standard (C11 6.5&#x2F;7):<p><pre><code>    An object shall have its stored value accessed only by an lvalue expression that has one of the following types:
    …
    a character type.
</code></pre>
In C++, from: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;reinterpret_cast" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;reinterpret_cast</a><p><pre><code>    Whenever an attempt is made to read or modify the stored value of an object of type DynamicType through a glvalue of type AliasedType, the behavior is undefined unless one of the following is true:
     …
    AliasedType is std::byte, (since C++17) char, or unsigned char: this permits examination of the object representation of any object as an array of bytes.</code></pre></div><br/></div></div></div></div></div></div><div id="37671719" class="c"><input type="checkbox" id="c-37671719" checked=""/><div class="controls bullet"><span class="by">bajsejohannes</span><span>|</span><a href="#37671772">prev</a><span>|</span><a href="#37671678">next</a><span>|</span><label class="collapse" for="c-37671719">[-]</label><label class="expand" for="c-37671719">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Typically arena lifetime is the whole program<p>Some other good cases for arenas are rendering of a frame in a video game and handling of a http request. The memory is contained within that context and short lived.</div><br/></div></div><div id="37671678" class="c"><input type="checkbox" id="c-37671678" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#37671719">prev</a><span>|</span><a href="#37670970">next</a><span>|</span><label class="collapse" for="c-37671678">[-]</label><label class="expand" for="c-37671678">[1 more]</label></div><br/><div class="children"><div class="content">I really like arena &#x2F; bump allocators, they&#x27;re really useful and powerful tools. I&#x27;ve been playing around lately with a Julia package that makes it relatively easy and safe to manage an arena <a href="https:&#x2F;&#x2F;github.com&#x2F;MasonProtter&#x2F;Bumper.jl">https:&#x2F;&#x2F;github.com&#x2F;MasonProtter&#x2F;Bumper.jl</a><p>The thread-safety and dynamic extent is something I&#x27;m particularly pleased about.</div><br/></div></div><div id="37670970" class="c"><input type="checkbox" id="c-37670970" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#37671678">prev</a><span>|</span><a href="#37671013">next</a><span>|</span><label class="collapse" for="c-37670970">[-]</label><label class="expand" for="c-37670970">[4 more]</label></div><br/><div class="children"><div class="content">Fantastic article! I have a project with a similar arena allocator, so I&#x27;ll definitely be taking some of these tricks. One thing my allocator does do is organize arenas into a linked list so that you can grow your size dynamically.
However I really like the article&#x27;s point that you&#x27;re always going to be living within _some_ memory budget, so you might as well allocate everything up front into a giant arena, and then divide the giant arena up into smaller arenas.<p>Also I&#x27;ve heard that you can save an instruction when checking if your allocator is full by subtracting from the top, and checking the zero flag. It seems to complicate alignment logic. Does that ever end up mattering?</div><br/><div id="37671103" class="c"><input type="checkbox" id="c-37671103" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#37670970">parent</a><span>|</span><a href="#37671377">next</a><span>|</span><label class="collapse" for="c-37671103">[-]</label><label class="expand" for="c-37671103">[1 more]</label></div><br/><div class="children"><div class="content">I would argue bumping down makes it even easier to reason about alignment.<p>Anyways, you can find a full article about up vs down at <a href="https:&#x2F;&#x2F;fitzgeraldnick.com&#x2F;2019&#x2F;11&#x2F;01&#x2F;always-bump-downwards.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;fitzgeraldnick.com&#x2F;2019&#x2F;11&#x2F;01&#x2F;always-bump-downwards....</a></div><br/></div></div><div id="37671377" class="c"><input type="checkbox" id="c-37671377" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#37670970">parent</a><span>|</span><a href="#37671103">prev</a><span>|</span><a href="#37671627">next</a><span>|</span><label class="collapse" for="c-37671377">[-]</label><label class="expand" for="c-37671377">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so you might as well allocate everything up front into a giant arena, and then divide the giant arena up into smaller arenas<p>However if you do this note how the article hints at this strategy needing a bit more code on Windows: Windows doesn&#x27;t do overcommit by default. If you do one big malloc Windows will grow the page file to ensure it can page that much memory in if you start writing to it. That&#x27;s fine if you allocate a couple megabytes, but if your area is gigabytes in size you want to call VirtualAlloc with MEM_RESERVE to get a big contiguous memory area, then call VirtualAlloc with MEM_COMMIT as needed on chunks you actually want to use.</div><br/></div></div><div id="37671627" class="c"><input type="checkbox" id="c-37671627" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37670970">parent</a><span>|</span><a href="#37671377">prev</a><span>|</span><a href="#37671013">next</a><span>|</span><label class="collapse" for="c-37671627">[-]</label><label class="expand" for="c-37671627">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However I really like the article&#x27;s point that you&#x27;re always going to be living within _some_ memory budget, so you might as well allocate everything up front into a giant arena, and then divide the giant arena up into smaller arenas.<p>That depends. If you’re running on e.g. a video game console where you’re the sole user of a block of pretty much all memory, go ahead. On a system with other things running, you generally don’t want to assume you can just take some amount of memory, even if it’s “just the free memory”, or even “I probably won’t use it so it will be overcommitted”. Changing system conditions and other system pressure are outside of your control and your reservation may prevent the system from doing its job effectively and prioritizing your application appropriately.</div><br/></div></div></div></div><div id="37671013" class="c"><input type="checkbox" id="c-37671013" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#37670970">prev</a><span>|</span><a href="#37671562">next</a><span>|</span><label class="collapse" for="c-37671013">[-]</label><label class="expand" for="c-37671013">[2 more]</label></div><br/><div class="children"><div class="content">This globally good, two remarks however:<p>&gt; you don’t need to write destructors<p>I think this is not accurate. Destructors are not deallocators, they are supposed to set the object field in an invalid state. Now truth is that both are often called together, e.g `delete`.<p>&gt; Typically arena lifetime is the whole program, so you don’t need to worry about freeing it<p>A technic I use is to increment a counter on `arena.alloc` and decrement it on `arena.dealloc`, and then free the memory (if it&#x27;s on the heap) accordingly.</div><br/><div id="37671176" class="c"><input type="checkbox" id="c-37671176" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#37671013">parent</a><span>|</span><a href="#37671562">next</a><span>|</span><label class="collapse" for="c-37671176">[-]</label><label class="expand" for="c-37671176">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; you don’t need to write destructors<p>&gt;<p>&gt; I think this is not accurate. Destructors are not<p>&gt; deallocators, they are supposed to set the object field in<p>&gt; an invalid state. Now truth is that both are often called<p>&gt; together, e.g `delete`.<p>If the object manages some resource other than memory, and if the object&#x27;s lifetime is intended to guard the resource, then a destructor is needed.<p>But if the object manages memory only, as is often the case, and all of that memory came from the arena, then you really don&#x27;t need to call any destructors.<p>This is the approach taken in one C++ [library][1] I&#x27;ve worked with, where objects represented scalar values to be used en masse for spreadsheet-like applications. In those applications (especially in 32-bit mode), being able to omit an allocator pointer and neglect a destructor call made things smaller and faster.<p>[1]: <a href="https:&#x2F;&#x2F;bloomberg.github.io&#x2F;bde-resources&#x2F;doxygen&#x2F;bde_api_prod&#x2F;group__bdld__datum.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;bloomberg.github.io&#x2F;bde-resources&#x2F;doxygen&#x2F;bde_api_pr...</a></div><br/></div></div></div></div><div id="37671562" class="c"><input type="checkbox" id="c-37671562" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37671013">prev</a><span>|</span><a href="#37671274">next</a><span>|</span><label class="collapse" for="c-37671562">[-]</label><label class="expand" for="c-37671562">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unsigned sizes are another historically common source of defects, and offer no practical advantages in return. Case in point exercise for the reader: Change each ptrdiff_t to size_t in alloc, find the defect that results, then fix it.<p>I know that it’s a different “kind” of defect, but none of the code has overflow checks even with ptrdiff_t…</div><br/></div></div><div id="37671274" class="c"><input type="checkbox" id="c-37671274" checked=""/><div class="controls bullet"><span class="by">yelnatz</span><span>|</span><a href="#37671562">prev</a><span>|</span><a href="#37671624">next</a><span>|</span><label class="collapse" for="c-37671274">[-]</label><label class="expand" for="c-37671274">[3 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t know these were called Arenas, this technique is prevalent in game development.</div><br/><div id="37671304" class="c"><input type="checkbox" id="c-37671304" checked=""/><div class="controls bullet"><span class="by">TickleSteve</span><span>|</span><a href="#37671274">parent</a><span>|</span><a href="#37671624">next</a><span>|</span><label class="collapse" for="c-37671304">[-]</label><label class="expand" for="c-37671304">[2 more]</label></div><br/><div class="children"><div class="content">also called a &quot;bump&quot; allocator... because all it does is bump a pointer.<p>nice to use when you have a nicely ordered order of execution where you are guaranteed to always come back to a known position where you can free the entire heap&#x2F;arena at once. (i.e. a typical main message handling loop).</div><br/><div id="37671900" class="c"><input type="checkbox" id="c-37671900" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#37671274">root</a><span>|</span><a href="#37671304">parent</a><span>|</span><a href="#37671624">next</a><span>|</span><label class="collapse" for="c-37671900">[-]</label><label class="expand" for="c-37671900">[1 more]</label></div><br/><div class="children"><div class="content">You can however use bump allocation for things that are not arenas. There are some GC allocators that use the technique.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>