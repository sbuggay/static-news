<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1682568400931" as="style"/><link rel="stylesheet" href="styles.css?v=1682568400931"/><link rel="apple-touch-startup-image" href="https://png.pngtree.com/png-clipart/20210309/original/pngtree-a-squatting-tabby-cat-png-image_5803660.jpg"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.eq8.eu/til/update-millions-of-records-in-rails.html">Update millions of records in Rails</a> <span class="domain">(<a href="https://blog.eq8.eu">blog.eq8.eu</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>39 comments</span></div><br/><div><div id="35718819" class="c"><input type="checkbox" id="c-35718819" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35719601">next</a><span>|</span><label class="collapse" for="c-35718819">[-]</label><label class="expand" for="c-35718819">[17 more]</label></div><br/><div class="children"><div class="content">This is the perfect time to drop down into the database and let the database handle it. If you&#x27;re doing mass migration of data, the data should not ever touch rails.<p>Also, this is another example of why normalizing your schemas is important - in a normalized schema, you would only have fiftyish state records, and a few tens of thousands of city records. (Yes, this is just an example, I&#x27;m sure they wouldn&#x27;t actually update city and state on every record this way, but it&#x27;s a useful example of why normalized data is easier to work with. Imagine if you missed a few records - now you have a random assortment of Cleveland, CLEVELAND, and cleveland, where if your schema were normalized with a constraint, you&#x27;d have one city_id pointing to Cleveland, OH)</div><br/><div id="35718908" class="c"><input type="checkbox" id="c-35718908" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#35718819">parent</a><span>|</span><a href="#35718962">next</a><span>|</span><label class="collapse" for="c-35718908">[-]</label><label class="expand" for="c-35718908">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Letting the database handle it&quot; for truly large tables can have some potentially tricky issues.<p>The most common I&#x27;ve seen relate to replication. If your database has replicas and uses row-based replication (as opposed to statement-based replication) running &quot;update huge_table set title = upper(title)&quot; could create a billion updated rows, which then need to be copied to all of those replicas. This can cause big problems.<p>In those cases, it&#x27;s better to update 1,000 rows at a time using some kind of batching mechanism, similar to the one described in the article.</div><br/><div id="35719763" class="c"><input type="checkbox" id="c-35719763" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35718908">parent</a><span>|</span><a href="#35718962">next</a><span>|</span><label class="collapse" for="c-35719763">[-]</label><label class="expand" for="c-35719763">[1 more]</label></div><br/><div class="children"><div class="content">I agree, but I would do the batching in the database rather than in a job, using something like a function that counts up or pg_sleep between queries with a subset of the range of existing rows.</div><br/></div></div></div></div><div id="35718962" class="c"><input type="checkbox" id="c-35718962" checked=""/><div class="controls bullet"><span class="by">hk1337</span><span>|</span><a href="#35718819">parent</a><span>|</span><a href="#35718908">prev</a><span>|</span><a href="#35718868">next</a><span>|</span><label class="collapse" for="c-35718962">[-]</label><label class="expand" for="c-35718962">[6 more]</label></div><br/><div class="children"><div class="content">Agreed. Rails uses ActiveRecord and you&#x27;ll most likely be trying to load millions of records through an ORM which will make you go insane trying to get it to work efficiently.<p>I have no problem with Rails or ActiveRecord but bulk upload of data through any ORM is a big no for me.</div><br/><div id="35719353" class="c"><input type="checkbox" id="c-35719353" checked=""/><div class="controls bullet"><span class="by">izietto</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35718962">parent</a><span>|</span><a href="#35718868">next</a><span>|</span><label class="collapse" for="c-35719353">[-]</label><label class="expand" for="c-35719353">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Rails uses ActiveRecord and you&#x27;ll most likely be trying to load millions of records through an ORM which will make you go insane trying to get it to work efficiently.<p>You just need to use batches (that `.in_batches` in the link), it&#x27;s an easy-peasy approach which is way more acceptable for your database than a single update of 500m records. I&#x27;ve been using it for years and it has never raised a single issue.</div><br/><div id="35719416" class="c"><input type="checkbox" id="c-35719416" checked=""/><div class="controls bullet"><span class="by">FrancoisBosun</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35719353">parent</a><span>|</span><a href="#35718868">next</a><span>|</span><label class="collapse" for="c-35719416">[-]</label><label class="expand" for="c-35719416">[4 more]</label></div><br/><div class="children"><div class="content">The downcasing in done in Ruby-land, thus the records had to be loaded in memory, on the worker. If the downcasing was done on the DB itself, then the records would not have needed to travel all the way to the worker, only to be discarded 200ms later. Better to run an UPDATE query direct against the DB instance, with IDs to control concurrency: UPDATE addresses SET city = lower(city), state = lower(state) WHERE id BETWEEN a AND b</div><br/><div id="35721047" class="c"><input type="checkbox" id="c-35721047" checked=""/><div class="controls bullet"><span class="by">revscat</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35719416">parent</a><span>|</span><a href="#35719842">next</a><span>|</span><label class="collapse" for="c-35721047">[-]</label><label class="expand" for="c-35721047">[2 more]</label></div><br/><div class="children"><div class="content">This is what the `in_batches` method already does. See [1], which is called by the `in_batches` method for update operations.<p>[1] <a href="https:&#x2F;&#x2F;api.rubyonrails.org&#x2F;classes&#x2F;ActiveRecord&#x2F;Relation.html#method-i-update_all" rel="nofollow">https:&#x2F;&#x2F;api.rubyonrails.org&#x2F;classes&#x2F;ActiveRecord&#x2F;Relation.ht...</a></div><br/><div id="35721337" class="c"><input type="checkbox" id="c-35721337" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35721047">parent</a><span>|</span><a href="#35719842">next</a><span>|</span><label class="collapse" for="c-35721337">[-]</label><label class="expand" for="c-35721337">[1 more]</label></div><br/><div class="children"><div class="content">You could <i>use</i> `in_batches` that way, but in the code from the article it looks like each call to `maximum`&#x2F;`minimum` is causing a round trip, plus the `map` inside `MyService` is loading each batch into memory.</div><br/></div></div></div></div><div id="35719842" class="c"><input type="checkbox" id="c-35719842" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35719416">parent</a><span>|</span><a href="#35721047">prev</a><span>|</span><a href="#35718868">next</a><span>|</span><label class="collapse" for="c-35719842">[-]</label><label class="expand" for="c-35719842">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, one of the first things I learned (Ruby 1.8) was that Ruby is slow.  If you can avoid creating a bunch of Ruby objects and push the logic into the database you&#x27;ll typically see performance gains.   The big exception was Mongo, where more &quot;advanced&quot; features got shoved off to the JS interpreter which was an expensive operation – at least until the &#x27;aggregation framework&#x27; became a thing.<p>Anyways.  Before blindly doing string manipulation with postgres make sure that all the locale stuff is set correctly.</div><br/></div></div></div></div></div></div></div></div><div id="35718868" class="c"><input type="checkbox" id="c-35718868" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#35718819">parent</a><span>|</span><a href="#35718962">prev</a><span>|</span><a href="#35720869">next</a><span>|</span><label class="collapse" for="c-35718868">[-]</label><label class="expand" for="c-35718868">[5 more]</label></div><br/><div class="children"><div class="content">Agreed. You could add&#x2F;apply them as rails migrations, too, that way the transformations exist as code and can be referenced&#x2F;seen in the future.</div><br/><div id="35719781" class="c"><input type="checkbox" id="c-35719781" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35718868">parent</a><span>|</span><a href="#35720869">next</a><span>|</span><label class="collapse" for="c-35719781">[-]</label><label class="expand" for="c-35719781">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a useful gem that creates a data_migrations directory (and associated table once run) for things like this, that are not changing the schema. I tend to write them as rake tasks with an `up` and `down` method if they are reversible. Also, hopefully, the migrations are idempotent and just do nothing if there are no affected records (though not all data changes are like that of course)</div><br/><div id="35719952" class="c"><input type="checkbox" id="c-35719952" checked=""/><div class="controls bullet"><span class="by">chao-</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35719781">parent</a><span>|</span><a href="#35720869">next</a><span>|</span><label class="collapse" for="c-35719952">[-]</label><label class="expand" for="c-35719952">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>There&#x27;s a useful gem that creates a data_migrations directory</i><p>Would you please share this useful gem&#x27;s name? I have hand-rolled some variety of this solution so many times that it feels like just a part of life, like doing the laundry. If a gem can do that setup for me, I would gladly use it.</div><br/><div id="35720511" class="c"><input type="checkbox" id="c-35720511" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35719952">parent</a><span>|</span><a href="#35720433">next</a><span>|</span><label class="collapse" for="c-35720511">[-]</label><label class="expand" for="c-35720511">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking of this one, I believe, but it&#x27;s pretty old:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;OffgridElectric&#x2F;rails-data-migrations">https:&#x2F;&#x2F;github.com&#x2F;OffgridElectric&#x2F;rails-data-migrations</a><p>This is maybe a more modern one I found:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ilyakatz&#x2F;data-migrate">https:&#x2F;&#x2F;github.com&#x2F;ilyakatz&#x2F;data-migrate</a></div><br/></div></div><div id="35720433" class="c"><input type="checkbox" id="c-35720433" checked=""/><div class="controls bullet"><span class="by">mrcb123</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35719952">parent</a><span>|</span><a href="#35720511">prev</a><span>|</span><a href="#35720869">next</a><span>|</span><label class="collapse" for="c-35720433">[-]</label><label class="expand" for="c-35720433">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;ilyakatz&#x2F;data-migrate">https:&#x2F;&#x2F;github.com&#x2F;ilyakatz&#x2F;data-migrate</a><p>and for seeding data <a href="https:&#x2F;&#x2F;github.com&#x2F;pboling&#x2F;seed_migration">https:&#x2F;&#x2F;github.com&#x2F;pboling&#x2F;seed_migration</a></div><br/></div></div></div></div></div></div></div></div><div id="35720869" class="c"><input type="checkbox" id="c-35720869" checked=""/><div class="controls bullet"><span class="by">itake</span><span>|</span><a href="#35718819">parent</a><span>|</span><a href="#35718868">prev</a><span>|</span><a href="#35719601">next</a><span>|</span><label class="collapse" for="c-35720869">[-]</label><label class="expand" for="c-35720869">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried this, but we ran into high CPU usage while the task was being run, causing other queries to time out or be delayed.<p>Is there a way to send low priority updates that wont interfere with other requests?</div><br/><div id="35721347" class="c"><input type="checkbox" id="c-35721347" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35720869">parent</a><span>|</span><a href="#35719601">next</a><span>|</span><label class="collapse" for="c-35721347">[-]</label><label class="expand" for="c-35721347">[2 more]</label></div><br/><div class="children"><div class="content">Depends on whether you have access to the underlying system - postgres queries run in processes per-query so you can renice the process, or you can do similar things in C with extensions.<p>But not out of the box or on something like RDS - then your best bet is to write a script or function that uses sleep or pg_sleep to wait between calls to the database - I tend to do it in the database itself by using `CREATE FUNCTION` to write it, but depending on your comfort with postgres it may be better to do it in  a scripting language or shell script (as in the parent article using a background job)</div><br/><div id="35722269" class="c"><input type="checkbox" id="c-35722269" checked=""/><div class="controls bullet"><span class="by">brasic</span><span>|</span><a href="#35718819">root</a><span>|</span><a href="#35721347">parent</a><span>|</span><a href="#35719601">next</a><span>|</span><label class="collapse" for="c-35722269">[-]</label><label class="expand" for="c-35722269">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; processes per-query
</code></pre>
Minor nit, this is probably what you meant but it’s process per _connection_.</div><br/></div></div></div></div></div></div></div></div><div id="35719601" class="c"><input type="checkbox" id="c-35719601" checked=""/><div class="controls bullet"><span class="by">jmuguy</span><span>|</span><a href="#35718819">prev</a><span>|</span><a href="#35719367">next</a><span>|</span><label class="collapse" for="c-35719601">[-]</label><label class="expand" for="c-35719601">[2 more]</label></div><br/><div class="children"><div class="content">We have a need to upsert millions of records in Rails on an ongoing basis (weekly).  Biggest problem we ran into was attempting to use Sidekiq and using too many workers each making smallish inserts.  You don&#x27;t run out of connections in that case - PG cannot handle that many parallel inserts into the same table(s).<p>After discussing with a friend that frequently works with large data sets, he suggested that single very large upserts&#x2F;inserts (50k to 100k) records would be handled much better by Postgresql, and they were.<p>Our final setup still has all those Sidekiq workers, but they dump the records as JSON blobs into Kafka.  From there a single consumer pulls them out and buffers.  Once it has 50k, it dumps them all in a single ActiveRecord Upsert.  Its been working very well for us for a while now.</div><br/><div id="35722124" class="c"><input type="checkbox" id="c-35722124" checked=""/><div class="controls bullet"><span class="by">mrj</span><span>|</span><a href="#35719601">parent</a><span>|</span><a href="#35719367">next</a><span>|</span><label class="collapse" for="c-35722124">[-]</label><label class="expand" for="c-35722124">[1 more]</label></div><br/><div class="children"><div class="content">Table partitions work well for this, too. You would do your mass import in a table that would be less likely to affect prod queries. After import, then change the temp table to extend the parent. After that it is used for queries against the parent.</div><br/></div></div></div></div><div id="35719367" class="c"><input type="checkbox" id="c-35719367" checked=""/><div class="controls bullet"><span class="by">albertgoeswoof</span><span>|</span><a href="#35719601">prev</a><span>|</span><a href="#35720453">next</a><span>|</span><label class="collapse" for="c-35719367">[-]</label><label class="expand" for="c-35719367">[3 more]</label></div><br/><div class="children"><div class="content">If you want to build scalable software, this is the only line you need from this blog post:<p>&gt; You need to schedule few thousand record samples and monitor how well&#x2F;bad will your worker perform<p>I find it staggering how many senior developers don’t know how to profile or performance test their software. Just throwing a few million rows into a local db and measuring your app performance is so basic, yet I’ve seen many teams not even consider this, and others farm it to a “QA”.</div><br/><div id="35719787" class="c"><input type="checkbox" id="c-35719787" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#35719367">parent</a><span>|</span><a href="#35720423">next</a><span>|</span><label class="collapse" for="c-35719787">[-]</label><label class="expand" for="c-35719787">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen two things that prompt this behavior:<p>- Fear of the database.  For some folks keeping the logic in the app which is fully under their control is comforting.  I find this to be common by folks who&#x27;ve been burnt by their db in the past.  It&#x27;s a lot easier to assert (quality) control over your own software.<p>- Difficulty in modeling data.  This is more tricky, but IMO separates code monkeys from developers.</div><br/></div></div><div id="35720423" class="c"><input type="checkbox" id="c-35720423" checked=""/><div class="controls bullet"><span class="by">what-no-tests</span><span>|</span><a href="#35719367">parent</a><span>|</span><a href="#35719787">prev</a><span>|</span><a href="#35720453">next</a><span>|</span><label class="collapse" for="c-35720423">[-]</label><label class="expand" for="c-35720423">[1 more]</label></div><br/><div class="children"><div class="content">Yes - often what once worked when the application only had a few hundred or thousand records doesn&#x27;t work anymore, now that it has millions of records.<p>Those milliseconds, N+1 queries, nested queries, large joins (owing to incongruence between logical data structure and how that data is stored on disk) and poorly-indexed tables combine into lots of sad times.</div><br/></div></div></div></div><div id="35720453" class="c"><input type="checkbox" id="c-35720453" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#35719367">prev</a><span>|</span><a href="#35719197">next</a><span>|</span><label class="collapse" for="c-35720453">[-]</label><label class="expand" for="c-35720453">[2 more]</label></div><br/><div class="children"><div class="content">Postgres has a built in function that converts strings into lowercase. Why not use that? This seems like an extremely convoluted way of performing the example task.<p>One could suppose that it&#x27;s just a contrived simple example to show the point, but the headline suggests otherwise.</div><br/><div id="35720768" class="c"><input type="checkbox" id="c-35720768" checked=""/><div class="controls bullet"><span class="by">stevebmark</span><span>|</span><a href="#35720453">parent</a><span>|</span><a href="#35719197">next</a><span>|</span><label class="collapse" for="c-35720768">[-]</label><label class="expand" for="c-35720768">[1 more]</label></div><br/><div class="children"><div class="content">The best part is the map that not only mutates its own arguments, but also mutates the arguments to the function, which all is in a &quot;service&quot; which has to be instantiated and then &quot;called.&quot; I really wish the Rails community would pick up best practices from other languages.</div><br/></div></div></div></div><div id="35719197" class="c"><input type="checkbox" id="c-35719197" checked=""/><div class="controls bullet"><span class="by">manv1</span><span>|</span><a href="#35720453">prev</a><span>|</span><a href="#35721387">next</a><span>|</span><label class="collapse" for="c-35719197">[-]</label><label class="expand" for="c-35719197">[2 more]</label></div><br/><div class="children"><div class="content">Really, a better solution might be to spew the results into another table and then schedule downtime and replace the original table (via rename or whatever).<p>It all depends on your database, which is why you need an actual DBA role on your team instead of just using your database like an abstract storage entity.</div><br/><div id="35720451" class="c"><input type="checkbox" id="c-35720451" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#35719197">parent</a><span>|</span><a href="#35721387">next</a><span>|</span><label class="collapse" for="c-35720451">[-]</label><label class="expand" for="c-35720451">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It all depends on your database, which is why you need an actual DBA role on your team instead of just using your database like an abstract storage entity.<p>People seem to be getting along alright without it, no?</div><br/></div></div></div></div><div id="35721387" class="c"><input type="checkbox" id="c-35721387" checked=""/><div class="controls bullet"><span class="by">gregors</span><span>|</span><a href="#35719197">prev</a><span>|</span><a href="#35719230">next</a><span>|</span><label class="collapse" for="c-35721387">[-]</label><label class="expand" for="c-35721387">[1 more]</label></div><br/><div class="children"><div class="content">kind of a tangent here, but I wish this would go out of style:<p>&gt;&gt;&gt; MyService.new.call(address_batch)<p>The call method doesn&#x27;t hold state past execution, so don&#x27;t instantiate a new object for no reason. Just call a static method.</div><br/></div></div><div id="35719230" class="c"><input type="checkbox" id="c-35719230" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#35721387">prev</a><span>|</span><a href="#35718281">next</a><span>|</span><label class="collapse" for="c-35719230">[-]</label><label class="expand" for="c-35719230">[1 more]</label></div><br/><div class="children"><div class="content">Cool, is the same applicable if I run mysql?</div><br/></div></div><div id="35718281" class="c"><input type="checkbox" id="c-35718281" checked=""/><div class="controls bullet"><span class="by">what-no-tests</span><span>|</span><a href="#35719230">prev</a><span>|</span><a href="#35720075">next</a><span>|</span><label class="collapse" for="c-35718281">[-]</label><label class="expand" for="c-35718281">[9 more]</label></div><br/><div class="children"><div class="content">Ooohh umm...no transaction?<p>WhenEVER I make an insert, update, or delete -- I always use a transaction.<p>That&#x27;s what we should always do, right?<p>Right?</div><br/><div id="35718597" class="c"><input type="checkbox" id="c-35718597" checked=""/><div class="controls bullet"><span class="by">chrisandchris</span><span>|</span><a href="#35718281">parent</a><span>|</span><a href="#35718752">next</a><span>|</span><label class="collapse" for="c-35718597">[-]</label><label class="expand" for="c-35718597">[3 more]</label></div><br/><div class="children"><div class="content">I think you really don&#x27;t want to keep a transaction &gt; 5 hours open.<p>&gt; For our setup&#x2F;task (just update few fields on a table) the process of probing different batch sizes &amp; Sidekiq thread numbers with couple of thousands&#x2F;millions records took about 5 hours [...]</div><br/><div id="35718849" class="c"><input type="checkbox" id="c-35718849" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35718281">root</a><span>|</span><a href="#35718597">parent</a><span>|</span><a href="#35722320">next</a><span>|</span><label class="collapse" for="c-35718849">[-]</label><label class="expand" for="c-35718849">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen transactions (pathologically) held open for <i>weeks</i> with no huge issues. Postgres is <i>amazing</i>. You&#x27;re 100% right that you should not do it though. Also little things like if you have more than some very large number of transactions while one transaction is open, things start to break down.</div><br/></div></div><div id="35722320" class="c"><input type="checkbox" id="c-35722320" checked=""/><div class="controls bullet"><span class="by">zzzeek</span><span>|</span><a href="#35718281">root</a><span>|</span><a href="#35718597">parent</a><span>|</span><a href="#35718849">prev</a><span>|</span><a href="#35718752">next</a><span>|</span><label class="collapse" for="c-35722320">[-]</label><label class="expand" for="c-35722320">[1 more]</label></div><br/><div class="children"><div class="content">you certainly dont want to autocommit every row at a time as depending on backend that will slow you down by a large margin.  this rails feature that runs a bulk update&#x2F;insert I would assume is certainly doing so within either a single tranasction, or a set of relatively few per-chunk transactions.</div><br/></div></div></div></div><div id="35718752" class="c"><input type="checkbox" id="c-35718752" checked=""/><div class="controls bullet"><span class="by">SkyPuncher</span><span>|</span><a href="#35718281">parent</a><span>|</span><a href="#35718597">prev</a><span>|</span><a href="#35718429">next</a><span>|</span><label class="collapse" for="c-35718752">[-]</label><label class="expand" for="c-35718752">[4 more]</label></div><br/><div class="children"><div class="content">Transactions are only necessary when the change is tightly coupled.<p>---<p>In this case, it&#x27;s okay for individual records to fail. They can either be manually processed, re-run, or root caused for failure and handled individually.</div><br/><div id="35719322" class="c"><input type="checkbox" id="c-35719322" checked=""/><div class="controls bullet"><span class="by">swe_dima</span><span>|</span><a href="#35718281">root</a><span>|</span><a href="#35718752">parent</a><span>|</span><a href="#35718429">next</a><span>|</span><label class="collapse" for="c-35719322">[-]</label><label class="expand" for="c-35719322">[3 more]</label></div><br/><div class="children"><div class="content">Groupping several updates inside a transaction actually makes it faster because database doesn&#x27;t have to &quot;commit&quot; changes for each one.
This has diminishing returns however, if too much data changes inside a transaction it can becomes slower due to memory issues.
So something like 1000-10000 updates per transaction is a sweet spot I think.</div><br/><div id="35722553" class="c"><input type="checkbox" id="c-35722553" checked=""/><div class="controls bullet"><span class="by">SkyPuncher</span><span>|</span><a href="#35718281">root</a><span>|</span><a href="#35719322">parent</a><span>|</span><a href="#35720383">next</a><span>|</span><label class="collapse" for="c-35722553">[-]</label><label class="expand" for="c-35722553">[1 more]</label></div><br/><div class="children"><div class="content">While you&#x27;re technically correct, it&#x27;s probably unlikely performance is going to matter for these types of mass updates. As long as performance isn&#x27;t atrocious, theres one-time updates will be &quot;fast enough&quot;.<p>Typically, these get run during off-peak hours. This running in 30 minutes vs 12 hours simply isn&#x27;t important.</div><br/></div></div><div id="35720383" class="c"><input type="checkbox" id="c-35720383" checked=""/><div class="controls bullet"><span class="by">what-no-tests</span><span>|</span><a href="#35718281">root</a><span>|</span><a href="#35719322">parent</a><span>|</span><a href="#35722553">prev</a><span>|</span><a href="#35718429">next</a><span>|</span><label class="collapse" for="c-35720383">[-]</label><label class="expand" for="c-35720383">[1 more]</label></div><br/><div class="children"><div class="content">THIS.<p>A lot of the work I do involves analyzing and improving Ruby applications&#x27; performance. Often, simply wrapping transactions around the database operations will help - without making other (often much needed) structural changes.</div><br/></div></div></div></div></div></div><div id="35718429" class="c"><input type="checkbox" id="c-35718429" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#35718281">parent</a><span>|</span><a href="#35718752">prev</a><span>|</span><a href="#35720075">next</a><span>|</span><label class="collapse" for="c-35718429">[-]</label><label class="expand" for="c-35718429">[1 more]</label></div><br/><div class="children"><div class="content">If you’re updating a single entity it doesn’t really matter. An exception is if you’re doing something like select for update in psql where you’re explicitly introducing locks. If you’re performing multiple operations simultaneously and want them all to go or die together, yes.</div><br/></div></div></div></div><div id="35720075" class="c"><input type="checkbox" id="c-35720075" checked=""/><div class="controls bullet"><span class="by">tinglymintyfrsh</span><span>|</span><a href="#35718281">prev</a><span>|</span><label class="collapse" for="c-35720075">[-]</label><label class="expand" for="c-35720075">[1 more]</label></div><br/><div class="children"><div class="content">Wasteful and the wrong place to do it. Also, Sidekiq is slow, old, and commercial crippleware.<p>Generate and send SQL (wrapped in transactions) from C bindings via a proper background job processor like beanstalkd in batches of say 50k. Getting Ruby involved in millions of records is asking for trouble.</div><br/></div></div></div></div></div></div></div></body></html>