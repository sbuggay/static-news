<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696582867262" as="style"/><link rel="stylesheet" href="styles.css?v=1696582867262"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.regehr.org/archives/28">Nine ways to break your systems code using volatile</a>Â <span class="domain">(<a href="https://blog.regehr.org">blog.regehr.org</a>)</span></div><div class="subtext"><span>luu</span> | <span>19 comments</span></div><br/><div><div id="37787959" class="c"><input type="checkbox" id="c-37787959" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37787247">next</a><span>|</span><label class="collapse" for="c-37787959">[-]</label><label class="expand" for="c-37787959">[2 more]</label></div><br/><div class="children"><div class="content">There are gaping omissions in this article.<p>There is a need for volatile in portable C programming, in two circumstances:<p>1. When an asynchronous signal handler modifies a variable that is inspected by the interrupted mainline code (e.g. to set a flag indicating that the signal went off), that variable must be of type &quot;volatile sig_atomic_t&quot;. (The article points to some outside discussion by Hans Boehm about this in relation to Unix, but it&#x27;s not just for Unix; it&#x27;s in ISO C.)<p>2. When a function, after saving a context with setjmp(), modifies automatic local variables, and then the context is restored with longjmp(), those variables must be declared volatile, or else they will not reliably have the correct values. (E.g. the longjmp may or may not restore the values which they had at setjmp time, or do it for some of those variables but not others.)<p>No matter how a C compiler treats volatile, in order to be ISO C conforming, if the program correctly uses volatile in the above situations, it must somehow work. Even if it is useless for anything else: threads, hardware, ...<p><pre><code>  {
    volatile int i = 0;

    if (setjmp(jmp_buf) == 0) {
      i++;
      longjmp(jmp_buf, 1);
    } else {
      printf(&quot;i == %d\n&quot;, i);
    }
  }
</code></pre>
Here, the printf should produce i == 1, which is not required if the <i>volatile</i> is removed.<p>For instance, if i is located in a machine register, and setjmp&#x2F;longjmp work by saving and restoring registers (or just some registers, including that one), the longjmp operation will restore the value that existed in the register at the time setjmp was called, which is zero.<p>If that&#x27;s a problem in a given compiler, even if it has a garbage implementation of volatile, it has to pay attention to the fact that volatile is being used in setjmp code.</div><br/><div id="37788427" class="c"><input type="checkbox" id="c-37788427" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37787959">parent</a><span>|</span><a href="#37787247">next</a><span>|</span><label class="collapse" for="c-37788427">[-]</label><label class="expand" for="c-37788427">[1 more]</label></div><br/><div class="children"><div class="content">For 2. that seems like a defect in the specification of setjmp()? The equivalent  &quot;just works&quot; for functions like pthread_mutex_lock() etc. Those calls implicitly add barriers to force reloading.</div><br/></div></div></div></div><div id="37787247" class="c"><input type="checkbox" id="c-37787247" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37787959">prev</a><span>|</span><a href="#37787173">next</a><span>|</span><label class="collapse" for="c-37787247">[-]</label><label class="expand" for="c-37787247">[5 more]</label></div><br/><div class="children"><div class="content">(2010)<p>The post is still accurate, but in 2011 C and C++ added atomics, which are a more portable alternative to uses of volatile for atomicity.  They can be more efficient in some cases than the locks suggested by the post, especially in CPUs with higher core counts.  (Note that dual-core consumer CPUs were around by 2010 but had only existed for a few years.  Linux only finished removing the Big Kernel Lock in 2011.)</div><br/><div id="37788235" class="c"><input type="checkbox" id="c-37788235" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#37787247">parent</a><span>|</span><a href="#37787444">next</a><span>|</span><label class="collapse" for="c-37788235">[-]</label><label class="expand" for="c-37788235">[1 more]</label></div><br/><div class="children"><div class="content">C11 did add _Atomic, BUT, they are not more portable than using volatile.<p>In C11 any type of any size can have an atomic qualifyer. That means you can have a 50 byte struct that is an atomic. No hardware has a 50 byte atomic instruction so that is not implementable using atomics. The standard gets around this by letting an implementation have a hidden mutex to guarantee that the operations will be atomic.<p>The problem with this is Windows. Windows lets an application load dynamicaly and shared libraries (DLL). This breaks the C11 Atomic model. Let me illustrate using an example:<p>Application A creates an atomic data structure, and the implementation creates a mutex for it. Application B does the same thing. Application A wants to share this data structute with dll X. It then has to share its mutex with the DLL sop that the DLL and application uses the same syncronization primitive. Now Application B wants to do the same thing, problem is DLL X cant use Application Bs Mutex, becaus it is required to use Apllication As mutex.<p>C11s Atomics will never be implemented on Windows because they cant be! Besides, all major compilers do support intrinsic atomics using volatile, that are nearly identical, (and in some ways better understood) so thats what I recomend using. Linus has indicated that he thinks the C11 concurrent memory model is broken so the kernel will continiue to use volatile and intrincics.</div><br/></div></div><div id="37787444" class="c"><input type="checkbox" id="c-37787444" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37787247">parent</a><span>|</span><a href="#37788235">prev</a><span>|</span><a href="#37787173">next</a><span>|</span><label class="collapse" for="c-37787444">[-]</label><label class="expand" for="c-37787444">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The post is still accurate, but in 2011 C and C++ added atomics, which are a more portable alternative to uses of volatile for atomicity.<p>Atomics and volatile solve different problems, though. Atomics ensure a read or write completes uninterrupted. Volatile ensures that a read or write is never optimised away.<p>I think C11 atomics <i>can</i> be optimised away (for example, reading a value twice in a row might result in only a single actual read).<p>Happy to be corrected, though.</div><br/><div id="37787803" class="c"><input type="checkbox" id="c-37787803" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37787247">root</a><span>|</span><a href="#37787444">parent</a><span>|</span><a href="#37787744">next</a><span>|</span><label class="collapse" for="c-37787803">[-]</label><label class="expand" for="c-37787803">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Atomics and volatile solve different problems, though.<p>Yep, that&#x27;s why atomics are only an alternative to uses of volatile _for atomicity_.  For the original use case of accessing hardware registers, volatile is still the correct choice.<p>It is indeed possible for C11 atomics to be optimized, although interestingly, the three major compilers do very little such optimization.  This paper [1] lists some optimizations that are implemented in LLVM and some that aren&#x27;t; it&#x27;s from 2015 but from some quick testing it seems like not much has changed since.<p>[1] <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2015&#x2F;n4455.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2015&#x2F;n44...</a></div><br/></div></div></div></div></div></div><div id="37787173" class="c"><input type="checkbox" id="c-37787173" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37787247">prev</a><span>|</span><a href="#37788229">next</a><span>|</span><label class="collapse" for="c-37787173">[-]</label><label class="expand" for="c-37787173">[6 more]</label></div><br/><div class="children"><div class="content">This is a very good post; too many people (even myself, sometimes) forget that volatile doesn&#x27;t mean that the statement containing it cannot be reordered.<p>[EDIT: the one thing he missed, which I would have liked to know, is about using volatile with int (or sig_atomic_t) as an &quot;eventually consistent&quot; value, for example one global `sig_atomic_t end_flag = 0;`, a single writer (a SIGINT handler to set it to 1),  and many threads with `while (end_flag == 0) { ... }` loops.<p>I&#x27;ve been using this pattern for a while with no obvious problems - access to `end_flag` can be rearranged by the compiler, barriers are irrelevant, the value can be corrupted by a race on every read and it won&#x27;t matter - the thread will get the eventual value of end_flag on the next loop and end.]</div><br/><div id="37787922" class="c"><input type="checkbox" id="c-37787922" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#37787173">parent</a><span>|</span><a href="#37787938">next</a><span>|</span><label class="collapse" for="c-37787922">[-]</label><label class="expand" for="c-37787922">[1 more]</label></div><br/><div class="children"><div class="content">&gt; one global `sig_atomic_t end_flag = 0;`, a single writer (a SIGINT handler to set it to 1), and many threads with `while (end_flag == 0) { ... }` loops.<p>While unlikely to cause problems, this is a data race (a set of at least two concurrent accesses, of which at least one is not an atomic  access and at least one is a write) and therefore constitutes undefined behavior.<p>sig_atomic_t is only safe to use from one thread, where concurrency is given by a signal handler.</div><br/></div></div><div id="37787938" class="c"><input type="checkbox" id="c-37787938" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37787173">parent</a><span>|</span><a href="#37787922">prev</a><span>|</span><a href="#37787474">next</a><span>|</span><label class="collapse" for="c-37787938">[-]</label><label class="expand" for="c-37787938">[1 more]</label></div><br/><div class="children"><div class="content">That use of volatile for signalling thread exit, although it might work ok in practice, is still a data race and so UB under C11&#x2F;C++11 MM rules.</div><br/></div></div><div id="37787474" class="c"><input type="checkbox" id="c-37787474" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#37787173">parent</a><span>|</span><a href="#37787938">prev</a><span>|</span><a href="#37788229">next</a><span>|</span><label class="collapse" for="c-37787474">[-]</label><label class="expand" for="c-37787474">[3 more]</label></div><br/><div class="children"><div class="content">I suspect sig_atomic_t does work fine when we&#x27;re talking about POSIX signals, but OP was probably thinking more from an embedded programming and hardware interrupt handlers, which don&#x27;t conform to POSIX signal semantics.</div><br/><div id="37787532" class="c"><input type="checkbox" id="c-37787532" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37787173">root</a><span>|</span><a href="#37787474">parent</a><span>|</span><a href="#37788229">next</a><span>|</span><label class="collapse" for="c-37787532">[-]</label><label class="expand" for="c-37787532">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I suspect sig_atomic_t does work fine when we&#x27;re talking about POSIX signals, but OP was probably thinking more from an embedded programming and hardware interrupt handlers, which don&#x27;t conform to POSIX signal semantics.<p>It&#x27;s not the sig_atomic_t that I think is wrong (could be plain int), it&#x27;s the &quot;Is it safe to have one writer to a zero-initialised volatile value, and many readers checking for non-zero of that value?&quot;<p>Now I wouldn&#x27;t use this and expect correctness in the value, but even when the value that is read is corrupted because that single write did not finish (it&#x27;s zero, one or something else), it will be non-zero <i>eventually</i>, and so the thread will end.</div><br/><div id="37787910" class="c"><input type="checkbox" id="c-37787910" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37787173">root</a><span>|</span><a href="#37787532">parent</a><span>|</span><a href="#37788229">next</a><span>|</span><label class="collapse" for="c-37787910">[-]</label><label class="expand" for="c-37787910">[1 more]</label></div><br/><div class="children"><div class="content">Technically, using volatile between threads is a data race and therefore UB [1]; the guarantees made around sig_atomic_t only apply between a thread and a signal handler on the same thread.<p>Though, I&#x27;d argue that the no-optimization guarantee of volatile actually does justify reasoning of the form &quot;it&#x27;s not undefined behavior because the hardware guarantees it&quot;, which is a mistake anywhere else in C.  On essentially all architectures, loads and stores of volatile integers act the same way as loads and stores of atomics using memory_order_relaxed (or stronger, depending on the architecture).  So it may be legal to rely on volatile being atomic, as long as you don&#x27;t expect the code to be compiled on some hypothetical architecture that doesn&#x27;t have this feature.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;71895449&#x2F;is-it-a-data-race" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;71895449&#x2F;is-it-a-data-ra...</a></div><br/></div></div></div></div></div></div></div></div><div id="37788229" class="c"><input type="checkbox" id="c-37788229" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#37787173">prev</a><span>|</span><a href="#37788195">next</a><span>|</span><label class="collapse" for="c-37788229">[-]</label><label class="expand" for="c-37788229">[1 more]</label></div><br/><div class="children"><div class="content">(Meta: As already pointed out by @comex, this post is from 2010 and it would be helpful with a tag in the title to make that clearer.)<p>That said, it&#x27;s an awesome post (not surprising considering the source). I found the initial set-up explaining the concept of C&#x27;s abstract machine very succinct and nice, it&#x27;s something I would wish more people discussing the language to be (well) aware of.<p>Great post, thanks!</div><br/></div></div><div id="37788195" class="c"><input type="checkbox" id="c-37788195" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#37788229">prev</a><span>|</span><a href="#37787310">next</a><span>|</span><label class="collapse" for="c-37788195">[-]</label><label class="expand" for="c-37788195">[1 more]</label></div><br/><div class="children"><div class="content">In the Linux Kernel instead of marking variables&#x2F;types as volatile you mark _accesses_ as volatile. there&#x27;s a pair of macros READ_ONCE&#x2F;WRITE_ONCE that temporarily cast the pointer for you. I think this is a better way to use volatile.<p>Even then I think it&#x27;s rarely useful outside of x86-specific code (where the CPU gives you quite a lot of memory ordering guarantees). Would be interesting to check how often it gets used elsewhere.</div><br/></div></div><div id="37787310" class="c"><input type="checkbox" id="c-37787310" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37788195">prev</a><span>|</span><a href="#37787742">next</a><span>|</span><label class="collapse" for="c-37787310">[-]</label><label class="expand" for="c-37787310">[2 more]</label></div><br/><div class="children"><div class="content">In a discussion like this you have to mention that Microsoftâs compiler extended volatile to mean atomic[1], although its default behavior depends on target ISA apparently. Regardless, just use c11&#x2F;c++11 atomics at this point.<p>1. <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;volatile-cpp?view=msvc-170" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;volatile-cpp?view=...</a></div><br/><div id="37787688" class="c"><input type="checkbox" id="c-37787688" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37787310">parent</a><span>|</span><a href="#37787742">next</a><span>|</span><label class="collapse" for="c-37787688">[-]</label><label class="expand" for="c-37787688">[1 more]</label></div><br/><div class="children"><div class="content">Yes but they consider the additional semantics a mistake:<p>&quot;we strongly recommend that you specify &#x2F;volatile:iso, and use explicit synchronization primitives and compiler intrinsics when you are dealing with memory that is shared across threads.&quot;<p>&#x2F;volatile:iso is the default for ARM as the extended semantics would be extremely penalising.</div><br/></div></div></div></div><div id="37787742" class="c"><input type="checkbox" id="c-37787742" checked=""/><div class="controls bullet"><span class="by">2rsf</span><span>|</span><a href="#37787310">prev</a><span>|</span><label class="collapse" for="c-37787742">[-]</label><label class="expand" for="c-37787742">[1 more]</label></div><br/><div class="children"><div class="content">As a former embedded engineer on older Motorola and ARM processors I have seen reordering happening, and more than once had to check the generated assembly code, the other items more or less makes sense if you don&#x27;t expect too much from your compiler, for example using volatile to get atomicity.<p>Using volatile on multi-threaded code is ok as long as you know what you are doing, for example kicking a watchdog at a defined physical address could be fine from different threads.</div><br/></div></div></div></div></div></div></div></body></html>