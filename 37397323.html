<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693990869238" as="style"/><link rel="stylesheet" href="styles.css?v=1693990869238"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bitbytebit.substack.com/p/when-deployments-are-easy-code-becomes">When deployments are easy, code becomes simpler</a> <span class="domain">(<a href="https://bitbytebit.substack.com">bitbytebit.substack.com</a>)</span></div><div class="subtext"><span>recroad</span> | <span>78 comments</span></div><br/><div><div id="37397673" class="c"><input type="checkbox" id="c-37397673" checked=""/><div class="controls bullet"><span class="by">dmoy</span><span>|</span><a href="#37402064">next</a><span>|</span><label class="collapse" for="c-37397673">[-]</label><label class="expand" for="c-37397673">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Is this bad because I now have to do a deployment to enable the feature? ... I would argue as long as your deployments are easy, this is the better way to do things because it reduces the complexity of integrating with a third-party tool.<p>Shoot, even when it&#x27;s all first party tooling, I prefer a release-flags-and-binary as an atomic unit.  If the flags and binary are going out as a single push, it simplifies a lot of things:<p>* reproducible state for given time with only one thing to track (running version), instead of two or more things (binary version, flag configs version)<p>* corollary: rollbacks are much more simple, because it&#x27;s just one thing to rollback - the code+config+everything as an atomic unit, not &quot;did we need to roll back the flags, or the binary, or both?&quot; (Corollary to corollary: removes the awful problem of &quot;oh shit the code and&#x2F;or flags&#x2F;configs wasn&#x27;t backwards&#x2F;forwards compatible&quot; where you shoot yourself in the foot while doing a rollback<p>* removals and cleanups are easier: can remove flags, config bits, and code all at once, instead of having to do a careful dance of &quot;set code behavior to default-on and remove dependency on flag, the wait for full deployment, then make sure everyone is okay with not rolling back after a given point, then remove flags and config logic&quot;<p>* depending on your tooling, diffs vs prod during code review get cleaner</div><br/><div id="37400176" class="c"><input type="checkbox" id="c-37400176" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#37397673">parent</a><span>|</span><a href="#37402064">next</a><span>|</span><label class="collapse" for="c-37400176">[-]</label><label class="expand" for="c-37400176">[12 more]</label></div><br/><div class="children"><div class="content">The problem is when your deployment depends on external state like a database. Code rollbacks are trivial, rolling back state (if you even can) is not.</div><br/><div id="37401320" class="c"><input type="checkbox" id="c-37401320" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37400176">parent</a><span>|</span><a href="#37400519">next</a><span>|</span><label class="collapse" for="c-37401320">[-]</label><label class="expand" for="c-37401320">[6 more]</label></div><br/><div class="children"><div class="content">One of the very best development teams I worked with had an interesting take, they always did database migrations first. Any new state that was to be added to the system could only be done so by first adding the new database fields or tables. This ensure that version 1 of the code would work with version 1 and 2 of the database. They would then roll out version 2 of the code, but have the new features hidden behind a feature flags (in the database), ensuring that version 2 could run, without using the new database schema. Once they where confident that everything was still running on version 2 of the code and database they&#x27;d enable the new feature. Later the feature flag could be migrated from the database to a properties file, saving the database lookup.<p>I wouldn&#x27;t necessarily call this approach simple, but it was incredibly safe and rollbacks was always a none event.</div><br/><div id="37402631" class="c"><input type="checkbox" id="c-37402631" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37401320">parent</a><span>|</span><a href="#37401407">next</a><span>|</span><label class="collapse" for="c-37402631">[-]</label><label class="expand" for="c-37402631">[1 more]</label></div><br/><div class="children"><div class="content">Not saying it is a bad idea, but the way it works is it ensures certain things happen that you would normally want to happen, namely:<p>* test of a rollback procedure,<p>* developers thinking about backwards compatibility and rollback procedure.<p>The main issue I see with this approach is that the test of the rollback is only partial. Just because the schema is usable by the previous version of the application does not mean the new data that is going to be put by the application will perform the same way.<p>Another issue I am seeing is that it is not a separate testing event but essentially happening live when the application is turned on on production. Not nice.<p>On the pros, this is very useful when you want to have more than one version of the application code to coexist at the same time. But I would not rely on learning about incompatibility when I start deploying the application, I would want to know that well before then.</div><br/></div></div><div id="37401407" class="c"><input type="checkbox" id="c-37401407" checked=""/><div class="controls bullet"><span class="by">QuercusMax</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37401320">parent</a><span>|</span><a href="#37402631">prev</a><span>|</span><a href="#37402301">next</a><span>|</span><label class="collapse" for="c-37401407">[-]</label><label class="expand" for="c-37401407">[1 more]</label></div><br/><div class="children"><div class="content">I learned this as standard practice at Google back in 2015.<p>We got really good at data migrations and it was no big deal - but we only got serious about this after we had a major DB and functionality update that went wrong and took us down for 2 days.</div><br/></div></div><div id="37402301" class="c"><input type="checkbox" id="c-37402301" checked=""/><div class="controls bullet"><span class="by">steffres</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37401320">parent</a><span>|</span><a href="#37401407">prev</a><span>|</span><a href="#37400519">next</a><span>|</span><label class="collapse" for="c-37402301">[-]</label><label class="expand" for="c-37402301">[3 more]</label></div><br/><div class="children"><div class="content">That sounds reasonable. But what about the case where the DB migration of version 2 would be incompatbile with code version 1, e.g. a column was dropped?</div><br/><div id="37402527" class="c"><input type="checkbox" id="c-37402527" checked=""/><div class="controls bullet"><span class="by">jaimebuelta</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37402301">parent</a><span>|</span><a href="#37400519">next</a><span>|</span><label class="collapse" for="c-37402527">[-]</label><label class="expand" for="c-37402527">[2 more]</label></div><br/><div class="children"><div class="content">You NEVER do that in one go, you need to split it in several deployments. Dropping a column is relatively straightforward, in two steps. First deploy a version of the code that doesn’t use the column, then release the migration dropping the column.<p>The typical example is the renaming of a column, which needs to be done in several steps:<p>1. Create the new column, copying the data from the old column (DB migration) both columns exist, but only the old one is used<p>2. Deploy new code that works with both columns, reading from old and writing new and old<p>3. Deploy data migration (DB migration) that ensures old and new columns has the same values (to ensure data consistency). At this point, there are no “old column only” writes by the code deployed in previous step<p>4. Deploy new code using only new column. Old column is deprecated<p>5. Delete old column<p>At any given point, code versions N (current) and N-1 (previous) are compatible with the DB. Any change on the DB is done in advance in a backwards compatible way.</div><br/><div id="37402612" class="c"><input type="checkbox" id="c-37402612" checked=""/><div class="controls bullet"><span class="by">steffres</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37402527">parent</a><span>|</span><a href="#37400519">next</a><span>|</span><label class="collapse" for="c-37402612">[-]</label><label class="expand" for="c-37402612">[1 more]</label></div><br/><div class="children"><div class="content">I see. Thanks for the clarifications.<p>And these DB migrations, did your team keep a history of them? If so, did you manage them yourselves, or did you use some tools like flyway?<p>I&#x27;m asking because I&#x27;m starting a project where we will manage the persistence SQL layer without any ORM (always did it so far with Django&#x27;s migrations), but might consider some third party tools for DB migrations.</div><br/></div></div></div></div></div></div></div></div><div id="37400519" class="c"><input type="checkbox" id="c-37400519" checked=""/><div class="controls bullet"><span class="by">mcny</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37400176">parent</a><span>|</span><a href="#37401320">prev</a><span>|</span><a href="#37400700">next</a><span>|</span><label class="collapse" for="c-37400519">[-]</label><label class="expand" for="c-37400519">[1 more]</label></div><br/><div class="children"><div class="content">I always say this - there is no such thing as a rollback. Anyone who pretends you can simply &quot;roll back&quot; a stateful application is out of their mind.<p>If you can roll back and forward events, good for you but for most of us rollbacks are actually a new build, deployment, and a new set of tests. Every single time.</div><br/></div></div><div id="37400700" class="c"><input type="checkbox" id="c-37400700" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37400176">parent</a><span>|</span><a href="#37400519">prev</a><span>|</span><a href="#37400751">next</a><span>|</span><label class="collapse" for="c-37400700">[-]</label><label class="expand" for="c-37400700">[3 more]</label></div><br/><div class="children"><div class="content">If a git commit hash was directly tied to a data hash at that state (IPFS), that would be trivial.</div><br/><div id="37400963" class="c"><input type="checkbox" id="c-37400963" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37400700">parent</a><span>|</span><a href="#37401560">next</a><span>|</span><label class="collapse" for="c-37400963">[-]</label><label class="expand" for="c-37400963">[1 more]</label></div><br/><div class="children"><div class="content">Or have the SAN make a snapshot of your db before the deploy, no fancy solution-looking-for-a-problem tech needed.<p>Completely reverting all the state to some point in the past is easy and have been a solved problem for quite a while.<p>The actual problem is undoing states changes related to the code change, while <i>not</i> losing state changes related to normal system activity.<p>If I add some new fields to how my web forum records posts, and then find out that it&#x27;s eating every tenth post and need to revert, it&#x27;d be good to <i>not</i> lose and posts made in the meantime.</div><br/></div></div><div id="37401560" class="c"><input type="checkbox" id="c-37401560" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37400700">parent</a><span>|</span><a href="#37400963">prev</a><span>|</span><a href="#37400751">next</a><span>|</span><label class="collapse" for="c-37401560">[-]</label><label class="expand" for="c-37401560">[1 more]</label></div><br/><div class="children"><div class="content">And useless. Unless customers don’t care about their data.</div><br/></div></div></div></div><div id="37400751" class="c"><input type="checkbox" id="c-37400751" checked=""/><div class="controls bullet"><span class="by">dmoy</span><span>|</span><a href="#37397673">root</a><span>|</span><a href="#37400176">parent</a><span>|</span><a href="#37400700">prev</a><span>|</span><a href="#37402064">next</a><span>|</span><label class="collapse" for="c-37400751">[-]</label><label class="expand" for="c-37400751">[1 more]</label></div><br/><div class="children"><div class="content">Sure, that is still a problem.  But that problem exists whether or not your flags&#x2F;configs are pushed atomically with your code&#x2F;binary changes.<p>Having flags push separately adds another problem on top of data corruption.</div><br/></div></div></div></div></div></div><div id="37402064" class="c"><input type="checkbox" id="c-37402064" checked=""/><div class="controls bullet"><span class="by">vinay_ys</span><span>|</span><a href="#37397673">prev</a><span>|</span><a href="#37398280">next</a><span>|</span><label class="collapse" for="c-37402064">[-]</label><label class="expand" for="c-37402064">[1 more]</label></div><br/><div class="children"><div class="content">Pushing config to production is also deployment. Pushing config update to a dynamic config serving service from which all other services pull the config is also deployment.<p>You need safety guardrails for any deployment of code or config – a clearly defined unit of deployment that is version controlled, changes going through a repeatable automated flow in which lints&#x2F;tests can be added, changes can be rolled out atomically all at once, or rolled out with careful control gradually, can be rolled back to a known safe version instantly when needed etc. All of this applies to config and code (binary).<p>Within code, having feature flags, dynamic config variables, experiments that can be ramped up slowly and ramped down automatically upon regression detection etc – these are mechanisms to make your life easier when you have unknown-unknowns manifest to bite you. And they always do in any non-trivial real-world large-scale distributed architecture application that needs to evolve continuously.<p>And these unknown-unknowns are not just code bugs, they are mix shifts in usage patterns, data etc causing unanticipated behaviors too. They are old stale stored state interacting with new code that you didn&#x27;t test for. They are changes in code outside of your control – like remote services or OS&#x2F;language libraries – that you assume to be mostly stable and don&#x27;t exhaustively test every single time – that you don&#x27;t even know when they changed - that change behavior without changing interface etc. These are real-world software systems problems.<p>If your software is built like an appliance – frozen in time and doesn&#x27;t change ever after, is stateless, doesn&#x27;t interact with outside world etc – then you don&#x27;t need any of those guardrails and you can keep your code simple.</div><br/></div></div><div id="37398280" class="c"><input type="checkbox" id="c-37398280" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#37402064">prev</a><span>|</span><a href="#37402656">next</a><span>|</span><label class="collapse" for="c-37398280">[-]</label><label class="expand" for="c-37398280">[14 more]</label></div><br/><div class="children"><div class="content">I have recently seen someone wrap a single function in about 10 classes of Java to turn it into a standalone application, slap on some Docker Compose magic, add some build scripts, and then continue to look proud at the feature being wholly configurable at deployment time.<p>Of course, the deployment team would have to be informed about this change, so some documentation was required as well, but that was exactly the part of the process where most effort was saved.<p>Note that all this was used for a system that would be deployed only at one customer, and the feature would always be on.  Yes, a boolean flag would have been a better solution for this.<p>My cynicism is probably not the best approach to change the world for the better, so any hint on how to teach younger colleagues to stop snacking micro service candy is much appreciated.</div><br/><div id="37398394" class="c"><input type="checkbox" id="c-37398394" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#37398280">parent</a><span>|</span><a href="#37401904">next</a><span>|</span><label class="collapse" for="c-37398394">[-]</label><label class="expand" for="c-37398394">[1 more]</label></div><br/><div class="children"><div class="content">Just raise it up early, often, and simply.<p>&quot;Isn&#x27;t this just a Boolean flag? If X else y?&quot;<p>I&#x27;ve saved a great many man months by doing just this. Sometimes work just vanishes. And it&#x27;s not just the juniors that do it, sometimes the senior &#x2F; tech lead types just miss a crucial point to make the solution trivial.<p>But juniors are often used to wanting to make work, rather than solve a problem.</div><br/></div></div><div id="37401904" class="c"><input type="checkbox" id="c-37401904" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37398280">parent</a><span>|</span><a href="#37398394">prev</a><span>|</span><a href="#37398370">next</a><span>|</span><label class="collapse" for="c-37401904">[-]</label><label class="expand" for="c-37401904">[1 more]</label></div><br/><div class="children"><div class="content">If you’re one of these people who are oozing with sarcasm then just be yourself. It’s a fun way to convey when something actually is ridiculous. Nothing wrong with that.<p>Just also make sure from time to time that you’re on the same side. Don’t hesitate to laugh at your own mistakes openly. Sprinkle in some sympathetic, honest remarks. Target the thing, the mistakes, never the person.<p>Bottom line: laugh together at the expense of human fallibility and not a particular person.</div><br/></div></div><div id="37398370" class="c"><input type="checkbox" id="c-37398370" checked=""/><div class="controls bullet"><span class="by">digging</span><span>|</span><a href="#37398280">parent</a><span>|</span><a href="#37401904">prev</a><span>|</span><a href="#37401815">next</a><span>|</span><label class="collapse" for="c-37398370">[-]</label><label class="expand" for="c-37398370">[8 more]</label></div><br/><div class="children"><div class="content">&gt; My cynicism is probably not the best approach to change the world for the better, so any hint on how to teach younger colleagues to stop snacking micro service candy is much appreciated.<p>I could be way off base here, but I&#x27;d bet a lot of junior devs are just trying to stand out. They want respect, raises, promotions, and new job offers. Invisible good solutions don&#x27;t bring those.</div><br/><div id="37398899" class="c"><input type="checkbox" id="c-37398899" checked=""/><div class="controls bullet"><span class="by">kdmccormick</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37398370">parent</a><span>|</span><a href="#37400537">next</a><span>|</span><label class="collapse" for="c-37398899">[-]</label><label class="expand" for="c-37398899">[3 more]</label></div><br/><div class="children"><div class="content">Seems cynical. In my experience, junior devs are just more susceptible to cargo-culting and getting excited about cool ways to apply the things they learned in undergrad. I haven&#x27;t actually seen a lot of &quot;resume-driven development&quot; in my (relatively limited) time in the industry... just well-intentioned eager people with more knowledge than wisdom.</div><br/><div id="37399049" class="c"><input type="checkbox" id="c-37399049" checked=""/><div class="controls bullet"><span class="by">chiefalchemist</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37398899">parent</a><span>|</span><a href="#37400537">next</a><span>|</span><label class="collapse" for="c-37399049">[-]</label><label class="expand" for="c-37399049">[2 more]</label></div><br/><div class="children"><div class="content">&gt; just well-intentioned eager people with more knowledge than wisdom.<p>Yup. And that by definition is a junior colleague ;)</div><br/><div id="37401143" class="c"><input type="checkbox" id="c-37401143" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37399049">parent</a><span>|</span><a href="#37400537">next</a><span>|</span><label class="collapse" for="c-37401143">[-]</label><label class="expand" for="c-37401143">[1 more]</label></div><br/><div class="children"><div class="content">I like to describe my colleagues as the delta between how smart they are, and how smart they _think_ they are. “Junior” devs almost always fall in the “wide gap” spectrum but it is by no means restricted to any age group.</div><br/></div></div></div></div></div></div><div id="37400537" class="c"><input type="checkbox" id="c-37400537" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37398370">parent</a><span>|</span><a href="#37398899">prev</a><span>|</span><a href="#37398478">next</a><span>|</span><label class="collapse" for="c-37400537">[-]</label><label class="expand" for="c-37400537">[2 more]</label></div><br/><div class="children"><div class="content">Strongly disagree this is a junior dev thing. Most of the terribly complex abstractions are, in my experience creates by people who have enough seniority that others can&#x27;t easily question them. There are good devs and bad devs, and there are junior and senior devs, but it&#x27;s the first axis that determines code quality.</div><br/><div id="37401765" class="c"><input type="checkbox" id="c-37401765" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37400537">parent</a><span>|</span><a href="#37398478">next</a><span>|</span><label class="collapse" for="c-37401765">[-]</label><label class="expand" for="c-37401765">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen entire orgs paralysed by a single architecture astronaut who has been there since the beginning who nobody has found a way to route around. Simplicity as a cultural value is underrated, and fetishising complexity can kill a business.</div><br/></div></div></div></div><div id="37398478" class="c"><input type="checkbox" id="c-37398478" checked=""/><div class="controls bullet"><span class="by">catchnear4321</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37398370">parent</a><span>|</span><a href="#37400537">prev</a><span>|</span><a href="#37401815">next</a><span>|</span><label class="collapse" for="c-37398478">[-]</label><label class="expand" for="c-37398478">[2 more]</label></div><br/><div class="children"><div class="content">junior devs are junior devs in part because they do not yet know that there is no guarantee that anyone else has been keeping track of their victories come review time.<p>solutions are only invisible due to a lack of sufficient documentation and communication.<p>boring solutions are part of the job.  they can be fun if the goal is shifted from implementing to automating.<p>none of this to say you are wrong, but a junior dev that succeeds at such peacocking efforts is signaling the poor health of their surrounding team as much as their eagerness to impress.  where was the manager or senior dev to say “great!  have you considered a boolean?”</div><br/><div id="37400972" class="c"><input type="checkbox" id="c-37400972" checked=""/><div class="controls bullet"><span class="by">blq10</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37398478">parent</a><span>|</span><a href="#37401815">next</a><span>|</span><label class="collapse" for="c-37400972">[-]</label><label class="expand" for="c-37400972">[1 more]</label></div><br/><div class="children"><div class="content">Nobody cares about invisible good solutions, because invisible solutions are simple - and developers are to one degree or another, rated on the degree of complexity they can deal with and how smart they can be. It is common here to understand the cleverness behind just doing the dumb thing, but it is not common in many places.</div><br/></div></div></div></div></div></div><div id="37401815" class="c"><input type="checkbox" id="c-37401815" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37398280">parent</a><span>|</span><a href="#37398370">prev</a><span>|</span><a href="#37402656">next</a><span>|</span><label class="collapse" for="c-37401815">[-]</label><label class="expand" for="c-37401815">[3 more]</label></div><br/><div class="children"><div class="content">Are there no seniors on the team? Why aren&#x27;t anyone helping and guiding your team to make a better product? Seniority isn&#x27;t about technical skill, it&#x27;s about being a multiplier and paving the road for others. If you&#x27;re not, and you&#x27;re letting the team in your eyes waste time, the whole team acts just as junior.</div><br/><div id="37401911" class="c"><input type="checkbox" id="c-37401911" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37401815">parent</a><span>|</span><a href="#37402656">next</a><span>|</span><label class="collapse" for="c-37401911">[-]</label><label class="expand" for="c-37401911">[2 more]</label></div><br/><div class="children"><div class="content">Touché!  Both luckily and unfortunately, this incident was not on my team.<p>Even then, I find it increasingly hard to argue people out of the nonsense they pick up on blogs and conferences.<p>Especially for newer techniques that are not yet proven to be inefficient, such as using micro services in the wrong context, one has to resort to arguments by authority.  Some junior and senior devs are not very susceptible to that.<p>For areas such as web development for user interfaces, or taking in enormous dependency trees with package managers, the problem is even worse.  Here, an entire industry had standardised on suboptimal methods.  One can argue that this is wrong, but there is no viable alternative.<p>In the latter case, guiding only one junior developer does not improve things.  One has to educate the entire industry.</div><br/><div id="37402392" class="c"><input type="checkbox" id="c-37402392" checked=""/><div class="controls bullet"><span class="by">wofo</span><span>|</span><a href="#37398280">root</a><span>|</span><a href="#37401911">parent</a><span>|</span><a href="#37402656">next</a><span>|</span><label class="collapse" for="c-37402392">[-]</label><label class="expand" for="c-37402392">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the nonsense they pick up on blogs and conferences<p>Thanks for this bit. As I gain more experience, I grow less and less patient with many blogs and conference talks. Often authors are just very excited about a topic, and my general impression is that they tend to propose ideas that are not seriously battle-tested in production.</div><br/></div></div></div></div></div></div></div></div><div id="37402656" class="c"><input type="checkbox" id="c-37402656" checked=""/><div class="controls bullet"><span class="by">Palmik</span><span>|</span><a href="#37398280">prev</a><span>|</span><a href="#37400706">next</a><span>|</span><label class="collapse" for="c-37402656">[-]</label><label class="expand" for="c-37402656">[1 more]</label></div><br/><div class="children"><div class="content">At Google, there are no branches, so typically development indeed happens under some experiment flag. Binary, configs and experiment flags are on separate deployment schedules, and often you need to coordinate your release across different systems (with their own binary, config and experiment flag deployment schedules). This requires you to think about backward &amp; forward compatibility of all your changes.</div><br/></div></div><div id="37400706" class="c"><input type="checkbox" id="c-37400706" checked=""/><div class="controls bullet"><span class="by">daigoba66</span><span>|</span><a href="#37402656">prev</a><span>|</span><a href="#37401156">next</a><span>|</span><label class="collapse" for="c-37400706">[-]</label><label class="expand" for="c-37400706">[12 more]</label></div><br/><div class="children"><div class="content">As an aside, those “feature flags as a service” tools have some neat features, but are just way too expensive for what most apps probably need: simple binary flags that can change at runtime.<p>Example: just use a database table. Query and cache in memory for 60s. If you want, build a simple internal web page or tool to toggle flags. This works, and scales (from experience).<p>Do many apps really need A&#x2F;B testing or segmented rollout? Maybe, but probably not.</div><br/><div id="37401362" class="c"><input type="checkbox" id="c-37401362" checked=""/><div class="controls bullet"><span class="by">hsn915</span><span>|</span><a href="#37400706">parent</a><span>|</span><a href="#37400905">next</a><span>|</span><label class="collapse" for="c-37401362">[-]</label><label class="expand" for="c-37401362">[3 more]</label></div><br/><div class="children"><div class="content">Is &quot;feature flag as a service&quot; the new trend in backend development?<p>Why would anyone replace a literal byte in memory with a full program?<p>Why?</div><br/><div id="37402114" class="c"><input type="checkbox" id="c-37402114" checked=""/><div class="controls bullet"><span class="by">bratbag</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37401362">parent</a><span>|</span><a href="#37401791">next</a><span>|</span><label class="collapse" for="c-37402114">[-]</label><label class="expand" for="c-37402114">[1 more]</label></div><br/><div class="children"><div class="content">Because feature flags often intersect with segmentation and AB testing.<p>So it&#x27;s not just a byte in memory, but often also correlating the status of said byte with a users identity and then tracking and summarising user behaviour based on that relationship.<p>It&#x27;s become fairly standardised and requires engineer time to setup and maintain the services behind all that, so it&#x27;s valid to go third party for less than the cost of said engineer time, if all you want is standard.<p>Edit:it&#x27;s also hard to always predict when a standard flags going to become part of a test, so just integrating for every flag and making that a standard process for your teams becomes the simplest approach.</div><br/></div></div><div id="37401791" class="c"><input type="checkbox" id="c-37401791" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37401362">parent</a><span>|</span><a href="#37402114">prev</a><span>|</span><a href="#37400905">next</a><span>|</span><label class="collapse" for="c-37401791">[-]</label><label class="expand" for="c-37401791">[1 more]</label></div><br/><div class="children"><div class="content">I am not a fan nor a user of backend feature flags, so don&#x27;t ding me for relaying this: they tout features such as central management of these settings, bringing them in the hands of the product team rather than being tugged away in code, allowing for canary deployments where you fade in a feature based on performance metrics, a&#x2F;b testing, and so on. In their own interest, these folks take an as broad as possible view on what is a feature flag, often including things that you&#x27;d otherwise call system configuration or entitlements or permission toggles. It&#x27;s not a new trend, LaunchDarkly is probably the best known commercial party here, and they&#x27;ve been around for about ten years, and I don&#x27;t think they were first.</div><br/></div></div></div></div><div id="37400905" class="c"><input type="checkbox" id="c-37400905" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37400706">parent</a><span>|</span><a href="#37401362">prev</a><span>|</span><a href="#37400940">next</a><span>|</span><label class="collapse" for="c-37400905">[-]</label><label class="expand" for="c-37400905">[6 more]</label></div><br/><div class="children"><div class="content">&quot;Just use a database table&quot; solves for the simplest cases - a single monolithic app. It works incredibly well in this case. It falls apart when I need to turn features on across multiple apps together.</div><br/><div id="37401376" class="c"><input type="checkbox" id="c-37401376" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37400905">parent</a><span>|</span><a href="#37401727">next</a><span>|</span><label class="collapse" for="c-37401376">[-]</label><label class="expand" for="c-37401376">[3 more]</label></div><br/><div class="children"><div class="content">Then you use etcd or consul.<p>I would claim that release a new feature by enabling additional code path across multiple apps at once is a bit of an anti-pattern. It seems rather dangerous and error prone. In that case I&#x27;d actually release it in reverse order, so to speak. Release the apps that use the services of others first and have it check is this service is available&#x2F;functional and if not, skip calling it. The release the feature to the next service down the stack. Then you can always rollback the last service and be confident that the callers still work.<p>It&#x27;s way more work and I can see why for certain types of application isn&#x27;t not really worth the trouble.</div><br/><div id="37401498" class="c"><input type="checkbox" id="c-37401498" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37401376">parent</a><span>|</span><a href="#37401727">next</a><span>|</span><label class="collapse" for="c-37401498">[-]</label><label class="expand" for="c-37401498">[2 more]</label></div><br/><div class="children"><div class="content">The point of feature flags is to decouple releases from deployments.</div><br/><div id="37401520" class="c"><input type="checkbox" id="c-37401520" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37401498">parent</a><span>|</span><a href="#37401727">next</a><span>|</span><label class="collapse" for="c-37401520">[-]</label><label class="expand" for="c-37401520">[1 more]</label></div><br/><div class="children"><div class="content">Then you just have a feature flag per app.</div><br/></div></div></div></div></div></div><div id="37401727" class="c"><input type="checkbox" id="c-37401727" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37400905">parent</a><span>|</span><a href="#37401376">prev</a><span>|</span><a href="#37400967">next</a><span>|</span><label class="collapse" for="c-37401727">[-]</label><label class="expand" for="c-37401727">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just use a database table&quot; solves for the simplest cases - a single monolithic app.<p><i>Most</i> cases are the simplest cases.<p>No approach works for every single use case, but OP was specifically talking about the common case. You don’t have to shoot for the most complex use case every time.</div><br/></div></div><div id="37400967" class="c"><input type="checkbox" id="c-37400967" checked=""/><div class="controls bullet"><span class="by">ehnto</span><span>|</span><a href="#37400706">root</a><span>|</span><a href="#37400905">parent</a><span>|</span><a href="#37401727">prev</a><span>|</span><a href="#37400940">next</a><span>|</span><label class="collapse" for="c-37400967">[-]</label><label class="expand" for="c-37400967">[1 more]</label></div><br/><div class="children"><div class="content">I think OPs point was a simple app doesn&#x27;t need this whole suite of tools, but you pay for them anyway, which makes it a bad cost&#x2F;value proposition for simple apps.<p>So yes a more complex situation could benefit from all this extra tooling and complexity but otherwise it is dead weight&#x2F;cost.</div><br/></div></div></div></div><div id="37400940" class="c"><input type="checkbox" id="c-37400940" checked=""/><div class="controls bullet"><span class="by">ehnto</span><span>|</span><a href="#37400706">parent</a><span>|</span><a href="#37400905">prev</a><span>|</span><a href="#37400790">next</a><span>|</span><label class="collapse" for="c-37400940">[-]</label><label class="expand" for="c-37400940">[1 more]</label></div><br/><div class="children"><div class="content">I think most frameworks I have worked with have the concept of configurations, more advanced ones have config that can be overriden by environment files. Definitely a solved problem if you want to roll your own.<p>.env files are the quick and dirty version for simple sites that don&#x27;t have an  admin panel or database.</div><br/></div></div><div id="37400790" class="c"><input type="checkbox" id="c-37400790" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#37400706">parent</a><span>|</span><a href="#37400940">prev</a><span>|</span><a href="#37401156">next</a><span>|</span><label class="collapse" for="c-37400790">[-]</label><label class="expand" for="c-37400790">[1 more]</label></div><br/><div class="children"><div class="content">This technique has been used since Wordpress days and earlier. At it’s core, it’s a “meta” table with a string identifier and some value. It’s a pattern I still use today in my own web apps.</div><br/></div></div></div></div><div id="37401156" class="c"><input type="checkbox" id="c-37401156" checked=""/><div class="controls bullet"><span class="by">ketchupdebugger</span><span>|</span><a href="#37400706">prev</a><span>|</span><a href="#37401939">next</a><span>|</span><label class="collapse" for="c-37401156">[-]</label><label class="expand" for="c-37401156">[7 more]</label></div><br/><div class="children"><div class="content">&gt;Much of the time I’m using flags so I can commit unfinished code because I don’t want to create a separate branch and have one source of truth<p>This seems like an incident in the making. If each dev on a team commits unfinished code into prod behind flags, the whole project is going to be littered with flags and unfinished code. Some intern is going to delete a flag or an if check and then everything is going to break.</div><br/><div id="37401294" class="c"><input type="checkbox" id="c-37401294" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#37401156">parent</a><span>|</span><a href="#37401352">next</a><span>|</span><label class="collapse" for="c-37401294">[-]</label><label class="expand" for="c-37401294">[1 more]</label></div><br/><div class="children"><div class="content">Why would an intern remove a flag? The flag is not special, it&#x27;s code like everything else, with tests, ownership, documentation etc..<p>The idea of the &quot;unfinished code behind a flag&quot; is to be able to work on trunk instead of a long lived branch, increasing the pace of development and reducing integration costs.<p>This works quite well in my experience, and definitely better than &quot;let&#x27;s keep a huge branch in sync with the main one for 3 months while we finish&quot;.<p>The problem IME is the opposite: flags do not get removed fast enough, littering the code past their utility.</div><br/></div></div><div id="37401352" class="c"><input type="checkbox" id="c-37401352" checked=""/><div class="controls bullet"><span class="by">hsn915</span><span>|</span><a href="#37401156">parent</a><span>|</span><a href="#37401294">prev</a><span>|</span><a href="#37401460">next</a><span>|</span><label class="collapse" for="c-37401352">[-]</label><label class="expand" for="c-37401352">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing special about flags that makes them more likely for an intern to delete by mistake.<p>It&#x27;s just code.<p>If the team is so bad that an intern can mess things up, they will, and the mess will have nothing to do with feature flags.</div><br/><div id="37401832" class="c"><input type="checkbox" id="c-37401832" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#37401156">root</a><span>|</span><a href="#37401352">parent</a><span>|</span><a href="#37401460">next</a><span>|</span><label class="collapse" for="c-37401832">[-]</label><label class="expand" for="c-37401832">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t there common patterns of good &quot;just code&quot; and bad &quot;just code&quot;? I&#x27;ve been told for a long time that global variables are a bad pattern. Maybe feature flags are a bad pattern too.<p>One concern about feature flags is testing, and the added permutations of testing needed to include all the feature flags in testing. You tested with flag A on and off, you tested with flag B on and off, but did you ever test with them both on and both off? Without feature flags, a big change that could have been represented by a feature flag would hopefully have to make its way past some quality gates. With feature flags, the exact permutation that you&#x27;re going to cause later today by flipping on some feature flags may well not have been tested. Not that forgetting to test is something you can&#x27;t protect yourself against with tools and processes, but testing all the permutations may be expensive.<p>You may not have to test <i>all</i> the permutations, if you can predict <i>which</i> permutations are relevant for your flipping feature flags later today. But a lot of organizations have poor discipline in cleaning up old feature flags, so it may not be so predictable. Maybe that&#x27;s not a feature flag problem but an organizational problem, but the feature flags are gonna get blamed at some point, nonetheless.</div><br/></div></div></div></div><div id="37401460" class="c"><input type="checkbox" id="c-37401460" checked=""/><div class="controls bullet"><span class="by">wingerlang</span><span>|</span><a href="#37401156">parent</a><span>|</span><a href="#37401352">prev</a><span>|</span><a href="#37401634">next</a><span>|</span><label class="collapse" for="c-37401460">[-]</label><label class="expand" for="c-37401460">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked at a large company where everything was under feature flags, think a dozen teams working on apps alone. We didn&#x27;t push straight to develop, but we definitely had possibly unfinished code on production. For example a feature could be &quot;done&quot; but a bug was found, and the app was already released. That feature flag would simply not be turned on until the next version where it would be fixed.<p>We had a lot of tests for each feature flag variation, both unit and ui tests.<p>The codebase wasn&#x27;t &quot;littered&quot; but there definitely existed unused code under flags, either to-be-used, or to-be-deleted. We had a grafana view of experiments that were old and not yet removed to manage them.<p>Overall we never had incidents around this, to my knowledge anyway.</div><br/></div></div><div id="37401634" class="c"><input type="checkbox" id="c-37401634" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#37401156">parent</a><span>|</span><a href="#37401460">prev</a><span>|</span><a href="#37401939">next</a><span>|</span><label class="collapse" for="c-37401634">[-]</label><label class="expand" for="c-37401634">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This seems like an incident in the making<p>This is how every major tech company works today.</div><br/><div id="37402190" class="c"><input type="checkbox" id="c-37402190" checked=""/><div class="controls bullet"><span class="by">clintonb</span><span>|</span><a href="#37401156">root</a><span>|</span><a href="#37401634">parent</a><span>|</span><a href="#37401939">next</a><span>|</span><label class="collapse" for="c-37402190">[-]</label><label class="expand" for="c-37402190">[1 more]</label></div><br/><div class="children"><div class="content">Not quite. I never used flags to hide unfinished code. I left that on a branch. Feature flags are used to rollout production-ready features.<p>This just seems like taking trunk-based development to an unnecessary extreme.</div><br/></div></div></div></div></div></div><div id="37401939" class="c"><input type="checkbox" id="c-37401939" checked=""/><div class="controls bullet"><span class="by">once_inc</span><span>|</span><a href="#37401156">prev</a><span>|</span><a href="#37398795">next</a><span>|</span><label class="collapse" for="c-37401939">[-]</label><label class="expand" for="c-37401939">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I did an inventory of my recent feature flags and realized that about 80% of them aren’t there to roll things out to specific populations, or do any sort of A&#x2F;B testing, but to hide unfinished code.<p>Which means that for 20% you actually do need the feature flags. So you can&#x27;t do away with the product, and as the author and many of the respondents here have mentioned, there is also a number of benefits to using feature flags.<p>In the trivial case of a feature for a single user still in development; yeah, a boolean is enough. But that is not the intended use case for feature flags, nor is it what the libraries promote you to do.</div><br/></div></div><div id="37398795" class="c"><input type="checkbox" id="c-37398795" checked=""/><div class="controls bullet"><span class="by">huac</span><span>|</span><a href="#37401939">prev</a><span>|</span><a href="#37397992">next</a><span>|</span><label class="collapse" for="c-37398795">[-]</label><label class="expand" for="c-37398795">[2 more]</label></div><br/><div class="children"><div class="content">I wanted a very simple feature flagging solution, so I wrote my own with Google Sheets as the backend: <a href="https:&#x2F;&#x2F;github.com&#x2F;stillmatic&#x2F;flagsheet">https:&#x2F;&#x2F;github.com&#x2F;stillmatic&#x2F;flagsheet</a><p>It&#x27;s slightly more complex than a code push but still very easy to use.</div><br/><div id="37401645" class="c"><input type="checkbox" id="c-37401645" checked=""/><div class="controls bullet"><span class="by">calderwoodra</span><span>|</span><a href="#37398795">parent</a><span>|</span><a href="#37397992">next</a><span>|</span><label class="collapse" for="c-37401645">[-]</label><label class="expand" for="c-37401645">[1 more]</label></div><br/><div class="children"><div class="content">Really nice and simple feature rich solution. Thanks for sharing!</div><br/></div></div></div></div><div id="37397992" class="c"><input type="checkbox" id="c-37397992" checked=""/><div class="controls bullet"><span class="by">perlgeek</span><span>|</span><a href="#37398795">prev</a><span>|</span><a href="#37397683">next</a><span>|</span><label class="collapse" for="c-37397992">[-]</label><label class="expand" for="c-37397992">[3 more]</label></div><br/><div class="children"><div class="content">Feature flags give you orthogonality.<p>When you have an `if False:` or equivalent in code, you have to deploy to enable a new feature, so if the current state in the test environment isn&#x27;t good, you either have to wait for it to be fixed, or to roll back all possibly bad new commits before you can enable the feature.<p>Another feature of feature flags is that a non-coder can toggle them.<p>If you need neither of these, sure, go ahead with commits and deployments instead.</div><br/><div id="37399677" class="c"><input type="checkbox" id="c-37399677" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37397992">parent</a><span>|</span><a href="#37401776">next</a><span>|</span><label class="collapse" for="c-37399677">[-]</label><label class="expand" for="c-37399677">[1 more]</label></div><br/><div class="children"><div class="content">When you&#x27;re trying to triage a production problem or explain what happened between Saturday and today, orthogonality isn&#x27;t a feature, it&#x27;s a challenge to be overcome.</div><br/></div></div><div id="37401776" class="c"><input type="checkbox" id="c-37401776" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37397992">parent</a><span>|</span><a href="#37399677">prev</a><span>|</span><a href="#37397683">next</a><span>|</span><label class="collapse" for="c-37401776">[-]</label><label class="expand" for="c-37401776">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if the current state in the test environment isn&#x27;t good, you either have to wait for it to be fixed, or to roll back all possibly bad new commits before you can enable the feature.<p>This is a symptom of long release cycles. The more work you “save up” to deploy all at once, the more difficult deployments become. Everything becomes much easier when you minimise unreleased work.</div><br/></div></div></div></div><div id="37397683" class="c"><input type="checkbox" id="c-37397683" checked=""/><div class="controls bullet"><span class="by">teeray</span><span>|</span><a href="#37397992">prev</a><span>|</span><a href="#37400913">next</a><span>|</span><label class="collapse" for="c-37397683">[-]</label><label class="expand" for="c-37397683">[5 more]</label></div><br/><div class="children"><div class="content">Anyone have advice for teams without control over when their software is deployed by the people actually running it? Say you have a product released to a third party and they may or may not take releases and may be arbitrarily delayed in deploying those they choose to take.</div><br/><div id="37398563" class="c"><input type="checkbox" id="c-37398563" checked=""/><div class="controls bullet"><span class="by">GrinningFool</span><span>|</span><a href="#37397683">parent</a><span>|</span><a href="#37399224">next</a><span>|</span><label class="collapse" for="c-37398563">[-]</label><label class="expand" for="c-37398563">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re in a for a long tail of pain if you have significant uptake.<p>To avoid this, you will need have a clear policy on what you&#x27;re willing to support (eg versions up to 1 year old, or &quot;major version - 1&quot;, etc.), and stick to it. Otherwise, people will expect you to support all of it, forever.</div><br/><div id="37399706" class="c"><input type="checkbox" id="c-37399706" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37397683">root</a><span>|</span><a href="#37398563">parent</a><span>|</span><a href="#37399224">next</a><span>|</span><label class="collapse" for="c-37399706">[-]</label><label class="expand" for="c-37399706">[2 more]</label></div><br/><div class="children"><div class="content">Bug fix releases never get deployed.<p>If you want people to keep up to date with your releases, you either have to provide an automatic update facility that they have to manually turn off (ugh, too hard), or you have to dangle desirable features as carrots in front of them, so that upgrading is exciting instead of a social obligation.</div><br/><div id="37400783" class="c"><input type="checkbox" id="c-37400783" checked=""/><div class="controls bullet"><span class="by">jcrben</span><span>|</span><a href="#37397683">root</a><span>|</span><a href="#37399706">parent</a><span>|</span><a href="#37399224">next</a><span>|</span><label class="collapse" for="c-37400783">[-]</label><label class="expand" for="c-37400783">[1 more]</label></div><br/><div class="children"><div class="content">My experience is kinda the opposite. Big companies get into certain workflows and don&#x27;t want to change, altho they are happy to take bugfixes. This is also where I&#x27;m at with much of the software I rely upon, some of which I pull at my own whim.</div><br/></div></div></div></div></div></div><div id="37399224" class="c"><input type="checkbox" id="c-37399224" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#37397683">parent</a><span>|</span><a href="#37398563">prev</a><span>|</span><a href="#37400913">next</a><span>|</span><label class="collapse" for="c-37399224">[-]</label><label class="expand" for="c-37399224">[1 more]</label></div><br/><div class="children"><div class="content">Give yourself as much leverage as you can get over their deployment cycles. Use both carrot and stick - Include features they can&#x27;t live without with the hardest of deployment maintenance burdens, and make sure you have tight adherence to your software lifecycle - Every question about 1.0 should be answered with &quot;We don&#x27;t know, 1.0 is out of support&quot; from the second that it&#x27;s EOL date passes.<p>Include the currently running version in every logfile, if not every log statement. Make it clear to you where they are and run your own run-behind that upgrades only after they do. This will be painful, but it will save you overall time.</div><br/></div></div></div></div><div id="37400913" class="c"><input type="checkbox" id="c-37400913" checked=""/><div class="controls bullet"><span class="by">totallywrong</span><span>|</span><a href="#37397683">prev</a><span>|</span><a href="#37401056">next</a><span>|</span><label class="collapse" for="c-37400913">[-]</label><label class="expand" for="c-37400913">[3 more]</label></div><br/><div class="children"><div class="content">TIL there&#x27;s an industry around feature flags. I can see how it can be useful, but imo if you&#x27;re doing the modern approach with k8s, gitops, etc. deployments are too easy to bother with this.</div><br/><div id="37401869" class="c"><input type="checkbox" id="c-37401869" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37400913">parent</a><span>|</span><a href="#37401162">next</a><span>|</span><label class="collapse" for="c-37401869">[-]</label><label class="expand" for="c-37401869">[1 more]</label></div><br/><div class="children"><div class="content">Often it&#x27;s not about only turning something on&#x2F;off (a simple bool). But doing a slow ramp up, only enable for certain cohorts to test etc. Things still doable in code, of course, but it&#x27;s nice with a dashboard to control it.<p>You quickly end up with a NIH thing. You make a boolean toggle in the db. Then make an internal dashboard. Then some more advanced toggles. And suddenly you&#x27;ve spent a few weeks of coding time to essentially save yourself from spinning up an Unleash container.</div><br/></div></div><div id="37401162" class="c"><input type="checkbox" id="c-37401162" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#37400913">parent</a><span>|</span><a href="#37401869">prev</a><span>|</span><a href="#37401056">next</a><span>|</span><label class="collapse" for="c-37401162">[-]</label><label class="expand" for="c-37401162">[1 more]</label></div><br/><div class="children"><div class="content">Even if deployments took 2 seconds you’ll still find a frontend engineer who wants to “iterate faster” and an ear attached to the purse strings who will listen.</div><br/></div></div></div></div><div id="37401056" class="c"><input type="checkbox" id="c-37401056" checked=""/><div class="controls bullet"><span class="by">8ig8</span><span>|</span><a href="#37400913">prev</a><span>|</span><a href="#37400620">next</a><span>|</span><label class="collapse" for="c-37401056">[-]</label><label class="expand" for="c-37401056">[1 more]</label></div><br/><div class="children"><div class="content">Hello, PHP</div><br/></div></div><div id="37400620" class="c"><input type="checkbox" id="c-37400620" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#37401056">prev</a><span>|</span><a href="#37397738">next</a><span>|</span><label class="collapse" for="c-37400620">[-]</label><label class="expand" for="c-37400620">[1 more]</label></div><br/><div class="children"><div class="content">Easy deployments are great, and all too rare. But feature flags are good too.  It&#x27;s actually a trade-off between determinism and control. No flags make the blob deterministic; flags give you control over the blob very late in its runtime. In the limit your feature flags might be set by an admin endpoint (which is very common, actually).<p>But the OP&#x27;s real issue is git, and not wanting to work on a branch. I actually think that&#x27;s a valid goal! I&#x27;ve noticed that many teams have simply moved &quot;one level up&quot; with their git usage. The repo is the new directory; the push is the new commit; etc. You can practice and get fast with it, but it&#x27;s still too many moving parts and plenty of things to go wrong. I actually think that feature flags are too coarse anyway to block off incomplete code; you should probably use conditionals for incomplete code, even if you also have robust feature flag support. The reason is that you never, ever want to dynamically turn incomplete code on, so coupling the flag to a deployment makes perfect sense.</div><br/></div></div><div id="37397738" class="c"><input type="checkbox" id="c-37397738" checked=""/><div class="controls bullet"><span class="by">bsima</span><span>|</span><a href="#37400620">prev</a><span>|</span><label class="collapse" for="c-37397738">[-]</label><label class="expand" for="c-37397738">[13 more]</label></div><br/><div class="children"><div class="content">&gt; I did an inventory of my recent feature flags and realized that about 80% of them aren’t there to roll things out to specific populations, or do any sort of A&#x2F;B testing, but to hide unfinished code.<p>Maybe it’s just me but having unfinished, dead, or scratch code in a production codebase really annoys me. Either finish your work or delete the unneeded code. More than a few times I’ve sunk time out of my day into investigating some code path only to realize it’s completely unused.</div><br/><div id="37400270" class="c"><input type="checkbox" id="c-37400270" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#37397738">parent</a><span>|</span><a href="#37397926">next</a><span>|</span><label class="collapse" for="c-37400270">[-]</label><label class="expand" for="c-37400270">[1 more]</label></div><br/><div class="children"><div class="content">Some changes are too big to fit into a effort. A few years ago, I was working on a niche compiler. When the project was first started, the decision was made to inline everything, greatly simplifying the rest of the compiler [0]. This decision had served us well for the better part of its then 17 year lifetime, but was finally starting to cause issues with compile time and memory usage. One of our senior developers, who was intimately familiar with the project, tried on several occasions to allow for things to not get inlined. However, he kept having to give up as it was a low priority background task, and his branch would diverge from the main branch faster than he could keep his up to date.<p>The solution ended up being a rather simple feature flag. Within a few days, he coded a flag that would enable not-inlinging; and updated our test infastructure to look for regressions on unit tests with the flag enabled. Going forward, developers we responsible for making sure their changes didn&#x27;t cause regression when the flag was enabled; and everyone was able to slowly chip away at everything the feature broke when they had spare cycles.<p>What would have been a major stop-the-world refactor with our most senior engineers, turned into a slow moving non-issue.<p>[0] Lack of turing completeness was and remains an explicit design goal, so recursion was explicitly forbidden.</div><br/></div></div><div id="37397926" class="c"><input type="checkbox" id="c-37397926" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37397738">parent</a><span>|</span><a href="#37400270">prev</a><span>|</span><a href="#37399591">next</a><span>|</span><label class="collapse" for="c-37397926">[-]</label><label class="expand" for="c-37397926">[3 more]</label></div><br/><div class="children"><div class="content">“Unfinished” can mean abandoned, but it can also mean half-baked code that has been pushed to master even though it’s still actively being developed and is nowhere near ready to run. Personally I prefer long-lived feature branches; this is a risk with no payoff.<p>As for experimentation, I like percentage rollouts with segregated control&#x2F;treatment group metrics. I agree that trivial on&#x2F;off flags should be replaced by code deployments where possible (at my day job, code deployments happen to be a lot slower).</div><br/><div id="37399744" class="c"><input type="checkbox" id="c-37399744" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37397926">parent</a><span>|</span><a href="#37400632">next</a><span>|</span><label class="collapse" for="c-37399744">[-]</label><label class="expand" for="c-37399744">[1 more]</label></div><br/><div class="children"><div class="content">Companies have an expectation that most of the code they paid for will eventually ship. Pretending like code might not ever be finished is an odd choice.<p>The exception is experimental work. Obviously experiments aren&#x27;t being merged into master, so they don&#x27;t need to be included in the arithmetic for any processes that eventually involve master.</div><br/></div></div><div id="37400632" class="c"><input type="checkbox" id="c-37400632" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37397926">parent</a><span>|</span><a href="#37399744">prev</a><span>|</span><a href="#37399591">next</a><span>|</span><label class="collapse" for="c-37400632">[-]</label><label class="expand" for="c-37400632">[1 more]</label></div><br/><div class="children"><div class="content">Personally, long-lived branches feel like disaster waiting to materialize since by definition they do not integrate with upstream.<p>Yeah, you might be really responsible and rebase and test your feature frequently, but what about other people? They are more likely to break the integration with your code since they can&#x27;t even see it.</div><br/></div></div></div></div><div id="37399591" class="c"><input type="checkbox" id="c-37399591" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37397738">parent</a><span>|</span><a href="#37397926">prev</a><span>|</span><a href="#37397797">next</a><span>|</span><label class="collapse" for="c-37399591">[-]</label><label class="expand" for="c-37399591">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather have unfinished feature flagged code in master (and therefore production) than have the same unfinished code withering in a long running branch, diverging from master and causing integration problems later.<p>&gt; Either finish your work or delete the unneeded code.<p>It&#x27;s work in progress. We&#x27;re working on getting it finished.</div><br/><div id="37399667" class="c"><input type="checkbox" id="c-37399667" checked=""/><div class="controls bullet"><span class="by">rvrs</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37399591">parent</a><span>|</span><a href="#37397797">next</a><span>|</span><label class="collapse" for="c-37399667">[-]</label><label class="expand" for="c-37399667">[6 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s work in progress. We&#x27;re working on getting it finished.<p>So finish it and then I will merge your PR ;) What&#x27;s the use of putting it in master if it&#x27;s not finished?<p>It&#x27;s the author&#x27;s responsibility to get it merged successfully. If they&#x27;re taking too long and have to rebase and re-work their code to integrate, that&#x27;s on them.  Pushing it into master is either wasting a reader&#x27;s time (per the original comment) or, worse, inviting an uninitiated collaborator to use it and cause an incident.</div><br/><div id="37400868" class="c"><input type="checkbox" id="c-37400868" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37399667">parent</a><span>|</span><a href="#37399729">next</a><span>|</span><label class="collapse" for="c-37400868">[-]</label><label class="expand" for="c-37400868">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So finish it and then I will merge your PR ;) What&#x27;s the use of putting it in master if it&#x27;s not finished?<p>Because of the thing I said in the sentence before the one you quoted.<p>&gt; If they&#x27;re taking too long and have to rebase and re-work their code to integrate, that&#x27;s on them.<p>No, in the organisations I build, we work as a team and if someone is taking too long it&#x27;s because we don&#x27;t have the systems in place to help them work faster. There is very clear research on the benefits of working in small batches and integrating continuously. If that research has passed you by then I strongly suggest you go back and take a look.</div><br/></div></div><div id="37399729" class="c"><input type="checkbox" id="c-37399729" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37399667">parent</a><span>|</span><a href="#37400868">prev</a><span>|</span><a href="#37401058">next</a><span>|</span><label class="collapse" for="c-37399729">[-]</label><label class="expand" for="c-37399729">[3 more]</label></div><br/><div class="children"><div class="content">Somewhere along the way, a new generation of developers thought that &#x27;Continuous Integration&#x27; means &quot;automated builds&quot;.  I wonder what they think that &#x27;integration&#x27; word is doing there?<p>Since you&#x27;re here, I&#x27;ll ask you. What do you think &#x27;integration&#x27; means in this context?</div><br/><div id="37399861" class="c"><input type="checkbox" id="c-37399861" checked=""/><div class="controls bullet"><span class="by">rvrs</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37399729">parent</a><span>|</span><a href="#37401058">next</a><span>|</span><label class="collapse" for="c-37399861">[-]</label><label class="expand" for="c-37399861">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Passing CI&quot; is a low bar -- it is only a single layer of defense. Moreover, code has syntactic properties that aren&#x27;t necessarily evaluated by CI. My comment claimed that there are readability and usability concerns with unfinished code. This is why we have code review. CI is a signal that the code is good to merge, but as a code reviewer, I have the final say. I don&#x27;t merge unfinished code.<p>If CI passes on your branch but later fails due to lagging behind master, it is on you to get it working before re-requesting review.<p>PS: The HN guidelines clearly state &quot;Be kind. Don&#x27;t be snarky.&quot; (:</div><br/><div id="37400335" class="c"><input type="checkbox" id="c-37400335" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37399861">parent</a><span>|</span><a href="#37401058">next</a><span>|</span><label class="collapse" for="c-37400335">[-]</label><label class="expand" for="c-37400335">[1 more]</label></div><br/><div class="children"><div class="content">Continous Integration is a development methodology, not an automated process. The idea is that developers continuously merge their changes into a shared integration branch. Having long running feature branches that get merged when they are done is a valid methodology, but it is not continuous integration; no matter what your automated build and test pipeline calls it.<p>In practice, I have typically seen CI done with either feature freezes, or release branches to allow creating versions where everything is complete.</div><br/></div></div></div></div></div></div><div id="37401058" class="c"><input type="checkbox" id="c-37401058" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37397738">root</a><span>|</span><a href="#37399667">parent</a><span>|</span><a href="#37399729">prev</a><span>|</span><a href="#37397797">next</a><span>|</span><label class="collapse" for="c-37401058">[-]</label><label class="expand" for="c-37401058">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s the use of putting it in master if it&#x27;s not finished?<p>Visibility, and avoiding duplicated effort. What&#x27;s the use of keeping it out of master?<p>&gt; Pushing it into master is either wasting a reader&#x27;s time (per the original comment)<p>The new parts they&#x27;ll have to read sooner or later, and for the parts that are changing it&#x27;s better for them to read the new version than the old version.<p>&gt; or, worse, inviting an uninitiated collaborator to use it and cause an incident.<p>Why would that cause an incident? Having someone see the &quot;upcoming&quot; code and realise they can reuse it in something they&#x27;re working on is the ideal outcome.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>