<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693126853352" as="style"/><link rel="stylesheet" href="styles.css?v=1693126853352"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://openwrt.org/docs/techref/ubus">Ubus (OpenWrt micro bus architecture)</a> <span class="domain">(<a href="https://openwrt.org">openwrt.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>19 comments</span></div><br/><div><div id="37280542" class="c"><input type="checkbox" id="c-37280542" checked=""/><div class="controls bullet"><span class="by">xgbi</span><span>|</span><a href="#37280644">next</a><span>|</span><label class="collapse" for="c-37280542">[-]</label><label class="expand" for="c-37280542">[1 more]</label></div><br/><div class="children"><div class="content">Story time.. I coded a similar thing when I started working after graduation for a DTV software company; we needed to have an IPC on Linux and I whipped up some very crude equivalent of protobuf (which I didn’t know about), based on an RLE lib i stumbled upon and without any form of discovery.<p>It was circa 2009, I had only been exposed to plain text protocols and didn’t know about json. In hindsight, we might’ve been better using standard dbus, of protobuf, but I was a rookie and it provided the performance we needed (for DTV metadata).<p>I’m happy to see that these can still thrive, and I just recently figured out that discovery is a net multiplier in these projects; doing this really proved me that any problem is solvable if you can have some time to think about it and can prototype.<p>I long for these moments now, I feel like nearly all computing issues have been solved and we are now just plumbers, connecting libraries and software modules through config files instead of building things.</div><br/></div></div><div id="37280644" class="c"><input type="checkbox" id="c-37280644" checked=""/><div class="controls bullet"><span class="by">attah_</span><span>|</span><a href="#37280542">prev</a><span>|</span><a href="#37280674">next</a><span>|</span><label class="collapse" for="c-37280644">[-]</label><label class="expand" for="c-37280644">[3 more]</label></div><br/><div class="children"><div class="content">In case you want to react to stuff connecting to your router via ubus:<p>iw event |  awk &#x27;&#x2F;new station&#x2F; {print $4}&#x27; | xargs -n 1 sh -c &#x27;ubus send new_station {\&quot;mac\&quot;:\&quot;$1\&quot;}&#x27; _<p>(Yes, this contains silly hacks to work around busybox limitations)</div><br/><div id="37280700" class="c"><input type="checkbox" id="c-37280700" checked=""/><div class="controls bullet"><span class="by">phoronixrly</span><span>|</span><a href="#37280644">parent</a><span>|</span><a href="#37280674">next</a><span>|</span><label class="collapse" for="c-37280700">[-]</label><label class="expand" for="c-37280700">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure that there already is an event emmitted upon station connection</div><br/><div id="37280735" class="c"><input type="checkbox" id="c-37280735" checked=""/><div class="controls bullet"><span class="by">attah_</span><span>|</span><a href="#37280644">root</a><span>|</span><a href="#37280700">parent</a><span>|</span><a href="#37280674">next</a><span>|</span><label class="collapse" for="c-37280735">[-]</label><label class="expand" for="c-37280735">[1 more]</label></div><br/><div class="children"><div class="content">Certainly not by default anyway. That would have been great though.
Double-checked with ubus listen in case it had changed over the last couple of years.</div><br/></div></div></div></div></div></div><div id="37280674" class="c"><input type="checkbox" id="c-37280674" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#37280644">prev</a><span>|</span><a href="#37280325">next</a><span>|</span><label class="collapse" for="c-37280674">[-]</label><label class="expand" for="c-37280674">[1 more]</label></div><br/><div class="children"><div class="content">Source code:<p><a href="https:&#x2F;&#x2F;git.openwrt.org&#x2F;?p=project&#x2F;ubus.git;a=tree;h=refs&#x2F;heads&#x2F;master;hb=refs&#x2F;heads&#x2F;master" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.openwrt.org&#x2F;?p=project&#x2F;ubus.git;a=tree;h=refs&#x2F;he...</a></div><br/></div></div><div id="37280325" class="c"><input type="checkbox" id="c-37280325" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37280674">prev</a><span>|</span><label class="collapse" for="c-37280325">[-]</label><label class="expand" for="c-37280325">[13 more]</label></div><br/><div class="children"><div class="content">Did they consider using a memory-safe language for this?</div><br/><div id="37280593" class="c"><input type="checkbox" id="c-37280593" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37280325">parent</a><span>|</span><a href="#37280363">next</a><span>|</span><label class="collapse" for="c-37280593">[-]</label><label class="expand" for="c-37280593">[2 more]</label></div><br/><div class="children"><div class="content">There is no real case to be made against the idea of memory safety, but there is a case to be made for C.<p>You can write C code such that its unit tested, fuzzed, statically analyzed and reviewed, and often embedded code has one or two specific jobs.<p>I would have loved to see Zig here, as it makes all of the above (testing, analysis, code clarity for review) easier, but its also not memory safe necessarily.<p>You could write it in D with @safe (which is SafeD or whatever), which is memory safe, but thats not a very popular language.<p>You could use Ada, but again, thats not as easy to find devs for as C is.<p>You could use Go or Ocaml, though go isn&#x27;t really memory safe and you can easily cause data races in goroutines, and ocaml has a runtime afaik so thats out of the question for low memory devices.<p>You could use Rust, assuming it had existed back when they started it, and you would get memory safety, but also an entire kitchen sink of useless garbage (like C++). Youd also have to shell out to unsafe{} in a lot of places, unless you use a crate for it, which will then do unsafe{} for you.<p>So chances are, whatever you do, C is a pretty sane choice, or maybe C++ if you want RAII to at least make your resource management and lifetimes easy to handle.<p>I dont think you deserve to be downvoted, since this is an interesting discussion to have. However, I think it would have been helpful for the discussion if you had outlined which language youd suggest and why.<p>To Steelman your argument, I would say you think that C is unsafe to such a degree that even a for loop is UB most of the time (integer overflow as UB), no real way to check array bounds, no real way to catch off-by-one and similarly stupid simple errors, use after free, egc. and that the entire ecosystem relies on raw pointers and macros, and its a shitshow. I think your point would have been to suggest Rust, as it fixes all these issues, while bringing along a stronger type system and a better toolchain.</div><br/><div id="37280737" class="c"><input type="checkbox" id="c-37280737" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280593">parent</a><span>|</span><a href="#37280363">next</a><span>|</span><label class="collapse" for="c-37280737">[-]</label><label class="expand" for="c-37280737">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You could use Rust, assuming it had existed back when they started it, and you would get memory safety, but also an entire kitchen sink of useless garbage (like C++). Youd also have to shell out to unsafe{} in a lot of places, unless you use a crate for it, which will then do unsafe{} for you.<p>I&#x27;m not saying C is a wrong choice here, but this argument doesn&#x27;t make much sense to me. All the other languages also come with &quot;useless garbage&quot; (some even with a collector for them). I don&#x27;t see why you&#x27;d need that many unsafe blocks either.<p>I feel like Rust, as a language, is much better equipped for writing a daemon like this. I&#x27;ll even go as far as to say that modern C++ (C++2x) is a better choice than C for this stuff with its superior memory and resource management tools.<p>Of course most of the OpenWRT development is done in C, so doing it in another language requires a very good reason. I wouldn&#x27;t look at the concept of &quot;a networked daemon exchanging messages between arbitrary services&quot; and think C of all languages is a good fit unless every other developer on the team can only write C.<p>Zig would&#x27;ve been a nice way to meet halfway, but the language isn&#x27;t finished yet.<p>Of course the point is moot because this particular project existed years before any of the modern alternatives or many of the C++ improvements were even available. Still, if they&#x27;d start a project like this again, I&#x27;d hope they&#x27;d pick a better language for it.</div><br/></div></div></div></div><div id="37280363" class="c"><input type="checkbox" id="c-37280363" checked=""/><div class="controls bullet"><span class="by">Roark66</span><span>|</span><a href="#37280325">parent</a><span>|</span><a href="#37280593">prev</a><span>|</span><a href="#37280389">next</a><span>|</span><label class="collapse" for="c-37280363">[-]</label><label class="expand" for="c-37280363">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea if they did. C is a &quot;default choice&quot; in embedded systems.<p>I don&#x27;t know if we now have a better alternative that is similar in speed, ram use and binary size.<p>If we do I&#x27;d would read a discussion on which one to use with interest.</div><br/></div></div><div id="37280389" class="c"><input type="checkbox" id="c-37280389" checked=""/><div class="controls bullet"><span class="by">btgeekboy</span><span>|</span><a href="#37280325">parent</a><span>|</span><a href="#37280363">prev</a><span>|</span><a href="#37280344">next</a><span>|</span><label class="collapse" for="c-37280389">[-]</label><label class="expand" for="c-37280389">[8 more]</label></div><br/><div class="children"><div class="content">Considering the repo dates back to 2010 (predating Rust by 4+ years), there probably wasn’t a better option that could run on the embedded devices that OpenWRT targets.</div><br/><div id="37280462" class="c"><input type="checkbox" id="c-37280462" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280389">parent</a><span>|</span><a href="#37280344">next</a><span>|</span><label class="collapse" for="c-37280462">[-]</label><label class="expand" for="c-37280462">[7 more]</label></div><br/><div class="children"><div class="content">The project age is good background info. However Rust didn&#x27;t invent memory-safety, there were reasonable options  for system programming at that time too (eg Ocaml, Go, Ada,  etc).<p>edit: Also D in safe mode like mentioend above - not sure if it was around in 2010?</div><br/><div id="37280526" class="c"><input type="checkbox" id="c-37280526" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280462">parent</a><span>|</span><a href="#37280344">next</a><span>|</span><label class="collapse" for="c-37280526">[-]</label><label class="expand" for="c-37280526">[6 more]</label></div><br/><div class="children"><div class="content">I think any language with a large runtime would be out of the question, because Openwrt has to fit into system with very limited storage.</div><br/><div id="37280590" class="c"><input type="checkbox" id="c-37280590" checked=""/><div class="controls bullet"><span class="by">josteink</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280526">parent</a><span>|</span><a href="#37280344">next</a><span>|</span><label class="collapse" for="c-37280590">[-]</label><label class="expand" for="c-37280590">[5 more]</label></div><br/><div class="children"><div class="content">To put it in context:<p>On some devices you have 32MB flash storage <i>in total</i>.<p>32 Megabytes, not gigabytes. This is not a typo.<p>This needs to fit the bootloader, the Linux kernel, the initrd, the rootfs containing all the user-space tools making OpenWRT an actual usable OS and whatever daemons you need to implement your particular network needs. Oh and you probably want the WebUI too.<p><i>In 32MBs.</i> There are newspapers online which loads more than that just to show the front page!<p>There’s no room for 2MB HelloWorld type languages in this space.</div><br/><div id="37280641" class="c"><input type="checkbox" id="c-37280641" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280590">parent</a><span>|</span><a href="#37280647">next</a><span>|</span><label class="collapse" for="c-37280641">[-]</label><label class="expand" for="c-37280641">[3 more]</label></div><br/><div class="children"><div class="content">This is a good point. But Ocaml and Ada are not in the 2MB helloworld club (eg Ocaml is more like 200k), don&#x27;t know about Go. Also accounting that to a single binary is not the right perspective I think - adopting a safe language in OpenWRT should be arranged so that all the programs using that language can share the same copy of the runtime.</div><br/><div id="37280717" class="c"><input type="checkbox" id="c-37280717" checked=""/><div class="controls bullet"><span class="by">phoronixrly</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280641">parent</a><span>|</span><a href="#37280647">next</a><span>|</span><label class="collapse" for="c-37280717">[-]</label><label class="expand" for="c-37280717">[2 more]</label></div><br/><div class="children"><div class="content">200k is very large in the OpenWrt world</div><br/><div id="37280752" class="c"><input type="checkbox" id="c-37280752" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280717">parent</a><span>|</span><a href="#37280647">next</a><span>|</span><label class="collapse" for="c-37280752">[-]</label><label class="expand" for="c-37280752">[1 more]</label></div><br/><div class="children"><div class="content">Ada then?<p>Eg on <a href="https:&#x2F;&#x2F;ada.godbolt.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ada.godbolt.org&#x2F;</a> you can see the default program compiled to ~25 lines of assembler.<p>edit: actually it contains a call to a bounds check function that presumably is in the runtime library, i don&#x27;t know how big that is.<p>A major point in this is that C also has a fairly big runtime library that should be factored into the comparison!</div><br/></div></div></div></div></div></div><div id="37280647" class="c"><input type="checkbox" id="c-37280647" checked=""/><div class="controls bullet"><span class="by">mlichvar</span><span>|</span><a href="#37280325">root</a><span>|</span><a href="#37280590">parent</a><span>|</span><a href="#37280641">prev</a><span>|</span><a href="#37280344">next</a><span>|</span><label class="collapse" for="c-37280647">[-]</label><label class="expand" for="c-37280647">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s even less than that. Current OpenWrt versions work on devices with 8 MB of flash and 64 MB of RAM. OpenWrt 19.07 worked on 4MB&#x2F;32MB devices.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>