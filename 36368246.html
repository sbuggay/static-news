<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686992467816" as="style"/><link rel="stylesheet" href="styles.css?v=1686992467816"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://epage.github.io/blog/2023/06/iterating-on-test/">Iterating on Testing in Rust</a> <span class="domain">(<a href="https://epage.github.io">epage.github.io</a>)</span></div><div class="subtext"><span>lukastyrychtr</span> | <span>6 comments</span></div><br/><div><div id="36368516" class="c"><input type="checkbox" id="c-36368516" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36368329">next</a><span>|</span><label class="collapse" for="c-36368516">[-]</label><label class="expand" for="c-36368516">[1 more]</label></div><br/><div class="children"><div class="content">All problems they&#x27;re facing are due to the decision to make tests a &quot;special case&quot; rather than just normal Rust code that happens to test things.<p>While I like Rust&#x27;s `[#test]` can be placed anywhere and will be found&#x2F;run by cargo test, I think there should also be something like `[#test_context]` where you receive a handle to the test framework&#x27;s entry point (a little like Go) and from there you just write code to create tests... this is a stupid simple way to solve every problem mentioned in this post. Dart has something like this, and it&#x27;s amazing for me to realize that is totally simplistic solution makes everything those complex Java testing frameworks do (test by example cases, skip depending on a function&#x27;s return value, group tests into sub-tests etc.).<p>This is what it may look like in Rust:<p><pre><code>    #[test_context]
    fn make_tests(t: &amp;mut TestHarness) {
        t.newGroup(&quot;group 1&quot;, |t| {
            t.newTest(&quot;test something&quot;, |t| {
              assert_eq(...);
            });
            for (input, expected) in &amp;[(&quot;a&quot;, &quot;a1&quot;), (&quot;b&quot;, &quot;b1&quot;)] {
              t.newTest(format!(&quot;my_fun({}) == {}&quot;, input, expected), || {
                assert_eq(my_fun(input), expected);
              }),
            }
        });
    }</code></pre></div><br/></div></div><div id="36368329" class="c"><input type="checkbox" id="c-36368329" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#36368516">prev</a><span>|</span><a href="#36368457">next</a><span>|</span><label class="collapse" for="c-36368329">[-]</label><label class="expand" for="c-36368329">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Test generation<p>&gt; Data driven tests are an easy way to cover a lot of cases (granted, property testing is even better). The most trivial way of doing this is just looping over your cases<p>&gt; […]<p>&gt; You don&#x27;t know which input was being processed on failure (without extra steps)<p>&gt; Any debug output from prior iterations will flood the display when analyzing a failure<p>For generating separate tests for different inputs, keeping it easy to see which input failed the test I use the test-case crate <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;test-case" rel="nofollow noreferrer">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;test-case</a><p>Here’s an example from the test-case readme:<p><pre><code>    #[cfg(test)]
    mod tests {
        use test_case::test_case;

        #[test_case(-2, -4 ; &quot;when both operands are negative&quot;)]
        #[test_case(2,  4  ; &quot;when both operands are positive&quot;)]
        #[test_case(4,  2  ; &quot;when operands are swapped&quot;)]
        fn multiplication_tests(x: i8, y: i8) {
            let actual = (x * y).abs();

            assert_eq!(8, actual)
        }
    }
</code></pre>
And then when you run<p><pre><code>    cargo test
</code></pre>
You get this output:<p><pre><code>    running 4 tests
    test tests::multiplication_tests::when_both_operands_are_negative ... ok
    test tests::multiplication_tests::when_both_operands_are_positive ... ok
    test tests::multiplication_tests::when_operands_are_swapped ... ok
    
    test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code></pre></div><br/><div id="36368399" class="c"><input type="checkbox" id="c-36368399" checked=""/><div class="controls bullet"><span class="by">mqus</span><span>|</span><a href="#36368329">parent</a><span>|</span><a href="#36368347">next</a><span>|</span><label class="collapse" for="c-36368399">[-]</label><label class="expand" for="c-36368399">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty good, but since it&#x27;s static, you can&#x27;t use parameter generating methods (e.g. for combinatorial input or derived tests). And if you do that within the test, you&#x27;re back to having to manage those on your own. JUnit&amp;AssertJ really do have advantages on Rust here.</div><br/></div></div><div id="36368347" class="c"><input type="checkbox" id="c-36368347" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36368329">parent</a><span>|</span><a href="#36368399">prev</a><span>|</span><a href="#36368457">next</a><span>|</span><label class="collapse" for="c-36368347">[-]</label><label class="expand" for="c-36368347">[1 more]</label></div><br/><div class="children"><div class="content">This is so cool, I haven&#x27;t seen this ... Python I think? The doctest I think it was called.<p>But at compile time without static analysis tools, this is so cool.</div><br/></div></div></div></div><div id="36368457" class="c"><input type="checkbox" id="c-36368457" checked=""/><div class="controls bullet"><span class="by">Deukhoofd</span><span>|</span><a href="#36368329">prev</a><span>|</span><label class="collapse" for="c-36368457">[-]</label><label class="expand" for="c-36368457">[1 more]</label></div><br/><div class="children"><div class="content">I have to agree, every time I&#x27;m writing unit tests in Rust I&#x27;m struck by how extremely limited it is compared to testing frameworks in other languages, and how much effort is needed to get some fairly standard stuff like data tests to work. It&#x27;s definitely something that needs attention.</div><br/></div></div></div></div></div></div></div></body></html>