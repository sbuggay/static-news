<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728723674136" as="style"/><link rel="stylesheet" href="styles.css?v=1728723674136"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.0x74696d.com/posts/iouring-and-seccomp/">Io_uring and seccomp (2022)</a> <span class="domain">(<a href="https://blog.0x74696d.com">blog.0x74696d.com</a>)</span></div><div class="subtext"><span>pncnmnp</span> | <span>20 comments</span></div><br/><div><div id="41814125" class="c"><input type="checkbox" id="c-41814125" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#41813440">next</a><span>|</span><label class="collapse" for="c-41814125">[-]</label><label class="expand" for="c-41814125">[1 more]</label></div><br/><div class="children"><div class="content">Using seccomp with a default-open filter is a terrible idea to begin with; it wasn&#x27;t really designed for any of this. Seccomp in its most basic form didn&#x27;t even have a filter list, it just allowed read() and write(). (And close() or something, don&#x27;t quote me on the details, the point is it was a fixed list.) You&#x27;re supposed to use it with a default-closed filter and fully enumerate what you need. (Yes, that&#x27;s hard in a lot of cases, but still.)<p>There have been other cases where syscalls got cloned, mostly to add new parameters, but either way seccomp with an &quot;open&quot; filter can only ever be defense-in-depth, not a critical line in itself.<p>(Don&#x27;t misunderstand, defense-in-depth is good, and keep using seccomp for it. But an open seccomp filter MUST be considered  bypassable.)</div><br/></div></div><div id="41813440" class="c"><input type="checkbox" id="c-41813440" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41814125">prev</a><span>|</span><a href="#41816276">next</a><span>|</span><label class="collapse" for="c-41813440">[-]</label><label class="expand" for="c-41813440">[2 more]</label></div><br/><div class="children"><div class="content">This seems like an instance of an anti-pattern I&#x27;ve seen, which is inflating &quot;permission&quot; and &quot;API call&quot; to the same thing.<p>IIRC, AWS does this, where permission is by API call. As an example, you can have permission to call ssm:GetParameter <i>n</i> times, but if you try to combine those <i>n</i> API calls into a batch with GetParameters, that&#x27;s a different IAM perm, <i>even though exactly the same thing is occurring.</i></div><br/><div id="41816236" class="c"><input type="checkbox" id="c-41816236" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41813440">parent</a><span>|</span><a href="#41816276">next</a><span>|</span><label class="collapse" for="c-41816236">[-]</label><label class="expand" for="c-41816236">[1 more]</label></div><br/><div class="children"><div class="content">I find that so frustrating. Another example is uploading an image to ECR (elastic container registry). You need like four different permissions to do it, which I think correspond to individual http requests, but it is usually just a single docker&#x2F;podman&#x2F;skopeo command, and I can&#x27;t think of a situation where you would want to grant permission to initiate an upload but not complete it.<p>Multipart uploads in s3 have a similar problem.</div><br/></div></div></div></div><div id="41816276" class="c"><input type="checkbox" id="c-41816276" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#41813440">prev</a><span>|</span><a href="#41813454">next</a><span>|</span><label class="collapse" for="c-41816276">[-]</label><label class="expand" for="c-41816276">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking about how one would change io_uring design to be compatible with seccomp, and came up with a very simple one:<p>A new io_uring fd comes with all operations disabled by default. User has to call &quot;io_uring_register(fd, ENABLE_OP,  op)&quot; before operation is used for the first time. Then seccomp filter can easily filter enable_op calls to prohibit certain operations.<p>It could even be added now in backward-compatible way - add a new feature to io_uring_setup that enables it. Then one could set seccomp filter to only accept setup requests with this feature set, and deny all others. Together, this should allow cooperating programs to pass seccomp filter, while programs that won&#x27;t register ops could not use seccomp at all.</div><br/></div></div><div id="41813454" class="c"><input type="checkbox" id="c-41813454" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#41816276">prev</a><span>|</span><a href="#41815314">next</a><span>|</span><label class="collapse" for="c-41813454">[-]</label><label class="expand" for="c-41813454">[6 more]</label></div><br/><div class="children"><div class="content">Both Docker and containerd have started to block io_uring in the default profile for about a year now due to too many security issues with it.</div><br/><div id="41814795" class="c"><input type="checkbox" id="c-41814795" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#41813454">parent</a><span>|</span><a href="#41813781">next</a><span>|</span><label class="collapse" for="c-41814795">[-]</label><label class="expand" for="c-41814795">[1 more]</label></div><br/><div class="children"><div class="content">And Google, in ChromeOS, Android, and purportedly, Google production servers, for around a year and a half, as well. For this reason it&#x27;s also disabled in several of the kernelCTF configurations and in the ones where it remains (GKE), it only pays out at half-rate in bug bounty.</div><br/></div></div><div id="41813781" class="c"><input type="checkbox" id="c-41813781" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41813454">parent</a><span>|</span><a href="#41814795">prev</a><span>|</span><a href="#41815314">next</a><span>|</span><label class="collapse" for="c-41813781">[-]</label><label class="expand" for="c-41813781">[4 more]</label></div><br/><div class="children"><div class="content">Has anyone speculated yet about how much slower a secure io_uring has to be? Is it still a net win once you lock it down fully?</div><br/><div id="41815378" class="c"><input type="checkbox" id="c-41815378" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#41813454">root</a><span>|</span><a href="#41813781">parent</a><span>|</span><a href="#41815702">next</a><span>|</span><label class="collapse" for="c-41815378">[-]</label><label class="expand" for="c-41815378">[2 more]</label></div><br/><div class="children"><div class="content">As far as I know, io_uring is quite secure: a user cannot perform a syscall through it unless it has the privileges required to perform this syscall directly<p>I would gladly get more details about the exact purpose of seccomp in a container environment. Reading a bit of internet, I find that docker &quot;uses seccomp to block mount(2), which could be used to escape the container&quot;, which makes no sense to me because mount(2) requires CAP_SYS_ADMIN</div><br/><div id="41815693" class="c"><input type="checkbox" id="c-41815693" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#41813454">root</a><span>|</span><a href="#41815378">parent</a><span>|</span><a href="#41815702">next</a><span>|</span><label class="collapse" for="c-41815693">[-]</label><label class="expand" for="c-41815693">[1 more]</label></div><br/><div class="children"><div class="content">io_uring cve&#x27;s: <a href="https:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvekey.cgi?keyword=io_uring" rel="nofollow">https:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvekey.cgi?keyword=io_uring</a><p>seccomp is used for defense in depth.
If someone managed to escalate privileges through some means the seccomp policy will still prevent them from doing nasty things or escalating further.</div><br/></div></div></div></div><div id="41815702" class="c"><input type="checkbox" id="c-41815702" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#41813454">root</a><span>|</span><a href="#41813781">parent</a><span>|</span><a href="#41815378">prev</a><span>|</span><a href="#41815314">next</a><span>|</span><label class="collapse" for="c-41815702">[-]</label><label class="expand" for="c-41815702">[1 more]</label></div><br/><div class="children"><div class="content">That would be impossible to know.
The main thing with io_uring is it makes it so you don&#x27;t need to context switch (ie make system calls) to perform a number of operations.</div><br/></div></div></div></div></div></div><div id="41815314" class="c"><input type="checkbox" id="c-41815314" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41813454">prev</a><span>|</span><a href="#41812459">next</a><span>|</span><label class="collapse" for="c-41815314">[-]</label><label class="expand" for="c-41815314">[4 more]</label></div><br/><div class="children"><div class="content">Surely this is a seccomp shortcoming, or kernel auth shortcoming, rather than an io_uring problem?<p>That is, seccomp is (apparently? I’ve never used it myself) capable of intercepting direct calls. Obviously, that design isn’t going to be able to handle “indirect” calls in its default implementation.<p>Either seccomp needs a way to act on the buffer or intercept io_uring calls, or there’s a need for a new auth mechanism that’s capable of handling io_uring style API’s.<p>Torpedoing the whole api (a la gcp) feels like throwing the baby out with the bath water.</div><br/><div id="41815755" class="c"><input type="checkbox" id="c-41815755" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41815314">parent</a><span>|</span><a href="#41812459">next</a><span>|</span><label class="collapse" for="c-41815755">[-]</label><label class="expand" for="c-41815755">[3 more]</label></div><br/><div class="children"><div class="content">That framing doesn&#x27;t make sense. System calls and their arguments are an obvious security boundary and have been a sandboxing component for decades. io_uring blows that boundary apart. The &quot;problem&quot; is io_uring, not seccomp.<p>If you want to make a case for io_uring being benign for security, the right argument is probably against all unmediated shared-kernel multitenancy (ie: multitenancy either through virtualization, or WASM&#x2F;V8-type language runtimes, and nothing else). It doesn&#x27;t make sense to say system call filters are flawed because someone came up with an omni-syscall that breaks those filters.</div><br/><div id="41816289" class="c"><input type="checkbox" id="c-41816289" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41815314">root</a><span>|</span><a href="#41815755">parent</a><span>|</span><a href="#41816924">next</a><span>|</span><label class="collapse" for="c-41816289">[-]</label><label class="expand" for="c-41816289">[1 more]</label></div><br/><div class="children"><div class="content">The syscall implementations themselves do checks and return EPERM&#x2F;EACCES when appropriate. The mechanism for doing the syscall can change. I mean, in the 90s it happened via int 0x80, then we got sysenter, then the vdso. io_uring just moved part of it to user mode.<p>It seems like a totally reasonable design to me to &quot;just&quot; put the right hooks into the filter mechanism and make it get called the same way regardless of the syscall mechanism.</div><br/></div></div><div id="41816924" class="c"><input type="checkbox" id="c-41816924" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41815314">root</a><span>|</span><a href="#41815755">parent</a><span>|</span><a href="#41816289">prev</a><span>|</span><a href="#41812459">next</a><span>|</span><label class="collapse" for="c-41816924">[-]</label><label class="expand" for="c-41816924">[1 more]</label></div><br/><div class="children"><div class="content">The obvious solution is to block operations over io_uring if the equivalent syscall would have been blocked by seccomp. But I&#x27;m not sure if there is some reason that wouldn&#x27;t work.<p>Another possibility would be to allow setting restrictions on all io_uring operations for the current and all child processes, although that would be less convenient than using the existing seccomp system.</div><br/></div></div></div></div></div></div><div id="41812459" class="c"><input type="checkbox" id="c-41812459" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41815314">prev</a><span>|</span><a href="#41815666">next</a><span>|</span><label class="collapse" for="c-41812459">[-]</label><label class="expand" for="c-41812459">[4 more]</label></div><br/><div class="children"><div class="content">&gt; But if you&#x27;ve got a separation of duties where a sysadmin sets up seccomp filtering generically across applications<p>Is this even possible, regardless of io_uring?</div><br/><div id="41813146" class="c"><input type="checkbox" id="c-41813146" checked=""/><div class="controls bullet"><span class="by">amarshall</span><span>|</span><a href="#41812459">parent</a><span>|</span><a href="#41816028">next</a><span>|</span><label class="collapse" for="c-41813146">[-]</label><label class="expand" for="c-41813146">[2 more]</label></div><br/><div class="children"><div class="content">Well the article brings up containers as an example. If the sysadmin controls “your” parent or root process (e.g. the login shell), they can just perform seccomp filtering there and it applies to everything within it (like any other sandbox).</div><br/><div id="41815680" class="c"><input type="checkbox" id="c-41815680" checked=""/><div class="controls bullet"><span class="by">0x74696d</span><span>|</span><a href="#41812459">root</a><span>|</span><a href="#41813146">parent</a><span>|</span><a href="#41816028">next</a><span>|</span><label class="collapse" for="c-41815680">[-]</label><label class="expand" for="c-41815680">[1 more]</label></div><br/><div class="children"><div class="content">(author here) I&#x27;m one of the maintainers of HashiCorp&#x27;s Nomad, so that example was likely inspired by the separation of duties that&#x27;s part of our security model. In that environment, there&#x27;s a subset of task (ex. container) configuration that&#x27;s controlled by the cluster admin and a subset that&#x27;s controlled by the job author deploying onto the cluster.</div><br/></div></div></div></div><div id="41816028" class="c"><input type="checkbox" id="c-41816028" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#41812459">parent</a><span>|</span><a href="#41813146">prev</a><span>|</span><a href="#41815666">next</a><span>|</span><label class="collapse" for="c-41816028">[-]</label><label class="expand" for="c-41816028">[1 more]</label></div><br/><div class="children"><div class="content">Yes- systemd will let you do that, as well docker&#x2F;containerd&#x2F;podman.</div><br/></div></div></div></div><div id="41815666" class="c"><input type="checkbox" id="c-41815666" checked=""/><div class="controls bullet"><span class="by">0x74696d</span><span>|</span><a href="#41812459">prev</a><span>|</span><label class="collapse" for="c-41815666">[-]</label><label class="expand" for="c-41815666">[1 more]</label></div><br/><div class="children"><div class="content">Author here! The motivating example of this post is frankly pretty lousy in retrospect (and was even so soon after writing, given the friendly reminder from Giovanni Campagna that `socket` wasn&#x27;t one of the io_uring opcodes). At best this is an interesting limitation of seccomp. Maybe relevant if you were using gVisor?</div><br/></div></div></div></div></div></div></div></body></html>