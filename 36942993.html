<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690880459345" as="style"/><link rel="stylesheet" href="styles.css?v=1690880459345"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://unum-cloud.github.io/usearch/">USearch: Smaller and faster single-file vector search engine</a> <span class="domain">(<a href="https://unum-cloud.github.io">unum-cloud.github.io</a>)</span></div><div class="subtext"><span>0xedb</span> | <span>45 comments</span></div><br/><div><div id="36952095" class="c"><input type="checkbox" id="c-36952095" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36948260">next</a><span>|</span><label class="collapse" for="c-36952095">[-]</label><label class="expand" for="c-36952095">[12 more]</label></div><br/><div class="children"><div class="content">Slightly offtopic, but I&#x27;m currently working on a video similarity search tool, and the vectors I&#x27;m using are pretty big (the size of a vector is over 2M). This is quite different to the normal vector size of maybe 10k max.<p>Currently I&#x27;m using Annoy (mostly because it&#x27;s what I&#x27;ve used before) but I am a bit worried that this is well outside what it has been designed for.<p>Has anyone got specific advice for things I should try? I&#x27;ve used FAISS previously but it seems to have the same design space.</div><br/><div id="36953799" class="c"><input type="checkbox" id="c-36953799" checked=""/><div class="controls bullet"><span class="by">janalsncm</span><span>|</span><a href="#36952095">parent</a><span>|</span><a href="#36953587">next</a><span>|</span><label class="collapse" for="c-36953799">[-]</label><label class="expand" for="c-36953799">[1 more]</label></div><br/><div class="children"><div class="content">Train an autoencoder to reduce your vector dimensions down to something more workable. It’s unlikely you’ll be able to search against such enormous vectors in a reasonable amount of time anyways.<p>Another option is to shard your vectors into N pieces, where N*k is the length of your vector. Since cosine similarity doesn’t care about order, it will be fine. The only requirement is that the k-th vector can only be compared with other k-th vectors for similarity. The benefit of this approach is that it can be parallelized easily.</div><br/></div></div><div id="36953587" class="c"><input type="checkbox" id="c-36953587" checked=""/><div class="controls bullet"><span class="by">jhj</span><span>|</span><a href="#36952095">parent</a><span>|</span><a href="#36953799">prev</a><span>|</span><a href="#36952515">next</a><span>|</span><label class="collapse" for="c-36953587">[-]</label><label class="expand" for="c-36953587">[1 more]</label></div><br/><div class="children"><div class="content">This seems impractical, it&#x27;s likely that the data is highly redundant and you&#x27;d probably do just as well by just picking a random projection to a much smaller subspace (or simply just perform a random subsampling of the dimensions, or sum dimensions together, stuff like that) rather than spending the compute to learn a projection via SVD or some such. Hubness might be a significant problem as well and lead to search results not matching your intent. Also, numeric problems (e.g., if you were accumulating distance in floating point) would become an issue as well with millions of dimensions unless the way that distances are summed get special treatment (like Kahan summation, or reduction trees to sum values of roughly equal expected magnitude, etc) too; x += dist[i] won&#x27;t cut it.<p>Any kind of acceleration technique to limit the search to a subset of the database (such as cell-probe-ish methods like LSH or IVF, or graph-based methods, etc) would take a ton of time to compute. Simply storing all the data you need for search, even brute force, would rapidly explode, not to mention the compute required.<p>Most cases with such large vectors I&#x27;ve seen begin with highly sparse vectors. Certainly Faiss (I wrote the GPU side of Faiss), Annoy, or most any similarity search libraries out there are geared to dense vectors in the 20 - 2000ish dimension range (beyond the number of dimensions where exact methods such as BSP or k-D trees work well as in &quot;high&quot; dimensions your nearest neighbor is highly likely to lie on either side of a dividing hyperplane, but below cases where simply storing the data uncompressed &#x2F; unquantized &#x2F; etc is hard and the amount of compute is prohibitive as well).<p>How big is the data set (number of vectors) that you are searching among, and are you performing single queries or batch queries?</div><br/></div></div><div id="36952515" class="c"><input type="checkbox" id="c-36952515" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36952095">parent</a><span>|</span><a href="#36953587">prev</a><span>|</span><a href="#36952261">next</a><span>|</span><label class="collapse" for="c-36952515">[-]</label><label class="expand" for="c-36952515">[1 more]</label></div><br/><div class="children"><div class="content">Reading the docs of this library it seems like I should try it, especially since it has built-in downcasting to save space on the indexes (which is rapidly turning into a big problem for me!)</div><br/></div></div><div id="36952261" class="c"><input type="checkbox" id="c-36952261" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36952095">parent</a><span>|</span><a href="#36952515">prev</a><span>|</span><a href="#36952379">next</a><span>|</span><label class="collapse" for="c-36952261">[-]</label><label class="expand" for="c-36952261">[2 more]</label></div><br/><div class="children"><div class="content">Yes, Annoy is probably not the best tool for the task. Are the vectors sparse?</div><br/><div id="36952354" class="c"><input type="checkbox" id="c-36952354" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36952095">root</a><span>|</span><a href="#36952261">parent</a><span>|</span><a href="#36952379">next</a><span>|</span><label class="collapse" for="c-36952354">[-]</label><label class="expand" for="c-36952354">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Are the vectors sparse?<p>No they aren&#x27;t.</div><br/></div></div></div></div><div id="36952379" class="c"><input type="checkbox" id="c-36952379" checked=""/><div class="controls bullet"><span class="by">shri_krishna</span><span>|</span><a href="#36952095">parent</a><span>|</span><a href="#36952261">prev</a><span>|</span><a href="#36948260">next</a><span>|</span><label class="collapse" for="c-36952379">[-]</label><label class="expand" for="c-36952379">[6 more]</label></div><br/><div class="children"><div class="content">&gt; the size of a vector is over 2M<p>Do you mean the dimension of the vector or the number of vectors?</div><br/><div id="36952496" class="c"><input type="checkbox" id="c-36952496" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36952095">root</a><span>|</span><a href="#36952379">parent</a><span>|</span><a href="#36948260">next</a><span>|</span><label class="collapse" for="c-36952496">[-]</label><label class="expand" for="c-36952496">[5 more]</label></div><br/><div class="children"><div class="content">The dimension of the vector. It&#x27;s the hidden state from a video vision transformer.</div><br/><div id="36952553" class="c"><input type="checkbox" id="c-36952553" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36952095">root</a><span>|</span><a href="#36952496">parent</a><span>|</span><a href="#36952788">next</a><span>|</span><label class="collapse" for="c-36952553">[-]</label><label class="expand" for="c-36952553">[2 more]</label></div><br/><div class="children"><div class="content">Ouch! That’s fat! Which model is that?<p>We have built a few video-search system by now, using USearch and UForm for embedding. They are only 256 dims and you can concatenate a few from different parts of the video. Any chance it would help?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;uform">https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;uform</a></div><br/><div id="36952734" class="c"><input type="checkbox" id="c-36952734" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#36952095">root</a><span>|</span><a href="#36952553">parent</a><span>|</span><a href="#36952788">next</a><span>|</span><label class="collapse" for="c-36952734">[-]</label><label class="expand" for="c-36952734">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s <a href="https:&#x2F;&#x2F;huggingface.co&#x2F;docs&#x2F;transformers&#x2F;main&#x2F;model_doc&#x2F;vivit" rel="nofollow noreferrer">https:&#x2F;&#x2F;huggingface.co&#x2F;docs&#x2F;transformers&#x2F;main&#x2F;model_doc&#x2F;vivi...</a><p>I&#x27;m doing the most naive implementation possible at the moment though so it&#x27;s likely I could improve it.<p>&gt; UForm<p>Looks interesting. I&#x27;ll have a play, thanks.<p>I&#x27;m surprised there aren&#x27;t more options in this space actually</div><br/></div></div></div></div><div id="36952788" class="c"><input type="checkbox" id="c-36952788" checked=""/><div class="controls bullet"><span class="by">shri_krishna</span><span>|</span><a href="#36952095">root</a><span>|</span><a href="#36952496">parent</a><span>|</span><a href="#36952553">prev</a><span>|</span><a href="#36948260">next</a><span>|</span><label class="collapse" for="c-36952788">[-]</label><label class="expand" for="c-36952788">[2 more]</label></div><br/><div class="children"><div class="content">Damn! 2M dimension dense vector is huge. Maybe you need to do some dimensionality reduction before attempting ANN. Something like PCA should help.</div><br/><div id="36952911" class="c"><input type="checkbox" id="c-36952911" checked=""/><div class="controls bullet"><span class="by">henrydark</span><span>|</span><a href="#36952095">root</a><span>|</span><a href="#36952788">parent</a><span>|</span><a href="#36948260">next</a><span>|</span><label class="collapse" for="c-36952911">[-]</label><label class="expand" for="c-36952911">[1 more]</label></div><br/><div class="children"><div class="content">How do you do pca on dimension 2M?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36948260" class="c"><input type="checkbox" id="c-36948260" checked=""/><div class="controls bullet"><span class="by">twelfthnight</span><span>|</span><a href="#36952095">prev</a><span>|</span><a href="#36953519">next</a><span>|</span><label class="collapse" for="c-36948260">[-]</label><label class="expand" for="c-36948260">[5 more]</label></div><br/><div class="children"><div class="content">Are folks typically using HNSW for vector search these days? I thought maybe ScaNN has proven to be better? Especially since it&#x27;s available in FAISS [2].<p>[1] <a href="https:&#x2F;&#x2F;ai.googleblog.com&#x2F;2020&#x2F;07&#x2F;announcing-scann-efficient-vector.html?m=1" rel="nofollow noreferrer">https:&#x2F;&#x2F;ai.googleblog.com&#x2F;2020&#x2F;07&#x2F;announcing-scann-efficient...</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;facebookresearch&#x2F;faiss&#x2F;wiki&#x2F;Fast-accumulation-of-PQ-and-AQ-codes-(FastScan)">https:&#x2F;&#x2F;github.com&#x2F;facebookresearch&#x2F;faiss&#x2F;wiki&#x2F;Fast-accumula...</a></div><br/><div id="36948329" class="c"><input type="checkbox" id="c-36948329" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36948260">parent</a><span>|</span><a href="#36948597">next</a><span>|</span><label class="collapse" for="c-36948329">[-]</label><label class="expand" for="c-36948329">[2 more]</label></div><br/><div class="children"><div class="content">Depends... I have a beef with all methods based on &quot;trained quantization&quot;. It introduces too much noise in your distribution, suffers from drifts, and makes the method mostly inapplicable for other forms of &quot;Similarity Search&quot; that don&#x27;t strictly fall into the &quot;Vector Search&quot; category.<p>Many disagree. Pick whatever rocks your boat, there is a FOSS library for almost everything these days :)</div><br/><div id="36948398" class="c"><input type="checkbox" id="c-36948398" checked=""/><div class="controls bullet"><span class="by">twelfthnight</span><span>|</span><a href="#36948260">root</a><span>|</span><a href="#36948329">parent</a><span>|</span><a href="#36948597">next</a><span>|</span><label class="collapse" for="c-36948398">[-]</label><label class="expand" for="c-36948398">[1 more]</label></div><br/><div class="children"><div class="content">Ah, those are interesting considerations. I don&#x27;t have a horse in that race, I just had to implement a similarity search algorithm a few years ago and it was surprisingly difficult to find a consensus on what ANN algo to use!</div><br/></div></div></div></div><div id="36948597" class="c"><input type="checkbox" id="c-36948597" checked=""/><div class="controls bullet"><span class="by">smeeth</span><span>|</span><a href="#36948260">parent</a><span>|</span><a href="#36948329">prev</a><span>|</span><a href="#36952921">next</a><span>|</span><label class="collapse" for="c-36948597">[-]</label><label class="expand" for="c-36948597">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, SPANN has better f1+queries per second on some benchmarks, but that&#x27;s a little like comparing sorting algorithms, they&#x27;re both fast and good.<p>The database software behind the ANN algo is probably a little more important in practice than the ANN algo itself, unless you&#x27;re operating at such scale and speed that its an actual issue (e.g. you&#x27;re google).<p>Differences between algorithms are a little more interesting when they let you do something totally different, like, for example, minimize the speed hit from doing searches on disk (SPTAG, DiskANN).</div><br/></div></div><div id="36952921" class="c"><input type="checkbox" id="c-36952921" checked=""/><div class="controls bullet"><span class="by">utopcell</span><span>|</span><a href="#36948260">parent</a><span>|</span><a href="#36948597">prev</a><span>|</span><a href="#36953519">next</a><span>|</span><label class="collapse" for="c-36952921">[-]</label><label class="expand" for="c-36952921">[1 more]</label></div><br/><div class="children"><div class="content">ScANN is not available in FAISS, it is Google&#x27;s version of it.</div><br/></div></div></div></div><div id="36953519" class="c"><input type="checkbox" id="c-36953519" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#36948260">prev</a><span>|</span><a href="#36949137">next</a><span>|</span><label class="collapse" for="c-36953519">[-]</label><label class="expand" for="c-36953519">[1 more]</label></div><br/><div class="children"><div class="content">Is view() for disk-based indexes doing something special over plain mmap(), e.g. setting read-aheads based on the knowledge of the intental structure to make it faster if done over the network?<p>Talking about <a href="https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch#disk-based-indexes">https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch#disk-based-indexes</a></div><br/></div></div><div id="36949137" class="c"><input type="checkbox" id="c-36949137" checked=""/><div class="controls bullet"><span class="by">freediver</span><span>|</span><a href="#36953519">prev</a><span>|</span><a href="#36952334">next</a><span>|</span><label class="collapse" for="c-36949137">[-]</label><label class="expand" for="c-36949137">[2 more]</label></div><br/><div class="children"><div class="content">I am interested in testing this in production, instead of faiss&#x2F;mrpt.<p>&gt; metric=&#x27;cos&#x27;, # Choose  &#x27;l2sq&#x27;, &#x27;haversine&#x27; or other metric, default = &#x27;ip&#x27;<p>As a note, it is actually &#x27;l2_sq&#x27; for the Python example.<p>&gt; index.add(labels=np.arange(len(vectors)), vectors=vectors)<p>Adding to index appears to be very slow. Also labels are listed as an optional param but the Python SDK has them as required.<p>Do you have setup of params for &#x27;brute force&#x27; approach (100% accuracy)?</div><br/><div id="36952300" class="c"><input type="checkbox" id="c-36952300" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36949137">parent</a><span>|</span><a href="#36952334">next</a><span>|</span><label class="collapse" for="c-36952300">[-]</label><label class="expand" for="c-36952300">[1 more]</label></div><br/><div class="children"><div class="content">Sure! You can pass exact=True to the search interface.<p>&gt; Adding to index appears to be very slow.<p>Interesting. Can you please elaborate? We benchmark it on daily basis, but there is always a chance we forgot some corner case :)<p>PS: Thanks for considering us! USearch is already used in production by a few companies (small and very large), and we would be happy to assist with integration!<p>PS2: Argument name inconsistency is solved on the main-dev, and will be released with a bunch of major changes in 1.0 this week.</div><br/></div></div></div></div><div id="36952334" class="c"><input type="checkbox" id="c-36952334" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#36949137">prev</a><span>|</span><a href="#36947450">next</a><span>|</span><label class="collapse" for="c-36952334">[-]</label><label class="expand" for="c-36952334">[2 more]</label></div><br/><div class="children"><div class="content">In this page they have &quot;space filling curves&quot; as an example in one of the images, but I haven&#x27;t been able to find production systems that actually use space filling curves for similarity search. Anyone have any tips?</div><br/><div id="36952609" class="c"><input type="checkbox" id="c-36952609" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36952334">parent</a><span>|</span><a href="#36947450">next</a><span>|</span><label class="collapse" for="c-36952609">[-]</label><label class="expand" for="c-36952609">[1 more]</label></div><br/><div class="children"><div class="content">Old-school Postgres extensions for GIS would be an example. They aren’t used much anymore, but I felt like they deserve a place in history :)<p>PS: Love your blog! I have worked on SFCs in the past. Did you?</div><br/></div></div></div></div><div id="36947450" class="c"><input type="checkbox" id="c-36947450" checked=""/><div class="controls bullet"><span class="by">eitan-turok</span><span>|</span><a href="#36952334">prev</a><span>|</span><a href="#36950127">next</a><span>|</span><label class="collapse" for="c-36947450">[-]</label><label class="expand" for="c-36947450">[11 more]</label></div><br/><div class="children"><div class="content">This looks like a great package. Many vector-search engines do not allow you to implement your own custom distance metrics. But Unum does. Love it!</div><br/><div id="36947608" class="c"><input type="checkbox" id="c-36947608" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36947450">parent</a><span>|</span><a href="#36950127">next</a><span>|</span><label class="collapse" for="c-36947608">[-]</label><label class="expand" for="c-36947608">[10 more]</label></div><br/><div class="children"><div class="content">Oh, thank you! The library author here :)<p>We&#x27;ve just hosted one of our first community&#x2F;contributor calls a few hours ago, discussing the plans for the upcoming 1.0 release, and integration with UCall, UStore, and UForm - our other FOSS libraries. Please don&#x27;t hesitate to reach out for any questions or feature requests - now is the best time :)</div><br/><div id="36948461" class="c"><input type="checkbox" id="c-36948461" checked=""/><div class="controls bullet"><span class="by">gregw134</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36947608">parent</a><span>|</span><a href="#36947860">next</a><span>|</span><label class="collapse" for="c-36948461">[-]</label><label class="expand" for="c-36948461">[6 more]</label></div><br/><div class="children"><div class="content">I Have a general vector retrieval question, if you have time to humor me. Suppose I have 10 features per document, each with an embedding. Is it possible to retrieve the document with the highest average embedding score across its features? The only approach I can think of is retrieving the top 1k results across each feature to generate a candidate set, then recomputing full scores for each document.</div><br/><div id="36948719" class="c"><input type="checkbox" id="c-36948719" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36948461">parent</a><span>|</span><a href="#36947860">next</a><span>|</span><label class="collapse" for="c-36948719">[-]</label><label class="expand" for="c-36948719">[5 more]</label></div><br/><div class="children"><div class="content">e z!<p>The simplest way with USearch - concatenate 10 embeddings, define a custom metric with Numba, that takes the average of 10 dot-products. Done :)</div><br/><div id="36948917" class="c"><input type="checkbox" id="c-36948917" checked=""/><div class="controls bullet"><span class="by">gregw134</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36948719">parent</a><span>|</span><a href="#36948771">next</a><span>|</span><label class="collapse" for="c-36948917">[-]</label><label class="expand" for="c-36948917">[2 more]</label></div><br/><div class="children"><div class="content">(replying here because hn limits thread length)<p>&gt; Yes, and yes. The last one may be a bit trickier through Python bindings today, but I can easily include that in the next release… shouldn’t take more than 50 LOC.<p>Appreciate it. That&#x27;d be game-changing for me. The ultimate thing I&#x27;d like to do is actually use a function of the form score = a<i>f1(embedding1) + b</i>f2(embedding2) + ...<p>That way you could make adjustments like ignoring feature1 unless its score passes a threshold. I&#x27;ll try looking at Numba to see if that&#x27;s possible.</div><br/><div id="36952314" class="c"><input type="checkbox" id="c-36952314" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36948917">parent</a><span>|</span><a href="#36948771">next</a><span>|</span><label class="collapse" for="c-36952314">[-]</label><label class="expand" for="c-36952314">[1 more]</label></div><br/><div class="children"><div class="content">Sure, don’t hesitate to reach out to us on Discord. It will be much easier to chat and exchange code snippets there: <a href="https:&#x2F;&#x2F;discord.gg&#x2F;A6wxt6dS9j" rel="nofollow noreferrer">https:&#x2F;&#x2F;discord.gg&#x2F;A6wxt6dS9j</a></div><br/></div></div></div></div><div id="36948771" class="c"><input type="checkbox" id="c-36948771" checked=""/><div class="controls bullet"><span class="by">gregw134</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36948719">parent</a><span>|</span><a href="#36948917">prev</a><span>|</span><a href="#36947860">next</a><span>|</span><label class="collapse" for="c-36948771">[-]</label><label class="expand" for="c-36948771">[2 more]</label></div><br/><div class="children"><div class="content">Cool. What if I want a weighted average of embeddings? Going further, is it possible to adjust the weights at search time?</div><br/><div id="36948829" class="c"><input type="checkbox" id="c-36948829" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36948771">parent</a><span>|</span><a href="#36947860">next</a><span>|</span><label class="collapse" for="c-36948829">[-]</label><label class="expand" for="c-36948829">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and yes. The last one may be a bit trickier through Python bindings today, but I can easily include that in the next release… shouldn’t take more than 50 LOC.</div><br/></div></div></div></div></div></div></div></div><div id="36947860" class="c"><input type="checkbox" id="c-36947860" checked=""/><div class="controls bullet"><span class="by">_0ffh</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36947608">parent</a><span>|</span><a href="#36948461">prev</a><span>|</span><a href="#36950127">next</a><span>|</span><label class="collapse" for="c-36947860">[-]</label><label class="expand" for="c-36947860">[3 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s a triviality, but you&#x27;ve got a typo in &quot;Hardware-agmostic&quot; you may want to fix.</div><br/><div id="36947905" class="c"><input type="checkbox" id="c-36947905" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36947860">parent</a><span>|</span><a href="#36950127">next</a><span>|</span><label class="collapse" for="c-36947905">[-]</label><label class="expand" for="c-36947905">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for suggestion! Details count, nothing is a triviality!<p>If someone here has free time and C++ experience I am open to recommendations on the codebase and style as well: <a href="https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch&#x2F;blob&#x2F;main-dev&#x2F;include&#x2F;usearch&#x2F;index.hpp">https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch&#x2F;blob&#x2F;main-dev&#x2F;include&#x2F;...</a></div><br/><div id="36949441" class="c"><input type="checkbox" id="c-36949441" checked=""/><div class="controls bullet"><span class="by">pilooch</span><span>|</span><a href="#36947450">root</a><span>|</span><a href="#36947905">parent</a><span>|</span><a href="#36950127">next</a><span>|</span><label class="collapse" for="c-36949441">[-]</label><label class="expand" for="c-36949441">[1 more]</label></div><br/><div class="children"><div class="content">Look at policy-based templating, my goto for generic AI&#x2F;search algorithms with many options. May prove useful.... Or not :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36950127" class="c"><input type="checkbox" id="c-36950127" checked=""/><div class="controls bullet"><span class="by">CharlesW</span><span>|</span><a href="#36947450">prev</a><span>|</span><a href="#36949458">next</a><span>|</span><label class="collapse" for="c-36950127">[-]</label><label class="expand" for="c-36950127">[2 more]</label></div><br/><div class="children"><div class="content">@ashvardanian, what are reasons a developer would choose this over sqlite-vss?</div><br/><div id="36952337" class="c"><input type="checkbox" id="c-36952337" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36950127">parent</a><span>|</span><a href="#36949458">next</a><span>|</span><label class="collapse" for="c-36952337">[-]</label><label class="expand" for="c-36952337">[1 more]</label></div><br/><div class="children"><div class="content">sqlite-vss is an SQLite extension. Such things are often build on top libraries like FAISS or USearch. It is just a matter of - how many layers of abstractions do you want to pay for… performance wise.<p>If you already use some DBMS to store your data - extension can be a good place to start. Once you scale and want to tune… switch to using the underlying engine directly.</div><br/></div></div></div></div><div id="36949458" class="c"><input type="checkbox" id="c-36949458" checked=""/><div class="controls bullet"><span class="by">moab</span><span>|</span><a href="#36950127">prev</a><span>|</span><a href="#36953222">next</a><span>|</span><label class="collapse" for="c-36949458">[-]</label><label class="expand" for="c-36949458">[3 more]</label></div><br/><div class="children"><div class="content">Do you have plans to support metadata filtering?</div><br/><div id="36949618" class="c"><input type="checkbox" id="c-36949618" checked=""/><div class="controls bullet"><span class="by">momothereal</span><span>|</span><a href="#36949458">parent</a><span>|</span><a href="#36953222">next</a><span>|</span><label class="collapse" for="c-36949618">[-]</label><label class="expand" for="c-36949618">[2 more]</label></div><br/><div class="children"><div class="content">I was going to ask the same. That is a really important feature to have to replace traditional indexes and usually poorly implemented in vector search libraries.<p>For example, filtering by arbitrary time range.</div><br/><div id="36953090" class="c"><input type="checkbox" id="c-36953090" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36949458">root</a><span>|</span><a href="#36949618">parent</a><span>|</span><a href="#36953222">next</a><span>|</span><label class="collapse" for="c-36953090">[-]</label><label class="expand" for="c-36953090">[1 more]</label></div><br/><div class="children"><div class="content">I will reply with a meme from my recent talk on Vector Databases, if that is in order: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;UMrhB3icP9w?t=1682" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;UMrhB3icP9w?t=1682</a><p>§ Supporting advanced filtering in USearch<p>In the low-level C++ interface we already support arbitrary predicates (callbacks) evaluated during HNSW graph traversal. JIT-ing them from the Python level is a bit trickier, but we will consider that, if there is demand.<p>§ Supporting advanced filtering with USearch<p>We are now in the process of building a bridge between USearch and UStore, that would allow combining Vector Search with a proper Multi-Modal database. This will solve your problem, but will take some time to get it right. Feel free to contribute :)</div><br/></div></div></div></div></div></div><div id="36953222" class="c"><input type="checkbox" id="c-36953222" checked=""/><div class="controls bullet"><span class="by">ykadowak</span><span>|</span><a href="#36949458">prev</a><span>|</span><a href="#36948091">next</a><span>|</span><label class="collapse" for="c-36953222">[-]</label><label class="expand" for="c-36953222">[2 more]</label></div><br/><div class="children"><div class="content">@ashvardanian any plan to put it on ANN benchmarks?</div><br/><div id="36953357" class="c"><input type="checkbox" id="c-36953357" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36953222">parent</a><span>|</span><a href="#36948091">next</a><span>|</span><label class="collapse" for="c-36953357">[-]</label><label class="expand" for="c-36953357">[1 more]</label></div><br/><div class="children"><div class="content">Here you go :)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;erikbern&#x2F;ann-benchmarks&#x2F;pull&#x2F;451">https:&#x2F;&#x2F;github.com&#x2F;erikbern&#x2F;ann-benchmarks&#x2F;pull&#x2F;451</a></div><br/></div></div></div></div><div id="36948091" class="c"><input type="checkbox" id="c-36948091" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36953222">prev</a><span>|</span><label class="collapse" for="c-36948091">[-]</label><label class="expand" for="c-36948091">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s performance like without BLAS acceleration?</div><br/><div id="36948190" class="c"><input type="checkbox" id="c-36948190" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36948091">parent</a><span>|</span><label class="collapse" for="c-36948190">[-]</label><label class="expand" for="c-36948190">[3 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t use BLAS. Why? BLAS helps with matrix-matrix multiplications, if you feel lazy and don&#x27;t want to write the matrix tiling code manually.<p>They bring essentially nothing of value in vector-vector operations, as compilers can properly auto-vectorize simple dot products... Moreover, they generally only target single and double precision, while we often prefer half or quarter precision. All in all, meaningless dependency.<p>What do we use? I wrote a tiny package called SimSIMD. It&#x27;s idea is to utilize less common SIMD instructions, especially in mixed-typed computations, that are hard for compilers to optimize. It was also a fun exercise to evaluate the performance of new SVE instruction on recent Arm CPUs, like the Graviton 3. You can find the code, the benchmarks, and the results in the repo: <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;simsimd">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;simsimd</a><p>Still, even without SimSIMD, USearch seems to be one of the faster implementations of vector search. You can find the benchmarks in the first table here: <a href="https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch#memory-efficiency-downcasting-and-quantization">https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch#memory-efficiency-down...</a></div><br/><div id="36948431" class="c"><input type="checkbox" id="c-36948431" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36948091">root</a><span>|</span><a href="#36948190">parent</a><span>|</span><label class="collapse" for="c-36948431">[-]</label><label class="expand" for="c-36948431">[2 more]</label></div><br/><div class="children"><div class="content">The docs recommends compiling for the target machine, does the pip package compile on install?</div><br/><div id="36948526" class="c"><input type="checkbox" id="c-36948526" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#36948091">root</a><span>|</span><a href="#36948431">parent</a><span>|</span><label class="collapse" for="c-36948526">[-]</label><label class="expand" for="c-36948526">[1 more]</label></div><br/><div class="children"><div class="content">If you install from PyPi default repository - it comes precompiled, but can still be ad-hoc accelerated with JIT-ed metrics. Either way, it should have decent performance. Still, if you wanna push the limits and work with Multi-Terabyte indexes on one node - recompiling locally should help.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>