<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735203655002" as="style"/><link rel="stylesheet" href="styles.css?v=1735203655002"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://igorstechnoclub.com/server-sent-events-sse-are-underrated/">Server-Sent Events (SSE) Are Underrated</a> <span class="domain">(<a href="https://igorstechnoclub.com">igorstechnoclub.com</a>)</span></div><div class="subtext"><span>Igor_Wiwi</span> | <span>93 comments</span></div><br/><div><div id="42511691" class="c"><input type="checkbox" id="c-42511691" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#42511707">next</a><span>|</span><label class="collapse" for="c-42511691">[-]</label><label class="expand" for="c-42511691">[6 more]</label></div><br/><div class="children"><div class="content">A while ago I created Mercure: an open pub-sub protocol built on top of SSE that is a replacement for WebSockets-based solutions such as Pusher. Mercure is now used by hundreds of apps in production.<p>At the core of Mercure is the hub. It is a standalone component that maintains persistent SSE (HTTP) connections to the clients, and it exposes a very simple HTTP API that server apps and clients can use to publish. POSTed updates are broadcasted to all connected clients using SSE. This makes SSE usable even with technologies not able to maintain persistent connections such as PHP and many serverless providers.<p>Mercure also adds nice features to SSE such as a JWT-based authorization mechanism, the ability to subscribe to several topics using a single connection, events history, automatic state reconciliation in case of network issue…<p>I maintain an open-source hub written in Go (technically, a module for the Caddy web server) and a SaaS version is also available.<p>Docs and code are available on <a href="https:&#x2F;&#x2F;mercure.rocks" rel="nofollow">https:&#x2F;&#x2F;mercure.rocks</a></div><br/><div id="42512565" class="c"><input type="checkbox" id="c-42512565" checked=""/><div class="controls bullet"><span class="by">Dren95</span><span>|</span><a href="#42511691">parent</a><span>|</span><a href="#42511826">next</a><span>|</span><label class="collapse" for="c-42512565">[-]</label><label class="expand" for="c-42512565">[1 more]</label></div><br/><div class="children"><div class="content">Cool didn’t know this. I used a similar solution called Centrifugo for a while. It allows you to choose which transport to use (ws, sse, others)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;centrifugal&#x2F;centrifugo">https:&#x2F;&#x2F;github.com&#x2F;centrifugal&#x2F;centrifugo</a></div><br/></div></div><div id="42511826" class="c"><input type="checkbox" id="c-42511826" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511691">parent</a><span>|</span><a href="#42512565">prev</a><span>|</span><a href="#42513202">next</a><span>|</span><label class="collapse" for="c-42511826">[-]</label><label class="expand" for="c-42511826">[3 more]</label></div><br/><div class="children"><div class="content">The site mentions battery-efficiency specifically. I&#x27;m curious what features does Mercure provide in that direction?</div><br/><div id="42512719" class="c"><input type="checkbox" id="c-42512719" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#42511691">root</a><span>|</span><a href="#42511826">parent</a><span>|</span><a href="#42512922">next</a><span>|</span><label class="collapse" for="c-42512719">[-]</label><label class="expand" for="c-42512719">[1 more]</label></div><br/><div class="children"><div class="content">SSE&#x2F;Mercure (as WebSockets) is much battery-efficient than polling (push vs poll, less bandwidth used).<p>Additionally, on controlled environnements, SSE can use a « push proxy » to wake up the device only when necessary: <a href="https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;multipage&#x2F;server-sent-events.html#eventsource-push" rel="nofollow">https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;multipage&#x2F;server-sent-events.ht...</a></div><br/></div></div><div id="42512922" class="c"><input type="checkbox" id="c-42512922" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42511691">root</a><span>|</span><a href="#42511826">parent</a><span>|</span><a href="#42512719">prev</a><span>|</span><a href="#42513202">next</a><span>|</span><label class="collapse" for="c-42512922">[-]</label><label class="expand" for="c-42512922">[1 more]</label></div><br/><div class="children"><div class="content">It comes down to all the extra bytes sent and processed (local and remote, and in flight) by long polling. SSE events are small while other methods might require multiple packets and all the needless headers throughout the stack, for example.</div><br/></div></div></div></div><div id="42513202" class="c"><input type="checkbox" id="c-42513202" checked=""/><div class="controls bullet"><span class="by">tonyhart7</span><span>|</span><a href="#42511691">parent</a><span>|</span><a href="#42511826">prev</a><span>|</span><a href="#42511707">next</a><span>|</span><label class="collapse" for="c-42513202">[-]</label><label class="expand" for="c-42513202">[1 more]</label></div><br/><div class="children"><div class="content">its cool but its in go, do you know other implementation in rust ????</div><br/></div></div></div></div><div id="42511707" class="c"><input type="checkbox" id="c-42511707" checked=""/><div class="controls bullet"><span class="by">piccirello</span><span>|</span><a href="#42511691">prev</a><span>|</span><a href="#42511562">next</a><span>|</span><label class="collapse" for="c-42511707">[-]</label><label class="expand" for="c-42511707">[7 more]</label></div><br/><div class="children"><div class="content">I utilized SSE when building automatic restart functionality[0] into Doppler&#x27;s CLI. Our api server would send down an event whenever an application&#x27;s secrets changed. The CLI would then fetch the latest secrets to inject into the application process. (I opted not to directly send the changed secrets via SSE as that would necessitate rechecking the access token that was used to establish the connection, lest we send changed secrets to a recently deauthorized client). I chose SSE over websockets because the latter required pulling in additional dependencies into our Golang application, and we truly only needed server-&gt;client communication.
 One issue we ran into that hasn&#x27;t been discussed is HTTP timeouts. Some load balancers close an HTTP connection after a certain timeout (e.g. 1 hour) to prevent connection exhaustion. You can usually extend this timeout, but it has to be explicitly configured. We also found that our server had to send intermittent &quot;ping&quot; events to prevent either Cloudflare or Google Cloud Load Balancing from closing the connection, though I don&#x27;t remember how frequently these were sent. Otherwise, SSE worked great for our use case.<p>[0] <a href="https:&#x2F;&#x2F;docs.doppler.com&#x2F;docs&#x2F;automatic-restart">https:&#x2F;&#x2F;docs.doppler.com&#x2F;docs&#x2F;automatic-restart</a></div><br/><div id="42511801" class="c"><input type="checkbox" id="c-42511801" checked=""/><div class="controls bullet"><span class="by">Xenoamorphous</span><span>|</span><a href="#42511707">parent</a><span>|</span><a href="#42511810">next</a><span>|</span><label class="collapse" for="c-42511801">[-]</label><label class="expand" for="c-42511801">[1 more]</label></div><br/><div class="children"><div class="content">I also used SSE 6 or so years ago, and had the same issue with out load balancer; a bit hacky but what I did was to set a timer that would send a single colon character (which is the comment delimiter IIRC) periodically to the client. Is that what you meant by “ping”?</div><br/></div></div><div id="42511810" class="c"><input type="checkbox" id="c-42511810" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511707">parent</a><span>|</span><a href="#42511801">prev</a><span>|</span><a href="#42511562">next</a><span>|</span><label class="collapse" for="c-42511810">[-]</label><label class="expand" for="c-42511810">[5 more]</label></div><br/><div class="children"><div class="content">Generally you&#x27;re going to want to send ping events pretty regularly (I&#x27;d default to every 15-30 seconds depending on application) whether you&#x27;re using SSE, WebSockets, or something else. Otherwise if the server crashes the client might not know the connection is no longer live.</div><br/><div id="42512234" class="c"><input type="checkbox" id="c-42512234" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42511707">root</a><span>|</span><a href="#42511810">parent</a><span>|</span><a href="#42512014">next</a><span>|</span><label class="collapse" for="c-42512234">[-]</label><label class="expand" for="c-42512234">[1 more]</label></div><br/><div class="children"><div class="content">What do you do for mobile phones: using data&#x2F;radio for pings would kill the battery?<p>After locking the phone, how is the ping restarted when the phone is unlocked? Or backgrounding the browser&#x2F;app?</div><br/></div></div><div id="42512014" class="c"><input type="checkbox" id="c-42512014" checked=""/><div class="controls bullet"><span class="by">sabareesh</span><span>|</span><a href="#42511707">root</a><span>|</span><a href="#42511810">parent</a><span>|</span><a href="#42512234">prev</a><span>|</span><a href="#42511562">next</a><span>|</span><label class="collapse" for="c-42512014">[-]</label><label class="expand" for="c-42512014">[3 more]</label></div><br/><div class="children"><div class="content">Yeah with cloudflare you need to do it every 30 seconds as the timeout is is 60 seconds</div><br/><div id="42512211" class="c"><input type="checkbox" id="c-42512211" checked=""/><div class="controls bullet"><span class="by">loloquwowndueo</span><span>|</span><a href="#42511707">root</a><span>|</span><a href="#42512014">parent</a><span>|</span><a href="#42511562">next</a><span>|</span><label class="collapse" for="c-42512211">[-]</label><label class="expand" for="c-42512211">[2 more]</label></div><br/><div class="children"><div class="content">Then why not do it every 59 seconds :)</div><br/><div id="42512681" class="c"><input type="checkbox" id="c-42512681" checked=""/><div class="controls bullet"><span class="by">virtue3</span><span>|</span><a href="#42511707">root</a><span>|</span><a href="#42512211">parent</a><span>|</span><a href="#42511562">next</a><span>|</span><label class="collapse" for="c-42512681">[-]</label><label class="expand" for="c-42512681">[1 more]</label></div><br/><div class="children"><div class="content">You’d probably want to do it every 29 seconds in case a ping fails to send&#x2F;deliver.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42511562" class="c"><input type="checkbox" id="c-42511562" checked=""/><div class="controls bullet"><span class="by">dugmartin</span><span>|</span><a href="#42511707">prev</a><span>|</span><a href="#42513914">next</a><span>|</span><label class="collapse" for="c-42511562">[-]</label><label class="expand" for="c-42511562">[30 more]</label></div><br/><div class="children"><div class="content">It doesn’t mention the big drawback of SSE as spelled out in the MDN docs:<p>“Warning: When not used over HTTP&#x2F;2, SSE suffers from a limitation to the maximum number of open connections, which can be especially painful when opening multiple tabs, as the limit is per browser and is set to a very low number (6).”</div><br/><div id="42512171" class="c"><input type="checkbox" id="c-42512171" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#42511562">parent</a><span>|</span><a href="#42512145">next</a><span>|</span><label class="collapse" for="c-42512171">[-]</label><label class="expand" for="c-42512171">[8 more]</label></div><br/><div class="children"><div class="content">One of my company&#x27;s APIs uses SSE, and it&#x27;s been a big support headache for us, because many people are being corporate firewalls that don&#x27;t do HTTP&#x2F;2 or HTTP&#x2F;3, and people often open many tabs at the same time. It&#x27;s unfortunately not possible to detect client-side whether the limit has been reached.<p>Another drawback of SSE is lack of authorization header support. There are a few polyfills (like this one [1]) that simulate SSE over fetch&#x2F;XHR, but it would be nice to not need to add the bloat.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;EventSource&#x2F;eventsource">https:&#x2F;&#x2F;github.com&#x2F;EventSource&#x2F;eventsource</a></div><br/><div id="42513929" class="c"><input type="checkbox" id="c-42513929" checked=""/><div class="controls bullet"><span class="by">fitsumbelay</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512171">parent</a><span>|</span><a href="#42512276">next</a><span>|</span><label class="collapse" for="c-42513929">[-]</label><label class="expand" for="c-42513929">[1 more]</label></div><br/><div class="children"><div class="content">I hate to suggest a solution before testing it myself so apologies in advance but I have a hunch that Broadcast Channel API can help you detect browser tab opens on client side. New tabs won&#x27;t connect to event source and instead listen get data from localStorage that the first loaded tab writes to.<p><a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=can+I+use+BroadcastChannel+API+to+detect+how+many+tabs+a+client+has+open%3F&amp;rlz=1C5CHFA_enUS917US918&amp;oq=can+I+use+BroadcastChannel+API+to+detect+how+many+tabs+a+client+has+open%3F&amp;gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQRRhA0gEJMTc0MTdqMGo3qAIAsAIA&amp;sourceid=chrome&amp;ie=UTF-8" rel="nofollow">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=can+I+use+BroadcastChannel+A...</a><p>The problem in this case is how to handle the first tab closing and re-assign which tab then becomes the new &quot;first&quot; tab that connects to the event source but it may be a LOE to solve.<p>Again apologies for suggesting unproven solutions but at the same time I&#x27;m interested in feedback it gets to see if its near the right track</div><br/></div></div><div id="42512276" class="c"><input type="checkbox" id="c-42512276" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512171">parent</a><span>|</span><a href="#42513929">prev</a><span>|</span><a href="#42512403">next</a><span>|</span><label class="collapse" for="c-42512276">[-]</label><label class="expand" for="c-42512276">[4 more]</label></div><br/><div class="children"><div class="content">Presumably you try SSE, and on failure fallback to something else like WebSockets?<p>Push seems to require supporting multiple communication protocols to avoid failure modes specific to one protocol - and libraries are complex because of that.</div><br/><div id="42512420" class="c"><input type="checkbox" id="c-42512420" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512276">parent</a><span>|</span><a href="#42512403">next</a><span>|</span><label class="collapse" for="c-42512420">[-]</label><label class="expand" for="c-42512420">[3 more]</label></div><br/><div class="children"><div class="content">But then why not just use websockets?</div><br/><div id="42512694" class="c"><input type="checkbox" id="c-42512694" checked=""/><div class="controls bullet"><span class="by">virtue3</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512420">parent</a><span>|</span><a href="#42512403">next</a><span>|</span><label class="collapse" for="c-42512694">[-]</label><label class="expand" for="c-42512694">[2 more]</label></div><br/><div class="children"><div class="content">From what I understand websockets are great until you have to load balance them. And then you learn why they aren’t so great.</div><br/><div id="42513465" class="c"><input type="checkbox" id="c-42513465" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512694">parent</a><span>|</span><a href="#42512403">next</a><span>|</span><label class="collapse" for="c-42513465">[-]</label><label class="expand" for="c-42513465">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve scaled websockets before, it isn&#x27;t that hard.<p>You need to scale up before your servers become overloaded, and basically new connections go north to the newly brought up server. It is a different mentality than scaling stateless services but it isn&#x27;t super duper hard.</div><br/></div></div></div></div></div></div></div></div><div id="42512403" class="c"><input type="checkbox" id="c-42512403" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512171">parent</a><span>|</span><a href="#42512276">prev</a><span>|</span><a href="#42512145">next</a><span>|</span><label class="collapse" for="c-42512403">[-]</label><label class="expand" for="c-42512403">[2 more]</label></div><br/><div class="children"><div class="content">FYI, the dev of that library created a new, better Event Source client<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client">https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client</a></div><br/><div id="42512441" class="c"><input type="checkbox" id="c-42512441" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512403">parent</a><span>|</span><a href="#42512145">next</a><span>|</span><label class="collapse" for="c-42512441">[-]</label><label class="expand" for="c-42512441">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I know. We both work at Sanity, actually! The reason I didn&#x27;t mention it was that the newer library isn&#x27;t a straight polyfill; it offers a completely different interface with async support and so on.</div><br/></div></div></div></div></div></div><div id="42512145" class="c"><input type="checkbox" id="c-42512145" checked=""/><div class="controls bullet"><span class="by">jesprenj</span><span>|</span><a href="#42511562">parent</a><span>|</span><a href="#42512171">prev</a><span>|</span><a href="#42511669">next</a><span>|</span><label class="collapse" for="c-42512145">[-]</label><label class="expand" for="c-42512145">[3 more]</label></div><br/><div class="children"><div class="content">You can easily multiplex data over one connection&#x2F;event stream. You can design your app so that it only uses one eventstream for all events it needs to receive.</div><br/><div id="42512271" class="c"><input type="checkbox" id="c-42512271" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512145">parent</a><span>|</span><a href="#42511669">next</a><span>|</span><label class="collapse" for="c-42512271">[-]</label><label class="expand" for="c-42512271">[2 more]</label></div><br/><div class="children"><div class="content">This, it works well in a service worker for example.</div><br/><div id="42512520" class="c"><input type="checkbox" id="c-42512520" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512271">parent</a><span>|</span><a href="#42511669">next</a><span>|</span><label class="collapse" for="c-42512520">[-]</label><label class="expand" for="c-42512520">[1 more]</label></div><br/><div class="children"><div class="content">How does this work with a service worker? I&#x27;ve only managed to do this via SharedWorker (which is not available on Chrome on Android).</div><br/></div></div></div></div></div></div><div id="42511669" class="c"><input type="checkbox" id="c-42511669" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42511562">parent</a><span>|</span><a href="#42512145">prev</a><span>|</span><a href="#42513027">next</a><span>|</span><label class="collapse" for="c-42511669">[-]</label><label class="expand" for="c-42511669">[7 more]</label></div><br/><div class="children"><div class="content">That is a very low number. I can think of many reasons why one would end up with more. Does anyone know why it is so low?</div><br/><div id="42512278" class="c"><input type="checkbox" id="c-42512278" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511669">parent</a><span>|</span><a href="#42511871">next</a><span>|</span><label class="collapse" for="c-42512278">[-]</label><label class="expand" for="c-42512278">[1 more]</label></div><br/><div class="children"><div class="content">The number was set while Apache was dominant and common deployments would get completely tanked by a decent number of clients opening more conns than this. c10k was a thing once, these days c10m is relatively trivial</div><br/></div></div><div id="42511871" class="c"><input type="checkbox" id="c-42511871" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511669">parent</a><span>|</span><a href="#42512278">prev</a><span>|</span><a href="#42512144">next</a><span>|</span><label class="collapse" for="c-42511871">[-]</label><label class="expand" for="c-42511871">[3 more]</label></div><br/><div class="children"><div class="content">Historical reasons. The HTTP&#x2F;1.1 spec actually recommends limited to 2 connections per domain. That said, I&#x27;m not sure why it&#x27;s still so low. I would guess mostly to avoid unintended side effects of changing it.</div><br/><div id="42513878" class="c"><input type="checkbox" id="c-42513878" checked=""/><div class="controls bullet"><span class="by">dontchooseanick</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511871">parent</a><span>|</span><a href="#42513830">next</a><span>|</span><label class="collapse" for="c-42513878">[-]</label><label class="expand" for="c-42513878">[1 more]</label></div><br/><div class="children"><div class="content">Because you&#x27;re supposed to use a single connection with HTTP Pipelining for all your ressources [1]<p>When index.html loads 4 CSS and 5 JS : 10 ressources in HTTP 1.0 needed 10 connections, with 10 TLS negociations (unless one ressource loaded fast and you could reuse it&#x27;s released connection)<p>With HTTP1.1 Pipelining you open only one connection, including a single TLS nego, and ask 10 ressources.<p>Why not only 1 per domain so ? IIRC it&#x27;s because the 1st ressource index.html may take a lot of Time to complete and well race conditions suggest you use another one that the &#x27;main thread&#x27; more or less. So basically 2 are sufficient.<p>[1] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;HTTP_pipelining" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;HTTP_pipelining</a></div><br/></div></div><div id="42513830" class="c"><input type="checkbox" id="c-42513830" checked=""/><div class="controls bullet"><span class="by">gsnedders</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511871">parent</a><span>|</span><a href="#42513878">prev</a><span>|</span><a href="#42512144">next</a><span>|</span><label class="collapse" for="c-42513830">[-]</label><label class="expand" for="c-42513830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The HTTP&#x2F;1.1 spec actually recommends limited to 2 connections per domain.<p>This is no longer true.<p>From RFC 9112 § 9.4 (<a href="https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9112.html#rfc.section.9.4" rel="nofollow">https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9112.html#rfc.section.9.4</a>):<p>&gt; Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.</div><br/></div></div></div></div><div id="42512144" class="c"><input type="checkbox" id="c-42512144" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511669">parent</a><span>|</span><a href="#42511871">prev</a><span>|</span><a href="#42512482">next</a><span>|</span><label class="collapse" for="c-42512144">[-]</label><label class="expand" for="c-42512144">[1 more]</label></div><br/><div class="children"><div class="content">Probably because without http&#x2F;2 each would require a TCP connection, which could get expensive.</div><br/></div></div><div id="42512482" class="c"><input type="checkbox" id="c-42512482" checked=""/><div class="controls bullet"><span class="by">giantrobot</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511669">parent</a><span>|</span><a href="#42512144">prev</a><span>|</span><a href="#42513027">next</a><span>|</span><label class="collapse" for="c-42512482">[-]</label><label class="expand" for="c-42512482">[1 more]</label></div><br/><div class="children"><div class="content">Because 30 years ago server processes often (enough) used inetd or served a request with a forked process. A browser hitting a server with a bunch of connections, especially over slow network links where the connection would be long lived, could swamp a server. Process launches were expensive and could use a lot of memory.<p>While server capacity in every dimension has increased the low connection count for browsers has remained. But even today it&#x27;s still a bit of a courtesy to not spam a server with a hundred simultaneous connections. If the server implicitly supports tons of connects with HTTP&#x2F;2 support that&#x27;s one thing but it&#x27;s not polite to abuse HTTP&#x2F;1.1 servers.</div><br/></div></div></div></div><div id="42513246" class="c"><input type="checkbox" id="c-42513246" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#42511562">parent</a><span>|</span><a href="#42513027">prev</a><span>|</span><a href="#42511993">next</a><span>|</span><label class="collapse" for="c-42513246">[-]</label><label class="expand" for="c-42513246">[1 more]</label></div><br/><div class="children"><div class="content">Http2 is controllable by you, since it&#x27;s supposed in every browser. 
So, the way to fix this limitation is to use http2</div><br/></div></div><div id="42511993" class="c"><input type="checkbox" id="c-42511993" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#42511562">parent</a><span>|</span><a href="#42513246">prev</a><span>|</span><a href="#42511577">next</a><span>|</span><label class="collapse" for="c-42511993">[-]</label><label class="expand" for="c-42511993">[6 more]</label></div><br/><div class="children"><div class="content">There is little reason to not use HTTP&#x2F;2 these days unless you are not doing TLS. I can understand not doing HTTP&#x2F;3 and QUIC, but HTTP&#x2F;2?</div><br/><div id="42512072" class="c"><input type="checkbox" id="c-42512072" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511993">parent</a><span>|</span><a href="#42511577">next</a><span>|</span><label class="collapse" for="c-42512072">[-]</label><label class="expand" for="c-42512072">[5 more]</label></div><br/><div class="children"><div class="content">Corporate proxy servers often downgrade connections to HTTP 1.1 because inertia and lazy vendors.</div><br/><div id="42512188" class="c"><input type="checkbox" id="c-42512188" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512072">parent</a><span>|</span><a href="#42511577">next</a><span>|</span><label class="collapse" for="c-42512188">[-]</label><label class="expand" for="c-42512188">[4 more]</label></div><br/><div class="children"><div class="content">To do that they need to MITM <i>and tamper with</i> the inner protocol.<p>In my experience this is quite rare. Some MITM proxies analyze the traffic, restrict which ciphers can be used, block non-dns udp (and therefore HTTP&#x2F;3), but they don&#x27;t usually downgrade the protocol from HTTP&#x2F;2 to HTTP&#x2F;1.</div><br/><div id="42512640" class="c"><input type="checkbox" id="c-42512640" checked=""/><div class="controls bullet"><span class="by">geoffeg</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512188">parent</a><span>|</span><a href="#42512519">next</a><span>|</span><label class="collapse" for="c-42512640">[-]</label><label class="expand" for="c-42512640">[1 more]</label></div><br/><div class="children"><div class="content">That hasn&#x27;t been my experience at large corporations. They usually have a corporate proxy which only speaks HTTP 1.1, intercepts all HTTPS, and doesn&#x27;t support websockets (unless you ask for an exception) and other more modern HTTP features.</div><br/></div></div><div id="42512519" class="c"><input type="checkbox" id="c-42512519" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512188">parent</a><span>|</span><a href="#42512640">prev</a><span>|</span><a href="#42512873">next</a><span>|</span><label class="collapse" for="c-42512519">[-]</label><label class="expand" for="c-42512519">[1 more]</label></div><br/><div class="children"><div class="content">&quot;tamper&quot; sounds much more involved than what they (their implementation) probably do: the proxy decodes the http request, potentially modifies it, and uses the decoded form to send a new request using their client, which only speaks http&#x2F;1</div><br/></div></div><div id="42512873" class="c"><input type="checkbox" id="c-42512873" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42512188">parent</a><span>|</span><a href="#42512519">prev</a><span>|</span><a href="#42511577">next</a><span>|</span><label class="collapse" for="c-42512873">[-]</label><label class="expand" for="c-42512873">[1 more]</label></div><br/><div class="children"><div class="content">That’s exactly what they’re doing and it’s still very common in private networks</div><br/></div></div></div></div></div></div></div></div><div id="42511577" class="c"><input type="checkbox" id="c-42511577" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#42511562">parent</a><span>|</span><a href="#42511993">prev</a><span>|</span><a href="#42513914">next</a><span>|</span><label class="collapse" for="c-42511577">[-]</label><label class="expand" for="c-42511577">[3 more]</label></div><br/><div class="children"><div class="content">And over HTTP&#x2F;2 and 3 they are efficient?</div><br/><div id="42511632" class="c"><input type="checkbox" id="c-42511632" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511577">parent</a><span>|</span><a href="#42513914">next</a><span>|</span><label class="collapse" for="c-42511632">[-]</label><label class="expand" for="c-42511632">[2 more]</label></div><br/><div class="children"><div class="content">HTTP&#x2F;2+ only uses a single transport connection (TCP or QUIC) per server, and multiplexes over that. So there&#x27;s essentially no practical limit.</div><br/><div id="42512506" class="c"><input type="checkbox" id="c-42512506" checked=""/><div class="controls bullet"><span class="by">toomim</span><span>|</span><a href="#42511562">root</a><span>|</span><a href="#42511632">parent</a><span>|</span><a href="#42513914">next</a><span>|</span><label class="collapse" for="c-42512506">[-]</label><label class="expand" for="c-42512506">[1 more]</label></div><br/><div class="children"><div class="content">Except that browsers add a limit of ~100 connections even with HTTP&#x2F;2, for no apparently good reason.</div><br/></div></div></div></div></div></div></div></div><div id="42513914" class="c"><input type="checkbox" id="c-42513914" checked=""/><div class="controls bullet"><span class="by">fitsumbelay</span><span>|</span><a href="#42511562">prev</a><span>|</span><a href="#42511504">next</a><span>|</span><label class="collapse" for="c-42513914">[-]</label><label class="expand" for="c-42513914">[1 more]</label></div><br/><div class="children"><div class="content">Finding use cases for SSE and reading about others doing the same brings me great joy. Very easy to set up -- you just set 2 or 3 response headers and off you go.<p>I have a hard time imagining the tech&#x27;s limits outside of testing scenarios so some of the examples brought up here are interesting</div><br/></div></div><div id="42511504" class="c"><input type="checkbox" id="c-42511504" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#42513914">prev</a><span>|</span><a href="#42511600">next</a><span>|</span><label class="collapse" for="c-42511504">[-]</label><label class="expand" for="c-42511504">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;data-star.dev" rel="nofollow">https:&#x2F;&#x2F;data-star.dev</a> is a hypermedia-oriented front end library built entirely around the idea of streaming hypermedia responses via SSE.<p>It was developed using Go &amp; NATS as backend technologies, but works with any SSE implementation.<p>Worth checking out if you want to explore SSE and what can be achieved w&#x2F;it more deeply.  Here is an interview with the author:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HbTFlUqELVc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HbTFlUqELVc</a></div><br/></div></div><div id="42511600" class="c"><input type="checkbox" id="c-42511600" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511504">prev</a><span>|</span><a href="#42511822">next</a><span>|</span><label class="collapse" for="c-42511600">[-]</label><label class="expand" for="c-42511600">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Perceived Limitations: The unidirectional nature might seem restrictive, though it&#x27;s often sufficient for many use cases<p>For my use cases the main limitations of SSE are:<p>1. Text-only, so if you want to do binary you need to do something like base64<p>2. Browser connection limits for HTTP&#x2F;1.1, ie you can only have ~6 connections per domain[0]<p>Connection limits aren&#x27;t a problem as long as you use HTTP&#x2F;2+.<p>Even so, I don&#x27;t think I would reach for SSE these days. For less latency-sensitive and data-use sensitive applications, I would just use long polling.<p>For things that are more performance-sensitive, I would probably use fetch with ReadableStream body responses. On the server side I would prefix each message with a 32bit integer (or maybe a variable length int of some sort) that gives the size of the message. This is far more flexible (by allowing binary data), and has less overhead compared to SSE, which requires 7 bytes (&quot;data:&quot; + &quot;\n\n&quot;) of overhead for each message.<p>[0]: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;985704" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;985704</a></div><br/><div id="42512410" class="c"><input type="checkbox" id="c-42512410" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#42511600">parent</a><span>|</span><a href="#42513283">next</a><span>|</span><label class="collapse" for="c-42512410">[-]</label><label class="expand" for="c-42512410">[1 more]</label></div><br/><div class="children"><div class="content">You can do fetch and readable stream with SSE - here&#x27;s an excellent client library for that<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client">https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client</a></div><br/></div></div><div id="42513283" class="c"><input type="checkbox" id="c-42513283" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#42511600">parent</a><span>|</span><a href="#42512410">prev</a><span>|</span><a href="#42511822">next</a><span>|</span><label class="collapse" for="c-42513283">[-]</label><label class="expand" for="c-42513283">[1 more]</label></div><br/><div class="children"><div class="content">ReadableStream appears to be SSE without any defined standards for chunk separation. In practice, how is it any different from using SSE? It appears to use the same concept.</div><br/></div></div></div></div><div id="42511822" class="c"><input type="checkbox" id="c-42511822" checked=""/><div class="controls bullet"><span class="by">Tiberium</span><span>|</span><a href="#42511600">prev</a><span>|</span><a href="#42512157">next</a><span>|</span><label class="collapse" for="c-42511822">[-]</label><label class="expand" for="c-42511822">[1 more]</label></div><br/><div class="children"><div class="content">One thing I dislike regards to SSE, which is not its fault but probably a side effect of the perceived simplicity: lots of developers do not actually use proper implementations and instead just parse the data chunks with regex, or something of the sorts! This is bad because SSE, for example, supports comments (&quot;: text&quot;) in streams, which most of those hand-rolled implementations don&#x27;t support.<p>For example, my friend used an LLM proxy that sends keepalive&#x2F;queue data as SSE comments (just for debugging mainly), but it didn&#x27;t work for Gemini, because someone at Google decided to parse SSE with a regex:
<a href="https:&#x2F;&#x2F;github.com&#x2F;google-gemini&#x2F;generative-ai-js&#x2F;blob&#x2F;main&#x2F;src&#x2F;requests&#x2F;stream-reader.ts#L28">https:&#x2F;&#x2F;github.com&#x2F;google-gemini&#x2F;generative-ai-js&#x2F;blob&#x2F;main&#x2F;...</a> (and yes, if the regex doesn&#x27;t match the complete line, the library will just throw an error)</div><br/></div></div><div id="42512157" class="c"><input type="checkbox" id="c-42512157" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42511822">prev</a><span>|</span><a href="#42513524">next</a><span>|</span><label class="collapse" for="c-42512157">[-]</label><label class="expand" for="c-42512157">[9 more]</label></div><br/><div class="children"><div class="content">I tried implementing SSE in a web project of mine recently, and was very surprised when my website totally stopped working when I had more than 6 tabs open.<p>It turns out, Firefox counts SSE connections against the 6 host max connections limit, and gives absolutely no useful feedback that it&#x27;s blocking the subsequent requests due to this limit (I don&#x27;t remember the precise error code and message anymore, but it left me very clueless for a while). It was only when I stared at the lack of corresponding server side logs that it clicked.<p>I don&#x27;t know if this same problem happens with websockets or not.</div><br/><div id="42512179" class="c"><input type="checkbox" id="c-42512179" checked=""/><div class="controls bullet"><span class="by">uncomplexity_</span><span>|</span><a href="#42512157">parent</a><span>|</span><a href="#42512197">next</a><span>|</span><label class="collapse" for="c-42512179">[-]</label><label class="expand" for="c-42512179">[6 more]</label></div><br/><div class="children"><div class="content">wait let&#x27;s check this<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42511562">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42511562</a><p>at <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent_events&#x2F;Using_server-sent_events" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent...</a> it says<p>&quot;Warning: When not used over HTTP&#x2F;2, SSE suffers from a limitation to the maximum number of open connections, which can be especially painful when opening multiple tabs, as the limit is per browser and is set to a very low number (6). The issue has been marked as &quot;Won&#x27;t fix&quot; in Chrome and Firefox. This limit is per browser + domain, which means that you can open 6 SSE connections across all of the tabs to www.example1.com and another 6 SSE connections to www.example2.com (per Stack Overflow). When using HTTP&#x2F;2, the maximum number of simultaneous HTTP streams is negotiated between the server and the client (defaults to 100).&quot;<p>so the fix is just use http&#x2F;2 on server-side?</div><br/><div id="42512239" class="c"><input type="checkbox" id="c-42512239" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42512157">root</a><span>|</span><a href="#42512179">parent</a><span>|</span><a href="#42513245">next</a><span>|</span><label class="collapse" for="c-42512239">[-]</label><label class="expand" for="c-42512239">[4 more]</label></div><br/><div class="children"><div class="content">Or a SharedWorker that creates a single SSE connection for all your tabs.<p>SharedWorker is not very complicated but it&#x27;s another component to add. It would be cool if this was built into SSE instead.</div><br/><div id="42512301" class="c"><input type="checkbox" id="c-42512301" checked=""/><div class="controls bullet"><span class="by">uncomplexity_</span><span>|</span><a href="#42512157">root</a><span>|</span><a href="#42512239">parent</a><span>|</span><a href="#42512344">next</a><span>|</span><label class="collapse" for="c-42512301">[-]</label><label class="expand" for="c-42512301">[2 more]</label></div><br/><div class="children"><div class="content">okay wtf this is amazing, seems usable with websockets too.<p>usage of Shared Web Workers <a href="https:&#x2F;&#x2F;dev.to&#x2F;ayushgp&#x2F;scaling-websocket-connections-using-shared-workers-14mj" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;ayushgp&#x2F;scaling-websocket-connections-using-s...</a><p>caniuse Shared Web Workers 45% <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;sharedworkers" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;sharedworkers</a><p>caniuse BroadcastChannel 96% <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;broadcastchannel" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;broadcastchannel</a></div><br/><div id="42512458" class="c"><input type="checkbox" id="c-42512458" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#42512157">root</a><span>|</span><a href="#42512301">parent</a><span>|</span><a href="#42512344">next</a><span>|</span><label class="collapse" for="c-42512458">[-]</label><label class="expand" for="c-42512458">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the issue with SharedWorkers is that Android Chromium doesn&#x27;t support it yet. <a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40290702" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40290702</a><p>But rather than Broadcast Channel, you can also use the Web Locks API (<a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Locks_API" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Locks_A...</a>) rather than Broadcast Channel<p>This library (<a href="https:&#x2F;&#x2F;github.com&#x2F;pubkey&#x2F;broadcast-channel&#x2F;blob&#x2F;master&#x2F;src&#x2F;leader-election.js#L307">https:&#x2F;&#x2F;github.com&#x2F;pubkey&#x2F;broadcast-channel&#x2F;blob&#x2F;master&#x2F;src&#x2F;...</a>) from the fantastic RxDB javascript DB library uses WebLocks with a fallback to Broadcast Channel. But, WebLocks are supported on 96% of browsers, so probably safe to just use it exclusively now.</div><br/></div></div></div></div><div id="42512344" class="c"><input type="checkbox" id="c-42512344" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42512157">root</a><span>|</span><a href="#42512239">parent</a><span>|</span><a href="#42512301">prev</a><span>|</span><a href="#42513245">next</a><span>|</span><label class="collapse" for="c-42512344">[-]</label><label class="expand" for="c-42512344">[1 more]</label></div><br/><div class="children"><div class="content">Ultimately this is what I did. But if you need or want per-tab connection state it will get complicated in a hurry.</div><br/></div></div></div></div><div id="42513245" class="c"><input type="checkbox" id="c-42513245" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#42512157">root</a><span>|</span><a href="#42512179">parent</a><span>|</span><a href="#42512239">prev</a><span>|</span><a href="#42512197">next</a><span>|</span><label class="collapse" for="c-42513245">[-]</label><label class="expand" for="c-42513245">[1 more]</label></div><br/><div class="children"><div class="content">Even if they don&#x27;t change the default 6 open connection. They could have at least made it per tab rather than per site. [1] [2] And I dont understand why this hasn&#x27;t been done in the past 10 years.<p>What am I missing?<p>[1] <a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=906896" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=906896</a><p>[2] <a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40329530" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40329530</a></div><br/></div></div></div></div><div id="42512197" class="c"><input type="checkbox" id="c-42512197" checked=""/><div class="controls bullet"><span class="by">mikojan</span><span>|</span><a href="#42512157">parent</a><span>|</span><a href="#42512179">prev</a><span>|</span><a href="#42513524">next</a><span>|</span><label class="collapse" for="c-42512197">[-]</label><label class="expand" for="c-42512197">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only if not used over HTTP&#x2F;2 and it says so in the docs too[0]<p>[0]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;EventSource" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;EventSource</a></div><br/><div id="42512317" class="c"><input type="checkbox" id="c-42512317" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42512157">root</a><span>|</span><a href="#42512197">parent</a><span>|</span><a href="#42513524">next</a><span>|</span><label class="collapse" for="c-42512317">[-]</label><label class="expand" for="c-42512317">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK browsers require https with http2. This is a locally running server&#x2F;app which will probably never have https. Maybe there is an exception for localhost, I&#x27;m not sure.</div><br/></div></div></div></div></div></div><div id="42513524" class="c"><input type="checkbox" id="c-42513524" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#42512157">prev</a><span>|</span><a href="#42512076">next</a><span>|</span><label class="collapse" for="c-42513524">[-]</label><label class="expand" for="c-42513524">[1 more]</label></div><br/><div class="children"><div class="content">I built several internal tool to tail logs using SSE with Flask&#x2F;FastAPI. Easy to implement and maintain.<p>For FastAPI if you want some hooks when client disconnects aka nginx 499 errors, follow this simple tip<p><a href="https:&#x2F;&#x2F;github.com&#x2F;encode&#x2F;starlette&#x2F;discussions&#x2F;1776#discussioncomment-3207518">https:&#x2F;&#x2F;github.com&#x2F;encode&#x2F;starlette&#x2F;discussions&#x2F;1776#discuss...</a></div><br/></div></div><div id="42512076" class="c"><input type="checkbox" id="c-42512076" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42513524">prev</a><span>|</span><a href="#42511513">next</a><span>|</span><label class="collapse" for="c-42512076">[-]</label><label class="expand" for="c-42512076">[5 more]</label></div><br/><div class="children"><div class="content">Does anyone have a good trick for figuring out when the client side connection is closed?  I just kill the connection on the server every N minutes and force the client to reconnect, but it&#x27;s not exactly graceful.<p>Secondly, on iOS mobile, I&#x27;ve noticed that the EventSource seems to fall asleep at some point and not wake up when you switch back to the PWA. Does anyone know what&#x27;s up with that?</div><br/><div id="42513350" class="c"><input type="checkbox" id="c-42513350" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#42512076">parent</a><span>|</span><a href="#42512153">next</a><span>|</span><label class="collapse" for="c-42513350">[-]</label><label class="expand" for="c-42513350">[1 more]</label></div><br/><div class="children"><div class="content">The socket closes. Most languages bubble this back up to you with a connection closed exception. 
In python async world, it would be a cancelled error.</div><br/></div></div><div id="42512153" class="c"><input type="checkbox" id="c-42512153" checked=""/><div class="controls bullet"><span class="by">jesprenj</span><span>|</span><a href="#42512076">parent</a><span>|</span><a href="#42513350">prev</a><span>|</span><a href="#42511513">next</a><span>|</span><label class="collapse" for="c-42512153">[-]</label><label class="expand" for="c-42512153">[3 more]</label></div><br/><div class="children"><div class="content">Send a dummy event and see if you get an ACK in response. Depends on the library you&#x27;re using.</div><br/><div id="42512262" class="c"><input type="checkbox" id="c-42512262" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42512076">root</a><span>|</span><a href="#42512153">parent</a><span>|</span><a href="#42511513">next</a><span>|</span><label class="collapse" for="c-42512262">[-]</label><label class="expand" for="c-42512262">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no ack on a raw SSE stream, unfortunately -- unless you mean send an event and expect the client to issue an HTTP request to the server like a keepalive?</div><br/><div id="42513964" class="c"><input type="checkbox" id="c-42513964" checked=""/><div class="controls bullet"><span class="by">jauco</span><span>|</span><a href="#42512076">root</a><span>|</span><a href="#42512262">parent</a><span>|</span><a href="#42511513">next</a><span>|</span><label class="collapse" for="c-42513964">[-]</label><label class="expand" for="c-42513964">[1 more]</label></div><br/><div class="children"><div class="content">There should be an ACK on the tcp packet (IIRC it’s not a lateral ACK but something like it) and the server should handle a timeout on that as the connection being “closed” which can be returned to the connection opener.<p>You might want to look into timeouts or error callbacks on your connection library&#x2F;framework.</div><br/></div></div></div></div></div></div></div></div><div id="42511513" class="c"><input type="checkbox" id="c-42511513" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#42512076">prev</a><span>|</span><a href="#42513148">next</a><span>|</span><label class="collapse" for="c-42511513">[-]</label><label class="expand" for="c-42511513">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re underrated when they work™<p>Currently at work I&#x27;m having issues because 
- Auth between an embedded app and javascript&#x27;s  EventSource is not working, so I have to resort to a Microsoft package which doesn&#x27;t always work.
- Not every tunnel is fond of keep-alive (Cloudflare), so I had to switch to ngrok (until I found out they have a limit of 20k requests).<p>I know this isn&#x27;t the protocol&#x27;s fault, and I&#x27;m sure there&#x27;s something I&#x27;m missing, but my god is it frustrating.</div><br/><div id="42512473" class="c"><input type="checkbox" id="c-42512473" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#42511513">parent</a><span>|</span><a href="#42513148">next</a><span>|</span><label class="collapse" for="c-42512473">[-]</label><label class="expand" for="c-42512473">[1 more]</label></div><br/><div class="children"><div class="content">Try this sse client <a href="https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client">https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client</a></div><br/></div></div></div></div><div id="42513148" class="c"><input type="checkbox" id="c-42513148" checked=""/><div class="controls bullet"><span class="by">ksajadi</span><span>|</span><a href="#42511513">prev</a><span>|</span><a href="#42511786">next</a><span>|</span><label class="collapse" for="c-42513148">[-]</label><label class="expand" for="c-42513148">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious as to how everyone deals with HTTP&#x2F;2 requirements between the backend servers and the load balancer? By default, HTTP&#x2F;2 requires TLS which means either no SSL termination at the load balancer or a SSL cert generated per server with a different one for the front end load balancer. This all seems very inefficient.</div><br/><div id="42513184" class="c"><input type="checkbox" id="c-42513184" checked=""/><div class="controls bullet"><span class="by">kcb</span><span>|</span><a href="#42513148">parent</a><span>|</span><a href="#42513259">next</a><span>|</span><label class="collapse" for="c-42513184">[-]</label><label class="expand" for="c-42513184">[1 more]</label></div><br/><div class="children"><div class="content">Not sure how widespread this is but AWS load balancers don&#x27;t validate the backend cert in any way. So I just generate some random self signed cert and use it everywhere.</div><br/></div></div><div id="42513259" class="c"><input type="checkbox" id="c-42513259" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#42513148">parent</a><span>|</span><a href="#42513184">prev</a><span>|</span><a href="#42511786">next</a><span>|</span><label class="collapse" for="c-42513259">[-]</label><label class="expand" for="c-42513259">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need http2 on the actual backend. All limitations for SSE&#x2F;http1 are browser level. 
Just downgrade to http1 from the LB to backend, even without SSL. As long as LB to browser is http2 you should be fine.</div><br/><div id="42513385" class="c"><input type="checkbox" id="c-42513385" checked=""/><div class="controls bullet"><span class="by">ksajadi</span><span>|</span><a href="#42513148">root</a><span>|</span><a href="#42513259">parent</a><span>|</span><a href="#42511786">next</a><span>|</span><label class="collapse" for="c-42513385">[-]</label><label class="expand" for="c-42513385">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that going to affect the whole multiplexing &#x2F; multiple connection of SSEs?</div><br/></div></div></div></div></div></div><div id="42511786" class="c"><input type="checkbox" id="c-42511786" checked=""/><div class="controls bullet"><span class="by">schmichael</span><span>|</span><a href="#42513148">prev</a><span>|</span><a href="#42511717">next</a><span>|</span><label class="collapse" for="c-42511786">[-]</label><label class="expand" for="c-42511786">[3 more]</label></div><br/><div class="children"><div class="content">I’ve never understood the use of SSE over ndjson. Builtin browser support for SSE might be nice, but it seems fairly easy to handle ndjson? For non-browser consumers ndjson is almost assuredly easier to handle. ndjson works over any transport from HTTP&#x2F;0.9 to HTTP&#x2F;3 to raw TCP or unix sockets or any reliable transport protocol.</div><br/><div id="42511915" class="c"><input type="checkbox" id="c-42511915" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511786">parent</a><span>|</span><a href="#42511717">next</a><span>|</span><label class="collapse" for="c-42511915">[-]</label><label class="expand" for="c-42511915">[2 more]</label></div><br/><div class="children"><div class="content">Manually streaming a XHR and parsing the messages is significantly more work, and you lose the built-in browser API. But if you use a fetch ReadableStream with TLV messages I&#x27;m sold.</div><br/><div id="42512468" class="c"><input type="checkbox" id="c-42512468" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#42511786">root</a><span>|</span><a href="#42511915">parent</a><span>|</span><a href="#42511717">next</a><span>|</span><label class="collapse" for="c-42512468">[-]</label><label class="expand" for="c-42512468">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s SSE with fetch and streams <a href="https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client">https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client</a></div><br/></div></div></div></div></div></div><div id="42511717" class="c"><input type="checkbox" id="c-42511717" checked=""/><div class="controls bullet"><span class="by">yu3zhou4</span><span>|</span><a href="#42511786">prev</a><span>|</span><a href="#42513008">next</a><span>|</span><label class="collapse" for="c-42511717">[-]</label><label class="expand" for="c-42511717">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had no idea they exist until I began to use APIs serving LLM outputs. They work pretty well for this purpose from my experience. An alternative to SSE is web sockets for this purpose I suppose</div><br/></div></div><div id="42513008" class="c"><input type="checkbox" id="c-42513008" checked=""/><div class="controls bullet"><span class="by">_caw</span><span>|</span><a href="#42511717">prev</a><span>|</span><a href="#42511761">next</a><span>|</span><label class="collapse" for="c-42513008">[-]</label><label class="expand" for="c-42513008">[1 more]</label></div><br/><div class="children"><div class="content">&gt; SSE works seamlessly with existing HTTP infrastructure<p>This is false. SSE is not supported on many proxies, and isn&#x27;t even supported on some common local proxy tooling.</div><br/></div></div><div id="42511761" class="c"><input type="checkbox" id="c-42511761" checked=""/><div class="controls bullet"><span class="by">sbergjohansen</span><span>|</span><a href="#42513008">prev</a><span>|</span><a href="#42511881">next</a><span>|</span><label class="collapse" for="c-42511761">[-]</label><label class="expand" for="c-42511761">[1 more]</label></div><br/><div class="children"><div class="content">Previous related discussion (2022):<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30403438">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30403438</a> (100 comments)</div><br/></div></div><div id="42511881" class="c"><input type="checkbox" id="c-42511881" checked=""/><div class="controls bullet"><span class="by">Tiberium</span><span>|</span><a href="#42511761">prev</a><span>|</span><a href="#42511530">next</a><span>|</span><label class="collapse" for="c-42511881">[-]</label><label class="expand" for="c-42511881">[5 more]</label></div><br/><div class="children"><div class="content">Also, another day, another mostly AI-written article on HN&#x27;s top page :)</div><br/><div id="42513926" class="c"><input type="checkbox" id="c-42513926" checked=""/><div class="controls bullet"><span class="by">slow_typist</span><span>|</span><a href="#42511881">parent</a><span>|</span><a href="#42512097">next</a><span>|</span><label class="collapse" for="c-42513926">[-]</label><label class="expand" for="c-42513926">[1 more]</label></div><br/><div class="children"><div class="content">What makes you think the article is AI-written?</div><br/></div></div><div id="42512097" class="c"><input type="checkbox" id="c-42512097" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42511881">parent</a><span>|</span><a href="#42513926">prev</a><span>|</span><a href="#42511530">next</a><span>|</span><label class="collapse" for="c-42512097">[-]</label><label class="expand" for="c-42512097">[3 more]</label></div><br/><div class="children"><div class="content">It’s funny how HN has a mix of people who think AGI is just around the corner, people trying to build&#x2F;sell stuff that uses LLMs, and others who can’t stand LLM-generated content. Makes me wonder how much overlap there is between these groups.</div><br/><div id="42512264" class="c"><input type="checkbox" id="c-42512264" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42511881">root</a><span>|</span><a href="#42512097">parent</a><span>|</span><a href="#42512226">next</a><span>|</span><label class="collapse" for="c-42512264">[-]</label><label class="expand" for="c-42512264">[1 more]</label></div><br/><div class="children"><div class="content">Those are not incompatible positions at all. You can think great AI is around the corner and still dislike today&#x27;s not-great AI writing.</div><br/></div></div><div id="42512226" class="c"><input type="checkbox" id="c-42512226" checked=""/><div class="controls bullet"><span class="by">Tiberium</span><span>|</span><a href="#42511881">root</a><span>|</span><a href="#42512097">parent</a><span>|</span><a href="#42512264">prev</a><span>|</span><a href="#42511530">next</a><span>|</span><label class="collapse" for="c-42512226">[-]</label><label class="expand" for="c-42512226">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have anything against LLMs, I use them daily myself, but publishing content that&#x27;s largely AI-generated without a disclaimer just feels dishonest to me. Oh, and also when people don&#x27;t spend at least some effort to make the style more natural, not those bullet point lists in the article that e.g. Claude loves so much.</div><br/></div></div></div></div></div></div><div id="42511530" class="c"><input type="checkbox" id="c-42511530" checked=""/><div class="controls bullet"><span class="by">programmarchy</span><span>|</span><a href="#42511881">prev</a><span>|</span><a href="#42511883">next</a><span>|</span><label class="collapse" for="c-42511530">[-]</label><label class="expand" for="c-42511530">[1 more]</label></div><br/><div class="children"><div class="content">Great post. I discovered SSE when building a chatbot and found out it’s what OpenAI used rather than WebSockets. The batteries-included automatic reconnection is huge, and the format is surprisingly human readable.</div><br/></div></div><div id="42511883" class="c"><input type="checkbox" id="c-42511883" checked=""/><div class="controls bullet"><span class="by">whatever1</span><span>|</span><a href="#42511530">prev</a><span>|</span><a href="#42512098">next</a><span>|</span><label class="collapse" for="c-42511883">[-]</label><label class="expand" for="c-42511883">[1 more]</label></div><br/><div class="children"><div class="content">Can Django with vanilla gunicorn do this ?</div><br/></div></div><div id="42512098" class="c"><input type="checkbox" id="c-42512098" checked=""/><div class="controls bullet"><span class="by">henning</span><span>|</span><a href="#42511883">prev</a><span>|</span><a href="#42511516">next</a><span>|</span><label class="collapse" for="c-42512098">[-]</label><label class="expand" for="c-42512098">[1 more]</label></div><br/><div class="children"><div class="content">They are handy for implementing simple ad-hoc hot reloading systems as well. E.g. you can have whatever file watcher you are using call an API when a file of interest changes that sends an event to listening clients on the frontend. You can also trigger an event after restarting the backend if you make an API change by triggering the event at boot time. Then you can just add a dev-only snippet to your base template that reloads the page or whatever. Better than nothing if your stack doesn&#x27;t support it out of the box and doesn&#x27;t take very much code or require adding any additional project dependencies. Not as sophisticated as React environments that will only reload a component that changed and only do a full page refresh if needed, but it still gives a nice, responsive feeling when paired with tools that recompile your backend when it changes.</div><br/></div></div><div id="42511516" class="c"><input type="checkbox" id="c-42511516" checked=""/><div class="controls bullet"><span class="by">condiment</span><span>|</span><a href="#42512098">prev</a><span>|</span><label class="collapse" for="c-42511516">[-]</label><label class="expand" for="c-42511516">[8 more]</label></div><br/><div class="children"><div class="content">So it’s websockets, only instead of the Web server needing to handle the protocol upgrade, you just piggyback on HTTP with an in-band protocol.<p>I’m not sure this makes sense in 2024. Pretty much every web server supports websockets at this point, and so do all of the browsers. You can easily impose the constraint on your code that communication through a websocket is mono-directional. And the capability to broadcast a message to all subscribers is going to be deceptively complex, no matter how you broadcast it.</div><br/><div id="42511553" class="c"><input type="checkbox" id="c-42511553" checked=""/><div class="controls bullet"><span class="by">realPubkey</span><span>|</span><a href="#42511516">parent</a><span>|</span><a href="#42511549">next</a><span>|</span><label class="collapse" for="c-42511553">[-]</label><label class="expand" for="c-42511553">[6 more]</label></div><br/><div class="children"><div class="content">Yes most servers support websockets. But unfortunately most proxies and firewalls do not, especially in big company networks. Suggesting my users to use SSEs for my database replication stream solved most of their problems. Also setting up a SSE endpoint is like 5 lines of code. WebSockets instead require much more and you also have to do things like pings etc to ensure that it automatically reconnects. SEEs with the JavaScript EventSource API have all you need build in:<p><a href="https:&#x2F;&#x2F;rxdb.info&#x2F;articles&#x2F;websockets-sse-polling-webrtc-webtransport.html" rel="nofollow">https:&#x2F;&#x2F;rxdb.info&#x2F;articles&#x2F;websockets-sse-polling-webrtc-web...</a></div><br/><div id="42511673" class="c"><input type="checkbox" id="c-42511673" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#42511516">root</a><span>|</span><a href="#42511553">parent</a><span>|</span><a href="#42511549">next</a><span>|</span><label class="collapse" for="c-42511673">[-]</label><label class="expand" for="c-42511673">[5 more]</label></div><br/><div class="children"><div class="content">SSE also works well on HTTP&#x2F;3 whereas web sockets still don’t.</div><br/><div id="42511698" class="c"><input type="checkbox" id="c-42511698" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511516">root</a><span>|</span><a href="#42511673">parent</a><span>|</span><a href="#42511549">next</a><span>|</span><label class="collapse" for="c-42511698">[-]</label><label class="expand" for="c-42511698">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see much point in WebSockets for HTTP&#x2F;3. WebTransport will cover everything you would need it for an more.</div><br/><div id="42511796" class="c"><input type="checkbox" id="c-42511796" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#42511516">root</a><span>|</span><a href="#42511698">parent</a><span>|</span><a href="#42511549">next</a><span>|</span><label class="collapse" for="c-42511796">[-]</label><label class="expand" for="c-42511796">[3 more]</label></div><br/><div class="children"><div class="content">That might very well be but the future is not today.</div><br/><div id="42511842" class="c"><input type="checkbox" id="c-42511842" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42511516">root</a><span>|</span><a href="#42511796">parent</a><span>|</span><a href="#42511549">next</a><span>|</span><label class="collapse" for="c-42511842">[-]</label><label class="expand" for="c-42511842">[2 more]</label></div><br/><div class="children"><div class="content">But why add it to HTTP&#x2F;3 at all? HTTP&#x2F;1.1 hijacking is a pretty simple process. I suspect HTTP&#x2F;3 would be significantly more complicated. I&#x27;m not sure that effort is worth it when WebTransport will make it obselete.</div><br/><div id="42513561" class="c"><input type="checkbox" id="c-42513561" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#42511516">root</a><span>|</span><a href="#42511842">parent</a><span>|</span><a href="#42511549">next</a><span>|</span><label class="collapse" for="c-42513561">[-]</label><label class="expand" for="c-42513561">[1 more]</label></div><br/><div class="children"><div class="content">It was added to HTTP&#x2F;2 as well and there is an RFC.  (Though a lot of servers don’t support it even on HTTP&#x2F;2)<p>My point is mostly that SSE works well and is supported and that has A meaningful benefit today.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>