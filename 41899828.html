<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729501267894" as="style"/><link rel="stylesheet" href="styles.css?v=1729501267894"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3444r0.html">Memory safety without lifetime parameters</a> <span class="domain">(<a href="https://www.open-std.org">www.open-std.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>23 comments</span></div><br/><div><div id="41900511" class="c"><input type="checkbox" id="c-41900511" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41901853">next</a><span>|</span><label class="collapse" for="c-41900511">[-]</label><label class="expand" for="c-41900511">[8 more]</label></div><br/><div class="children"><div class="content">Not sure what to make of this. Is this a feature, or a whole design?<p>The idea here is simply that if the whole call tree can be examined, rather than only looking at one module at a time, less annotation is needed. That&#x27;s reasonable enough, although it may result in long compile times.<p>What I don&#x27;t see here is:<p>- How are circular references handled?<p>- C++ objects implicitly have links from parent to child and child to parent. So there&#x27;s built-in circularity. How does that work?<p>- What about interior mutability?<p>Examining the whole call tree is useful. It allows catching mutex deadlocks where a thread locks against itself and stalls. It may be possible to replace something like Rust&#x27;s RefCell with something, perhaps &quot;SafeCell&quot;, that supports the same .borrow() and .borrow_mut operations, checking them at compile time for overlapping borrow scopes.</div><br/><div id="41900857" class="c"><input type="checkbox" id="c-41900857" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41900511">parent</a><span>|</span><a href="#41900691">next</a><span>|</span><label class="collapse" for="c-41900857">[-]</label><label class="expand" for="c-41900857">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure what to make of this. Is this a feature, or a whole design?<p>My (high-level) understanding is that this is a response to some feedback [1, 2] to the author&#x27;s previous paper [0] which (<i>very</i> generally speaking) adds some Rust-like systems&#x2F;semantics to C++ to achieve memory safety. Some commenters voiced disapproval of the need for lifetime annotations and expressed a desire to find a solution that doesn&#x27;t require them. I think this paper is an exploration of that idea to see what can be achieved without lifetime annotations.<p>[0]: <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p3444r0.html" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p34...</a><p>[1]: <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1ffgz49&#x2F;safe_c_language_extensions_for_memory_safety&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1ffgz49&#x2F;safe_c_languag...</a><p>[2]: <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1fiuhb7&#x2F;the_empire_of_c_strikes_back_with_safe_c_proposal&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1fiuhb7&#x2F;the_empire_of_...</a></div><br/></div></div><div id="41900691" class="c"><input type="checkbox" id="c-41900691" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#41900511">parent</a><span>|</span><a href="#41900857">prev</a><span>|</span><a href="#41901853">next</a><span>|</span><label class="collapse" for="c-41900691">[-]</label><label class="expand" for="c-41900691">[6 more]</label></div><br/><div class="children"><div class="content">&gt; - C++ objects implicitly have links from parent to child and child to parent. So there&#x27;s built-in circularity. How does that work?<p>Can you elaborate? 
In my understand, the parent&#x2F;child relation are on the class not the object itself.</div><br/><div id="41901096" class="c"><input type="checkbox" id="c-41901096" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41900511">root</a><span>|</span><a href="#41900691">parent</a><span>|</span><a href="#41901853">next</a><span>|</span><label class="collapse" for="c-41901096">[-]</label><label class="expand" for="c-41901096">[5 more]</label></div><br/><div class="children"><div class="content">A child class can reference fields in the parent, and                                                                    the parent can call virtual functions in the child.</div><br/><div id="41901223" class="c"><input type="checkbox" id="c-41901223" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#41900511">root</a><span>|</span><a href="#41901096">parent</a><span>|</span><a href="#41901853">next</a><span>|</span><label class="collapse" for="c-41901223">[-]</label><label class="expand" for="c-41901223">[4 more]</label></div><br/><div class="children"><div class="content">You mean vtable for inheritance? There&#x27;s no ownership relation here.</div><br/><div id="41901311" class="c"><input type="checkbox" id="c-41901311" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#41900511">root</a><span>|</span><a href="#41901223">parent</a><span>|</span><a href="#41901853">next</a><span>|</span><label class="collapse" for="c-41901311">[-]</label><label class="expand" for="c-41901311">[3 more]</label></div><br/><div class="children"><div class="content">Well, there is: it&#x27;s easy to trigger unsafe behaviour by calling a virtual method accessing a child class data member (say some std::vector) when in the parent class destructor, as the child sub object will already have been destroyed. Thus it&#x27;s reasonable to say that there is a bidirectional ownership relationship.</div><br/><div id="41901437" class="c"><input type="checkbox" id="c-41901437" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41900511">root</a><span>|</span><a href="#41901311">parent</a><span>|</span><a href="#41901439">next</a><span>|</span><label class="collapse" for="c-41901437">[-]</label><label class="expand" for="c-41901437">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Rust has safe destructor semantics. C++ does not.<p>Back references are really hard in Rust. You can do them with Rc, RefCell, and Weak, but there&#x27;s a lot of run-time checking involved. More static analysis could eliminate most of that run-time checking. .borrow(), .borrow_mut(), and .upgrade().unwrap() panic if they ever fail. So you really want to prove they can&#x27;t fail. If you can do that, you don&#x27;t need the run-time checks. In that direction lies the solution to Rust&#x27;s limited data structure problems.</div><br/></div></div><div id="41901439" class="c"><input type="checkbox" id="c-41901439" checked=""/><div class="controls bullet"><span class="by">messe</span><span>|</span><a href="#41900511">root</a><span>|</span><a href="#41901311">parent</a><span>|</span><a href="#41901437">prev</a><span>|</span><a href="#41901853">next</a><span>|</span><label class="collapse" for="c-41901439">[-]</label><label class="expand" for="c-41901439">[1 more]</label></div><br/><div class="children"><div class="content">When in the parent class destructor, the v-table will point toward the parent&#x27;s v-table not the child&#x27;s (try it out), so I&#x27;m not sure how you&#x27;d call a virtual method accessing a child member.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41901853" class="c"><input type="checkbox" id="c-41901853" checked=""/><div class="controls bullet"><span class="by">devnull3</span><span>|</span><a href="#41900511">prev</a><span>|</span><a href="#41900229">next</a><span>|</span><label class="collapse" for="c-41901853">[-]</label><label class="expand" for="c-41901853">[2 more]</label></div><br/><div class="children"><div class="content">This appears to be a out of season April Fool&#x27;s joke.<p>Am I the only one who thinks the this sacrifices the readability?</div><br/><div id="41901999" class="c"><input type="checkbox" id="c-41901999" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#41901853">parent</a><span>|</span><a href="#41900229">next</a><span>|</span><label class="collapse" for="c-41901999">[-]</label><label class="expand" for="c-41901999">[1 more]</label></div><br/><div class="children"><div class="content">It may be done on purpose? To me this looks like a satirical piece in response to some &quot;nooooo how dare you introduce lifetime annotations to C++&quot;-style comments on the same author (Sean Baxter)&#x27;s C++ lifetime annotation proposal.</div><br/></div></div></div></div><div id="41900229" class="c"><input type="checkbox" id="c-41900229" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#41901853">prev</a><span>|</span><a href="#41900239">next</a><span>|</span><label class="collapse" for="c-41900229">[-]</label><label class="expand" for="c-41900229">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This proposal implements two sets of constraint rules. Free functions constrain return references by the shortest of the argument lifetimes. Non-static member functions constrain return references by the implicit object lifetime.<p>It seems like this proposal just chooses a general set of constraints and forces it everywhere? Under these rules you couldn&#x27;t e.g., have a regex object with a match method that takes a string and returns a reference to that same string. Seems too limiting to be practical.</div><br/><div id="41900247" class="c"><input type="checkbox" id="c-41900247" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41900229">parent</a><span>|</span><a href="#41900239">next</a><span>|</span><label class="collapse" for="c-41900247">[-]</label><label class="expand" for="c-41900247">[1 more]</label></div><br/><div class="children"><div class="content">No, it explores this particular design, but concludes that lifetime annotations are needed.</div><br/></div></div></div></div><div id="41900239" class="c"><input type="checkbox" id="c-41900239" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41900229">prev</a><span>|</span><a href="#41900504">next</a><span>|</span><label class="collapse" for="c-41900239">[-]</label><label class="expand" for="c-41900239">[1 more]</label></div><br/><div class="children"><div class="content">The draft for this paper was submitted a few days ago at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41850258">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41850258</a> (3 points, no comments). Not sure if there are any differences between the two versions.</div><br/></div></div><div id="41900504" class="c"><input type="checkbox" id="c-41900504" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#41900239">prev</a><span>|</span><a href="#41900080">next</a><span>|</span><label class="collapse" for="c-41900504">[-]</label><label class="expand" for="c-41900504">[6 more]</label></div><br/><div class="children"><div class="content">Overall interesting read. I&#x27;m rooting for Sean. If he has faith that C++ is not too far gone to be saved...perhaps I can, too.<p>&gt; Explain the infeasibility of making legacy lvalue- and rvalue-references memory safe.<p>&gt; Relocation must replace move semantics<p>He advocates for adding lots of things to the language, but that point is a massive change to the language IMO. I definitely think move semantics are awful; as is the hierarchy of rvalues (xvalues and glvalues) is nuts, but at this point can they be removed from the language? Or do I misinterpret the point? Perhaps this is different between unsafe blocks (vs default safe blocks)?</div><br/><div id="41901262" class="c"><input type="checkbox" id="c-41901262" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41900504">parent</a><span>|</span><a href="#41900080">next</a><span>|</span><label class="collapse" for="c-41901262">[-]</label><label class="expand" for="c-41901262">[5 more]</label></div><br/><div class="children"><div class="content">If you check the flames on Reddit, not sure if he will keep at it, the WG21 feedback has been pretty disapointing, hence this paper, as kind of response to those replies.<p>Most folks at WG21 think profiles will magically solve the problem, even though many of the ideas are only available on paper, not a random C++ compiler.<p>The biggest issue is that while a language like Ada also has profiles, the safety culture is much different, and they are part of the ecosystem since Ada83, not something that was added later.</div><br/><div id="41901501" class="c"><input type="checkbox" id="c-41901501" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#41900504">root</a><span>|</span><a href="#41901262">parent</a><span>|</span><a href="#41901470">next</a><span>|</span><label class="collapse" for="c-41901501">[-]</label><label class="expand" for="c-41901501">[1 more]</label></div><br/><div class="children"><div class="content">It is a gargantuan endeavour tbh. I am writing safety C++ code for a living and still am undecided if it is a good idea to continue to do so. Safety benefits a lot from understandability and that is undoubtedly better with simple code and a simple(r) language.<p>Trying to keep the legacy code alive through compatibility introduces more than two languages in one, as all the combinations must be understood as well. Wrapping legacy code into bigger &quot;unsafe&quot; blocks and guarding the perimeter of that block is not a bad idea, it creates less mix to reason about.<p>Would allowing only safe references in safety code really hinder adoption?</div><br/></div></div><div id="41901470" class="c"><input type="checkbox" id="c-41901470" checked=""/><div class="controls bullet"><span class="by">blub</span><span>|</span><a href="#41900504">root</a><span>|</span><a href="#41901262">parent</a><span>|</span><a href="#41901501">prev</a><span>|</span><a href="#41900080">next</a><span>|</span><label class="collapse" for="c-41901470">[-]</label><label class="expand" for="c-41901470">[3 more]</label></div><br/><div class="children"><div class="content">Author’s paper also doesn’t solve the problem, because I wager most C++ programmers wouldn’t touch this rustified C++, which manages to look even worse than the already not light on the eyes original.</div><br/><div id="41901562" class="c"><input type="checkbox" id="c-41901562" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41900504">root</a><span>|</span><a href="#41901470">parent</a><span>|</span><a href="#41900080">next</a><span>|</span><label class="collapse" for="c-41901562">[-]</label><label class="expand" for="c-41901562">[2 more]</label></div><br/><div class="children"><div class="content">Probably, but then they will need to decide how much they feel like if C++ joins the computing equivalent of hazardous goods, where products written on it only have clearance for specific use cases.<p>See &quot;Product Security Bad Practices&quot; from CISA and FBI, published last week.<p><a href="https:&#x2F;&#x2F;www.cisa.gov&#x2F;resources-tools&#x2F;resources&#x2F;product-security-bad-practices" rel="nofollow">https:&#x2F;&#x2F;www.cisa.gov&#x2F;resources-tools&#x2F;resources&#x2F;product-secur...</a><p>=&gt; &quot;Software manufacturers should build products in a manner that systematically prevents the introduction of memory safety vulnerabilities, such as by using a memory safe language or hardware capabilities that prevent memory safety vulnerabilities. Additionally, software manufacturers should publish a memory safety roadmap by January 1, 2026.&quot;</div><br/><div id="41902039" class="c"><input type="checkbox" id="c-41902039" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#41900504">root</a><span>|</span><a href="#41901562">parent</a><span>|</span><a href="#41900080">next</a><span>|</span><label class="collapse" for="c-41902039">[-]</label><label class="expand" for="c-41902039">[1 more]</label></div><br/><div class="children"><div class="content">&gt; such as by using a memory safe language or hardware capabilities that prevent memory safety vulnerabilities<p>Heh, now I do believe that my partially-memory-corruption-based side job may be in danger. If it was just &quot;by using a memory safe language&quot; I do not care, but if they want to boost hardware assisted mitigations (better and ubiquitous memory tagging etc) it&#x27;s going to have significant impact.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41900632" class="c"><input type="checkbox" id="c-41900632" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#41900080">prev</a><span>|</span><label class="collapse" for="c-41900632">[-]</label><label class="expand" for="c-41900632">[1 more]</label></div><br/><div class="children"><div class="content">Seeing this on HN feels a bit like those apocryphal stories of the professor who hands out the &quot;read all the questions before you start&quot; quiz, and the last question just tells the students to ignore everything else, wait 30 minutes and leave for full marks.</div><br/></div></div></div></div></div></div></div></body></html>