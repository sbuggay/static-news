<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703408453838" as="style"/><link rel="stylesheet" href="styles.css?v=1703408453838"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.allegro.tech/2023/11/how-does-btree-make-your-queries-fast.html">How does a B-tree make queries fast?</a> <span class="domain">(<a href="https://blog.allegro.tech">blog.allegro.tech</a>)</span></div><div class="subtext"><span>jaycox2931</span> | <span>40 comments</span></div><br/><div><div id="38749726" class="c"><input type="checkbox" id="c-38749726" checked=""/><div class="controls bullet"><span class="by">dicroce</span><span>|</span><a href="#38751830">next</a><span>|</span><label class="collapse" for="c-38749726">[-]</label><label class="expand" for="c-38749726">[10 more]</label></div><br/><div class="children"><div class="content">I always think discussions like this should start with the following: A database with no indexes is slow. Finding a particular row will require a linear search. Adding an index on a column means that your optimizing finding rows by the values of that column. Hence, an index is really a mapping of a particular column&#x27;s value to the position in the db OF that row (very likely an 8 byte sized integer that is the offset into the file of the row in question).<p>This all means we can implement indexes as b-trees where the keys are the values of a particular column and the value is the file offset of the row with that value. You could envision a simple db format where indexes and the main row file are stored in separate files. In such a database you could drop an index simply by deleting the indexes file (or add one by creating it). The main row file actually has all of the data and so indexes can be recreated if necessary (at expense of course).</div><br/><div id="38750645" class="c"><input type="checkbox" id="c-38750645" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#38749726">parent</a><span>|</span><a href="#38749973">next</a><span>|</span><label class="collapse" for="c-38750645">[-]</label><label class="expand" for="c-38750645">[3 more]</label></div><br/><div class="children"><div class="content"><i>A database with no indexes is slow. Finding a particular row will require a linear search.</i><p>The crux is understanding what data access patterns you will have and what indexes &#x2F; data structures accelerate that access pattern. &quot;Index = fast&quot; is a painfully pernicious untrue meme. It&#x27;s absolutely true for application tables with queries only touching a few rows. On the other hand, analytics queries touching a high proportion of rows with joins on equality conditions (ie. hash joinable) isn&#x27;t going to go any faster with an index.<p>I&#x27;ve seen devs shotgun indexes at tables to fix performance (done it myself too) but the real test of index understanding is when that doesn&#x27;t work.</div><br/><div id="38751264" class="c"><input type="checkbox" id="c-38751264" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38750645">parent</a><span>|</span><a href="#38750844">next</a><span>|</span><label class="collapse" for="c-38751264">[-]</label><label class="expand" for="c-38751264">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On the other hand, analytics queries touching a high proportion of rows with joins on equality conditions (ie. hash joinable) isn&#x27;t going to go any faster with an index.<p>That&#x27;s when you bring a BRIN to the table. :-)</div><br/></div></div><div id="38750844" class="c"><input type="checkbox" id="c-38750844" checked=""/><div class="controls bullet"><span class="by">darkclouds</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38750645">parent</a><span>|</span><a href="#38751264">prev</a><span>|</span><a href="#38749973">next</a><span>|</span><label class="collapse" for="c-38750844">[-]</label><label class="expand" for="c-38750844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The crux is understanding what data access patterns you will have and what indexes &#x2F; data structures accelerate that access pattern<p>We have a winner. But when looking at SQL tables&#x2F;Views&#x2F;Stored Procedures, the data is also stored in order in memory, in effect have a master database and files on disk, with sorted databases and files in memory for faster access.</div><br/></div></div></div></div><div id="38749973" class="c"><input type="checkbox" id="c-38749973" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38749726">parent</a><span>|</span><a href="#38750645">prev</a><span>|</span><a href="#38751830">next</a><span>|</span><label class="collapse" for="c-38749973">[-]</label><label class="expand" for="c-38749973">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve implemented a high performance btree this way in the past, where each table and each index were separate files (with append-only writes for concurrency). It worked pretty well and wasn&#x27;t hard to get right, but it had some downsides (in particular, the kernel seemed to struggle with all the paging.)</div><br/><div id="38750056" class="c"><input type="checkbox" id="c-38750056" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38749973">parent</a><span>|</span><a href="#38751830">next</a><span>|</span><label class="collapse" for="c-38750056">[-]</label><label class="expand" for="c-38750056">[5 more]</label></div><br/><div class="children"><div class="content">&gt; a high performance btree<p>then …<p>&gt; the kernel seemed to struggle …<p>What was the struggle? If it’s performance doesn’t that contradict your earlier statement?<p>Genuinely interested in what the issue was, not trying to be a pedant</div><br/><div id="38750213" class="c"><input type="checkbox" id="c-38750213" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38750056">parent</a><span>|</span><a href="#38750975">next</a><span>|</span><label class="collapse" for="c-38750213">[-]</label><label class="expand" for="c-38750213">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What was the struggle?<p>Performance is always great until you have to hit disk. Not uncommon to rely on mmap at which point your disk access is sub-optimal vs. a hand-tailored buffer manager with strategies to improve disk reads.</div><br/><div id="38750773" class="c"><input type="checkbox" id="c-38750773" checked=""/><div class="controls bullet"><span class="by">sschnei8</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38750213">parent</a><span>|</span><a href="#38750960">next</a><span>|</span><label class="collapse" for="c-38750773">[-]</label><label class="expand" for="c-38750773">[1 more]</label></div><br/><div class="children"><div class="content">This requires the obligatory <a href="https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022&#x2F;</a></div><br/></div></div><div id="38750960" class="c"><input type="checkbox" id="c-38750960" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38750213">parent</a><span>|</span><a href="#38750773">prev</a><span>|</span><a href="#38750975">next</a><span>|</span><label class="collapse" for="c-38750960">[-]</label><label class="expand" for="c-38750960">[1 more]</label></div><br/><div class="children"><div class="content">the purpose of a btree is to optimize when you are hitting the disk, you can&#x27;t call that the struggle, that&#x27;s when the btree sings (tho you could consider extensible hashing)</div><br/></div></div></div></div><div id="38750975" class="c"><input type="checkbox" id="c-38750975" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38749726">root</a><span>|</span><a href="#38750056">parent</a><span>|</span><a href="#38750213">prev</a><span>|</span><a href="#38751830">next</a><span>|</span><label class="collapse" for="c-38750975">[-]</label><label class="expand" for="c-38750975">[1 more]</label></div><br/><div class="children"><div class="content">My throughput was significantly higher than sqlite (4x or so, if memory serves), but the kernel spent so much time swapping pages that the mouse cursor stuttered.<p>A custom page manager would have probably done the trick, but I don&#x27;t have the technical chops to write one.</div><br/></div></div></div></div></div></div></div></div><div id="38751830" class="c"><input type="checkbox" id="c-38751830" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#38749726">prev</a><span>|</span><a href="#38748845">next</a><span>|</span><label class="collapse" for="c-38751830">[-]</label><label class="expand" for="c-38751830">[4 more]</label></div><br/><div class="children"><div class="content">&gt; To sum up, the key takeaway is to prefer sequential access wherever we can.<p>For spinning disks, this is obvious. But why is sequential access faster on SSDs?</div><br/><div id="38752148" class="c"><input type="checkbox" id="c-38752148" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#38751830">parent</a><span>|</span><a href="#38752120">next</a><span>|</span><label class="collapse" for="c-38752148">[-]</label><label class="expand" for="c-38752148">[1 more]</label></div><br/><div class="children"><div class="content">Like sibling said, physical pages are typically much bigger than logical pages in SSDs. Also drives do prediction and sequential access is easy to predict.</div><br/></div></div><div id="38752120" class="c"><input type="checkbox" id="c-38752120" checked=""/><div class="controls bullet"><span class="by">wizerno</span><span>|</span><a href="#38751830">parent</a><span>|</span><a href="#38752148">prev</a><span>|</span><a href="#38751978">next</a><span>|</span><label class="collapse" for="c-38752120">[-]</label><label class="expand" for="c-38752120">[1 more]</label></div><br/><div class="children"><div class="content">TLDR; Garbage Collection.<p>In an SSD, a write operation can only be done when the page is already erased. However, the unit of read&#x2F;write operations are a page, while the unit of erase operation is a block. That means for a disk write, a naive implementation needs to read the whole block, erase the block, then write updated data back to the block, which is unacceptable. Furthermore, blocks should wear out uniformly, otherwise, the SSD would lose capacity.<p>To tackle these problems, SSD introduces Flash Translation Layer (FTL) which helps to build an illusion of random access device. To achieve this, FTL employs an approach very similar to LSM trees. Writes are always written to new, already erased pages, while in the background, garbage collects (GC) outdated data. FTL needs to keep a map from the user’s logical address to physical address on SSD, both in-memory and persistently.<p>So to answer your question, why are sequential writes are faster than random writes on SSDs? Because the address map table is smaller since new data is consecutive in larger chunks. Garbage Collection is simpler and only metadata needs to be updated. Erasing a block is required anyway.</div><br/></div></div><div id="38751978" class="c"><input type="checkbox" id="c-38751978" checked=""/><div class="controls bullet"><span class="by">zerr</span><span>|</span><a href="#38751830">parent</a><span>|</span><a href="#38752120">prev</a><span>|</span><a href="#38748845">next</a><span>|</span><label class="collapse" for="c-38751978">[-]</label><label class="expand" for="c-38751978">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d assume at some level of IO, blocks&#x2F;pages&#x2F;whole buffers are being read, as opposed to reading bytes one by one. So the sequental access takes advantage of this I suppose.</div><br/></div></div></div></div><div id="38748845" class="c"><input type="checkbox" id="c-38748845" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#38751830">prev</a><span>|</span><a href="#38749116">next</a><span>|</span><label class="collapse" for="c-38748845">[-]</label><label class="expand" for="c-38748845">[3 more]</label></div><br/><div class="children"><div class="content">Another neat part is that, for intersecting different B-trees, you can use a technique like this to get very efficient algorithm: <a href="https:&#x2F;&#x2F;nlp.stanford.edu&#x2F;IR-book&#x2F;html&#x2F;htmledition&#x2F;faster-postings-list-intersection-via-skip-pointers-1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;nlp.stanford.edu&#x2F;IR-book&#x2F;html&#x2F;htmledition&#x2F;faster-pos...</a><p>(Here discussed in terms of skip lists, but they are similar enough that the distinction doesn&#x27;t matter)</div><br/><div id="38749034" class="c"><input type="checkbox" id="c-38749034" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38748845">parent</a><span>|</span><a href="#38749116">next</a><span>|</span><label class="collapse" for="c-38749034">[-]</label><label class="expand" for="c-38749034">[2 more]</label></div><br/><div class="children"><div class="content">Note that the real primitive is &quot;find nearest [with hint]&quot;, which has to be the #1 thing I miss in Python.<p>For B-trees it&#x27;s only going to be a significant win if the chance of intersection is small, less than about `1&#x2F;(nodes_per_block)`. For binary trees it&#x27;s a much bigger win since that becomes 1&#x2F;2 and binary trees are horrible on cache.<p>Hmm, can you efficiently intersect an arbitrary number of B-trees using the same idea as a heap-merge, but with a max heap instead of a min heap? You&#x27;d still have to iterate over all on a match, but as long as 2 input trees don&#x27;t have an intersection, you don&#x27;t have to look at the others at all ... or does that become equivalent to just doing them in series?</div><br/><div id="38749443" class="c"><input type="checkbox" id="c-38749443" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#38748845">root</a><span>|</span><a href="#38749034">parent</a><span>|</span><a href="#38749116">next</a><span>|</span><label class="collapse" for="c-38749443">[-]</label><label class="expand" for="c-38749443">[1 more]</label></div><br/><div class="children"><div class="content">A nuance that is important here is that not all accesses are equal within the context of disk reads.  B-trees are designed to minimize block reads, not memory operations.<p>I guess there are worst case scenarios with evenly spaced intersections spread out exactly one per block, but in terms of block reads it fundamentally doesn&#x27;t matter how you intersect two such trees, you&#x27;ll still have to read all blocks, and that is orders of magnitude slower than comparing the values within.<p>I think the tree structure can be considered cached in real world scenarios; not really relevant to the performance you&#x27;ll get.</div><br/></div></div></div></div></div></div><div id="38749116" class="c"><input type="checkbox" id="c-38749116" checked=""/><div class="controls bullet"><span class="by">daveevad</span><span>|</span><a href="#38748845">prev</a><span>|</span><a href="#38749700">next</a><span>|</span><label class="collapse" for="c-38749116">[-]</label><label class="expand" for="c-38749116">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that deep.</div><br/><div id="38749420" class="c"><input type="checkbox" id="c-38749420" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#38749116">parent</a><span>|</span><a href="#38749700">next</a><span>|</span><label class="collapse" for="c-38749420">[-]</label><label class="expand" for="c-38749420">[3 more]</label></div><br/><div class="children"><div class="content">What a shallow response.</div><br/><div id="38750054" class="c"><input type="checkbox" id="c-38750054" checked=""/><div class="controls bullet"><span class="by">ukuina</span><span>|</span><a href="#38749116">root</a><span>|</span><a href="#38749420">parent</a><span>|</span><a href="#38749700">next</a><span>|</span><label class="collapse" for="c-38750054">[-]</label><label class="expand" for="c-38750054">[2 more]</label></div><br/><div class="children"><div class="content">I enjoyed the breadth of this discussion.</div><br/><div id="38751543" class="c"><input type="checkbox" id="c-38751543" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#38749116">root</a><span>|</span><a href="#38750054">parent</a><span>|</span><a href="#38749700">next</a><span>|</span><label class="collapse" for="c-38751543">[-]</label><label class="expand" for="c-38751543">[1 more]</label></div><br/><div class="children"><div class="content">Alright now, let&#x27;s restore some order to this thread.</div><br/></div></div></div></div></div></div></div></div><div id="38749700" class="c"><input type="checkbox" id="c-38749700" checked=""/><div class="controls bullet"><span class="by">charlieyu1</span><span>|</span><a href="#38749116">prev</a><span>|</span><a href="#38749906">next</a><span>|</span><label class="collapse" for="c-38749700">[-]</label><label class="expand" for="c-38749700">[3 more]</label></div><br/><div class="children"><div class="content">Is there any other data structures that benefits from hardware?</div><br/><div id="38750113" class="c"><input type="checkbox" id="c-38750113" checked=""/><div class="controls bullet"><span class="by">prydt</span><span>|</span><a href="#38749700">parent</a><span>|</span><a href="#38749709">next</a><span>|</span><label class="collapse" for="c-38750113">[-]</label><label class="expand" for="c-38750113">[1 more]</label></div><br/><div class="children"><div class="content">LSM trees are a good example of a data structure optimized for memory hardware (both hdds and ssds).</div><br/></div></div><div id="38749709" class="c"><input type="checkbox" id="c-38749709" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#38749700">parent</a><span>|</span><a href="#38750113">prev</a><span>|</span><a href="#38749906">next</a><span>|</span><label class="collapse" for="c-38749709">[-]</label><label class="expand" for="c-38749709">[1 more]</label></div><br/><div class="children"><div class="content">Arrays come to mind.</div><br/></div></div></div></div><div id="38749906" class="c"><input type="checkbox" id="c-38749906" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#38749700">prev</a><span>|</span><a href="#38749676">next</a><span>|</span><label class="collapse" for="c-38749906">[-]</label><label class="expand" for="c-38749906">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It was invented over 40 years ago, yet it is still employed by the majority of modern databases.<p>I wonder how true this is for the top commercial engines (Oracle, MS, IBM, etc.) whose internals are closed source and proprietary. Even a decade ago my experience performance testing Exadata implied some exotic magic at work, ie lookups are way faster than the expected O(log n). More recently while testing SQL Server&#x27;s ability to join hundreds of tables together the performance was _way_ in excess of what I expected. I can&#x27;t imagine these things have internals all that similar to say the B+Tree inside MySQL for example.</div><br/><div id="38749959" class="c"><input type="checkbox" id="c-38749959" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38749906">parent</a><span>|</span><a href="#38749975">next</a><span>|</span><label class="collapse" for="c-38749959">[-]</label><label class="expand" for="c-38749959">[1 more]</label></div><br/><div class="children"><div class="content">A lot of this comes down to query planners being really good at finding clever ways of doing scans and intersections of indexes, the tables themselves having indexes with a bunch of specialized representations, and the query execution doing very intelligent data traversal with partitioning or even multi-threading.<p>If you sit down and think carefully about your data you can often make even a simple bare-bones B-tree perform fantastically for a query, well in excess of what you&#x27;d get out of mysql or sqlite (which are already pretty fast).</div><br/></div></div><div id="38749975" class="c"><input type="checkbox" id="c-38749975" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38749906">parent</a><span>|</span><a href="#38749959">prev</a><span>|</span><a href="#38749676">next</a><span>|</span><label class="collapse" for="c-38749975">[-]</label><label class="expand" for="c-38749975">[4 more]</label></div><br/><div class="children"><div class="content">On disk, SQL Server uses only b-trees, unless using the new ColumnStore format.<p>In memory during a query it can use temporary indexes of other types, primarily hash tables and bitmaps.<p>Its performance on ad-hoc complex queries is about as good as it gets, few if any other RDBMS can beat its performance, but under the hood it’s still mostly just doing joins on b-trees!</div><br/><div id="38750369" class="c"><input type="checkbox" id="c-38750369" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#38749906">root</a><span>|</span><a href="#38749975">parent</a><span>|</span><a href="#38749676">next</a><span>|</span><label class="collapse" for="c-38750369">[-]</label><label class="expand" for="c-38750369">[3 more]</label></div><br/><div class="children"><div class="content">&gt; ..under the hood it’s still mostly just doing joins on b-trees!<p>I could see the on-disk format needing to be simple and stable, but once the datas buffered who knows what structures and algorithms these proprietary engines are using? You would need to have done some reverse engineering or had hands-on details from the inside which presumably comes w&#x2F;legal consequences for leaking them.</div><br/><div id="38751727" class="c"><input type="checkbox" id="c-38751727" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38749906">root</a><span>|</span><a href="#38750369">parent</a><span>|</span><a href="#38749676">next</a><span>|</span><label class="collapse" for="c-38751727">[-]</label><label class="expand" for="c-38751727">[2 more]</label></div><br/><div class="children"><div class="content">It tells you what it uses when you inspect the “query plans”. There’s some fairly technical explanation in the docs of what each of the operators do.<p>Generally the secret sauce in these things is the query optimiser heuristics.<p>The actual data structures and algorithm are often relatively simple.<p>Having said that, I’ve read their whitepaper on how they implement hash tables, and… it’s way more complex than I had assumed.<p>They cater for scenarios like many duplicated keys, parallel construction, unbalanced load across CPU cores, etc…</div><br/><div id="38751986" class="c"><input type="checkbox" id="c-38751986" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#38749906">root</a><span>|</span><a href="#38751727">parent</a><span>|</span><a href="#38749676">next</a><span>|</span><label class="collapse" for="c-38751986">[-]</label><label class="expand" for="c-38751986">[1 more]</label></div><br/><div class="children"><div class="content">the query plan says &quot;key lookup&quot; or &quot;index seek&quot; can we really assume anything about the implementation?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38749676" class="c"><input type="checkbox" id="c-38749676" checked=""/><div class="controls bullet"><span class="by">oggyboye</span><span>|</span><a href="#38749906">prev</a><span>|</span><label class="collapse" for="c-38749676">[-]</label><label class="expand" for="c-38749676">[9 more]</label></div><br/><div class="children"><div class="content">How does it work when indexing uuid columns?</div><br/><div id="38751836" class="c"><input type="checkbox" id="c-38751836" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38749676">parent</a><span>|</span><a href="#38751176">next</a><span>|</span><label class="collapse" for="c-38751836">[-]</label><label class="expand" for="c-38751836">[1 more]</label></div><br/><div class="children"><div class="content">Normally, a uuid is orderable.<p>However uuid4 create a lot of work during updates, and tend to result in relatively low fill trees so querying is less efficient than it could be.<p>They also don’t really benefit from btrees as range or prefix queries are extremely rare.</div><br/></div></div><div id="38751176" class="c"><input type="checkbox" id="c-38751176" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#38749676">parent</a><span>|</span><a href="#38751836">prev</a><span>|</span><a href="#38749965">next</a><span>|</span><label class="collapse" for="c-38751176">[-]</label><label class="expand" for="c-38751176">[4 more]</label></div><br/><div class="children"><div class="content">Very poorly is my understanding. There&#x27;s various sequential UUID-like schemes that are more sortable by prefixing with bits of physical time. Off the top of my head, ULIDs and also UUID v7.</div><br/><div id="38751456" class="c"><input type="checkbox" id="c-38751456" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#38749676">root</a><span>|</span><a href="#38751176">parent</a><span>|</span><a href="#38749965">next</a><span>|</span><label class="collapse" for="c-38751456">[-]</label><label class="expand" for="c-38751456">[3 more]</label></div><br/><div class="children"><div class="content">I think this really only matters for clustered indexes.</div><br/><div id="38751870" class="c"><input type="checkbox" id="c-38751870" checked=""/><div class="controls bullet"><span class="by">Tostino</span><span>|</span><a href="#38749676">root</a><span>|</span><a href="#38751456">parent</a><span>|</span><a href="#38751847">next</a><span>|</span><label class="collapse" for="c-38751870">[-]</label><label class="expand" for="c-38751870">[1 more]</label></div><br/><div class="children"><div class="content">No, you will have much larger index bloat as you add rows as page splits happen to accommodate the new rows.</div><br/></div></div><div id="38751847" class="c"><input type="checkbox" id="c-38751847" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38749676">root</a><span>|</span><a href="#38751456">parent</a><span>|</span><a href="#38751870">prev</a><span>|</span><a href="#38749965">next</a><span>|</span><label class="collapse" for="c-38751847">[-]</label><label class="expand" for="c-38751847">[1 more]</label></div><br/><div class="children"><div class="content">A clustered index means the entire table data is included. It’s the same issue, just to an even higher degree.</div><br/></div></div></div></div></div></div><div id="38749965" class="c"><input type="checkbox" id="c-38749965" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38749676">parent</a><span>|</span><a href="#38751176">prev</a><span>|</span><label class="collapse" for="c-38749965">[-]</label><label class="expand" for="c-38749965">[3 more]</label></div><br/><div class="children"><div class="content">Probably poorly by default, but you could use a hash of the uuid as a key (to try and more evenly spread the entropy) or key it off a suffix instead of a prefix since iirc that&#x27;s where most of the entropy lives.<p>In practice if you want good performance and scalability it&#x27;s important to select keys well.</div><br/><div id="38750148" class="c"><input type="checkbox" id="c-38750148" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#38749676">root</a><span>|</span><a href="#38749965">parent</a><span>|</span><label class="collapse" for="c-38750148">[-]</label><label class="expand" for="c-38750148">[2 more]</label></div><br/><div class="children"><div class="content">For this use case people generally choose sequential UUIDs or they want random ones to prevent hot pages for their inserts.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>