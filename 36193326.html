<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685955681113" as="style"/><link rel="stylesheet" href="styles.css?v=1685955681113"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://graydon2.dreamwidth.org/307291.html">The Rust I wanted had no future</a> <span class="domain">(<a href="https://graydon2.dreamwidth.org">graydon2.dreamwidth.org</a>)</span></div><div class="subtext"><span>dochtman</span> | <span>38 comments</span></div><br/><div><div id="36193721" class="c"><input type="checkbox" id="c-36193721" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#36193764">next</a><span>|</span><label class="collapse" for="c-36193721">[-]</label><label class="expand" for="c-36193721">[6 more]</label></div><br/><div class="children"><div class="content">Very interesting insight from Graydon, in hindsight I too would have loved something more towards ML than C++. I never liked the kitchen sink approach that I see first C++, now Rust moving towards, but I respect what Rust has managed to solidify into. It&#x27;s a good language.<p>That said, I still hate async with a passion, it makes the language more complex and not very elegant (i.e. function coloring). And now that I know how it works behind the scene (thanks to Jon Gjengset  [1]), it feels so complicated and hacky, a mediocre very high level concept that someone managed to implement as a zero-cost abstraction. Impressive, but still a bad idea.<p>I&#x27;m sure the pro of having a BDFL instead of a committee is being able to follow a singular vision, instead of trying to appease members by adding the fad du jour which might stray a little too far from the original vision. Too many chefs in the kitchen and all.<p>1: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ThjvMReOXYM">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ThjvMReOXYM</a></div><br/><div id="36193862" class="c"><input type="checkbox" id="c-36193862" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#36193721">parent</a><span>|</span><a href="#36193771">next</a><span>|</span><label class="collapse" for="c-36193862">[-]</label><label class="expand" for="c-36193862">[4 more]</label></div><br/><div class="children"><div class="content">Function coloring article conflated two things: one was legitimate limitation of JS unable to wait for async result from sync call, and the other was just author&#x27;s opinion how the syntax should look like.<p>Rust&#x27;s async doesn&#x27;t have the limitation author described – you can spawn and block both (Tokio has some limits there, but that&#x27;s Tokyo&#x27;s choice, not language limitation), making &quot;color&quot; largely irrelevant.<p>The second point was that both should have identical syntax, which Rust deliberately chose not to, because from Rusts perspective that would be too much implicit magic.</div><br/><div id="36193895" class="c"><input type="checkbox" id="c-36193895" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#36193721">root</a><span>|</span><a href="#36193862">parent</a><span>|</span><a href="#36193771">next</a><span>|</span><label class="collapse" for="c-36193895">[-]</label><label class="expand" for="c-36193895">[3 more]</label></div><br/><div class="children"><div class="content">I disagree. You can call an async function in Rust from a regular one, that&#x27;s true, but the returned value still needs to be passed through an executor to be useful.<p>Async without function coloring means being able to call `async fn add(a, b: usize) -&gt; usize` from anywhere and having an usize back, whether you&#x27;re calling from a regular or async function. If you need slightly different logic because of async, you got function coloring.<p>In fact, a hypothetical <i>async without coloring</i> functionality would not even need the `async` keyword at all, as all functions would be effectively the same, so you could choose to call one asynchronously or not with no particular ceremony. Is this even possible to do without compiler magic?</div><br/><div id="36193974" class="c"><input type="checkbox" id="c-36193974" checked=""/><div class="controls bullet"><span class="by">creatonez</span><span>|</span><a href="#36193721">root</a><span>|</span><a href="#36193895">parent</a><span>|</span><a href="#36193771">next</a><span>|</span><label class="collapse" for="c-36193974">[-]</label><label class="expand" for="c-36193974">[2 more]</label></div><br/><div class="children"><div class="content">Thing is, it&#x27;s a function coloring that mostly doesn&#x27;t impede you by making certain operations impossible without massive refactoring. Regardless of an extra method call needed, it gets rid of the &quot;you can only call a red function from within another red function&quot; barrier by allowing you to do it, as long as you specify how (execute inside this thread, or delegate to a worker thread). This makes most of the issues associated with Javascript function coloring evaporate.</div><br/><div id="36194014" class="c"><input type="checkbox" id="c-36194014" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#36193721">root</a><span>|</span><a href="#36193974">parent</a><span>|</span><a href="#36193771">next</a><span>|</span><label class="collapse" for="c-36194014">[-]</label><label class="expand" for="c-36194014">[1 more]</label></div><br/><div class="children"><div class="content">* * *</div><br/></div></div></div></div></div></div></div></div><div id="36193771" class="c"><input type="checkbox" id="c-36193771" checked=""/><div class="controls bullet"><span class="by">TurboHaskal</span><span>|</span><a href="#36193721">parent</a><span>|</span><a href="#36193862">prev</a><span>|</span><a href="#36193764">next</a><span>|</span><label class="collapse" for="c-36193771">[-]</label><label class="expand" for="c-36193771">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I too would have loved something more towards ML than C++<p>I stopped paying attention to the language around 2012-2013 or so when the direction clearly steered towards the latter.<p>You may want to check <a href="https:&#x2F;&#x2F;austral-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;austral-lang.org&#x2F;</a> out.</div><br/></div></div></div></div><div id="36193764" class="c"><input type="checkbox" id="c-36193764" checked=""/><div class="controls bullet"><span class="by">moonchrome</span><span>|</span><a href="#36193721">prev</a><span>|</span><a href="#36193478">next</a><span>|</span><label class="collapse" for="c-36193764">[-]</label><label class="expand" for="c-36193764">[10 more]</label></div><br/><div class="children"><div class="content">As someone casually following Rust and haven&#x27;t touched it or C++ in probably 5+ years (but keeping tabs in hope of coming back to that world), I feel like a lot of decisions he mentions are what made me optimistic about Rust adoption&#x2F;positioning itself as a modern C++ replacement. So I kind of agree with his conclusion - his version of Rust would be much less interesting to me, and I think a lot of it&#x27;s current users. eg. I only started playing with Rust once they removed green threads. Zero cost abstractions are a major selling point.</div><br/><div id="36193832" class="c"><input type="checkbox" id="c-36193832" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#36193764">parent</a><span>|</span><a href="#36193953">next</a><span>|</span><label class="collapse" for="c-36193832">[-]</label><label class="expand" for="c-36193832">[6 more]</label></div><br/><div class="children"><div class="content">I think this quote also applies more generally:<p>&gt; <i>It&#x27;s easier to work with than C++, but that&#x27;s fairly faint praise.</i><p>So, while Rust positions itself as a C++ alternative with all the complexities that C++ developers love, it may become less attractive for other use cases. For instance, I find it highly questionable to develop a web app in Rust...</div><br/><div id="36194006" class="c"><input type="checkbox" id="c-36194006" checked=""/><div class="controls bullet"><span class="by">moonchrome</span><span>|</span><a href="#36193764">root</a><span>|</span><a href="#36193832">parent</a><span>|</span><a href="#36193926">next</a><span>|</span><label class="collapse" for="c-36194006">[-]</label><label class="expand" for="c-36194006">[1 more]</label></div><br/><div class="children"><div class="content">&gt;So, while Rust positions itself as a C++ alternative with all the complexities that C++ developers love, it may become less attractive for other use cases. For instance, I find it highly questionable to develop a web app in Rust...<p>But we already have plenty of options for this use case (.NET, JVM, Go, Python, Ruby, node.js, PHP, Erlang, etc. etc.). Very mature ecosystems that solve a lot of different edge cases.<p>There are very few C++ alternatives worth mentioning, none as mature as Rust in terms of adoption&#x2F;tooling.</div><br/></div></div><div id="36193926" class="c"><input type="checkbox" id="c-36193926" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#36193764">root</a><span>|</span><a href="#36193832">parent</a><span>|</span><a href="#36194006">prev</a><span>|</span><a href="#36193952">next</a><span>|</span><label class="collapse" for="c-36193926">[-]</label><label class="expand" for="c-36193926">[1 more]</label></div><br/><div class="children"><div class="content">We build a proof-of-concept backend replacement for what is essentially “SharePoint being used as a DB with a frontend by people who don’t know how to use SharePoint” and was a nice experience. We also build it in a few other languages, C#, Go, Python and TypeScript and Rust was probably the best experience of them all. We ended up going with C# because we needed Odata, and at the time we hadn’t yet run into the many “joys” of working with Odata, ASP and Entity Framework and how their model builders, really, really, really, won’t play together nicely.<p>Knowing what we know now, we should’ve gone with TypeScript and just written our own Odata filter on top of it, but live and learn.<p>If I was in a position where I could pick and chose languages, and not worry about how not having TypeScript in most things will mean our best front-end developer can never go on vacation because he’s sort of our only front-end developer, I wouldn’t mind using Rust for web-backends.<p>Rust GUI is obviously not a great experience. At least not yet. But it’s not that bad either. I think it’s mostly the case of how JavaScript is just so good at it and seeing such a fast pace of improvements because the entire world uses it for most GUIs these days, that it’s just hard for anything else to compete. I mean, look at stuff like Flutter or Blazor, they are backed by Microsoft and Google and they’re vastly inferior choices for most use cases compared to simply building things in React, ReactNative or even electron, and that’s not because I have some wild love for JavaScript, it’s because it’s seeing rapid improvements they dwarf it’s competition simply by being used by a lot of people.<p>I wish Rust would have someone like Facebook pick it up and build a frontend framework for it, but I think that is just too unlikely for you to bet on, and you certainly wouldn’t want to do it yourself, even as open source because then that would probably be your entire job.<p>On the flip-side, the packages that handle basic back-end web stuff for Enterprise use are rock solid in Rust. Which is impressive, at least to me, considering it’s young age. I have no idea why, but maybe some serious players are contributing to it because they use it themselves. There isn’t a “Django” or Ruby+Rails for Rust, but if what you’re building is a lot of smaller APIs with various transport methods and data access in an federated authentication scenario then Rust is surprisingly mature for the web. It’s primary disadvantage being that your TypeScript and Rust developers won’t be able to cover for each other (which is why we didn’t poc with Java).</div><br/></div></div><div id="36193952" class="c"><input type="checkbox" id="c-36193952" checked=""/><div class="controls bullet"><span class="by">tick_tock_tick</span><span>|</span><a href="#36193764">root</a><span>|</span><a href="#36193832">parent</a><span>|</span><a href="#36193926">prev</a><span>|</span><a href="#36193909">next</a><span>|</span><label class="collapse" for="c-36193952">[-]</label><label class="expand" for="c-36193952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it may become less attractive for other use cases. For instance, I find it highly questionable to develop a web app in Rust...<p>I mean who&#x27;d want to and why bother trying to support that use case? Basically none of Rust&#x27;s value proposition exists for a web app while nearly every single one of the downsides do.</div><br/></div></div><div id="36193909" class="c"><input type="checkbox" id="c-36193909" checked=""/><div class="controls bullet"><span class="by">smabie</span><span>|</span><a href="#36193764">root</a><span>|</span><a href="#36193832">parent</a><span>|</span><a href="#36193952">prev</a><span>|</span><a href="#36193892">next</a><span>|</span><label class="collapse" for="c-36193909">[-]</label><label class="expand" for="c-36193909">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s tons of existing languages that are mostly okay that you can develop a webapp in.<p>Rust as a C++ replacement serves a real unmet need in the marketplace.</div><br/></div></div></div></div><div id="36193953" class="c"><input type="checkbox" id="c-36193953" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#36193764">parent</a><span>|</span><a href="#36193832">prev</a><span>|</span><a href="#36193786">next</a><span>|</span><label class="collapse" for="c-36193953">[-]</label><label class="expand" for="c-36193953">[1 more]</label></div><br/><div class="children"><div class="content">It makes me smile that my top-level comment says I would have preferred the ML-version of Rust, while you say you prefer the zero-cost-abstraction version of Rust that&#x27;s more C++-like.<p>Indeed in software engineering there is no silver bullet nor a perfect language for everybody :-)</div><br/></div></div><div id="36193786" class="c"><input type="checkbox" id="c-36193786" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36193764">parent</a><span>|</span><a href="#36193953">prev</a><span>|</span><a href="#36193478">next</a><span>|</span><label class="collapse" for="c-36193786">[-]</label><label class="expand" for="c-36193786">[2 more]</label></div><br/><div class="children"><div class="content">I was at the sidelines when Rust 1.0 was being made and I think it got into an llvm induced feedback loop. Slowly turning into C or C++ with other features but the same type, object and memory model.<p>Part of the reason was Rust&#x27;s desire to show itself as a direct competitor w.r.t performance, I think.</div><br/><div id="36193858" class="c"><input type="checkbox" id="c-36193858" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36193764">root</a><span>|</span><a href="#36193786">parent</a><span>|</span><a href="#36193478">next</a><span>|</span><label class="collapse" for="c-36193858">[-]</label><label class="expand" for="c-36193858">[1 more]</label></div><br/><div class="children"><div class="content">Performance, but with sanity.<p>Say you use a vector in C++. You push one element and pop two. In Rust that&#x27;s a None. In C++ the answer is UB (in my case 43).</div><br/></div></div></div></div></div></div><div id="36193478" class="c"><input type="checkbox" id="c-36193478" checked=""/><div class="controls bullet"><span class="by">jstx1</span><span>|</span><a href="#36193764">prev</a><span>|</span><a href="#36193800">next</a><span>|</span><label class="collapse" for="c-36193478">[-]</label><label class="expand" for="c-36193478">[9 more]</label></div><br/><div class="children"><div class="content">A bunch of things you don&#x27;t like about Rust? Turns out that the person who originally created the language doesn&#x27;t like them either.<p>I know that the main point is about governance and how having a BDFL would have led to a completely different language but I really would have preferred the Graydon-BDFL-Rust to what we have today.<p>Very interesting article, worth a read.</div><br/><div id="36193641" class="c"><input type="checkbox" id="c-36193641" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#36193478">parent</a><span>|</span><a href="#36193677">next</a><span>|</span><label class="collapse" for="c-36193641">[-]</label><label class="expand" for="c-36193641">[2 more]</label></div><br/><div class="children"><div class="content">One highlight from the article:<p>&gt; Traits. I generally don&#x27;t like traits &#x2F; typeclasses. To my eyes they&#x27;re too type-directed, too global, too much like programming and debugging a distributed set of invisible inference rules, and produce too much coupling between libraries in terms of what is or isn&#x27;t allowed to maintain coherence.<p>Very much this!<p>&gt; I wanted (and got part way into building) a first class module system in the ML tradition. Many team members objected because these systems are more verbose, often painfully so, and I lost the argument. But I still don&#x27;t like the result, and I would probably have backed the experiment out &quot;if I&#x27;d been BDFL&quot;.<p>I seen this the ML first class module system mentioned in a few different contexts and want to pick it up at some point.</div><br/><div id="36193851" class="c"><input type="checkbox" id="c-36193851" checked=""/><div class="controls bullet"><span class="by">wuiheerfoj</span><span>|</span><a href="#36193478">root</a><span>|</span><a href="#36193641">parent</a><span>|</span><a href="#36193677">next</a><span>|</span><label class="collapse" for="c-36193851">[-]</label><label class="expand" for="c-36193851">[1 more]</label></div><br/><div class="children"><div class="content">May I ask what you don’t like about traits (and perhaps insight on what the author meant)?<p>Being a relative rust noob compared to other languages, I always felt traits were a super power when compared to eg interfaces in Java&#x2F;C++ and flexible but with useful constraints compared to the structural typing nature of Typescript interfaces</div><br/></div></div></div></div><div id="36193677" class="c"><input type="checkbox" id="c-36193677" checked=""/><div class="controls bullet"><span class="by">skellington</span><span>|</span><a href="#36193478">parent</a><span>|</span><a href="#36193641">prev</a><span>|</span><a href="#36193740">next</a><span>|</span><label class="collapse" for="c-36193677">[-]</label><label class="expand" for="c-36193677">[4 more]</label></div><br/><div class="children"><div class="content">Committees tend to design less beautiful things. Look at modern c++ too. What a mess. Everyone in the committee has to jam in their favorite feature, much of which is sugar.</div><br/><div id="36193704" class="c"><input type="checkbox" id="c-36193704" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#36193478">root</a><span>|</span><a href="#36193677">parent</a><span>|</span><a href="#36193740">next</a><span>|</span><label class="collapse" for="c-36193704">[-]</label><label class="expand" for="c-36193704">[3 more]</label></div><br/><div class="children"><div class="content">Modern C++ is actually going relatively OK? You may be thinking of the old, pre-C++11 C++?</div><br/><div id="36193929" class="c"><input type="checkbox" id="c-36193929" checked=""/><div class="controls bullet"><span class="by">Sankozi</span><span>|</span><a href="#36193478">root</a><span>|</span><a href="#36193704">parent</a><span>|</span><a href="#36193793">next</a><span>|</span><label class="collapse" for="c-36193929">[-]</label><label class="expand" for="c-36193929">[1 more]</label></div><br/><div class="children"><div class="content">If you have a mess and add something to it, you still have a mess, probably a bigger one. To clean the mess you need to remove something (which is really hard in a programming language) not to add something.<p>Selecting and enforcing usage of a subset of C++ is a way to deal with that mess which companies frequently use.</div><br/></div></div><div id="36193793" class="c"><input type="checkbox" id="c-36193793" checked=""/><div class="controls bullet"><span class="by">chippiewill</span><span>|</span><a href="#36193478">root</a><span>|</span><a href="#36193704">parent</a><span>|</span><a href="#36193929">prev</a><span>|</span><a href="#36193740">next</a><span>|</span><label class="collapse" for="c-36193793">[-]</label><label class="expand" for="c-36193793">[1 more]</label></div><br/><div class="children"><div class="content">Modern C++ _is_ actually a mess to be fair. Overall it&#x27;s still an improvement on pre-c++11, but when looking at it end-to-end it feels awfully disjointed.</div><br/></div></div></div></div></div></div><div id="36193740" class="c"><input type="checkbox" id="c-36193740" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#36193478">parent</a><span>|</span><a href="#36193677">prev</a><span>|</span><a href="#36193964">next</a><span>|</span><label class="collapse" for="c-36193740">[-]</label><label class="expand" for="c-36193740">[1 more]</label></div><br/><div class="children"><div class="content">I am very glad to not have Rust end up along that path (I am sympathetic to the threading idea he mentioned though).<p>Rust as an alternative to C++ does, for me, involve all of the weird magical nonsense that you kind of need to get any of this working. The extreme use of generics to build out DSLs to get things working. General libraries being very hard to write, but still possible, to get alright ergonomics for usage itself. And yeah... the zero-cost abstraction thing.<p>I think Graydon-Rust would have also been very interesting, but it sounds unappealing to me, person who wants &quot;C++ but nicer&quot;.<p>But to his point... saying &quot;you could have much faster compile times&quot; is very tempting! Just, especially when it&#x27;s messing around with Rust &quot;for fun&quot;, the ergonomics sound pretty unfun.</div><br/></div></div><div id="36193964" class="c"><input type="checkbox" id="c-36193964" checked=""/><div class="controls bullet"><span class="by">crispinb</span><span>|</span><a href="#36193478">parent</a><span>|</span><a href="#36193740">prev</a><span>|</span><a href="#36193800">next</a><span>|</span><label class="collapse" for="c-36193964">[-]</label><label class="expand" for="c-36193964">[1 more]</label></div><br/><div class="children"><div class="content">* * *</div><br/></div></div></div></div><div id="36193800" class="c"><input type="checkbox" id="c-36193800" checked=""/><div class="controls bullet"><span class="by">Aissen</span><span>|</span><a href="#36193478">prev</a><span>|</span><a href="#36193887">next</a><span>|</span><label class="collapse" for="c-36193800">[-]</label><label class="expand" for="c-36193800">[1 more]</label></div><br/><div class="children"><div class="content">On integer wrapping, I think explicit wrap is annoying at first, but eliminates a whole class of bug. I can only agree with:<p>&gt; (Swift at least traps in release by default -- I wish Rust had chosen to).<p>I enable it in release on serious projects:<p><pre><code>    [profile.release]
    overflow-checks = true</code></pre></div><br/></div></div><div id="36193887" class="c"><input type="checkbox" id="c-36193887" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#36193800">prev</a><span>|</span><a href="#36193884">next</a><span>|</span><label class="collapse" for="c-36193887">[-]</label><label class="expand" for="c-36193887">[1 more]</label></div><br/><div class="children"><div class="content">Ah, Sather gets mentioned. That&#x27;s a name I haven&#x27;t heard in a long time. I remember looking at it during the latter half of the 90s when I was searching for the perfect OO language...<p><a href="https:&#x2F;&#x2F;www1.icsi.berkeley.edu&#x2F;~sather&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www1.icsi.berkeley.edu&#x2F;~sather&#x2F;</a></div><br/></div></div><div id="36193884" class="c"><input type="checkbox" id="c-36193884" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36193887">prev</a><span>|</span><a href="#36193970">next</a><span>|</span><label class="collapse" for="c-36193884">[-]</label><label class="expand" for="c-36193884">[1 more]</label></div><br/><div class="children"><div class="content">I’m very glad expressivity won out. I would like our profession to stop accepting tools that waste effort.<p>I’ve always seen safety and lifetimes and borrowing as the main value prop, so I was surprised to see he was sort of aiming at an ML without GC, rather than a C++ that doesn’t blow up.</div><br/></div></div><div id="36193970" class="c"><input type="checkbox" id="c-36193970" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#36193884">prev</a><span>|</span><a href="#36193821">next</a><span>|</span><label class="collapse" for="c-36193970">[-]</label><label class="expand" for="c-36193970">[1 more]</label></div><br/><div class="children"><div class="content">Technically, Rust had no future prior to the 2018 edition.  The fact that Rust can add new features as the use cases for it evolve is a strength of the language, one that it had from the start even with Graydon as a BDFL.</div><br/></div></div><div id="36193821" class="c"><input type="checkbox" id="c-36193821" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#36193970">prev</a><span>|</span><a href="#36193899">next</a><span>|</span><label class="collapse" for="c-36193821">[-]</label><label class="expand" for="c-36193821">[2 more]</label></div><br/><div class="children"><div class="content">The Rust he wanted sounds a lot like Ada.</div><br/><div id="36193828" class="c"><input type="checkbox" id="c-36193828" checked=""/><div class="controls bullet"><span class="by">tejinderss</span><span>|</span><a href="#36193821">parent</a><span>|</span><a href="#36193899">next</a><span>|</span><label class="collapse" for="c-36193828">[-]</label><label class="expand" for="c-36193828">[1 more]</label></div><br/><div class="children"><div class="content">Or like ocaml with its module system and no explicit lifetimes &#x2F; &amp; type.</div><br/></div></div></div></div><div id="36193899" class="c"><input type="checkbox" id="c-36193899" checked=""/><div class="controls bullet"><span class="by">TowerTall</span><span>|</span><a href="#36193821">prev</a><span>|</span><label class="collapse" for="c-36193899">[-]</label><label class="expand" for="c-36193899">[6 more]</label></div><br/><div class="children"><div class="content">The article starts with &quot;In a recent podcast about Rust leadership, the BDFL question came up again&quot;<p>What it BDFL?</div><br/><div id="36193922" class="c"><input type="checkbox" id="c-36193922" checked=""/><div class="controls bullet"><span class="by">compressedgas</span><span>|</span><a href="#36193899">parent</a><span>|</span><a href="#36193950">next</a><span>|</span><label class="collapse" for="c-36193922">[-]</label><label class="expand" for="c-36193922">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Benevolent_dictator_for_life" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Benevolent_dictator_for_life</a></div><br/></div></div><div id="36193950" class="c"><input type="checkbox" id="c-36193950" checked=""/><div class="controls bullet"><span class="by">kjandersen</span><span>|</span><a href="#36193899">parent</a><span>|</span><a href="#36193922">prev</a><span>|</span><a href="#36193914">next</a><span>|</span><label class="collapse" for="c-36193950">[-]</label><label class="expand" for="c-36193950">[1 more]</label></div><br/><div class="children"><div class="content">Benevolent Dictator for Life, a governance model quite prominent in PL and OSS at large.</div><br/></div></div><div id="36193914" class="c"><input type="checkbox" id="c-36193914" checked=""/><div class="controls bullet"><span class="by">Fiahil</span><span>|</span><a href="#36193899">parent</a><span>|</span><a href="#36193950">prev</a><span>|</span><a href="#36193951">next</a><span>|</span><label class="collapse" for="c-36193914">[-]</label><label class="expand" for="c-36193914">[2 more]</label></div><br/><div class="children"><div class="content">Benevolent dictator for life.<p>&quot;Benevolent dictator for life (BDFL) is a title given to a small number of open-source software development leaders, typically project founders who retain the final say in disputes or arguments within the community. The phrase originated in 1995 with reference to Guido van Rossum, creator of the Python programming language.&quot;</div><br/><div id="36193989" class="c"><input type="checkbox" id="c-36193989" checked=""/><div class="controls bullet"><span class="by">TowerTall</span><span>|</span><a href="#36193899">root</a><span>|</span><a href="#36193914">parent</a><span>|</span><a href="#36193951">next</a><span>|</span><label class="collapse" for="c-36193989">[-]</label><label class="expand" for="c-36193989">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Isn&#x27;t a BDFL needed in Open Source projects (not talking specific about Rust, but Open Source in general)? I work in a commercial software company. We have a CTO and he retain the final say in disputes or arguments. He also steers the global technical direction we take the software and has the final say, but he can get fired. Is that the main difference between a CTO and a BDFL?<p>What alternatives are there?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>