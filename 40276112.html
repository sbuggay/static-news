<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715158874819" as="style"/><link rel="stylesheet" href="styles.css?v=1715158874819"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://iliabylich.github.io/arena-based-parsers/">Arena-based parsers</a>Â <span class="domain">(<a href="https://iliabylich.github.io">iliabylich.github.io</a>)</span></div><div class="subtext"><span>ibylich</span> | <span>28 comments</span></div><br/><div><div id="40294968" class="c"><input type="checkbox" id="c-40294968" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#40294373">next</a><span>|</span><label class="collapse" for="c-40294968">[-]</label><label class="expand" for="c-40294968">[6 more]</label></div><br/><div class="children"><div class="content">I enjoy messing around parsing things etc.  Although I started with handmade unschooled attempts many decades ago, I later went through the classic yak&#x2F;bison phase etc before firmly getting back into the hand-rolling custom side of things where I&#x27;m much happier.<p>My main motivation is speed, e.g. I have enjoyed handcrafting wickedly fast custom JSON and SQL parsers and bits of code that sit on top of them.<p>My general approach now is to use a tokenizer that generates an int that represents each token, where the bits in the int tell me the location of the token in the source buffer and its type etc.<p>In languages with a lot of per-object overhead like Java this is literally a long; but in the C&#x2F;C++&#x2F;rust camp it can look and feel like an object or struct or whatever because, underneath, it ends up still being an int that gets passed in registers and on the stack etc.<p>Sometimes the parsing is one-pass and the tokens don&#x27;t need to be stored or anything; its usually the memory allocations that kill parsing performance, and a once-through json decoder can completely eliminate bottlenecks on hot paths in data processing etc.<p>Other times I run through once and store these tokens in an array, particularly if I&#x27;m going to be going back over them etc.  Its actually easy to make a function that, given an &#x27;int&#x27; token, finds the next one, so if you are going through the data several times you don&#x27;t need any allocations.  But other times you want to go backwards or you are really going to be going through the data a lot so it makes sense to store the offsets of everything.<p>Sometimes future steps will be reordering things and transforming the AST etc; in those cases, I generally have a writeable arena where I append the text of new tokens, and a bit in the token ints discriminate between the read-only source buffer and this transformed buffer.  This is all particularly cool when it comes to generating sensible error messages with context, which is a finesse most handmade parser makers rue later that they had overlooked :)<p>I would be interested to know just how unmainstream this kind of approach is?  Please weigh in, would love to learn new tricks :)</div><br/><div id="40295144" class="c"><input type="checkbox" id="c-40295144" checked=""/><div class="controls bullet"><span class="by">mightee_pirate</span><span>|</span><a href="#40294968">parent</a><span>|</span><a href="#40295234">next</a><span>|</span><label class="collapse" for="c-40295144">[-]</label><label class="expand" for="c-40295144">[3 more]</label></div><br/><div class="children"><div class="content">I am very interested in parsing and optimizing them. Currently I have an html parser written in go. I have used Go&#x27;s html parser but it is waaay slower than mine. Here what I do:
- stream the content (either from a file or from network) and send chunks to the tokenizer<p>- tokenizer is dead simple with a state machine<p>- when an html tag is found, emit the token with positions (problem is someone needs to hold the whole incoming buffer. currently its copying the incoming bytes but I plan to hold the bytes until a token is found. after emitting the token with the buffer (copying) the inner buffer will be freed)<p>- parser does its thing and creates a DOM<p>as you can see I am not well versed in optimizing to the last bit  but I am very interested in diving deep into the optimizations.<p>Currently I am looking at zero-copy networking. there is supposedly a library for go (fasthttp) that would not copy bytes from networking interface but I havent tried it yet.<p>What kind of algorithms would you recommend for tokenizing &amp; parsing html &#x2F; xml very efficiently ?</div><br/><div id="40295226" class="c"><input type="checkbox" id="c-40295226" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40294968">root</a><span>|</span><a href="#40295144">parent</a><span>|</span><a href="#40295234">next</a><span>|</span><label class="collapse" for="c-40295226">[-]</label><label class="expand" for="c-40295226">[2 more]</label></div><br/><div class="children"><div class="content">you may want to add blank lines between your bullets</div><br/><div id="40295516" class="c"><input type="checkbox" id="c-40295516" checked=""/><div class="controls bullet"><span class="by">mightee_pirate</span><span>|</span><a href="#40294968">root</a><span>|</span><a href="#40295226">parent</a><span>|</span><a href="#40295234">next</a><span>|</span><label class="collapse" for="c-40295516">[-]</label><label class="expand" for="c-40295516">[1 more]</label></div><br/><div class="children"><div class="content">thx</div><br/></div></div></div></div></div></div><div id="40295234" class="c"><input type="checkbox" id="c-40295234" checked=""/><div class="controls bullet"><span class="by">PythagoRascal</span><span>|</span><a href="#40294968">parent</a><span>|</span><a href="#40295144">prev</a><span>|</span><a href="#40295220">next</a><span>|</span><label class="collapse" for="c-40295234">[-]</label><label class="expand" for="c-40295234">[1 more]</label></div><br/><div class="children"><div class="content">I would be very interested in a more detailed write-up, if you have the time (or have one already).</div><br/></div></div><div id="40295220" class="c"><input type="checkbox" id="c-40295220" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40294968">parent</a><span>|</span><a href="#40295234">prev</a><span>|</span><a href="#40294373">next</a><span>|</span><label class="collapse" for="c-40295220">[-]</label><label class="expand" for="c-40295220">[1 more]</label></div><br/><div class="children"><div class="content">this sounds awesome, can i see?</div><br/></div></div></div></div><div id="40294373" class="c"><input type="checkbox" id="c-40294373" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40294968">prev</a><span>|</span><a href="#40294119">next</a><span>|</span><label class="collapse" for="c-40294373">[-]</label><label class="expand" for="c-40294373">[1 more]</label></div><br/><div class="children"><div class="content">probably worth noting that the default peg backend for the c combinator parser &#x27;hammer&#x27; uses an arena allocator for speed and because it&#x27;s a good match for packrat memoization. there are hammer bindings for several languages including python and java, not sure if there&#x27;s a rust one yet. hammer also has some other backends including lalr, and in some cases you can write a grammar such that you can parse it with either packrat or lalr<p>hammer&#x27;s arena allocator is not very fast, though. it&#x27;s faster than any malloc i&#x27;ve seen, but a good arena allocator is faster than calling an empty function, so you have to inline the fast path.  the open-source prototype arena allocator i wrote in <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;kmregion.h" rel="nofollow">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;kmregion.h</a> (and .c) doesn&#x27;t quite reach that level, but it takes about 1.9 nanoseconds per allocation (520 million allocations per second on one core), while glibc&#x27;s malloc takes about 19 nanoseconds per allocation.  more recent versions of glibc (on a faster cpu) have reduced that to 14 nanoseconds in that particular microbenchmark. details are at the link.  your mileage may vary<p>chris wellons wrote an excellent article last year about his approach to arena allocation in c in <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;27&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;27&#x2F;</a><p>for those who aren&#x27;t aware, garbage collectors for languages like js, c#, ocaml, or java are usually generational copying collectors for efficiency, which means they use what is effectively an arena allocator for most new allocations.  often they reserve a cpu register or two for this, which my c implementation above can&#x27;t<p>for c, the apache portable runtime &#x27;apr&#x27; has a generic arena allocator in it called pools, which also supports destructors (the drop trait, in rust) and nested pools<p>the arena allocator in gcc is called &#x27;obstacks&#x27; and got moved into libiberty so you can use it in other c programs.  or hypothetically in rust</div><br/></div></div><div id="40294119" class="c"><input type="checkbox" id="c-40294119" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#40294373">prev</a><span>|</span><a href="#40294912">next</a><span>|</span><label class="collapse" for="c-40294119">[-]</label><label class="expand" for="c-40294119">[8 more]</label></div><br/><div class="children"><div class="content">&gt; To release memory we simply release the blob itself, so it&#x27;s like a batched deallocation, sort of. The consequence here is that all of our types must be:<p>&gt; 1. trivially copyable (: Copy if we speak in Rust)<p>&gt; 2. trivially destructible (i.e. they can&#x27;t have impl Drop)<p>2 (Drop) seems obvious enough, but why 1 (Copy)? Thereâs a bit of Rust knowledge implicit there that Iâm unaware of, and I might not be alone in that. Could someone explain?</div><br/><div id="40294235" class="c"><input type="checkbox" id="c-40294235" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40294119">parent</a><span>|</span><a href="#40294209">next</a><span>|</span><label class="collapse" for="c-40294235">[-]</label><label class="expand" for="c-40294235">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a mistake. <i>Allocator Implementation</i>[1] shows values being moved into the arena, which can be done without Copy or even Clone. Maybe the author got confused, since moving an object in Rust just <i>copies</i> the bytes and invalidates the moved from binding.<p>[1]: <a href="https:&#x2F;&#x2F;iliabylich.github.io&#x2F;arena-based-parsers&#x2F;allocator_implementation.html" rel="nofollow">https:&#x2F;&#x2F;iliabylich.github.io&#x2F;arena-based-parsers&#x2F;allocator_i...</a></div><br/></div></div><div id="40294209" class="c"><input type="checkbox" id="c-40294209" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40294119">parent</a><span>|</span><a href="#40294235">prev</a><span>|</span><a href="#40294150">next</a><span>|</span><label class="collapse" for="c-40294209">[-]</label><label class="expand" for="c-40294209">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure being trivially destructible is sufficient for this use case. The only reason you might want a Copy bound when you&#x27;re not actually copying values is if you&#x27;re trying to disallow interior mutability, but that doesn&#x27;t seem to be the case here. Perhaps the author was misinformed.<p>Or maybe they&#x27;re just using Copy as a type-level bound that guarantees a trivial destructor, even if it&#x27;s more restrictive than strictly necessary.</div><br/><div id="40294736" class="c"><input type="checkbox" id="c-40294736" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#40294119">root</a><span>|</span><a href="#40294209">parent</a><span>|</span><a href="#40294150">next</a><span>|</span><label class="collapse" for="c-40294736">[-]</label><label class="expand" for="c-40294736">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t have a negative trait bound to say &quot;I take anything that _doesn&#x27;t_ implement Drop&quot;. It&#x27;s not a stabilized feature in Rust because it would allow adding a trait to a struct to become a breaking API change where it currently is not. Copy guarantees !Drop so it&#x27;s currently the only way to do it without opting into nightly features.<p>You can remove the requirement for trivially destructible types by maintaining a singly linked list of (ptr to alloc&#x27;d object, destructorFn) pairs with the links allocated from the arena itself. The arena can just walk the list and call all the drop functions when it gets reset. You can even specialize for types with trivial destructors so they don&#x27;t append to the list and so you only pay the extra cost if you allocate Drop types (using std::mem::needs_drop).</div><br/></div></div></div></div><div id="40294150" class="c"><input type="checkbox" id="c-40294150" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#40294119">parent</a><span>|</span><a href="#40294209">prev</a><span>|</span><a href="#40294912">next</a><span>|</span><label class="collapse" for="c-40294150">[-]</label><label class="expand" for="c-40294150">[4 more]</label></div><br/><div class="children"><div class="content">Trivially copyable and destructible means that they are plain-old data, with no allocations, associated resources or any other side-effects.</div><br/><div id="40294216" class="c"><input type="checkbox" id="c-40294216" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40294119">root</a><span>|</span><a href="#40294150">parent</a><span>|</span><a href="#40294912">next</a><span>|</span><label class="collapse" for="c-40294216">[-]</label><label class="expand" for="c-40294216">[3 more]</label></div><br/><div class="children"><div class="content">Trivial destructibility alone is generally sufficient for that in Rust. Recall that all values (outside a Pin) are trivially moveable, so pretty much the only reason you&#x27;d want trivial copying is if you actually need more than one valid copy at once. (One exception is using Copy to express a poor man&#x27;s Freeze bound, which is quite limited, and dubious in any case.)</div><br/><div id="40294435" class="c"><input type="checkbox" id="c-40294435" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#40294119">root</a><span>|</span><a href="#40294216">parent</a><span>|</span><a href="#40294912">next</a><span>|</span><label class="collapse" for="c-40294435">[-]</label><label class="expand" for="c-40294435">[2 more]</label></div><br/><div class="children"><div class="content">A type that is not Copy may have associated memory allocations, however. You cannot simply forget a range of !Copy structs without the risk of memory leaks.</div><br/><div id="40294484" class="c"><input type="checkbox" id="c-40294484" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40294119">root</a><span>|</span><a href="#40294435">parent</a><span>|</span><a href="#40294912">next</a><span>|</span><label class="collapse" for="c-40294484">[-]</label><label class="expand" for="c-40294484">[1 more]</label></div><br/><div class="children"><div class="content">If those !Copy structs deallocate their memory when dropped properly, then they aren&#x27;t trivially destructible. If they <i>were</i> trivially destructible, then they would leak their memory regardless of whether you dropped or forgot them. That&#x27;s what it means for a type to be trivially destructible: dropping it is a no-op.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40294912" class="c"><input type="checkbox" id="c-40294912" checked=""/><div class="controls bullet"><span class="by">5kg</span><span>|</span><a href="#40294119">prev</a><span>|</span><a href="#40294596">next</a><span>|</span><label class="collapse" for="c-40294912">[-]</label><label class="expand" for="c-40294912">[1 more]</label></div><br/><div class="children"><div class="content">Somewhat related talk: Modernizing Compiler Design for Carbon Toolchain - CppNow 2023 (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZI198eFghJk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZI198eFghJk</a>)</div><br/></div></div><div id="40294596" class="c"><input type="checkbox" id="c-40294596" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#40294912">prev</a><span>|</span><a href="#40294197">next</a><span>|</span><label class="collapse" for="c-40294596">[-]</label><label class="expand" for="c-40294596">[1 more]</label></div><br/><div class="children"><div class="content">protobuf for C++ has this feature - <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;cpp&#x2F;arenas&#x2F;" rel="nofollow">https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;cpp&#x2F;arenas&#x2F;</a> (not so much parsing but (de)serializing)</div><br/></div></div><div id="40294197" class="c"><input type="checkbox" id="c-40294197" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#40294596">prev</a><span>|</span><a href="#40294016">next</a><span>|</span><label class="collapse" for="c-40294197">[-]</label><label class="expand" for="c-40294197">[2 more]</label></div><br/><div class="children"><div class="content">Arena allocation is very trivial in zig</div><br/><div id="40295275" class="c"><input type="checkbox" id="c-40295275" checked=""/><div class="controls bullet"><span class="by">himujjal</span><span>|</span><a href="#40294197">parent</a><span>|</span><a href="#40294016">next</a><span>|</span><label class="collapse" for="c-40295275">[-]</label><label class="expand" for="c-40295275">[1 more]</label></div><br/><div class="children"><div class="content">This. Writing a parser in Zig is so simple. Just allocate once, and then start writing your parser.<p>One allocator for parser, one for scanner. One for type allocation. Keep them all for semantic analysis. Write the output renderer (binary&#x2F;language). Deallocate.<p>In this whole process, it makes it so easy to not think about memory anymore. Just enjoy writing your program.</div><br/></div></div></div></div><div id="40294016" class="c"><input type="checkbox" id="c-40294016" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#40294197">prev</a><span>|</span><a href="#40276113">next</a><span>|</span><label class="collapse" for="c-40294016">[-]</label><label class="expand" for="c-40294016">[7 more]</label></div><br/><div class="children"><div class="content">Oh yeah, arena allocation is great. I&#x27;ve used it a few times and it&#x27;s always a huge performance improvement. The requirements are that (i) the objects you&#x27;re allocating all have the same type, and (ii) they all have the same lifetime (i.e. it&#x27;s okay not to free any of them while others still live).</div><br/><div id="40294164" class="c"><input type="checkbox" id="c-40294164" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40294016">parent</a><span>|</span><a href="#40294059">next</a><span>|</span><label class="collapse" for="c-40294164">[-]</label><label class="expand" for="c-40294164">[1 more]</label></div><br/><div class="children"><div class="content">&quot;All objects of the same(-sized) type&quot; is typically a constraint of bitmap allocators, not arena allocators.</div><br/></div></div><div id="40294059" class="c"><input type="checkbox" id="c-40294059" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#40294016">parent</a><span>|</span><a href="#40294164">prev</a><span>|</span><a href="#40294423">next</a><span>|</span><label class="collapse" for="c-40294059">[-]</label><label class="expand" for="c-40294059">[2 more]</label></div><br/><div class="children"><div class="content">Why would a rust arena allocator be required to have objects all of the same type in it? No C arena allocator would have such a restriction.</div><br/><div id="40294291" class="c"><input type="checkbox" id="c-40294291" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#40294016">root</a><span>|</span><a href="#40294059">parent</a><span>|</span><a href="#40294423">next</a><span>|</span><label class="collapse" for="c-40294291">[-]</label><label class="expand" for="c-40294291">[1 more]</label></div><br/><div class="children"><div class="content">It wouldn&#x27;t. For some reason in Rust people tend to apply the term &quot;arena&quot; to &quot;vector + indices&quot; as well as the proper definition, which does have that restriction.</div><br/></div></div></div></div><div id="40294423" class="c"><input type="checkbox" id="c-40294423" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40294016">parent</a><span>|</span><a href="#40294059">prev</a><span>|</span><a href="#40276113">next</a><span>|</span><label class="collapse" for="c-40294423">[-]</label><label class="expand" for="c-40294423">[3 more]</label></div><br/><div class="children"><div class="content">your (i) is incorrect (arena allocators can allocate objects of different types, and indeed one of their strong points is that they don&#x27;t suffer from fragmentation) and your (ii) doesn&#x27;t make sense because <i>not</i> freeing an object is <i>always</i> okay, according to conventional programming language semantics anyway<p>this particular arena allocator <i>does</i> allocate objects of different types, almost arbitrary types in fact:<p><pre><code>    fn alloc_uninitialized&lt;T&gt;(&amp;self) -&gt; NonNull&lt;T&gt; { ... }
</code></pre>
the safety concern is that nothing <i>outside</i> the arena survive the arena if it contains a pointer into the arena. as the linked micro-book puts it, &#x27;it shouldn&#x27;t be possible for any arena-allocated [variable] to outlive the memory that it[s data]&#x27;s located on.&#x27;</div><br/><div id="40294464" class="c"><input type="checkbox" id="c-40294464" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40294016">root</a><span>|</span><a href="#40294423">parent</a><span>|</span><a href="#40276113">next</a><span>|</span><label class="collapse" for="c-40294464">[-]</label><label class="expand" for="c-40294464">[2 more]</label></div><br/><div class="children"><div class="content">&gt; not freeing an object is always okay, according to conventional programming language semantics anyway<p>Conventional semantics have to hit reality eventually. Long-running programs can&#x27;t just alloc forever without free, hence an arena not being the only allocator in most long-running programs.</div><br/><div id="40294474" class="c"><input type="checkbox" id="c-40294474" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40294016">root</a><span>|</span><a href="#40294464">parent</a><span>|</span><a href="#40276113">next</a><span>|</span><label class="collapse" for="c-40294474">[-]</label><label class="expand" for="c-40294474">[1 more]</label></div><br/><div class="children"><div class="content">yes, this is certainly a weak point in conventional semantics, but not relevant to this issue, which is about ensuring no dangling pointers, not about memory leaks<p>if you&#x27;re running low on memory, switching to an arena allocator is probably a bad idea, because it will usually increase your memory requirements (by delaying deallocation longer), not decrease them</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>