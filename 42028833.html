<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730624464106" as="style"/><link rel="stylesheet" href="styles.css?v=1730624464106"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://railsatscale.com/2024-10-23-next-generation-oob-gc/">Next Generation Out of Band Garbage Collection</a> <span class="domain">(<a href="https://railsatscale.com">railsatscale.com</a>)</span></div><div class="subtext"><span>ksec</span> | <span>46 comments</span></div><br/><div><div id="42029538" class="c"><input type="checkbox" id="c-42029538" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42031817">next</a><span>|</span><label class="collapse" for="c-42029538">[-]</label><label class="expand" for="c-42029538">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Ideally in a web application, aside from some in-memory caches, no object allocated as part of a request should survive longer than the request itself.<p>This is one of those areas where out of process caching wins. In process caching has a nasty habit of putting freshly created objects into collections that have survived for days or hours, creating writes in the old generation and back references from old to new.<p>Going out of process makes it someone else’s problem. And if it’s a compiled language with no or a better GC, all the better.</div><br/><div id="42031931" class="c"><input type="checkbox" id="c-42031931" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#42029538">parent</a><span>|</span><a href="#42029821">next</a><span>|</span><label class="collapse" for="c-42031931">[-]</label><label class="expand" for="c-42031931">[1 more]</label></div><br/><div class="children"><div class="content">Why it should be out of process caching and not, say, a special memory area in the same process?</div><br/></div></div><div id="42029821" class="c"><input type="checkbox" id="c-42029821" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42029538">parent</a><span>|</span><a href="#42031931">prev</a><span>|</span><a href="#42031637">next</a><span>|</span><label class="collapse" for="c-42029821">[-]</label><label class="expand" for="c-42029821">[4 more]</label></div><br/><div class="children"><div class="content">Author here.<p>Agreed. We have some facility for out of process caching (node local memcached), and I frequently have to argue with colleagues that it&#x27;s generally preferable to in-process caching.</div><br/><div id="42030724" class="c"><input type="checkbox" id="c-42030724" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#42029538">root</a><span>|</span><a href="#42029821">parent</a><span>|</span><a href="#42030405">next</a><span>|</span><label class="collapse" for="c-42030724">[-]</label><label class="expand" for="c-42030724">[1 more]</label></div><br/><div class="children"><div class="content">A similar strategy is to serialize the object and store it in-process but off heap. This is useful when the values are private to the process, and&#x2F;or they don&#x27;t need to survive a crash, and&#x2F;or you need to avoid the network overhead. Access times are often 100x-1000x faster.</div><br/></div></div><div id="42030405" class="c"><input type="checkbox" id="c-42030405" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42029538">root</a><span>|</span><a href="#42029821">parent</a><span>|</span><a href="#42030724">prev</a><span>|</span><a href="#42031637">next</a><span>|</span><label class="collapse" for="c-42030405">[-]</label><label class="expand" for="c-42030405">[2 more]</label></div><br/><div class="children"><div class="content">I accept that it is true but I bristle at the fact of it. It shouldn’t be true.</div><br/><div id="42031757" class="c"><input type="checkbox" id="c-42031757" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42029538">root</a><span>|</span><a href="#42030405">parent</a><span>|</span><a href="#42031637">next</a><span>|</span><label class="collapse" for="c-42031757">[-]</label><label class="expand" for="c-42031757">[1 more]</label></div><br/><div class="children"><div class="content">Depends, it&#x27;s not just about access time and GC pressure, it&#x27;s also about sharing that cache with other processes on the node.</div><br/></div></div></div></div></div></div><div id="42031637" class="c"><input type="checkbox" id="c-42031637" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42029538">parent</a><span>|</span><a href="#42029821">prev</a><span>|</span><a href="#42030554">next</a><span>|</span><label class="collapse" for="c-42031637">[-]</label><label class="expand" for="c-42031637">[1 more]</label></div><br/><div class="children"><div class="content">This could also be a case for non-managed objects in the same process. APIs aren&#x27;t typically very friendly, but I would expect they could be made so, especially if it was for a dedicated use-case like caching.</div><br/></div></div><div id="42030554" class="c"><input type="checkbox" id="c-42030554" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42029538">parent</a><span>|</span><a href="#42031637">prev</a><span>|</span><a href="#42031817">next</a><span>|</span><label class="collapse" for="c-42030554">[-]</label><label class="expand" for="c-42030554">[1 more]</label></div><br/><div class="children"><div class="content">Rust is emerging as a major contender for HTTP&#x2F;gRPC backend services.<p>Actix, Axum, sqlx, diesel, and a whole host of other utilities and frameworks make writing Rust for HTTP just as easy and developer efficient as Golang or Java, but the code will never have to deal with GC.<p>It&#x27;s easy to pull request scoped objects into durable caches.</div><br/></div></div></div></div><div id="42031817" class="c"><input type="checkbox" id="c-42031817" checked=""/><div class="controls bullet"><span class="by">voiper1</span><span>|</span><a href="#42029538">prev</a><span>|</span><a href="#42030318">next</a><span>|</span><label class="collapse" for="c-42031817">[-]</label><label class="expand" for="c-42031817">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Ideally in a web application, aside from some in-memory caches, no object allocated as part of a request should survive longer than the request itself. Any object that does is probably something that should be eagerly loaded during boot, or some state that is leaking between requests. As such, any object promoted to the old generation during a request cycle is very unlikely to be immortal, so promoting it is wasteful.<p>So could each request clean up it&#x27;s own garbage when it finishes, so then they should never need any global garbage collection?</div><br/><div id="42031873" class="c"><input type="checkbox" id="c-42031873" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42031817">parent</a><span>|</span><a href="#42030318">next</a><span>|</span><label class="collapse" for="c-42031873">[-]</label><label class="expand" for="c-42031873">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much what I&#x27;m hinting at at the end when I mention minor GC.<p>I don&#x27;t think doing it after each request would be sensible, but counter intuitively, the time it takes to run GC isn&#x27;t proportional to amount of garbage to collect, but to the number of live objects left (ignoring some minor things like finalizers).<p>So on paper at least we could run a minor GC for very cheap after each request, but there&#x27;s likely some better heuristics given currently the median request already spent less than 1ms in GC, so after every requests might be overdoing it.<p>Also even if we were doing that, many requests would still have to run GC because they allocate more than there is memory available, so they need to clean their own garbage to continue, you can&#x27;t delay GC indefinitely.<p>But at least now, endpoints that spend too much time in GC are responsible for their own demise, so engineers responsible for a given endpoint performance have a clear signal that they should allocate less, whereas before it could easily discounted as being caused by lots of garbage left over by another collocated endpoint.</div><br/></div></div></div></div><div id="42030318" class="c"><input type="checkbox" id="c-42030318" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#42031817">prev</a><span>|</span><a href="#42029101">next</a><span>|</span><label class="collapse" for="c-42030318">[-]</label><label class="expand" for="c-42030318">[7 more]</label></div><br/><div class="children"><div class="content">All the other virtual machines that support GC need to look at the JVM&#x27;s ZGC and Shenandoah. Sub-millisecond pause times with terabyte heaps.</div><br/><div id="42031793" class="c"><input type="checkbox" id="c-42031793" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42030318">parent</a><span>|</span><a href="#42031002">next</a><span>|</span><label class="collapse" for="c-42031793">[-]</label><label class="expand" for="c-42031793">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re actually hoping to get mmtK included in Ruby to be able to use more advanced GCs. Medium term we hope to use Immix: <a href="https:&#x2F;&#x2F;bugs.ruby-lang.org&#x2F;issues&#x2F;20860" rel="nofollow">https:&#x2F;&#x2F;bugs.ruby-lang.org&#x2F;issues&#x2F;20860</a><p>And yes, we&#x27;re aware of ZGC &amp;co <a href="https:&#x2F;&#x2F;www.eightbitraptor.com&#x2F;presentations&#x2F;RubyKaigi2023-mvh.pdf" rel="nofollow">https:&#x2F;&#x2F;www.eightbitraptor.com&#x2F;presentations&#x2F;RubyKaigi2023-m...</a></div><br/></div></div><div id="42031002" class="c"><input type="checkbox" id="c-42031002" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42030318">parent</a><span>|</span><a href="#42031793">prev</a><span>|</span><a href="#42030977">next</a><span>|</span><label class="collapse" for="c-42031002">[-]</label><label class="expand" for="c-42031002">[2 more]</label></div><br/><div class="children"><div class="content">I think we should be careful when correlating heap size with how long the collection should take.<p>Also, I really want ZGC in .NET runtime, but I don&#x27;t think I&#x27;ll ever get support for it first party. There&#x27;s some kind of principled ideologue holdout situation going on over at Microsoft. Every time I get into it with one of their engineers I&#x27;m sent to some impotent &quot;please may I have a temporary GC exemption&quot; API. All I want is it to do <i>nothing</i>. How hard is it to just not clean up the goddamn garbage? Give me a registry flag + env variable + cli arg all required at the same time if you&#x27;re so worried someone might trip over it.</div><br/><div id="42031313" class="c"><input type="checkbox" id="c-42031313" checked=""/><div class="controls bullet"><span class="by">reubenbond</span><span>|</span><a href="#42030318">root</a><span>|</span><a href="#42031002">parent</a><span>|</span><a href="#42030977">next</a><span>|</span><label class="collapse" for="c-42031313">[-]</label><label class="expand" for="c-42031313">[1 more]</label></div><br/><div class="children"><div class="content">Would GC.TryStartNoGCRegion work for you? <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.gc.trystartnogcregion?view=net-8.0#system-gc-trystartnogcregion(system-int64-system-boolean)" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.gc.tryst...</a></div><br/></div></div></div></div><div id="42030977" class="c"><input type="checkbox" id="c-42030977" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#42030318">parent</a><span>|</span><a href="#42031002">prev</a><span>|</span><a href="#42030861">next</a><span>|</span><label class="collapse" for="c-42030977">[-]</label><label class="expand" for="c-42030977">[2 more]</label></div><br/><div class="children"><div class="content">How much of a throughput penalty do those options incur on the application?</div><br/><div id="42031136" class="c"><input type="checkbox" id="c-42031136" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#42030318">root</a><span>|</span><a href="#42030977">parent</a><span>|</span><a href="#42030861">next</a><span>|</span><label class="collapse" for="c-42031136">[-]</label><label class="expand" for="c-42031136">[1 more]</label></div><br/><div class="children"><div class="content">I think it only affects throughput at the limit at the 5% level. All the portfolio companies that implemented it got a net increase in performance as they avoid redlining their servers.</div><br/></div></div></div></div><div id="42030861" class="c"><input type="checkbox" id="c-42030861" checked=""/><div class="controls bullet"><span class="by">oorza</span><span>|</span><a href="#42030318">parent</a><span>|</span><a href="#42030977">prev</a><span>|</span><a href="#42029101">next</a><span>|</span><label class="collapse" for="c-42030861">[-]</label><label class="expand" for="c-42030861">[1 more]</label></div><br/><div class="children"><div class="content">C4 still smokes them both, doesn&#x27;t it?</div><br/></div></div></div></div><div id="42029101" class="c"><input type="checkbox" id="c-42029101" checked=""/><div class="controls bullet"><span class="by">jeeyoungk</span><span>|</span><a href="#42030318">prev</a><span>|</span><a href="#42030310">next</a><span>|</span><label class="collapse" for="c-42029101">[-]</label><label class="expand" for="c-42029101">[11 more]</label></div><br/><div class="children"><div class="content">This is from several years ago (2017), but this has very similar vibe as Instagram disabling Python GC - <a href="https:&#x2F;&#x2F;instagram-engineering.com&#x2F;dismissing-python-garbage-collection-at-instagram-4dca40b29172" rel="nofollow">https:&#x2F;&#x2F;instagram-engineering.com&#x2F;dismissing-python-garbage-...</a></div><br/><div id="42029764" class="c"><input type="checkbox" id="c-42029764" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42029101">parent</a><span>|</span><a href="#42030310">next</a><span>|</span><label class="collapse" for="c-42029764">[-]</label><label class="expand" for="c-42029764">[10 more]</label></div><br/><div class="children"><div class="content">A 10% performance improvement on Python code is laughable. You can get a 5000% performance improvement if you switch to a better language.</div><br/><div id="42029921" class="c"><input type="checkbox" id="c-42029921" checked=""/><div class="controls bullet"><span class="by">ziddoap</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42029764">parent</a><span>|</span><a href="#42030240">next</a><span>|</span><label class="collapse" for="c-42029921">[-]</label><label class="expand" for="c-42029921">[7 more]</label></div><br/><div class="children"><div class="content">I bet the engineers at Instagram were unaware of pythons performance profile when they chose it, you should let them know that they should just switch to a different language.</div><br/><div id="42029958" class="c"><input type="checkbox" id="c-42029958" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42029921">parent</a><span>|</span><a href="#42031339">next</a><span>|</span><label class="collapse" for="c-42029958">[-]</label><label class="expand" for="c-42029958">[3 more]</label></div><br/><div class="children"><div class="content">Meta is just a small startup though, they probably don&#x27;t have enough resources nor the skills to switch to a better language even after they&#x27;ve heard the gospel.</div><br/><div id="42031865" class="c"><input type="checkbox" id="c-42031865" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42029958">parent</a><span>|</span><a href="#42031339">next</a><span>|</span><label class="collapse" for="c-42031865">[-]</label><label class="expand" for="c-42031865">[2 more]</label></div><br/><div class="children"><div class="content">The joke is that Facebook literally did, right?</div><br/><div id="42031902" class="c"><input type="checkbox" id="c-42031902" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42031865">parent</a><span>|</span><a href="#42031339">next</a><span>|</span><label class="collapse" for="c-42031902">[-]</label><label class="expand" for="c-42031902">[1 more]</label></div><br/><div class="children"><div class="content">Did what? Rewrite Instagram into another language? Do you have any source on this?<p>Last time I checked they&#x27;re working on improving Python performance instead (yes I know they forked it into Cinder, but they&#x27;re trying to upstream their optimizations [0]). Which is very similar to what we&#x27;re doing at Shopify.<p>Of course 100% of Instagram isn&#x27;t in Python, I&#x27;m certain there&#x27;s lots of supporting services in C++ etc, but AFAIK the Instagram &quot;frontend&quot; is still largely a Python&#x2F;Django app.<p>The joke is that if Meta thought that replacing all the Python code they have with something else was worth it, they&#x27;d have done it already.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;facebookincubator&#x2F;cinder">https:&#x2F;&#x2F;github.com&#x2F;facebookincubator&#x2F;cinder</a></div><br/></div></div></div></div></div></div><div id="42031339" class="c"><input type="checkbox" id="c-42031339" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42029921">parent</a><span>|</span><a href="#42029958">prev</a><span>|</span><a href="#42029979">next</a><span>|</span><label class="collapse" for="c-42031339">[-]</label><label class="expand" for="c-42031339">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I bet the engineers at Instagram were unaware of pythons performance profile when they chose it,<p>Is the Instagram stack Python? I doubt it, but stranger things have happened<p>I suspect it is actually some derivative of Apache, or Nginx.  Something sensible</div><br/><div id="42031699" class="c"><input type="checkbox" id="c-42031699" checked=""/><div class="controls bullet"><span class="by">httgp</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42031339">parent</a><span>|</span><a href="#42029979">next</a><span>|</span><label class="collapse" for="c-42031699">[-]</label><label class="expand" for="c-42031699">[1 more]</label></div><br/><div class="children"><div class="content">Instagram is built with Django.</div><br/></div></div></div></div><div id="42029979" class="c"><input type="checkbox" id="c-42029979" checked=""/><div class="controls bullet"><span class="by">electricwire</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42029921">parent</a><span>|</span><a href="#42031339">prev</a><span>|</span><a href="#42030240">next</a><span>|</span><label class="collapse" for="c-42029979">[-]</label><label class="expand" for="c-42029979">[1 more]</label></div><br/><div class="children"><div class="content">They may well have been initially, its a pretty puzzling choice</div><br/></div></div></div></div><div id="42030240" class="c"><input type="checkbox" id="c-42030240" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42029764">parent</a><span>|</span><a href="#42029921">prev</a><span>|</span><a href="#42030310">next</a><span>|</span><label class="collapse" for="c-42030240">[-]</label><label class="expand" for="c-42030240">[2 more]</label></div><br/><div class="children"><div class="content">Very naive take.<p>1. 10% performance improvement at Instagram could lead to many millions of revenue &quot;instantly&quot;. It is not laughable at any company.
2. It won&#x27;t be a 5000% performance improvement. Facebook uses its own fork of Python that is heavily optimized. Probably still far from C++, but you should be thinking about languages like Java when talking about performance.<p>&quot;Better&quot; is a very subjective term when discussing languages, and I hope such discussions can be more productive and meaningful.</div><br/><div id="42030744" class="c"><input type="checkbox" id="c-42030744" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#42029101">root</a><span>|</span><a href="#42030240">parent</a><span>|</span><a href="#42030310">next</a><span>|</span><label class="collapse" for="c-42030744">[-]</label><label class="expand" for="c-42030744">[1 more]</label></div><br/><div class="children"><div class="content">Cinder&#x27;s benchmarks don&#x27;t seem &quot;like Java&quot; performance, given they aren&#x27;t that far off cython.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;facebookincubator&#x2F;cinder&#x2F;blob&#x2F;cinder&#x2F;3.8&#x2F;PERF">https:&#x2F;&#x2F;github.com&#x2F;facebookincubator&#x2F;cinder&#x2F;blob&#x2F;cinder&#x2F;3.8&#x2F;...</a></div><br/></div></div></div></div></div></div></div></div><div id="42030310" class="c"><input type="checkbox" id="c-42030310" checked=""/><div class="controls bullet"><span class="by">sys64739</span><span>|</span><a href="#42029101">prev</a><span>|</span><a href="#42029201">next</a><span>|</span><label class="collapse" for="c-42030310">[-]</label><label class="expand" for="c-42030310">[2 more]</label></div><br/><div class="children"><div class="content">What dashboard software is that?</div><br/><div id="42030488" class="c"><input type="checkbox" id="c-42030488" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#42030310">parent</a><span>|</span><a href="#42029201">next</a><span>|</span><label class="collapse" for="c-42030488">[-]</label><label class="expand" for="c-42030488">[1 more]</label></div><br/><div class="children"><div class="content">Looks like grafana</div><br/></div></div></div></div><div id="42029678" class="c"><input type="checkbox" id="c-42029678" checked=""/><div class="controls bullet"><span class="by">henning</span><span>|</span><a href="#42029205">prev</a><span>|</span><label class="collapse" for="c-42029678">[-]</label><label class="expand" for="c-42029678">[13 more]</label></div><br/><div class="children"><div class="content">They built a large codebase on a language that doesn&#x27;t let you control memory, because that makes you &quot;more productive&quot;. So just having Rails allocate a per-request arena that is asynchronously freed which would force the programmer not to have any objects that outlive the request, or just pre-allocating memory for a fixed amount of request handling per server instance, or whatever allocation behavior you want to do that is generally possible in C&#x2F;C++&#x2F;Zig&#x2F;Rust&#x2F;Odin&#x2F;etc, requires hacking on the language itself. Which means your changes have to go through the Ruby team first. Any additional changes would also need to go through them, which increases the cost of change. Then there is a permanent layer of indirection between your GC callbacks and the semantics of what those callbacks do. Instead of just writing out the custom allocators you want, because that&#x27;s impossible. How depressing.</div><br/><div id="42029867" class="c"><input type="checkbox" id="c-42029867" checked=""/><div class="controls bullet"><span class="by">xerxes901</span><span>|</span><a href="#42029678">parent</a><span>|</span><a href="#42029816">next</a><span>|</span><label class="collapse" for="c-42029867">[-]</label><label class="expand" for="c-42029867">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Which means your changes have to go through the Ruby team first. Any additional changes would also need to go through them …<p>I do want to pick on this specifically - people can and should be patching open source projects they depend on and deploying them to production (exactly as described in the article). Something being in the language vs in “user” code should be no barrier to improving it.</div><br/><div id="42031675" class="c"><input type="checkbox" id="c-42031675" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42029867">parent</a><span>|</span><a href="#42029816">next</a><span>|</span><label class="collapse" for="c-42031675">[-]</label><label class="expand" for="c-42031675">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a pretty huge difference between implementing a performance optimization that works in your use case, and upstreaming that optimization to be generally usable.<p>The latter is often orders of magnitude more work, and the existing solution is probably chosen to be well suited in general.</div><br/></div></div></div></div><div id="42029816" class="c"><input type="checkbox" id="c-42029816" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42029678">parent</a><span>|</span><a href="#42029867">prev</a><span>|</span><label class="collapse" for="c-42029816">[-]</label><label class="expand" for="c-42029816">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing that Zig, Rust, Oden, and &quot;etc.&quot; didn&#x27;t exist when they started the codebase.  Now they need to keep moving in their imperfect state.  I don&#x27;t think anyone would start a large company on Ruby today.  (They would on Python, though, which is equally unfortunate.)</div><br/><div id="42029936" class="c"><input type="checkbox" id="c-42029936" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42029816">parent</a><span>|</span><a href="#42030217">next</a><span>|</span><label class="collapse" for="c-42029936">[-]</label><label class="expand" for="c-42029936">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how it is imperfect.<p>Per request arenas sound super cool on paper, and work very well on system with clear constraints.
But if suddenly a request start allocating more than the arena can accommodate you&#x27;re in a bit of a pickle. They&#x27;re absolutely not a panacea.<p>Setting aside the challenge of refactoring the Ruby VM to allow this sort of arenas, they&#x27;d be a terrible fit for Shopify&#x27;s monolith.<p>Ultimately, while it&#x27;s a bit counter intuitive, GCs can perform extremely well in term of throughput. Ruby&#x27;s GC isn&#x27;t quite there yet, but still perform quite well and is improving every versions.</div><br/><div id="42030682" class="c"><input type="checkbox" id="c-42030682" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42029936">parent</a><span>|</span><a href="#42030217">next</a><span>|</span><label class="collapse" for="c-42030682">[-]</label><label class="expand" for="c-42030682">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>allocating more than the arena can accommodate</i><p>In Zig, at least, this isn&#x27;t how arenas work. They&#x27;re a wrapper around a backing allocator, so if the arena runs out of memory, then that means the process is out of memory, something no allocation strategy can fix (ignoring the fact that Zig returns a specific error when that happens, and maybe you can trigger some cache eviction or something like that).<p>It&#x27;s easy to set them to retain a &#x27;reasonable&#x27; allocated capacity when they get reset, for whatever value of reasonable, so big allocation spikes get actually freed, but normal use just moves a pointer back and reuses that memory.<p>I don&#x27;t see Shopify harvesting a lot of value from a complete Zig rewrite, no. But arenas are basically ideal for the sort of memory use which web servers typically exhibit.</div><br/><div id="42031772" class="c"><input type="checkbox" id="c-42031772" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42030682">parent</a><span>|</span><a href="#42031687">next</a><span>|</span><label class="collapse" for="c-42031772">[-]</label><label class="expand" for="c-42031772">[1 more]</label></div><br/><div class="children"><div class="content">&gt; something no allocation strategy can fix<p>Well, yes, with a GC when your heap is full, you make space by getting rid of the garbage.<p>Also, with a good GC, allocating is most of the time just bumping a pointer, exactly like an arena, and the collection time is proportional to the number of live objects, which when triggered out of band is basically 0.<p>Hence why I think a well tuned GC really isn&#x27;t that far off.</div><br/></div></div><div id="42031687" class="c"><input type="checkbox" id="c-42031687" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42030682">parent</a><span>|</span><a href="#42031772">prev</a><span>|</span><a href="#42030217">next</a><span>|</span><label class="collapse" for="c-42031687">[-]</label><label class="expand" for="c-42031687">[1 more]</label></div><br/><div class="children"><div class="content">And when the default arena size is often outgrown, you&#x27;ll known from whatever diagnostics&#x2F;logging&#x2F;dashboard solution you are using. Which is incidentally also a great tool when optimizing per-request memory usage.<p>Being explicit about memory has many advantages, and is a strict requirement when scaling.</div><br/></div></div></div></div></div></div><div id="42030217" class="c"><input type="checkbox" id="c-42030217" checked=""/><div class="controls bullet"><span class="by">danmur</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42029816">parent</a><span>|</span><a href="#42029936">prev</a><span>|</span><a href="#42029869">next</a><span>|</span><label class="collapse" for="c-42030217">[-]</label><label class="expand" for="c-42030217">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think using Zig over Python is gonna have the biggest impact in making your next big company successful. It&#x27;s a drop in the ocean compared to the quality of people you have to actually design and build it.</div><br/><div id="42031691" class="c"><input type="checkbox" id="c-42031691" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42030217">parent</a><span>|</span><a href="#42031722">next</a><span>|</span><label class="collapse" for="c-42031691">[-]</label><label class="expand" for="c-42031691">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter for a startup trying to get acquired.<p>It does matter for a company trying to scale its user base while keeping costs down.</div><br/></div></div><div id="42031722" class="c"><input type="checkbox" id="c-42031722" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42030217">parent</a><span>|</span><a href="#42031691">prev</a><span>|</span><a href="#42029869">next</a><span>|</span><label class="collapse" for="c-42031722">[-]</label><label class="expand" for="c-42031722">[1 more]</label></div><br/><div class="children"><div class="content">That is nonsense. If you can run your code on 10 servers instead of 1k servers, that is an insane time and money saver that could make or break a company.</div><br/></div></div></div></div><div id="42029869" class="c"><input type="checkbox" id="c-42029869" checked=""/><div class="controls bullet"><span class="by">bhaak</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42029816">parent</a><span>|</span><a href="#42030217">prev</a><span>|</span><label class="collapse" for="c-42029869">[-]</label><label class="expand" for="c-42029869">[2 more]</label></div><br/><div class="children"><div class="content">Startups are not large companies in the beginning.<p>Although I&#x27;m not sure what the preferred language for quickly getting a startup up and running would be these days.</div><br/><div id="42029920" class="c"><input type="checkbox" id="c-42029920" checked=""/><div class="controls bullet"><span class="by">floating-io</span><span>|</span><a href="#42029678">root</a><span>|</span><a href="#42029869">parent</a><span>|</span><label class="collapse" for="c-42029920">[-]</label><label class="expand" for="c-42029920">[1 more]</label></div><br/><div class="children"><div class="content">Whatever works and you can find enough developers for.<p>The language (or the rest of the stack even) is rarely a barrier to success.  What matters are a good idea, good motivation, and decent availability of competence.<p>JMHO.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>