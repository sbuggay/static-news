<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723453264502" as="style"/><link rel="stylesheet" href="styles.css?v=1723453264502"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://unskilled.blog/posts/preemption-in-go-an-introduction/">Introduction to Golang Preemption Mechanisms</a> <span class="domain">(<a href="https://unskilled.blog">unskilled.blog</a>)</span></div><div class="subtext"><span>lcof</span> | <span>13 comments</span></div><br/><div><div id="41219192" class="c"><input type="checkbox" id="c-41219192" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41220958">next</a><span>|</span><label class="collapse" for="c-41219192">[-]</label><label class="expand" for="c-41219192">[7 more]</label></div><br/><div class="children"><div class="content">Are there any proposals to make the golang runtime cgroup aware? Last time I checked the go runtime will spawn a OS process for each cpu it can see even if it is running in a cgroup which only allows 1 CPU of usage.
On servers with 100+ cores I have seen scheduling time take over 10% of the program runtime.<p>The fix is to inspect the cgroupfs to see how many CPU shares you can utilize and then set gomaxprocs to match that. I think other runtime like Java and .NET do this automatically.<p>It is the same thing with GOMEMLIMIT, I don’t see why the runtime does not inspect cgroupfs and set GOMEMLIMIT to 90% of the cgroup memory limit.</div><br/><div id="41219307" class="c"><input type="checkbox" id="c-41219307" checked=""/><div class="controls bullet"><span class="by">lcof</span><span>|</span><a href="#41219192">parent</a><span>|</span><a href="#41219274">next</a><span>|</span><label class="collapse" for="c-41219307">[-]</label><label class="expand" for="c-41219307">[1 more]</label></div><br/><div class="children"><div class="content">On Linux, go uses sched_getaffinity to know how many cpu core it is allowed to run on:<p><a href="https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;master:src&#x2F;runtime&#x2F;os_linux.go;l=97" rel="nofollow">https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;master:src&#x2F;runtime&#x2F;os_l...</a></div><br/></div></div><div id="41219274" class="c"><input type="checkbox" id="c-41219274" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#41219192">parent</a><span>|</span><a href="#41219307">prev</a><span>|</span><a href="#41220003">next</a><span>|</span><label class="collapse" for="c-41219274">[-]</label><label class="expand" for="c-41219274">[4 more]</label></div><br/><div class="children"><div class="content">I am guessing the API isn&#x27;t stable enough for letting the runtime set maxprocs.  I use <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;go.uber.org&#x2F;automaxprocs" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;go.uber.org&#x2F;automaxprocs</a> and have had to update it periodically because Redhat and Debian have different defaults.  (Should one even run k8s on Redhat?  I say no, but Redhat says yes.  That&#x27;s how I know about this.)<p>This, I think, is cgroups 1 vs. cgroups 2 and everyone should have cgroups 2 now, but ... it would feel weird for the Go runtime to decide on one.  To me, anyway.</div><br/><div id="41219337" class="c"><input type="checkbox" id="c-41219337" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41219192">root</a><span>|</span><a href="#41219274">parent</a><span>|</span><a href="#41220003">next</a><span>|</span><label class="collapse" for="c-41219337">[-]</label><label class="expand" for="c-41219337">[3 more]</label></div><br/><div class="children"><div class="content">Which API is not stable? Cgroupfs?<p>I would think that cgroupfs is considered an API to userspace and therefore it shouldn’t break in the future? Hence creating cgroups v2?<p>I have written code which handles both cgroups v1 and cgroups v2, it isn’t terribly hard. Golang could also only support setting automatic parameters when running in cgroups v2 if that made things easier.<p>For a language that prides itself in sane defaults I think they have missed the mark here. I could probably add support to the golang runtime in a few hundred lines of code and probably save millions of dollars and megawatts of energy because the go runtime is not spawning 50 processes to run a program which is constrained to 1 core.</div><br/><div id="41219997" class="c"><input type="checkbox" id="c-41219997" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#41219192">root</a><span>|</span><a href="#41219337">parent</a><span>|</span><a href="#41220003">next</a><span>|</span><label class="collapse" for="c-41219997">[-]</label><label class="expand" for="c-41219997">[2 more]</label></div><br/><div class="children"><div class="content">I’m not 100% sold on the idea that Go’s defaults are sane.<p>They’re highly opinionated and not really that intuitive.</div><br/><div id="41220239" class="c"><input type="checkbox" id="c-41220239" checked=""/><div class="controls bullet"><span class="by">throw-the-towel</span><span>|</span><a href="#41219192">root</a><span>|</span><a href="#41219997">parent</a><span>|</span><a href="#41220003">next</a><span>|</span><label class="collapse" for="c-41220239">[-]</label><label class="expand" for="c-41220239">[1 more]</label></div><br/><div class="children"><div class="content">Could you elaborate?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41220958" class="c"><input type="checkbox" id="c-41220958" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41219192">prev</a><span>|</span><a href="#41221374">next</a><span>|</span><label class="collapse" for="c-41220958">[-]</label><label class="expand" for="c-41220958">[1 more]</label></div><br/><div class="children"><div class="content">&gt; think about it - what if I suddenly stopped you while taking a dump? It would have been easier to have stopped you before, or after, but not in the middle of it. Not sure about the analogy, but you got it.<p>Gold.</div><br/></div></div><div id="41221374" class="c"><input type="checkbox" id="c-41221374" checked=""/><div class="controls bullet"><span class="by">hiyer</span><span>|</span><a href="#41220958">prev</a><span>|</span><a href="#41218830">next</a><span>|</span><label class="collapse" for="c-41221374">[-]</label><label class="expand" for="c-41221374">[1 more]</label></div><br/><div class="children"><div class="content">This is a well-written article, but one thing that wasn&#x27;t clear to me was how the runtime determines that it&#x27;s at a safe point. Can someone shed some light on that?</div><br/></div></div><div id="41218830" class="c"><input type="checkbox" id="c-41218830" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#41221374">prev</a><span>|</span><a href="#41219447">next</a><span>|</span><label class="collapse" for="c-41218830">[-]</label><label class="expand" for="c-41218830">[2 more]</label></div><br/><div class="children"><div class="content">Interesting that it’s temporal (according to the article, you have around 10 microseconds before the signal-based preempter kicks in). How bad is performance if the load on the host is so high that double-preempting is common, I wonder? Or am I missing something and that question is not meaningful?</div><br/><div id="41218961" class="c"><input type="checkbox" id="c-41218961" checked=""/><div class="controls bullet"><span class="by">lcof</span><span>|</span><a href="#41218830">parent</a><span>|</span><a href="#41219447">next</a><span>|</span><label class="collapse" for="c-41218961">[-]</label><label class="expand" for="c-41218961">[1 more]</label></div><br/><div class="children"><div class="content">No it’s an interesting comment. This is not really about load, but about control flow: if goroutine is just spinning wild without going through any function prologue, it won’t even be aware of the synchronous preemption request. Asynchronous preemption (signal-based) is mainly (I say “mainly” because I am not sure I can say “only”) for this kind of situation.<p>I don’t have the link ready, but twitch had this kind of issue with base64 decoding in some kind of servers. The GC would try to STW, but there would always be one or a few goroutines decoding base64 in a tight loop for the time STW was attempted, delaying it again and again.<p>Asynchronous preemption is a solution to this kind of issue. Load is not the issue here, as long as you go through the runtime often enough.</div><br/></div></div></div></div><div id="41219447" class="c"><input type="checkbox" id="c-41219447" checked=""/><div class="controls bullet"><span class="by">ollien</span><span>|</span><a href="#41218830">prev</a><span>|</span><label class="collapse" for="c-41219447">[-]</label><label class="expand" for="c-41219447">[1 more]</label></div><br/><div class="children"><div class="content">Great post! One question that lingered for me is: what are asynchronous safe-points? The post goes into some detail about their synchronous counterparts</div><br/></div></div></div></div></div></div></div></body></html>