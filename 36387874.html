<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687165250065" as="style"/><link rel="stylesheet" href="styles.css?v=1687165250065"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mtlynch.io/notes/nix-first-impressions/">My First Impressions of Nix</a> <span class="domain">(<a href="https://mtlynch.io">mtlynch.io</a>)</span></div><div class="subtext"><span>signa11</span> | <span>62 comments</span></div><br/><div><div id="36388114" class="c"><input type="checkbox" id="c-36388114" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388323">next</a><span>|</span><label class="collapse" for="c-36388114">[-]</label><label class="expand" for="c-36388114">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Nix, on the other hand, does have a concept of state. If you make a one-line change to a 200-line Nix configuration, it doesn’t have to re-do all the work from the other 199 lines. It can evaluate the state of the system against the configuration file and recognize that it just has to apply the one-line change. And that change usually happens in a few seconds.<p>The author seems to have some misguided ideas about Nix. Nix is not fast because it is stateful. It is fast because it is functional and reproducible, which allows for caching without compromising correctness. I don&#x27;t want to split hairs, but referentially transparent caching like this is not quite what I&#x27;d call state.<p>Yes, there is some statefulness in system activation, but this is not what makes Nix Nix -- quite the opposite.</div><br/><div id="36388251" class="c"><input type="checkbox" id="c-36388251" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#36388114">parent</a><span>|</span><a href="#36388218">next</a><span>|</span><label class="collapse" for="c-36388251">[-]</label><label class="expand" for="c-36388251">[4 more]</label></div><br/><div class="children"><div class="content">Just to elaborate a bit for those not familiar to Nix (slightly simplified to exclude recent support for content addressing). Nix work with derivations, a derivation is basically a data structure that specifies how a package is built. Derivations are normally not created by hand but using a function (eg. <i>stdenv.mkDerivation</i>).<p>When you ask Nix to build a package, it hashes a normalized form of derivation data structure. This hash is useful in various ways, but one way it is used [1] is to look up whether the derivation is already in the Nix Store. Because if it is, there is no need to build it. So Nix looks up whether<p><pre><code>    &#x2F;nix&#x2F;&lt;the_derivation_hash&gt;
</code></pre>
exists. If it exists, the build is done. If it doesn&#x27;t exist and you have a binary cache configured (which by default is the binary cache provided by the NixOS project), Nix will look up the derivation hash in the binary cache. If it exists in the binary cache, Nix will download the path to the local Nix store. After that<p><pre><code>    &#x2F;nix&#x2F;&lt;the_derivation_hash&gt;
</code></pre>
exists in the store and the build is done (without building anything). Only if that fails, Nix will actually build the derivation.<p>Now, one of the cool things about Nix is that it is derivations all the way down. So, it&#x27;s not that just what we traditionally think of as packages is a derivation, but people wrap up all kinds of things as derivations, including configuration, etc. Since derivations are usually generated by functions, there are all kinds of useful functions that make derivations for eg.: single configuration files, scripts, etc.<p>In the end, building a NixOS system generation is just building a derivation. nixos-rebuild switches to a different generation by just setting a bunch of symlinks to an output path in the store containing that system generation (<i>&#x2F;nix&#x2F;&lt;system_config_derivation_hash</i>).<p>At any rate, when <i>you make a one-line change to a 200-line Nix configuration</i>, Nix does have state to keep track of what it needs to rebuild or not. Nix will just try to build the derivation (and its dependencies), but it hashes the derivations, finds that their output paths are already in the store.<p>Some might argue that then the store is state. But it&#x27;s not, at build time you are evaluating a pure function with memoization (the Nix Store).<p>[1] There is also a package name and version in the store path, but lets keep it simple.</div><br/><div id="36388405" class="c"><input type="checkbox" id="c-36388405" checked=""/><div class="controls bullet"><span class="by">henrydark</span><span>|</span><a href="#36388114">root</a><span>|</span><a href="#36388251">parent</a><span>|</span><a href="#36388218">next</a><span>|</span><label class="collapse" for="c-36388405">[-]</label><label class="expand" for="c-36388405">[3 more]</label></div><br/><div class="children"><div class="content">I agree with everything but the last statement. This all comes down to: do you consider memoization to be state.<p>I predict people&#x27;s answers to this question will come from experience with memoization. Here&#x27;s mine: I kept trying to get nix to build tensorflow locally, so that I would get the avx512 benefits of the big, but gpu-less machine I had. I hadn&#x27;t realized some other derivation had already downloaded tensorflow from online cache, so didn&#x27;t have avx512 enabled. I kept making shells, trying tensorflow, seeing it doesn&#x27;t have support. The solution was to tell nix to disregard the nix store, in order to force the local build. This experience has left me with the concrete feeling that the nix store is full-on state, and I the user must be aware of it.</div><br/><div id="36388614" class="c"><input type="checkbox" id="c-36388614" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388114">root</a><span>|</span><a href="#36388405">parent</a><span>|</span><a href="#36388604">next</a><span>|</span><label class="collapse" for="c-36388614">[-]</label><label class="expand" for="c-36388614">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you have unfortunately discovered that sometimes the hardware itself is an input that isn&#x27;t always captured explicitly, but also isn&#x27;t controlled for with sandboxing. Ideally enabling avx512 would be an explicit input to the tensorflow package, but based on your experience it sounds like this feature is detected during the build automatically.<p>I hope that issues like this get better over time thanks to projects like Trustix, which would make non-reproducibility like this more apparent.</div><br/></div></div><div id="36388604" class="c"><input type="checkbox" id="c-36388604" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#36388114">root</a><span>|</span><a href="#36388405">parent</a><span>|</span><a href="#36388614">prev</a><span>|</span><a href="#36388218">next</a><span>|</span><label class="collapse" for="c-36388604">[-]</label><label class="expand" for="c-36388604">[1 more]</label></div><br/><div class="children"><div class="content">I think part of the problem ist that derivation hashs sometimes don&#x27;t fully cover the intermediate states of a derivation during the build process. This might lead to two hashs pointing to effectively two different configurations. I&#x27;ve had that experience in particular with non-reproducible derivations.<p>Even one of those in the store will make the store, or at least a subset of it, a state.</div><br/></div></div></div></div></div></div><div id="36388218" class="c"><input type="checkbox" id="c-36388218" checked=""/><div class="controls bullet"><span class="by">hardware2win</span><span>|</span><a href="#36388114">parent</a><span>|</span><a href="#36388251">prev</a><span>|</span><a href="#36388323">next</a><span>|</span><label class="collapse" for="c-36388218">[-]</label><label class="expand" for="c-36388218">[2 more]</label></div><br/><div class="children"><div class="content">Functional?</div><br/><div id="36388717" class="c"><input type="checkbox" id="c-36388717" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#36388114">root</a><span>|</span><a href="#36388218">parent</a><span>|</span><a href="#36388323">next</a><span>|</span><label class="collapse" for="c-36388717">[-]</label><label class="expand" for="c-36388717">[1 more]</label></div><br/><div class="children"><div class="content">Just in case: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functional_programming" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functional_programming</a></div><br/></div></div></div></div></div></div><div id="36388323" class="c"><input type="checkbox" id="c-36388323" checked=""/><div class="controls bullet"><span class="by">scandinavian</span><span>|</span><a href="#36388114">prev</a><span>|</span><a href="#36388721">next</a><span>|</span><label class="collapse" for="c-36388323">[-]</label><label class="expand" for="c-36388323">[16 more]</label></div><br/><div class="children"><div class="content">Now that we have another Nix post, maybe someone can enlighten me about something I&#x27;ve been wondering about.<p>I&#x27;m one of the maintainers of a popular django application. Someone made a nix package of the project, but we&#x27;ve now twice gotten invalid bug reports from people using the package because the package depends on &quot;django_4&quot; and whenever someone updates that nix package, the package for our project breaks.<p>Of course we, like all other python projects, don&#x27;t support using other dependency versions then the ones in the requirements.txt file. So when someone just uses a different minor version of django, stuff breaks. What&#x27;s the disconnect here? Why does all nix packages that use django_4 need to use the same version, that seems super prone to breaking all kinds of stuff. Same for the other 35+ dependencies that run arbitrary versions instead of the ones defined in the requirements.txt file.</div><br/><div id="36388406" class="c"><input type="checkbox" id="c-36388406" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388323">parent</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388406">[-]</label><label class="expand" for="c-36388406">[12 more]</label></div><br/><div class="children"><div class="content">It seems like Nixpkgs aims to minimize the number of package versions in use at one time. Not just nix, most package managers do, it seems (i.e. you wouldn&#x27;t expect to find different minor versions of Nginx in Debian, would you?)<p>So by that same logic, there is only one version of Django 4.<p>It is definitely possible with Nix to use the precise versions of what&#x27;s in your requirements.txt, but I&#x27;m not sure if the Nixpkgs maintainers would allow all that extra duplication upstream.</div><br/><div id="36388489" class="c"><input type="checkbox" id="c-36388489" checked=""/><div class="controls bullet"><span class="by">traxys</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388406">parent</a><span>|</span><a href="#36388436">next</a><span>|</span><label class="collapse" for="c-36388489">[-]</label><label class="expand" for="c-36388489">[1 more]</label></div><br/><div class="children"><div class="content">I packaged some python applications in nixpkgs, and it seems the consensus is to try and relax the dependency so that the globally packaged version is used, but if it fails the you can override the version yourself. Though this is not done through the requirements.txt because that file does not have enough information (no integrity hash for example).</div><br/></div></div><div id="36388436" class="c"><input type="checkbox" id="c-36388436" checked=""/><div class="controls bullet"><span class="by">scandinavian</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388406">parent</a><span>|</span><a href="#36388489">prev</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388436">[-]</label><label class="expand" for="c-36388436">[10 more]</label></div><br/><div class="children"><div class="content">I get what you are saying, but nothing you said works in practice for python packages, so not sure that I actually learned anything.<p>Is it fair to summize that python applications with python dependencies do not really work well as nix packages and shouldn&#x27;t be used?</div><br/><div id="36388811" class="c"><input type="checkbox" id="c-36388811" checked=""/><div class="controls bullet"><span class="by">ruuda</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388436">parent</a><span>|</span><a href="#36388564">next</a><span>|</span><label class="collapse" for="c-36388811">[-]</label><label class="expand" for="c-36388811">[1 more]</label></div><br/><div class="children"><div class="content">No, that is not a fair summary; Nix is the nicest way to manage Python packages that I have found thus far.</div><br/></div></div><div id="36388564" class="c"><input type="checkbox" id="c-36388564" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388436">parent</a><span>|</span><a href="#36388811">prev</a><span>|</span><a href="#36388527">next</a><span>|</span><label class="collapse" for="c-36388564">[-]</label><label class="expand" for="c-36388564">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but nothing you said works in practice for python packages<p>How do transitive dependencies in the Python ecosystem work, then? I assume Django works with multiple versions of python and bcrypt. I assume pandas works with multiple versions of scipy. Is there no semantic versioning? If everything requires an exact version, how do you prevent everything from grinding to a halt?<p>&gt; Is it fair to summize that python applications with python dependencies do not really work well as nix packages and shouldn&#x27;t be used?<p>Let&#x27;s not conflate Nix and Nixpkgs. Nixpkgs has its reasons for minimizing redundant packages, however it is certainly possible to package your app with Nix and use the exact specified dependencies.</div><br/><div id="36388601" class="c"><input type="checkbox" id="c-36388601" checked=""/><div class="controls bullet"><span class="by">scandinavian</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388564">parent</a><span>|</span><a href="#36388527">next</a><span>|</span><label class="collapse" for="c-36388601">[-]</label><label class="expand" for="c-36388601">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How do transitive dependencies in the Python ecosystem work, then?<p>Not very well.<p>&gt; how do you prevent everything from grinding to a halt?<p>I don&#x27;t have a good answer for you.<p>&gt; Is there no semantic versioning?<p>You can read django release process here [1], not sure how it&#x27;s relevant. I&#x27;m not the maintainer of django, but of a project using django. Would it be better if all software was perfect, had no bugs and used perfect semantic versioning? Yes, I would say so. Is that a requirement for using nixpkgs?<p>&gt; Nixpkgs has its reasons for minimizing redundant packages, however it is certainly possible to package your app with Nix and use the exact specified dependencies.<p>I&#x27;m not packaging it, someone else is, it breaks and they come to the project to raise invalid bug reports.<p>[1] <a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;internals&#x2F;release-process&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;internals&#x2F;release-proc...</a></div><br/><div id="36388689" class="c"><input type="checkbox" id="c-36388689" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388601">parent</a><span>|</span><a href="#36388527">next</a><span>|</span><label class="collapse" for="c-36388689">[-]</label><label class="expand" for="c-36388689">[1 more]</label></div><br/><div class="children"><div class="content">&gt; not sure how it&#x27;s relevant.<p>Well you said earlier that nothing I said works in practice for python packages. My only point is that it must work at some level in the python ecosystem, else the ecosystem would collapse.<p>Anyways, it sounds like you&#x27;re unhappy that someone did a bad job packaging your application. That sucks. Elsewhere in this thread someone mentioned that there isn&#x27;t a strict single version policy in nixpkgs, so this can probably be easily fixed. I&#x27;d suggest filing a bug in Nixpkgs.</div><br/></div></div></div></div></div></div><div id="36388527" class="c"><input type="checkbox" id="c-36388527" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388436">parent</a><span>|</span><a href="#36388564">prev</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388527">[-]</label><label class="expand" for="c-36388527">[5 more]</label></div><br/><div class="children"><div class="content">Sounds like the problem is with Python maintainers who don’t understand that breaking changes should only be made between major versions.<p>If that’s not possible though then as sibling comment said - you can override the dependencies and the nix maintainer should make sure the package works as expected</div><br/><div id="36388607" class="c"><input type="checkbox" id="c-36388607" checked=""/><div class="controls bullet"><span class="by">hfkwer</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388527">parent</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388607">[-]</label><label class="expand" for="c-36388607">[4 more]</label></div><br/><div class="children"><div class="content">Sounds like the problem could also be with Nix maintainers who don&#x27;t understand that &quot;semver&quot; is not a universal law of nature and that not all projects and ecosystems follow it. This kind of blanket dismissal can cut both ways.<p>Semver (the website and &quot;spec&quot;) was created in 2009 by some guy. It&#x27;s not an RFC, a standard, or anything like that. Yes, it gained widespread adoption. Yes, the guy in question is a cofounder of GitHub. So what? You cannot force it upon everyone. Python is about 20 years older than semver. Django is several years older. Should the whole ecosystem change their conventions because it&#x27;s more convenient for a few people?</div><br/><div id="36388646" class="c"><input type="checkbox" id="c-36388646" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388607">parent</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388646">[-]</label><label class="expand" for="c-36388646">[3 more]</label></div><br/><div class="children"><div class="content">Except Django site says that a.b are feature releases which should be backwards compatible except for specific exceptions. If their software truly breaks “with every update to django_4” then it’s either a problem on Django’s side or a problem in how said person uses Django</div><br/><div id="36388711" class="c"><input type="checkbox" id="c-36388711" checked=""/><div class="controls bullet"><span class="by">hfkwer</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388646">parent</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388711">[-]</label><label class="expand" for="c-36388711">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it&#x27;s deliberate or a communication&#x2F;comprehension problem, but you&#x27;re misquoting Django&#x27;s release process <a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;internals&#x2F;release-process&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;internals&#x2F;release-proc...</a><p>&gt; * Versions are numbered in the form A.B or A.B.C.<p>&gt; * A.B is the feature release version number. Each version will be mostly backwards compatible with the previous release. Exceptions to this rule will be listed in the release notes.<p>&gt; * C is the patch release version number, which is incremented for bugfix and security releases. These releases will be 100% backwards-compatible with the previous patch release. The only exception is when a security or data loss issue can’t be fixed without breaking backwards-compatibility. If this happens, the release notes will provide detailed upgrade instructions.<p>Going from &quot;mostly backwards compatible with the previous release. Exceptions to this rule will be listed&quot; to &quot;should be backwards compatible except for specific exceptions&quot; is quite the stretch. There are no &quot;specific exceptions&quot;: incompatibilities can be anywhere and you need to read the release notes to know where. In semver, a minor version increment is backwards-compatible, no exception, no ifs or buts.<p>If you want to shoehorn Django&#x27;s release process into &quot;semver&quot;, then act as if the product is called &quot;Django 4&quot;. If the version is &quot;Django v4.X.Y&quot;, then X is the major version number, Y is the minor version number, and there is no patch version. It should be version in Nix as &quot;django4 vX.Y.0&quot;.</div><br/><div id="36388746" class="c"><input type="checkbox" id="c-36388746" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#36388323">root</a><span>|</span><a href="#36388711">parent</a><span>|</span><a href="#36388802">next</a><span>|</span><label class="collapse" for="c-36388746">[-]</label><label class="expand" for="c-36388746">[1 more]</label></div><br/><div class="children"><div class="content">They clearly say “exceptions to this rule will be listed in the release notes” meaning that backwards compatibility is the rule. There’d be no exceptions if there was no rule hence I said they “should” be backwards compatible except for specific exceptions, which shall be noted in the release notes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36388802" class="c"><input type="checkbox" id="c-36388802" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#36388323">parent</a><span>|</span><a href="#36388406">prev</a><span>|</span><a href="#36388815">next</a><span>|</span><label class="collapse" for="c-36388802">[-]</label><label class="expand" for="c-36388802">[1 more]</label></div><br/><div class="children"><div class="content">nixpkgs doesn&#x27;t use requirements.txt for whatever reason.<p>(That reason probably being the utter brokenness and braindead state of Python packaging; Node packages work much better.)</div><br/></div></div><div id="36388815" class="c"><input type="checkbox" id="c-36388815" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#36388323">parent</a><span>|</span><a href="#36388802">prev</a><span>|</span><a href="#36388420">next</a><span>|</span><label class="collapse" for="c-36388815">[-]</label><label class="expand" for="c-36388815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Of course we, like all other python projects, don&#x27;t support using other dependency versions then the ones in the requirements.txt file. So when someone just uses a different minor version of django, stuff breaks<p>That sounds wrong. A Python package should not have a requirements.txt file at all. A requirements.txt file is for &quot;freezing&quot; and fully reproducing an environment (ie. in a virtualenv or docker container). This is useful for certain applications like deploying services or sharing notebooks etc. It is <i>not</i> for packages. A package should document its requirements via setup.py&#x2F;pyproject.toml and do so in the loosest way possible. Django uses semver and Django apps don&#x27;t generally need to pin to minor versions.<p>Stuff like this is why people think Python packaging is worse than it really is.</div><br/></div></div><div id="36388420" class="c"><input type="checkbox" id="c-36388420" checked=""/><div class="controls bullet"><span class="by">jacereda</span><span>|</span><a href="#36388323">parent</a><span>|</span><a href="#36388815">prev</a><span>|</span><a href="#36388721">next</a><span>|</span><label class="collapse" for="c-36388420">[-]</label><label class="expand" for="c-36388420">[1 more]</label></div><br/><div class="children"><div class="content">The answer today would probably be to use flakes: <a href="https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Flakes" rel="nofollow noreferrer">https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Flakes</a></div><br/></div></div></div></div><div id="36388721" class="c"><input type="checkbox" id="c-36388721" checked=""/><div class="controls bullet"><span class="by">Jedd</span><span>|</span><a href="#36388323">prev</a><span>|</span><a href="#36388169">next</a><span>|</span><label class="collapse" for="c-36388721">[-]</label><label class="expand" for="c-36388721">[1 more]</label></div><br/><div class="children"><div class="content">My experiences with Saltstack and Ansible are inverted - I realise the comparison was only a casual aside in TFA, but the &#x27;Ansible executed the idea better than Saltstack&#x27; comment invites so many questions, especially in the context of an article that dwells on how unpleasant Ansible is.<p>Ansible certainly defaults to slow, and I never got into the weeds for performance tuning it, but Saltstack felt fast, especially the example of &#x27;install package foo&#x27; which he anticipated takes 15 minutes to run against one of his VMs using Ansible.  I agree, that sounds unpleasant.<p>Others have noted the slight confusion about state (and where that state is or should be maintained), and certainly writing idempotent salt or ansible recipes takes some thought, just as writing performant recipes does.  The &#x27;have to rewrite everything&#x27; whenever Ansible releases a new feature doesn&#x27;t sound right - perhaps I misunderstand the problem described there.<p>Author mentions apt, but ultimately sounds like they wanted something more container-y than a fat VM running a full GNU&#x2F;Linux distro with managed packages + config files. In that light, the mention of Hashicorp - specifically Terraform &amp; Nomad - felt tantalisingly prescient.</div><br/></div></div><div id="36388169" class="c"><input type="checkbox" id="c-36388169" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#36388721">prev</a><span>|</span><a href="#36388339">next</a><span>|</span><label class="collapse" for="c-36388169">[-]</label><label class="expand" for="c-36388169">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve occasionally encountered projects using Nix, and I&#x27;ve casually browsed the Nix and NixOS websites, but I still don&#x27;t have a clear idea of <i>what Nix is.</i><p>Is it a package manager? A build system? An operating system? A container platform? A sandbox? An automation tool?<p>Which widely used, existing software tools is it analogous to?</div><br/><div id="36388241" class="c"><input type="checkbox" id="c-36388241" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388287">next</a><span>|</span><label class="collapse" for="c-36388241">[-]</label><label class="expand" for="c-36388241">[1 more]</label></div><br/><div class="children"><div class="content">Most of the above.<p>- Nix is a tool for building and installing software.<p>- Nix is a language for expressing how to build a package. Nix-the-tool reads expressions defined in Nix-the-language to know what to do. At the end of the day, this translates into normal commands that run in a sandboxed build environment.<p>- Nixpkgs is a monolithic repository of 80000+ packages, defined literally as one giant expression in the Nix language (this works fine because Nix is an extremely lazy language). This also includes lots of helpers and abstractions for building packages that can be handy in your own projects. It is possible to use Nix-the-tool without Nixpkgs, but nobody does.<p>- NixOS is a Linux distribution built on these foundations. Everything under &#x2F;etc is built from nix expressions. You can not directly edit these. Mostly NixOS is about building systemd unit files from Nix expressions - viewed through that lens it&#x27;s not really all that exotic of an OS. NixOS has modules that make it very easy to configure and run lots of software.</div><br/></div></div><div id="36388287" class="c"><input type="checkbox" id="c-36388287" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388241">prev</a><span>|</span><a href="#36388260">next</a><span>|</span><label class="collapse" for="c-36388287">[-]</label><label class="expand" for="c-36388287">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s maybe best described as a software ecosystem, which has the unfortunate problem that the programming language it uses and the package&#x2F;deploy tools written in that programming language share the name &quot;Nix&quot;. Nix the language (basically a customized version of Standard ML) is used to write package and OS definitions that Nix the tool uses to actually build and deploy software, containers, and operating systems. The &quot;ecosystem&quot; bit comes from the fact that the language is used to write the package&#x2F;deploy definitions, and a large community of users have assembled a rather good and up-to-date set of package definitions, and these have been bundled together as an operating system, and these all share the rubric &quot;Nix&quot;.</div><br/></div></div><div id="36388260" class="c"><input type="checkbox" id="c-36388260" checked=""/><div class="controls bullet"><span class="by">imagineerschool</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388287">prev</a><span>|</span><a href="#36388318">next</a><span>|</span><label class="collapse" for="c-36388260">[-]</label><label class="expand" for="c-36388260">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Yes, it is.&quot;<p>AFAIK It&#x27;s each of those things, each unfortunately named the same.</div><br/><div id="36388639" class="c"><input type="checkbox" id="c-36388639" checked=""/><div class="controls bullet"><span class="by">rollcat</span><span>|</span><a href="#36388169">root</a><span>|</span><a href="#36388260">parent</a><span>|</span><a href="#36388318">next</a><span>|</span><label class="collapse" for="c-36388639">[-]</label><label class="expand" for="c-36388639">[1 more]</label></div><br/><div class="children"><div class="content">We already have names like NixOS and nixpkgs at the top, and individual commands such as nix-env or nix-shell at a lower layer. Perhaps it would be beneficial to adopt official names for other components currently named &quot;nix&quot;, such as nixlang (when referring to just the language).</div><br/></div></div></div></div><div id="36388318" class="c"><input type="checkbox" id="c-36388318" checked=""/><div class="controls bullet"><span class="by">nickcox</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388260">prev</a><span>|</span><a href="#36388255">next</a><span>|</span><label class="collapse" for="c-36388318">[-]</label><label class="expand" for="c-36388318">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is it a package manager? A build system? An operating system? A container platform? A sandbox? An automation tool?<p>Yes</div><br/></div></div><div id="36388255" class="c"><input type="checkbox" id="c-36388255" checked=""/><div class="controls bullet"><span class="by">mindwok</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388318">prev</a><span>|</span><a href="#36388290">next</a><span>|</span><label class="collapse" for="c-36388255">[-]</label><label class="expand" for="c-36388255">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s got elements of all of those things. It&#x27;s basically a toolchain for building an &#x27;environment&#x27;, which is roughly analogous to a Linux distribution.<p>It starts with a language that lets you declare the desired state of your environment, including which packages are present and the configuration of those packages. The packages are installed and managed through the Nix package manager. The end result is an &#x27;environment&#x27; that reflects the desired state you expressed. That environment can be a Docker image, an ISO, or it could be a running system you&#x27;re booted into (in the case of NixOS). Or it can even be an ephemeral environment that exists on the filesystem of whatever distribution you&#x27;re using (in the case of nix-shell). Each of these options offers different levels of isolation and reproducibility, depending on the requirements of your project or system.<p>There&#x27;s lots of clever components that make something like this possible, and they&#x27;re all wrapped up in the Nix umbrella.</div><br/></div></div><div id="36388290" class="c"><input type="checkbox" id="c-36388290" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388255">prev</a><span>|</span><a href="#36388226">next</a><span>|</span><label class="collapse" for="c-36388290">[-]</label><label class="expand" for="c-36388290">[1 more]</label></div><br/><div class="children"><div class="content">It confuses a lot of people, because Nix breaks down the boundaries of what we traditionally see as separate tools. If you have a sufficiently powerful language to describe how to build things, you can build packages, container images, operating systems, etc. with it. Probably the closest equivalent outside Nix&#x2F;Guix is Bazel or Buck (not the same, but they have many overlapping goals).</div><br/></div></div><div id="36388226" class="c"><input type="checkbox" id="c-36388226" checked=""/><div class="controls bullet"><span class="by">seqizz</span><span>|</span><a href="#36388169">parent</a><span>|</span><a href="#36388290">prev</a><span>|</span><a href="#36388339">next</a><span>|</span><label class="collapse" for="c-36388226">[-]</label><label class="expand" for="c-36388226">[3 more]</label></div><br/><div class="children"><div class="content">Afaiu it&#x27;s trying to become all. Nix is on core, you can get packages from nixpkgs &#x2F; write your own definitions, use it on OS configurations via NixOS, use its built-in helpers to run your containers with it, make a whole CI and cache it with the help of Hydra etc.</div><br/><div id="36388240" class="c"><input type="checkbox" id="c-36388240" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#36388169">root</a><span>|</span><a href="#36388226">parent</a><span>|</span><a href="#36388339">next</a><span>|</span><label class="collapse" for="c-36388240">[-]</label><label class="expand" for="c-36388240">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s confusing because NixOS also seems to be an operating system, looking at the blog post?</div><br/><div id="36388265" class="c"><input type="checkbox" id="c-36388265" checked=""/><div class="controls bullet"><span class="by">chpatrick</span><span>|</span><a href="#36388169">root</a><span>|</span><a href="#36388240">parent</a><span>|</span><a href="#36388339">next</a><span>|</span><label class="collapse" for="c-36388265">[-]</label><label class="expand" for="c-36388265">[1 more]</label></div><br/><div class="children"><div class="content">NixOS is just a super barebones distro where everything is configured with Nix. You can also use Nix on Ubuntu or some other distro.</div><br/></div></div></div></div></div></div></div></div><div id="36388339" class="c"><input type="checkbox" id="c-36388339" checked=""/><div class="controls bullet"><span class="by">dottedmag</span><span>|</span><a href="#36388169">prev</a><span>|</span><a href="#36388111">next</a><span>|</span><label class="collapse" for="c-36388339">[-]</label><label class="expand" for="c-36388339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Using VS Code Remote SSH on NixOS systems<p>This is the main of issue with Nix and other niche distributions: they are new operating systems, with their set of file layouts, package managers, and even syscall variations.<p>Linux ecosystem is awfully fragmented. If you ever want to use any software outside of your not-very-well-walled-garden provided by distribution authors, you have to hope your operating system (that is, distro) is sufficiently similar to one of few distros software authors have built and QAed their software on.<p>I have written at length about it here: <a href="https:&#x2F;&#x2F;dottedmag.net&#x2F;blog&#x2F;linux-is-not-os&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dottedmag.net&#x2F;blog&#x2F;linux-is-not-os&#x2F;</a><p>I wish for a system that:<p>1. provides declarative configuration.<p>2. allows for easy local patching.<p>3. is ABI-compatible with a major distro.<p>Alas. Fedora Bluesilver delivers 1 and 3. Gentoo provides 2. NixOS provides 1 and 3.</div><br/></div></div><div id="36388111" class="c"><input type="checkbox" id="c-36388111" checked=""/><div class="controls bullet"><span class="by">lvncelot</span><span>|</span><a href="#36388339">prev</a><span>|</span><a href="#36388256">next</a><span>|</span><label class="collapse" for="c-36388111">[-]</label><label class="expand" for="c-36388111">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a huge fan of Nix, and I&#x27;m glad to have stuck with the often times daunting process of getting into it - and I have to agree with the author&#x27;s point regarding the documentation. That&#x27;s not a fault of the people who actually did sit down and document their process, or distill their learning path into a tutorial - I myself understand it well enough to use it, but not well enough to really explain it without confusing people even more, but it&#x27;s still a pity that finding good, exhaustive documentation for Nix is really difficult.<p>Another pitfall is the usage of flakes, which, on the one hand are (imho) great, recommended everywhere and often times even assumed to be used implicitly, but on the other hand are <i>still</i> experimental. I myself started using flakes not because of the promised benefit (although I did realize the benefit later on) but just because multiple tutorials I&#x27;ve read gave me the feeling that flakes were the de facto way to do Nix from now on - and mind you, that was in late 2020.<p>I&#x27;m using Nix for setting up my work machine (Mac via nix-darwin), my private machines (NixOS), selfhosting that&#x27;s not in my k8s (also NixOS), and some private projects (dependencies, ci, and containers) - where the issues I&#x27;ve described don&#x27;t really bother me, but for professional projects, where I&#x27;d have to convince and&#x2F;or instruct colleagues, Nix feels a bit too rough around the edges for me right now.<p>Edit: I also think it&#x27;s important to distinguish between Nix the technology (fantastic) and Nix the language (meh) - which is why I&#x27;m still itching to try out Guix[1], which is similar to Nix (the technology) in a lot of ways while using  Guile[2] as a language.<p>[1] <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;guix.gnu.org&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;</a></div><br/><div id="36388331" class="c"><input type="checkbox" id="c-36388331" checked=""/><div class="controls bullet"><span class="by">mteigers</span><span>|</span><a href="#36388111">parent</a><span>|</span><a href="#36388256">next</a><span>|</span><label class="collapse" for="c-36388331">[-]</label><label class="expand" for="c-36388331">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if you have any pointers for whole Mac config with nix-darwin. This is something I&#x27;ve just started looking at and at the moment don&#x27;t have much more than a nix-shell with some nice-to-haves. Any tips &#x2F; tricks &#x2F; guides are greatly appreciated.</div><br/><div id="36388554" class="c"><input type="checkbox" id="c-36388554" checked=""/><div class="controls bullet"><span class="by">cormacrelf</span><span>|</span><a href="#36388111">root</a><span>|</span><a href="#36388331">parent</a><span>|</span><a href="#36388256">next</a><span>|</span><label class="collapse" for="c-36388554">[-]</label><label class="expand" for="c-36388554">[2 more]</label></div><br/><div class="children"><div class="content">Life’s short. Don’t waste it configuring nix-darwin.</div><br/><div id="36388703" class="c"><input type="checkbox" id="c-36388703" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#36388111">root</a><span>|</span><a href="#36388554">parent</a><span>|</span><a href="#36388256">next</a><span>|</span><label class="collapse" for="c-36388703">[-]</label><label class="expand" for="c-36388703">[1 more]</label></div><br/><div class="children"><div class="content">As someone who has nix-darwin on their daily driver machine I can confidently say that I spent very little time configuring it and my config is almost in full shared between both NixOS and nix-darwin</div><br/></div></div></div></div></div></div></div></div><div id="36388256" class="c"><input type="checkbox" id="c-36388256" checked=""/><div class="controls bullet"><span class="by">CapsAdmin</span><span>|</span><a href="#36388111">prev</a><span>|</span><a href="#36388233">next</a><span>|</span><label class="collapse" for="c-36388256">[-]</label><label class="expand" for="c-36388256">[2 more]</label></div><br/><div class="children"><div class="content">I feel a little lost on nixos. Been using it for a while now on my main personal desktop and it&#x27;s fine, but whenever I want to do something like running a python project (ml based ones for example), or compile software from source, I&#x27;m lost because I don&#x27;t know what I&#x27;m doing. Most projects target Ubuntu, so I feel you need to know a lot about how nix really works to get them compiling, which is often not what I&#x27;m in the mood for tinkering with when I just want to test something.<p>So in the end I end up using distrobox with Ubuntu which works surprisingly well, but feels very hacky as I&#x27;m supposed to try and use nix. The way I rationalize this is that I&#x27;ll get rid of distrobox slowly over time as I learn how it works.</div><br/><div id="36388303" class="c"><input type="checkbox" id="c-36388303" checked=""/><div class="controls bullet"><span class="by">madjam002</span><span>|</span><a href="#36388256">parent</a><span>|</span><a href="#36388233">next</a><span>|</span><label class="collapse" for="c-36388303">[-]</label><label class="expand" for="c-36388303">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used Nix for 5 years now and use it heavily in production, and in my opinion, just do what works for you. If you try and use Nix 100% &quot;correctly&quot; then you&#x27;ll end up like the countless other people who tried Nix and failed.<p>Especially for toying around in dev environments, be pragmatic and take advantage of its amazing strengths, but if distrobox lets you enjoy using NixOS and speed up your workflow, so be it.<p>Heck I&#x27;m spinning up some services in production just now and I&#x27;m reaching for Docker Compose as that&#x27;s how the vendor officially supports deploying their software. Turns out NixOS can still bring some benefits to a Docker Compose workflow, deploying it via a systemd service, config managed in Nix, it&#x27;s not as nice as building the service entirely in a Nix derivation and deploying it natively, but it&#x27;s still better than without NixOS.</div><br/></div></div></div></div><div id="36388233" class="c"><input type="checkbox" id="c-36388233" checked=""/><div class="controls bullet"><span class="by">bouk</span><span>|</span><a href="#36388256">prev</a><span>|</span><a href="#36387936">next</a><span>|</span><label class="collapse" for="c-36388233">[-]</label><label class="expand" for="c-36388233">[1 more]</label></div><br/><div class="children"><div class="content">If you want to install a package, search for it at <a href="https:&#x2F;&#x2F;search.nixos.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;search.nixos.org</a><p>The gnome system monitor is gnome.gnome-system-monitor for example <a href="https:&#x2F;&#x2F;search.nixos.org&#x2F;packages?channel=23.05&amp;show=gnome.gnome-system-monitor&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=System-monitor" rel="nofollow noreferrer">https:&#x2F;&#x2F;search.nixos.org&#x2F;packages?channel=23.05&amp;show=gnome.g...</a></div><br/></div></div><div id="36387936" class="c"><input type="checkbox" id="c-36387936" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36388233">prev</a><span>|</span><a href="#36388091">next</a><span>|</span><label class="collapse" for="c-36387936">[-]</label><label class="expand" for="c-36387936">[1 more]</label></div><br/><div class="children"><div class="content">easiest way to get up and running w&#x2F;value in the nix ecosystem is <a href="https:&#x2F;&#x2F;devenv.sh" rel="nofollow noreferrer">https:&#x2F;&#x2F;devenv.sh</a> and as time goes on use escape hatches to utilise more of nix ala <a href="https:&#x2F;&#x2F;nix.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;nix.dev</a></div><br/></div></div><div id="36388091" class="c"><input type="checkbox" id="c-36388091" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#36387936">prev</a><span>|</span><a href="#36388172">next</a><span>|</span><label class="collapse" for="c-36388091">[-]</label><label class="expand" for="c-36388091">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of Nix documentation I’ve found says things like, “Simply add these lines!”<p>&gt; Huh?<p>&gt; Which file? And where in the file do I add those lines?<p>This issue is prevalent <i>everywhere</i>. Even the best documented projects fail into this trap almost immediately.</div><br/><div id="36388116" class="c"><input type="checkbox" id="c-36388116" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#36388091">parent</a><span>|</span><a href="#36388172">next</a><span>|</span><label class="collapse" for="c-36388116">[-]</label><label class="expand" for="c-36388116">[1 more]</label></div><br/><div class="children"><div class="content">And why, what do those lines mean</div><br/></div></div></div></div><div id="36388172" class="c"><input type="checkbox" id="c-36388172" checked=""/><div class="controls bullet"><span class="by">wesapien</span><span>|</span><a href="#36388091">prev</a><span>|</span><a href="#36388293">next</a><span>|</span><label class="collapse" for="c-36388172">[-]</label><label class="expand" for="c-36388172">[4 more]</label></div><br/><div class="children"><div class="content">Does anyone have any ideas on what the most likely outcome would be for NixOS losing the S3 bucket funding?</div><br/><div id="36388277" class="c"><input type="checkbox" id="c-36388277" checked=""/><div class="controls bullet"><span class="by">throwawayqqq11</span><span>|</span><a href="#36388172">parent</a><span>|</span><a href="#36388235">next</a><span>|</span><label class="collapse" for="c-36388277">[-]</label><label class="expand" for="c-36388277">[1 more]</label></div><br/><div class="children"><div class="content">You propably have to pull all your sources from github and compile them yourself once, since there is no remote store that provides prebuild artifacts? (I dont know what use the S3 bucket&#x2F;s is for.)</div><br/></div></div><div id="36388235" class="c"><input type="checkbox" id="c-36388235" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#36388172">parent</a><span>|</span><a href="#36388277">prev</a><span>|</span><a href="#36388232">next</a><span>|</span><label class="collapse" for="c-36388235">[-]</label><label class="expand" for="c-36388235">[1 more]</label></div><br/><div class="children"><div class="content">IMO, one of the budget storage companies (Backblaze, Storj, etc) and&#x2F;or a CDN stepping up to support it out of their marketing budget.</div><br/></div></div><div id="36388232" class="c"><input type="checkbox" id="c-36388232" checked=""/><div class="controls bullet"><span class="by">seqizz</span><span>|</span><a href="#36388172">parent</a><span>|</span><a href="#36388235">prev</a><span>|</span><a href="#36388293">next</a><span>|</span><label class="collapse" for="c-36388232">[-]</label><label class="expand" for="c-36388232">[1 more]</label></div><br/><div class="children"><div class="content">As far as I remember there was enough money to keep them alive on current setting about a year. Worst case they&#x27;ll switch to an alternative provider which _might_ be a bit slower?</div><br/></div></div></div></div><div id="36388293" class="c"><input type="checkbox" id="c-36388293" checked=""/><div class="controls bullet"><span class="by">arminluschin</span><span>|</span><a href="#36388172">prev</a><span>|</span><a href="#36387927">next</a><span>|</span><label class="collapse" for="c-36388293">[-]</label><label class="expand" for="c-36388293">[1 more]</label></div><br/><div class="children"><div class="content">I love how this is written. Very relatable, very approachable.</div><br/></div></div><div id="36387927" class="c"><input type="checkbox" id="c-36387927" checked=""/><div class="controls bullet"><span class="by">seungwoolee518</span><span>|</span><a href="#36388293">prev</a><span>|</span><a href="#36388108">next</a><span>|</span><label class="collapse" for="c-36387927">[-]</label><label class="expand" for="c-36387927">[2 more]</label></div><br/><div class="children"><div class="content">Seems like link is dead.</div><br/><div id="36388011" class="c"><input type="checkbox" id="c-36388011" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#36387927">parent</a><span>|</span><a href="#36388108">next</a><span>|</span><label class="collapse" for="c-36388011">[-]</label><label class="expand" for="c-36388011">[1 more]</label></div><br/><div class="children"><div class="content">seems to work just fine here.</div><br/></div></div></div></div><div id="36388108" class="c"><input type="checkbox" id="c-36388108" checked=""/><div class="controls bullet"><span class="by">nittanymount</span><span>|</span><a href="#36387927">prev</a><span>|</span><a href="#36388237">next</a><span>|</span><label class="collapse" for="c-36388108">[-]</label><label class="expand" for="c-36388108">[5 more]</label></div><br/><div class="children"><div class="content">planning to learn&#x2F;use ansible, 
wonder if Nix is ready to use ? have most functions&#x2F;features ?</div><br/><div id="36388165" class="c"><input type="checkbox" id="c-36388165" checked=""/><div class="controls bullet"><span class="by">throwaway6835-8</span><span>|</span><a href="#36388108">parent</a><span>|</span><a href="#36388283">next</a><span>|</span><label class="collapse" for="c-36388165">[-]</label><label class="expand" for="c-36388165">[1 more]</label></div><br/><div class="children"><div class="content">Go with Ansible unless you want to fully dedicate into Nix ecosystem and spend a lot of time learning it (and it&#x27;s not easy, for example because of lacking documentation). Also Ansible is something you more often find in actual projects&#x2F;workplace.</div><br/></div></div><div id="36388283" class="c"><input type="checkbox" id="c-36388283" checked=""/><div class="controls bullet"><span class="by">mindwok</span><span>|</span><a href="#36388108">parent</a><span>|</span><a href="#36388165">prev</a><span>|</span><a href="#36388157">next</a><span>|</span><label class="collapse" for="c-36388283">[-]</label><label class="expand" for="c-36388283">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re planning on using Ansible for your job or to administer Linux systems, then stick with Ansible. Nix is very niche and you aren&#x27;t going to see much return on investment until adoption is significantly higher, and I&#x27;m not sure that will happen in its current state.<p>That being said if you want to learn Nix for its own sake or because it is awesome, which it is, then have fun!</div><br/></div></div><div id="36388157" class="c"><input type="checkbox" id="c-36388157" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36388108">parent</a><span>|</span><a href="#36388283">prev</a><span>|</span><a href="#36388153">next</a><span>|</span><label class="collapse" for="c-36388157">[-]</label><label class="expand" for="c-36388157">[1 more]</label></div><br/><div class="children"><div class="content">If you can adopt NixOS, then it&#x27;s worth considering. But if you have to use a standard distro then Nix on its own won&#x27;t solve your configuration-management problems.<p>To sum it up succinctly, I would say that Nix helps you manage $PATH while NixOS helps you manage &#x2F;etc.</div><br/></div></div><div id="36388153" class="c"><input type="checkbox" id="c-36388153" checked=""/><div class="controls bullet"><span class="by">SkyMarshal</span><span>|</span><a href="#36388108">parent</a><span>|</span><a href="#36388157">prev</a><span>|</span><a href="#36388237">next</a><span>|</span><label class="collapse" for="c-36388153">[-]</label><label class="expand" for="c-36388153">[1 more]</label></div><br/><div class="children"><div class="content">Try it out in a VM and see for yourself.</div><br/></div></div></div></div><div id="36388237" class="c"><input type="checkbox" id="c-36388237" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36388108">prev</a><span>|</span><a href="#36388195">next</a><span>|</span><label class="collapse" for="c-36388237">[-]</label><label class="expand" for="c-36388237">[2 more]</label></div><br/><div class="children"><div class="content">I have shell script with bunch of common functions to simplify particular tasks and then main script that when ran  installs all needed packages, creates &#x2F; copies various config files, pulls my C++ code from repo and builds my servers and installs those as daemons. It also installs cron jobs that execute backups &#x2F; replication. It is smart enough to skip already performed steps and can safely run multiple times. It can run on Debian, Ubuntu, Arch and Mint.<p>It is fast and reliable and can deploy new infra and or restore state of that from backup. I use it for years without any problems.</div><br/><div id="36388296" class="c"><input type="checkbox" id="c-36388296" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#36388237">parent</a><span>|</span><a href="#36388195">next</a><span>|</span><label class="collapse" for="c-36388296">[-]</label><label class="expand" for="c-36388296">[1 more]</label></div><br/><div class="children"><div class="content">That is awesome and I&#x27;m glad it works for you. Nix does a lot of other things as well, and also has a large package repo and community around it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>