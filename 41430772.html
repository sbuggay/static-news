<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725440450794" as="style"/><link rel="stylesheet" href="styles.css?v=1725440450794"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://morizbuesing.com/blog/greppability-code-metric/">Greppability is an underrated code metric</a> <span class="domain">(<a href="https://morizbuesing.com">morizbuesing.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>420 comments</span></div><br/><div><div id="41431701" class="c"><input type="checkbox" id="c-41431701" checked=""/><div class="controls bullet"><span class="by">lucumo</span><span>|</span><a href="#41432955">next</a><span>|</span><label class="collapse" for="c-41431701">[-]</label><label class="expand" for="c-41431701">[104 more]</label></div><br/><div class="children"><div class="content">Grepping for symbols like function names and class names feels so anemic compared to using a tool that has a syntactic understanding of the code. Just &quot;go to definition&quot; and &quot;find usages&quot; alone reduce the need for text search enormously.<p>For the past decade-plus I have mostly only searched for user facing strings. Those have the advantage of being longer, so are more easily searched.<p>Honestly, posts like this sound like the author needs to invest some time in learning about better tools for his language. A good IDE  alone will save you so much time.</div><br/><div id="41432569" class="c"><input type="checkbox" id="c-41432569" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432945">next</a><span>|</span><label class="collapse" for="c-41432569">[-]</label><label class="expand" for="c-41432569">[35 more]</label></div><br/><div class="children"><div class="content">Scenarios where an IDE with full syntactic understanding is better:<p>- It&#x27;s your day to day project and you expect to be working in it for a long time.<p>Scenarios where grepping is more useful:<p>- Your language has #ifdef or equivalent syntax which does conditional compilation making syntactic tools incomplete.<p>- You just opened the project for the first time.<p>- It&#x27;s in a language you don&#x27;t daily drive (you write backend but have to delve in frontend code, it&#x27;s a 3rd party library, it&#x27;s configuration files, random json&#x2F;xml files or data)<p>- You&#x27;re editing or searching through documentation.<p>- You haven&#x27;t even downloaded the project and are checking things out in github (or some similar site for your project).<p>- You&#x27;re providing remote assistance to someone and you are not at your main development machine.<p>- You&#x27;re remoting via SSH and have access to code there (say it&#x27;s a python server).<p>Yes, an IDE will save you time daily driving. But there&#x27;s no reason to sabotage all the other usecases.</div><br/><div id="41432760" class="c"><input type="checkbox" id="c-41432760" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41434870">next</a><span>|</span><label class="collapse" for="c-41432760">[-]</label><label class="expand" for="c-41432760">[1 more]</label></div><br/><div class="children"><div class="content">Further important (to me) scenarios that also argue for greppability:<p>- greppability does not preclude IDE or language server tooling; there&#x27;s often special cases where only certain e.g. context-dependant usages matter, and sometimes grep is the easiest way to find those.<p>- projects that include multiple languages, such as for instance the fairly common setup of HTML, JS, CSS, SQL, and some server-side language.<p>- performance in scenarios with huge amounts of code, or where you&#x27;re searching very often (e.g. in each git commit for some amount of history)<p>- ease of use across repositories (e.g. a client app, a spec, and a server app in separate repos).<p>I treat greppability as an almost universal default.  I&#x27;d much rather have code in a &quot;weird&quot; naming style in some language but have consistent identifiers across languages, than have normal-style-guide default identifiers in each language, but differing identifiers across languages. If code &quot;looks weird&quot;, if anything that&#x27;s often actually a _benefit_ in such cases, not a downside - most serialization libraries I use for this kind of stuff tend to do a lot of automagic mapping that can break in ways that are sometimes hard to detect at compile time if somebody renames something, or sometimes even just for a casing change or type change. Having a hint as to this fragility immediate at a glance even in dynamically typed languages is sometimes a nice side-effect. Very speculatively, I wouldn&#x27;t be surprised if AI coding tools can deal with consistent names better than context-dependent ones too; greppability is likely not specifically about merely the tool grep.<p>And the best part is that there&#x27;s almost no downside; it&#x27;s not like you need to pick either a language server, IDE or grep - just use whatever is most convenient for each task.</div><br/></div></div><div id="41434870" class="c"><input type="checkbox" id="c-41434870" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41432760">prev</a><span>|</span><a href="#41432658">next</a><span>|</span><label class="collapse" for="c-41434870">[-]</label><label class="expand" for="c-41434870">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s your day to day project and you expect to be working in it for a long time.<p>I don&#x27;t think we need to restrict the benefits quite that much—if it&#x27;s a project that <i>isn&#x27;t</i> my day-to-day but is in a language I already have set up in my IDE, I&#x27;d much prefer to open it up in my IDE and use jump to definition and friends than to try to grep and hope that the developers made it grepable.<p>Going further, I&#x27;d equally rather have plugins ready to go for every language my company works in and use them for exploring a foreign codebase. The navigation tools all work more or less the same, so it&#x27;s not like I need to invest effort learning a new tool in order to benefit from navigation.<p>&gt; Yes, an IDE will save you time daily driving. But there&#x27;s no reason to sabotage all the other usecases.<p>Certainly don&#x27;t sabotage, but some of these suggestions are bad for other reasons that aren&#x27;t about grep.<p>For example: breaking the naming conventions of your language in order to avoid remapping is questionable at best. Operating like that binds your business logic way too tightly to the database representation, and while &quot;just return the db object&quot; sounds like a good  optimization in theory, I&#x27;ve never not regretted having frontend code that assumes it&#x27;s operating directly on database objects.</div><br/><div id="41438517" class="c"><input type="checkbox" id="c-41438517" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434870">parent</a><span>|</span><a href="#41441258">next</a><span>|</span><label class="collapse" for="c-41438517">[-]</label><label class="expand" for="c-41438517">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>if it&#x27;s a project that</i> isn&#x27;t <i>my day-to-day but is in a language I already have set up in my IDE, I&#x27;d much prefer to open it up in my IDE and use jump to definition and friends than to try to grep and hope that the developers made it grepable.</i><p>It&#x27;s funny, because my preference and actual use is the exact opposite: for a project that isn&#x27;t my day-to-day, I&#x27;m <i>much</i> more likely to try to grep through it rather than open it in an IDE.</div><br/></div></div><div id="41441258" class="c"><input type="checkbox" id="c-41441258" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434870">parent</a><span>|</span><a href="#41438517">prev</a><span>|</span><a href="#41432658">next</a><span>|</span><label class="collapse" for="c-41441258">[-]</label><label class="expand" for="c-41441258">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if it&#x27;s a project that isn&#x27;t my day-to-day<p>Another overlooked advantage of greppability is to be able to fuzzy the search, or discover related code that wasn&#x27;t directly linked to what you were looking for.<p>For instance if you were hunting for the method updating a `foo_bar` instance, grepping it will also give you instances of `generic_foo_bar` and `shim_foo_bar`. It can be noise, as it can be stuff you wouldn&#x27;t have seen otherwise and save your bacon. If you&#x27;re not familiar with a project I think it&#x27;s quite an advantage.<p>&gt; hope that the developers made it grepable<p>hopefully it&#x27;s enforced at an organization level.</div><br/></div></div></div></div><div id="41432658" class="c"><input type="checkbox" id="c-41432658" checked=""/><div class="controls bullet"><span class="by">popinman322</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41434870">prev</a><span>|</span><a href="#41434122">next</a><span>|</span><label class="collapse" for="c-41432658">[-]</label><label class="expand" for="c-41432658">[5 more]</label></div><br/><div class="children"><div class="content">Grep is also useful when IDE indexing isn&#x27;t feasible for the entire project. At past employers I worked in monorepos where the sheer size of the index caused multiple seconds of delay in intellisense and UI stuttering; our devex team&#x27;s preferred approach was to better integrate our IDE experience with the build system such that only symbols in scope of the module you were working on would be loaded. This was usually fine, and it works especially well for product teams, but it&#x27;s a headache when you&#x27;re doing cross-cutting work (e.g. for infrastructure projects&#x2F;overhauls).<p>We also had a livegrep instance that we could use to grep any corporate repo, regardless of where it was hosted. That was extremely useful for investigating failures in build scripts that spanned multiple repositories (e.g. building a Go sidecar that relies on a service config in the Java monorepo).</div><br/><div id="41434386" class="c"><input type="checkbox" id="c-41434386" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432658">parent</a><span>|</span><a href="#41434308">prev</a><span>|</span><a href="#41434122">next</a><span>|</span><label class="collapse" for="c-41434386">[-]</label><label class="expand" for="c-41434386">[3 more]</label></div><br/><div class="children"><div class="content">If running into this, make sure to enable 64-bit intellisense and increase the ram limit, by default it is 4gb.</div><br/><div id="41438293" class="c"><input type="checkbox" id="c-41438293" checked=""/><div class="controls bullet"><span class="by">Cieric</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434386">parent</a><span>|</span><a href="#41434122">next</a><span>|</span><label class="collapse" for="c-41438293">[-]</label><label class="expand" for="c-41438293">[2 more]</label></div><br/><div class="children"><div class="content">As someone who runs into that daily, I&#x27;m surprised I never heard of this before.<p>I seem to have found the 64-bit mode under &quot;Tools &gt; Options&quot; then &quot;Text Editor &gt; C&#x2F;C++ &gt; IntelliSense&quot;. The top option is [] Enable 64-bit IntelliSense.<p>But I can&#x27;t seem to find the ram limit you mentioned and searching for it just keeps bringing up stuff related to vscode. Do you know where it is off the top of your head or a page that might describe it?</div><br/><div id="41440120" class="c"><input type="checkbox" id="c-41440120" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438293">parent</a><span>|</span><a href="#41434122">next</a><span>|</span><label class="collapse" for="c-41440120">[-]</label><label class="expand" for="c-41440120">[1 more]</label></div><br/><div class="children"><div class="content">The RAM limit <i>is</i> 32 bit Intellisense. 2^32 is 4GiB.<p>Edit: I take that back, this was a first-principles comment. There&#x27;s a setting &#x27;C_Cpp: Intelli Sense Memory Limit&#x27; (space included).</div><br/></div></div></div></div></div></div></div></div><div id="41434122" class="c"><input type="checkbox" id="c-41434122" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41432658">prev</a><span>|</span><a href="#41434173">next</a><span>|</span><label class="collapse" for="c-41434122">[-]</label><label class="expand" for="c-41434122">[13 more]</label></div><br/><div class="children"><div class="content">- You&#x27;re fully aware that it would be better to be able to use tooling for $THING, but tooling doesn&#x27;t exist yet or is immature.</div><br/><div id="41434891" class="c"><input type="checkbox" id="c-41434891" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434122">parent</a><span>|</span><a href="#41434173">next</a><span>|</span><label class="collapse" for="c-41434891">[-]</label><label class="expand" for="c-41434891">[12 more]</label></div><br/><div class="children"><div class="content">you would not believe the amount of time i spent pretty-printing python dicts by hand last week</div><br/><div id="41435108" class="c"><input type="checkbox" id="c-41435108" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434891">parent</a><span>|</span><a href="#41434173">next</a><span>|</span><label class="collapse" for="c-41435108">[-]</label><label class="expand" for="c-41435108">[11 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;pprint.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;pprint.html</a></div><br/><div id="41435123" class="c"><input type="checkbox" id="c-41435123" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435108">parent</a><span>|</span><a href="#41434173">next</a><span>|</span><label class="collapse" for="c-41435123">[-]</label><label class="expand" for="c-41435123">[10 more]</label></div><br/><div class="children"><div class="content">yeah, pprint is why i was doing it by hand ;)</div><br/><div id="41435815" class="c"><input type="checkbox" id="c-41435815" checked=""/><div class="controls bullet"><span class="by">lkbm</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435123">parent</a><span>|</span><a href="#41438442">next</a><span>|</span><label class="collapse" for="c-41435815">[-]</label><label class="expand" for="c-41435815">[8 more]</label></div><br/><div class="children"><div class="content">I used to pipe things through black for that. (a script that imported black, not just black on the command line.)<p>I also had `j2p` and `p2j` that would convert between python (formatted via black) and json (formatted via jq), and the  `j2p_clip`&#x2F;`p2j_clip` versions that would pipe from clipboard and back into clipboards.<p>It&#x27;s worth taking the time to build a few simple scripts for things you do a lot. I used to open up the repl and import json to convert between json and python dicts multiple times a day, so spending a few minutes throwing together a simple script to do it was well worth the effort.</div><br/><div id="41438184" class="c"><input type="checkbox" id="c-41438184" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435815">parent</a><span>|</span><a href="#41438442">next</a><span>|</span><label class="collapse" for="c-41438184">[-]</label><label class="expand" for="c-41438184">[7 more]</label></div><br/><div class="children"><div class="content">part of what i ended up with was this:<p><pre><code>    {&#x27;country&#x27;: [&#x27;25&#x27;, &#x27;32&#x27;, &#x27;6&#x27;, &#x27;37&#x27;, &#x27;72&#x27;, &#x27;22&#x27;, &#x27;17&#x27;, &#x27;39&#x27;, &#x27;14&#x27;, &#x27;10&#x27;,
                 &#x27;35&#x27;, &#x27;43&#x27;, &#x27;56&#x27;, &#x27;36&#x27;, &#x27;110&#x27;, &#x27;11&#x27;, &#x27;26&#x27;, &#x27;12&#x27;, &#x27;4&#x27;, &#x27;5&#x27;],
     &#x27;timeZone&#x27;: &#x27;8&#x27;, &#x27;dateFrom&#x27;: &#x27;2024-05-01&#x27;, &#x27;dateTo&#x27;: &#x27;2024-05-30&#x27;,
</code></pre>
black is the opposite extreme from what i wanted; <a href="https:&#x2F;&#x2F;black.readthedocs.io&#x2F;en&#x2F;stable&#x2F;the_black_code_style&#x2F;current_style.html#pragmatism" rel="nofollow">https:&#x2F;&#x2F;black.readthedocs.io&#x2F;en&#x2F;stable&#x2F;the_black_code_style&#x2F;...</a> explains:<p>&gt; <i>If a data structure literal (tuple, list, set, dict) or a line of “from” imports cannot fit in the allotted length, it’s always split into one element per line.</i><p>i&#x27;m not interested in minimizing diffs.  i&#x27;m interested in being able to see all the fields of one record on one screen—moreover, i&#x27;d like to be able to see more than one record at a time so i can compare what&#x27;s the same and what&#x27;s different<p>black seems to be designed for the kind of person who always eats at mcdonald&#x27;s when they travel because they value predictability over quality</div><br/><div id="41438497" class="c"><input type="checkbox" id="c-41438497" checked=""/><div class="controls bullet"><span class="by">pushfoo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438184">parent</a><span>|</span><a href="#41439679">next</a><span>|</span><label class="collapse" for="c-41438497">[-]</label><label class="expand" for="c-41438497">[4 more]</label></div><br/><div class="children"><div class="content">My understanding of black is that it solves bikeshedding by making everyone a little unhappy.<p>For aligned column readability and other scenarios, <i># fmt: off</i> and <i># fmt: on</i> become crucial. The problem is that like <i># type: ignore</i>, those start spreading if you&#x27;re not careful.</div><br/><div id="41440395" class="c"><input type="checkbox" id="c-41440395" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438497">parent</a><span>|</span><a href="#41438653">next</a><span>|</span><label class="collapse" for="c-41440395">[-]</label><label class="expand" for="c-41440395">[2 more]</label></div><br/><div class="children"><div class="content">My only complaint with black is that it only splits long definitions into per-line if they exceed a limit. That’s probably configurable, now that I write it down.<p>Other than that, I actually quite like its formatting choices.</div><br/><div id="41441030" class="c"><input type="checkbox" id="c-41441030" checked=""/><div class="controls bullet"><span class="by">pushfoo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41440395">parent</a><span>|</span><a href="#41438653">next</a><span>|</span><label class="collapse" for="c-41441030">[-]</label><label class="expand" for="c-41441030">[1 more]</label></div><br/><div class="children"><div class="content">Line length is definitely configurable. All it takes is adding the following on pyproject.toml[1]:<p><pre><code>  [tool.black]
  line-length = 100
</code></pre>
Aside from matrix-like or column aligned data, the only truly awful thing I&#x27;ve encountered has been broken f-string handling[2].<p>[1]: Example from <a href="https:&#x2F;&#x2F;github.com&#x2F;pythonarcade&#x2F;arcade&#x2F;blob&#x2F;808e1dafcf1da30f52e1daea858c32cad92e97d5&#x2F;pyproject.toml#L177-L188">https:&#x2F;&#x2F;github.com&#x2F;pythonarcade&#x2F;arcade&#x2F;blob&#x2F;808e1dafcf1da30f...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;psf&#x2F;black&#x2F;issues&#x2F;4389">https:&#x2F;&#x2F;github.com&#x2F;psf&#x2F;black&#x2F;issues&#x2F;4389</a></div><br/></div></div></div></div><div id="41438653" class="c"><input type="checkbox" id="c-41438653" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438497">parent</a><span>|</span><a href="#41440395">prev</a><span>|</span><a href="#41439679">next</a><span>|</span><label class="collapse" for="c-41438653">[-]</label><label class="expand" for="c-41438653">[1 more]</label></div><br/><div class="children"><div class="content">yeah; unless your coworkers are hindu, you can solve &#x27;bikeshedding&#x27; about which restaurant to go to by going to mcdonald&#x27;s, too</div><br/></div></div></div></div><div id="41439679" class="c"><input type="checkbox" id="c-41439679" checked=""/><div class="controls bullet"><span class="by">lkbm</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438184">parent</a><span>|</span><a href="#41438497">prev</a><span>|</span><a href="#41438442">next</a><span>|</span><label class="collapse" for="c-41439679">[-]</label><label class="expand" for="c-41439679">[2 more]</label></div><br/><div class="children"><div class="content">Fair. I spent some time trying to figure out how to make it do roughly that before giving up.</div><br/><div id="41440352" class="c"><input type="checkbox" id="c-41440352" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41439679">parent</a><span>|</span><a href="#41438442">next</a><span>|</span><label class="collapse" for="c-41440352">[-]</label><label class="expand" for="c-41440352">[1 more]</label></div><br/><div class="children"><div class="content">i kind of get the vibe from the black documentation that it&#x27;s written by the kind of person who thinks we&#x27;re bad people for wanting that, and perhaps that everyone should wear the same uniform because vanity is sinful and aesthetics are frivolous</div><br/></div></div></div></div></div></div></div></div><div id="41438442" class="c"><input type="checkbox" id="c-41438442" checked=""/><div class="controls bullet"><span class="by">pushfoo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435123">parent</a><span>|</span><a href="#41435815">prev</a><span>|</span><a href="#41434173">next</a><span>|</span><label class="collapse" for="c-41438442">[-]</label><label class="expand" for="c-41438442">[1 more]</label></div><br/><div class="children"><div class="content">we keep having similar problems, lol.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41434173" class="c"><input type="checkbox" id="c-41434173" checked=""/><div class="controls bullet"><span class="by">jollyllama</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41434122">prev</a><span>|</span><a href="#41435030">next</a><span>|</span><label class="collapse" for="c-41434173">[-]</label><label class="expand" for="c-41434173">[2 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s your day to day project and you expect to be working in it for a long time.<p>Bold of everyone here to assume that everyone has a day to day project. If you&#x27;re a consultant or for other reasons you&#x27;re switching projects on a month to month basis, greppability is probably the top metric second to UT coverage.</div><br/><div id="41436489" class="c"><input type="checkbox" id="c-41436489" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434173">parent</a><span>|</span><a href="#41435030">next</a><span>|</span><label class="collapse" for="c-41436489">[-]</label><label class="expand" for="c-41436489">[1 more]</label></div><br/><div class="children"><div class="content">They said the scenario in which that would be useful was IF: &quot;It&#x27;s your day to day project and you expect to be working in it for a long time&quot;. The implication being that if neither of those hold then skip to the next section.<p>I don&#x27;t think anyone is assuming anything here. I&#x27;ve contracted for most of my career and this didn&#x27;t seem like an outlandish statement.<p>Also, if you&#x27;re working in a project for a month, odds are you could set up an IDE in the first few hours. Not sure how any of this rises to the level of being 
&quot;bold&quot;.</div><br/></div></div></div></div><div id="41435030" class="c"><input type="checkbox" id="c-41435030" checked=""/><div class="controls bullet"><span class="by">joe-six-pack</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41434173">prev</a><span>|</span><a href="#41436382">next</a><span>|</span><label class="collapse" for="c-41435030">[-]</label><label class="expand" for="c-41435030">[5 more]</label></div><br/><div class="children"><div class="content">You forgot massive codebases. Language servers really struggle with anything on the order of the Linux kernel, FreeBSD, or Chromium.</div><br/><div id="41437494" class="c"><input type="checkbox" id="c-41437494" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435030">parent</a><span>|</span><a href="#41436398">next</a><span>|</span><label class="collapse" for="c-41437494">[-]</label><label class="expand" for="c-41437494">[3 more]</label></div><br/><div class="children"><div class="content">I honestly suspect that the amount of time spent dealing with the issues monorepos cause is net-larger than the gains most get from what a monorepo offers.  It&#x27;s just harder to measure because it tends to degrade slowly, happen to things you didn&#x27;t realize you were relying on (until you need them), and without clear ways to point fingers at the cause.<p>Plus it means your engs don&#x27;t learn how to deal with open source code concerns, e.g. libraries, forking, dependency management.  Which gradually screws over the whole ecosystem.<p>If you&#x27;re willing to put Google-scale effort into building your tooling, sure.  Every problem is solvable.  Only Google does that though, everyone else is getting by with a tiny fraction of the resources <i>and</i> doesn&#x27;t already have a solid foundation to reduce those maintenance costs.</div><br/><div id="41438245" class="c"><input type="checkbox" id="c-41438245" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41437494">parent</a><span>|</span><a href="#41436398">next</a><span>|</span><label class="collapse" for="c-41438245">[-]</label><label class="expand" for="c-41438245">[2 more]</label></div><br/><div class="children"><div class="content">The projects mentioned were all single projects with single repos</div><br/><div id="41440843" class="c"><input type="checkbox" id="c-41440843" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438245">parent</a><span>|</span><a href="#41436398">next</a><span>|</span><label class="collapse" for="c-41440843">[-]</label><label class="expand" for="c-41440843">[1 more]</label></div><br/><div class="children"><div class="content">Sure.  But those are far from the only massive codebases out there, and many of the biggest are monorepos because sorta by definition they are the size of <i>multiple</i> projects.</div><br/></div></div></div></div></div></div><div id="41436398" class="c"><input type="checkbox" id="c-41436398" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435030">parent</a><span>|</span><a href="#41437494">prev</a><span>|</span><a href="#41436382">next</a><span>|</span><label class="collapse" for="c-41436398">[-]</label><label class="expand" for="c-41436398">[1 more]</label></div><br/><div class="children"><div class="content">clangd works fine for me with the linux kernel. For best results build the kernel with clang by setting LLVM=1 and KERNEL_LLVM=1 in the build environment and run .&#x2F;scripts&#x2F;clang-tools&#x2F;gen_compile_commands.py after building.</div><br/></div></div></div></div><div id="41436382" class="c"><input type="checkbox" id="c-41436382" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41435030">prev</a><span>|</span><a href="#41439646">next</a><span>|</span><label class="collapse" for="c-41436382">[-]</label><label class="expand" for="c-41436382">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Your language has #ifdef or equivalent syntax which does conditional compilation making syntactic tools incomplete.<p>Your other points make sense, but in this case, at least for C&#x2F;C++, you can generate a compile_commands.json that will let clangd interpret your code accurately.<p>If building with make just do `bear -- make` instead of `make`. If building with cmake pass `-DCMAKE_EXPORT_COMPILE_COMMANDS=1`.</div><br/><div id="41436890" class="c"><input type="checkbox" id="c-41436890" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41436382">parent</a><span>|</span><a href="#41439646">next</a><span>|</span><label class="collapse" for="c-41436890">[-]</label><label class="expand" for="c-41436890">[2 more]</label></div><br/><div class="children"><div class="content">Does it evaluate macros?
Because macros allow for arbitrary computation.</div><br/><div id="41437564" class="c"><input type="checkbox" id="c-41437564" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41436890">parent</a><span>|</span><a href="#41439646">next</a><span>|</span><label class="collapse" for="c-41437564">[-]</label><label class="expand" for="c-41437564">[1 more]</label></div><br/><div class="children"><div class="content">The macros I see in the real world seem to usually work fine. I’m sure it’s not perfect and you can construct a macro that would confuse it, but it’s a lot better than not having a compilation db at all.</div><br/></div></div></div></div></div></div><div id="41439646" class="c"><input type="checkbox" id="c-41439646" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41436382">prev</a><span>|</span><a href="#41435016">next</a><span>|</span><label class="collapse" for="c-41439646">[-]</label><label class="expand" for="c-41439646">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Go to definition&quot; often doesn&#x27;t work in dynamic languages like Python without type hints; it might not work when the code is dynamically generated.</div><br/></div></div><div id="41435016" class="c"><input type="checkbox" id="c-41435016" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41439646">prev</a><span>|</span><a href="#41432945">next</a><span>|</span><label class="collapse" for="c-41435016">[-]</label><label class="expand" for="c-41435016">[1 more]</label></div><br/><div class="children"><div class="content">- you just switched branch&#x2F;rebased and the index is not up to date.<p>- the project is large enough that the IDE can&#x27;t cope.<p>- you want to also match comments, commented out code or in-project documentation<p>- you want fuzzy search and match similarly named functions<p>I use clangd integration in my IDE all the time, but often brute force is the right solution.</div><br/></div></div></div></div><div id="41432945" class="c"><input type="checkbox" id="c-41432945" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432569">prev</a><span>|</span><a href="#41431810">next</a><span>|</span><label class="collapse" for="c-41432945">[-]</label><label class="expand" for="c-41432945">[30 more]</label></div><br/><div class="children"><div class="content">I abandoned VSCode and went back to vim + ctags + ripgrep after a year with the most popular IDE. I miss some features but it didn’t give me a 10x or even 1.5x improvement in my own work along any dimension.<p>I attribute that mostly to my several decades of experience with vi(m) and command line tools, not to anything inherently bad about VSCode.<p>What counts as “better” tools has a lot of subjectivity and circumstances implied. No one set of tools works for everyone. I very often have to work over ssh on servers that don’t allow installing anything, much less Node and npm for VSCode, so I invest my time in the tools that always work everywhere, for the work I do.<p>The main project I’ve worked on for the last few years has a little less than 500,000 lines of code. VSCode’s LSP takes a few seconds fairly often to maintain the LSP indexes. Running ctags over the same code takes about a second and I can control when that happens. vim has no delays at all, and ripgrep can search all of the files in a second or two.</div><br/><div id="41438557" class="c"><input type="checkbox" id="c-41438557" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432945">parent</a><span>|</span><a href="#41433130">next</a><span>|</span><label class="collapse" for="c-41438557">[-]</label><label class="expand" for="c-41438557">[1 more]</label></div><br/><div class="children"><div class="content">I have similar feelings... I still use IntelliJ IDEA for JVM languages, but for C, Rust, Go, Python, etc., I&#x27;ve been using vim for years (decades?), and that&#x27;s just how I prefer to write code in those languages.  I do have LSP plugins installed in vim for the languages I work in, and do have a key sequence mapped for jump-to-definition... but I still find myself (rip)grepping through the source at least as often as I j-t-d, maybe more often.</div><br/></div></div><div id="41433130" class="c"><input type="checkbox" id="c-41433130" checked=""/><div class="controls bullet"><span class="by">wrasee</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432945">parent</a><span>|</span><a href="#41438557">prev</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41433130">[-]</label><label class="expand" for="c-41433130">[21 more]</label></div><br/><div class="children"><div class="content">Did you consider Neovim?  You get the benefit of vim while also being able to mix in as much LSP tooling as you like.  The tradeoff is that it takes some time to set up, although that is getting easier.<p>That won’t make LSP go any faster though.  There’s still something interesting in the fact that a ripgrep of every line in the codebase can still be faster than a dedicated tool.</div><br/><div id="41433197" class="c"><input type="checkbox" id="c-41433197" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41433130">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41433197">[-]</label><label class="expand" for="c-41433197">[14 more]</label></div><br/><div class="children"><div class="content">Considered it and have tried repeatedly to get it to work with mixed success. As you wrote, it takes &quot;some time&quot; to set up. In my case it would only offer marginal improvements over plain vim, since I&#x27;m not that interested in the LSP integration (and vim has that too, through a plugin).<p>In the environments I often work in I can&#x27;t install anything or run processes like node. I ssh into a server and have to use whatever came with the Linux distro, which means sticking with the tools I will find everywhere. I can&#x27;t copy the code from the server either. If I get lucky they used version control. I know not everyone works with those constraints. I specialize in working on abandoned and legacy code.</div><br/><div id="41433360" class="c"><input type="checkbox" id="c-41433360" checked=""/><div class="controls bullet"><span class="by">wrasee</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41433197">parent</a><span>|</span><a href="#41434905">next</a><span>|</span><label class="collapse" for="c-41433360">[-]</label><label class="expand" for="c-41433360">[2 more]</label></div><br/><div class="children"><div class="content">Yes ok. And legacy code might be a good example where grep works well, if it&#x27;s fair to argue a greater propensity for things like preprocessors, older languages and custom builds that may not play as well with semantic-level tools, let alone be written with modern tooling in mind.</div><br/><div id="41434886" class="c"><input type="checkbox" id="c-41434886" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41433360">parent</a><span>|</span><a href="#41434905">next</a><span>|</span><label class="collapse" for="c-41434886">[-]</label><label class="expand" for="c-41434886">[1 more]</label></div><br/><div class="children"><div class="content">Lol, I&#x27;m not working with COBOL or Fortran. Legacy code in my world means the original developers have left, not that it dates from the 1970s. Mostly I work with PHP, shell scripts, various flavors of SQL, Python, sometimes Rails or other stuff. All things modern LSPs can handle.</div><br/></div></div></div></div><div id="41434905" class="c"><input type="checkbox" id="c-41434905" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41433197">parent</a><span>|</span><a href="#41433360">prev</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41434905">[-]</label><label class="expand" for="c-41434905">[11 more]</label></div><br/><div class="children"><div class="content">can you not upload executables over ssh, say for policy reasons or disk-space reasons?  how about shell scripts?<p>i mean, i doubt i&#x27;m going to come up with some brilliant breakthrough that makes your life easier that you&#x27;ve somehow overlooked, but i&#x27;d like to understand what kinds of constraints people like you often confront<p>i&#x27;m just glad you don&#x27;t have to use teamviewer</div><br/><div id="41435739" class="c"><input type="checkbox" id="c-41435739" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434905">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41435739">[-]</label><label class="expand" for="c-41435739">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have to use TeamViewer, though I very occasionally have to use Windows RDP.<p>You can transfer any kind of file over ssh. scp, sftp, rsync will all copy binaries. Mainly the issues come down to policy and billable time. Many of my customers simply don&#x27;t allow installing <i>anything</i> on their servers without a tedious approval process. Even if I can install things I might spin my wheels trying to get it to work in an environment I don&#x27;t have root privileges on, with no one willing to help, and I can&#x27;t bill for that time. I don&#x27;t work for free to get an editor installed. I use the tools I know I can find on any Linux&#x2F;BSD server.<p>With some customers I have root privileges and manage the server for them. With others their IT dept has rules I have to follow (I freelance) if I want to keep a good relationship. Since I juggle multiple customers and environments I find it simpler not having to manage different editors and environments, so I mostly stick with the defaults. I do have a .profile and .vimrc I copy around if allowed to, that&#x27;s about it.<p>I can&#x27;t lose time&#x2F;money and possibly goodwill whining about not having everything just-so for me. I recently worked on a server over ssh that didn&#x27;t have tmux installed. Fortunately it did have screen, and I can use that too, no big deal. I spent less than 60 seconds figuring that out and getting to work rather than wasting hours of non-billable time annoying someone about how I needed tmux installed.</div><br/><div id="41435867" class="c"><input type="checkbox" id="c-41435867" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435739">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41435867">[-]</label><label class="expand" for="c-41435867">[9 more]</label></div><br/><div class="children"><div class="content">i see, thanks!<p>wrt rdp, i feel like rdp is actually better than vnc or x11-over-ssh, but for cases where regular ssh works, i&#x27;d rather use ssh<p>i wasn&#x27;t thinking in terms of installing tmux, more like a self-contained binary that doesn&#x27;t require any kind of &#x27;installation&#x27;</div><br/><div id="41435986" class="c"><input type="checkbox" id="c-41435986" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435867">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41435986">[-]</label><label class="expand" for="c-41435986">[8 more]</label></div><br/><div class="children"><div class="content">I used the word &quot;install&quot; but the usual rule says I can&#x27;t install, upload, or execute any non-approved software. Usually that just gets stated as a policy, but I have seen Linux home directories on noexec partitions -- government agencies and big corporations can get very strict about that. So copying a self-contained binary up and running it would violate the policy.<p>I pretty much live in ssh. Remote Desktop means a lot of clicking and watching a GUI visibly repaint. Not efficient. Every so often I have customers using applications that only run on Windows, no API, no command line, so they will enable RDP to that, usually through a VPN.</div><br/><div id="41436285" class="c"><input type="checkbox" id="c-41436285" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435986">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41436285">[-]</label><label class="expand" for="c-41436285">[7 more]</label></div><br/><div class="children"><div class="content">i see!  but i guess your .profile and .vimrc don&#x27;t count?</div><br/><div id="41436574" class="c"><input type="checkbox" id="c-41436574" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41436285">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41436574">[-]</label><label class="expand" for="c-41436574">[6 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t executables.</div><br/><div id="41437761" class="c"><input type="checkbox" id="c-41437761" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41436574">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41437761">[-]</label><label class="expand" for="c-41437761">[5 more]</label></div><br/><div class="children"><div class="content">my cousin wrote a vt52 emulator in bash, and i was looking at a macro assembler written in bash the other day: <a href="https:&#x2F;&#x2F;github.com&#x2F;jhswartz&#x2F;mle-amd64&#x2F;blob&#x2F;master&#x2F;amd64">https:&#x2F;&#x2F;github.com&#x2F;jhswartz&#x2F;mle-amd64&#x2F;blob&#x2F;master&#x2F;amd64</a>. i haven&#x27;t seen a cscope written in bash, but you probably remember how the first versions of ctags were written in sh (or csh?) and ed.  so there&#x27;s not much limit to how far shell functions can go in augmenting your programming environment<p>if awk, python, or perl is accepted, the possibilities expand further</div><br/><div id="41438639" class="c"><input type="checkbox" id="c-41438639" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41437761">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41438639">[-]</label><label class="expand" for="c-41438639">[4 more]</label></div><br/><div class="children"><div class="content">Sure, but this is taking things to a bit of an absurd extreme.  If I worked in a restrictive environment where I couldn&#x27;t install my own tools, I don&#x27;t think I would be in a position to burn a ton of my employer&#x27;s time building sophisticated development tools in bash.<p>(One-off small scripts for things, sure.  But I&#x27;m not going to implement something like ctags or cscope or a LSP server in bash.)</div><br/><div id="41438890" class="c"><input type="checkbox" id="c-41438890" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438639">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41438890">[-]</label><label class="expand" for="c-41438890">[3 more]</label></div><br/><div class="children"><div class="content">certainly it&#x27;s absurd!  nobody would deny that.  on the other hand, the problem to solve is also an absurd problem<p>and i wasn&#x27;t suggesting trying to bill for doing it, but rather, if you were frequently in this situation, it might be reasonable to spend non-billable time between clients doing it</div><br/><div id="41440419" class="c"><input type="checkbox" id="c-41440419" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41438890">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41440419">[-]</label><label class="expand" for="c-41440419">[2 more]</label></div><br/><div class="children"><div class="content">I guess I don’t see the problem as absurd. As a freelancer I need to focus on the problems the customer will pay for. I don’t write code for free or in my spare time anymore, I used to years ago. i feel comfortable working with the constraints imposed, I think of that as a valuable skill, not a handicap.</div><br/><div id="41440621" class="c"><input type="checkbox" id="c-41440621" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41440419">parent</a><span>|</span><a href="#41434073">next</a><span>|</span><label class="collapse" for="c-41440621">[-]</label><label class="expand" for="c-41440621">[1 more]</label></div><br/><div class="children"><div class="content">i see.  thank you very much for being willing to share your invaluable experience and hard-won wisdom</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41434073" class="c"><input type="checkbox" id="c-41434073" checked=""/><div class="controls bullet"><span class="by">VHRanger</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41433130">parent</a><span>|</span><a href="#41433197">prev</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41434073">[-]</label><label class="expand" for="c-41434073">[6 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also helix now, which requires next to no setup, but requires learning new motions (subject is before the verb in helix)</div><br/><div id="41434894" class="c"><input type="checkbox" id="c-41434894" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434073">parent</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41434894">[-]</label><label class="expand" for="c-41434894">[5 more]</label></div><br/><div class="children"><div class="content">I looked at Helix but since I dream in vim motions at this point (vi user since it came out) I&#x27;d have to see a 10x improvement to switch. VSCode didn&#x27;t give me a 10X improvement, I doubt Helix would.</div><br/><div id="41435423" class="c"><input type="checkbox" id="c-41435423" checked=""/><div class="controls bullet"><span class="by">VHRanger</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434894">parent</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41435423">[-]</label><label class="expand" for="c-41435423">[4 more]</label></div><br/><div class="children"><div class="content">Helix certainly won&#x27;t give you a 10x improvement. It tends to convert a lot of people moving &quot;up&quot; from VS Code, and still a decent chunk, but certainly fewer neovim users moving &quot;down&quot;.<p>Advantages of Helix are pretty straightforward:<p>1. Very little configuration bullshit to deal with. There&#x27;s not even a plugin system yet! You just paste your favorite config file and language&#x2F;LSP config file and you&#x27;re good to go. For anything else, submit a pull request.<p>2. Built in LSP support for basically anything an LSP exists for.<p>3. There&#x27;s a bit of a new generation command line IDE forming itself around zellij (tmux that doesn&#x27;t suck) +  helix  + yazi (basically nnn or mc on crack, highly recommended).<p>That whole zellij+helix+yazi environment is frankly a joy to work in, and might be the 2-3x improvement over neovim that makes the switch worth it.</div><br/><div id="41435850" class="c"><input type="checkbox" id="c-41435850" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435423">parent</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41435850">[-]</label><label class="expand" for="c-41435850">[3 more]</label></div><br/><div class="children"><div class="content">Like I wrote, I looked at Helix. Seems cool but not enough for me to switch. And I would have to install it on the machines I work on, which very often I can&#x27;t do because of company policies, or can&#x27;t waste the non-billable time on.<p>I only recently moved from screen to tmux, and I still have to fall back to screen sometimes because tmux doesn&#x27;t come with every Linux distro. I expect I will retire before I think tmux (or screen, for that matter) &quot;sucks&quot; to the point I would look at something else. And again I very often can&#x27;t install things on customer servers anyway.</div><br/><div id="41437333" class="c"><input type="checkbox" id="c-41437333" checked=""/><div class="controls bullet"><span class="by">VHRanger</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435850">parent</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41437333">[-]</label><label class="expand" for="c-41437333">[2 more]</label></div><br/><div class="children"><div class="content">Tmux does suck pretty bad though?<p>It conflicts with the clipboard and a bunch of hotkeys, and configuring it never works because they have breaking change in how their config file works ever 6months or so.<p>These days I only use it to launch a long running job in ssh to detach the session it&#x27;s on and leave.</div><br/><div id="41440441" class="c"><input type="checkbox" id="c-41440441" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41437333">parent</a><span>|</span><a href="#41434977">next</a><span>|</span><label class="collapse" for="c-41440441">[-]</label><label class="expand" for="c-41440441">[1 more]</label></div><br/><div class="children"><div class="content">That’s more or less what I use it for — keeping sessions alive. I don’t use 90% of the features. vim does splits, and there’s ctrl-Z to background it and get a shell.<p>I know I could get more out of tmux but haven’t really needed to. I use it with the default config. I have learned from experience that the less I try to customize my environment the less non-billable time I waste trying to get that working and maintaining it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41434977" class="c"><input type="checkbox" id="c-41434977" checked=""/><div class="controls bullet"><span class="by">joe-six-pack</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432945">parent</a><span>|</span><a href="#41433130">prev</a><span>|</span><a href="#41431810">next</a><span>|</span><label class="collapse" for="c-41434977">[-]</label><label class="expand" for="c-41434977">[7 more]</label></div><br/><div class="children"><div class="content">VSCode is not an IDE, it&#x27;s an extensible text editor. IDEs are <i>integrated</i> (it&#x27;s in the name) and get developed as a whole. I&#x27;m 99% certain that if you were forced to spend a couple of months in a real IDE (like IDEA or Rider), you would not want to go back to vim, or any other text editor. Speaking as a long time user of both.</div><br/><div id="41435657" class="c"><input type="checkbox" id="c-41435657" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434977">parent</a><span>|</span><a href="#41438601">next</a><span>|</span><label class="collapse" for="c-41435657">[-]</label><label class="expand" for="c-41435657">[5 more]</label></div><br/><div class="children"><div class="content">I get your point, but VSCode does far more than text editing. The line between an advanced editor and an IDE gets blurry. If you look at the Wikipedia page about IDEs[1] you see that VSCode ticks off more boxes than not. It has integration with source code control, refactoring, a debugger, etc. With the right combination of extensions it gets really close to an IDE as strictly defined. These days advanced text editor vs. &quot;real&quot; IDE seems more like a distinction without much of a difference.<p>You may feel 99% certain, but you got it wrong. I have quite a bit of experience with IDEs, you shouldn&#x27;t assume I use vim out of ignorance. I have worked as a programmer for 40+ years, with development tools (integrated or not) that I have forgotten the names of. That includes &quot;real&quot; IDEs like Visual Studio, Metrowerks CodeWarrior, Symantec Think C, MPW, Oracle SQL Developer, Turbo Pascal, XCode, etc. and so on. When I started programming every mainframe and minicomputer came with an IDE for the platform. Unix came along with the tools broken out after I had worked for several years. In high school I learned programming on an HP-2000 BASIC minicomputer -- an IDE.<p>So I have spent more than &quot;a couple of months in real IDEs&quot; and I still use vim day to day. If I went back to C++ or C# for Windows I would use Visual Studio, but I don&#x27;t do that anymore. For the kind of work I do <i>now</i> vim + ctags + ripgrep (and awk, sed, bash, etc.) get my work done. At my very first real job I used PWB&#x2F;Unix[2] -- PWB means Programmer&#x27;s Work Bench -- an IDE of sorts. I still use the same tools (on Linux) because they work and I can always count on finding a large subset of them on any server I have to work with.<p>I don&#x27;t dislike or mean to crap on IDEs. I have used my share of IDEs and would again if the work called for that. I get what I need from the tools I&#x27;ve chosen, other people make different choices, no perfect language, editor, IDE, what have you exists.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Integrated_development_environment" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Integrated_development_environ...</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PWB&#x2F;UNIX" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PWB&#x2F;UNIX</a></div><br/><div id="41441862" class="c"><input type="checkbox" id="c-41441862" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41435657">parent</a><span>|</span><a href="#41438601">next</a><span>|</span><label class="collapse" for="c-41441862">[-]</label><label class="expand" for="c-41441862">[4 more]</label></div><br/><div class="children"><div class="content">What IDE existed for the HP 2000? (Where I learned, too. In Portland :)</div><br/><div id="41441962" class="c"><input type="checkbox" id="c-41441962" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41441862">parent</a><span>|</span><a href="#41438601">next</a><span>|</span><label class="collapse" for="c-41441962">[-]</label><label class="expand" for="c-41441962">[3 more]</label></div><br/><div class="children"><div class="content">Me too -- in Portland, Cleveland HS, mid-70s.<p>The HP 2000 [1] had a timeshared BASIC system that the school district made available to schools, over ASR-33 teletypes with dial-up modems. The BASIC system could edit, run (translate to byte code and execute), manage files. No version control or debuggers back then. The HP 2000 had another layer of of the operating system accessible to administrators (the A000 account if I remember right) but it was the same timeshared BASIC system with some additional commands for managing user accounts and files.<p>No one familiar with modern IDEs would recognize the HP 2000 BASIC system as an IDE, but it was self-contained and fully integrated around writing BASIC programs. HP also offered FORTRAN for it but not under the timeshared BASIC system. A friend wrote an assembler (in BASIC!) and taking advantage of a glitch in the bytecode interpreter we could load and run programs written in assembly language.<p>After high school I got a job as night computer operator with the Multnomah County ESD (school district) so I had admin access to the HP 2000, and their two HP 3000 systems, and an IBM computer they used for crunching class registrations. Good times.<p>Someone had an emulator online for a while, accessible over telnet, but I can&#x27;t find it now.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HP_Time-Shared_BASIC" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HP_Time-Shared_BASIC</a></div><br/><div id="41442354" class="c"><input type="checkbox" id="c-41442354" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41441962">parent</a><span>|</span><a href="#41438601">next</a><span>|</span><label class="collapse" for="c-41442354">[-]</label><label class="expand" for="c-41442354">[2 more]</label></div><br/><div class="children"><div class="content">i think it&#x27;s very reasonable to describe time-shared basic systems like that as ides.  the paradigmatic example of an &#x27;ide&#x27; is probably turbo pascal 1.0, and of the features that separated turbo pascal from &#x27;unintegrated&#x27; editor&#x2F;compiler&#x2F;assembler&#x2F;linker&#x2F;debugger setups, i think the dartmouth timesharing system falls mostly on the &#x27;ide&#x27; side of the line.  you could stop your program at any point and inspect its variables, change them, evaluate expressions, <i>change the source code</i>, and continue execution.  runtime errors would also pop you into the interactive basic prompt where you could do all those things.  i believe the hp 2000 timesharing basic had all these features, too</div><br/><div id="41443038" class="c"><input type="checkbox" id="c-41443038" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41442354">parent</a><span>|</span><a href="#41438601">next</a><span>|</span><label class="collapse" for="c-41443038">[-]</label><label class="expand" for="c-41443038">[1 more]</label></div><br/><div class="children"><div class="content">At the time, in the context of other software development environments (like submitting decks of punch cards) the HP 2000 timeshared BASIC environment would count as an IDE. Compared to Turbo Pascal or any modern IDE it falls short.<p>HP TSB did not have a REPL. If your program crashed or stopped you could not examine variables from the terminal. You could not peek or poke memory locations as you could with microcomputer BASICs (which didn&#x27;t support multiple users, so didn&#x27;t have the security concern). You had to insert PRINT statements to debug the code. TSB BASIC didn&#x27;t have compile&#x2F;link steps, it tokenized the code as you entered the lines, and the interpreter amounted to a big switch statements on the tokens. P. J Brown&#x27;s book <i>Writing Interactive Compilers and Interpreters</i> (1981) describes how TSB works. Eventually I got the source code to TSB (written in assembler) and figured it out for myself.<p>Other BASIC implementations that popped up around the same time had richer feature sets. In my senior year at high school I got (unauthorized) access to a couple of Unix systems in Portland, ordered the <i>Bell Labs Technical Journal</i> issues that described Unix and C, and taught myself from those. I didn&#x27;t get paid to work on a Unix system until several years later (detours into RSTS-11, TOPS-20, VMS, Microdata, Pr1me, others) but I caught the Unix and C bugs young and I still work with those tools every day.<p>Some programmer friends and more than a few colleagues over the years have made fun of my continued use of what they call obsolete and arcane tools. I don&#x27;t mind, I have never felt like I did less or sloppier work than my co-workers, and my freelance customers don&#x27;t care what I use as long as I can solve their problems. Most of the work in programming doesn&#x27;t happen at the keyboard anyway. I do pay attention and experiment with all kinds of tools but I usually end up going back to the Unix tools I have long familiarity with. That said I did spend many years in Visual Studio, MPW, CodeWarrior, and MPW writing C and C++ code, and I do think those tools (well, maybe not MPW) offered a lot of benefits over coding with vim and grep, for the projects I did back then.<p>Maybe ironically I use an iPad Pro, I don&#x27;t have a desktop or laptop anymore. So I have the most modern hardware and a touch-based (soon) AI-assisted operating system that runs a terminal emulator during my work time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41438601" class="c"><input type="checkbox" id="c-41438601" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41434977">parent</a><span>|</span><a href="#41435657">prev</a><span>|</span><a href="#41431810">next</a><span>|</span><label class="collapse" for="c-41438601">[-]</label><label class="expand" for="c-41438601">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re arguing semantics here in a way that&#x27;s not particularly productive.  VSCode can be set up in a way that is nearly as featureful as an IDE like IntelliJ IDEA or Eclipse, and the default configuration and OOB experience pushes you hard in that direction.  VSCode is designed for software development, not as a general text editor; I would never open up VSCode to edit a configuration file or type up a text file of notes, for example.<p>Something like vim is designed as a general text-editing tool.  Sure, you can load it up with plugins and scripts that give you a bunch of features you&#x27;d find in an IDE, but the experience is not the same, and the &quot;integrated&quot; bit of &quot;IDE&quot; is still just not there.<p>(And I say this as someone who does most of his coding in vim, with LSP plugins installed, only reaching for a &quot;proper&quot; IDE for Java and Scala.)<p>One metric I would use: if I can sit down at a random co-worker&#x27;s desk and feel more or less at home in their editor of choice, then it&#x27;s probably an IDE that has reasonable defaults and is geared for software development.  IDEA and VSCode would qualify... vim would certainly not.</div><br/></div></div></div></div></div></div><div id="41431810" class="c"><input type="checkbox" id="c-41431810" checked=""/><div class="controls bullet"><span class="by">heisenbit</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432945">prev</a><span>|</span><a href="#41431750">next</a><span>|</span><label class="collapse" for="c-41431810">[-]</label><label class="expand" for="c-41431810">[3 more]</label></div><br/><div class="children"><div class="content">A good IDE can be so much better iff it understands the code. However this requires the IDE to be able to understand the project structure, dependencies etc. which can be considerable effort. In a codebase with many projects employing several different languages it becomes hard to get and maintain the IDE understands everything state.</div><br/><div id="41432414" class="c"><input type="checkbox" id="c-41432414" checked=""/><div class="controls bullet"><span class="by">amichal</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431810">parent</a><span>|</span><a href="#41432465">next</a><span>|</span><label class="collapse" for="c-41432414">[-]</label><label class="expand" for="c-41432414">[1 more]</label></div><br/><div class="children"><div class="content">And an IDE would also fail to find references for most of the cases described in the article: name composition&#x2F;manipulation, naming consistency across language barriers, and flat namespaces in serialization. And file&#x2F;path folder naming seems to be irrelevant to the smart IDE argument. &quot;Naming things is hard&quot;</div><br/></div></div><div id="41432465" class="c"><input type="checkbox" id="c-41432465" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431810">parent</a><span>|</span><a href="#41432414">prev</a><span>|</span><a href="#41431750">next</a><span>|</span><label class="collapse" for="c-41432465">[-]</label><label class="expand" for="c-41432465">[1 more]</label></div><br/><div class="children"><div class="content">And especially in large monorepos anything that understands the code can become quite sluggish. While ripgrep remains fast.<p>A kind of in-between I&#x27;ve found for some search and replace action is comby (<a href="https:&#x2F;&#x2F;comby.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;comby.dev&#x2F;</a>). Having a matching braces feature is a godsend for doing some kind of replacements properly.</div><br/></div></div></div></div><div id="41431750" class="c"><input type="checkbox" id="c-41431750" checked=""/><div class="controls bullet"><span class="by">brain5ide</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431810">prev</a><span>|</span><a href="#41432401">next</a><span>|</span><label class="collapse" for="c-41431750">[-]</label><label class="expand" for="c-41431750">[2 more]</label></div><br/><div class="children"><div class="content">I think the first sentence of the author counters your comment.
What you described works best in a familiar codebase where the organizing principles have been maintained well and are familiar to the reader and the tools are just the extension of those organizing principles. Even then a deviation from those rules might produce gaps in understanding of what the codebase does.<p>And grep cuts right through that in a pretty universal way. What the post describes are just ways to not work against grep to optimize for something ephemeral.</div><br/><div id="41431820" class="c"><input type="checkbox" id="c-41431820" checked=""/><div class="controls bullet"><span class="by">ricardo81</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431750">parent</a><span>|</span><a href="#41432401">next</a><span>|</span><label class="collapse" for="c-41431820">[-]</label><label class="expand" for="c-41431820">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Not just because it&#x27;s unfamiliar code, you can also get a feel for how the program&#x2F;programmer(s) structured the whole thing.</div><br/></div></div></div></div><div id="41432401" class="c"><input type="checkbox" id="c-41432401" checked=""/><div class="controls bullet"><span class="by">citrin_ru</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431750">prev</a><span>|</span><a href="#41431793">next</a><span>|</span><label class="collapse" for="c-41432401">[-]</label><label class="expand" for="c-41432401">[1 more]</label></div><br/><div class="children"><div class="content">Not everything you need to look for is a language identifier. I often grep for configuration option names in the code to see what the option actually does - sometimes it is easy to grep, sometimes there are too many matches, sometimes they cannot be found because option name composed in the code from separate unrepeatable (because of too many matches) parts. It&#x27;s not hard to make config options greppable but some coders just don&#x27;t care about this property.</div><br/></div></div><div id="41431793" class="c"><input type="checkbox" id="c-41431793" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432401">prev</a><span>|</span><a href="#41433451">next</a><span>|</span><label class="collapse" for="c-41431793">[-]</label><label class="expand" for="c-41431793">[15 more]</label></div><br/><div class="children"><div class="content">Go to definition and find usages only work one symbol at a time. I use both, but I still use global find&#x2F;replace for groups of symbols sharing the same concept.<p>For example if I want to rename all “Dog” (DogModel, DogView, DogController) symbols to “Wolf”, find&#x2F;replace is much better at that because it will tell me about symbols I had forgotten about.</div><br/><div id="41432605" class="c"><input type="checkbox" id="c-41432605" checked=""/><div class="controls bullet"><span class="by">sandermvanvliet</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41431884">next</a><span>|</span><label class="collapse" for="c-41432605">[-]</label><label class="expand" for="c-41432605">[1 more]</label></div><br/><div class="children"><div class="content">Jetbrains ReSharper (and Rider) is smart enough to handle these things. It’ll suggest renames across other symbols even ones that have related names</div><br/></div></div><div id="41431884" class="c"><input type="checkbox" id="c-41431884" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41432605">prev</a><span>|</span><a href="#41431930">next</a><span>|</span><label class="collapse" for="c-41431884">[-]</label><label class="expand" for="c-41431884">[1 more]</label></div><br/><div class="children"><div class="content">For that use case I think you can use treesitter[1] you can find Dog.* but only if it is a variable name, for example. Avoiding replacement inside of say literals.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MZPR_SC9LzE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MZPR_SC9LzE</a></div><br/></div></div><div id="41431930" class="c"><input type="checkbox" id="c-41431930" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41431884">prev</a><span>|</span><a href="#41431822">next</a><span>|</span><label class="collapse" for="c-41431930">[-]</label><label class="expand" for="c-41431930">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason they <i>have</i> to work one symbol at a time - that&#x27;s just a missing feature in your language server implementation.<p>Some language servers support modifying the symbols in contexts like docstrings as well.</div><br/><div id="41432000" class="c"><input type="checkbox" id="c-41432000" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431930">parent</a><span>|</span><a href="#41431822">next</a><span>|</span><label class="collapse" for="c-41432000">[-]</label><label class="expand" for="c-41432000">[7 more]</label></div><br/><div class="children"><div class="content">I’ve never seen an LSP server that lets you rename “Dog” to “Wolf” where your actual class names are “Dog[A-Za-z]*”?<p>Do you have an example?</div><br/><div id="41432785" class="c"><input type="checkbox" id="c-41432785" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432000">parent</a><span>|</span><a href="#41432121">next</a><span>|</span><label class="collapse" for="c-41432785">[-]</label><label class="expand" for="c-41432785">[4 more]</label></div><br/><div class="children"><div class="content">Neither have I; and no, I don&#x27;t - I misinterpreted what you said.<p>But I don&#x27;t see why LSP servers shouldn&#x27;t support this, still. I&#x27;m not sure if the LSP specification allows for this as of current, though.</div><br/><div id="41436842" class="c"><input type="checkbox" id="c-41436842" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432785">parent</a><span>|</span><a href="#41432121">next</a><span>|</span><label class="collapse" for="c-41436842">[-]</label><label class="expand" for="c-41436842">[3 more]</label></div><br/><div class="children"><div class="content">I would actually love a regexp search-and-replace assisted by either TreeSitter or LSP.<p>Something that lets me say that I want to replace “Dog\(.*\)” with “Wolf\1”, but where each substitution is performed only within single “symbols” as identified by TS or LSP.</div><br/><div id="41440117" class="c"><input type="checkbox" id="c-41440117" checked=""/><div class="controls bullet"><span class="by">nickcox</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41436842">parent</a><span>|</span><a href="#41432121">next</a><span>|</span><label class="collapse" for="c-41440117">[-]</label><label class="expand" for="c-41440117">[2 more]</label></div><br/><div class="children"><div class="content">ast-grep supports regex [1] or pattern based [2] matching and replacement.<p>[1] <a href="https:&#x2F;&#x2F;ast-grep.github.io&#x2F;guide&#x2F;rule-config&#x2F;atomic-rule.html#regex" rel="nofollow">https:&#x2F;&#x2F;ast-grep.github.io&#x2F;guide&#x2F;rule-config&#x2F;atomic-rule.htm...</a>
[2] <a href="https:&#x2F;&#x2F;ast-grep.github.io&#x2F;guide&#x2F;rule-config&#x2F;atomic-rule.html#pattern" rel="nofollow">https:&#x2F;&#x2F;ast-grep.github.io&#x2F;guide&#x2F;rule-config&#x2F;atomic-rule.htm...</a></div><br/></div></div></div></div></div></div><div id="41432121" class="c"><input type="checkbox" id="c-41432121" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432000">parent</a><span>|</span><a href="#41432785">prev</a><span>|</span><a href="#41431822">next</a><span>|</span><label class="collapse" for="c-41432121">[-]</label><label class="expand" for="c-41432121">[2 more]</label></div><br/><div class="children"><div class="content">IntelliJ&#x27;s refactor tool?</div><br/><div id="41435153" class="c"><input type="checkbox" id="c-41435153" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432121">parent</a><span>|</span><a href="#41431822">next</a><span>|</span><label class="collapse" for="c-41435153">[-]</label><label class="expand" for="c-41435153">[1 more]</label></div><br/><div class="children"><div class="content">IntelliJ doesn&#x27;t use LSP as far as I know.<p>It does usually make that kind of DogModel -&gt; WolfModel refactoring.</div><br/></div></div></div></div></div></div></div></div><div id="41431822" class="c"><input type="checkbox" id="c-41431822" checked=""/><div class="controls bullet"><span class="by">gugagore</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41431930">prev</a><span>|</span><a href="#41433451">next</a><span>|</span><label class="collapse" for="c-41431822">[-]</label><label class="expand" for="c-41431822">[4 more]</label></div><br/><div class="children"><div class="content">I am familiar with the situation you describe, and it&#x27;s a good point.<p>However, it does suggest that there is an opportunity for factoring &quot;Dog&quot; out in the code, at least by name spacing (e.g. Dog.Model).</div><br/><div id="41432509" class="c"><input type="checkbox" id="c-41432509" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431822">parent</a><span>|</span><a href="#41431877">next</a><span>|</span><label class="collapse" for="c-41432509">[-]</label><label class="expand" for="c-41432509">[2 more]</label></div><br/><div class="children"><div class="content">That gets to the core of the issue doesn’t it? There are two cultures: Do you prefer to refactor DogView into Dog.View, or do you prefer to refactor Dog.View into DogView.<p>Personally I value uniqueness&#x2F;canonicalness over conciseness. I would rather have DogView because then there is one name for the symbol regardless of where I am in the codebase. If the same symbol is used with differently qualified names it is confusing - I want the least qualified name to be more descriptive than “View”.<p>The other culture is to lean heavily on namespaces and to not worry about uniqueness. In this case you have View and Dog.View that may be used interchangeably in different files. This is the dominant culture in Java and C#.</div><br/><div id="41434632" class="c"><input type="checkbox" id="c-41434632" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432509">parent</a><span>|</span><a href="#41431877">next</a><span>|</span><label class="collapse" for="c-41434632">[-]</label><label class="expand" for="c-41434632">[1 more]</label></div><br/><div class="children"><div class="content">The second culture that you describe happens also to be how OCaml structures things in modules. It&#x27;s quite a turnoff for me.</div><br/></div></div></div></div><div id="41431877" class="c"><input type="checkbox" id="c-41431877" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431822">parent</a><span>|</span><a href="#41432509">prev</a><span>|</span><a href="#41433451">next</a><span>|</span><label class="collapse" for="c-41431877">[-]</label><label class="expand" for="c-41431877">[1 more]</label></div><br/><div class="children"><div class="content">That really depends on the context, and specific situation.</div><br/></div></div></div></div></div></div><div id="41433451" class="c"><input type="checkbox" id="c-41433451" checked=""/><div class="controls bullet"><span class="by">sauercrowd</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431793">prev</a><span>|</span><a href="#41431885">next</a><span>|</span><label class="collapse" for="c-41433451">[-]</label><label class="expand" for="c-41433451">[1 more]</label></div><br/><div class="children"><div class="content">strongly disagree here. This works if
- your IDE&#x2F;language server is performant
- all the tools are fully set up
- you know how to query the specific semantic entity you&#x27;re looking for (remembering shortcuts)
- you are only interested in a single specific semantic entity - mixing entities is rarely supported<p>I dont map out projects in terms of semantics, I map out projects in files and code - That makes querying intuitive and I can easily compose queries that match the specificity of what I care about (e.g. I might want to find a `Server` but I want to show both classes, interfaces and abstract classes).<p>For the specific toolchain I&#x27;m using - typescript - the symbol search is also unusable once it hits a certain project size, it&#x27;s just way too slow for it to be part of my core workflow</div><br/></div></div><div id="41431885" class="c"><input type="checkbox" id="c-41431885" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41433451">prev</a><span>|</span><a href="#41432267">next</a><span>|</span><label class="collapse" for="c-41431885">[-]</label><label class="expand" for="c-41431885">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately in larger codebases or dynamic languages these tools are just not good enough today. At least not those I and my employers have tried.<p>They&#x27;re either incomplete (you don&#x27;t get ALL references or you get false references) or way too slow (&gt;10 seconds when rg takes 1-2).<p>Recommendations are most welcome.</div><br/><div id="41431900" class="c"><input type="checkbox" id="c-41431900" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431885">parent</a><span>|</span><a href="#41432267">next</a><span>|</span><label class="collapse" for="c-41431900">[-]</label><label class="expand" for="c-41431900">[1 more]</label></div><br/><div class="children"><div class="content">Only thing I can recommend is using C# (obviously not always possible). Never had an issue with these functions in Visual Studio proper no matter how big the project.</div><br/></div></div></div></div><div id="41432267" class="c"><input type="checkbox" id="c-41432267" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431885">prev</a><span>|</span><a href="#41438500">next</a><span>|</span><label class="collapse" for="c-41432267">[-]</label><label class="expand" for="c-41432267">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t use an IDE on my entire git history, but git can grep.</div><br/></div></div><div id="41438500" class="c"><input type="checkbox" id="c-41438500" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432267">prev</a><span>|</span><a href="#41432827">next</a><span>|</span><label class="collapse" for="c-41438500">[-]</label><label class="expand" for="c-41438500">[1 more]</label></div><br/><div class="children"><div class="content">Even with IDEs, I find that I grep through source trees fairly often.<p>Sometimes it&#x27;s because I don&#x27;t completely trust the IDE to find everything I&#x27;m interested in (justifiably; sometimes it doesn&#x27;t).  Sometimes it&#x27;s because I&#x27;m not looking to dive into the code and do serious work on it; I&#x27;m just doing a quick drive-by check&#x2F;lookup for something.  Sometimes it&#x27;s because I&#x27;m ssh&#x27;d into another machine and I don&#x27;t have the ability to easily open the sources in an IDE.</div><br/></div></div><div id="41432827" class="c"><input type="checkbox" id="c-41432827" checked=""/><div class="controls bullet"><span class="by">phyrex</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41438500">prev</a><span>|</span><a href="#41433622">next</a><span>|</span><label class="collapse" for="c-41432827">[-]</label><label class="expand" for="c-41432827">[1 more]</label></div><br/><div class="children"><div class="content">This breaks down at scale and across languages. All the FAANGs make heavy use of the equivalent of grepping in their code base</div><br/></div></div><div id="41433622" class="c"><input type="checkbox" id="c-41433622" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432827">prev</a><span>|</span><a href="#41441046">next</a><span>|</span><label class="collapse" for="c-41433622">[-]</label><label class="expand" for="c-41433622">[2 more]</label></div><br/><div class="children"><div class="content">True, but IDEs are fragile tools. Sometimes you want to fall back to simpler tools that will always work, and grep is not fragile.</div><br/><div id="41434163" class="c"><input type="checkbox" id="c-41434163" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41433622">parent</a><span>|</span><a href="#41441046">next</a><span>|</span><label class="collapse" for="c-41434163">[-]</label><label class="expand" for="c-41434163">[1 more]</label></div><br/><div class="children"><div class="content">The basis if this article (and its forebear &quot;Too DRY - The Grep Test&quot;[1]) is that grep <i>is</i> fragile.  It&#x27;s just fragile in a way that&#x27;s different from the way that IDEs are fragile.<p>1. &lt;<a href="http:&#x2F;&#x2F;jamie-wong.com&#x2F;2013&#x2F;07&#x2F;12&#x2F;grep-test&#x2F;" rel="nofollow">http:&#x2F;&#x2F;jamie-wong.com&#x2F;2013&#x2F;07&#x2F;12&#x2F;grep-test&#x2F;</a>&gt;</div><br/></div></div></div></div><div id="41441046" class="c"><input type="checkbox" id="c-41441046" checked=""/><div class="controls bullet"><span class="by">umvi</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41433622">prev</a><span>|</span><a href="#41439936">next</a><span>|</span><label class="collapse" for="c-41441046">[-]</label><label class="expand" for="c-41441046">[1 more]</label></div><br/><div class="children"><div class="content">Interface-heavy languages break IDEs. In .NET at least, &quot;go to definition&quot; jumps you to the <i>interface</i> definition which you probably aren&#x27;t interested in (vs. the specific implementation you are trying to dig into). Also with .NET specifically XAML breaks IDE traceability as well.</div><br/></div></div><div id="41439936" class="c"><input type="checkbox" id="c-41439936" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41441046">prev</a><span>|</span><a href="#41437351">next</a><span>|</span><label class="collapse" for="c-41439936">[-]</label><label class="expand" for="c-41439936">[1 more]</label></div><br/><div class="children"><div class="content">A bit on the other side of the argument, I use grep plus find plus some shell work to do source code analysis for security reviews. grep doesn&#x27;t really understand the syntax of languages, and that is mostly OK.<p>I&#x27;ve used this technique on auditing many code bases including the C family, perl, Visual Basic, C# and SQL.<p>With this sort of tool, I don&#x27;t need to look for language-particular parsers--so long as the source is in a text file, this works well.</div><br/></div></div><div id="41437351" class="c"><input type="checkbox" id="c-41437351" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41439936">prev</a><span>|</span><a href="#41432124">next</a><span>|</span><label class="collapse" for="c-41437351">[-]</label><label class="expand" for="c-41437351">[1 more]</label></div><br/><div class="children"><div class="content">Sure, if you have the luxury of having a functional IDE for all of your code.<p>You can&#x27;t imagine how much faster I was than everybody else at answering questions about a large codebase just because I knew how to use ripgrep (on Windows). &quot;Knowing how to grep&quot; is a superpower.</div><br/></div></div><div id="41432124" class="c"><input type="checkbox" id="c-41432124" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41437351">prev</a><span>|</span><a href="#41437176">next</a><span>|</span><label class="collapse" for="c-41432124">[-]</label><label class="expand" for="c-41432124">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve come to really like language servers for big personal and work projects where I already have my tools configured and tuned for efficiently working with it.<p>But being able to grep is really nice when trying to figure out something out about a source tree that I don&#x27;t yet have set up to compile, nor am I a developer of.  I.e., I&#x27;ve downloaded the source for a tool I&#x27;ve been using pre-built binaries of and am now trying to trace why I might be getting a particular error.</div><br/></div></div><div id="41437176" class="c"><input type="checkbox" id="c-41437176" checked=""/><div class="controls bullet"><span class="by">brooke2k</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432124">prev</a><span>|</span><a href="#41434617">next</a><span>|</span><label class="collapse" for="c-41437176">[-]</label><label class="expand" for="c-41437176">[2 more]</label></div><br/><div class="children"><div class="content">with all due respect, it sounds like you have the privilege of working in some relatively tidy codebases (and I&#x27;m jealous!)<p>with a legacy codebase, or a fork of a dependency that had to be patched which uses an incompatible buildsystem, or any C&#x2F;C++&#x2F;obj-c&#x2F;etc that heavily uses the preprocessor or nonstandard build practices, or codebases that mix lots of different languages over awkward FFI boundaries and so on and so forth -- there are so many situations where sometimes an IDE just can&#x27;t get you 100% of the way there and you have to revert to grepping to do any real work<p>that being said, I don&#x27;t fully support the idea of handcuffing your code in the name of greppability, but I think dismissing it as a metric under the premise that IDEs make grepping &quot;obsolete&quot; is a little bit hasty</div><br/><div id="41437448" class="c"><input type="checkbox" id="c-41437448" checked=""/><div class="controls bullet"><span class="by">lucumo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41437176">parent</a><span>|</span><a href="#41434617">next</a><span>|</span><label class="collapse" for="c-41437448">[-]</label><label class="expand" for="c-41437448">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with all due respect, it sounds like you have the privilege of working in some relatively tidy codebases (and I&#x27;m jealous!)<p>I wish, but no. I&#x27;ve found people will make a mess of everything. Which is why I don&#x27;t trust solutions that rely on humans having more discipline, like what this article advocates.<p>In any situation where grep is your last saviour, you cannot rely on the greppability of the code. You&#x27;ll have to check and double check everything, and still accept the risk of errors.</div><br/></div></div></div></div><div id="41434617" class="c"><input type="checkbox" id="c-41434617" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41437176">prev</a><span>|</span><a href="#41433714">next</a><span>|</span><label class="collapse" for="c-41434617">[-]</label><label class="expand" for="c-41434617">[1 more]</label></div><br/><div class="children"><div class="content">It seems like the law of diminishing returns; while I&#x27;m sure in a few cases this characteristic of a code writing style is extremely useful, it cuts into other things such as readability and conciseness. Fewer lines can mean fewer bugs, within reason, if you aren&#x27;t in lisp and are using more than 3 parentheses, you might want to split it up because the compiler&#x2F;JIT&#x2F;interpreter is going to anyway.</div><br/></div></div><div id="41433714" class="c"><input type="checkbox" id="c-41433714" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41434617">prev</a><span>|</span><a href="#41432767">next</a><span>|</span><label class="collapse" for="c-41433714">[-]</label><label class="expand" for="c-41433714">[1 more]</label></div><br/><div class="children"><div class="content">I can run rg over my project faster than I can do anything in my IDE. Both tools have their places.</div><br/></div></div><div id="41432767" class="c"><input type="checkbox" id="c-41432767" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41433714">prev</a><span>|</span><a href="#41432955">next</a><span>|</span><label class="collapse" for="c-41432767">[-]</label><label class="expand" for="c-41432767">[1 more]</label></div><br/><div class="children"><div class="content">IDEs are cool and all, but there is no way I&#x27;m gonna let VSCode index my 80GB yocto tmp directory. Ctags can crunch the whole thing in a few minutes, and so can grep.<p>Plus there are cases where grep is really what you need, for example after updating a particular command line tool whose output changed, I was able to find all scripts which grepped the output of the tool in a way that was broken.</div><br/></div></div></div></div><div id="41432955" class="c"><input type="checkbox" id="c-41432955" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#41431701">prev</a><span>|</span><a href="#41432094">next</a><span>|</span><label class="collapse" for="c-41432955">[-]</label><label class="expand" for="c-41432955">[28 more]</label></div><br/><div class="children"><div class="content">The second point here made me realize that it&#x27;d be super useful for a grep tool to have a &quot;super case insensitive&quot; mode which expands a search for, say, &quot;FooBar|first_name&quot; to something like &#x2F;foo[-_]?bar|first[-_]?name&#x2F;i, so that any camel&#x2F;snake&#x2F;pascal&#x2F;kebab&#x2F;etc case will match. In fact, I struggle to come up with situations where that <i>wouldn&#x27;t</i> be a great default.</div><br/><div id="41437663" class="c"><input type="checkbox" id="c-41437663" checked=""/><div class="controls bullet"><span class="by">msmolkin</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41439414">next</a><span>|</span><label class="collapse" for="c-41437663">[-]</label><label class="expand" for="c-41437663">[4 more]</label></div><br/><div class="children"><div class="content">Hey, I just created a new tool called Super Grep that does exactly what you described.<p>I implemented a format-agnostic search that can match patterns across various naming conventions like camelCase, snake_case, PascalCase, kebab-case. If needed, I&#x27;ll integrate in space-separated words.<p>I&#x27;ve just published the tool to PyPI, so you can easily install it using pip (`pip install super-grep`), and then you just run it from the command line with `super-grep`. You can let me know if you think there&#x27;s a smarter name for it.<p>Source: <a href="https:&#x2F;&#x2F;www.github.com&#x2F;msmolkin&#x2F;super-grep">https:&#x2F;&#x2F;www.github.com&#x2F;msmolkin&#x2F;super-grep</a></div><br/><div id="41437840" class="c"><input type="checkbox" id="c-41437840" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41437663">parent</a><span>|</span><a href="#41442927">next</a><span>|</span><label class="collapse" for="c-41437840">[-]</label><label class="expand" for="c-41437840">[2 more]</label></div><br/><div class="children"><div class="content">You should post this as a Show HN! But maybe wait a while (like a couple weeks or something) for the current thread to get flushed out of the hivemind cache.<p>If you do, email a link to hn@ycombinator.com and we&#x27;ll put it in the second-chance pool (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;pool">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;pool</a>, explained at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26998308">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26998308</a>), so it will get a random placement on HN&#x27;s front page.</div><br/><div id="41439551" class="c"><input type="checkbox" id="c-41439551" checked=""/><div class="controls bullet"><span class="by">msmolkin</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41437840">parent</a><span>|</span><a href="#41442927">next</a><span>|</span><label class="collapse" for="c-41439551">[-]</label><label class="expand" for="c-41439551">[1 more]</label></div><br/><div class="children"><div class="content">Wow, thanks so much for the encouragement and advice, dang! I&#x27;m honored to receive a personal response from you and so soon after posting. I really appreciate the suggestion to post this as a Show HN. If I end up doing it, I&#x27;ll definitely wait a bit–thanks for that suggestion, as I would have thought to do the opposite otherwise. Nice of you to offer to put it in the second-chance pool as well.</div><br/></div></div></div></div><div id="41442927" class="c"><input type="checkbox" id="c-41442927" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41437663">parent</a><span>|</span><a href="#41437840">prev</a><span>|</span><a href="#41439414">next</a><span>|</span><label class="collapse" for="c-41442927">[-]</label><label class="expand" for="c-41442927">[1 more]</label></div><br/><div class="children"><div class="content">wow this is so cool!! it feels super amazing to dump a random idea on HN and then <i>somebody makes it</i>! i&#x27;m installing python as we speak just so i can use this.</div><br/></div></div></div></div><div id="41439414" class="c"><input type="checkbox" id="c-41439414" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41437663">prev</a><span>|</span><a href="#41437462">next</a><span>|</span><label class="collapse" for="c-41439414">[-]</label><label class="expand" for="c-41439414">[2 more]</label></div><br/><div class="children"><div class="content">Adding to that, I&#x27;m often bitten trying to search for user strings because they&#x27;re split across lines to adhere to 80 characters.<p>So if I&#x27;m trying to locate the error message &quot;because the disk is full&quot; but it&#x27;s in the code as:<p><pre><code>  ... + &quot; because the &quot; + 
    &quot;disk is full&quot;)
</code></pre>
then it will fail.<p>So really, combining both our use cases, what would be great is to simply search for a given <i>case-insensitive alphanumeric string</i> in files that <i>skips all non-alphanumeric characters</i>.<p>So if I search for:<p><pre><code>  Foobar2
</code></pre>
it would match all of:<p><pre><code>  FooBar2
  foo_bar[2]
  &quot;Foo &quot; + \
    (&quot;bar 2&quot;)
  foo.bar.2
</code></pre>
And then in the search results, even if you get some accidental hits, you can be happy knowing that you didn&#x27;t miss anything.</div><br/><div id="41440649" class="c"><input type="checkbox" id="c-41440649" checked=""/><div class="controls bullet"><span class="by">lathiat</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41439414">parent</a><span>|</span><a href="#41437462">next</a><span>|</span><label class="collapse" for="c-41440649">[-]</label><label class="expand" for="c-41440649">[1 more]</label></div><br/><div class="children"><div class="content">These are both of the problems I regularly have. The first one I immediately saw when reading the title of this submissionw as the &quot;super case insensitive&quot; that I often see when working on Go Codebases particularly when using a combination of Go Classes and YAML or JSON. Also happens with command line arguments being converted to variables.<p>But the string split thing you mentioned happens a lot when searching for OpenStack error messages in Python that is often split across lines like you showed. My current solution is to randomly shift what I&#x27;m searching for, or try pick the most unique line.</div><br/></div></div></div></div><div id="41437462" class="c"><input type="checkbox" id="c-41437462" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41439414">prev</a><span>|</span><a href="#41434024">next</a><span>|</span><label class="collapse" for="c-41437462">[-]</label><label class="expand" for="c-41437462">[1 more]</label></div><br/><div class="children"><div class="content">fwiw I pretty frequently use `first.?name` - the odds of it matching something like &quot;FirstSname&quot; are low enough that it&#x27;s not an issue, and it finds all cases and all common separators in one shot.<p>(`first\S?name` is usually better, by ignoring whitespace -&gt; better ignores comments describing a thing, but `.` is easier to remember and type so I usually just do that)</div><br/></div></div><div id="41434024" class="c"><input type="checkbox" id="c-41434024" checked=""/><div class="controls bullet"><span class="by">hnben</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41437462">prev</a><span>|</span><a href="#41433320">next</a><span>|</span><label class="collapse" for="c-41434024">[-]</label><label class="expand" for="c-41434024">[8 more]</label></div><br/><div class="children"><div class="content">&gt;  &quot;super case insensitive&quot;<p>lets say someone would make a plugin for their favorite IDE for this kind of search. How would the details look like?<p>To keep it simple, lets assume we just do the super-case-insensitivity, without the other regex condition. Lets say the user searches for &quot;first_name&quot; and wants to find &quot;FirstName&quot;.<p>one simple solution would be to have a convention where a word starts or ends, e.g. with &quot; &quot;. So the user would enter &quot;first name&quot; into the plugin&#x27;s search field. The plugin turns it into &quot;&#x2F;first[-_]?name&#x2F;i&quot; and gives this regexp to the normal search of the IDE.<p>another simple solution would be to ignore all word boundaries. So when the user enters &quot;first name&quot;, the regexp would become &quot;&#x2F;f[-_]?i[-_]?r[-_]?s[-_]?t[-_]?n[-_]?a[-_]?m[-_]?e[-_]?&#x2F;i&quot;. Then the search would not only be super-case-insensitive, but super-duper-case-insensitive. I guess the biggest downside would be, that this could get very slow.<p>I think implementing a plugin like this would be trivial for most IDEs, that support plugins.<p>Am I missing something?</div><br/><div id="41434577" class="c"><input type="checkbox" id="c-41434577" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434024">parent</a><span>|</span><a href="#41434275">next</a><span>|</span><label class="collapse" for="c-41434577">[-]</label><label class="expand" for="c-41434577">[2 more]</label></div><br/><div class="children"><div class="content">Hm I&#x27;d go even simpler than that. Notably, I&#x27;d not do this:<p>&gt; So the user would enter &quot;first name&quot; into the plugin&#x27;s search field.<p>Why wouldn&#x27;t the user just enter &quot;first_name&quot; or &quot;firstName&quot; or something like that? I&#x27;m thinking about situations like, you&#x27;re looking at backend code that&#x27;s snake_cased, but you also want it to catch frontend code that&#x27;s camelCased. So when you search for &quot;first_name&quot; you automagically also match &quot;firstName&quot; (and &quot;FirstName&quot; and &quot;first-name&quot; and so on). I wouldn&#x27;t personally introduce some convention that adds spaces into the mix, I&#x27;d simply convert anything that looks snake&#x2F;kebab&#x2F;pascal&#x2F;camel-cased into a regex that matches all 4 forms.<p>Could even be as stupid as converting &quot;first_name&quot; <i>or</i> &quot;firstName&quot;, <i>or</i> &quot;FirstName&quot; etc into &quot;first_name|firstname|first-name&quot;, no character classes needed. That catches pretty much every naming convention right? (assuming it&#x27;s searched for with case insensitivity)</div><br/><div id="41438064" class="c"><input type="checkbox" id="c-41438064" checked=""/><div class="controls bullet"><span class="by">specialist</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434577">parent</a><span>|</span><a href="#41434275">next</a><span>|</span><label class="collapse" for="c-41438064">[-]</label><label class="expand" for="c-41438064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;first_name&quot; or &quot;firstName&quot;</i><p>Ya. Query tokenizer would emit &quot;first&quot; and &quot;name&quot; for both. That&#x27;d be neat.</div><br/></div></div></div></div><div id="41434275" class="c"><input type="checkbox" id="c-41434275" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434024">parent</a><span>|</span><a href="#41434577">prev</a><span>|</span><a href="#41434136">next</a><span>|</span><label class="collapse" for="c-41434275">[-]</label><label class="expand" for="c-41434275">[1 more]</label></div><br/><div class="children"><div class="content">Shame on me for jumping past the simple solutions, but...<p>If you&#x27;re going that far, and you&#x27;re in a context which probably has a parser for the underlying language ready at hand, you might as well just convert all tokens to a common format and do the same with the queries.  So searches for foo-bar find strings like FooBar because they both normalize to foo_bar.<p>Then you can index by more than just line number.  For instance you might find &quot;foo&quot; and &quot;bar&quot; even when &quot;foo = 6&quot; shows up in a file called &quot;bar.py&quot; or when they show up on separate lines but still in the same function.</div><br/></div></div><div id="41434136" class="c"><input type="checkbox" id="c-41434136" checked=""/><div class="controls bullet"><span class="by">inanutshellus</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434024">parent</a><span>|</span><a href="#41434275">prev</a><span>|</span><a href="#41435497">next</a><span>|</span><label class="collapse" for="c-41434136">[-]</label><label class="expand" for="c-41434136">[1 more]</label></div><br/><div class="children"><div class="content">IIUC, you&#x27;re not missing anything though your interpretation is off from mine*. He wasn&#x27;t saying it&#x27;d be hard, he was saying it should be done.<p>* my understanding was simply that the regex would (A) recognize `[a-z][A-Z]` and inject optional _&#x27;s and -&#x27;s between... and (B) notice mid-word hyphens or underscores and switch them to search for both.</div><br/></div></div><div id="41435497" class="c"><input type="checkbox" id="c-41435497" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434024">parent</a><span>|</span><a href="#41434136">prev</a><span>|</span><a href="#41437845">next</a><span>|</span><label class="collapse" for="c-41435497">[-]</label><label class="expand" for="c-41435497">[2 more]</label></div><br/><div class="children"><div class="content">The best way would be to make an escape code that matches zero or one punctuation.<p>So you&#x27;s search for &quot;&#x2F;first\_name&#x2F;i&quot;.</div><br/><div id="41437021" class="c"><input type="checkbox" id="c-41437021" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41435497">parent</a><span>|</span><a href="#41437845">next</a><span>|</span><label class="collapse" for="c-41437021">[-]</label><label class="expand" for="c-41437021">[1 more]</label></div><br/><div class="children"><div class="content">That already exists as &quot;?&quot; and was used in their example:<p><pre><code>  &#x2F;first[-_]?name&#x2F;i
</code></pre>
Or to use your example, just checking for underscores and not also dashes:<p><pre><code>  &#x2F;first_?name&#x2F;i
</code></pre>
Backslash is already used to change special characters like &quot;?&quot; from these meanings into just &quot;use this character without interpreting it&quot; (or the reverse, in some dialects).</div><br/></div></div></div></div><div id="41437845" class="c"><input type="checkbox" id="c-41437845" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434024">parent</a><span>|</span><a href="#41435497">prev</a><span>|</span><a href="#41433320">next</a><span>|</span><label class="collapse" for="c-41437845">[-]</label><label class="expand" for="c-41437845">[1 more]</label></div><br/><div class="children"><div class="content">It would be a mistake to try to solve this problem with regexes.</div><br/></div></div></div></div><div id="41433320" class="c"><input type="checkbox" id="c-41433320" checked=""/><div class="controls bullet"><span class="by">WizardClickBoy</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41434024">prev</a><span>|</span><a href="#41434419">next</a><span>|</span><label class="collapse" for="c-41433320">[-]</label><label class="expand" for="c-41433320">[4 more]</label></div><br/><div class="children"><div class="content">This reminds me of the substitution mode of Tim Pope&#x27;s amazing vim plugin [abolish](<a href="https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-abolish?tab=readme-ov-file#substitution">https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-abolish?tab=readme-ov-file#subs...</a>)<p>Basically in vim to substitute text you&#x27;d usually do something with :substitute (or :s), like:<p>:%s&#x2F;textToSubstitute&#x2F;replacementText&#x2F;g<p>...and have to add a pattern for each differently-cased version of the text.<p>With the :Subvert command (or :S) you can do all three at once, while maintaining the casing for each replacement. So this:<p>textToSubstitute<p>TextToSubstitute<p>texttosubstitute<p>:%S&#x2F;textToSubstitute&#x2F;replacementText&#x2F;g<p>...results in:<p>replacementText<p>ReplacementText<p>replacementtext</div><br/><div id="41434165" class="c"><input type="checkbox" id="c-41434165" checked=""/><div class="controls bullet"><span class="by">WizardClickBoy</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41433320">parent</a><span>|</span><a href="#41434328">next</a><span>|</span><label class="collapse" for="c-41434165">[-]</label><label class="expand" for="c-41434165">[1 more]</label></div><br/><div class="children"><div class="content">Also just realised while looking at the docs it works for search as well as replacement, with:<p>:S&#x2F;textToFind<p>matching all of textToFind TextToFind texttofind TEXTTOFIND<p>But not TeXttOfFiND.<p>Golly!</div><br/></div></div><div id="41434328" class="c"><input type="checkbox" id="c-41434328" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41433320">parent</a><span>|</span><a href="#41434165">prev</a><span>|</span><a href="#41434419">next</a><span>|</span><label class="collapse" for="c-41434328">[-]</label><label class="expand" for="c-41434328">[2 more]</label></div><br/><div class="children"><div class="content">The Emacs replace command[1] defaults to preserving UPCASE, Capitalized, and lowercase too.<p>[1] <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;emacs&#x2F;Replacement-and-Lax-Matches.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;emacs&#x2F;Re...</a></div><br/><div id="41434452" class="c"><input type="checkbox" id="c-41434452" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434328">parent</a><span>|</span><a href="#41434419">next</a><span>|</span><label class="collapse" for="c-41434452">[-]</label><label class="expand" for="c-41434452">[1 more]</label></div><br/><div class="children"><div class="content">Of course it does. Or it wouldn’t be Emacs</div><br/></div></div></div></div></div></div><div id="41434419" class="c"><input type="checkbox" id="c-41434419" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41433320">prev</a><span>|</span><a href="#41434266">next</a><span>|</span><label class="collapse" for="c-41434419">[-]</label><label class="expand" for="c-41434419">[2 more]</label></div><br/><div class="children"><div class="content">I think Nim has this?</div><br/><div id="41436087" class="c"><input type="checkbox" id="c-41436087" checked=""/><div class="controls bullet"><span class="by">archargelod</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434419">parent</a><span>|</span><a href="#41434266">next</a><span>|</span><label class="collapse" for="c-41436087">[-]</label><label class="expand" for="c-41436087">[1 more]</label></div><br/><div class="children"><div class="content">Nim comes bundled with a `nimgrep` tool [0], that is essentially grep on steroids. It has `-y` flag for style insensitive matching, so &quot;fooBar&quot;, &quot;foo_bar&quot; and even &quot;Foo__Ba_R&quot; can be matched with a simple &quot;foobar&quot; pattern.<p>The other killer feature of nimgrep is that instead of regex, you can use PEG grammar [1]<p><pre><code>  [0] - https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;nimgrep.html
  [1] - https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;pegs.html</code></pre></div><br/></div></div></div></div><div id="41434266" class="c"><input type="checkbox" id="c-41434266" checked=""/><div class="controls bullet"><span class="by">dominicrose</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41434419">prev</a><span>|</span><a href="#41433333">next</a><span>|</span><label class="collapse" for="c-41434266">[-]</label><label class="expand" for="c-41434266">[2 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say you have a FilterModal component and you&#x27;re using it like this: x-filter-modal<p>Improving the IDE to find one or the other by searching for one or the other is missing the point or the article, that consistency is important.<p>I&#x27;d rather have a simple IDE and a good codebase than the opposite.
In the example that I gave the worst thing is that it&#x27;s the framework which forces you do use these two names for the same thing.</div><br/><div id="41434590" class="c"><input type="checkbox" id="c-41434590" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434266">parent</a><span>|</span><a href="#41433333">next</a><span>|</span><label class="collapse" for="c-41434590">[-]</label><label class="expand" for="c-41434590">[1 more]</label></div><br/><div class="children"><div class="content">My point is that if grep tools were more powerful we wouldn&#x27;t <i>need</i> this very particular kind of consistency, which gives us the very big benefit of being allowed to keep every part of the codebase in its idiomatic naming convention.<p>I didn&#x27;t miss the point, I disagreed with the point because I think it&#x27;s a tool problem, not a code problem. I agree with most other points in the article.</div><br/></div></div></div></div><div id="41433333" class="c"><input type="checkbox" id="c-41433333" checked=""/><div class="controls bullet"><span class="by">adammarples</span><span>|</span><a href="#41432955">parent</a><span>|</span><a href="#41434266">prev</a><span>|</span><a href="#41432094">next</a><span>|</span><label class="collapse" for="c-41433333">[-]</label><label class="expand" for="c-41433333">[4 more]</label></div><br/><div class="children"><div class="content">Fzf?</div><br/><div id="41433874" class="c"><input type="checkbox" id="c-41433874" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41433333">parent</a><span>|</span><a href="#41432094">next</a><span>|</span><label class="collapse" for="c-41433874">[-]</label><label class="expand" for="c-41433874">[3 more]</label></div><br/><div class="children"><div class="content">Fuzzy search is not the same. For instance, it might by default match not only “FooBar” and “foo_bar” but also e.g. “FooQux(BarQuux)”, which in a large code base might mean hundreds of false positives.</div><br/><div id="41434080" class="c"><input type="checkbox" id="c-41434080" checked=""/><div class="controls bullet"><span class="by">mgkimsal</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41433874">parent</a><span>|</span><a href="#41432094">next</a><span>|</span><label class="collapse" for="c-41434080">[-]</label><label class="expand" for="c-41434080">[2 more]</label></div><br/><div class="children"><div class="content">Ideally there&#x27;d be some sort of ranking or scoring that would happen to sort by.  FooQux(BarQuux) would seemingly rank much lower then FooBar when searching for FooBar or &quot;Foo Bar&quot; but might still be useful in results if ranked and displayed lower.</div><br/><div id="41434701" class="c"><input type="checkbox" id="c-41434701" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41432955">root</a><span>|</span><a href="#41434080">parent</a><span>|</span><a href="#41432094">next</a><span>|</span><label class="collapse" for="c-41434701">[-]</label><label class="expand" for="c-41434701">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, that&#x27;s a good solution – and I believe e.g. fzf does some sort of ranking by default. The devil is however in the details:<p>One minor inconvenience is that the scoring should ideally be different per filetype. For instance, Python would count &quot;foo-bar&quot; as two symbols (&quot;foo minus bar&quot;) whereas Lisp would count it was one symbol, and that should ideally result in different scores when searching for &quot;foobar&quot; in both. Similarly, foo(bar) should ideally have a lower different score than &quot;foo_bar&quot; for symbol search even though the keywords are separated by the same number of characters.<p>I think this can be accomodated by keeping a per-language list of symbols and associated &quot;penalties&quot;, which can be used to calculate &quot;how far&quot; keywords are from each other in the search results weighted by language semantics :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41432094" class="c"><input type="checkbox" id="c-41432094" checked=""/><div class="controls bullet"><span class="by">VoxPelli</span><span>|</span><a href="#41432955">prev</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41432094">[-]</label><label class="expand" for="c-41432094">[39 more]</label></div><br/><div class="children"><div class="content">I advocate for greppability as well – and in Swedish it becomes extra fun – as the equivalent phrase in Swedish becomes &quot;grep-bar&quot; or &quot;grep-barhet&quot; and those are actual words in Swedish – &quot;greppbar&quot; roughly means &quot;understandable&quot;, &quot;greppbarhet&quot; roughly means &quot;the possibility to understand&quot;</div><br/><div id="41432278" class="c"><input type="checkbox" id="c-41432278" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432153">next</a><span>|</span><label class="collapse" for="c-41432278">[-]</label><label class="expand" for="c-41432278">[16 more]</label></div><br/><div class="children"><div class="content">How many other UNIX commands did the Swedes adopt into their language?<p>I know that they invented &quot;curl&quot;. Do you <i>tar xfz</i>?</div><br/><div id="41432518" class="c"><input type="checkbox" id="c-41432518" checked=""/><div class="controls bullet"><span class="by">scbrg</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432278">parent</a><span>|</span><a href="#41432799">next</a><span>|</span><label class="collapse" for="c-41432518">[-]</label><label class="expand" for="c-41432518">[3 more]</label></div><br/><div class="children"><div class="content">We do tar, for xfz I think you have to look to the Slavic languages :)<p>Anyway, to answer your question:<p><pre><code>  $ grep -Fxf &lt;(ls -1 &#x2F;bin) &#x2F;usr&#x2F;share&#x2F;dict&#x2F;swedish 
  ack
  ar
  as
  black
  dialog
  dig
  du
  ebb
  ed
  editor
  finger
  flock
  gem
  glade
  grep
  id
  import
  last
  less
  make
  man
  montage
  pager
  pass
  pc
  plog
  red
  reset
  rev
  sed
  sort
  sorter
  split
  stat
  tar
  test
  transform
  vi
</code></pre>
:)<p>[edit]: Ironically, <i>grep</i> in that list is <i>not</i> the same word as the one OP is talking about. That one is actually based on <i>grepp</i>, with the double p. <i>grep</i> means pitchfork.</div><br/><div id="41433471" class="c"><input type="checkbox" id="c-41433471" checked=""/><div class="controls bullet"><span class="by">pbhjpbhj</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432518">parent</a><span>|</span><a href="#41432799">next</a><span>|</span><label class="collapse" for="c-41433471">[-]</label><label class="expand" for="c-41433471">[2 more]</label></div><br/><div class="children"><div class="content">Pitchfork? As in something that might be used to search a haystack?? How delightful.</div><br/><div id="41435685" class="c"><input type="checkbox" id="c-41435685" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433471">parent</a><span>|</span><a href="#41432799">next</a><span>|</span><label class="collapse" for="c-41435685">[-]</label><label class="expand" for="c-41435685">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that’s one type.<p>Another is for turning soil at a small scale by hand (also called a cultivator, I think).<p>But they all have somewhat long prongs.</div><br/></div></div></div></div></div></div><div id="41432799" class="c"><input type="checkbox" id="c-41432799" checked=""/><div class="controls bullet"><span class="by">tripzilch</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432278">parent</a><span>|</span><a href="#41432518">prev</a><span>|</span><a href="#41432316">next</a><span>|</span><label class="collapse" for="c-41432799">[-]</label><label class="expand" for="c-41432799">[3 more]</label></div><br/><div class="children"><div class="content">I learned from bash.org that &quot;tar -xzvf&quot; is in German accent for &quot;xtract ze vucking files&quot;.</div><br/><div id="41443427" class="c"><input type="checkbox" id="c-41443427" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432799">parent</a><span>|</span><a href="#41440301">next</a><span>|</span><label class="collapse" for="c-41443427">[-]</label><label class="expand" for="c-41443427">[1 more]</label></div><br/><div class="children"><div class="content">Party pooper checking in: easier to remember is that v is the verbose option in most tools, x and f you already know, z is auto-detected for as long as I remember so you don&#x27;t need to pass that. Add c for creating an archive and, congratulations, you can now do 90% of the tasks you&#x27;ll ever want to do with tar, especially defusing xkcd bombs!<p>I hadn&#x27;t heard of the German option but I love it, shame really that z is obsolete :(</div><br/></div></div><div id="41440301" class="c"><input type="checkbox" id="c-41440301" checked=""/><div class="controls bullet"><span class="by">Tmpod</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432799">parent</a><span>|</span><a href="#41443427">prev</a><span>|</span><a href="#41432316">next</a><span>|</span><label class="collapse" for="c-41440301">[-]</label><label class="expand" for="c-41440301">[1 more]</label></div><br/><div class="children"><div class="content">A classic</div><br/></div></div></div></div><div id="41432316" class="c"><input type="checkbox" id="c-41432316" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432278">parent</a><span>|</span><a href="#41432799">prev</a><span>|</span><a href="#41432153">next</a><span>|</span><label class="collapse" for="c-41432316">[-]</label><label class="expand" for="c-41432316">[9 more]</label></div><br/><div class="children"><div class="content">As far as I understood, it was part of the language before.<p>The german equivalent of the word would be probably &quot;greifbar&quot;. Being able to hold something, usually used metaphorically.</div><br/><div id="41432395" class="c"><input type="checkbox" id="c-41432395" checked=""/><div class="controls bullet"><span class="by">ManuelKiessling</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432316">parent</a><span>|</span><a href="#41432330">next</a><span>|</span><label class="collapse" for="c-41432395">[-]</label><label class="expand" for="c-41432395">[1 more]</label></div><br/><div class="children"><div class="content">Which leads to &quot;begreifbar&quot;, which I would explain&#x2F;translate (badly) with &quot;something is begreifbar if it can be understood&quot;.</div><br/></div></div><div id="41432330" class="c"><input type="checkbox" id="c-41432330" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432316">parent</a><span>|</span><a href="#41432395">prev</a><span>|</span><a href="#41432153">next</a><span>|</span><label class="collapse" for="c-41432330">[-]</label><label class="expand" for="c-41432330">[7 more]</label></div><br/><div class="children"><div class="content">&gt; able to hold<p>Would &quot;grasp&quot; work?</div><br/><div id="41433441" class="c"><input type="checkbox" id="c-41433441" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432330">parent</a><span>|</span><a href="#41432438">next</a><span>|</span><label class="collapse" for="c-41433441">[-]</label><label class="expand" for="c-41433441">[1 more]</label></div><br/><div class="children"><div class="content">Yes. &quot;Grasping for straws.&quot;</div><br/></div></div><div id="41432438" class="c"><input type="checkbox" id="c-41432438" checked=""/><div class="controls bullet"><span class="by">octocop</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432330">parent</a><span>|</span><a href="#41433441">prev</a><span>|</span><a href="#41432153">next</a><span>|</span><label class="collapse" for="c-41432438">[-]</label><label class="expand" for="c-41432438">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s closer to grip</div><br/><div id="41433301" class="c"><input type="checkbox" id="c-41433301" checked=""/><div class="controls bullet"><span class="by">trashtester</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432438">parent</a><span>|</span><a href="#41432692">next</a><span>|</span><label class="collapse" for="c-41433301">[-]</label><label class="expand" for="c-41433301">[3 more]</label></div><br/><div class="children"><div class="content">&quot;zu greifen&quot; may best translate to &quot;to grip&quot;, but &quot;grip&quot; has different mental connotations in English (it refers to mental stability, not intellectual insight).<p>The best dual purpose translation of &quot;zu greifen&quot;&#x2F;&quot;gripe&quot; (German&#x2F;Scandinavian) meaning &quot;zu begreifen&quot;&#x2F;&quot;begripe&quot;&#x2F;&quot;understand&quot; would be &quot;to grasp&quot;, which covers both physically grabbing into something and also to understand it intellectually.<p>All these words stem back to the Proto-Indo-European gʰrebʰ, which more or less completes the circle back to &quot;grep&quot;.</div><br/><div id="41434011" class="c"><input type="checkbox" id="c-41434011" checked=""/><div class="controls bullet"><span class="by">lordgrenville</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433301">parent</a><span>|</span><a href="#41432692">next</a><span>|</span><label class="collapse" for="c-41434011">[-]</label><label class="expand" for="c-41434011">[2 more]</label></div><br/><div class="children"><div class="content">related to &quot;grok&quot;?</div><br/><div id="41434522" class="c"><input type="checkbox" id="c-41434522" checked=""/><div class="controls bullet"><span class="by">trashtester</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41434011">parent</a><span>|</span><a href="#41432692">next</a><span>|</span><label class="collapse" for="c-41434522">[-]</label><label class="expand" for="c-41434522">[1 more]</label></div><br/><div class="children"><div class="content">grok
&#x2F;ɡrɒk&#x2F;<p>Origin
1960s: a word invented by Robert Heinlein (1907–88), American author.</div><br/></div></div></div></div></div></div><div id="41432692" class="c"><input type="checkbox" id="c-41432692" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432438">parent</a><span>|</span><a href="#41433301">prev</a><span>|</span><a href="#41432153">next</a><span>|</span><label class="collapse" for="c-41432692">[-]</label><label class="expand" for="c-41432692">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always related grep to grab</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41432153" class="c"><input type="checkbox" id="c-41432153" checked=""/><div class="controls bullet"><span class="by">elygre</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432278">prev</a><span>|</span><a href="#41432351">next</a><span>|</span><label class="collapse" for="c-41432153">[-]</label><label class="expand" for="c-41432153">[7 more]</label></div><br/><div class="children"><div class="content">Could I suggest that greppbarhet is more precisely translated as “the ability of being understood”?<p>(Norwegian here. Our languages are similar, but we miss this one.)</div><br/><div id="41433372" class="c"><input type="checkbox" id="c-41433372" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432153">parent</a><span>|</span><a href="#41432624">next</a><span>|</span><label class="collapse" for="c-41433372">[-]</label><label class="expand" for="c-41433372">[4 more]</label></div><br/><div class="children"><div class="content">Norwegian still translates grep as &quot;grip&quot;&#x2F;&quot;grab&quot;.  I always thought of grepping as reaching in with a hand into the text and grabbing lines.  That association is close at hand (insert lame chuckle) for German and English speakers too.</div><br/><div id="41433458" class="c"><input type="checkbox" id="c-41433458" checked=""/><div class="controls bullet"><span class="by">pbhjpbhj</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433372">parent</a><span>|</span><a href="#41432624">next</a><span>|</span><label class="collapse" for="c-41433458">[-]</label><label class="expand" for="c-41433458">[3 more]</label></div><br/><div class="children"><div class="content">In English that association is going to depend a lot on one&#x27;s accent; until now I&#x27;ve never associated grep-ing with anything other than using grep! (But, equally, that might just be a me thing.)</div><br/><div id="41433892" class="c"><input type="checkbox" id="c-41433892" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433458">parent</a><span>|</span><a href="#41434316">next</a><span>|</span><label class="collapse" for="c-41433892">[-]</label><label class="expand" for="c-41433892">[1 more]</label></div><br/><div class="children"><div class="content">It doesn’t sound anything like grip in my accent but for some reason the association has always been there for me. Grabbing or ripping parts from the file.</div><br/></div></div><div id="41434316" class="c"><input type="checkbox" id="c-41434316" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433458">parent</a><span>|</span><a href="#41433892">prev</a><span>|</span><a href="#41432624">next</a><span>|</span><label class="collapse" for="c-41434316">[-]</label><label class="expand" for="c-41434316">[1 more]</label></div><br/><div class="children"><div class="content">What about <i>groping</i>? Groping around for text.</div><br/></div></div></div></div></div></div><div id="41432624" class="c"><input type="checkbox" id="c-41432624" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432153">parent</a><span>|</span><a href="#41433372">prev</a><span>|</span><a href="#41432351">next</a><span>|</span><label class="collapse" for="c-41432624">[-]</label><label class="expand" for="c-41432624">[2 more]</label></div><br/><div class="children"><div class="content">So, at the extrem opposite of the esoteric &quot;general regular expression print&quot; that grep stands for with few ever knowing it?</div><br/><div id="41433098" class="c"><input type="checkbox" id="c-41433098" checked=""/><div class="controls bullet"><span class="by">johncoltrane</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432624">parent</a><span>|</span><a href="#41432351">next</a><span>|</span><label class="collapse" for="c-41433098">[-]</label><label class="expand" for="c-41433098">[1 more]</label></div><br/><div class="children"><div class="content">s&#x2F;general&#x2F;global</div><br/></div></div></div></div></div></div><div id="41432351" class="c"><input type="checkbox" id="c-41432351" checked=""/><div class="controls bullet"><span class="by">vanschelven</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432153">prev</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41432351">[-]</label><label class="expand" for="c-41432351">[8 more]</label></div><br/><div class="children"><div class="content">Begreppelijk (begrijpelijk) in Dutch</div><br/><div id="41432782" class="c"><input type="checkbox" id="c-41432782" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432351">parent</a><span>|</span><a href="#41432560">prev</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41432782">[-]</label><label class="expand" for="c-41432782">[6 more]</label></div><br/><div class="children"><div class="content">or &quot;Grijpbaar&quot; (grabbable)</div><br/><div id="41433274" class="c"><input type="checkbox" id="c-41433274" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432782">parent</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41433274">[-]</label><label class="expand" for="c-41433274">[5 more]</label></div><br/><div class="children"><div class="content">So Dutch&#x2F;German make &quot;begreif&quot; a verb, for Swedish it is just a noun (that means &quot;concept&quot;).<p>But &quot;begrijpelijk&quot; has a clone: &quot;begriplig&quot;.  An adverb based on a verb in a foreign dictionary.  There is no verb that goes &quot;begreppa&quot;, it&#x27;s just &quot;greppa&quot;.</div><br/><div id="41434463" class="c"><input type="checkbox" id="c-41434463" checked=""/><div class="controls bullet"><span class="by">fedder</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433274">parent</a><span>|</span><a href="#41434700">next</a><span>|</span><label class="collapse" for="c-41434463">[-]</label><label class="expand" for="c-41434463">[1 more]</label></div><br/><div class="children"><div class="content">The term concept itself suggests grasping or holding&#x2F;taking hold of, see the latin verb concipio or adjective conceptus.</div><br/></div></div><div id="41434700" class="c"><input type="checkbox" id="c-41434700" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433274">parent</a><span>|</span><a href="#41434463">prev</a><span>|</span><a href="#41433337">next</a><span>|</span><label class="collapse" for="c-41434700">[-]</label><label class="expand" for="c-41434700">[1 more]</label></div><br/><div class="children"><div class="content">Dutch also has a noun (&quot;begrip&quot;) meaning &quot;notion&quot; or &quot;understanding&quot;.</div><br/></div></div><div id="41433337" class="c"><input type="checkbox" id="c-41433337" checked=""/><div class="controls bullet"><span class="by">trashtester</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433274">parent</a><span>|</span><a href="#41434700">prev</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41433337">[-]</label><label class="expand" for="c-41433337">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Jag kan inte begripa svenska.&quot;</div><br/><div id="41433385" class="c"><input type="checkbox" id="c-41433385" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433337">parent</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41433385">[-]</label><label class="expand" for="c-41433385">[1 more]</label></div><br/><div class="children"><div class="content">Oh, you&#x27;re right.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41432453" class="c"><input type="checkbox" id="c-41432453" checked=""/><div class="controls bullet"><span class="by">octocop</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432351">prev</a><span>|</span><a href="#41432549">next</a><span>|</span><label class="collapse" for="c-41432453">[-]</label><label class="expand" for="c-41432453">[3 more]</label></div><br/><div class="children"><div class="content">And we also have &quot;begrepp&quot;, which is also a spin on content and understanding it&#x27;s content.</div><br/><div id="41433140" class="c"><input type="checkbox" id="c-41433140" checked=""/><div class="controls bullet"><span class="by">majewsky</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432453">parent</a><span>|</span><a href="#41432549">next</a><span>|</span><label class="collapse" for="c-41433140">[-]</label><label class="expand" for="c-41433140">[2 more]</label></div><br/><div class="children"><div class="content">Oh, that&#x27;s like German &quot;begreifen&quot;, no? (Which means &quot;to grok&quot;.)</div><br/><div id="41433178" class="c"><input type="checkbox" id="c-41433178" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433140">parent</a><span>|</span><a href="#41432549">next</a><span>|</span><label class="collapse" for="c-41433178">[-]</label><label class="expand" for="c-41433178">[1 more]</label></div><br/><div class="children"><div class="content">Grok is right!  I&#x27;d translate Swedish &quot;greppbar&quot; directly as &quot;grokkable&quot;; &quot;att greppa&quot; as &quot;to grok&quot;.</div><br/></div></div></div></div></div></div><div id="41432549" class="c"><input type="checkbox" id="c-41432549" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432453">prev</a><span>|</span><a href="#41433410">next</a><span>|</span><label class="collapse" for="c-41432549">[-]</label><label class="expand" for="c-41432549">[3 more]</label></div><br/><div class="children"><div class="content">Which is ironic, given that the article is about making it easier to use grep <i>in order to avoid having to understand anything</i>.</div><br/><div id="41433006" class="c"><input type="checkbox" id="c-41433006" checked=""/><div class="controls bullet"><span class="by">bob88jg</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432549">parent</a><span>|</span><a href="#41433410">next</a><span>|</span><label class="collapse" for="c-41433006">[-]</label><label class="expand" for="c-41433006">[2 more]</label></div><br/><div class="children"><div class="content">Nah, you&#x27;ve got it backwards. The article isn&#x27;t about dodging understanding - it&#x27;s about making it way easier to spot patterns in your code. And that&#x27;s exactly how you start to really get what&#x27;s going on under the hood. Better searching = faster learning. It&#x27;s like having a good map when you&#x27;re exploring a new city</div><br/><div id="41434999" class="c"><input type="checkbox" id="c-41434999" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41433006">parent</a><span>|</span><a href="#41433410">next</a><span>|</span><label class="collapse" for="c-41434999">[-]</label><label class="expand" for="c-41434999">[1 more]</label></div><br/><div class="children"><div class="content">The article advocates making code harder to understand for the sake of better search. It&#x27;s like forcing a city to conform to a nice, clean, readable map: it&#x27;ll make exploring easier for you, at the cost of making the city stop working.</div><br/></div></div></div></div></div></div><div id="41433410" class="c"><input type="checkbox" id="c-41433410" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432549">prev</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41433410">[-]</label><label class="expand" for="c-41433410">[1 more]</label></div><br/><div class="children"><div class="content">Graspability. ;)<p>More customarily: intelligibility.</div><br/></div></div></div></div><div id="41431090" class="c"><input type="checkbox" id="c-41431090" checked=""/><div class="controls bullet"><span class="by">adpirz</span><span>|</span><a href="#41432094">prev</a><span>|</span><a href="#41431049">next</a><span>|</span><label class="collapse" for="c-41431090">[-]</label><label class="expand" for="c-41431090">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen some pretty wild conditional string interpolation where there were like 3-4 separate phrases that each had a number of different options, something akin to `${a ? &#x27;You&#x27; : &#x27;we&#x27;} {b ? &#x27;did&#x27; : &#x27;will do&#x27; } {c ? &#x27;thing&#x27; : &#x27;things&#x27; }`.<p>When I was first onboarding to this project, I was tasked with updating a component and simply tried to find three of the words I saw in the UI, and this was before we implemented a straightforward path-based routing system. It took me far too long just to find what I was going to be working on, and that&#x27;s the day I distinctly remember learning this lesson. I was pretty junior, but I&#x27;d later return to this code and threw it all away for a number of easily greppable strings.</div><br/><div id="41431387" class="c"><input type="checkbox" id="c-41431387" checked=""/><div class="controls bullet"><span class="by">ctxc</span><span>|</span><a href="#41431090">parent</a><span>|</span><a href="#41431049">next</a><span>|</span><label class="collapse" for="c-41431387">[-]</label><label class="expand" for="c-41431387">[5 more]</label></div><br/><div class="children"><div class="content">Tangential: I love it when UIs say &quot;1 object&quot; and &quot;2 objects&quot;. Shows attention to detail.<p>As opposed to &quot;1 objects&quot; or &quot;1 object(s)&quot;. 
A UI filled with &quot;(s)&quot;, ughh</div><br/><div id="41433437" class="c"><input type="checkbox" id="c-41433437" checked=""/><div class="controls bullet"><span class="by">gnuvince</span><span>|</span><a href="#41431090">root</a><span>|</span><a href="#41431387">parent</a><span>|</span><a href="#41431667">next</a><span>|</span><label class="collapse" for="c-41433437">[-]</label><label class="expand" for="c-41433437">[1 more]</label></div><br/><div class="children"><div class="content">I like the more robotic &quot;Objects: 1&quot; or &quot;Objects: 2&quot;, since it avoids the pluralization problems entirely (e.g., in French 0 is singular, but in English it&#x27;s plural; some words have special when pluralized, such as child -&gt; children or attorney general -&gt; attorneys general). And related to this article, it&#x27;s more greppable&#x2F;awkable, e.g. `awk &#x2F;^Objects:&#x2F; &amp;&amp; $2 &gt; 10`.</div><br/></div></div><div id="41431667" class="c"><input type="checkbox" id="c-41431667" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#41431090">root</a><span>|</span><a href="#41431387">parent</a><span>|</span><a href="#41433437">prev</a><span>|</span><a href="#41435309">next</a><span>|</span><label class="collapse" for="c-41431667">[-]</label><label class="expand" for="c-41431667">[1 more]</label></div><br/><div class="children"><div class="content">Moreso when it&#x27;s not tripped up by &quot;1 sheeps&quot; or &quot;1 diagnoses&quot;.</div><br/></div></div><div id="41435309" class="c"><input type="checkbox" id="c-41435309" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41431090">root</a><span>|</span><a href="#41431387">parent</a><span>|</span><a href="#41431667">prev</a><span>|</span><a href="#41434839">next</a><span>|</span><label class="collapse" for="c-41435309">[-]</label><label class="expand" for="c-41435309">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you&#x27;re going to have a bad time<p><a href="https:&#x2F;&#x2F;www.foo.be&#x2F;docs&#x2F;tpj&#x2F;issues&#x2F;vol4_1&#x2F;tpj0401-0013.html" rel="nofollow">https:&#x2F;&#x2F;www.foo.be&#x2F;docs&#x2F;tpj&#x2F;issues&#x2F;vol4_1&#x2F;tpj0401-0013.html</a></div><br/></div></div><div id="41434839" class="c"><input type="checkbox" id="c-41434839" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41431090">root</a><span>|</span><a href="#41431387">parent</a><span>|</span><a href="#41435309">prev</a><span>|</span><a href="#41431049">next</a><span>|</span><label class="collapse" for="c-41434839">[-]</label><label class="expand" for="c-41434839">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact - I had to localize this kind of logic to my language (Polish). I realized quickly it&#x27;s fucked up.<p>This is roughly the logic:<p><pre><code>    function strFromNumOfObjects(n) {
      if (n === 1) {
          return &quot;obiekt&quot;;
      }
      let last_digit = (n%10);
      let penultimate_digit = Math.trunc((n%100)&#x2F;10);
      if ((penultimate_digit == 0 || penultimate_digit &gt;= 2) &amp;&amp; last_digit &gt; 1 &amp;&amp; last_digit &lt;= 4) {
          return &quot;obiekty&quot;;
      }
      return &quot;obiektów&quot;;
    }
</code></pre>
Basically pluralizing words in Polish is a fizz-buzz problem :) In other Slavic languages it should be similar BTW</div><br/></div></div></div></div></div></div><div id="41431049" class="c"><input type="checkbox" id="c-41431049" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41431090">prev</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41431049">[-]</label><label class="expand" for="c-41431049">[17 more]</label></div><br/><div class="children"><div class="content">This is the reason many coding styles and tools (including the Linux kernel coding style and the default Rust style as implemented in rustfmt) do not break string constants across lines even if they&#x27;re longer than the desired line length: you might see the string in the program&#x27;s output, and want to search for the same string in the code to find where it gets shown.</div><br/><div id="41431124" class="c"><input type="checkbox" id="c-41431124" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#41431049">parent</a><span>|</span><a href="#41440889">next</a><span>|</span><label class="collapse" for="c-41431124">[-]</label><label class="expand" for="c-41431124">[14 more]</label></div><br/><div class="children"><div class="content">My team drives me bonkers with this.  They hear the general principle &quot;really long lines of code are bad&quot;, but extrapolate it to &quot;no characters shall pass the soft gutter no matter what&quot;.<p>Even if you have, say, 5 sequential related structs, that are all virtually identical, all written on one line so that the similarities and differences are obvious at a mere glance...  Then someone comes through and touches my file, and while they&#x27;re at it, &quot;fix&quot; the line that went 2 characters past the 80 mark by reformatting the 4th struct to span several lines.   Now when you see that list of structs, you wonder &quot;why is this one different?&quot;  and you have to read carefully to determine, nope, it just contained one longer string.  Or god forbid the reformat all the structs to match, turning a 1-page file into 3 pages, and making it so you have to read and understand each element of each struct just to see what&#x27;s going on.<p>If I could have written the rule of thumb, I would have said &quot;No logic or control shall happen after the end of the gutter.&quot;  But if there&#x27;s a paragraph-long string on one line-  who cares??  We all have a single keystroke that can toggle soft-wrap, and the odds that you&#x27;re going to need to know anything about that string other than &quot;it&#x27;s a long string&quot; are virtually nil.<p>Sorry.   I got triggered.  :-)</div><br/><div id="41431210" class="c"><input type="checkbox" id="c-41431210" checked=""/><div class="controls bullet"><span class="by">BigJono</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431166">next</a><span>|</span><label class="collapse" for="c-41431210">[-]</label><label class="expand" for="c-41431210">[2 more]</label></div><br/><div class="children"><div class="content">Yep this triggers the fuck out of me too. It drives me absolutely insane when I&#x27;m taking the time and effort to write good test cases that use inline per test data that I&#x27;ve taken the time to format so it&#x27;s nice and readable for the next person, then the next person comes along, spends 30 seconds writing some 2 line rubbish to hit a code coverage metric, then spends another 60 seconds adding a linter rule that blows all the test data out to 400 lines of unreadable dogshit that uses only the left 15% of screen real estate.</div><br/><div id="41432765" class="c"><input type="checkbox" id="c-41432765" checked=""/><div class="controls bullet"><span class="by">port19</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431210">parent</a><span>|</span><a href="#41431166">next</a><span>|</span><label class="collapse" for="c-41432765">[-]</label><label class="expand" for="c-41432765">[1 more]</label></div><br/><div class="children"><div class="content">I routinely spot 3-line prints with the string on its own line in our code. Even for cases where the string + print don&#x27;t even reach the 80 character &quot;limit&quot;</div><br/></div></div></div></div><div id="41431166" class="c"><input type="checkbox" id="c-41431166" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431210">prev</a><span>|</span><a href="#41431333">next</a><span>|</span><label class="collapse" for="c-41431166">[-]</label><label class="expand" for="c-41431166">[1 more]</label></div><br/><div class="children"><div class="content">My team also had a similar thing in place.  I am saving this article in my pocket saves, so that I can give &quot;proofs&quot; of why this is better<p>From Zen of Python:  
```
Special cases aren&#x27;t special enough to break the rules.
Although practicality beats purity.
```
<a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0020&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0020&#x2F;</a></div><br/></div></div><div id="41431333" class="c"><input type="checkbox" id="c-41431333" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431166">prev</a><span>|</span><a href="#41434663">next</a><span>|</span><label class="collapse" for="c-41431333">[-]</label><label class="expand" for="c-41431333">[4 more]</label></div><br/><div class="children"><div class="content">This is why autoformatters that frob with line endings are just terrible and fundamentally broken.<p>I&#x27;m fairly firmly in the &quot;wrap at 80&quot; camp by the way; but sometimes a tad longer just makes sense. Or shorter for that matter: forced removal of line breaks is just as bad.</div><br/><div id="41431943" class="c"><input type="checkbox" id="c-41431943" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431333">parent</a><span>|</span><a href="#41434663">next</a><span>|</span><label class="collapse" for="c-41431943">[-]</label><label class="expand" for="c-41431943">[3 more]</label></div><br/><div class="children"><div class="content">80 feels really impractically narrow. A project I work on uses 110 because it&#x27;s approximately the widest you can comfortably compare two revisions on the same monitor, or was for some person at some time, and I can live with it, but any less would just feel so cramped. A few indentation levels deep and I&#x27;d be writing newspaper columns.</div><br/><div id="41440043" class="c"><input type="checkbox" id="c-41440043" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431943">parent</a><span>|</span><a href="#41432380">next</a><span>|</span><label class="collapse" for="c-41440043">[-]</label><label class="expand" for="c-41440043">[1 more]</label></div><br/><div class="children"><div class="content">80 lines wide is the width we had back in the late 90s.  Displays are nothing like that anymore.  I managed to talk my team into setting the linter to something more reasonable, but individuals still feel like they&#x27;re being virtuous if they stick to 80 and reformat any line they touch that goes over.  It&#x27;s just dogma!</div><br/></div></div><div id="41432380" class="c"><input type="checkbox" id="c-41432380" checked=""/><div class="controls bullet"><span class="by">NotMichaelBay</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431943">parent</a><span>|</span><a href="#41440043">prev</a><span>|</span><a href="#41434663">next</a><span>|</span><label class="collapse" for="c-41432380">[-]</label><label class="expand" for="c-41432380">[1 more]</label></div><br/><div class="children"><div class="content">There is usually a way to restructure the code so that it doesn&#x27;t have multiple levels of nested indentation, which is a good practice IMO because it makes the code easier to read.</div><br/></div></div></div></div></div></div><div id="41434663" class="c"><input type="checkbox" id="c-41434663" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431333">prev</a><span>|</span><a href="#41432161">next</a><span>|</span><label class="collapse" for="c-41434663">[-]</label><label class="expand" for="c-41434663">[2 more]</label></div><br/><div class="children"><div class="content">I have been places where we allow long strings, but other things aren’t allowed and generally 80 to 100 char limits otherwise. I like 100 for c++&#x2F;java and 80 for C. If it gets much longer than that (not being strings) then it’s time for a rethink in most cases, grouping&#x2F;scoping symbols are getting too deep. I’m sure other languages may or may not have that as a reasonable argument. It is just a rule of thumb though.</div><br/></div></div><div id="41432161" class="c"><input type="checkbox" id="c-41432161" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41434663">prev</a><span>|</span><a href="#41440889">next</a><span>|</span><label class="collapse" for="c-41432161">[-]</label><label class="expand" for="c-41432161">[4 more]</label></div><br/><div class="children"><div class="content">This is world autoformatters have wrought. The central dogma of the autoformatter is that &quot;formatting&quot; is based on dumb syntactic rules with no inflow of imprecise human judgements.</div><br/><div id="41432239" class="c"><input type="checkbox" id="c-41432239" checked=""/><div class="controls bullet"><span class="by">scrollaway</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41432161">parent</a><span>|</span><a href="#41440889">next</a><span>|</span><label class="collapse" for="c-41432239">[-]</label><label class="expand" for="c-41432239">[3 more]</label></div><br/><div class="children"><div class="content">Most autoformatters do not reformat string constants as GP has said, and even if they did, this is something that can be much more accurately and correctly specified with an AF than with a human.<p>Autoformatting collectively saves probably close to millions of work hours per year in our industry, and that’s at the current adoption. Do you think it’s productive to manually space things out, clean up missing trailing commas and what not? Machines do it better.</div><br/><div id="41432309" class="c"><input type="checkbox" id="c-41432309" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41432239">parent</a><span>|</span><a href="#41440889">next</a><span>|</span><label class="collapse" for="c-41432309">[-]</label><label class="expand" for="c-41432309">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Even if you have, say, 5 sequential related structs, that are all virtually identical, all written on one line so that the similarities and differences are obvious at a mere glance... Then someone comes through and touches my file, and while they&#x27;re at it, &quot;fix&quot; the line that went 2 characters past the 80 mark by reformatting the 4th struct to span several lines.<p>Autoformatters absolutely do this. They do not understand considerations like symmetry.<p>I am doubtful as to the costs of &quot;somewhere in the codebase there is a missing trailing comma&quot;.</div><br/><div id="41441281" class="c"><input type="checkbox" id="c-41441281" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41432309">parent</a><span>|</span><a href="#41440889">next</a><span>|</span><label class="collapse" for="c-41441281">[-]</label><label class="expand" for="c-41441281">[1 more]</label></div><br/><div class="children"><div class="content">The wins of autoformatting are 1) never having to have a dispute over formatting or have formatting depend on who last touched code, 2) never manually formatting code or depending on someone&#x27;s editor configuration, 3) having CI verify formatting, and 4) not having someone (intentionally or unintentionally) make unrelated formatting changes in a commit.<p>Also, autoformatters can be remarkably good. For instance, rustfmt will do things like:<p><pre><code>    x.func(Some(MyStruct {
        field: big + long + expr,
        field2,
    }));
</code></pre>
rather than mindlessly introducing three levels of indentation.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41440889" class="c"><input type="checkbox" id="c-41440889" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#41431049">parent</a><span>|</span><a href="#41431124">prev</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41440889">[-]</label><label class="expand" for="c-41440889">[2 more]</label></div><br/><div class="children"><div class="content">If I recall, rustfmt had a bug where long string literals (say, over 120 chars or so — or maybe if it was that the string was long enough to extend beyond the gutter when properly indented?) would prevent formatting of the entire file they were in. Has this been fixed?</div><br/><div id="41441297" class="c"><input type="checkbox" id="c-41441297" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41440889">parent</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41441297">[-]</label><label class="expand" for="c-41441297">[1 more]</label></div><br/><div class="children"><div class="content">Not the whole file, but sufficiently long un-line-breakable code in a complex statement can cause rustfmt to give up on trying to format <i>that statement</i>. That&#x27;s a known issue that needs fixing.</div><br/></div></div></div></div></div></div><div id="41431114" class="c"><input type="checkbox" id="c-41431114" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41431049">prev</a><span>|</span><a href="#41437847">next</a><span>|</span><label class="collapse" for="c-41431114">[-]</label><label class="expand" for="c-41431114">[146 more]</label></div><br/><div class="children"><div class="content">Rust and Javascript and Lisp all get extra points because they put a keyword in front of every function definition. Searching for “fn doTheThing” or “defun do-the-thing” ensures that you find the actual definition. Meanwhile C lacks any such keyword, so the best you can do is search for the name. That gets you a sea of callers with the declarations and definitions mixed in. Some C coding conventions have you split the definition into two lines, first the return type on a line followed by a second line that starts with the function name. It looks ugly, but at least you can search for “^doTheThing” to find just the definition(s).</div><br/><div id="41431417" class="c"><input type="checkbox" id="c-41431417" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431546">next</a><span>|</span><label class="collapse" for="c-41431417">[-]</label><label class="expand" for="c-41431417">[39 more]</label></div><br/><div class="children"><div class="content">Golang has a similar property as a side-effect of the following design decision.<p><pre><code>  ... the language has been designed to be easy to analyze and can be parsed without a symbol table
</code></pre>
Taken from  <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq</a><p>The &quot;top-level declarations&quot; in source files are exactly: package, import, const, var, type, func. Nothing else. If you&#x27;re searching for a function, it&#x27;s always going to start with &quot;func&quot;, even if it&#x27;s an anonymous function. Searching for methods implemented by a struct similarly only needs one to know the &quot;func&quot; keyword and the name of the struct.<p>Coming from a background of mostly Clojure, Common Lisp, and TypeScript, the &quot;greppability&quot; of Go code is by far the best I have seen.<p>Of course, in any language, Go included, it&#x27;s always better to rely on static analysis tools (like the IDE or LSP server) to find references, definitions, etc. But when searching code of some open source library, I always resort to ripgrep rather than setting up a development environment, unless I found something that I want to patch (which in case I set up the devlopment environment and rely on LSP instead of grep to discover definitions and references).</div><br/><div id="41433880" class="c"><input type="checkbox" id="c-41433880" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41443247">next</a><span>|</span><label class="collapse" for="c-41433880">[-]</label><label class="expand" for="c-41433880">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not so sure about greppability in the context of Go. At least at Google (where Go originates, and whose style guide presumably has strong influence on other organizations&#x27; use of the language), we discourage &quot;stuttering&quot;:<p>&gt; A piece of Go source code should avoid unnecessary repetition. One common source of this is repetitive names, which often include unnecessary words or repeat their context or type. Code itself can also be unnecessarily repetitive if the same or a similar code segment appears multiple times in close proximity.<p><a href="https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;go&#x2F;decisions#repetitive-with-package" rel="nofollow">https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;go&#x2F;decisions#repetitive-...</a><p>(see also <a href="https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;go&#x2F;best-practices#avoid-repetition" rel="nofollow">https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;go&#x2F;best-practices#avoid-...</a>)<p>This is the style rule that motivates the sibling comment about method names being split between method and receiver, for what it&#x27;s worth.<p>I don&#x27;t think this use case has received much attention internally, since it&#x27;s fairly rare at Google to use grep directly to navigate code. As you suggest, it&#x27;s much more common to either use your IDE with LSP integration, or Code Search (which you can get a sense of via Chromium&#x27;s public repository, e.g. <a href="https:&#x2F;&#x2F;source.chromium.org&#x2F;search?q=v8&amp;sq=&amp;ss=chromium%2Fchromium%2Fsrc" rel="nofollow">https:&#x2F;&#x2F;source.chromium.org&#x2F;search?q=v8&amp;sq=&amp;ss=chromium%2Fch...</a>).</div><br/><div id="41437417" class="c"><input type="checkbox" id="c-41437417" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433880">parent</a><span>|</span><a href="#41443247">next</a><span>|</span><label class="collapse" for="c-41437417">[-]</label><label class="expand" for="c-41437417">[2 more]</label></div><br/><div class="children"><div class="content">The thing about stuttering is that the first part of the name is fixed anyway, MOST of the time.<p>If you want to search for `url.Parse`, you can find most of the usages just by searching for `url.Parse`, because the package will generally be imported as `url` (and you won’t import Parse into your namespace).<p>It’s not as good as find references via LSP but it is like 99% accurate and works with just grep.</div><br/><div id="41440002" class="c"><input type="checkbox" id="c-41440002" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41437417">parent</a><span>|</span><a href="#41443247">next</a><span>|</span><label class="collapse" for="c-41440002">[-]</label><label class="expand" for="c-41440002">[1 more]</label></div><br/><div class="children"><div class="content">That works somewhat for finding uses of a native Go module, although I&#x27;ve seen lots of cases where the module name is autogenerated and so you need to import with an alias (protobufs, I&#x27;m looking at you). It also doesn&#x27;t work quite so well in reverse -- you need to find files with `package url;`, then find instances of &#x27;\bfunc Parse\(&#x27;.<p>Lastly, one of the bigger issues is (as aforementioned sibling commenter mentioned) the application of this principle to methods. This is especially bad with method names for established interfaces, like Write or String. Even with a LSP server, you then need to trace up the call stack to figure out what concrete types the function is being called with, then look at the definitions of those types. I can&#x27;t imagine wanting to do that with only (rip)grep at my disposal.</div><br/></div></div></div></div></div></div><div id="41443247" class="c"><input type="checkbox" id="c-41443247" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41433880">prev</a><span>|</span><a href="#41432693">next</a><span>|</span><label class="collapse" for="c-41443247">[-]</label><label class="expand" for="c-41443247">[1 more]</label></div><br/><div class="children"><div class="content">Go is horrible due to the absence of specific &quot;interface implementation&quot; markers. Gets pretty hard to find where or how a type implements an interface.</div><br/></div></div><div id="41432693" class="c"><input type="checkbox" id="c-41432693" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41443247">prev</a><span>|</span><a href="#41439067">next</a><span>|</span><label class="collapse" for="c-41432693">[-]</label><label class="expand" for="c-41432693">[9 more]</label></div><br/><div class="children"><div class="content">The culture of single letter variables in golang, at least in the codebases I&#x27;ve seen, undoes this.</div><br/><div id="41433450" class="c"><input type="checkbox" id="c-41433450" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432693">parent</a><span>|</span><a href="#41432988">next</a><span>|</span><label class="collapse" for="c-41433450">[-]</label><label class="expand" for="c-41433450">[1 more]</label></div><br/><div class="children"><div class="content">Single letter variables in Golang are to be used in small, local contexts. Akin to the throwaway i var in for loops. You only grep the struct methods, the same way no one greps &#x27;this&#x27; or &#x27;self&#x27;.<p>The code bases you&#x27;ve been reading, and even some of the native libraries, don&#x27;t do it properly. Probably due to legacy reasons that wouldn&#x27;t pass readability approvals nowadays.</div><br/></div></div><div id="41432988" class="c"><input type="checkbox" id="c-41432988" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432693">parent</a><span>|</span><a href="#41433450">prev</a><span>|</span><a href="#41432831">next</a><span>|</span><label class="collapse" for="c-41432988">[-]</label><label class="expand" for="c-41432988">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The culture of single letter variables in golang, at least in the codebases I&#x27;ve seen, undoes this.<p>The convention, not just in Go, is that the smaller the scope, the smaller the variable reference.<p>So, sure, you&#x27;re going to see single-letter variables in short functions, inside short block scopes, etc, but that is true of almost any language.<p>I haven&#x27;t seen single-letter variables in Go that are in a scope that <i>isn&#x27;t</i> short.<p>Of course, this could just mean that I haven&#x27;t seen enough of other peoples Go source.</div><br/><div id="41435484" class="c"><input type="checkbox" id="c-41435484" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432988">parent</a><span>|</span><a href="#41435397">next</a><span>|</span><label class="collapse" for="c-41435484">[-]</label><label class="expand" for="c-41435484">[1 more]</label></div><br/><div class="children"><div class="content">Zipf&#x27;s law, right - these rules are a formalization of our brain&#x27;s functionality with language.<p>Of course, with enough code, someone does everything.</div><br/></div></div><div id="41435397" class="c"><input type="checkbox" id="c-41435397" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432988">parent</a><span>|</span><a href="#41435484">prev</a><span>|</span><a href="#41433358">next</a><span>|</span><label class="collapse" for="c-41435397">[-]</label><label class="expand" for="c-41435397">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that is true of almost any language<p>You&#x27;d be surprised how often language-local cultures break that rule on either side. And a few times it&#x27;s even an improvement.</div><br/></div></div><div id="41433358" class="c"><input type="checkbox" id="c-41433358" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432988">parent</a><span>|</span><a href="#41435397">prev</a><span>|</span><a href="#41435843">next</a><span>|</span><label class="collapse" for="c-41433358">[-]</label><label class="expand" for="c-41433358">[1 more]</label></div><br/><div class="children"><div class="content">I like using l for logger and db for database client&#x2F;pool&#x2F;handle even if there&#x27;s a wider scope. And if the bulk of a file is interacting with a single client I might call that c.</div><br/></div></div><div id="41435843" class="c"><input type="checkbox" id="c-41435843" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432988">parent</a><span>|</span><a href="#41433358">prev</a><span>|</span><a href="#41432831">next</a><span>|</span><label class="collapse" for="c-41435843">[-]</label><label class="expand" for="c-41435843">[2 more]</label></div><br/><div class="children"><div class="content">E.g. food and art are very important in Japan, so stomach is <i>i</i> and a drawing&#x2F;painting is <i>e</i>.</div><br/><div id="41437083" class="c"><input type="checkbox" id="c-41437083" checked=""/><div class="controls bullet"><span class="by">BrandoElFollito</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435843">parent</a><span>|</span><a href="#41432831">next</a><span>|</span><label class="collapse" for="c-41437083">[-]</label><label class="expand" for="c-41437083">[1 more]</label></div><br/><div class="children"><div class="content">Food is very very important in France so we call it <i>nourriture</i> :)</div><br/></div></div></div></div></div></div><div id="41432831" class="c"><input type="checkbox" id="c-41432831" checked=""/><div class="controls bullet"><span class="by">VonGallifrey</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432693">parent</a><span>|</span><a href="#41432988">prev</a><span>|</span><a href="#41439067">next</a><span>|</span><label class="collapse" for="c-41432831">[-]</label><label class="expand" for="c-41432831">[1 more]</label></div><br/><div class="children"><div class="content">The way I have seen this is that single letter variables are mostly used when declaration and (all) usages are very close together.<p>If I see a loop with i or k, v then I can be fairly confident that those are an Index or a Key Value pair. Also I probably don&#x27;t need to grep them since everything interacting with these variables is probably already on my screen.<p>Everything that has a wider scope or which would be unclear with a single letter is named with a more descriptive name.<p>Of course this is highly dependent on the people you work with, but this is the way it works on projects I have worked on.</div><br/></div></div></div></div><div id="41439067" class="c"><input type="checkbox" id="c-41439067" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41432693">prev</a><span>|</span><a href="#41432217">next</a><span>|</span><label class="collapse" for="c-41439067">[-]</label><label class="expand" for="c-41439067">[1 more]</label></div><br/><div class="children"><div class="content">In golang you get `func (someName someType) funcname`, so it&#x27;s much less greppable than languages using `func funcname`</div><br/></div></div><div id="41432217" class="c"><input type="checkbox" id="c-41432217" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41439067">prev</a><span>|</span><a href="#41431546">next</a><span>|</span><label class="collapse" for="c-41432217">[-]</label><label class="expand" for="c-41432217">[24 more]</label></div><br/><div class="children"><div class="content">Golang gets zero points from me because function receivers are declared between func and the name of the function. God ai hate this design choice and boy am I glad I can use golsp.</div><br/><div id="41433941" class="c"><input type="checkbox" id="c-41433941" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432217">parent</a><span>|</span><a href="#41440276">next</a><span>|</span><label class="collapse" for="c-41433941">[-]</label><label class="expand" for="c-41433941">[1 more]</label></div><br/><div class="children"><div class="content">I search &quot;) myFunc&quot; to find member functions. It would be nice to search &quot;c myFunc&quot;, but a parentheses works</div><br/></div></div><div id="41440276" class="c"><input type="checkbox" id="c-41440276" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432217">parent</a><span>|</span><a href="#41433941">prev</a><span>|</span><a href="#41433215">next</a><span>|</span><label class="collapse" for="c-41440276">[-]</label><label class="expand" for="c-41440276">[1 more]</label></div><br/><div class="children"><div class="content">I very rarely use literal grep at all. Perl grep is my standard goto.<p>For functions:
grep -P &#x27;^func funcName\(&#x27;<p>For methods:
grep -P &#x27;^func [^)]+\) methodName\(&#x27;</div><br/></div></div><div id="41433215" class="c"><input type="checkbox" id="c-41433215" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432217">parent</a><span>|</span><a href="#41440276">prev</a><span>|</span><a href="#41435636">next</a><span>|</span><label class="collapse" for="c-41433215">[-]</label><label class="expand" for="c-41433215">[16 more]</label></div><br/><div class="children"><div class="content">Is it just hard to get used to, or does it fundamentally make something more difficult?</div><br/><div id="41433544" class="c"><input type="checkbox" id="c-41433544" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433215">parent</a><span>|</span><a href="#41433353">next</a><span>|</span><label class="collapse" for="c-41433544">[-]</label><label class="expand" for="c-41433544">[10 more]</label></div><br/><div class="children"><div class="content">this thread is about using `grep` to find things, and this subthread is specifically about how the `func` keyword in golang makes it easy to distinguish the definition of a function from its uses, so <i>yes</i>, because `grep &#x27;func lart(&#x27;` will not find definitions of `lart` as a method.  you might end up with something like `grep &#x27;func .*) *lart(&#x27;` which is both imprecise and enough noise that you will not want to type it; you&#x27;ll have to can it in a script, with the associated losses of flexibility and transparency</div><br/><div id="41433722" class="c"><input type="checkbox" id="c-41433722" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433544">parent</a><span>|</span><a href="#41440290">next</a><span>|</span><label class="collapse" for="c-41433722">[-]</label><label class="expand" for="c-41433722">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair, I see many examples in this thread where people pass an exact string directly to grep, as you do.  I&#x27;m an avid grepper, but my grep tool [1] translates spaces to &quot;.*?&quot;, so I would just type &quot;func lart(&quot; in that example and it would work.<p>An incremental grep tool with just this one transformation rule gets you a lot more mileage out of grep.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;minad&#x2F;consult&#x2F;blob&#x2F;screenshots&#x2F;consult-line.png?raw=true">https:&#x2F;&#x2F;github.com&#x2F;minad&#x2F;consult&#x2F;blob&#x2F;screenshots&#x2F;consult-li...</a><p>EDIT: Better demo <a href="https:&#x2F;&#x2F;jumpshare.com&#x2F;s&#x2F;zMENBSr2LwwauJVjo1wS" rel="nofollow">https:&#x2F;&#x2F;jumpshare.com&#x2F;s&#x2F;zMENBSr2LwwauJVjo1wS</a></div><br/><div id="41433818" class="c"><input type="checkbox" id="c-41433818" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433722">parent</a><span>|</span><a href="#41440290">next</a><span>|</span><label class="collapse" for="c-41433818">[-]</label><label class="expand" for="c-41433818">[4 more]</label></div><br/><div class="children"><div class="content">that&#x27;s going to find all the functions that take an argument named lart or of a lart type too, but it also sounds like a thing i really want to try</div><br/><div id="41433964" class="c"><input type="checkbox" id="c-41433964" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433818">parent</a><span>|</span><a href="#41440290">next</a><span>|</span><label class="collapse" for="c-41433964">[-]</label><label class="expand" for="c-41433964">[3 more]</label></div><br/><div class="children"><div class="content">Also, anything that contains &quot;func&quot; and &quot;lart&quot; as a substring, e.g. foobar(function), blart(baz).<p>It&#x27;s not far off from my manually-constructed patterns when I want to make sure I find a function definition (and am willing to tolerate some false positives), but I personally prefer fine-grained control over when it&#x27;s in use.</div><br/><div id="41434100" class="c"><input type="checkbox" id="c-41434100" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433964">parent</a><span>|</span><a href="#41440290">next</a><span>|</span><label class="collapse" for="c-41434100">[-]</label><label class="expand" for="c-41434100">[2 more]</label></div><br/><div class="children"><div class="content">Mmh, I type &quot;func\ lart(&quot; when I need the literal string.  But it&#x27;s less often, so it&#x27;s fair that it&#x27;s slightly more to type.</div><br/><div id="41434156" class="c"><input type="checkbox" id="c-41434156" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434100">parent</a><span>|</span><a href="#41440290">next</a><span>|</span><label class="collapse" for="c-41434156">[-]</label><label class="expand" for="c-41434156">[1 more]</label></div><br/><div class="children"><div class="content">yeah!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41440290" class="c"><input type="checkbox" id="c-41440290" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433544">parent</a><span>|</span><a href="#41433722">prev</a><span>|</span><a href="#41433353">next</a><span>|</span><label class="collapse" for="c-41440290">[-]</label><label class="expand" for="c-41440290">[4 more]</label></div><br/><div class="children"><div class="content">For functions: grep -P &#x27;^func funcName\(&#x27;<p>For methods: grep -P &#x27;^func [^)]+\) methodName\(&#x27;<p>Hope that helps.</div><br/><div id="41440629" class="c"><input type="checkbox" id="c-41440629" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41440290">parent</a><span>|</span><a href="#41433353">next</a><span>|</span><label class="collapse" for="c-41440629">[-]</label><label class="expand" for="c-41440629">[3 more]</label></div><br/><div class="children"><div class="content">thanks, that definitely looks better! pcre is kind of working against you here tho; i assume you&#x27;re invoking it out of habit</div><br/><div id="41440899" class="c"><input type="checkbox" id="c-41440899" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41440629">parent</a><span>|</span><a href="#41433353">next</a><span>|</span><label class="collapse" for="c-41440899">[-]</label><label class="expand" for="c-41440899">[2 more]</label></div><br/><div class="children"><div class="content">I am actually unaware of downsides of PCRE. Could you explain? I hardly ever use literal grep nowadays.</div><br/><div id="41442588" class="c"><input type="checkbox" id="c-41442588" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41440899">parent</a><span>|</span><a href="#41433353">next</a><span>|</span><label class="collapse" for="c-41442588">[-]</label><label class="expand" for="c-41442588">[1 more]</label></div><br/><div class="children"><div class="content">oh, i mean that instead of<p><pre><code>    grep -P &#x27;^func [^)]+\) methodName\(&#x27;
</code></pre>
you could say<p><pre><code>    grep &#x27;func [^)]*) methodName(&#x27;
</code></pre>
which is a bit less typing<p>however, i have to admit that i sort of ensnared myself in my own noose here by being too clever!  i forgot that grep&#x27;s regexp dialect only supports + if you \ it, and it took me six tries to figure out why i wasn&#x27;t getting any grep hits.  there&#x27;s a lot to be said for the predictability and consistency of pcre!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41433353" class="c"><input type="checkbox" id="c-41433353" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433215">parent</a><span>|</span><a href="#41433544">prev</a><span>|</span><a href="#41433796">next</a><span>|</span><label class="collapse" for="c-41433353">[-]</label><label class="expand" for="c-41433353">[1 more]</label></div><br/><div class="children"><div class="content">Can’t say I’ve ever had an issue with it, but it does get a bit wild when you have a function signature that takes a function and returns one, unless you clear it up with some types.<p><pre><code>  func (s *Recv) foo(fn func(x any) err) func bar(y any) (*Recv, err)
</code></pre>
As an exaggerated example. Easy to parse but not always easy to read at a glance.</div><br/></div></div><div id="41433796" class="c"><input type="checkbox" id="c-41433796" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433215">parent</a><span>|</span><a href="#41433353">prev</a><span>|</span><a href="#41435636">next</a><span>|</span><label class="collapse" for="c-41433796">[-]</label><label class="expand" for="c-41433796">[4 more]</label></div><br/><div class="children"><div class="content">I have to always add wildcards between func and the function name, because I can never know how the other developer has decided to specify the name of the receiver. This will always be a problem as far as grepping with primitive tools that don&#x27;t parse the language.</div><br/><div id="41434211" class="c"><input type="checkbox" id="c-41434211" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433796">parent</a><span>|</span><a href="#41435636">next</a><span>|</span><label class="collapse" for="c-41434211">[-]</label><label class="expand" for="c-41434211">[3 more]</label></div><br/><div class="children"><div class="content">FYI, many people use thin wrappers like this, it&#x27;s still a primitive tool that doesn&#x27;t parse the language, but it can handle that problem: <a href="https:&#x2F;&#x2F;jumpshare.com&#x2F;s&#x2F;zMENBSr2LwwauJVjo1wS" rel="nofollow">https:&#x2F;&#x2F;jumpshare.com&#x2F;s&#x2F;zMENBSr2LwwauJVjo1wS</a> (GIF)</div><br/><div id="41434334" class="c"><input type="checkbox" id="c-41434334" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434211">parent</a><span>|</span><a href="#41435636">next</a><span>|</span><label class="collapse" for="c-41434334">[-]</label><label class="expand" for="c-41434334">[2 more]</label></div><br/><div class="children"><div class="content">On machines where I control the tooling, this is not an issue. But I can’t take my config to my colleagues machine.</div><br/><div id="41435507" class="c"><input type="checkbox" id="c-41435507" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434334">parent</a><span>|</span><a href="#41435636">next</a><span>|</span><label class="collapse" for="c-41435507">[-]</label><label class="expand" for="c-41435507">[1 more]</label></div><br/><div class="children"><div class="content">If only AFS had succeeded. What would a modern version of this look like?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41435636" class="c"><input type="checkbox" id="c-41435636" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432217">parent</a><span>|</span><a href="#41433215">prev</a><span>|</span><a href="#41435211">next</a><span>|</span><label class="collapse" for="c-41435636">[-]</label><label class="expand" for="c-41435636">[4 more]</label></div><br/><div class="children"><div class="content">Receivers are utterly idiotic. Like how could anyone with two working brain cells sign off on something like that?<p>If you don&#x27;t want OOP in the language, but want people to be able to write thing.function(arg), you just make function(thing, arg) and thing.function(arg) equivalent syntax.</div><br/><div id="41435941" class="c"><input type="checkbox" id="c-41435941" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435636">parent</a><span>|</span><a href="#41435211">next</a><span>|</span><label class="collapse" for="c-41435941">[-]</label><label class="expand" for="c-41435941">[3 more]</label></div><br/><div class="children"><div class="content">C# did this for extension methods and it Just Works.  You just add the &quot;this&quot; keyword to a function in a pure-static class and you get method-like calling on the first param of that function.</div><br/><div id="41436004" class="c"><input type="checkbox" id="c-41436004" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435941">parent</a><span>|</span><a href="#41435211">next</a><span>|</span><label class="collapse" for="c-41436004">[-]</label><label class="expand" for="c-41436004">[2 more]</label></div><br/><div class="children"><div class="content">If the function has to be modified in any way in order to grant permission to be used that way, then it is not quite &quot;did this&quot;.<p>Equivalent means that there is no difference at the AST level between o.f(a) and f(o, a), like there is no difference in C among <i>(a + i), a[i], i[a] and </i>(i + a).<p>However, a this keyword is way better than making the programmers fraction off a parameter and move it to the other side of the function name.</div><br/><div id="41437256" class="c"><input type="checkbox" id="c-41437256" checked=""/><div class="controls bullet"><span class="by">tczMUFlmoNk</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41436004">parent</a><span>|</span><a href="#41435211">next</a><span>|</span><label class="collapse" for="c-41437256">[-]</label><label class="expand" for="c-41437256">[1 more]</label></div><br/><div class="children"><div class="content">A search term here is &quot;Uniform Function Call Syntax&quot;, as present in (e.g.) D:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Uniform_Function_Call_Syntax" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Uniform_Function_Call_Syntax</a></div><br/></div></div></div></div></div></div></div></div><div id="41435211" class="c"><input type="checkbox" id="c-41435211" checked=""/><div class="controls bullet"><span class="by">executesorder66</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432217">parent</a><span>|</span><a href="#41435636">prev</a><span>|</span><a href="#41431546">next</a><span>|</span><label class="collapse" for="c-41435211">[-]</label><label class="expand" for="c-41435211">[1 more]</label></div><br/><div class="children"><div class="content">How many God AI&#x27;s have expressed their hate for this design? &#x2F;s</div><br/></div></div></div></div></div></div><div id="41431546" class="c"><input type="checkbox" id="c-41431546" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431417">prev</a><span>|</span><a href="#41432037">next</a><span>|</span><label class="collapse" for="c-41431546">[-]</label><label class="expand" for="c-41431546">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript has multiple ways to define a function so you sort of lose that getting the actual definition benefit.<p>on edit: I see someone discussed that you can grep for both arrow functions and named function at the same time and I suppose you can also construct a query that handles a function constructor as well - but this does not really handle curried functions or similar patterns - I guess at that point one is letting the perfect become the enemy of the good.<p>Most people grepping know the code base and the patterns in use, so they probably only need to grep for one type of function declaration.</div><br/></div></div><div id="41432037" class="c"><input type="checkbox" id="c-41432037" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431546">prev</a><span>|</span><a href="#41431222">next</a><span>|</span><label class="collapse" for="c-41432037">[-]</label><label class="expand" for="c-41432037">[10 more]</label></div><br/><div class="children"><div class="content">C is so much worse than that. Many people declare symbols using macros for various reasons, so you end up with things like DEFINE_FUNCTION(foo) {. In order to get a complete list of symbols you need to preprocess it, this requires knowing what the compiler flags are. Nobody really knows what their compiler flags are because they are hidden between multiple levels of indirection and a variety of build systems.</div><br/><div id="41433330" class="c"><input type="checkbox" id="c-41433330" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432037">parent</a><span>|</span><a href="#41433604">next</a><span>|</span><label class="collapse" for="c-41433330">[-]</label><label class="expand" for="c-41433330">[7 more]</label></div><br/><div class="children"><div class="content">&gt; C is so much worse than that. Many people declare symbols using macros for various reasons, so you end up with things like DEFINE_FUNCTION(foo) {.<p>That’s not really C; that’s a C-based DSL. The same problem exists with Lisp, except even worse, since its preprocessor is much more powerful, and hence encourages DSL-creation much more than C does. But in fact, it can happen with any language - even if a language lacks any built-in processor or macro facility, you can always build a custom one, or use a general purpose macro processor such as M4.<p>If you are creating a DSL, you need to create custom tooling to go along with it - ideal scenario, your tools are so customisable that supporting a DSL is more about configuration than coding something from scratch.</div><br/><div id="41435947" class="c"><input type="checkbox" id="c-41435947" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433330">parent</a><span>|</span><a href="#41433561">next</a><span>|</span><label class="collapse" for="c-41435947">[-]</label><label class="expand" for="c-41435947">[1 more]</label></div><br/><div class="children"><div class="content">If your Lisp macro starts with a symbol whose name begins with <i>def</i>, and the next symbol is a name, then good old Exuberant Ctags will index it, and you get jump to definition.<p>Not so with DEFINE_FUNCTION(foo) {, I think.<p><pre><code>  $ cat &gt; foo.lisp
  (define-musical-scale g)
  $ ctags foo.lisp
  $ grep scale tags
  g       foo.lisp        &#x2F;^(define-musical-scale g)$&#x2F;;&quot;  f
</code></pre>
Exuberant Ctags is not even a tool from the Lisp culture. I suspect it is mostly shunned by Lisp programmers. Except maybe for the Emacs one, which is different. (Same <i>ctags</i> command name, completely different software and tag file format.)</div><br/></div></div><div id="41433561" class="c"><input type="checkbox" id="c-41433561" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433330">parent</a><span>|</span><a href="#41435947">prev</a><span>|</span><a href="#41433604">next</a><span>|</span><label class="collapse" for="c-41433561">[-]</label><label class="expand" for="c-41433561">[5 more]</label></div><br/><div class="children"><div class="content">the issue is that the c preprocessor is always available and usually used</div><br/><div id="41433852" class="c"><input type="checkbox" id="c-41433852" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433561">parent</a><span>|</span><a href="#41433604">next</a><span>|</span><label class="collapse" for="c-41433852">[-]</label><label class="expand" for="c-41433852">[4 more]</label></div><br/><div class="children"><div class="content">Other languages have preprocessors or macro facilities too.<p>C&#x27;s is very weak. Languages with more powerful preprocessors&#x2F;macros than C&#x27;s include many Lisp dialects, Rust, and PL&#x2F;I. If you think everyone using a weak preprocessor is bad, wait until you see what people will do when you give them a powerful one.<p>Microfocus COBOL has an API for writing custom COBOL preprocessors in COBOL (the Integrated Preprocessor Interface). (Or some other language, if you insist.) I bet there are some bizarre abominations hidden in the bowels of various enterprises based on that (&quot;our business doesn&#x27;t just run on COBOL, it runs on our own custom dialect of COBOL!&quot;)</div><br/><div id="41434069" class="c"><input type="checkbox" id="c-41434069" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433852">parent</a><span>|</span><a href="#41433604">next</a><span>|</span><label class="collapse" for="c-41434069">[-]</label><label class="expand" for="c-41434069">[3 more]</label></div><br/><div class="children"><div class="content">c&#x27;s macro system is weak on purpose, based on, i suspect, bad experiences with m6 and m4. i think they thought it was easier to debug things like ratfor, tmg, lex, and (much later) protoc, which generate code in a more imperative paradigm for which their existing debugging approaches worked<p>i can&#x27;t say i think they were wholly wrong; paging through compiler error messages is not my favorite part of c++ templates.  but i have a certain amount of affection for what used to be called gasp, the gas macro system, which i&#x27;ve programmed for example to compute jump offsets for compiling a custom bytecode. and i think m4 is really a pathological case; most hairy macro systems aren&#x27;t even 10% as bad as m4, due to a combination of several tempting but wrong design decisions.  lots of trauma resulted<p>so when they got a do-over they eliminated the preprocessor entirely in golang, and compensated with reflection, which makes debugging easier rather than harder<p>probably old hat to you, but i just learned last month how to use x-macros in the c preprocessor to automatically generate serialization and deserialization code for record types (speaking of cobol): <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;binmsg_cpp.c" rel="nofollow">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;binmsg_cpp.c</a> (aha, i see you&#x27;re linking to a page that documents it)</div><br/><div id="41434108" class="c"><input type="checkbox" id="c-41434108" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434069">parent</a><span>|</span><a href="#41433604">next</a><span>|</span><label class="collapse" for="c-41434108">[-]</label><label class="expand" for="c-41434108">[2 more]</label></div><br/><div class="children"><div class="content">C&#x27;s is weak yet not weak – you can do various advanced things (like conditional expansion or iteration), but using esoteric voodoo with extreme performance cost. Whereas other preprocessors let you do that using builtins which are fast and easy to grok.<p>See for example <a href="https:&#x2F;&#x2F;github.com&#x2F;pfultz2&#x2F;Cloak&#x2F;wiki&#x2F;C-Preprocessor-tricks,-tips,-and-idioms">https:&#x2F;&#x2F;github.com&#x2F;pfultz2&#x2F;Cloak&#x2F;wiki&#x2F;C-Preprocessor-tricks,...</a><p>Poor C preprocessor performance has a negative real world impact, for example recently with the Linux kernel – <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;983965&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;983965&#x2F;</a> – a more powerful preprocessor would enable people to do those things they are doing anyway much more cheaply</div><br/><div id="41436671" class="c"><input type="checkbox" id="c-41436671" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434108">parent</a><span>|</span><a href="#41433604">next</a><span>|</span><label class="collapse" for="c-41436671">[-]</label><label class="expand" for="c-41436671">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always suspected the powerful macro facilities in Lisp are why it&#x27;s never been very common - the ability to do proper macros means all the very smart programmers create code that has to be read like a maths paper.  It&#x27;s too bespoke to the problem domain and too tempting to make it short rather than understandable.<p>I like Rust (tho I have not yet programmed in it) but I think if people get too into macro generated code, there is a risk there to its uptake.<p>It&#x27;s hard for smart programmers to really believe this, but the old &quot;if you write your code as cleverly as possible, you will not be able to debug it&quot; is a useful warning.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41433604" class="c"><input type="checkbox" id="c-41433604" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432037">parent</a><span>|</span><a href="#41433330">prev</a><span>|</span><a href="#41431222">next</a><span>|</span><label class="collapse" for="c-41433604">[-]</label><label class="expand" for="c-41433604">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the usefulness of macros always has to be balanced against their cost. I know of only one codebase that does this particular thing though, Emacs. It is used to define Lisp functions that are implemented in C.</div><br/><div id="41435404" class="c"><input type="checkbox" id="c-41435404" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433604">parent</a><span>|</span><a href="#41431222">next</a><span>|</span><label class="collapse" for="c-41435404">[-]</label><label class="expand" for="c-41435404">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a common pattern for just about any binding of C-implementation to a higher-level language. Python has a similar pattern, and I once had to re-invent it from scratch (not knowing any of this) for a game engine.</div><br/></div></div></div></div></div></div><div id="41431222" class="c"><input type="checkbox" id="c-41431222" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432037">prev</a><span>|</span><a href="#41431241">next</a><span>|</span><label class="collapse" for="c-41431222">[-]</label><label class="expand" for="c-41431222">[75 more]</label></div><br/><div class="children"><div class="content">Not JavaScript. Cool kids never write “function” any more, it’s all arrow functions. You can search for const, which will typically work, but not always (could be a let, var, or multi-const intializer).</div><br/><div id="41432163" class="c"><input type="checkbox" id="c-41432163" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431235">next</a><span>|</span><label class="collapse" for="c-41432163">[-]</label><label class="expand" for="c-41432163">[20 more]</label></div><br/><div class="children"><div class="content">Yes but that’s an anti pattern. Arrow functions aren’t there to look cool, they’re how you define lambdas &#x2F; anonymous functions.<p>Other than that, functions should be defined by the keyword.</div><br/><div id="41440947" class="c"><input type="checkbox" id="c-41440947" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432163">parent</a><span>|</span><a href="#41432242">next</a><span>|</span><label class="collapse" for="c-41440947">[-]</label><label class="expand" for="c-41440947">[1 more]</label></div><br/><div class="children"><div class="content">Functions and arrow functions have an important difference: arrow functions do not create their own `this`. If you&#x27;re in a context where a nested function needs to maintain access to the outer function’s `this`, and you don&#x27;t want to muck with `bind` or `call`, then you <i>need</i> an arrow function.</div><br/></div></div><div id="41432242" class="c"><input type="checkbox" id="c-41432242" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432163">parent</a><span>|</span><a href="#41440947">prev</a><span>|</span><a href="#41432449">next</a><span>|</span><label class="collapse" for="c-41432242">[-]</label><label class="expand" for="c-41432242">[17 more]</label></div><br/><div class="children"><div class="content">How is that an anti-pattern?<p>&gt; Other than that, functions should be defined by the keyword.<p>Says who?</div><br/><div id="41432615" class="c"><input type="checkbox" id="c-41432615" checked=""/><div class="controls bullet"><span class="by">hansworst</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432242">parent</a><span>|</span><a href="#41432418">next</a><span>|</span><label class="collapse" for="c-41432615">[-]</label><label class="expand" for="c-41432615">[13 more]</label></div><br/><div class="children"><div class="content">Anonymous functions don&#x27;t have names. This makes it much harder to do things like profiling (just try to find that one specific arrow function in your performance profile flame graph) and tracing. Tools like Sentry that automatically log stack traces when errors occur become much less useful if every function is anonymous.</div><br/><div id="41433235" class="c"><input type="checkbox" id="c-41433235" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432615">parent</a><span>|</span><a href="#41434286">next</a><span>|</span><label class="collapse" for="c-41433235">[-]</label><label class="expand" for="c-41433235">[11 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    const foo = () =&gt; {}
</code></pre>
This function is not anonymous, it&#x27;s called foo.</div><br/><div id="41434321" class="c"><input type="checkbox" id="c-41434321" checked=""/><div class="controls bullet"><span class="by">mrighele</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433235">parent</a><span>|</span><a href="#41433655">next</a><span>|</span><label class="collapse" for="c-41434321">[-]</label><label class="expand" for="c-41434321">[3 more]</label></div><br/><div class="children"><div class="content">Interesting, it seems that the javascript runtime is smart enough detect this pattern and actually create a named function (I tried Chrome and Node.js)<p><pre><code>    const foo = () =&gt; {}
    console.log( foo.name );
</code></pre>
actually outputs &#x27;foo&#x27;, and not the empty string that I was expecting.<p><pre><code>   const test = () =&gt; ( () =&gt; {} );
   const foo = test();
   console.log( foo.name );
</code></pre>
outputs the empty string.<p>Is this behavior required by the standard ?</div><br/><div id="41434536" class="c"><input type="checkbox" id="c-41434536" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434321">parent</a><span>|</span><a href="#41436891">next</a><span>|</span><label class="collapse" for="c-41434536">[-]</label><label class="expand" for="c-41434536">[1 more]</label></div><br/><div class="children"><div class="content">Yes, in great detail.  <a href="https:&#x2F;&#x2F;tc39.es&#x2F;ecma262&#x2F;multipage&#x2F;ordinary-and-exotic-objects-behaviours.html#sec-setfunctionname" rel="nofollow">https:&#x2F;&#x2F;tc39.es&#x2F;ecma262&#x2F;multipage&#x2F;ordinary-and-exotic-object...</a> is the specification, and for the TL;DR <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Function&#x2F;name" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a> is pretty good.</div><br/></div></div><div id="41436891" class="c"><input type="checkbox" id="c-41436891" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434321">parent</a><span>|</span><a href="#41434536">prev</a><span>|</span><a href="#41433655">next</a><span>|</span><label class="collapse" for="c-41436891">[-]</label><label class="expand" for="c-41436891">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re probably remembering how it used to work.  This is the example I remember from way back that we shouldn&#x27;t use because (aside from being unnecessary and weird) this function wouldn&#x27;t have a name in stack traces:<p><pre><code>  var foo = function() {};
</code></pre>
Except nowadays it too does have the name &quot;foo&quot;.</div><br/></div></div></div></div><div id="41433655" class="c"><input type="checkbox" id="c-41433655" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433235">parent</a><span>|</span><a href="#41434321">prev</a><span>|</span><a href="#41433619">next</a><span>|</span><label class="collapse" for="c-41433655">[-]</label><label class="expand" for="c-41433655">[5 more]</label></div><br/><div class="children"><div class="content">But to call foo in bar you must define foo before bar.<p>function foo(){} is also callable if bar is defined before foo.</div><br/><div id="41434325" class="c"><input type="checkbox" id="c-41434325" checked=""/><div class="controls bullet"><span class="by">sestep</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433655">parent</a><span>|</span><a href="#41433619">next</a><span>|</span><label class="collapse" for="c-41434325">[-]</label><label class="expand" for="c-41434325">[4 more]</label></div><br/><div class="children"><div class="content">Not true at the top-level.</div><br/><div id="41435300" class="c"><input type="checkbox" id="c-41435300" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434325">parent</a><span>|</span><a href="#41433619">next</a><span>|</span><label class="collapse" for="c-41435300">[-]</label><label class="expand" for="c-41435300">[3 more]</label></div><br/><div class="children"><div class="content">Not sure what you find not true about it. All named “function”s get hoisted just like “var”s, I use post-definitions of utility functions all the time in file scopes, function scopes, after return statements, everywhere. You’re probably thinking about<p><pre><code>  const foo = function (){}
</code></pre>
without its own name before (). These behave like expressions and cannot be hoisted.</div><br/><div id="41435559" class="c"><input type="checkbox" id="c-41435559" checked=""/><div class="controls bullet"><span class="by">MetaWhirledPeas</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435300">parent</a><span>|</span><a href="#41433619">next</a><span>|</span><label class="collapse" for="c-41435559">[-]</label><label class="expand" for="c-41435559">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I use post-definitions of utility functions all the time in file scopes, function scopes, after return statements, everywhere<p>I haven&#x27;t figured out if people consider this a best practice, but I love doing it. To me the list of called functions is a high-level explanation of the code, and listing all the definitions first just buries the high-level logic &quot;below the fold&quot;. Immediately diving into function contents outside of their broader context is confusing to me.</div><br/><div id="41435910" class="c"><input type="checkbox" id="c-41435910" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435559">parent</a><span>|</span><a href="#41433619">next</a><span>|</span><label class="collapse" for="c-41435910">[-]</label><label class="expand" for="c-41435910">[1 more]</label></div><br/><div class="children"><div class="content">I don’t monitor “best” practices, so beware. But in languages like C and Pascal I also had a habit of simply declaring all interfaces at the top and then grouping implementations reasonably. It also created a nice “index” of what’s in the file.<p>Hoisting also enables cross-imports without helper unit extraction headaches. Many hate js&#x2F;ts at the “kids hate == and null” level but in reality these languages have a very practical design that wins so many rounds irl.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41433619" class="c"><input type="checkbox" id="c-41433619" checked=""/><div class="controls bullet"><span class="by">BlarfMcFlarf</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433235">parent</a><span>|</span><a href="#41433655">prev</a><span>|</span><a href="#41434767">next</a><span>|</span><label class="collapse" for="c-41433619">[-]</label><label class="expand" for="c-41433619">[1 more]</label></div><br/><div class="children"><div class="content">Does the function know it’s called foo for tracing&#x2F;error logging&#x2F;etc?</div><br/></div></div><div id="41434767" class="c"><input type="checkbox" id="c-41434767" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433235">parent</a><span>|</span><a href="#41433619">prev</a><span>|</span><a href="#41434286">next</a><span>|</span><label class="collapse" for="c-41434767">[-]</label><label class="expand" for="c-41434767">[1 more]</label></div><br/><div class="children"><div class="content">Not really, its an anonymous function stored in a variable foo</div><br/></div></div></div></div><div id="41434286" class="c"><input type="checkbox" id="c-41434286" checked=""/><div class="controls bullet"><span class="by">mostlylikeable</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432615">parent</a><span>|</span><a href="#41433235">prev</a><span>|</span><a href="#41432418">next</a><span>|</span><label class="collapse" for="c-41434286">[-]</label><label class="expand" for="c-41434286">[1 more]</label></div><br/><div class="children"><div class="content">To me, arrow functions behave more like I would expect functions to behave. They don’t include all the magic bindings that the function keyword imparts. Feels more “pure” to me. Anonymous functions can be either function () {} or () =&gt; {}</div><br/></div></div></div></div><div id="41432418" class="c"><input type="checkbox" id="c-41432418" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432242">parent</a><span>|</span><a href="#41432615">prev</a><span>|</span><a href="#41432326">next</a><span>|</span><label class="collapse" for="c-41432418">[-]</label><label class="expand" for="c-41432418">[1 more]</label></div><br/><div class="children"><div class="content">As of a few years ago (not sure about now) the backtrace frame info for anonymous functions were far worse than ones defined via the function keyword with a name.</div><br/></div></div><div id="41432326" class="c"><input type="checkbox" id="c-41432326" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432242">parent</a><span>|</span><a href="#41432418">prev</a><span>|</span><a href="#41432449">next</a><span>|</span><label class="collapse" for="c-41432326">[-]</label><label class="expand" for="c-41432326">[2 more]</label></div><br/><div class="children"><div class="content">All the wise ones. Well, except for you maybe.<p>Serious arguments would be:<p>- readability<p>- greppability</div><br/><div id="41436943" class="c"><input type="checkbox" id="c-41436943" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432326">parent</a><span>|</span><a href="#41432449">next</a><span>|</span><label class="collapse" for="c-41436943">[-]</label><label class="expand" for="c-41436943">[1 more]</label></div><br/><div class="children"><div class="content">(It wasn&#x27;t an insult, but a joke on the username)</div><br/></div></div></div></div></div></div></div></div><div id="41431235" class="c"><input type="checkbox" id="c-41431235" checked=""/><div class="controls bullet"><span class="by">lispisok</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41432163">prev</a><span>|</span><a href="#41431272">next</a><span>|</span><label class="collapse" for="c-41431235">[-]</label><label class="expand" for="c-41431235">[29 more]</label></div><br/><div class="children"><div class="content">Am I the only one who hates arrow functions?</div><br/><div id="41431342" class="c"><input type="checkbox" id="c-41431342" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41432003">next</a><span>|</span><label class="collapse" for="c-41431342">[-]</label><label class="expand" for="c-41431342">[8 more]</label></div><br/><div class="children"><div class="content">I did, until I used them enough where I saw where they were useful.<p>The bad examples of arrow functions I saw initially were of:<p>1. Devs trying to mix them in with OOP code as a bandaid over OOP headahes (e.g. bind&#x2F;this) instead of just not using OOP in the first place.<p>2. Devs trying to stick functional programming everywhere because they had seen a trivial example where a `.map()` made more semantic sense than a for&#x2F;for-in&#x2F;for-of loop. Despite the fact that for&#x2F;for-in&#x2F;for-of loops were easier to read for anything non-trivial and also had better performance because you had access to the `break`, `continue` and `return` keywords.</div><br/><div id="41433038" class="c"><input type="checkbox" id="c-41433038" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431342">parent</a><span>|</span><a href="#41432286">next</a><span>|</span><label class="collapse" for="c-41433038">[-]</label><label class="expand" for="c-41433038">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; also had better performance because you had access to the `break`, `continue` and `return` keywords.
</code></pre>
This is a great point.<p>One more: Debugging `.map()` is also much harder than a for loop.</div><br/><div id="41433524" class="c"><input type="checkbox" id="c-41433524" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433038">parent</a><span>|</span><a href="#41432286">next</a><span>|</span><label class="collapse" for="c-41433524">[-]</label><label class="expand" for="c-41433524">[1 more]</label></div><br/><div class="children"><div class="content">I feel there are a few ways to invoke .map() in a readable way and many ways that make the code flow needlessly indirect.<p>Should be a judgment call, and the author needs to be used to doing both looping and mapping constructs, so that they are unafraid of the bit of extra typing needed for the loop.</div><br/></div></div></div></div><div id="41432286" class="c"><input type="checkbox" id="c-41432286" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431342">parent</a><span>|</span><a href="#41433038">prev</a><span>|</span><a href="#41432003">next</a><span>|</span><label class="collapse" for="c-41432286">[-]</label><label class="expand" for="c-41432286">[5 more]</label></div><br/><div class="children"><div class="content">Another benefit of using for instead of array fns is that it is easy to add await keyword should the fn become async.<p>But many teams will have it as a rule to always use array fns.</div><br/><div id="41433629" class="c"><input type="checkbox" id="c-41433629" checked=""/><div class="controls bullet"><span class="by">jappgar</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432286">parent</a><span>|</span><a href="#41432003">next</a><span>|</span><label class="collapse" for="c-41433629">[-]</label><label class="expand" for="c-41433629">[4 more]</label></div><br/><div class="children"><div class="content">That gives you have the option of making it serially async but not parallel, which can be achieved easily using Promise.all in either scenario.</div><br/><div id="41434616" class="c"><input type="checkbox" id="c-41434616" checked=""/><div class="controls bullet"><span class="by">adregan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433629">parent</a><span>|</span><a href="#41432003">next</a><span>|</span><label class="collapse" for="c-41434616">[-]</label><label class="expand" for="c-41434616">[3 more]</label></div><br/><div class="children"><div class="content">As an aside: It’s way less ergonomic, but you likely want `Promise.allSettled` rather than `Promise.all` as the first promise that throws aborts the rest.</div><br/><div id="41435385" class="c"><input type="checkbox" id="c-41435385" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434616">parent</a><span>|</span><a href="#41432003">next</a><span>|</span><label class="collapse" for="c-41435385">[-]</label><label class="expand" for="c-41435385">[2 more]</label></div><br/><div class="children"><div class="content">It doesn’t really abort the rest, it just prioritizes the selection of a first catch-path as a current continuation. The rest is still thenable, and there’s no “abort promise” operation in general. There are abort signals, but it’s up to an async process to accept a signal and decide when&#x2F;whether to check it.</div><br/><div id="41437048" class="c"><input type="checkbox" id="c-41437048" checked=""/><div class="controls bullet"><span class="by">adregan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435385">parent</a><span>|</span><a href="#41432003">next</a><span>|</span><label class="collapse" for="c-41437048">[-]</label><label class="expand" for="c-41437048">[1 more]</label></div><br/><div class="children"><div class="content">Admittedly, I was being a bit hand-wavy and describing a bit more of how it feels rather than the way it is (I&#x27;m perpetually annoyed that promises can&#x27;t be cancelled), but I was thinking of the code I&#x27;ve seen many times across many code bases:<p><pre><code>    let results;
    try {
      results = await Promise.all(vals.map(someAsyncOp))
    } catch (err) {
      console.error(err)
    }
</code></pre>
While you <i>could</i> pull that promises mapping into a variable and keep it thenable, 99% of the time I see the above instead. Promises have some rough edges because they are stateful, so I think it might be easier to recommend swapping that Promise.all for an Promise.allSettled, and using a shared utility for parsing the promise result.<p>I consider this issue akin to the relationship between `sort`, `reverse`, `splice`, the mutating operation APIs, and their non mutating counterparts `toSorted`, `toReversed`, `toSpliced`. Promise.all is kind of the mutating version of allSettled.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41432003" class="c"><input type="checkbox" id="c-41432003" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431342">prev</a><span>|</span><a href="#41431942">next</a><span>|</span><label class="collapse" for="c-41432003">[-]</label><label class="expand" for="c-41432003">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like using them <i>everywhere</i>, but they&#x27;re very handy for inline anonymous functions.<p>But it really pains me when I see<p>export const foo = () =&gt; {}<p>instead of<p>export function foo() {}</div><br/><div id="41432031" class="c"><input type="checkbox" id="c-41432031" checked=""/><div class="controls bullet"><span class="by">creesch</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432003">parent</a><span>|</span><a href="#41434288">next</a><span>|</span><label class="collapse" for="c-41432031">[-]</label><label class="expand" for="c-41432031">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, that&#x27;s something I also never have understood myself. For inline anonymous functions like callbacks they make perfect sense. As long as you don&#x27;t need `this`.<p>But everywhere else they reduce readability of the code with no tangible benefit I am aware of.</div><br/></div></div><div id="41434288" class="c"><input type="checkbox" id="c-41434288" checked=""/><div class="controls bullet"><span class="by">NohatCoder</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432003">parent</a><span>|</span><a href="#41432031">prev</a><span>|</span><a href="#41432234">next</a><span>|</span><label class="collapse" for="c-41434288">[-]</label><label class="expand" for="c-41434288">[2 more]</label></div><br/><div class="children"><div class="content">But do they make much of a difference? You have always been able to write:<p><pre><code>    myArray.sort(function(a,b){return a-b})
</code></pre>
People for some reason treat this syntactic sugar like it gives them some new fundamental ability.</div><br/><div id="41435460" class="c"><input type="checkbox" id="c-41435460" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41434288">parent</a><span>|</span><a href="#41432234">next</a><span>|</span><label class="collapse" for="c-41435460">[-]</label><label class="expand" for="c-41435460">[1 more]</label></div><br/><div class="children"><div class="content">Oh Javascript would be much better if it could only be syntactic sugar...<p>`function(a,b){return a-b;}` is different from `(a,b) =&gt; a - b`<p>And `function diff(a,b) {return a-b;}` is different from `const diff(a,b) =&gt; a - b;`.</div><br/></div></div></div></div><div id="41432234" class="c"><input type="checkbox" id="c-41432234" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432003">parent</a><span>|</span><a href="#41434288">prev</a><span>|</span><a href="#41433645">next</a><span>|</span><label class="collapse" for="c-41432234">[-]</label><label class="expand" for="c-41432234">[2 more]</label></div><br/><div class="children"><div class="content">I wish javascript had a built-in or at least (defacto) default linter. Like go-fmt or rust fmt. Or clippy even.<p>One that could enforce these styles. Because not only is the 
export const foo = () {}<p>painful on itself, it will quite certainly get intermixed with the<p>function foo() {}<p>and then in the next library a<p>const foo = function() {}<p>and so on. I&#x27;d rather have a consistently irritating style, than this willy-nilly yolo style that the JS community seems to embrace.</div><br/><div id="41432537" class="c"><input type="checkbox" id="c-41432537" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432234">parent</a><span>|</span><a href="#41433645">next</a><span>|</span><label class="collapse" for="c-41432537">[-]</label><label class="expand" for="c-41432537">[1 more]</label></div><br/><div class="children"><div class="content">ESLint and Prettier are the de facto default linter&#x2F;formatter combo in JS. There are rules you can enable to enforce your preferred style of function [1][2].<p>[1] <a href="https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;func-style" rel="nofollow">https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;func-style</a><p>[2] <a href="https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;prefer-arrow-callback" rel="nofollow">https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;prefer-arrow-callback</a></div><br/></div></div></div></div><div id="41433645" class="c"><input type="checkbox" id="c-41433645" checked=""/><div class="controls bullet"><span class="by">jappgar</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432003">parent</a><span>|</span><a href="#41432234">prev</a><span>|</span><a href="#41431942">next</a><span>|</span><label class="collapse" for="c-41433645">[-]</label><label class="expand" for="c-41433645">[3 more]</label></div><br/><div class="children"><div class="content">These aren&#x27;t equivalent as function foo will be hoisted but const foo will not be.</div><br/><div id="41433873" class="c"><input type="checkbox" id="c-41433873" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433645">parent</a><span>|</span><a href="#41435205">next</a><span>|</span><label class="collapse" for="c-41433873">[-]</label><label class="expand" for="c-41433873">[1 more]</label></div><br/><div class="children"><div class="content">Sure the food that this restaurant serves is pricey, but you have to remember that it also tastes terrible.</div><br/></div></div><div id="41435205" class="c"><input type="checkbox" id="c-41435205" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433645">parent</a><span>|</span><a href="#41433873">prev</a><span>|</span><a href="#41431942">next</a><span>|</span><label class="collapse" for="c-41435205">[-]</label><label class="expand" for="c-41435205">[1 more]</label></div><br/><div class="children"><div class="content">Yep, and that usually doesn&#x27;t matter at the top level.</div><br/></div></div></div></div></div></div><div id="41431942" class="c"><input type="checkbox" id="c-41431942" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41432003">prev</a><span>|</span><a href="#41431524">next</a><span>|</span><label class="collapse" for="c-41431942">[-]</label><label class="expand" for="c-41431942">[7 more]</label></div><br/><div class="children"><div class="content">I like them because it reinforces the idea that functions are just values like any other - having a separate keyword feels like it is inconsistent.</div><br/><div id="41432134" class="c"><input type="checkbox" id="c-41432134" checked=""/><div class="controls bullet"><span class="by">0xfffafaCrash</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431942">parent</a><span>|</span><a href="#41432294">next</a><span>|</span><label class="collapse" for="c-41432134">[-]</label><label class="expand" for="c-41432134">[1 more]</label></div><br/><div class="children"><div class="content">Moreover the binding and lexical scope aspects supported by classic functions are amongst the worst aspects of the language.<p>Arrow functions are also far more concise and ergonomic when working with higher order functions or simple expressions<p>The main thing to be wary of with arrow functions is when they are used anonymously inline without it being clear what the function is doing at a glance. That and Error stack traces but the latter is exacerbated by there being no actual standard regarding Error.prototype.stack</div><br/></div></div><div id="41432294" class="c"><input type="checkbox" id="c-41432294" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431942">parent</a><span>|</span><a href="#41432134">prev</a><span>|</span><a href="#41431524">next</a><span>|</span><label class="collapse" for="c-41432294">[-]</label><label class="expand" for="c-41432294">[5 more]</label></div><br/><div class="children"><div class="content">Why do you want to reinforce that idea?<p>To me arrow functions mostly just decrease readability and makes them blend in too much, when it should be important distinction what is a function and what is not.</div><br/><div id="41437534" class="c"><input type="checkbox" id="c-41437534" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432294">parent</a><span>|</span><a href="#41432803">next</a><span>|</span><label class="collapse" for="c-41437534">[-]</label><label class="expand" for="c-41437534">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a javascript programmer, but I really like the arrow pattern from a distance exactly because it enforces that idea.<p>My experience is that newcomers are often thrown off and confused by higher order functions. I think partly because, well let&#x27;s be honest they just <i>are</i> more confusing than normal functions, but I think it&#x27;s also because languages often bind functions differently from everything else.<p>`const cool = () =&gt; 5`<p>Makes it obvious and transparent, that `cool&#x27; is just a variable where as:<p>`function cool() {return 5}`<p>looks very different from other variable bindings.</div><br/><div id="41438379" class="c"><input type="checkbox" id="c-41438379" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41437534">parent</a><span>|</span><a href="#41432803">next</a><span>|</span><label class="collapse" for="c-41438379">[-]</label><label class="expand" for="c-41438379">[1 more]</label></div><br/><div class="children"><div class="content">Since we&#x27;re on the topic of higher order functions, arrow functions allow you to express function currying very succinctly (which some people prefer). This is a contrived example to illustrate the syntactical differences:<p><pre><code>  const arrow = (a) =&gt; (b) =&gt; `${a}-${b}`
  
  function verbose(a) {
    return function (b) {
      return `${a}-${b}`
    }
  }
  
  function uncurried(a, b) {
    return `${a}-${b}`
  }
  
  const values = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]
  values.map(arrow(&#x27;qux&#x27;))
  values.map(verbose(&#x27;qux&#x27;))
  values.map(uncurried.bind(null, &#x27;qux&#x27;))
  values.map((b) =&gt; uncurried(&#x27;qux&#x27;, b))</code></pre></div><br/></div></div></div></div><div id="41432803" class="c"><input type="checkbox" id="c-41432803" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432294">parent</a><span>|</span><a href="#41437534">prev</a><span>|</span><a href="#41441372">next</a><span>|</span><label class="collapse" for="c-41432803">[-]</label><label class="expand" for="c-41432803">[1 more]</label></div><br/><div class="children"><div class="content">Not to be dismissive, but because I like it - it just sits right with me.</div><br/></div></div><div id="41441372" class="c"><input type="checkbox" id="c-41441372" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432294">parent</a><span>|</span><a href="#41432803">prev</a><span>|</span><a href="#41431524">next</a><span>|</span><label class="collapse" for="c-41441372">[-]</label><label class="expand" for="c-41441372">[1 more]</label></div><br/><div class="children"><div class="content">&gt; should be important distinction what is a function and what is not<p>code is to express logic clearly to the reader. We should assess it for that purpose, before assess for any derivative, secondary concern such as whether categories of things in code (function etc) visually pops out when you use some specific tool like vim, or grep. There are syntax highlighters for a reason.
And maybe if grep sucks with code then build the proper tool for code searching, instead of writing code after the tool.</div><br/></div></div></div></div></div></div><div id="41431524" class="c"><input type="checkbox" id="c-41431524" checked=""/><div class="controls bullet"><span class="by">ndnxncjdj</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431942">prev</a><span>|</span><a href="#41431910">next</a><span>|</span><label class="collapse" for="c-41431524">[-]</label><label class="expand" for="c-41431524">[1 more]</label></div><br/><div class="children"><div class="content">I very much prefer the way scoping is handled in arrow functions.</div><br/></div></div><div id="41431910" class="c"><input type="checkbox" id="c-41431910" checked=""/><div class="controls bullet"><span class="by">nosianu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431524">prev</a><span>|</span><a href="#41433687">next</a><span>|</span><label class="collapse" for="c-41431910">[-]</label><label class="expand" for="c-41431910">[1 more]</label></div><br/><div class="children"><div class="content">A simple heuristic I use is to use arrow functions for inline function arguments, and named &quot;function&quot; functions for all others.<p>One reason is exactly what the subject of discussion is here, it&#x27;s easier to string-search with that keyword in front of the name, but I don&#x27;t need that for trivial inline functions (whenever I do I make it an actual function that I declare normally and not inline).<p>Then there&#x27;s the different handling of &quot;this&quot;, depending on how you write your code this may be an important reason to use an arrow function in some places.</div><br/></div></div><div id="41433687" class="c"><input type="checkbox" id="c-41433687" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431910">prev</a><span>|</span><a href="#41432176">next</a><span>|</span><label class="collapse" for="c-41433687">[-]</label><label class="expand" for="c-41433687">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m of the opinion that giving a global name to an anonymous function should result in a compilation error.</div><br/></div></div><div id="41432176" class="c"><input type="checkbox" id="c-41432176" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41433687">prev</a><span>|</span><a href="#41431272">next</a><span>|</span><label class="collapse" for="c-41432176">[-]</label><label class="expand" for="c-41432176">[1 more]</label></div><br/><div class="children"><div class="content">why the need to pronounce arbitrary preferences, who cares?</div><br/></div></div></div></div><div id="41431272" class="c"><input type="checkbox" id="c-41431272" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431235">prev</a><span>|</span><a href="#41431240">next</a><span>|</span><label class="collapse" for="c-41431272">[-]</label><label class="expand" for="c-41431272">[3 more]</label></div><br/><div class="children"><div class="content">Yes JavaScript.<p>You can search for both: &quot;function&quot; and &quot;=&gt;&quot; to find all function expressions and arrow function expressions.<p>All named functions are easily searchable.<p>All anonymous functions are throw away functions that are only called in one place so you don&#x27;t need to search for them in the first place.<p>As soon as an anonymous function becomes important enough to receive a label (i.e. assigning it to a variable, being assigned to a parameter, converting to function expression), it has also become searchable by that label too.</div><br/><div id="41431579" class="c"><input type="checkbox" id="c-41431579" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431272">parent</a><span>|</span><a href="#41431240">next</a><span>|</span><label class="collapse" for="c-41431579">[-]</label><label class="expand" for="c-41431579">[2 more]</label></div><br/><div class="children"><div class="content">The =&gt; is after the param spec, so you’re searching for foo.*=&gt; or something more complex, but then still missing multiline signatures. This is very easy to get caught by in TypeScript, and also happens when dealing with higher-order functions (quite common in React).</div><br/><div id="41431859" class="c"><input type="checkbox" id="c-41431859" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431579">parent</a><span>|</span><a href="#41431240">next</a><span>|</span><label class="collapse" for="c-41431859">[-]</label><label class="expand" for="c-41431859">[1 more]</label></div><br/><div class="children"><div class="content">Why are you searching for foo.<i>=&gt;<p>Are you searching through every function, or functions that have a very specific parameter?<p>And whatever you picked, why?<p>---------------------------------------------------------------<p>- If you&#x27;re searching for every function, then there&#x27;s no need to search for foo.</i>=&gt;, you only need to search for function and =&gt;.<p>- If you&#x27;re searching for a specific parameter, then just search for the parameter. Searching for functions is redundant.<p>---------------------------------------------------------------<p>Arrow function expressions and function expressions can both be named or anonymous.<p>Introducing arrow functions didn&#x27;t suddenly make JavaScript unsearchable.<p>JavaScript supported anonymous functions before arrow function expressions were introduced.<p>Anonymous functions can only ever be:<p>- run on the spot<p>- thrown away<p>- or passed around after they&#x27;ve been given a label<p>Which means, whenever you actually want to search for something, it&#x27;s going to be labelled.<p>So search for the label.</div><br/></div></div></div></div></div></div><div id="41431240" class="c"><input type="checkbox" id="c-41431240" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431272">prev</a><span>|</span><a href="#41435966">next</a><span>|</span><label class="collapse" for="c-41431240">[-]</label><label class="expand" for="c-41431240">[20 more]</label></div><br/><div class="children"><div class="content">You can still search for `&lt;keyword&gt; = \(.*\) =&gt; `, albeit it&#x27;s a bit cumbersome.</div><br/><div id="41431324" class="c"><input type="checkbox" id="c-41431324" checked=""/><div class="controls bullet"><span class="by">post-it</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431240">parent</a><span>|</span><a href="#41431782">next</a><span>|</span><label class="collapse" for="c-41431324">[-]</label><label class="expand" for="c-41431324">[2 more]</label></div><br/><div class="children"><div class="content">All you need is `&lt;keyword&gt; =`<p>Really, all you need is `&lt;keyword&gt;` and if the first result is a call to that function, just jump to its definition.</div><br/><div id="41431352" class="c"><input type="checkbox" id="c-41431352" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431324">parent</a><span>|</span><a href="#41431782">next</a><span>|</span><label class="collapse" for="c-41431352">[-]</label><label class="expand" for="c-41431352">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>Just search the definition.<p>Any time that a function doesn&#x27;t have a definition, it&#x27;s never the target of a search anyway.</div><br/></div></div></div></div><div id="41431782" class="c"><input type="checkbox" id="c-41431782" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431240">parent</a><span>|</span><a href="#41431324">prev</a><span>|</span><a href="#41435966">next</a><span>|</span><label class="collapse" for="c-41431782">[-]</label><label class="expand" for="c-41431782">[17 more]</label></div><br/><div class="children"><div class="content">All you need is a tool that actually understands the language.<p>It&#x27;s 2024 and HN still suggests using regular expressions to search through a code base.</div><br/><div id="41432356" class="c"><input type="checkbox" id="c-41432356" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431782">parent</a><span>|</span><a href="#41435593">next</a><span>|</span><label class="collapse" for="c-41432356">[-]</label><label class="expand" for="c-41432356">[10 more]</label></div><br/><div class="children"><div class="content">Regex is a universal tool.<p>Your special tool might not work on plattform X, fails for edge case - and you generally don&#x27;t know how it works. With regex or simple string search - I am in control. And can understand why results show up, or investigate when they don&#x27;t, but should.</div><br/><div id="41432545" class="c"><input type="checkbox" id="c-41432545" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432356">parent</a><span>|</span><a href="#41435593">next</a><span>|</span><label class="collapse" for="c-41432545">[-]</label><label class="expand" for="c-41432545">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Your special tool might not work on plattform X<p>As always, people come out with the weirdest of excuses to not use actual tools in the 99.9999% of the cases when they are available, and work.<p>When that tools doesn&#x27;t work, or isn&#x27;t sufficient, use another one like fuzzy text search or regexps.<p>&gt; and you generally don&#x27;t know how it works.<p>Do you know how your stove works? Or do you truly understand what the device you&#x27;re typing this comment on truly works?<p>Only in programming I see people deliberately avoid useful tools because &lt;some fringe edge case that comes up once in a millenium in their daily work&gt;</div><br/><div id="41435774" class="c"><input type="checkbox" id="c-41435774" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432545">parent</a><span>|</span><a href="#41433586">next</a><span>|</span><label class="collapse" for="c-41435774">[-]</label><label class="expand" for="c-41435774">[3 more]</label></div><br/><div class="children"><div class="content">It’s you who sees it as excuses. If I have a screwdriver multitool, I don’t need another one which is for d10 only. It simply creates <i>unnecessary</i> clutter in a toolbox. The difference between definition and mention search for a function is:<p><pre><code>  gr&lt;bs&gt;&lt;bs&gt;ion name&lt;cr&gt;
  vs
  grname&lt;cr&gt;
</code></pre>
or for the current identifier, simply<p><pre><code>  gr&lt;m-w&gt;&lt;cr&gt;
</code></pre>
I could even make my own useful tools like “\[fvm]gr” for function, variable or field search and brag about it watching miserable ide guys from the high balcony, but ain’t that unnecessary as well.</div><br/><div id="41435818" class="c"><input type="checkbox" id="c-41435818" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435774">parent</a><span>|</span><a href="#41433586">next</a><span>|</span><label class="collapse" for="c-41435818">[-]</label><label class="expand" for="c-41435818">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It simply creates unnecessary clutter in a toolbox.<p>And then you proceed to... invent several pale imitations of a symbol&#x2F;usages search.<p>More here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41435862">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41435862</a> so as not to repeat myself</div><br/><div id="41436006" class="c"><input type="checkbox" id="c-41436006" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435818">parent</a><span>|</span><a href="#41433586">next</a><span>|</span><label class="collapse" for="c-41436006">[-]</label><label class="expand" for="c-41436006">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t really apply, ignores things just said.</div><br/></div></div></div></div></div></div><div id="41433586" class="c"><input type="checkbox" id="c-41433586" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432545">parent</a><span>|</span><a href="#41435774">prev</a><span>|</span><a href="#41432885">next</a><span>|</span><label class="collapse" for="c-41433586">[-]</label><label class="expand" for="c-41433586">[1 more]</label></div><br/><div class="children"><div class="content">if you think anything works in 99.9999% of cases, you’ve never programmed a computer</div><br/></div></div><div id="41432885" class="c"><input type="checkbox" id="c-41432885" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432545">parent</a><span>|</span><a href="#41433586">prev</a><span>|</span><a href="#41435593">next</a><span>|</span><label class="collapse" for="c-41432885">[-]</label><label class="expand" for="c-41432885">[4 more]</label></div><br/><div class="children"><div class="content">When you specialize in one thing only, do what you want.<p>But I prefer tools, that I can use wherever I go. To not be dependant and chained to that environment.<p>&quot;Do you know how your stove works? Or do you truly understand what the device you&#x27;re typing this comment on truly works?&quot;<p>Also yes, I do.<p>&quot; people deliberately avoid useful tools because &lt;some fringe edge case that comes up once in a millenium in their daily work&gt;&quot;<p>Well, or I did already changed tools often enough, to be fed up with it and rather invest in tech that does not loose its value in the next iteration of the innovation cycle.</div><br/><div id="41433558" class="c"><input type="checkbox" id="c-41433558" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432885">parent</a><span>|</span><a href="#41435593">next</a><span>|</span><label class="collapse" for="c-41433558">[-]</label><label class="expand" for="c-41433558">[3 more]</label></div><br/><div class="children"><div class="content">&gt; When you specialize in one thing only, do what you want.<p>I specialize in one thing only: programming<p>&gt; But I prefer tools, that I can use wherever I go.<p>Do you always walk everywhere, or do you use a tool available at the time, like cars, planes, bycicles, public transport?<p>&gt; rather invest in tech that does not loose its value in the next iteration of the innovation cycle.<p>Things like &quot;fund symbol&quot;, &quot;find usages&quot;, &quot;find implementation&quot; have been available in actual tools for close to two decades now.</div><br/><div id="41433923" class="c"><input type="checkbox" id="c-41433923" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433558">parent</a><span>|</span><a href="#41435593">next</a><span>|</span><label class="collapse" for="c-41433923">[-]</label><label class="expand" for="c-41433923">[2 more]</label></div><br/><div class="children"><div class="content">I did not say I do not use what is avaiable, but this debate is about in general having your code in a shape that simply searching for strings work.</div><br/><div id="41435862" class="c"><input type="checkbox" id="c-41435862" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433923">parent</a><span>|</span><a href="#41435593">next</a><span>|</span><label class="collapse" for="c-41435862">[-]</label><label class="expand" for="c-41435862">[1 more]</label></div><br/><div class="children"><div class="content">Simply searching for strings rarely works well as the codebase grows larger. Because besides knowing where all things named X are, you want to actually see where X is used, or where it&#x27;s called from, or where it is defined.<p>With search you end up grepping the code twice:<p>- first grepping for the name<p>We&#x27;re literally in a thread where people invent regexes for how to search the same thing (a function) defined in two different ways (as a function or as a const)<p>- secondly, manually grepping through search results deducing if it&#x27;s relevant to what you&#x27;re looking for<p>It becomes significantly worse if you want to include third-party libs in your search.<p>There are countless times when I would just Cmd+B&#x2F;Cmd+Click a symbol in IDEA and continue my exploration down to Java&#x27;s own libraries. There are next to zero cases when IDEA would fail to recognise a function and find its usages if it was defined as a const, not as a function. Why would I willingly deny myself these tools as so many in this thread do?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41435593" class="c"><input type="checkbox" id="c-41435593" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431782">parent</a><span>|</span><a href="#41432356">prev</a><span>|</span><a href="#41433457">next</a><span>|</span><label class="collapse" for="c-41435593">[-]</label><label class="expand" for="c-41435593">[2 more]</label></div><br/><div class="children"><div class="content">Its current year and IDEs still can’t remember how I just transformed the snippet of code and suggest to transform the rest of the files in the same way. All they can do in “refactor” menu is only “rename” and then some extract&#x2F;etc nonsense which no one uses irl.<p>By using regexps I have an experience that opens many doors, and the fact that they aren’t automatic could make me sad, if only these doors weren’t completely shut without that experience.</div><br/><div id="41435951" class="c"><input type="checkbox" id="c-41435951" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435593">parent</a><span>|</span><a href="#41433457">next</a><span>|</span><label class="collapse" for="c-41435951">[-]</label><label class="expand" for="c-41435951">[1 more]</label></div><br/><div class="children"><div class="content">No one is stopping you from using regexps in IDEs.<p>And you somehow manage to undersell the rename functionality in an IDE. And I&#x27;ve used move&#x2F;extract functionality multiple times.<p>I do however agree that applicable transformations (like upgrading to new syntaxes, or ways of doing stuff as languages evolve) could be applied wholesale to large chunks of code.</div><br/></div></div></div></div><div id="41433457" class="c"><input type="checkbox" id="c-41433457" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431782">parent</a><span>|</span><a href="#41435593">prev</a><span>|</span><a href="#41433059">next</a><span>|</span><label class="collapse" for="c-41433457">[-]</label><label class="expand" for="c-41433457">[2 more]</label></div><br/><div class="children"><div class="content">The thing is: In large codebase the tool may become slow or crash, in a new language you may not have such tool..
Grep is far more robust!</div><br/><div id="41435883" class="c"><input type="checkbox" id="c-41435883" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433457">parent</a><span>|</span><a href="#41433059">next</a><span>|</span><label class="collapse" for="c-41435883">[-]</label><label class="expand" for="c-41435883">[1 more]</label></div><br/><div class="children"><div class="content">When tools don&#x27;t work or unsuitable, you use different tools.<p>And yet people are obsessed with never using useful tools in the first place because they can invent scenarios when this tool doesn&#x27;t work. Even if these scenarios might never actually come up in their daily work.</div><br/></div></div></div></div><div id="41433059" class="c"><input type="checkbox" id="c-41433059" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431782">parent</a><span>|</span><a href="#41433457">prev</a><span>|</span><a href="#41435966">next</a><span>|</span><label class="collapse" for="c-41433059">[-]</label><label class="expand" for="c-41433059">[2 more]</label></div><br/><div class="children"><div class="content">Not to move the goal posts too much, but when I am searching a huge Python or Java code base from IntelliJ, I use a mixture of symbol and text search.  One good thing about text search, you get hits from comments.</div><br/><div id="41433571" class="c"><input type="checkbox" id="c-41433571" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41433059">parent</a><span>|</span><a href="#41435966">next</a><span>|</span><label class="collapse" for="c-41433571">[-]</label><label class="expand" for="c-41433571">[1 more]</label></div><br/><div class="children"><div class="content">Yup. I do, too.<p>I&#x27;m mostly ranting against this weird &quot;we will never use great tools because full-text search&quot; obsession</div><br/></div></div></div></div></div></div></div></div><div id="41435966" class="c"><input type="checkbox" id="c-41435966" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431240">prev</a><span>|</span><a href="#41432331">next</a><span>|</span><label class="collapse" for="c-41435966">[-]</label><label class="expand" for="c-41435966">[1 more]</label></div><br/><div class="children"><div class="content">You can still look for `(funcname)\s*=` can&#x27;t you?  I mean it&#x27;s not like functions get re-declared a lot.</div><br/></div></div><div id="41432331" class="c"><input type="checkbox" id="c-41432331" checked=""/><div class="controls bullet"><span class="by">albedoa</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41435966">prev</a><span>|</span><a href="#41431241">next</a><span>|</span><label class="collapse" for="c-41432331">[-]</label><label class="expand" for="c-41432331">[1 more]</label></div><br/><div class="children"><div class="content">I want to talk to the developer who considers greppability when deciding whether to use the &quot;function&quot; keyword but requires his definitions to be greppable by distancing them from their call locations. I just have a few questions for him.</div><br/></div></div></div></div><div id="41431241" class="c"><input type="checkbox" id="c-41431241" checked=""/><div class="controls bullet"><span class="by">eddieh</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431222">prev</a><span>|</span><a href="#41433564">next</a><span>|</span><label class="collapse" for="c-41431241">[-]</label><label class="expand" for="c-41431241">[1 more]</label></div><br/><div class="children"><div class="content">I used to define functions as `funcname (arglist)`<p>And always call the function as `funcname(args)`<p>So definitions have a space between the name and arg parentheses, while calls do not. Seemed to work well, even in languages with extraneous keywords before definitions since space + paren is shorter than most keywords.<p>Now days I don’t bother since it really isn’t that useful especially with tags or LSP.<p>I still put the return type on a line of its own, not for search&#x2F;grep, but because it is cleaner and looks nice to me—overly long lines are the ugliest of coding IMO. Well that and excessive nesting.</div><br/></div></div><div id="41433564" class="c"><input type="checkbox" id="c-41433564" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431241">prev</a><span>|</span><a href="#41431639">next</a><span>|</span><label class="collapse" for="c-41433564">[-]</label><label class="expand" for="c-41433564">[1 more]</label></div><br/><div class="children"><div class="content"><i>Meanwhile C lacks any such keyword, so the best you can do is search for the name. That gets you a sea of callers with the declarations and definitions mixed in</i><p>That’s why in my personal projects I follow classic “type\nname” and grep with “^name\&gt;”.<p><i>looks ugly</i><p>Single line definitions with long, irregular type names and unaligned function names look ugly. Col 1 names are not only greppable but skimmable. I can speedscroll through code and still see where I am.</div><br/></div></div><div id="41431639" class="c"><input type="checkbox" id="c-41431639" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41433564">prev</a><span>|</span><a href="#41436326">next</a><span>|</span><label class="collapse" for="c-41431639">[-]</label><label class="expand" for="c-41431639">[1 more]</label></div><br/><div class="children"><div class="content">Yet you reply to an article that defines functions as variables, which I&#x27;ve seen a lot of developers do usually for no good reason at all.<p>To me, that&#x27;s a much common and worse practice with regards to greppability than splitting identifiers using string which I haven&#x27;t seen much in the wild.</div><br/></div></div><div id="41436326" class="c"><input type="checkbox" id="c-41436326" checked=""/><div class="controls bullet"><span class="by">wpollock</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431639">prev</a><span>|</span><a href="#41436821">next</a><span>|</span><label class="collapse" for="c-41436326">[-]</label><label class="expand" for="c-41436326">[2 more]</label></div><br/><div class="children"><div class="content">In the bygone days of ctags, C function definitions included a space before opening parenthesis, while function calls never had that space. I have a hard time remembering that modern coding styles never have that space and my IDE complains about it. (AFAIK, the modern gtags doesn&#x27;t rely on that space to determine definitions.)  Even without *tags, the convention made it easy to grep for definitions.</div><br/><div id="41436780" class="c"><input type="checkbox" id="c-41436780" checked=""/><div class="controls bullet"><span class="by">mzs</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41436326">parent</a><span>|</span><a href="#41436821">next</a><span>|</span><label class="collapse" for="c-41436780">[-]</label><label class="expand" for="c-41436780">[1 more]</label></div><br/><div class="children"><div class="content">space after builtin was recommended instead:<p><pre><code>  if (x == 0) { ...
  sizeof (buf);
  return (-1);
  exit(0);</code></pre></div><br/></div></div></div></div><div id="41436821" class="c"><input type="checkbox" id="c-41436821" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41436326">prev</a><span>|</span><a href="#41432991">next</a><span>|</span><label class="collapse" for="c-41436821">[-]</label><label class="expand" for="c-41436821">[1 more]</label></div><br/><div class="children"><div class="content">In terms of C, that&#x27;s one reason I prefer the BSD coding style:<p>int<p>foo(void)
{
}<p>vs the Linux coding style:<p>int foo(void)
{
}<p>The BSD style allows me to find function definitions using git grep ^foo.</div><br/></div></div><div id="41432991" class="c"><input type="checkbox" id="c-41432991" checked=""/><div class="controls bullet"><span class="by">mav3ri3k</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41436821">prev</a><span>|</span><a href="#41435374">next</a><span>|</span><label class="collapse" for="c-41432991">[-]</label><label class="expand" for="c-41432991">[1 more]</label></div><br/><div class="children"><div class="content">Although in rust, function like macros make it super hard to trace code. I like them when I am writing the code and hate then when I have to read others macros.</div><br/></div></div><div id="41435374" class="c"><input type="checkbox" id="c-41435374" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432991">prev</a><span>|</span><a href="#41435389">next</a><span>|</span><label class="collapse" for="c-41435374">[-]</label><label class="expand" for="c-41435374">[1 more]</label></div><br/><div class="children"><div class="content">Those also make your language easier to parse, and to read.<p>Many people insist that IDEs make the entire point moot, but that&#x27;s the kind of thing that make IDEs easier to write and debug, so I disagree.</div><br/></div></div><div id="41435389" class="c"><input type="checkbox" id="c-41435389" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41435374">prev</a><span>|</span><a href="#41433578">next</a><span>|</span><label class="collapse" for="c-41435389">[-]</label><label class="expand" for="c-41435389">[1 more]</label></div><br/><div class="children"><div class="content">One thing which works for C is to search something like `[a-z] foo\(.+\) \{` assuming that spacing matches the coding style, often the shorter form `[a-z] foo\(` works well, which tries to ensure there is a type definition and bin assignment or something before name. Then there is only a handful false positives.</div><br/></div></div><div id="41433578" class="c"><input type="checkbox" id="c-41433578" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41435389">prev</a><span>|</span><a href="#41437241">next</a><span>|</span><label class="collapse" for="c-41433578">[-]</label><label class="expand" for="c-41433578">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so the best you can do is search for the name<p>This is why in C projects libs go in &quot;lib&#x2F;&quot; and sources go in &quot;src&#x2F;&quot;.  If your header files have the same directory structure as libs,  then &quot;include&#x2F;&quot; is a also a decent way to find definitions.</div><br/></div></div><div id="41437241" class="c"><input type="checkbox" id="c-41437241" checked=""/><div class="controls bullet"><span class="by">leogout</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41433578">prev</a><span>|</span><a href="#41431866">next</a><span>|</span><label class="collapse" for="c-41437241">[-]</label><label class="expand" for="c-41437241">[1 more]</label></div><br/><div class="children"><div class="content">Javascript is a bit trickier i think nowadays with the fat arrow notation :
const myFunc = () =&gt; console. log(&quot;can&#x27;t find me :p&quot;);</div><br/></div></div><div id="41431866" class="c"><input type="checkbox" id="c-41431866" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41437241">prev</a><span>|</span><a href="#41431574">next</a><span>|</span><label class="collapse" for="c-41431866">[-]</label><label class="expand" for="c-41431866">[3 more]</label></div><br/><div class="children"><div class="content">Not sure this is very true for Common Lisp. Classic example are accessor functions where the generic function is created by whichever class is defined first and the method where the class is defined. Other macros will construct new symbols for function names (or take them from the macro arguments).</div><br/><div id="41433573" class="c"><input type="checkbox" id="c-41433573" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431866">parent</a><span>|</span><a href="#41431897">next</a><span>|</span><label class="collapse" for="c-41433573">[-]</label><label class="expand" for="c-41433573">[1 more]</label></div><br/><div class="children"><div class="content">That’s true, but I regard it as fairly minor. Accessor functions don&#x27;t have any logic in them, so in practice you don’t have to grep for them. But it can be confusing for new players, since they don&#x27;t know ahead of time which ones are accessors and which are not.</div><br/></div></div><div id="41431897" class="c"><input type="checkbox" id="c-41431897" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431866">parent</a><span>|</span><a href="#41433573">prev</a><span>|</span><a href="#41431574">next</a><span>|</span><label class="collapse" for="c-41431897">[-]</label><label class="expand" for="c-41431897">[1 more]</label></div><br/><div class="children"><div class="content">Still you can extend the concept without a lot of work, couldn&#x27;t you?</div><br/></div></div></div></div><div id="41431574" class="c"><input type="checkbox" id="c-41431574" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431866">prev</a><span>|</span><a href="#41433142">next</a><span>|</span><label class="collapse" for="c-41431574">[-]</label><label class="expand" for="c-41431574">[1 more]</label></div><br/><div class="children"><div class="content">For most functions ^\S.*name( will find declarations and definitions.<p>Most of us use exuberant ctags to allow jumping to definitions.</div><br/></div></div><div id="41433142" class="c"><input type="checkbox" id="c-41433142" checked=""/><div class="controls bullet"><span class="by">throwawayffffas</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431574">prev</a><span>|</span><a href="#41435527">next</a><span>|</span><label class="collapse" for="c-41433142">[-]</label><label class="expand" for="c-41433142">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Meanwhile C lacks any such keyword<p>It&#x27;s a hassle. But not the end of the world.<p>I usually search for &quot;doTheThing\(.+?\) \{&quot; first.<p>If I don&#x27;t get a hit, or too many hits I move to &quot;doTheThing\([^\)]*?\) \{&quot; and so on.</div><br/></div></div><div id="41435527" class="c"><input type="checkbox" id="c-41435527" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41433142">prev</a><span>|</span><a href="#41431835">next</a><span>|</span><label class="collapse" for="c-41435527">[-]</label><label class="expand" for="c-41435527">[1 more]</label></div><br/><div class="children"><div class="content">C, starting with K&amp;R, has all declarations and definitions on lines at the left margin, and little else. this is easy to grep for.</div><br/></div></div><div id="41431835" class="c"><input type="checkbox" id="c-41431835" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41435527">prev</a><span>|</span><a href="#41435410">next</a><span>|</span><label class="collapse" for="c-41431835">[-]</label><label class="expand" for="c-41431835">[1 more]</label></div><br/><div class="children"><div class="content">C has &quot;classical&quot; tooling like Cscope and Exuberant Ctags. The stuff works very well, except on the odd weird code that does idiotic things that should not be done with preprocessing.<p>Even for Lisp, you don&#x27;t want to be grepping, or at least not all the time for basic things.<p>For TXR Lisp, I provide a program that will scan code and build (or add to) your tags file (either a Vim or Emacs compatible one).<p>Given<p><pre><code>  (defstruct point ()
    x
    y)
</code></pre>
it will let your editor jump to the definition of point, x and y.</div><br/></div></div><div id="41435410" class="c"><input type="checkbox" id="c-41435410" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431835">prev</a><span>|</span><a href="#41437847">next</a><span>|</span><label class="collapse" for="c-41435410">[-]</label><label class="expand" for="c-41435410">[2 more]</label></div><br/><div class="children"><div class="content">Do people really use text search for this rather than an IDE that parses all of the code and knows exactly where each declaration is, able to instantly jump to them from a key press on any usage...? Wild.</div><br/><div id="41435414" class="c"><input type="checkbox" id="c-41435414" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41435410">parent</a><span>|</span><a href="#41437847">next</a><span>|</span><label class="collapse" for="c-41435414">[-]</label><label class="expand" for="c-41435414">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Not everyone uses or likes an IDE. Also, when you lean on an IDE for navigation, there is a tendency to write more complicated code, since it feels easy to navigate, you don&#x27;t feel the pain.</div><br/></div></div></div></div></div></div><div id="41437847" class="c"><input type="checkbox" id="c-41437847" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41431114">prev</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41437847">[-]</label><label class="expand" for="c-41437847">[2 more]</label></div><br/><div class="children"><div class="content">Yes, and &#x27;greppable&#x27; is an underused word&#x2F;concept in its own right.<p>I&#x27;ve used this as an organizing principle since forever (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1535916">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1535916</a>). It&#x27;s one of the best ways to factor code that I know of.</div><br/><div id="41439643" class="c"><input type="checkbox" id="c-41439643" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41437847">parent</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41439643">[-]</label><label class="expand" for="c-41439643">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good, but I&#x27;m snagging on the examples here; for instance, the insistence on consistent use of camel or snake case. That seems to me to be <i>purely</i> a tooling limitation; a more code-aware grep could just automatically synthesize the covering regexp for both. It feels like there&#x27;s a sweet spot in between LSP-ism and grep-ism that isn&#x27;t being captured.</div><br/></div></div></div></div><div id="41431107" class="c"><input type="checkbox" id="c-41431107" checked=""/><div class="controls bullet"><span class="by">dblotsky</span><span>|</span><a href="#41437847">prev</a><span>|</span><a href="#41431249">next</a><span>|</span><label class="collapse" for="c-41431107">[-]</label><label class="expand" for="c-41431107">[6 more]</label></div><br/><div class="children"><div class="content">Hard agree with the idea of greppability, but hard disagree about keeping names the same across boundaries.<p>I think the benefit of having one symbol exist in only one domain (e.g. “user_request” only showing up in the database-handling code, where it’s used 3 times, and not in the UI code, where it might’ve been used 30 times) reduces more cognitive load than is added by searching for 2 symbols instead of 1 common one.</div><br/><div id="41431369" class="c"><input type="checkbox" id="c-41431369" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41432584">next</a><span>|</span><label class="collapse" for="c-41431369">[-]</label><label class="expand" for="c-41431369">[1 more]</label></div><br/><div class="children"><div class="content">I’ve also found that I sometimes really like when I grep for a symbol and hit some mapping code. Just knowing that some value goes through a specific mapping layer and then is never mentioned again until the spot where it’s read often answers the question I had by itself, while without the mapping code there’d just be no occurrences of the symbol in the current code base and I’d have no clue which external source it’s coming from.</div><br/></div></div><div id="41432584" class="c"><input type="checkbox" id="c-41432584" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41431369">prev</a><span>|</span><a href="#41433065">next</a><span>|</span><label class="collapse" for="c-41432584">[-]</label><label class="expand" for="c-41432584">[1 more]</label></div><br/><div class="children"><div class="content">Probably depends on how your system is structured. if you know you only want to look in the DB code, hopefully it is either all together or there is something about the folder naming pattern you can take advantage of when saying where to search to limit it.<p>The upside to doing it this way is it makes your grepping more flexible by allowing you to either only search the one part of the codebase to see say DB code or see all the DB and UI things using the concept.</div><br/></div></div><div id="41433065" class="c"><input type="checkbox" id="c-41433065" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41432584">prev</a><span>|</span><a href="#41431347">next</a><span>|</span><label class="collapse" for="c-41433065">[-]</label><label class="expand" for="c-41433065">[1 more]</label></div><br/><div class="children"><div class="content">I have mixed thoughts on this too. Fortunately grep (rg in my case) easily handles it:<p>rg -i ‘foo.?bar’ finds all of foo_bar, fooBar, and FooBar.</div><br/></div></div><div id="41431347" class="c"><input type="checkbox" id="c-41431347" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41433065">prev</a><span>|</span><a href="#41431249">next</a><span>|</span><label class="collapse" for="c-41431347">[-]</label><label class="expand" for="c-41431347">[2 more]</label></div><br/><div class="children"><div class="content">Not to mention the readability hit from identifiers like foo.user_request in JavaScript, which triggers both linters and my own sense of language convention.</div><br/><div id="41432820" class="c"><input type="checkbox" id="c-41432820" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41431107">root</a><span>|</span><a href="#41431347">parent</a><span>|</span><a href="#41431249">next</a><span>|</span><label class="collapse" for="c-41432820">[-]</label><label class="expand" for="c-41432820">[1 more]</label></div><br/><div class="children"><div class="content">Both of those are easy to fix.  You&#x27;ll adapt quickly if you pick a different convention.<p>Additionally, I find that in practice such &quot;unusual&quot; code is actually beneficial - it often makes it easy to see at a glance that the code is somehow in sync with some external spec.  Especially when it comes to implicit usages such as in (de)serialization, noticing that quickly is quite valuable.<p>I&#x27;d much rather trash <i>every</i> languages&#x27; coding conventions than use subtly different names for objects serialized and shared across languages.  It&#x27;s just a pain.</div><br/></div></div></div></div></div></div><div id="41431249" class="c"><input type="checkbox" id="c-41431249" checked=""/><div class="controls bullet"><span class="by">amingilani</span><span>|</span><a href="#41431107">prev</a><span>|</span><a href="#41433537">next</a><span>|</span><label class="collapse" for="c-41431249">[-]</label><label class="expand" for="c-41431249">[6 more]</label></div><br/><div class="children"><div class="content">I agree that code searchability is a good thing but I disagree with those examples. They intentionally increase the chance of errors.<p>Maybe there’s an alternative way to achieve what the author set out but increasing searchability at the cost of increasing brittleness isn’t it for me.<p>In this example:<p>const getTableName = (addressType: &#x27;shipping&#x27; | &#x27;billing&#x27;) =&gt; {
    return `${addressType}_addresses`
}<p>The input string and output are coupled. If you add string conditionals as the author did, you introduce the chance of a mismatch between the input and output.<p>const getTableName = (addressType: &#x27;shipping&#x27; | &#x27;billing&#x27;) =&gt; {
    if (addressType === &#x27;shipping&#x27;) {
        return &#x27;shipping_addresses&#x27;
    }
    if (addressType === &#x27;billing&#x27;) {
        return &#x27;billing_addresses&#x27;
    }
    throw new TypeError(&#x27;addressType must be billing or shipping&#x27;)
}<p>Similarly, flattening dictionaries for readability introduces the chance of a random typo making our lives hell. A single typo in the repetitions below will be awful.<p>{
    &quot;auth.login.title&quot;: &quot;Login&quot;,
    &quot;auth.login.emailLabel&quot;: &quot;Email&quot;,
    &quot;auth.login.passwordLabel&quot;: &quot;Password&quot;,
    &quot;auth.register.title&quot;: &quot;Login&quot;,
    &quot;auth.register.emailLabel&quot;: &quot;Email&quot;,
    &quot;auth.register.passwordLabel&quot;: &quot;Password&quot;,
}<p>Typos aren’t unlikely. In a codebase I work with, we have a perpetually open ticket about how  ARTISTS is mistyped as ATRISTS in a similarly flat enum.<p>The issue can’t be solved easily because the enum is now copied across several codebases. But the ticket has a counter for the number of developers that independently discovered the bug and it’s in the mid two digits.</div><br/><div id="41431315" class="c"><input type="checkbox" id="c-41431315" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41432337">next</a><span>|</span><label class="collapse" for="c-41431315">[-]</label><label class="expand" for="c-41431315">[1 more]</label></div><br/><div class="children"><div class="content">Typos are find-and-fix-once, while unsearchability is a maintenance burden forever.<p>I don&#x27;t think coupling variable names by making sure they contain the same strings is the best way to show they&#x27;re related, compared to an actual map from address type to table name. There might be a lot of things called &#x27;shipping&#x27; in my app, only some of which are coupled to `shipping_addresses`.<p>Shouldn&#x27;t a linter be able to catch that there is no enum member called MyEnum.ATRISTS, or is it not an actual enum?</div><br/></div></div><div id="41432337" class="c"><input type="checkbox" id="c-41432337" checked=""/><div class="controls bullet"><span class="by">peeters</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41431315">prev</a><span>|</span><a href="#41431364">next</a><span>|</span><label class="collapse" for="c-41432337">[-]</label><label class="expand" for="c-41432337">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The input string and output are coupled. If you add string conditionals as the author did, you introduce the chance of a mismatch between the input and output.<p>I think it depends on whether the repetition is accidental or intrinsic. Does the table name <i>happen</i> to contain the address type as a prefix, or does it intrinsically have to? Greppability aside, when things are incidentally related, it&#x27;s often better to repeat yourself to not give the wrong impression that they&#x27;re intrinsically related. Conversely, if they <i>are</i> intrinsically related (i.e. it&#x27;s an invariant of the system that the table name starts with the address type as a prefix) then it&#x27;s better for the code to align with that.</div><br/></div></div><div id="41431364" class="c"><input type="checkbox" id="c-41431364" checked=""/><div class="controls bullet"><span class="by">ctxc</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41432337">prev</a><span>|</span><a href="#41431541">next</a><span>|</span><label class="collapse" for="c-41431364">[-]</label><label class="expand" for="c-41431364">[1 more]</label></div><br/><div class="children"><div class="content">Agree with you.<p>What happens when translation files get too big and you want to split and send only relevant parts?  
Like send only auth keys when user is unauthenticated?<p>`return translations[auth][login]` is no longer possible.<p>Or just imagine you want to iterate through `auth` keys. _shudders_</div><br/></div></div><div id="41431541" class="c"><input type="checkbox" id="c-41431541" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41431364">prev</a><span>|</span><a href="#41431550">next</a><span>|</span><label class="collapse" for="c-41431541">[-]</label><label class="expand" for="c-41431541">[1 more]</label></div><br/><div class="children"><div class="content">Entrenched typos like ATRISTS are actually a greppability goldmine. Chances are there are more occurrences of pluralized people who are making art in the codebase, but only ATRISTS is the one from that enum.<p>I certainly would not suggest deliberately mistyping, but there are places where the benefit is approaching the cost. Certain log messages can absolutely benefit from subtle letter garbling that retains readability while adding uniqueness.</div><br/></div></div><div id="41431550" class="c"><input type="checkbox" id="c-41431550" checked=""/><div class="controls bullet"><span class="by">kaelwd</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41431541">prev</a><span>|</span><a href="#41433537">next</a><span>|</span><label class="collapse" for="c-41431550">[-]</label><label class="expand" for="c-41431550">[1 more]</label></div><br/><div class="children"><div class="content">REFERER moment.</div><br/></div></div></div></div><div id="41433537" class="c"><input type="checkbox" id="c-41433537" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#41431249">prev</a><span>|</span><a href="#41431203">next</a><span>|</span><label class="collapse" for="c-41433537">[-]</label><label class="expand" for="c-41433537">[1 more]</label></div><br/><div class="children"><div class="content">Working in spring, which accepts I don&#x27;t know how many formats from ENV_VARS to yaml, this very much resonates with me, because as a general rule, if one can use a certain option, someone will do it.<p>Also the reason why I try to avoid Gradle when possible:<p>The possibilities are endless. At one place I think I found 21 wildly different Gradle configs out of 24 that I checked.<p>(For anyone that wonders, it was combinations of:<p>- placeholders vs straightforward depency (this is a thing in maven too)<p>- for loops doing things based on lists or maps instead of just calmly declaring them one after another, maybe to save some characters<p>- helper functions so you could declare dependencies like azure(&lt;something&gt;(&lt;version&gt;))<p>- order of declarations<p>- Kotlin vs Groovy syntax<p>I have probably forgotten a couple more but this is thankfully already a few years ago.)</div><br/></div></div><div id="41431203" class="c"><input type="checkbox" id="c-41431203" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41433537">prev</a><span>|</span><a href="#41434599">next</a><span>|</span><label class="collapse" for="c-41431203">[-]</label><label class="expand" for="c-41431203">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why D has a cast keyword:<p><pre><code>    ubyte c = cast(ubyte)i;
</code></pre>
instead of:<p><pre><code>    unsigned char c = (unsigned char)i;
</code></pre>
Casts are a blunt instrument that subvert the type system, and so they need to be greppable.<p>Having the cast keyword also removes the grammatical ambiguities in the expression syntax.</div><br/><div id="41431594" class="c"><input type="checkbox" id="c-41431594" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#41431203">parent</a><span>|</span><a href="#41434599">next</a><span>|</span><label class="collapse" for="c-41431594">[-]</label><label class="expand" for="c-41431594">[6 more]</label></div><br/><div class="children"><div class="content">Do you often grep for casts?
I never do that.</div><br/><div id="41432071" class="c"><input type="checkbox" id="c-41432071" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41431594">parent</a><span>|</span><a href="#41434378">next</a><span>|</span><label class="collapse" for="c-41432071">[-]</label><label class="expand" for="c-41432071">[2 more]</label></div><br/><div class="children"><div class="content">I regard every cast as a bug in my own code and try to refactor it so there aren&#x27;t any. I can&#x27;t get rid of all of them, but they&#x27;re always worth a second look.<p>I don&#x27;t normally grep for them, but others have told me they did.<p>P.S. one thing about D is you can do things like this:<p><pre><code>    ubyte b = i;            &#x2F;&#x2F; error, losing bits
    ubyte b = cast(ubyte)i; &#x2F;&#x2F; ugly cast
    ubyte b = i &amp; 0xFF;     &#x2F;&#x2F; no cast, no error!
</code></pre>
It&#x27;s just one of the nice little details that making programming in D a pleasure.</div><br/><div id="41442113" class="c"><input type="checkbox" id="c-41442113" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41432071">parent</a><span>|</span><a href="#41434378">next</a><span>|</span><label class="collapse" for="c-41442113">[-]</label><label class="expand" for="c-41442113">[1 more]</label></div><br/><div class="children"><div class="content">These things are better checked automatically with a static linter, that presumably already has a full parser and AST representation of the language and knows what is a cast and not.<p>Nobody should keep a checklist of &quot;100 things to grep for when doing a code review&quot;.</div><br/></div></div></div></div><div id="41434378" class="c"><input type="checkbox" id="c-41434378" checked=""/><div class="controls bullet"><span class="by">SnowflakeOnIce</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41431594">parent</a><span>|</span><a href="#41432071">prev</a><span>|</span><a href="#41434699">next</a><span>|</span><label class="collapse" for="c-41434378">[-]</label><label class="expand" for="c-41434378">[1 more]</label></div><br/><div class="children"><div class="content">When doing appsec review in C or C++, yes!</div><br/></div></div><div id="41434699" class="c"><input type="checkbox" id="c-41434699" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41431594">parent</a><span>|</span><a href="#41434378">prev</a><span>|</span><a href="#41431994">next</a><span>|</span><label class="collapse" for="c-41434699">[-]</label><label class="expand" for="c-41434699">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I know I don’t do that either. I mean if there was some special case where I remembered “oh yeah I had to cast that variable in this special case”. In general I avoid casting as much as I can in C&#x2F;C++, but especially in C.</div><br/></div></div><div id="41431994" class="c"><input type="checkbox" id="c-41431994" checked=""/><div class="controls bullet"><span class="by">aa-jv</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41431594">parent</a><span>|</span><a href="#41434699">prev</a><span>|</span><a href="#41434599">next</a><span>|</span><label class="collapse" for="c-41431994">[-]</label><label class="expand" for="c-41431994">[1 more]</label></div><br/><div class="children"><div class="content">Try to think about why you might want to do that.  It makes a lot of sense, but if you&#x27;re not doing it, that might be enlightening...</div><br/></div></div></div></div></div></div><div id="41434599" class="c"><input type="checkbox" id="c-41434599" checked=""/><div class="controls bullet"><span class="by">dwh452</span><span>|</span><a href="#41431203">prev</a><span>|</span><a href="#41434750">next</a><span>|</span><label class="collapse" for="c-41434599">[-]</label><label class="expand" for="c-41434599">[6 more]</label></div><br/><div class="children"><div class="content">This sounds like the advice to prefer the variable name &#x27;ii&#x27; over &#x27;i&#x27; because you can easily search for it. I loath such advice because it causes the code to become ugly. Similarly, there are &#x27;YODA Conditions&#x27; which make code hard to comprehend which solves an insignificant error that is easily caught with tooling. The problem with advice like these is you will encounter deranged developers that become obsessive about such things and make the code base ugly trying to implement dozens of style rules. Code should look good. Making a piece of text look good for other humans to comprehend I consider to be job #1 or #2 for a good developer.</div><br/><div id="41434643" class="c"><input type="checkbox" id="c-41434643" checked=""/><div class="controls bullet"><span class="by">moolcool</span><span>|</span><a href="#41434599">parent</a><span>|</span><a href="#41435472">next</a><span>|</span><label class="collapse" for="c-41434643">[-]</label><label class="expand" for="c-41434643">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem with advice like these is you will encounter deranged developers that become obsessive about such things and make the code base ugly trying to implement dozens of style rules<p>That&#x27;s more of a &quot;deranged developer&quot; problem than a problem with the guidelines themselves. E.g. I think his `getTableName` example is quite sensible, but also one which some dogmatic engineers would flag and code-golf down to the one-liner.</div><br/></div></div><div id="41435472" class="c"><input type="checkbox" id="c-41435472" checked=""/><div class="controls bullet"><span class="by">antifa</span><span>|</span><a href="#41434599">parent</a><span>|</span><a href="#41434643">prev</a><span>|</span><a href="#41434693">next</a><span>|</span><label class="collapse" for="c-41435472">[-]</label><label class="expand" for="c-41435472">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the advice to prefer the variable name &#x27;ii&#x27; over &#x27;i&#x27; because you can easily search for it<p>\bi\b is the easy way to search for i.</div><br/></div></div><div id="41434693" class="c"><input type="checkbox" id="c-41434693" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41434599">parent</a><span>|</span><a href="#41435472">prev</a><span>|</span><a href="#41435598">next</a><span>|</span><label class="collapse" for="c-41434693">[-]</label><label class="expand" for="c-41434693">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &#x27;ii&#x27; over &#x27;i&#x27;<p>You don&#x27;t need to search for local variables, nobody names global variables &quot;i&quot; - so the &quot;ii&quot; advice is pointless.<p>You often do need to search for places where global stuff is referenced, and while IDEs can help with that - the same things that break grepability often break &quot;find references&quot; in IDE. For example if you dynamically construct function names to call, play with reflections, preproccessor, macros, etc.<p>So it&#x27;s a good advice to avoid these things.<p>&gt; you will encounter deranged developers that become obsessive about such things and make the code base ugly<p>You can abuse any rule, including<p>&gt;  Code should look good.<p>and I&#x27;d argue the more general a rule is - the more likely it is to be abused. So I prefer specific rules like &quot;don&#x27;t construct identifiers dynamically&quot; to general &quot;be good&quot; rules.</div><br/></div></div><div id="41435598" class="c"><input type="checkbox" id="c-41435598" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41434599">parent</a><span>|</span><a href="#41434693">prev</a><span>|</span><a href="#41434787">next</a><span>|</span><label class="collapse" for="c-41435598">[-]</label><label class="expand" for="c-41435598">[1 more]</label></div><br/><div class="children"><div class="content">Those things only make the codebase &quot;ugly&quot; until you learn how to read it.</div><br/></div></div><div id="41434787" class="c"><input type="checkbox" id="c-41434787" checked=""/><div class="controls bullet"><span class="by">inetknght</span><span>|</span><a href="#41434599">parent</a><span>|</span><a href="#41435598">prev</a><span>|</span><a href="#41434750">next</a><span>|</span><label class="collapse" for="c-41434787">[-]</label><label class="expand" for="c-41434787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This sounds like the advice to prefer the variable name &#x27;ii&#x27; over &#x27;i&#x27; because you can easily search for it</i><p>I&#x27;ve never heard of that advice. I honestly like algebraic names (singular digits) as long as they&#x27;re well documented in a comment or aliasing another longer-name.<p>&gt; <i>there are &#x27;YODA Conditions&#x27; which make code hard to comprehend which solves an insignificant error that is easily caught with tooling</i><p>Yoda conditions [0] are a useful defensive programming technique and does not reduce readability except to someone new to it. I argue it improves readability, particularly for myself.<p>As for tooling... it doesn&#x27;t catch every case for every language.<p>&gt; <i>I loath such advice because it causes the code to become ugly.</i><p>Beauty is in the eye of the beholder. While I appreciate your opinion, I also reject it out of hand for professional developers. Instead of deciding whether code is &quot;ugly&quot; perhaps you should decide whether the code is useful. Feel free to keep your pretty code in your personal projects (and show them off so you can highlight how your style really comes together for that one really cool thing you&#x27;re doing).<p>&gt; <i>you will encounter deranged developers that become obsessive about such things</i><p>I don&#x27;t like being called deranged but I am definitely obsessed about eliminated whole classes of bugs just by the coding design and style not allowing them to happen. If safe code is &quot;ugly&quot; to you... well then I consider myself to be a better developer than you. I&#x27;d rather have ugly code that&#x27;s easily testable instead of pretty code that&#x27;s difficult to test in isolation which most developers end up writing.<p>&gt; <i>Code should look good. Making a piece of text look good for other humans to comprehend I consider to be job #1 or #2 for a good developer.</i><p>It depends on the project. Just remember that what looks good to you isn&#x27;t what looks good to me. So if it&#x27;s your personal project, then make it look good! If it&#x27;s something we&#x27;re both working on... then expect to defend your stylistic choices with numbers and logic instead of arguments about &quot;pretty&quot;.<p>Then, from the article:<p>&gt; <i>Flat is better than nested</i><p>If I&#x27;m searching for something in JSON I&#x27;m going to use jq [1] instead of grep. Use the right tools for the right job after all. I definitely prefer much richer structured data instead of a flat list of key-value pairs.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Yoda_conditions" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Yoda_conditions</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Jq_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Jq_(programming_language)</a></div><br/></div></div></div></div><div id="41434750" class="c"><input type="checkbox" id="c-41434750" checked=""/><div class="controls bullet"><span class="by">trey-jones</span><span>|</span><a href="#41434599">prev</a><span>|</span><a href="#41432795">next</a><span>|</span><label class="collapse" for="c-41434750">[-]</label><label class="expand" for="c-41434750">[3 more]</label></div><br/><div class="children"><div class="content">As someone who almost exclusively uses grep for finding what I need in codebases that are new to me and old to me, you can make whatever arbitrary rules you want, as long as you&#x27;re consistent, I&#x27;ll be pretty happy with it.  If syntax is loose in some area (single vs double quotes, parens or braces or none), just do the same thing every time.  Whitespace consistency isn&#x27;t crucial, but it can&#x27;t hurt (between function name and parens, for example).</div><br/><div id="41435275" class="c"><input type="checkbox" id="c-41435275" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#41434750">parent</a><span>|</span><a href="#41434899">next</a><span>|</span><label class="collapse" for="c-41435275">[-]</label><label class="expand" for="c-41435275">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also thinking long-context LLMs are going to make this advice seem pretty archaic in a few years. They&#x27;re so good at reading code and extremely useful for asking questions of a code base.<p>That said, I completely agree with the author on not using clever string tricks to compose identifiers. That makes code both harder to search and to read.</div><br/></div></div><div id="41434899" class="c"><input type="checkbox" id="c-41434899" checked=""/><div class="controls bullet"><span class="by">necrotic_comp</span><span>|</span><a href="#41434750">parent</a><span>|</span><a href="#41435275">prev</a><span>|</span><a href="#41432795">next</a><span>|</span><label class="collapse" for="c-41434899">[-]</label><label class="expand" for="c-41434899">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. So long as the code hits performance and business goals, there doesn&#x27;t need to be an emphasis put on &quot;newness&quot; or any other sort of vanity metric - make the code obvious, searchable, and understandable so that in a time crunch or during an outage it&#x27;s easy to search and find the culprit.</div><br/></div></div></div></div><div id="41432795" class="c"><input type="checkbox" id="c-41432795" checked=""/><div class="controls bullet"><span class="by">arendtio</span><span>|</span><a href="#41434750">prev</a><span>|</span><a href="#41431099">next</a><span>|</span><label class="collapse" for="c-41432795">[-]</label><label class="expand" for="c-41432795">[4 more]</label></div><br/><div class="children"><div class="content">I am firmly against the suggested changes. I love grepping through code too (often using -A -B -C), but I also like browsing the code, with tools where you can just click on a function and see its definition.<p>However, changing how the code should be written so that grepping becomes easier is optimizing for the wrong target. It is much more important that the code is easily readable and maintainable.<p>In addition, some tools are designed explicitly for grepping through code (from the top of my head ack is an example). If grep doesn&#x27;t work, one should try a more sophisticated tool instead of using different coding styles.</div><br/><div id="41432826" class="c"><input type="checkbox" id="c-41432826" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41432795">parent</a><span>|</span><a href="#41432970">next</a><span>|</span><label class="collapse" for="c-41432826">[-]</label><label class="expand" for="c-41432826">[1 more]</label></div><br/><div class="children"><div class="content">Nothing the author wrote would necessarily make code harder to read or maintain. Consistent naming of the same thing throughout, not constructing variables or table names dynamically, etc. benefit both readers&#x2F;maintainers and searching.<p>I understood “grepping” to mean ripgrep (rg) or ack, not just plain grep. I think programmers who use command line tools or vim know about those. VSCode uses rg.</div><br/></div></div><div id="41432970" class="c"><input type="checkbox" id="c-41432970" checked=""/><div class="controls bullet"><span class="by">lucideer</span><span>|</span><a href="#41432795">parent</a><span>|</span><a href="#41432826">prev</a><span>|</span><a href="#41431099">next</a><span>|</span><label class="collapse" for="c-41432970">[-]</label><label class="expand" for="c-41432970">[2 more]</label></div><br/><div class="children"><div class="content">Greppability is really a proxy metric here - these changes all have other benefits even if you never grep (mostly readability tbh).<p><pre><code>    const getTableName = (addressType: &#x27;shipping&#x27; | &#x27;billing&#x27;) =&gt; {
        return `${addressType}_addresses`
    }
</code></pre>
This is a simplified example but in a longer function, readability of the `return` lines would be improved as the reader wouldn&#x27;t have to reference the union type (which may or may not be defined in the signature). The rewrite is also safer as it errors out if a runtime `addressType` value doesn&#x27;t match the union type (above code would not throw an error, just return an indeterminate value which would cause undefined behaviour).<p>&quot;Flat is better than nested&quot; also greatly improves readability in both examples: either reading the i18n line, or reading the classname at definition &#x2F; call will be more readable when the name contains full context of function.</div><br/></div></div></div></div><div id="41431099" class="c"><input type="checkbox" id="c-41431099" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41432795">prev</a><span>|</span><a href="#41432506">next</a><span>|</span><label class="collapse" for="c-41431099">[-]</label><label class="expand" for="c-41431099">[3 more]</label></div><br/><div class="children"><div class="content">one of the strangest and most grep-hostile approaches to identifiers that I have ever observed is Nim ignoring both case and underscores in an effort to allow everyone to write code in their preferred style:<p><a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;manual.html#partial-caseminusinsensitivity_1" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;manual.html#partial-caseminusinsen...</a></div><br/><div id="41431194" class="c"><input type="checkbox" id="c-41431194" checked=""/><div class="controls bullet"><span class="by">uasi</span><span>|</span><a href="#41431099">parent</a><span>|</span><a href="#41434814">next</a><span>|</span><label class="collapse" for="c-41431194">[-]</label><label class="expand" for="c-41431194">[1 more]</label></div><br/><div class="children"><div class="content">Nim even provides a dedicated grep-like tool to search for identifiers regardless of the style <a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;nimgrep.html" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;nimgrep.html</a></div><br/></div></div><div id="41434814" class="c"><input type="checkbox" id="c-41434814" checked=""/><div class="controls bullet"><span class="by">planetis</span><span>|</span><a href="#41431099">parent</a><span>|</span><a href="#41431194">prev</a><span>|</span><a href="#41432506">next</a><span>|</span><label class="collapse" for="c-41434814">[-]</label><label class="expand" for="c-41434814">[1 more]</label></div><br/><div class="children"><div class="content">And it works pretty well, coming from 6+ years of experience. It&#x27;s not that strange if consider case insensitive filesystems and email addresses. But on the internet you only hear the opinion of the loudest minority.</div><br/></div></div></div></div><div id="41432506" class="c"><input type="checkbox" id="c-41432506" checked=""/><div class="controls bullet"><span class="by">vijucat</span><span>|</span><a href="#41431099">prev</a><span>|</span><a href="#41433154">next</a><span>|</span><label class="collapse" for="c-41432506">[-]</label><label class="expand" for="c-41432506">[2 more]</label></div><br/><div class="children"><div class="content">One other thing I&#x27;d like to add is greppable comments! In the same vein as TODO and FIXME, I use hashtags in comments to drop hints to future me reading the code. #learning is a universal one:<p>&#x2F;&#x2F; #learning: transparent color using color.new(color.white, 100). This is GREAT for hiding plot() lines during inapplicable periods (such as when no trade is on)<p>But project-specific hashtags are quite useful, too.<p>&#x2F;&#x2F; #60within600: bunch API calls to not hit the 60 calls within 10 minutes limit<p>&#x2F;&#x2F; This memoizes fn call results to prevent #60within600<p>The hashtagging was inspired long ago by del.icio.us, if you remember that. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Delicious_(website)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Delicious_(website)</a></div><br/><div id="41433434" class="c"><input type="checkbox" id="c-41433434" checked=""/><div class="controls bullet"><span class="by">philipwhiuk</span><span>|</span><a href="#41432506">parent</a><span>|</span><a href="#41433154">next</a><span>|</span><label class="collapse" for="c-41433434">[-]</label><label class="expand" for="c-41433434">[1 more]</label></div><br/><div class="children"><div class="content">Seems like you&#x27;re trying to implement a ticketing system in your code to me.<p>If you need to prevent 60 within 600, write a test.</div><br/></div></div></div></div><div id="41433154" class="c"><input type="checkbox" id="c-41433154" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#41432506">prev</a><span>|</span><a href="#41434913">next</a><span>|</span><label class="collapse" for="c-41433154">[-]</label><label class="expand" for="c-41433154">[1 more]</label></div><br/><div class="children"><div class="content"><i>astgrep</i> is a very useful tool when grep fails: <a href="https:&#x2F;&#x2F;ast-grep.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ast-grep.github.io&#x2F;</a><p>It&#x27;s not as easy to use as grep but I think one can script it to be nearly so. It has huge power but without learning it all one can do searches that grep finds difficult. e.g. finding all the locations where a method is called and showing the parameters even if they are on multiple lines.  You can then use rewrite rules to do CLI code refactoring.<p>I think it also has potential in a build toolchain e.g. to look for patterns you want to discourage as a pre-commit hook.<p><i>ultragrep</i> - <a href="https:&#x2F;&#x2F;github.com&#x2F;zendesk&#x2F;ultragrep">https:&#x2F;&#x2F;github.com&#x2F;zendesk&#x2F;ultragrep</a> - I don&#x27;t love this quite as much but it does have a way to build indexes so you can do fast greps across a big codebase. It also has a text mode UI if you want it and I find that almost worthwhile.<p>I use <i>ripgrep</i> most of the time but while I like it, there is a limit to how many grep tools I can remember and I should probably cut down to using ultragrep and astgrep.<p>plain gnu grep itself is something one has to know when one is on an unfamiliar machine.</div><br/></div></div><div id="41434913" class="c"><input type="checkbox" id="c-41434913" checked=""/><div class="controls bullet"><span class="by">guhcampos</span><span>|</span><a href="#41433154">prev</a><span>|</span><a href="#41431231">next</a><span>|</span><label class="collapse" for="c-41434913">[-]</label><label class="expand" for="c-41434913">[1 more]</label></div><br/><div class="children"><div class="content">One situation that comes to mind is configuration of applications on containers using environment variables.<p>It&#x27;s extremely valuable to be able to just `grep -r PREFIX_` on a codebase and be able to visualize all possible configuration values for that application.<p>This is encouraged by some frameworks like Django, where you are expected to list all the configuration values in a `settings` module, but is not standard for `viper`, `click` and `pydantic-settings`, which try to be too smart and auto-generate the variable names for you. It&#x27;s one of these cases where &quot;modern&quot; frameworks and applications try to save a minuscule amount of work by automating some task, but end up reducing the maintainability of the code over time.</div><br/></div></div><div id="41431231" class="c"><input type="checkbox" id="c-41431231" checked=""/><div class="controls bullet"><span class="by">jackphilson</span><span>|</span><a href="#41434913">prev</a><span>|</span><a href="#41442206">next</a><span>|</span><label class="collapse" for="c-41431231">[-]</label><label class="expand" for="c-41431231">[8 more]</label></div><br/><div class="children"><div class="content">I wonder - why isn&#x27;t this talked about more? We have had tens of thousands of software companies, each with probably a dozen people focused on hyperoptimizing everything. Why hasn&#x27;t this point been talked about more on the internet to the point where it&#x27;s obvious today? And it&#x27;s not specifically about this, it&#x27;s more in general. Do people just learn this on their own, and not say anything? Or is the discussion related to this topic buried in some old forum somewhere?</div><br/><div id="41431818" class="c"><input type="checkbox" id="c-41431818" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41431231">parent</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41431818">[-]</label><label class="expand" for="c-41431818">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s talked about, just in the opposite direction.<p>I&#x27;ve left hardcoded strings (think Kafka event type names) in my source for this very reason, but after a round of code review they get squirreled away as constants in separate files because string repetition is bad or something.</div><br/><div id="41431980" class="c"><input type="checkbox" id="c-41431980" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41431818">parent</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41431980">[-]</label><label class="expand" for="c-41431980">[5 more]</label></div><br/><div class="children"><div class="content">Without constants, it&#x27;s too easy to let a typo sneak in or have inconvenience later replacing one &quot;event&quot; but not replacing an unrelated &quot;event&quot;. I&#x27;ll only do it if the string is used two times at most, but usually I&#x27;ll make a constant the first time and it doesn&#x27;t feel like any loss.</div><br/><div id="41432061" class="c"><input type="checkbox" id="c-41432061" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41431980">parent</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41432061">[-]</label><label class="expand" for="c-41432061">[4 more]</label></div><br/><div class="children"><div class="content">Yes, this is exactly what I was fighting against.<p>If I have three classes that interact with &quot;MyTable&quot;, then I can grep for places that interact with &quot;MyTable&quot; and I get back three classes.<p>After refactoring, the class which now knows about &quot;MyTable&quot; is Constants.java, which has no business knowing about &quot;MyTable&quot;.  Grepping it now turns up a false-positive and finds 0 of the actual usage sites (3 false-negatives).</div><br/><div id="41432604" class="c"><input type="checkbox" id="c-41432604" checked=""/><div class="controls bullet"><span class="by">NotMichaelBay</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41432061">parent</a><span>|</span><a href="#41432367">next</a><span>|</span><label class="collapse" for="c-41432604">[-]</label><label class="expand" for="c-41432604">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not exactly a false positive. It&#x27;s just a level of indirection, 1 more search by the constant name to find usages. What you sacrifice there you gain by having the compiler help find typos and the IDE help with autocompletion.</div><br/></div></div><div id="41432367" class="c"><input type="checkbox" id="c-41432367" checked=""/><div class="controls bullet"><span class="by">GeneralMayhem</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41432061">parent</a><span>|</span><a href="#41432604">prev</a><span>|</span><a href="#41433446">next</a><span>|</span><label class="collapse" for="c-41432367">[-]</label><label class="expand" for="c-41432367">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but now you have the string constant as a symbol, which you can either grep for (in which case you&#x27;re delayed by one search, not the end of the world if you were going to unwind callstacks anyway) or, if you have an LSP, you can jump directly from it to users...</div><br/></div></div><div id="41433446" class="c"><input type="checkbox" id="c-41433446" checked=""/><div class="controls bullet"><span class="by">philipwhiuk</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41432061">parent</a><span>|</span><a href="#41432367">prev</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41433446">[-]</label><label class="expand" for="c-41433446">[1 more]</label></div><br/><div class="children"><div class="content">`Constants.java` is a massive code-smell (which I have in many projects, but it&#x27;s still a smell).<p>The file name is awful.<p>At worst it should be &#x27;DbConstants&#x27; but probably they should be defined elsewhere.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41442206" class="c"><input type="checkbox" id="c-41442206" checked=""/><div class="controls bullet"><span class="by">eschluntz</span><span>|</span><a href="#41431231">prev</a><span>|</span><a href="#41432924">next</a><span>|</span><label class="collapse" for="c-41442206">[-]</label><label class="expand" for="c-41442206">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree! I wrote this a few years ago: <a href="https:&#x2F;&#x2F;blog.cobaltrobotics.com&#x2F;you-cant-read-code-that-you-cant-find" rel="nofollow">https:&#x2F;&#x2F;blog.cobaltrobotics.com&#x2F;you-cant-read-code-that-you-...</a></div><br/></div></div><div id="41432924" class="c"><input type="checkbox" id="c-41432924" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#41442206">prev</a><span>|</span><a href="#41435702">next</a><span>|</span><label class="collapse" for="c-41432924">[-]</label><label class="expand" for="c-41432924">[3 more]</label></div><br/><div class="children"><div class="content">This also applies to dependency injection. While it has significant benefits, it hurts clarity of the code. It becomes more difficult to see where each object is coming from.</div><br/><div id="41435791" class="c"><input type="checkbox" id="c-41435791" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41432924">parent</a><span>|</span><a href="#41435702">next</a><span>|</span><label class="collapse" for="c-41435791">[-]</label><label class="expand" for="c-41435791">[2 more]</label></div><br/><div class="children"><div class="content">Magical dependency injection <i>frameworks</i>, that is.<p>Plain old putting-dependencies-in-the-constructor-instead-of-newing-them is great.<p>If you &#x27;wire&#x27; it yourself, you see the top-level structure of the project in main, e.g.<p><pre><code>  cache          &lt;- createCache &quot;.&#x2F;cache&quot;
  workQueue      &lt;- createWorkQueue parallelism
  projectFinder  &lt;- createProjectFinder basePath
  gradleBuilder  &lt;- createGradleBuilder cache
  normaliser     &lt;- createNormaliser
  gradleParser   &lt;- createGradleParser normaliser
  relationFinder &lt;- createRelationFinder cache normaliser
</code></pre>
At a glance I can see what uses normaliser, and what is used by normaliser.</div><br/><div id="41442823" class="c"><input type="checkbox" id="c-41442823" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41432924">root</a><span>|</span><a href="#41435791">parent</a><span>|</span><a href="#41435702">next</a><span>|</span><label class="collapse" for="c-41442823">[-]</label><label class="expand" for="c-41442823">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve ditched &quot;magical dependency injection frameworks&quot; for manual injections in constructors and the net result is that development is actually faster. Yes, you write slightly more code, but at the same time, it&#x27;s much easier to figure out what&#x27;s going on. Before, if something went wrong, we would get some arcane errors from deep inside the DI framework and had to decypher what it means and what changes we need to apply to the configs. Now, it&#x27;s just regular code (great with refactorings and greppability, too).</div><br/></div></div></div></div></div></div><div id="41435702" class="c"><input type="checkbox" id="c-41435702" checked=""/><div class="controls bullet"><span class="by">settsu</span><span>|</span><a href="#41432924">prev</a><span>|</span><a href="#41432296">next</a><span>|</span><label class="collapse" for="c-41435702">[-]</label><label class="expand" for="c-41435702">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m ardently in favor of making code human readable as practically as possible. Personally it follows on my personal Rule #1: Be kind (i.e., in this case, to others and your future self.)<p>However, searchable =&#x2F;= greppable.<p>&gt; Flat is better than nested<p>Context matters but, generally speaking, I would say that flatter is <i>anti</i>-grep.</div><br/></div></div><div id="41432296" class="c"><input type="checkbox" id="c-41432296" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41435702">prev</a><span>|</span><a href="#41431886">next</a><span>|</span><label class="collapse" for="c-41432296">[-]</label><label class="expand" for="c-41432296">[5 more]</label></div><br/><div class="children"><div class="content">There are of course cases of dynamic data in every language (The table name is an apt example) but usually when I look in code I just expect to be able to follow definitions. If the language doesn&#x27;t reliably allow me to find &quot;usages of this type&quot; without risking finding <i>another type with the exact same name</i> then I&#x27;m already starting up my static type system compiler for the rewrite.<p>There are exceptions of course: when searching git logs, comments etc doesn&#x27;t help what the language or IDE does.<p>And when searching for an unknown symbol (type, function, variable) you don&#x27;t know the name of, but you know _should_ look like &quot;Dog<i>Order&quot; or &quot;Order</i>Dog&quot; is a common task too. In this case I&#x27;d probably search for &quot; Dog.<i>Order\(&quot;  or &quot; Order.</i>Dog\(&quot;  if I&#x27;m looking for a function. The language trait that enabled it is that method names are Pascal Case and always have an opening ( at the end. But my IDE at least lets me search for members (variables, functions) separate from type names. There should be an <i>index</i> in the IDE though that lets you query this data. E.g. looking for types starting with foo could be done with search t:Foo,  instead of having to grep for &quot;(struct|class) Foo&quot; or similar. Tooling is the key.</div><br/><div id="41432348" class="c"><input type="checkbox" id="c-41432348" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#41432296">parent</a><span>|</span><a href="#41431886">next</a><span>|</span><label class="collapse" for="c-41432348">[-]</label><label class="expand" for="c-41432348">[4 more]</label></div><br/><div class="children"><div class="content">The author uses JavaScript and Python as examples. So I presume they have (most?) experience with dynamic languages.<p>In static languages, greppability is hardly as much as a factor. Especially with the availability of LSPs and other such tools nowadays.<p>When I write rust, or Java, I hardly grep, I &quot;go to usages&quot; or &quot;go to definition&quot;, &quot;rename symbol&quot; and so on.  Similar, but not to that extent, with typescript. But when coding in Javascript, Ruby or Python, no matter how fancy or language-focused an IDE is, I&#x27;ll be grepping a lot. Decades of Ruby and Rails &quot;black magic&quot; taught me to grep for partial patterns like the author shows, too. Or to just run the code-path entirely (through tests) because the table-definition of the database will change the available methods and behaviour of the code. Yes. I know.<p>An LSP (or linter, or checker) can only do so much when the available code, methods, classes, behaviour can be changed or added at runtime.</div><br/><div id="41441312" class="c"><input type="checkbox" id="c-41441312" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41432296">root</a><span>|</span><a href="#41432348">parent</a><span>|</span><a href="#41432402">next</a><span>|</span><label class="collapse" for="c-41441312">[-]</label><label class="expand" for="c-41441312">[1 more]</label></div><br/><div class="children"><div class="content">Then again, in languages like Java that go all-in on object orientation and dynamic dispatch, &quot;go to definition&quot; can become a real chore in sufficiently large codebases. I must have wasted hours of my life trying to find which class is the one implementing some interface or abstract method at a certain point. Bonus points if the implementing class changes based on ordinary runtime conditions.</div><br/></div></div><div id="41432402" class="c"><input type="checkbox" id="c-41432402" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41432296">root</a><span>|</span><a href="#41432348">parent</a><span>|</span><a href="#41441312">prev</a><span>|</span><a href="#41431886">next</a><span>|</span><label class="collapse" for="c-41432402">[-]</label><label class="expand" for="c-41432402">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy to use dynamic languages occasionally too (Bash, Javascript, Python, ..) but I have a rule of thumb that says if I can&#x27;t see the entire codebase on one screen, then it&#x27;s too large for dynamic.</div><br/><div id="41433626" class="c"><input type="checkbox" id="c-41433626" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41432296">root</a><span>|</span><a href="#41432402">parent</a><span>|</span><a href="#41431886">next</a><span>|</span><label class="collapse" for="c-41433626">[-]</label><label class="expand" for="c-41433626">[1 more]</label></div><br/><div class="children"><div class="content">Would be great if the wider industry shared that view</div><br/></div></div></div></div></div></div></div></div><div id="41431886" class="c"><input type="checkbox" id="c-41431886" checked=""/><div class="controls bullet"><span class="by">whirlwin</span><span>|</span><a href="#41432296">prev</a><span>|</span><a href="#41431072">next</a><span>|</span><label class="collapse" for="c-41431886">[-]</label><label class="expand" for="c-41431886">[1 more]</label></div><br/><div class="children"><div class="content">Code grepping at build time can be useful.<p>Grepping at at runtime, if you can call it that, is also very powerful. If you have a binary, either your company or a third party one, but don&#x27;t have the source code easily available, I have used the `strings` program from GNU binutils  which shows tokens in binary code, e.g. hardcoded URLs, credentials and so on. It can also be useful for analyzing certain things in memory.</div><br/></div></div><div id="41431072" class="c"><input type="checkbox" id="c-41431072" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41431886">prev</a><span>|</span><a href="#41440568">next</a><span>|</span><label class="collapse" for="c-41431072">[-]</label><label class="expand" for="c-41431072">[13 more]</label></div><br/><div class="children"><div class="content">A lot of this reads like code search tools could and should be a lot better. They probably will be with AI finding its way into everything. In the old days, people would Hungarian prefix types, but now the IDE mitigates that with color codes.</div><br/><div id="41431088" class="c"><input type="checkbox" id="c-41431088" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41431072">parent</a><span>|</span><a href="#41431102">next</a><span>|</span><label class="collapse" for="c-41431088">[-]</label><label class="expand" for="c-41431088">[6 more]</label></div><br/><div class="children"><div class="content">Do you have some ideas for how to make code search better?<p>Right now, code search is basically just text search. If you think code search tools “could and should” be a lot better, what kind of improvements are you thinking about? How would those improvements work?</div><br/><div id="41431142" class="c"><input type="checkbox" id="c-41431142" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431088">parent</a><span>|</span><a href="#41431299">next</a><span>|</span><label class="collapse" for="c-41431142">[-]</label><label class="expand" for="c-41431142">[3 more]</label></div><br/><div class="children"><div class="content">Not OP, but we wouldn&#x27;t need to worry so much about picking out distinct greppable names <i>if</i> (big if) there were tools that parsed the code to draw out concepts for us, ex:<p>1. The popular &quot;Find Usages&quot; which varies widely in accuracy  and reliability by language, IDE, and codebase meta-quirks.<p>2. Tools that show Callee&#x2F;Caller trees, and sometimes possible data-flows between variables.<p>3. DSLs to search hierarchies, like how XPath lets you find XML elements based on nesting, rather than relying on a distinctly greppable <i>single</i> tag-name for the leaf you&#x27;re interested in. (e.g. `&lt;Product&gt;&lt;Name&gt;` vs `&lt;ProductName&gt;`)<p>When things go well, the actual variable name no longer needs to restate certain aspects and relationships that can instead be found through metadata.<p>For example, `GiftCard.purchaser_customer_uuid` is nicely greppable, but you could relax that to `GiftCard.purchaser` if it had a static type of `UUID&lt;Customer&gt;`. Or perhaps you could go to the `Customer.uuid` definition and say &quot;Show me all variables that can populate or be-populated-by this one, up to X steps out, and excluding ones that are function scoped.&quot;<p>That said, I <i>do</i> advocate for &quot;greppability&quot; as a general practice, since I seldom trust that languages, tools, or institutions will come together in a way that makes it unnecessary.</div><br/><div id="41431564" class="c"><input type="checkbox" id="c-41431564" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431142">parent</a><span>|</span><a href="#41431855">next</a><span>|</span><label class="collapse" for="c-41431564">[-]</label><label class="expand" for="c-41431564">[1 more]</label></div><br/><div class="children"><div class="content">I guess I wasn’t thinking of “find usages”, but as the article points out, it’s hard to find usages if the usages are dynamic.<p>The solution—to write code which is <i>less</i> dynamic—helps code search and features like find usages.</div><br/></div></div><div id="41431855" class="c"><input type="checkbox" id="c-41431855" checked=""/><div class="controls bullet"><span class="by">alexpovel</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431142">parent</a><span>|</span><a href="#41431564">prev</a><span>|</span><a href="#41431299">next</a><span>|</span><label class="collapse" for="c-41431855">[-]</label><label class="expand" for="c-41431855">[1 more]</label></div><br/><div class="children"><div class="content">Regarding your third point, I put together a tool capable of that to some degree.<p>It allows you to grep inside source code, but limit the search to e.g. “only docstrings inside class definitions”, among other things. That is, it allows nesting and is syntax aware. That example is for Python, but the tool speaks more languages (thanks to treesitter).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;alexpovel&#x2F;srgn&#x2F;blob&#x2F;main&#x2F;README.md#multiple-language-scopes">https:&#x2F;&#x2F;github.com&#x2F;alexpovel&#x2F;srgn&#x2F;blob&#x2F;main&#x2F;README.md#multip...</a></div><br/></div></div></div></div><div id="41431299" class="c"><input type="checkbox" id="c-41431299" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431088">parent</a><span>|</span><a href="#41431142">prev</a><span>|</span><a href="#41431152">next</a><span>|</span><label class="collapse" for="c-41431299">[-]</label><label class="expand" for="c-41431299">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Right now, code search is basically just text search.<p>We have lots of code search that is much more syntax-aware than just text search, but it tends to be behind very limited UI, because we have all the tech to do much better code search, but no one has come up with a generally-usable UI for it, so we just have very specific instances -- like &quot;go to definition&quot;, &quot;find references&quot; , etc.<p>That takes all the same technological bits that would be need for, say, &quot;find all definitions of functions visible in the current scope whose name starts with &#x27;ban&#x27;&quot; or &quot;find all definitions of int8 constants visible in the current scope&quot;...but what&#x27;s the UI that makes that kind of searching outside of the kind of special cases now behind their own IDE menu items usable?</div><br/></div></div><div id="41431152" class="c"><input type="checkbox" id="c-41431152" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431088">parent</a><span>|</span><a href="#41431299">prev</a><span>|</span><a href="#41431102">next</a><span>|</span><label class="collapse" for="c-41431152">[-]</label><label class="expand" for="c-41431152">[1 more]</label></div><br/><div class="children"><div class="content">Vector embeddings.</div><br/></div></div></div></div><div id="41431102" class="c"><input type="checkbox" id="c-41431102" checked=""/><div class="controls bullet"><span class="by">ddfs123</span><span>|</span><a href="#41431072">parent</a><span>|</span><a href="#41431088">prev</a><span>|</span><a href="#41440568">next</a><span>|</span><label class="collapse" for="c-41431102">[-]</label><label class="expand" for="c-41431102">[6 more]</label></div><br/><div class="children"><div class="content">Unless you have syntax-aware grep support, I don&#x27;t see how searching nested key json could be better. But grep is the default installed. Not to mention ad-hoc languages that does not have any IDE support.</div><br/><div id="41431150" class="c"><input type="checkbox" id="c-41431150" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431102">parent</a><span>|</span><a href="#41431219">next</a><span>|</span><label class="collapse" for="c-41431150">[-]</label><label class="expand" for="c-41431150">[2 more]</label></div><br/><div class="children"><div class="content">If you put a lot of arbitrary constraints to not allow it to be better, sure. Enjoy.</div><br/><div id="41433661" class="c"><input type="checkbox" id="c-41433661" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431150">parent</a><span>|</span><a href="#41431219">next</a><span>|</span><label class="collapse" for="c-41433661">[-]</label><label class="expand" for="c-41433661">[1 more]</label></div><br/><div class="children"><div class="content">There is no conflict between improving tools and learning how to express your code in such a way that as many tools as possible work better OOTB.</div><br/></div></div></div></div><div id="41431219" class="c"><input type="checkbox" id="c-41431219" checked=""/><div class="controls bullet"><span class="by">uasi</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431102">parent</a><span>|</span><a href="#41431150">prev</a><span>|</span><a href="#41431266">next</a><span>|</span><label class="collapse" for="c-41431219">[-]</label><label class="expand" for="c-41431219">[2 more]</label></div><br/><div class="children"><div class="content">gron makes nested JSON greppable <a href="https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron">https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron</a></div><br/><div id="41434358" class="c"><input type="checkbox" id="c-41434358" checked=""/><div class="controls bullet"><span class="by">hoherd</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431219">parent</a><span>|</span><a href="#41431266">next</a><span>|</span><label class="collapse" for="c-41434358">[-]</label><label class="expand" for="c-41434358">[1 more]</label></div><br/><div class="children"><div class="content">`gron` is so underrated. Usually when I try to show people who useful it is they don&#x27;t seem to understand how powerful it is. One common use is showing how to customize only one part of a helm chart by checking values of an already installed chart:<p><pre><code>    $ helm get values -n $NS $DEPLOYMENT -o json | gron | grep resources | gron -u | json-to-yaml.py
    elasticsearch:
      client:
        resources:
          limits:
            cpu: 3
            memory: 4Gi
          requests:
            cpu: 1
            memory: 2Gi
      data:
        resources:
          limits:
            cpu: 6
            memory: 6Gi
          requests:
            cpu: 200m
            memory: 2Gi
    fluentd:
      resources:
        limits:
          memory: 768Mi
        requests:
          memory: 384Mi
</code></pre>
That snip could be provided to another team or a customer as a yaml file that could be included with `helm upgrade -f whatever.yaml`. This is soooo much easier than digging that limited set of data out of the much more detailed data.</div><br/></div></div></div></div><div id="41431266" class="c"><input type="checkbox" id="c-41431266" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431102">parent</a><span>|</span><a href="#41431219">prev</a><span>|</span><a href="#41440568">next</a><span>|</span><label class="collapse" for="c-41431266">[-]</label><label class="expand" for="c-41431266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ad-hoc languages<p>This is self-inflicted.</div><br/></div></div></div></div></div></div><div id="41440568" class="c"><input type="checkbox" id="c-41440568" checked=""/><div class="controls bullet"><span class="by">krawczstef</span><span>|</span><a href="#41431072">prev</a><span>|</span><a href="#41437311">next</a><span>|</span><label class="collapse" for="c-41440568">[-]</label><label class="expand" for="c-41440568">[1 more]</label></div><br/><div class="children"><div class="content">Yep. When I was designing <a href="https:&#x2F;&#x2F;github.com&#x2F;dagworks-inc&#x2F;hamilton">https:&#x2F;&#x2F;github.com&#x2F;dagworks-inc&#x2F;hamilton</a> part of the idea was to make it easy to understand what and where. That is, enable one to grep for function definitions and their downstream use easily, and where people can&#x27;t screw this up. You&#x27;d be surprised how easy it is to make a code base where grep doesn&#x27;t help you all that much (at least in the python data transform world) ...</div><br/></div></div><div id="41437311" class="c"><input type="checkbox" id="c-41437311" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41440568">prev</a><span>|</span><a href="#41432856">next</a><span>|</span><label class="collapse" for="c-41437311">[-]</label><label class="expand" for="c-41437311">[1 more]</label></div><br/><div class="children"><div class="content">I work on a project where people decided to refer to translations by doing the equivalent of:<p><pre><code>  :label=&quot;$translate(getProductSectionLabel(&#x27;title&#x27;))&quot;
</code></pre>
where the logic is a bit like:<p><pre><code>  const getProductSectionLabel = (code) =&gt; `myapp.sales.sections.products.${code}`
</code></pre>
and then the actual values are in a nested structure, like:<p><pre><code>  myapp: {
    sales: {
      sections: {
       products: {
         title: &quot;Products&quot;
         ...
       }
       ...
     }
     ...
    }
    ...
  }
</code></pre>
People seem to have gone for that because writing that first part is simpler within the component, but I couldn&#x27;t get across that this makes the codebase harder to navigate.<p>Meanwhile, my personal codebases are more like:<p><pre><code>  :label&quot;$translate(&#x27;myapp-sales-products-title&#x27;)&quot;
</code></pre>
and the translation file also has the equivalent of:<p><pre><code>  myapp-sales-products-title: &quot;Products&quot;
</code></pre>
which is way simpler at the expense of some more duplication (easily mitigated by compressing the translations).</div><br/></div></div><div id="41432856" class="c"><input type="checkbox" id="c-41432856" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#41437311">prev</a><span>|</span><a href="#41439608">next</a><span>|</span><label class="collapse" for="c-41432856">[-]</label><label class="expand" for="c-41432856">[1 more]</label></div><br/><div class="children"><div class="content">Conceptually it is akin to having file names that sort well.<p>Grep is a simple tool, not too different from a simple string sort. It is better than no tool, but is it better than a tool that understands the notation? A strong side of grep is that it is universal and is not tied to a particular notation. Yet if you could easily define a specific notation and have a tool to immediately understand it, would you still prefer grep?<p>We tend to organize the code according to the tools we have. E.g. if a tool gives us a list of entities in alphabetic order, we will try to name the entities so that they form “logical” groups. This may pass as a local organizational principle and may be useful but it is always intimately coupled with the underlying tool.</div><br/></div></div><div id="41439608" class="c"><input type="checkbox" id="c-41439608" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#41432856">prev</a><span>|</span><a href="#41432471">next</a><span>|</span><label class="collapse" for="c-41439608">[-]</label><label class="expand" for="c-41439608">[1 more]</label></div><br/><div class="children"><div class="content">CSS preprocessors are often used in a way that hurts &quot;greppability&quot;. For example, SCSS developers often break identifiers like<p><pre><code>    .product {
        &amp;-promo {
</code></pre>
I always felt it was a bad practice but nevertheless it is often used. Glad to find out that I am not the only one who noticed this.<p>Of course, one might say that I should have used a specialized tool for this. But it would be more convenient if I could search anything with text search. Also, there is no tool that allows to search over identifiers that are calculated in runtime in a program.</div><br/></div></div><div id="41432471" class="c"><input type="checkbox" id="c-41432471" checked=""/><div class="controls bullet"><span class="by">kmarc</span><span>|</span><a href="#41439608">prev</a><span>|</span><label class="collapse" for="c-41432471">[-]</label><label class="expand" for="c-41432471">[1 more]</label></div><br/><div class="children"><div class="content">Some good recommendations in the article.<p>Greppability is also helpful when you start scripting your editor. Vim has `includeexpr` and co. to implement some &quot;intelligence&quot; when trying to find declarations etc. This enabled me to write a couple line snippet that immediately could resolve Bazel starlark symbols even in &quot;imported&quot; (`load()`) files. At one point I realized I have better code navigation than any of my colleagues using IDEs.<p>This, and tools like ripgrep really help a lot. This is something that VS Code developers also realized when indlcluded ripgrep itself as their &quot;backend&quot; of searching in files.</div><br/></div></div></div></div></div></div></div></body></html>