<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725354074872" as="style"/><link rel="stylesheet" href="styles.css?v=1725354074872"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://morizbuesing.com/blog/greppability-code-metric/">Greppability is an underrated code metric</a> <span class="domain">(<a href="https://morizbuesing.com">morizbuesing.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>181 comments</span></div><br/><div><div id="41432795" class="c"><input type="checkbox" id="c-41432795" checked=""/><div class="controls bullet"><span class="by">arendtio</span><span>|</span><a href="#41432094">next</a><span>|</span><label class="collapse" for="c-41432795">[-]</label><label class="expand" for="c-41432795">[1 more]</label></div><br/><div class="children"><div class="content">I am firmly against the suggested changes. I love grepping through code too (often using -A -B -C), but I also like browsing the code, with tools where you can just click on a function and see its definition.<p>However, changing how the code should be written so that grepping becomes easier is optimizing for the wrong target. It is much more important that the code is easily readable and maintainable.<p>In addition, some tools are designed explicitly for grepping through code (from the top of my head ack is an example). If grep doesn&#x27;t work, one should try a more sophisticated tool instead of using different coding styles.</div><br/></div></div><div id="41432094" class="c"><input type="checkbox" id="c-41432094" checked=""/><div class="controls bullet"><span class="by">VoxPelli</span><span>|</span><a href="#41432795">prev</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41432094">[-]</label><label class="expand" for="c-41432094">[16 more]</label></div><br/><div class="children"><div class="content">I advocate for greppability as well – and in Swedish it becomes extra fun – as the equivalent phrase in Swedish becomes &quot;grep-bar&quot; or &quot;grep-barhet&quot; and those are actual words in Swedish – &quot;greppbar&quot; roughly means &quot;understandable&quot;, &quot;greppbarhet&quot; roughly means &quot;the possibility to understand&quot;</div><br/><div id="41432153" class="c"><input type="checkbox" id="c-41432153" checked=""/><div class="controls bullet"><span class="by">elygre</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41432153">[-]</label><label class="expand" for="c-41432153">[2 more]</label></div><br/><div class="children"><div class="content">Could I suggest that greppbarhet is more precisely translated as “the ability of being understood”?<p>(Norwegian here. Our languages are similar, but we miss this one.)</div><br/><div id="41432624" class="c"><input type="checkbox" id="c-41432624" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432153">parent</a><span>|</span><a href="#41432453">next</a><span>|</span><label class="collapse" for="c-41432624">[-]</label><label class="expand" for="c-41432624">[1 more]</label></div><br/><div class="children"><div class="content">So, at the extrem opposite of the esoteric &quot;general regular expression print&quot; that grep stands for with few ever knowing it?</div><br/></div></div></div></div><div id="41432453" class="c"><input type="checkbox" id="c-41432453" checked=""/><div class="controls bullet"><span class="by">octocop</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432153">prev</a><span>|</span><a href="#41432549">next</a><span>|</span><label class="collapse" for="c-41432453">[-]</label><label class="expand" for="c-41432453">[1 more]</label></div><br/><div class="children"><div class="content">And we also have &quot;begrepp&quot;, which is also a spin on content and understanding it&#x27;s content.</div><br/></div></div><div id="41432549" class="c"><input type="checkbox" id="c-41432549" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432453">prev</a><span>|</span><a href="#41432351">next</a><span>|</span><label class="collapse" for="c-41432549">[-]</label><label class="expand" for="c-41432549">[1 more]</label></div><br/><div class="children"><div class="content">Which is ironic, given that the article is about making it easier to use grep <i>in order to avoid having to understand anything</i>.</div><br/></div></div><div id="41432351" class="c"><input type="checkbox" id="c-41432351" checked=""/><div class="controls bullet"><span class="by">vanschelven</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432549">prev</a><span>|</span><a href="#41432278">next</a><span>|</span><label class="collapse" for="c-41432351">[-]</label><label class="expand" for="c-41432351">[3 more]</label></div><br/><div class="children"><div class="content">Begreppelijk (begrijpelijk) in Dutch</div><br/><div id="41432782" class="c"><input type="checkbox" id="c-41432782" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432351">parent</a><span>|</span><a href="#41432560">next</a><span>|</span><label class="collapse" for="c-41432782">[-]</label><label class="expand" for="c-41432782">[1 more]</label></div><br/><div class="children"><div class="content">or &quot;Grijpbaar&quot; (grabbable)</div><br/></div></div></div></div><div id="41432278" class="c"><input type="checkbox" id="c-41432278" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#41432094">parent</a><span>|</span><a href="#41432351">prev</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41432278">[-]</label><label class="expand" for="c-41432278">[8 more]</label></div><br/><div class="children"><div class="content">How many other UNIX commands did the Swedes adopt into their language?<p>I know that they invented &quot;curl&quot;. Do you <i>tar xfz</i>?</div><br/><div id="41432518" class="c"><input type="checkbox" id="c-41432518" checked=""/><div class="controls bullet"><span class="by">scbrg</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432278">parent</a><span>|</span><a href="#41432799">next</a><span>|</span><label class="collapse" for="c-41432518">[-]</label><label class="expand" for="c-41432518">[1 more]</label></div><br/><div class="children"><div class="content">We do tar, for xfz I think you have to look to the Slavic languages :)<p>Anyway, to answer your question:<p><pre><code>  $ grep -Fxf &lt;(ls -1 &#x2F;bin) &#x2F;usr&#x2F;share&#x2F;dict&#x2F;swedish 
  ack
  ar
  as
  black
  dialog
  dig
  du
  ebb
  ed
  editor
  finger
  flock
  gem
  glade
  grep
  id
  import
  last
  less
  make
  man
  montage
  pager
  pass
  pc
  plog
  red
  reset
  rev
  sed
  sort
  sorter
  split
  stat
  tar
  test
  transform
  vi
</code></pre>
:)<p>[edit]: Ironically, <i>grep</i> in that list is <i>not</i> the same word as the one OP is talking about. That one is actually based on <i>grepp</i>, with the double p. <i>grep</i> means pitchfork.</div><br/></div></div><div id="41432799" class="c"><input type="checkbox" id="c-41432799" checked=""/><div class="controls bullet"><span class="by">tripzilch</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432278">parent</a><span>|</span><a href="#41432518">prev</a><span>|</span><a href="#41432316">next</a><span>|</span><label class="collapse" for="c-41432799">[-]</label><label class="expand" for="c-41432799">[1 more]</label></div><br/><div class="children"><div class="content">I learned from bash.org that &quot;tar -xzvf&quot; is in German accent for &quot;xtract ze vucking files&quot;.</div><br/></div></div><div id="41432316" class="c"><input type="checkbox" id="c-41432316" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432278">parent</a><span>|</span><a href="#41432799">prev</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41432316">[-]</label><label class="expand" for="c-41432316">[5 more]</label></div><br/><div class="children"><div class="content">As far as I understood, it was part of the language before.<p>The german equivalent of the word would be probably &quot;greifbar&quot;. Being able to hold something, usually used metaphorically.</div><br/><div id="41432395" class="c"><input type="checkbox" id="c-41432395" checked=""/><div class="controls bullet"><span class="by">ManuelKiessling</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432316">parent</a><span>|</span><a href="#41432330">next</a><span>|</span><label class="collapse" for="c-41432395">[-]</label><label class="expand" for="c-41432395">[1 more]</label></div><br/><div class="children"><div class="content">Which leads to &quot;begreifbar&quot;, which I would explain&#x2F;translate (badly) with &quot;something is begreifbar if it can be understood&quot;.</div><br/></div></div><div id="41432330" class="c"><input type="checkbox" id="c-41432330" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432316">parent</a><span>|</span><a href="#41432395">prev</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41432330">[-]</label><label class="expand" for="c-41432330">[3 more]</label></div><br/><div class="children"><div class="content">&gt; able to hold<p>Would &quot;grasp&quot; work?</div><br/><div id="41432438" class="c"><input type="checkbox" id="c-41432438" checked=""/><div class="controls bullet"><span class="by">octocop</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432330">parent</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41432438">[-]</label><label class="expand" for="c-41432438">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s closer to grip</div><br/><div id="41432692" class="c"><input type="checkbox" id="c-41432692" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41432094">root</a><span>|</span><a href="#41432438">parent</a><span>|</span><a href="#41431114">next</a><span>|</span><label class="collapse" for="c-41432692">[-]</label><label class="expand" for="c-41432692">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always related grep to grab</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41431114" class="c"><input type="checkbox" id="c-41431114" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41432094">prev</a><span>|</span><a href="#41431701">next</a><span>|</span><label class="collapse" for="c-41431114">[-]</label><label class="expand" for="c-41431114">[50 more]</label></div><br/><div class="children"><div class="content">Rust and Javascript and Lisp all get extra points because they put a keyword in front of every function definition. Searching for “fn doTheThing” or “defun do-the-thing” ensures that you find the actual definition. Meanwhile C lacks any such keyword, so the best you can do is search for the name. That gets you a sea of callers with the declarations and definitions mixed in. Some C coding conventions have you split the definition into two lines, first the return type on a line followed by a second line that starts with the function name. It looks ugly, but at least you can search for “^doTheThing” to find just the definition(s).</div><br/><div id="41431417" class="c"><input type="checkbox" id="c-41431417" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432037">next</a><span>|</span><label class="collapse" for="c-41431417">[-]</label><label class="expand" for="c-41431417">[3 more]</label></div><br/><div class="children"><div class="content">Golang has a similar property as a side-effect of the following design decision.<p><pre><code>  ... the language has been designed to be easy to analyze and can be parsed without a symbol table
</code></pre>
Taken from  <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq</a><p>The &quot;top-level declarations&quot; in source files are exactly: package, import, const, var, type, func. Nothing else. If you&#x27;re searching for a function, it&#x27;s always going to start with &quot;func&quot;, even if it&#x27;s an anonymous function. Searching for methods implemented by a struct similarly only needs one to know the &quot;func&quot; keyword and the name of the struct.<p>Coming from a background of mostly Clojure, Common Lisp, and TypeScript, the &quot;greppability&quot; of Go code is by far the best I have seen.<p>Of course, in any language, Go included, it&#x27;s always better to rely on static analysis tools (like the IDE or LSP server) to find references, definitions, etc. But when searching code of some open source library, I always resort to ripgrep rather than setting up a development environment, unless I found something that I want to patch (which in case I set up the devlopment environment and rely on LSP instead of grep to discover definitions and references).</div><br/><div id="41432693" class="c"><input type="checkbox" id="c-41432693" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41432217">next</a><span>|</span><label class="collapse" for="c-41432693">[-]</label><label class="expand" for="c-41432693">[1 more]</label></div><br/><div class="children"><div class="content">The culture of single letter variables in golang, at least in the codebases I&#x27;ve seen, undoes this.</div><br/></div></div><div id="41432217" class="c"><input type="checkbox" id="c-41432217" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431417">parent</a><span>|</span><a href="#41432693">prev</a><span>|</span><a href="#41432037">next</a><span>|</span><label class="collapse" for="c-41432217">[-]</label><label class="expand" for="c-41432217">[1 more]</label></div><br/><div class="children"><div class="content">Golang gets zero points from me because function receivers are declared between func and the name of the function. God ai hate this design choice and boy am I glad I can use golsp.</div><br/></div></div></div></div><div id="41432037" class="c"><input type="checkbox" id="c-41432037" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431417">prev</a><span>|</span><a href="#41431546">next</a><span>|</span><label class="collapse" for="c-41432037">[-]</label><label class="expand" for="c-41432037">[1 more]</label></div><br/><div class="children"><div class="content">C is so much worse than that. Many people declare symbols using macros for various reasons, so you end up with things like DEFINE_FUNCTION(foo) {. In order to get a complete list of symbols you need to preprocess it, this requires knowing what the compiler flags are. Nobody really knows what their compiler flags are because they are hidden between multiple levels of indirection and a variety of build systems.</div><br/></div></div><div id="41431546" class="c"><input type="checkbox" id="c-41431546" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432037">prev</a><span>|</span><a href="#41431222">next</a><span>|</span><label class="collapse" for="c-41431546">[-]</label><label class="expand" for="c-41431546">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript has multiple ways to define a function so you sort of lose that getting the actual definition benefit.<p>on edit: I see someone discussed that you can grep for both arrow functions and named function at the same time and I suppose you can also construct a query that handles a function constructor as well - but this does not really handle curried functions or similar patterns - I guess at that point one is letting the perfect become the enemy of the good.<p>Most people grepping know the code base and the patterns in use, so they probably only need to grep for one type of function declaration.</div><br/></div></div><div id="41431222" class="c"><input type="checkbox" id="c-41431222" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431546">prev</a><span>|</span><a href="#41432789">next</a><span>|</span><label class="collapse" for="c-41431222">[-]</label><label class="expand" for="c-41431222">[31 more]</label></div><br/><div class="children"><div class="content">Not JavaScript. Cool kids never write “function” any more, it’s all arrow functions. You can search for const, which will typically work, but not always (could be a let, var, or multi-const intializer).</div><br/><div id="41432163" class="c"><input type="checkbox" id="c-41432163" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431235">next</a><span>|</span><label class="collapse" for="c-41432163">[-]</label><label class="expand" for="c-41432163">[6 more]</label></div><br/><div class="children"><div class="content">Yes but that’s an anti pattern. Arrow functions aren’t there to look cool, they’re how you define lambdas &#x2F; anonymous functions.<p>Other than that, functions should be defined by the keyword.</div><br/><div id="41432242" class="c"><input type="checkbox" id="c-41432242" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432163">parent</a><span>|</span><a href="#41432449">prev</a><span>|</span><a href="#41431235">next</a><span>|</span><label class="collapse" for="c-41432242">[-]</label><label class="expand" for="c-41432242">[4 more]</label></div><br/><div class="children"><div class="content">How is that an anti-pattern?<p>&gt; Other than that, functions should be defined by the keyword.<p>Says who?</div><br/><div id="41432615" class="c"><input type="checkbox" id="c-41432615" checked=""/><div class="controls bullet"><span class="by">hansworst</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432242">parent</a><span>|</span><a href="#41432418">next</a><span>|</span><label class="collapse" for="c-41432615">[-]</label><label class="expand" for="c-41432615">[1 more]</label></div><br/><div class="children"><div class="content">Anonymous functions don&#x27;t have names. This makes it much harder to do things like profiling (just try to find that one specific arrow function in your performance profile flame graph) and tracing. Tools like Sentry that automatically log stack traces when errors occur become much less useful if every function is anonymous.</div><br/></div></div><div id="41432418" class="c"><input type="checkbox" id="c-41432418" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432242">parent</a><span>|</span><a href="#41432615">prev</a><span>|</span><a href="#41432326">next</a><span>|</span><label class="collapse" for="c-41432418">[-]</label><label class="expand" for="c-41432418">[1 more]</label></div><br/><div class="children"><div class="content">As of a few years ago (not sure about now) the backtrace frame info for anonymous functions were far worse than ones defined via the function keyword with a name.</div><br/></div></div><div id="41432326" class="c"><input type="checkbox" id="c-41432326" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432242">parent</a><span>|</span><a href="#41432418">prev</a><span>|</span><a href="#41431235">next</a><span>|</span><label class="collapse" for="c-41432326">[-]</label><label class="expand" for="c-41432326">[1 more]</label></div><br/><div class="children"><div class="content">All the wise ones. Well, except for you maybe.<p>Serious arguments would be:<p>- readability
- greppabiloty</div><br/></div></div></div></div></div></div><div id="41431235" class="c"><input type="checkbox" id="c-41431235" checked=""/><div class="controls bullet"><span class="by">lispisok</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41432163">prev</a><span>|</span><a href="#41431240">next</a><span>|</span><label class="collapse" for="c-41431235">[-]</label><label class="expand" for="c-41431235">[14 more]</label></div><br/><div class="children"><div class="content">Am I the only one who hates arrow functions?</div><br/><div id="41432003" class="c"><input type="checkbox" id="c-41432003" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431342">next</a><span>|</span><label class="collapse" for="c-41432003">[-]</label><label class="expand" for="c-41432003">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like using them <i>everywhere</i>, but they&#x27;re very handy for inline anonymous functions.<p>But it really pains me when I see<p>export const foo = () =&gt; {}<p>instead of<p>export function foo() {}</div><br/><div id="41432031" class="c"><input type="checkbox" id="c-41432031" checked=""/><div class="controls bullet"><span class="by">creesch</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432003">parent</a><span>|</span><a href="#41432234">next</a><span>|</span><label class="collapse" for="c-41432031">[-]</label><label class="expand" for="c-41432031">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, that&#x27;s something I also never have understood myself. For inline anonymous functions like callbacks they make perfect sense. As long as you don&#x27;t need `this`.<p>But everywhere else they reduce readability of the code with no tangible benefit I am aware of.</div><br/></div></div><div id="41432234" class="c"><input type="checkbox" id="c-41432234" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432003">parent</a><span>|</span><a href="#41432031">prev</a><span>|</span><a href="#41431342">next</a><span>|</span><label class="collapse" for="c-41432234">[-]</label><label class="expand" for="c-41432234">[2 more]</label></div><br/><div class="children"><div class="content">I wish javascript had a built-in or at least (defacto) default linter. Like go-fmt or rust fmt. Or clippy even.<p>One that could enforce these styles. Because not only is the 
export const foo = () {}<p>painful on itself, it will quite certainly get intermixed with the<p>function foo() {}<p>and then in the next library a<p>const foo = function() {}<p>and so on. I&#x27;d rather have a consistently irritating style, than this willy-nilly yolo style that the JS community seems to embrace.</div><br/><div id="41432537" class="c"><input type="checkbox" id="c-41432537" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432234">parent</a><span>|</span><a href="#41431342">next</a><span>|</span><label class="collapse" for="c-41432537">[-]</label><label class="expand" for="c-41432537">[1 more]</label></div><br/><div class="children"><div class="content">ESLint and Prettier are the de facto default linter&#x2F;formatter combo in JS. There are rules you can enable to enforce your preferred style of function [1][2].<p>[1] <a href="https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;func-style" rel="nofollow">https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;func-style</a><p>[2] <a href="https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;prefer-arrow-callback" rel="nofollow">https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;prefer-arrow-callback</a></div><br/></div></div></div></div></div></div><div id="41431342" class="c"><input type="checkbox" id="c-41431342" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41432003">prev</a><span>|</span><a href="#41431910">next</a><span>|</span><label class="collapse" for="c-41431342">[-]</label><label class="expand" for="c-41431342">[2 more]</label></div><br/><div class="children"><div class="content">I did, until I used them enough where I saw where they were useful.<p>The bad examples of arrow functions I saw initially were of:<p>1. Devs trying to mix them in with OOP code as a bandaid over OOP headahes (e.g. bind&#x2F;this) instead of just not using OOP in the first place.<p>2. Devs trying to stick functional programming everywhere because they had seen a trivial example where a `.map()` made more semantic sense than a for&#x2F;for-in&#x2F;for-of loop. Despite the fact that for&#x2F;for-in&#x2F;for-of loops were easier to read for anything non-trivial and also had better performance because you had access to the `break`, `continue` and `return` keywords.</div><br/><div id="41432286" class="c"><input type="checkbox" id="c-41432286" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431342">parent</a><span>|</span><a href="#41431910">next</a><span>|</span><label class="collapse" for="c-41432286">[-]</label><label class="expand" for="c-41432286">[1 more]</label></div><br/><div class="children"><div class="content">Another benefit of using for instead of array fns is that it is easy to add await keyword should the fn become async.<p>But many teams will have it as a rule to always use array fns.</div><br/></div></div></div></div><div id="41431910" class="c"><input type="checkbox" id="c-41431910" checked=""/><div class="controls bullet"><span class="by">nosianu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431342">prev</a><span>|</span><a href="#41431942">next</a><span>|</span><label class="collapse" for="c-41431910">[-]</label><label class="expand" for="c-41431910">[1 more]</label></div><br/><div class="children"><div class="content">A simple heuristic I use is to use arrow functions for inline function arguments, and named &quot;function&quot; functions for all others.<p>One reason is exactly what the subject of discussion is here, it&#x27;s easier to string-search with that keyword in front of the name, but I don&#x27;t need that for trivial inline functions (whenever I do I make it an actual function that I declare normally and not inline).<p>Then there&#x27;s the different handling of &quot;this&quot;, depending on how you write your code this may be an important reason to use an arrow function in some places.</div><br/></div></div><div id="41431942" class="c"><input type="checkbox" id="c-41431942" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431910">prev</a><span>|</span><a href="#41431524">next</a><span>|</span><label class="collapse" for="c-41431942">[-]</label><label class="expand" for="c-41431942">[4 more]</label></div><br/><div class="children"><div class="content">I like them because it reinforces the idea that functions are just values like any other - having a separate keyword feels like it is inconsistent.</div><br/><div id="41432134" class="c"><input type="checkbox" id="c-41432134" checked=""/><div class="controls bullet"><span class="by">0xfffafaCrash</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431942">parent</a><span>|</span><a href="#41432294">next</a><span>|</span><label class="collapse" for="c-41432134">[-]</label><label class="expand" for="c-41432134">[1 more]</label></div><br/><div class="children"><div class="content">Moreover the binding and lexical scope aspects supported by classic functions are amongst the worst aspects of the language.<p>Arrow functions are also far more concise and ergonomic when working with higher order functions or simple expressions<p>The main thing to be wary of with arrow functions is when they are used anonymously inline without it being clear what the function is doing at a glance. That and Error stack traces but the latter is exacerbated by there being no actual standard regarding Error.prototype.stack</div><br/></div></div><div id="41432294" class="c"><input type="checkbox" id="c-41432294" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431942">parent</a><span>|</span><a href="#41432134">prev</a><span>|</span><a href="#41431524">next</a><span>|</span><label class="collapse" for="c-41432294">[-]</label><label class="expand" for="c-41432294">[2 more]</label></div><br/><div class="children"><div class="content">Why do you want to reinforce that idea?<p>To me arrow functions mostly just decrease readability and makes them blend in too much, when it should be important distinction what is a function and what is not.</div><br/><div id="41432803" class="c"><input type="checkbox" id="c-41432803" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432294">parent</a><span>|</span><a href="#41431524">next</a><span>|</span><label class="collapse" for="c-41432803">[-]</label><label class="expand" for="c-41432803">[1 more]</label></div><br/><div class="children"><div class="content">Not to be dismissive, but because I like it - it just sits right with me.</div><br/></div></div></div></div></div></div><div id="41431524" class="c"><input type="checkbox" id="c-41431524" checked=""/><div class="controls bullet"><span class="by">ndnxncjdj</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431942">prev</a><span>|</span><a href="#41432176">next</a><span>|</span><label class="collapse" for="c-41431524">[-]</label><label class="expand" for="c-41431524">[1 more]</label></div><br/><div class="children"><div class="content">I very much prefer the way scoping is handled in arrow functions.</div><br/></div></div><div id="41432176" class="c"><input type="checkbox" id="c-41432176" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431235">parent</a><span>|</span><a href="#41431524">prev</a><span>|</span><a href="#41431240">next</a><span>|</span><label class="collapse" for="c-41432176">[-]</label><label class="expand" for="c-41432176">[1 more]</label></div><br/><div class="children"><div class="content">why the need to pronounce arbitrary preferences, who cares?</div><br/></div></div></div></div><div id="41431240" class="c"><input type="checkbox" id="c-41431240" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431235">prev</a><span>|</span><a href="#41432331">next</a><span>|</span><label class="collapse" for="c-41431240">[-]</label><label class="expand" for="c-41431240">[6 more]</label></div><br/><div class="children"><div class="content">You can still search for `&lt;keyword&gt; = \(.*\) =&gt; `, albeit it&#x27;s a bit cumbersome.</div><br/><div id="41431324" class="c"><input type="checkbox" id="c-41431324" checked=""/><div class="controls bullet"><span class="by">post-it</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431240">parent</a><span>|</span><a href="#41431782">next</a><span>|</span><label class="collapse" for="c-41431324">[-]</label><label class="expand" for="c-41431324">[2 more]</label></div><br/><div class="children"><div class="content">All you need is `&lt;keyword&gt; =`<p>Really, all you need is `&lt;keyword&gt;` and if the first result is a call to that function, just jump to its definition.</div><br/><div id="41431352" class="c"><input type="checkbox" id="c-41431352" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431324">parent</a><span>|</span><a href="#41431782">next</a><span>|</span><label class="collapse" for="c-41431352">[-]</label><label class="expand" for="c-41431352">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>Just search the definition.<p>Any time that a function doesn&#x27;t have a definition, it&#x27;s never the target of a search anyway.</div><br/></div></div></div></div><div id="41431782" class="c"><input type="checkbox" id="c-41431782" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431240">parent</a><span>|</span><a href="#41431324">prev</a><span>|</span><a href="#41432331">next</a><span>|</span><label class="collapse" for="c-41431782">[-]</label><label class="expand" for="c-41431782">[3 more]</label></div><br/><div class="children"><div class="content">All you need is a tool that actually understands the language.<p>It&#x27;s 2024 and HN still suggests using regular expressions to search through a code base.</div><br/><div id="41432356" class="c"><input type="checkbox" id="c-41432356" checked=""/><div class="controls bullet"><span class="by">lukan</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431782">parent</a><span>|</span><a href="#41432331">next</a><span>|</span><label class="collapse" for="c-41432356">[-]</label><label class="expand" for="c-41432356">[2 more]</label></div><br/><div class="children"><div class="content">Regex is a universal tool.<p>Your special tool might not work on plattform X, fails for edge case - and you generally don&#x27;t know how it works. With regex or simple string search - I am in control. And can understand why results show up, or investigate when they don&#x27;t, but should.</div><br/><div id="41432545" class="c"><input type="checkbox" id="c-41432545" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432356">parent</a><span>|</span><a href="#41432331">next</a><span>|</span><label class="collapse" for="c-41432545">[-]</label><label class="expand" for="c-41432545">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Your special tool might not work on plattform X<p>As always, people come out with the weirdest of excuses to not use actual tools in the 99.9999% of the cases when they are available, and work.<p>When that tools doesn&#x27;t work, or isn&#x27;t sufficient, use another one like fuzzy text search or regexps.<p>&gt; and you generally don&#x27;t know how it works.<p>Do you know how your stove works? Or do you truly understand what the device you&#x27;re typing this comment on truly works?<p>Only in programming I see people deliberately avoid useful tools because &lt;some fringe edge case that comes up once in a millenium in their daily work&gt;</div><br/></div></div></div></div></div></div></div></div><div id="41432331" class="c"><input type="checkbox" id="c-41432331" checked=""/><div class="controls bullet"><span class="by">albedoa</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41431240">prev</a><span>|</span><a href="#41431272">next</a><span>|</span><label class="collapse" for="c-41432331">[-]</label><label class="expand" for="c-41432331">[1 more]</label></div><br/><div class="children"><div class="content">I want to talk to the developer who considers greppability when deciding whether to use the &quot;function&quot; keyword but requires his definitions to be greppable by distancing them from their call locations. I just have a few questions for him.</div><br/></div></div><div id="41431272" class="c"><input type="checkbox" id="c-41431272" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431222">parent</a><span>|</span><a href="#41432331">prev</a><span>|</span><a href="#41432789">next</a><span>|</span><label class="collapse" for="c-41431272">[-]</label><label class="expand" for="c-41431272">[3 more]</label></div><br/><div class="children"><div class="content">Yes JavaScript.<p>You can search for both: &quot;function&quot; and &quot;=&gt;&quot; to find all function expressions and arrow function expressions.<p>All named functions are easily searchable.<p>All anonymous functions are throw away functions that are only called in one place so you don&#x27;t need to search for them in the first place.<p>As soon as an anonymous function becomes important enough to receive a label (i.e. assigning it to a variable, being assigned to a parameter, converting to function expression), it has also become searchable by that label too.</div><br/><div id="41431579" class="c"><input type="checkbox" id="c-41431579" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431272">parent</a><span>|</span><a href="#41432789">next</a><span>|</span><label class="collapse" for="c-41431579">[-]</label><label class="expand" for="c-41431579">[2 more]</label></div><br/><div class="children"><div class="content">The =&gt; is after the param spec, so you’re searching for foo.*=&gt; or something more complex, but then still missing multiline signatures. This is very easy to get caught by in TypeScript, and also happens when dealing with higher-order functions (quite common in React).</div><br/><div id="41431859" class="c"><input type="checkbox" id="c-41431859" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431579">parent</a><span>|</span><a href="#41432789">next</a><span>|</span><label class="collapse" for="c-41431859">[-]</label><label class="expand" for="c-41431859">[1 more]</label></div><br/><div class="children"><div class="content">Why are you searching for foo.<i>=&gt;<p>Are you searching through every function, or functions that have a very specific parameter?<p>And whatever you picked, why?<p>---------------------------------------------------------------<p>- If you&#x27;re searching for every function, then there&#x27;s no need to search for foo.</i>=&gt;, you only need to search for function and =&gt;.<p>- If you&#x27;re searching for a specific parameter, then just search for the parameter. Searching for functions is redundant.<p>---------------------------------------------------------------<p>Arrow function expressions and function expressions can both be named or anonymous.<p>Introducing arrow functions didn&#x27;t suddenly make JavaScript unsearchable.<p>JavaScript supported anonymous functions before arrow function expressions were introduced.<p>Anonymous functions can only ever be:<p>- run on the spot<p>- thrown away<p>- or passed around after they&#x27;ve been given a label<p>Which means, whenever you actually want to search for something, it&#x27;s going to be labelled.<p>So search for the label.</div><br/></div></div></div></div></div></div></div></div><div id="41432789" class="c"><input type="checkbox" id="c-41432789" checked=""/><div class="controls bullet"><span class="by">sva_</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431222">prev</a><span>|</span><a href="#41431241">next</a><span>|</span><label class="collapse" for="c-41432789">[-]</label><label class="expand" for="c-41432789">[1 more]</label></div><br/><div class="children"><div class="content">People don&#x27;t use LSP?</div><br/></div></div><div id="41431241" class="c"><input type="checkbox" id="c-41431241" checked=""/><div class="controls bullet"><span class="by">eddieh</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432789">prev</a><span>|</span><a href="#41431639">next</a><span>|</span><label class="collapse" for="c-41431241">[-]</label><label class="expand" for="c-41431241">[1 more]</label></div><br/><div class="children"><div class="content">I used to define functions as `funcname (arglist)`<p>And always call the function as `funcname(args)`<p>So definitions have a space between the name and arg parentheses, while calls do not. Seemed to work well, even in languages with extraneous keywords before definitions since space + paren is shorter than most keywords.<p>Now days I don’t bother since it really isn’t that useful especially with tags or LSP.<p>I still put the return type on a line of its own, not for search&#x2F;grep, but because it is cleaner and looks nice to me—overly long lines are the ugliest of coding IMO. Well that and excessive nesting.</div><br/></div></div><div id="41431639" class="c"><input type="checkbox" id="c-41431639" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431241">prev</a><span>|</span><a href="#41431866">next</a><span>|</span><label class="collapse" for="c-41431639">[-]</label><label class="expand" for="c-41431639">[1 more]</label></div><br/><div class="children"><div class="content">Yet you reply to an article that defines functions as variables, which I&#x27;ve seen a lot of developers do usually for no good reason at all.<p>To me, that&#x27;s a much common and worse practice with regards to greppability than splitting identifiers using string which I haven&#x27;t seen much in the wild.</div><br/></div></div><div id="41431866" class="c"><input type="checkbox" id="c-41431866" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431639">prev</a><span>|</span><a href="#41431574">next</a><span>|</span><label class="collapse" for="c-41431866">[-]</label><label class="expand" for="c-41431866">[2 more]</label></div><br/><div class="children"><div class="content">Not sure this is very true for Common Lisp. Classic example are accessor functions where the generic function is created by whichever class is defined first and the method where the class is defined. Other macros will construct new symbols for function names (or take them from the macro arguments).</div><br/><div id="41431897" class="c"><input type="checkbox" id="c-41431897" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41431866">parent</a><span>|</span><a href="#41431574">next</a><span>|</span><label class="collapse" for="c-41431897">[-]</label><label class="expand" for="c-41431897">[1 more]</label></div><br/><div class="children"><div class="content">Still you can extend the concept without a lot of work, couldn&#x27;t you?</div><br/></div></div></div></div><div id="41431574" class="c"><input type="checkbox" id="c-41431574" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431866">prev</a><span>|</span><a href="#41432425">next</a><span>|</span><label class="collapse" for="c-41431574">[-]</label><label class="expand" for="c-41431574">[1 more]</label></div><br/><div class="children"><div class="content">For most functions ^\S.*name( will find declarations and definitions.<p>Most of us use exuberant ctags to allow jumping to definitions.</div><br/></div></div><div id="41432425" class="c"><input type="checkbox" id="c-41432425" checked=""/><div class="controls bullet"><span class="by">akritid</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431574">prev</a><span>|</span><a href="#41432006">next</a><span>|</span><label class="collapse" for="c-41432425">[-]</label><label class="expand" for="c-41432425">[1 more]</label></div><br/><div class="children"><div class="content">Looks fine (subjective) and there is also ctags</div><br/></div></div><div id="41432006" class="c"><input type="checkbox" id="c-41432006" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432425">prev</a><span>|</span><a href="#41431835">next</a><span>|</span><label class="collapse" for="c-41432006">[-]</label><label class="expand" for="c-41432006">[2 more]</label></div><br/><div class="children"><div class="content">Though glob imports in rust can hide a source, so those should be avoided.</div><br/><div id="41432405" class="c"><input type="checkbox" id="c-41432405" checked=""/><div class="controls bullet"><span class="by">mre</span><span>|</span><a href="#41431114">root</a><span>|</span><a href="#41432006">parent</a><span>|</span><a href="#41431835">next</a><span>|</span><label class="collapse" for="c-41432405">[-]</label><label class="expand" for="c-41432405">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. I wrote an entire blog post about that:  <a href="https:&#x2F;&#x2F;corrode.dev&#x2F;blog&#x2F;dont-use-preludes-and-globs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;corrode.dev&#x2F;blog&#x2F;dont-use-preludes-and-globs&#x2F;</a></div><br/></div></div></div></div><div id="41431835" class="c"><input type="checkbox" id="c-41431835" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41432006">prev</a><span>|</span><a href="#41431223">next</a><span>|</span><label class="collapse" for="c-41431835">[-]</label><label class="expand" for="c-41431835">[1 more]</label></div><br/><div class="children"><div class="content">C has &quot;classical&quot; tooling like Cscope and Exuberant Ctags. The stuff works very well, except on the odd weird code that does idiotic things that should not be done with preprocessing.<p>Even for Lisp, you don&#x27;t want to be grepping, or at least not all the time for basic things.<p>For TXR Lisp, I provide a program that will scan code and build (or add to) your tags file (either a Vim or Emacs compatible one).<p>Given<p><pre><code>  (defstruct point ()
    x
    y)
</code></pre>
it will let your editor jump to the definition of point, x and y.</div><br/></div></div><div id="41431223" class="c"><input type="checkbox" id="c-41431223" checked=""/><div class="controls bullet"><span class="by">bionsystem</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431835">prev</a><span>|</span><a href="#41431308">next</a><span>|</span><label class="collapse" for="c-41431223">[-]</label><label class="expand" for="c-41431223">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t cscope fit this usecase ?</div><br/></div></div><div id="41431308" class="c"><input type="checkbox" id="c-41431308" checked=""/><div class="controls bullet"><span class="by">semiinfinitely</span><span>|</span><a href="#41431114">parent</a><span>|</span><a href="#41431223">prev</a><span>|</span><a href="#41431874">next</a><span>|</span><label class="collapse" for="c-41431308">[-]</label><label class="expand" for="c-41431308">[1 more]</label></div><br/><div class="children"><div class="content">python also!</div><br/></div></div></div></div><div id="41431701" class="c"><input type="checkbox" id="c-41431701" checked=""/><div class="controls bullet"><span class="by">lucumo</span><span>|</span><a href="#41431114">prev</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41431701">[-]</label><label class="expand" for="c-41431701">[37 more]</label></div><br/><div class="children"><div class="content">Grepping for symbols like function names and class names feels so anemic compared to using a tool that has a syntactic understanding of the code. Just &quot;go to definition&quot; and &quot;find usages&quot; alone reduce the need for text search enormously.<p>For the past decade-plus I have mostly only searched for user facing strings. Those have the advantage of being longer, so are more easily searched.<p>Honestly, posts like this sound like the author needs to invest some time in learning about better tools for his language. A good IDE  alone will save you so much time.</div><br/><div id="41432569" class="c"><input type="checkbox" id="c-41432569" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431810">next</a><span>|</span><label class="collapse" for="c-41432569">[-]</label><label class="expand" for="c-41432569">[3 more]</label></div><br/><div class="children"><div class="content">Scenarios where an IDE with full syntactic understanding is better:<p>- It&#x27;s your day to day project and you expect to be working in it for a long time.<p>Scenarios where grepping is more useful:<p>- Your language has #ifdef or equivalent syntax which does conditional compilation making syntactic tools incomplete.<p>- You just opened the project for the first time.<p>- It&#x27;s in a language you don&#x27;t daily drive (you write backend but have to delve in frontend code, it&#x27;s a 3rd party library, it&#x27;s configuration files, random json&#x2F;xml files or data)<p>- You&#x27;re editing or searching through documentation.<p>- You haven&#x27;t even downloaded the project and are checking things out in github (or some similar site for your project).<p>- You&#x27;re providing remote assistance to someone and you are not at your main development machine.<p>- You&#x27;re remoting via SSH and have access to code there (say it&#x27;s a python server).<p>Yes, an IDE will save you time daily driving. But there&#x27;s no reason to sabotage all the other usecases.</div><br/><div id="41432760" class="c"><input type="checkbox" id="c-41432760" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41432658">next</a><span>|</span><label class="collapse" for="c-41432760">[-]</label><label class="expand" for="c-41432760">[1 more]</label></div><br/><div class="children"><div class="content">Further important (to me) scenarios that also argue for greppability:<p>- greppability does not preclude IDE or language server tooling; there&#x27;s often special cases where only certain e.g. context-dependant usages matter, and sometimes grep is the easiest way to find those.
 - projects that include multiple languages, such as for instance the fairly common setup of HTML, JS, CSS, SQL, and some server-side language.
 - performance in scenarios with huge amounts of code, or where you&#x27;re searching very often (e.g. in each git commit for some amount of history)
 - ease of use across repositories (e.g. a client app, a spec, and a server app in separate repos).<p>I treat greppability as an almost universal default.  I&#x27;d much rather have code in a &quot;weird&quot; naming style in some language but have consistent identifiers across languages, than have normal-style-guide default identifiers in each language, but differing identifiers across languages. If code &quot;looks weird&quot;, if anything that&#x27;s often actually a _benefit_ in such cases, not a downside - most serialization libraries I use for this kind of stuff tend to do a lot of automagic mapping that can break in ways that are sometimes hard to detect at compile time if somebody renames something, or sometimes even just for a casing change or type change. Having a hint as to this fragility immediate at a glance even in dynamically typed languages is sometimes a nice side-effect. Very speculatively, I wouldn&#x27;t be surpised if AI coding tools can deal with consistent names better than context-dependent ones too; greppability is likely not specifically about merely the tool grep.<p>And the best part is that there&#x27;s almost no downside; it&#x27;s not like you need to pick either a language server, IDE or grep - just use whatever is most convenient for each task.</div><br/></div></div><div id="41432658" class="c"><input type="checkbox" id="c-41432658" checked=""/><div class="controls bullet"><span class="by">popinman322</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432569">parent</a><span>|</span><a href="#41432760">prev</a><span>|</span><a href="#41431810">next</a><span>|</span><label class="collapse" for="c-41432658">[-]</label><label class="expand" for="c-41432658">[1 more]</label></div><br/><div class="children"><div class="content">Grep is also useful when IDE indexing isn&#x27;t feasible for the entire project. At past employers I worked in monorepos where the sheer size of the index caused multiple seconds of delay in intellisense and UI stuttering; our devex team&#x27;s preferred approach was to better integrate our IDE experience with the build system such that only symbols in scope of the module you were working on would be loaded. This was usually fine, and it works especially well for product teams, but it&#x27;s a headache when you&#x27;re doing cross-cutting work (e.g. for infrastructure projects&#x2F;overhauls).<p>We also had a livegrep instance that we could use to grep any corporate repo, regardless of where it was hosted. That was extremely useful for investigating failures in build scripts that spanned multiple repositories (e.g. building a Go sidecar that relies on a service config in the Java monorepo).</div><br/></div></div></div></div><div id="41431810" class="c"><input type="checkbox" id="c-41431810" checked=""/><div class="controls bullet"><span class="by">heisenbit</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432569">prev</a><span>|</span><a href="#41431750">next</a><span>|</span><label class="collapse" for="c-41431810">[-]</label><label class="expand" for="c-41431810">[3 more]</label></div><br/><div class="children"><div class="content">A good IDE can be so much better iff it understands the code. However this requires the IDE to be able to understand the project structure, dependencies etc. which can be considerable effort. In a codebase with many projects employing several different languages it becomes hard to get and maintain the IDE understands everything state.</div><br/><div id="41432414" class="c"><input type="checkbox" id="c-41432414" checked=""/><div class="controls bullet"><span class="by">amichal</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431810">parent</a><span>|</span><a href="#41432465">next</a><span>|</span><label class="collapse" for="c-41432414">[-]</label><label class="expand" for="c-41432414">[1 more]</label></div><br/><div class="children"><div class="content">And an IDE would also fail to find references for most of the cases described in the article: name composition&#x2F;manipulation, naming consistency across language barriers, and flat namespaces in serialization. And file&#x2F;path folder naming seems to be irrelevant to the smart IDE argument. &quot;Naming things is hard&quot;</div><br/></div></div><div id="41432465" class="c"><input type="checkbox" id="c-41432465" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431810">parent</a><span>|</span><a href="#41432414">prev</a><span>|</span><a href="#41431750">next</a><span>|</span><label class="collapse" for="c-41432465">[-]</label><label class="expand" for="c-41432465">[1 more]</label></div><br/><div class="children"><div class="content">And especially in large monorepos anything that understands the code can become quite sluggish. While ripgrep remains fast.<p>A kind of in-between I&#x27;ve found for some search and replace action is comby (<a href="https:&#x2F;&#x2F;comby.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;comby.dev&#x2F;</a>). Having a matching braces feature is a godsend for doing some kind of replacements properly.</div><br/></div></div></div></div><div id="41431750" class="c"><input type="checkbox" id="c-41431750" checked=""/><div class="controls bullet"><span class="by">brain5ide</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431810">prev</a><span>|</span><a href="#41431793">next</a><span>|</span><label class="collapse" for="c-41431750">[-]</label><label class="expand" for="c-41431750">[2 more]</label></div><br/><div class="children"><div class="content">I think the first sentence of the author counters your comment.
What you described works best in a familiar codebase where the organizing principles have been maintained well and are familiar to the reader and the tools are just the extension of those organizing principles. Even then a deviation from those rules might produce gaps in understanding of what the codebase does.<p>And grep cuts right through that in a pretty universal way. What the post describes are just ways to not work against grep to optimize for something ephemeral.</div><br/><div id="41431820" class="c"><input type="checkbox" id="c-41431820" checked=""/><div class="controls bullet"><span class="by">ricardo81</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431750">parent</a><span>|</span><a href="#41431793">next</a><span>|</span><label class="collapse" for="c-41431820">[-]</label><label class="expand" for="c-41431820">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Not just because it&#x27;s unfamiliar code, you can also get a feel for how the program&#x2F;programmer(s) structured the whole thing.</div><br/></div></div></div></div><div id="41431793" class="c"><input type="checkbox" id="c-41431793" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431750">prev</a><span>|</span><a href="#41432401">next</a><span>|</span><label class="collapse" for="c-41431793">[-]</label><label class="expand" for="c-41431793">[10 more]</label></div><br/><div class="children"><div class="content">Go to definition and find usages only work one symbol at a time. I use both, but I still use global find&#x2F;replace for groups of symbols sharing the same concept.<p>For example if I want to rename all “Dog” (DogModel, DogView, DogController) symbols to “Wolf”, find&#x2F;replace is much better at that because it will tell me about symbols I had forgotten about.</div><br/><div id="41432605" class="c"><input type="checkbox" id="c-41432605" checked=""/><div class="controls bullet"><span class="by">sandermvanvliet</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41431822">next</a><span>|</span><label class="collapse" for="c-41432605">[-]</label><label class="expand" for="c-41432605">[1 more]</label></div><br/><div class="children"><div class="content">Jetbrains ReSharper (and Rider) is smart enough to handle these things. It’ll suggest renames across other symbols even ones that have related names</div><br/></div></div><div id="41431822" class="c"><input type="checkbox" id="c-41431822" checked=""/><div class="controls bullet"><span class="by">gugagore</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41432605">prev</a><span>|</span><a href="#41431884">next</a><span>|</span><label class="collapse" for="c-41431822">[-]</label><label class="expand" for="c-41431822">[3 more]</label></div><br/><div class="children"><div class="content">I am familiar with the situation you describe, and it&#x27;s a good point.<p>However, it does suggest that there is an opportunity for factoring &quot;Dog&quot; out in the code, at least by name spacing (e.g. Dog.Model).</div><br/><div id="41432509" class="c"><input type="checkbox" id="c-41432509" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431822">parent</a><span>|</span><a href="#41431877">next</a><span>|</span><label class="collapse" for="c-41432509">[-]</label><label class="expand" for="c-41432509">[1 more]</label></div><br/><div class="children"><div class="content">That gets to the core of the issue doesn’t it? There are two cultures: Do you prefer to refactor DogView into Dog.View, or do you prefer to refactor Dog.View into DogView.<p>Personally I value uniqueness&#x2F;canonicalness over conciseness. I would rather have DogView because then there is one name for the symbol regardless of where I am in the codebase. If the same symbol is used with differently qualified names it is confusing - I want the least qualified name to be more descriptive than “View”.<p>The other culture is to lean heavily on namespaces and to not worry about uniqueness. In this case you have View and Dog.View that may be used interchangeably in different files. This is the dominant culture in Java and C#.</div><br/></div></div><div id="41431877" class="c"><input type="checkbox" id="c-41431877" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431822">parent</a><span>|</span><a href="#41432509">prev</a><span>|</span><a href="#41431884">next</a><span>|</span><label class="collapse" for="c-41431877">[-]</label><label class="expand" for="c-41431877">[1 more]</label></div><br/><div class="children"><div class="content">That really depends on the context, and specific situation.</div><br/></div></div></div></div><div id="41431884" class="c"><input type="checkbox" id="c-41431884" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41431822">prev</a><span>|</span><a href="#41431930">next</a><span>|</span><label class="collapse" for="c-41431884">[-]</label><label class="expand" for="c-41431884">[1 more]</label></div><br/><div class="children"><div class="content">For that use case I think you can use treesitter[1] you can find Dog.* but only if it is a variable name, for example. Avoiding replacement inside of say literals.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MZPR_SC9LzE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MZPR_SC9LzE</a></div><br/></div></div><div id="41431930" class="c"><input type="checkbox" id="c-41431930" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431793">parent</a><span>|</span><a href="#41431884">prev</a><span>|</span><a href="#41432401">next</a><span>|</span><label class="collapse" for="c-41431930">[-]</label><label class="expand" for="c-41431930">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason they <i>have</i> to work one symbol at a time - that&#x27;s just a missing feature in your language server implementation.<p>Some language servers support modifying the symbols in contexts like docstrings as well.</div><br/><div id="41432000" class="c"><input type="checkbox" id="c-41432000" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431930">parent</a><span>|</span><a href="#41432401">next</a><span>|</span><label class="collapse" for="c-41432000">[-]</label><label class="expand" for="c-41432000">[3 more]</label></div><br/><div class="children"><div class="content">I’ve never seen an LSP server that lets you rename “Dog” to “Wolf” where your actual class names are “Dog[A-Za-z]*”?<p>Do you have an example?</div><br/><div id="41432785" class="c"><input type="checkbox" id="c-41432785" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432000">parent</a><span>|</span><a href="#41432121">next</a><span>|</span><label class="collapse" for="c-41432785">[-]</label><label class="expand" for="c-41432785">[1 more]</label></div><br/><div class="children"><div class="content">Neither have I; and no, I don&#x27;t - I misinterpreted what you said.<p>But I don&#x27;t see why LSP servers shouldn&#x27;t support this, still. I&#x27;m not sure if the LSP specification allows for this as of current, though.</div><br/></div></div><div id="41432121" class="c"><input type="checkbox" id="c-41432121" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41432000">parent</a><span>|</span><a href="#41432785">prev</a><span>|</span><a href="#41432401">next</a><span>|</span><label class="collapse" for="c-41432121">[-]</label><label class="expand" for="c-41432121">[1 more]</label></div><br/><div class="children"><div class="content">IntelliJ&#x27;s refactor tool?</div><br/></div></div></div></div></div></div></div></div><div id="41432401" class="c"><input type="checkbox" id="c-41432401" checked=""/><div class="controls bullet"><span class="by">citrin_ru</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431793">prev</a><span>|</span><a href="#41431885">next</a><span>|</span><label class="collapse" for="c-41432401">[-]</label><label class="expand" for="c-41432401">[1 more]</label></div><br/><div class="children"><div class="content">Not everything you need to look for is a language identifier. I often grep for configuration option names in the code to see what the option actually does - sometimes it is easy to grep, sometimes there are too many matches, sometimes they cannot be found because option name composed in the code from separate unrepeatable (because of too many matches) parts. It&#x27;s not hard to make config options greppable but some coders just don&#x27;t care about this property.</div><br/></div></div><div id="41431885" class="c"><input type="checkbox" id="c-41431885" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432401">prev</a><span>|</span><a href="#41432124">next</a><span>|</span><label class="collapse" for="c-41431885">[-]</label><label class="expand" for="c-41431885">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately in larger codebases or dynamic languages these tools are just not good enough today. At least not those I and my employers have tried.<p>They&#x27;re either incomplete (you don&#x27;t get ALL references or you get false references) or way too slow (&gt;10 seconds when rg takes 1-2).<p>Recommendations are most welcome.</div><br/><div id="41431900" class="c"><input type="checkbox" id="c-41431900" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431885">parent</a><span>|</span><a href="#41432124">next</a><span>|</span><label class="collapse" for="c-41431900">[-]</label><label class="expand" for="c-41431900">[1 more]</label></div><br/><div class="children"><div class="content">Only thing I can recommend is using C# (obviously not always possible). Never had an issue with these functions in Visual Studio proper no matter how big the project.</div><br/></div></div></div></div><div id="41432124" class="c"><input type="checkbox" id="c-41432124" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431885">prev</a><span>|</span><a href="#41432767">next</a><span>|</span><label class="collapse" for="c-41432124">[-]</label><label class="expand" for="c-41432124">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve come to really like language servers for big personal and work projects where I already have my tools configured and tuned for efficiently working with it.<p>But being able to grep is really nice when trying to figure out something out about a source tree that I don&#x27;t yet have set up to compile, nor am I a developer of.  I.e., I&#x27;ve downloaded the source for a tool I&#x27;ve been using pre-built binaries of and am now trying to trace why I might be getting a particular error.</div><br/></div></div><div id="41432767" class="c"><input type="checkbox" id="c-41432767" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432124">prev</a><span>|</span><a href="#41432267">next</a><span>|</span><label class="collapse" for="c-41432767">[-]</label><label class="expand" for="c-41432767">[1 more]</label></div><br/><div class="children"><div class="content">IDEs are cool and all, but there is no way I&#x27;m gonna let VSCode index my 80GB yocto tmp directory. Ctags can crunch the whole thing in a few minutes, and so can grep.<p>Plus there are cases where grep is really what you need, for example after updating a particular command line tool whose output changed, I was able to find all scripts which grepped the output of the tool in a way that was broken.</div><br/></div></div><div id="41432267" class="c"><input type="checkbox" id="c-41432267" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432767">prev</a><span>|</span><a href="#41432417">next</a><span>|</span><label class="collapse" for="c-41432267">[-]</label><label class="expand" for="c-41432267">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t use an IDE on my entire git history, but git can grep.</div><br/></div></div><div id="41432417" class="c"><input type="checkbox" id="c-41432417" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432267">prev</a><span>|</span><a href="#41431978">next</a><span>|</span><label class="collapse" for="c-41432417">[-]</label><label class="expand" for="c-41432417">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, in my 18 years of software development, I haven&#x27;t &quot;greped&quot; code once.<p>I only use grep to filter the output of CLI tools.<p>For code, I use my IDE or repository features.</div><br/></div></div><div id="41431978" class="c"><input type="checkbox" id="c-41431978" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41432417">prev</a><span>|</span><a href="#41431970">next</a><span>|</span><label class="collapse" for="c-41431978">[-]</label><label class="expand" for="c-41431978">[1 more]</label></div><br/><div class="children"><div class="content">Definitely true when you can use static typing.<p>Unfortunately sometimes you can&#x27;t, and sometimes you can but people can&#x27;t be arsed, so this is still a consideration.</div><br/></div></div><div id="41431970" class="c"><input type="checkbox" id="c-41431970" checked=""/><div class="controls bullet"><span class="by">aa-jv</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431978">prev</a><span>|</span><a href="#41431726">next</a><span>|</span><label class="collapse" for="c-41431970">[-]</label><label class="expand" for="c-41431970">[3 more]</label></div><br/><div class="children"><div class="content">On the flipside, IDE&#x27;s can turn you into lazy, inefficient programmers by doing all the hand-holding for you.<p>If your feelings are anemic when tasked with doing a grep, its because you have lost a very valuable skill by delegating it to a computer.  There are some things the IDE is never going to be able to find - lest it becomes the development environment - so keeping your grep fu sharpened is wise beyond the decades.<p>(Disclaimer: 40 years of software development, and vim+cscope+grep&#x2F;silversearcher are all I really need, next to my compiler..)</div><br/><div id="41432644" class="c"><input type="checkbox" id="c-41432644" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431970">parent</a><span>|</span><a href="#41432177">next</a><span>|</span><label class="collapse" for="c-41432644">[-]</label><label class="expand" for="c-41432644">[1 more]</label></div><br/><div class="children"><div class="content">I count the IDE and stuff like LSP as natural extensions of the compiler. For sure I grep (or equivalent) for stuff, but I highly prefer statically typed languages&#x2F;ecosystems.<p>At the end of the day, I&#x27;m here to solve problems, and there&#x27;s no end to them -- might as well get a head start.</div><br/></div></div><div id="41432177" class="c"><input type="checkbox" id="c-41432177" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431970">parent</a><span>|</span><a href="#41432644">prev</a><span>|</span><a href="#41431726">next</a><span>|</span><label class="collapse" for="c-41432177">[-]</label><label class="expand" for="c-41432177">[1 more]</label></div><br/><div class="children"><div class="content">Huh? I have an old hand-powered drill from my Grandpa in my workshop. I used it once for fun. For all other tasks I use a powered drill.
Same for IDEs.
They help your refactor and reason about code - both properties I value.
Sure, I could print it and use a textmarker, but I&#x27;m not Grandpa</div><br/></div></div></div></div><div id="41431727" class="c"><input type="checkbox" id="c-41431727" checked=""/><div class="controls bullet"><span class="by">jakub_g</span><span>|</span><a href="#41431701">parent</a><span>|</span><a href="#41431726">prev</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41431727">[-]</label><label class="expand" for="c-41431727">[6 more]</label></div><br/><div class="children"><div class="content">Your observation does not help with the majority of the points in the article. How do you find all usages of a <i>parameter value literal</i>?</div><br/><div id="41431770" class="c"><input type="checkbox" id="c-41431770" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431727">parent</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41431770">[-]</label><label class="expand" for="c-41431770">[5 more]</label></div><br/><div class="children"><div class="content">This is what the article starts with: &quot;Even in projects exclusively written by myself, I have to search a lot: function names, error messages, class names, that kind of thing.&quot;<p>All of that is trivial to search for with a tool that understands the language.</div><br/><div id="41431838" class="c"><input type="checkbox" id="c-41431838" checked=""/><div class="controls bullet"><span class="by">nosianu</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431770">parent</a><span>|</span><a href="#41431814">next</a><span>|</span><label class="collapse" for="c-41431838">[-]</label><label class="expand" for="c-41431838">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>All of that is trivial to search for with a tool that understands the language.</i><p>Isn&#x27;t string search, or grepping for patterns, even more trivial? So what is your argument? You found an alternative method, good, but how is it any better?<p>In my own case, I wrote a library that we used in many projects, and I often wanted to know where and how functions from my lib were used in those projects. For example, to be able to tell how much of an effort it would be for the users to refactor when I changed something. However, your method of choice at least with my IDE (Webstorm) only worked locally within the project. Only string search would let me reliably and easily search all projects.<p>I actually experimented creating a &quot;meta&quot; project of all projects, but while it worked that lead to too many problems, and the main method to find anything still was string search (CTRL-SHIFT-F Find dialog in IDEA IDEs is string search and it&#x27;s a wonderful dialog in that IDE family). I also had to open that meta project. Instead, I created a gitignored folder with symlinks to the sources of all the other projects and created a search scope for that folder, in which the search dialog let me string-search all projects&#x27; sources at once right from within the library project and still being able to use the excellent Find dialog.<p>In addition, I found that sometimes the IDE would not find a usage even within the project. I only noticed because I used both methods, and string search showed me one or two places more than the method that relied on the underlying code-parsing. Unfortunately IDEs have bugs, and the method you suggests relies on much more work of the IDE in parsing and indexing compared to the much more mundane string or string pattern search.</div><br/><div id="41432080" class="c"><input type="checkbox" id="c-41432080" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431838">parent</a><span>|</span><a href="#41431814">next</a><span>|</span><label class="collapse" for="c-41432080">[-]</label><label class="expand" for="c-41432080">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Isn&#x27;t string search, or grepping for patterns, even more trivial?<p>It&#x27;s not trivial when you looking for <i>symbols</i> in <i>context</i>.<p>&gt; the method you suggests relies on much more work of the IDE in parsing and indexing compared to<p>...compared to parsing and indexing you have to do manually because a full-text search (especially in a large codebase) will return a lot of irrelevant info?<p>Funnily enough I also have a personal anecdote. We had a huge PHP code base based on Symfony. We were in the middle of a huge refactoring spree. I saw my colleagues switch from vim&#x2F;emacs to Idea&#x2F;WebStorm looking at how I easily found symbols in the code base, found their usages, refactored them etc. compared to the full-text search they were always stuck with.<p>This was 5-6 years ago, before LSP became ubiquitous.</div><br/></div></div></div></div><div id="41431814" class="c"><input type="checkbox" id="c-41431814" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431770">parent</a><span>|</span><a href="#41431838">prev</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41431814">[-]</label><label class="expand" for="c-41431814">[2 more]</label></div><br/><div class="children"><div class="content">I actually don&#x27;t think there&#x27;s a tool that handles usages when using PHP varvars or when using example number one there which is parametrically choosing a table name.<p>When you string interpolate to build the name you lose searchability.</div><br/><div id="41432087" class="c"><input type="checkbox" id="c-41432087" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41431701">root</a><span>|</span><a href="#41431814">parent</a><span>|</span><a href="#41431090">next</a><span>|</span><label class="collapse" for="c-41432087">[-]</label><label class="expand" for="c-41432087">[1 more]</label></div><br/><div class="children"><div class="content">Yes, full-text search is a great fallback when everything else fails. But in the use cases listed at the beginning of the article it&#x27;s usually not needed if you have proper tools</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41431090" class="c"><input type="checkbox" id="c-41431090" checked=""/><div class="controls bullet"><span class="by">adpirz</span><span>|</span><a href="#41431701">prev</a><span>|</span><a href="#41431049">next</a><span>|</span><label class="collapse" for="c-41431090">[-]</label><label class="expand" for="c-41431090">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen some pretty wild conditional string interpolation where there were like 3-4 separate phrases that each had a number of different options, something akin to `${a ? &#x27;You&#x27; : &#x27;we&#x27;} {b ? &#x27;did&#x27; : &#x27;will do&#x27; } {c ? &#x27;thing&#x27; : &#x27;things&#x27; }`.<p>When I was first onboarding to this project, I was tasked with updating a component and simply tried to find three of the words I saw in the UI, and this was before we implemented a straightforward path-based routing system. It took me far too long just to find what I was going to be working on, and that&#x27;s the day I distinctly remember learning this lesson. I was pretty junior, but I&#x27;d later return to this code and threw it all away for a number of easily greppable strings.</div><br/><div id="41431387" class="c"><input type="checkbox" id="c-41431387" checked=""/><div class="controls bullet"><span class="by">ctxc</span><span>|</span><a href="#41431090">parent</a><span>|</span><a href="#41431049">next</a><span>|</span><label class="collapse" for="c-41431387">[-]</label><label class="expand" for="c-41431387">[2 more]</label></div><br/><div class="children"><div class="content">Tangential: I love it when UIs say &quot;1 object&quot; and &quot;2 objects&quot;. Shows attention to detail.<p>As opposed to &quot;1 objects&quot; or &quot;1 object(s)&quot;. 
A UI filled with &quot;(s)&quot;, ughh</div><br/><div id="41431667" class="c"><input type="checkbox" id="c-41431667" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#41431090">root</a><span>|</span><a href="#41431387">parent</a><span>|</span><a href="#41431049">next</a><span>|</span><label class="collapse" for="c-41431667">[-]</label><label class="expand" for="c-41431667">[1 more]</label></div><br/><div class="children"><div class="content">Moreso when it&#x27;s not tripped up by &quot;1 sheeps&quot; or &quot;1 diagnoses&quot;.</div><br/></div></div></div></div></div></div><div id="41431049" class="c"><input type="checkbox" id="c-41431049" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41431090">prev</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41431049">[-]</label><label class="expand" for="c-41431049">[11 more]</label></div><br/><div class="children"><div class="content">This is the reason many coding styles and tools (including the Linux kernel coding style and the default Rust style as implemented in rustfmt) do not break string constants across lines even if they&#x27;re longer than the desired line length: you might see the string in the program&#x27;s output, and want to search for the same string in the code to find where it gets shown.</div><br/><div id="41431124" class="c"><input type="checkbox" id="c-41431124" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#41431049">parent</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41431124">[-]</label><label class="expand" for="c-41431124">[10 more]</label></div><br/><div class="children"><div class="content">My team drives me bonkers with this.  They hear the general principle &quot;really long lines of code are bad&quot;, but extrapolate it to &quot;no characters shall pass the soft gutter no matter what&quot;.<p>Even if you have, say, 5 sequential related structs, that are all virtually identical, all written on one line so that the similarities and differences are obvious at a mere glance...  Then someone comes through and touches my file, and while they&#x27;re at it, &quot;fix&quot; the line that went 2 characters past the 80 mark by reformatting the 4th struct to span several lines.   Now when you see that list of structs, you wonder &quot;why is this one different?&quot;  and you have to read carefully to determine, nope, it just contained one longer string.  Or god forbid the reformat all the structs to match, turning a 1-page file into 3 pages, and making it so you have to read and understand each element of each struct just to see what&#x27;s going on.<p>If I could have written the rule of thumb, I would have said &quot;No logic or control shall happen after the end of the gutter.&quot;  But if there&#x27;s a paragraph-long string on one line-  who cares??  We all have a single keystroke that can toggle soft-wrap, and the odds that you&#x27;re going to need to know anything about that string other than &quot;it&#x27;s a long string&quot; are virtually nil.<p>Sorry.   I got triggered.  :-)</div><br/><div id="41431210" class="c"><input type="checkbox" id="c-41431210" checked=""/><div class="controls bullet"><span class="by">BigJono</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431166">next</a><span>|</span><label class="collapse" for="c-41431210">[-]</label><label class="expand" for="c-41431210">[2 more]</label></div><br/><div class="children"><div class="content">Yep this triggers the fuck out of me too. It drives me absolutely insane when I&#x27;m taking the time and effort to write good test cases that use inline per test data that I&#x27;ve taken the time to format so it&#x27;s nice and readable for the next person, then the next person comes along, spends 30 seconds writing some 2 line rubbish to hit a code coverage metric, then spends another 60 seconds adding a linter rule that blows all the test data out to 400 lines of unreadable dogshit that uses only the left 15% of screen real estate.</div><br/><div id="41432765" class="c"><input type="checkbox" id="c-41432765" checked=""/><div class="controls bullet"><span class="by">port19</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431210">parent</a><span>|</span><a href="#41431166">next</a><span>|</span><label class="collapse" for="c-41432765">[-]</label><label class="expand" for="c-41432765">[1 more]</label></div><br/><div class="children"><div class="content">I routinely spot 3-line prints with the string on its own line in our code. Even for cases where the string + print don&#x27;t even reach the 80 character &quot;limit&quot;</div><br/></div></div></div></div><div id="41431166" class="c"><input type="checkbox" id="c-41431166" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431210">prev</a><span>|</span><a href="#41431333">next</a><span>|</span><label class="collapse" for="c-41431166">[-]</label><label class="expand" for="c-41431166">[1 more]</label></div><br/><div class="children"><div class="content">My team also had a similar thing in place.  I am saving this article in my pocket saves, so that I can give &quot;proofs&quot; of why this is better<p>From Zen of Python:  
```
Special cases aren&#x27;t special enough to break the rules.
Although practicality beats purity.
```
<a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0020&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0020&#x2F;</a></div><br/></div></div><div id="41431333" class="c"><input type="checkbox" id="c-41431333" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431166">prev</a><span>|</span><a href="#41432161">next</a><span>|</span><label class="collapse" for="c-41431333">[-]</label><label class="expand" for="c-41431333">[3 more]</label></div><br/><div class="children"><div class="content">This is why autoformatters that frob with line endings are just terrible and fundamentally broken.<p>I&#x27;m fairly firmly in the &quot;wrap at 80&quot; camp by the way; but sometimes a tad longer just makes sense. Or shorter for that matter: forced removal of line breaks is just as bad.</div><br/><div id="41431943" class="c"><input type="checkbox" id="c-41431943" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431333">parent</a><span>|</span><a href="#41432161">next</a><span>|</span><label class="collapse" for="c-41431943">[-]</label><label class="expand" for="c-41431943">[2 more]</label></div><br/><div class="children"><div class="content">80 feels really impractically narrow. A project I work on uses 110 because it&#x27;s approximately the widest you can comfortably compare two revisions on the same monitor, or was for some person at some time, and I can live with it, but any less would just feel so cramped. A few indentation levels deep and I&#x27;d be writing newspaper columns.</div><br/><div id="41432380" class="c"><input type="checkbox" id="c-41432380" checked=""/><div class="controls bullet"><span class="by">NotMichaelBay</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431943">parent</a><span>|</span><a href="#41432161">next</a><span>|</span><label class="collapse" for="c-41432380">[-]</label><label class="expand" for="c-41432380">[1 more]</label></div><br/><div class="children"><div class="content">There is usually a way to restructure the code so that it doesn&#x27;t have multiple levels of nested indentation, which is a good practice IMO because it makes the code easier to read.</div><br/></div></div></div></div></div></div><div id="41432161" class="c"><input type="checkbox" id="c-41432161" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41431124">parent</a><span>|</span><a href="#41431333">prev</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41432161">[-]</label><label class="expand" for="c-41432161">[3 more]</label></div><br/><div class="children"><div class="content">This is world autoformatters have wrought. The central dogma of the autoformatter is that &quot;formatting&quot; is based on dumb syntactic rules with no inflow of imprecise human judgements.</div><br/><div id="41432239" class="c"><input type="checkbox" id="c-41432239" checked=""/><div class="controls bullet"><span class="by">scrollaway</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41432161">parent</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41432239">[-]</label><label class="expand" for="c-41432239">[2 more]</label></div><br/><div class="children"><div class="content">Most autoformatters do not reformat string constants as GP has said, and even if they did, this is something that can be much more accurately and correctly specified with an AF than with a human.<p>Autoformatting collectively saves probably close to millions of work hours per year in our industry, and that’s at the current adoption. Do you think it’s productive to manually space things out, clean up missing trailing commas and what not? Machines do it better.</div><br/><div id="41432309" class="c"><input type="checkbox" id="c-41432309" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#41431049">root</a><span>|</span><a href="#41432239">parent</a><span>|</span><a href="#41431107">next</a><span>|</span><label class="collapse" for="c-41432309">[-]</label><label class="expand" for="c-41432309">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Even if you have, say, 5 sequential related structs, that are all virtually identical, all written on one line so that the similarities and differences are obvious at a mere glance... Then someone comes through and touches my file, and while they&#x27;re at it, &quot;fix&quot; the line that went 2 characters past the 80 mark by reformatting the 4th struct to span several lines.<p>Autoformatters absolutely do this. They do not understand considerations like symmetry.<p>I am doubtful as to the costs of &quot;somewhere in the codebase there is a missing trailing comma&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41431107" class="c"><input type="checkbox" id="c-41431107" checked=""/><div class="controls bullet"><span class="by">dblotsky</span><span>|</span><a href="#41431049">prev</a><span>|</span><a href="#41431249">next</a><span>|</span><label class="collapse" for="c-41431107">[-]</label><label class="expand" for="c-41431107">[5 more]</label></div><br/><div class="children"><div class="content">Hard agree with the idea of greppability, but hard disagree about keeping names the same across boundaries.<p>I think the benefit of having one symbol exist in only one domain (e.g. “user_request” only showing up in the database-handling code, where it’s used 3 times, and not in the UI code, where it might’ve been used 30 times) reduces more cognitive load than is added by searching for 2 symbols instead of 1 common one.</div><br/><div id="41432584" class="c"><input type="checkbox" id="c-41432584" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41431369">next</a><span>|</span><label class="collapse" for="c-41432584">[-]</label><label class="expand" for="c-41432584">[1 more]</label></div><br/><div class="children"><div class="content">Probably depends on how your system is structured. if you know you only want to look in the DB code, hopefully it is either all together or there is something about the folder naming pattern you can take advantage of when saying where to search to limit it.<p>The upside to doing it this way is it makes your grepping more flexible by allowing you to either only search the one part of the codebase to see say DB code or see all the DB and UI things using the concept.</div><br/></div></div><div id="41431369" class="c"><input type="checkbox" id="c-41431369" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41432584">prev</a><span>|</span><a href="#41431347">next</a><span>|</span><label class="collapse" for="c-41431369">[-]</label><label class="expand" for="c-41431369">[1 more]</label></div><br/><div class="children"><div class="content">I’ve also found that I sometimes really like when I grep for a symbol and hit some mapping code. Just knowing that some value goes through a specific mapping layer and then is never mentioned again until the spot where it’s read often answers the question I had by itself, while without the mapping code there’d just be no occurrences of the symbol in the current code base and I’d have no clue which external source it’s coming from.</div><br/></div></div><div id="41431347" class="c"><input type="checkbox" id="c-41431347" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#41431107">parent</a><span>|</span><a href="#41431369">prev</a><span>|</span><a href="#41431249">next</a><span>|</span><label class="collapse" for="c-41431347">[-]</label><label class="expand" for="c-41431347">[2 more]</label></div><br/><div class="children"><div class="content">Not to mention the readability hit from identifiers like foo.user_request in JavaScript, which triggers both linters and my own sense of language convention.</div><br/><div id="41432820" class="c"><input type="checkbox" id="c-41432820" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41431107">root</a><span>|</span><a href="#41431347">parent</a><span>|</span><a href="#41431249">next</a><span>|</span><label class="collapse" for="c-41432820">[-]</label><label class="expand" for="c-41432820">[1 more]</label></div><br/><div class="children"><div class="content">Both of those are easy to fix.  You&#x27;ll adapt quickly if you pick a different convention.<p>Additionally, I find that in practice such &quot;unusual&quot; code is actually beneficial - it often makes it easy to see at a glance that the code is somehow in sync with some external spec.  Especially when it comes to implicit usages such as in (de)serialization, noticing that quickly is quite valuable.<p>I&#x27;d much rather trash <i>every</i> languages&#x27; coding conventions than use subtly different names for objects serialized and shared across languages.  It&#x27;s just a pain.</div><br/></div></div></div></div></div></div><div id="41431249" class="c"><input type="checkbox" id="c-41431249" checked=""/><div class="controls bullet"><span class="by">amingilani</span><span>|</span><a href="#41431107">prev</a><span>|</span><a href="#41432506">next</a><span>|</span><label class="collapse" for="c-41431249">[-]</label><label class="expand" for="c-41431249">[6 more]</label></div><br/><div class="children"><div class="content">I agree that code searchability is a good thing but I disagree with those examples. They intentionally increase the chance of errors.<p>Maybe there’s an alternative way to achieve what the author set out but increasing searchability at the cost of increasing brittleness isn’t it for me.<p>In this example:<p>const getTableName = (addressType: &#x27;shipping&#x27; | &#x27;billing&#x27;) =&gt; {
    return `${addressType}_addresses`
}<p>The input string and output are coupled. If you add string conditionals as the author did, you introduce the chance of a mismatch between the input and output.<p>const getTableName = (addressType: &#x27;shipping&#x27; | &#x27;billing&#x27;) =&gt; {
    if (addressType === &#x27;shipping&#x27;) {
        return &#x27;shipping_addresses&#x27;
    }
    if (addressType === &#x27;billing&#x27;) {
        return &#x27;billing_addresses&#x27;
    }
    throw new TypeError(&#x27;addressType must be billing or shipping&#x27;)
}<p>Similarly, flattening dictionaries for readability introduces the chance of a random typo making our lives hell. A single typo in the repetitions below will be awful.<p>{
    &quot;auth.login.title&quot;: &quot;Login&quot;,
    &quot;auth.login.emailLabel&quot;: &quot;Email&quot;,
    &quot;auth.login.passwordLabel&quot;: &quot;Password&quot;,
    &quot;auth.register.title&quot;: &quot;Login&quot;,
    &quot;auth.register.emailLabel&quot;: &quot;Email&quot;,
    &quot;auth.register.passwordLabel&quot;: &quot;Password&quot;,
}<p>Typos aren’t unlikely. In a codebase I work with, we have a perpetually open ticket about how  ARTISTS is mistyped as ATRISTS in a similarly flat enum.<p>The issue can’t be solved easily because the enum is now copied across several codebases. But the ticket has a counter for the number of developers that independently discovered the bug and it’s in the mid two digits.</div><br/><div id="41431315" class="c"><input type="checkbox" id="c-41431315" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41432337">next</a><span>|</span><label class="collapse" for="c-41431315">[-]</label><label class="expand" for="c-41431315">[1 more]</label></div><br/><div class="children"><div class="content">Typos are find-and-fix-once, while unsearchability is a maintenance burden forever.<p>I don&#x27;t think coupling variable names by making sure they contain the same strings is the best way to show they&#x27;re related, compared to an actual map from address type to table name. There might be a lot of things called &#x27;shipping&#x27; in my app, only some of which are coupled to `shipping_addresses`.<p>Shouldn&#x27;t a linter be able to catch that there is no enum member called MyEnum.ATRISTS, or is it not an actual enum?</div><br/></div></div><div id="41432337" class="c"><input type="checkbox" id="c-41432337" checked=""/><div class="controls bullet"><span class="by">peeters</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41431315">prev</a><span>|</span><a href="#41431364">next</a><span>|</span><label class="collapse" for="c-41432337">[-]</label><label class="expand" for="c-41432337">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The input string and output are coupled. If you add string conditionals as the author did, you introduce the chance of a mismatch between the input and output.<p>I think it depends on whether the repetition is accidental or intrinsic. Does the table name <i>happen</i> to contain the address type as a prefix, or does it intrinsically have to? Greppability aside, when things are incidentally related, it&#x27;s often better to repeat yourself to not give the wrong impression that they&#x27;re intrinsically related. Conversely, if they <i>are</i> intrinsically related (i.e. it&#x27;s an invariant of the system that the table name starts with the address type as a prefix) then it&#x27;s better for the code to align with that.</div><br/></div></div><div id="41431364" class="c"><input type="checkbox" id="c-41431364" checked=""/><div class="controls bullet"><span class="by">ctxc</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41432337">prev</a><span>|</span><a href="#41431541">next</a><span>|</span><label class="collapse" for="c-41431364">[-]</label><label class="expand" for="c-41431364">[1 more]</label></div><br/><div class="children"><div class="content">Agree with you.<p>What happens when translation files get too big and you want to split and send only relevant parts?  
Like send only auth keys when user is unauthenticated?<p>`return translations[auth][login]` is no longer possible.<p>Or just imagine you want to iterate through `auth` keys. _shudders_</div><br/></div></div><div id="41431541" class="c"><input type="checkbox" id="c-41431541" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41431364">prev</a><span>|</span><a href="#41431550">next</a><span>|</span><label class="collapse" for="c-41431541">[-]</label><label class="expand" for="c-41431541">[1 more]</label></div><br/><div class="children"><div class="content">Entrenched typos like ATRISTS are actually a greppability goldmine. Chances are there are more occurrences of pluralized people who are making art in the codebase, but only ATRISTS is the one from that enum.<p>I certainly would not suggest deliberately mistyping, but there are places where the benefit is approaching the cost. Certain log messages can absolutely benefit from subtle letter garbling that retains readability while adding uniqueness.</div><br/></div></div><div id="41431550" class="c"><input type="checkbox" id="c-41431550" checked=""/><div class="controls bullet"><span class="by">kaelwd</span><span>|</span><a href="#41431249">parent</a><span>|</span><a href="#41431541">prev</a><span>|</span><a href="#41432506">next</a><span>|</span><label class="collapse" for="c-41431550">[-]</label><label class="expand" for="c-41431550">[1 more]</label></div><br/><div class="children"><div class="content">REFERER moment.</div><br/></div></div></div></div><div id="41432506" class="c"><input type="checkbox" id="c-41432506" checked=""/><div class="controls bullet"><span class="by">vijucat</span><span>|</span><a href="#41431249">prev</a><span>|</span><a href="#41432712">next</a><span>|</span><label class="collapse" for="c-41432506">[-]</label><label class="expand" for="c-41432506">[1 more]</label></div><br/><div class="children"><div class="content">One other thing I&#x27;d like to add is greppable comments! In the same vein as TODO and FIXME, I use hashtags in comments to drop hints to future me reading the code. #learning is a universal one:<p>&#x2F;&#x2F; #learning: transparent color using color.new(color.white, 100). This is GREAT for hiding plot() lines during inapplicable periods (such as when no trade is on)<p>But project-specific hashtags are quite useful, too.<p>&#x2F;&#x2F; #60within600: bunch API calls to not hit the 60 calls within 10 minutes limit<p>&#x2F;&#x2F; This memoizes fn call results to prevent #60within600<p>The hashtagging was inspired long ago by del.icio.us, if you remember that. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Delicious_(website)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Delicious_(website)</a></div><br/></div></div><div id="41432712" class="c"><input type="checkbox" id="c-41432712" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#41432506">prev</a><span>|</span><a href="#41432296">next</a><span>|</span><label class="collapse" for="c-41432712">[-]</label><label class="expand" for="c-41432712">[1 more]</label></div><br/><div class="children"><div class="content">I use greppable strings explicitly, like<p><pre><code>  requests.get(f&#x27;http:&#x2F;&#x2F;a.b.c.d&#x2F;wol?device={wol_computer}&amp;grep-id=wake-on-lan&#x27;, timeout=3)
</code></pre>
This way I find `grep-id` in the server logs as a reminder of what to grep for, then `grep-id=wake-on-lan` in the entire codebase to find the actual source of the call.<p>Or I add comments with a grepable token to the code.</div><br/></div></div><div id="41432296" class="c"><input type="checkbox" id="c-41432296" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41432712">prev</a><span>|</span><a href="#41432661">next</a><span>|</span><label class="collapse" for="c-41432296">[-]</label><label class="expand" for="c-41432296">[3 more]</label></div><br/><div class="children"><div class="content">There are of course cases of dynamic data in every language (The table name is an apt example) but usually when I look in code I just expect to be able to follow definitions. If the language doesn&#x27;t reliably allow me to find &quot;usages of this type&quot; without risking finding <i>another type with the exact same name</i> then I&#x27;m already starting up my static type system compiler for the rewrite.<p>There are exceptions of course: when searching git logs, comments etc doesn&#x27;t help what the language or IDE does.<p>And when searching for an unknown symbol (type, function, variable) you don&#x27;t know the name of, but you know _should_ look like &quot;Dog<i>Order&quot; or &quot;Order</i>Dog&quot; is a common task too. In this case I&#x27;d probably search for &quot; Dog.<i>Order\(&quot;  or &quot; Order.</i>Dog\(&quot;  if I&#x27;m looking for a function. The language trait that enabled it is that method names are Pascal Case and always have an opening ( at the end. But my IDE at least lets me search for members (variables, functions) separate from type names. There should be an <i>index</i> in the IDE though that lets you query this data. E.g. looking for types starting with foo could be done with search t:Foo,  instead of having to grep for &quot;(struct|class) Foo&quot; or similar. Tooling is the key.</div><br/><div id="41432348" class="c"><input type="checkbox" id="c-41432348" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#41432296">parent</a><span>|</span><a href="#41432661">next</a><span>|</span><label class="collapse" for="c-41432348">[-]</label><label class="expand" for="c-41432348">[2 more]</label></div><br/><div class="children"><div class="content">The author uses JavaScript and Python as examples. So I presume they have (most?) experience with dynamic languages.<p>In static languages, greppability is hardly as much as a factor. Especially with the availability of LSPs and other such tools nowadays.<p>When I write rust, or Java, I hardly grep, I &quot;go to usages&quot; or &quot;go to definition&quot;, &quot;rename symbol&quot; and so on.  Similar, but not to that extent, with typescript. But when coding in Javascript, Ruby or Python, no matter how fancy or language-focused an IDE is, I&#x27;ll be grepping a lot. Decades of Ruby and Rails &quot;black magic&quot; taught me to grep for partial patterns like the author shows, too. Or to just run the code-path entirely (through tests) because the table-definition of the database will change the available methods and behaviour of the code. Yes. I know.<p>An LSP (or linter, or checker) can only do so much when the available code, methods, classes, behaviour can be changed or added at runtime.</div><br/><div id="41432402" class="c"><input type="checkbox" id="c-41432402" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41432296">root</a><span>|</span><a href="#41432348">parent</a><span>|</span><a href="#41432661">next</a><span>|</span><label class="collapse" for="c-41432402">[-]</label><label class="expand" for="c-41432402">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy to use dynamic languages occasionally too (Bash, Javascript, Python, ..) but I have a rule of thumb that says if I can&#x27;t see the entire codebase on one screen, then it&#x27;s too large for dynamic.</div><br/></div></div></div></div></div></div><div id="41432661" class="c"><input type="checkbox" id="c-41432661" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41432296">prev</a><span>|</span><a href="#41431203">next</a><span>|</span><label class="collapse" for="c-41432661">[-]</label><label class="expand" for="c-41432661">[1 more]</label></div><br/><div class="children"><div class="content">If you really do want your code to be searchable, here’s a couple of practices I’ve adopted:<p>1) Eliminate spelling mistakes. Eliminate alternative spellings. UK vs US English? Pick a side and stick to it.<p>2) Eliminate contractions. Or keep a very short list of allowable ones (We permit “info” for instance.)<p>The point of this is to increase the predictability of the names you use. If you’ve got “tradeable” and “tradable” in your code base, search for it is going to be a pain. You can supplement these rules with common coding standards like “We call these things providers.” but just getting the spelling consistent is huge.</div><br/></div></div><div id="41431203" class="c"><input type="checkbox" id="c-41431203" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41432661">prev</a><span>|</span><a href="#41432471">next</a><span>|</span><label class="collapse" for="c-41431203">[-]</label><label class="expand" for="c-41431203">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why D has a cast keyword:<p><pre><code>    ubyte c = cast(ubyte)i;
</code></pre>
instead of:<p><pre><code>    unsigned char c = (unsigned char)i;
</code></pre>
Casts are a blunt instrument that subvert the type system, and so they need to be greppable.<p>Having the cast keyword also removes the grammatical ambiguities in the expression syntax.</div><br/><div id="41431594" class="c"><input type="checkbox" id="c-41431594" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#41431203">parent</a><span>|</span><a href="#41432471">next</a><span>|</span><label class="collapse" for="c-41431594">[-]</label><label class="expand" for="c-41431594">[3 more]</label></div><br/><div class="children"><div class="content">Do you often grep for casts?
I never do that.</div><br/><div id="41432071" class="c"><input type="checkbox" id="c-41432071" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41431594">parent</a><span>|</span><a href="#41431994">next</a><span>|</span><label class="collapse" for="c-41432071">[-]</label><label class="expand" for="c-41432071">[1 more]</label></div><br/><div class="children"><div class="content">I regard every cast as a bug in my own code and try to refactor it so there aren&#x27;t any. I can&#x27;t get rid of all of them, but they&#x27;re always worth a second look.<p>I don&#x27;t normally grep for them, but others have told me they did.<p>P.S. one thing about D is you can do things like this:<p><pre><code>    ubyte b = i;            &#x2F;&#x2F; error, losing bits
    ubyte b = cast(ubyte)i; &#x2F;&#x2F; ugly cast
    ubyte b = i &amp; 0xFF;     &#x2F;&#x2F; no cast, no error!
</code></pre>
It&#x27;s just one of the nice little details that making programming in D a pleasure.</div><br/></div></div><div id="41431994" class="c"><input type="checkbox" id="c-41431994" checked=""/><div class="controls bullet"><span class="by">aa-jv</span><span>|</span><a href="#41431203">root</a><span>|</span><a href="#41431594">parent</a><span>|</span><a href="#41432071">prev</a><span>|</span><a href="#41432471">next</a><span>|</span><label class="collapse" for="c-41431994">[-]</label><label class="expand" for="c-41431994">[1 more]</label></div><br/><div class="children"><div class="content">Try to think about why you might want to do that.  It makes a lot of sense, but if you&#x27;re not doing it, that might be enlightening...</div><br/></div></div></div></div></div></div><div id="41432471" class="c"><input type="checkbox" id="c-41432471" checked=""/><div class="controls bullet"><span class="by">kmarc</span><span>|</span><a href="#41431203">prev</a><span>|</span><a href="#41432659">next</a><span>|</span><label class="collapse" for="c-41432471">[-]</label><label class="expand" for="c-41432471">[1 more]</label></div><br/><div class="children"><div class="content">Some good recommendations in the article.<p>Greppability is also helpful when you start scripting your editor. Vim has `includeexpr` and co. to implement some &quot;intelligence&quot; when trying to find declarations etc. This enabled me to write a couple line snippet that immediately could resolve Bazel starlark symbols even in &quot;imported&quot; (`load()`) files. At one point I realized I have better code navigation than any of my colleagues using IDEs.<p>This, and tools like ripgrep really help a lot. This is something that VS Code developers also realized when indlcluded ripgrep itself as their &quot;backend&quot; of searching in files.</div><br/></div></div><div id="41432659" class="c"><input type="checkbox" id="c-41432659" checked=""/><div class="controls bullet"><span class="by">noufalibrahim</span><span>|</span><a href="#41432471">prev</a><span>|</span><a href="#41432662">next</a><span>|</span><label class="collapse" for="c-41432659">[-]</label><label class="expand" for="c-41432659">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how to validate this but this seems to be a specific case of &quot;avoiding magic&quot; where there&#x27;s a lot of dynamically generated variables and things. Having the static text of the program more or less show its intent helps readability and searchability quite a bit.<p>I suppose the other extreme is to have a program generator with an input spec and you being left to read through the generated code without access to the input spec.</div><br/></div></div><div id="41432662" class="c"><input type="checkbox" id="c-41432662" checked=""/><div class="controls bullet"><span class="by">peanut-walrus</span><span>|</span><a href="#41432659">prev</a><span>|</span><a href="#41431099">next</a><span>|</span><label class="collapse" for="c-41432662">[-]</label><label class="expand" for="c-41432662">[1 more]</label></div><br/><div class="children"><div class="content">These are all extremely good suggestions. Especially the flattening bit - yes, it&#x27;s verbose as hell, but it just makes so much sense whenever you have to deal with the code any time after writing it. Helm charts, please take note, the docs even say that &quot;In most cases, flat should be favored over nested.&quot;, yet almost every time I have to deal with a Helm chart, it&#x27;s a mess of nested structures.</div><br/></div></div><div id="41431099" class="c"><input type="checkbox" id="c-41431099" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41432662">prev</a><span>|</span><a href="#41431886">next</a><span>|</span><label class="collapse" for="c-41431099">[-]</label><label class="expand" for="c-41431099">[2 more]</label></div><br/><div class="children"><div class="content">one of the strangest and most grep-hostile approaches to identifiers that I have ever observed is Nim ignoring both case and underscores in an effort to allow everyone to write code in their preferred style:<p><a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;manual.html#partial-caseminusinsensitivity_1" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;manual.html#partial-caseminusinsen...</a></div><br/><div id="41431194" class="c"><input type="checkbox" id="c-41431194" checked=""/><div class="controls bullet"><span class="by">uasi</span><span>|</span><a href="#41431099">parent</a><span>|</span><a href="#41431886">next</a><span>|</span><label class="collapse" for="c-41431194">[-]</label><label class="expand" for="c-41431194">[1 more]</label></div><br/><div class="children"><div class="content">Nim even provides a dedicated grep-like tool to search for identifiers regardless of the style <a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;nimgrep.html" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;nimgrep.html</a></div><br/></div></div></div></div><div id="41431886" class="c"><input type="checkbox" id="c-41431886" checked=""/><div class="controls bullet"><span class="by">whirlwin</span><span>|</span><a href="#41431099">prev</a><span>|</span><a href="#41432182">next</a><span>|</span><label class="collapse" for="c-41431886">[-]</label><label class="expand" for="c-41431886">[1 more]</label></div><br/><div class="children"><div class="content">Code grepping at build time can be useful.<p>Grepping at at runtime, if you can call it that, is also very powerful. If you have a binary, either your company or a third party one, but don&#x27;t have the source code easily available, I have used the `strings` program from GNU binutils  which shows tokens in binary code, e.g. hardcoded URLs, credentials and so on. It can also be useful for analyzing certain things in memory.</div><br/></div></div><div id="41432182" class="c"><input type="checkbox" id="c-41432182" checked=""/><div class="controls bullet"><span class="by">traxys</span><span>|</span><a href="#41431886">prev</a><span>|</span><a href="#41431231">next</a><span>|</span><label class="collapse" for="c-41432182">[-]</label><label class="expand" for="c-41432182">[3 more]</label></div><br/><div class="children"><div class="content">I read parts of the Linux kernel source code pretty often, and getting the definition of a function is often pretty involved:<p>- I don&#x27;t always know the return code type, as the calling code assigned a field whose definition I don&#x27;t know to find either<p>- I don&#x27;t know if it&#x27;s a C function or a preprocessor macro<p>This often results in me searching for the exact function name, and combing through the uses in the drivers.
You then need to re-start all that recursively to understand the function you just read.<p>I could use clangd for that, but I don&#x27;t have the ressources on my laptop to compile a kernel</div><br/><div id="41432192" class="c"><input type="checkbox" id="c-41432192" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#41432182">parent</a><span>|</span><a href="#41431231">next</a><span>|</span><label class="collapse" for="c-41432192">[-]</label><label class="expand" for="c-41432192">[2 more]</label></div><br/><div class="children"><div class="content">Why not simply hold Ctrl and click on the name of the function?</div><br/><div id="41432346" class="c"><input type="checkbox" id="c-41432346" checked=""/><div class="controls bullet"><span class="by">GeneralMayhem</span><span>|</span><a href="#41432182">root</a><span>|</span><a href="#41432192">parent</a><span>|</span><a href="#41431231">next</a><span>|</span><label class="collapse" for="c-41432346">[-]</label><label class="expand" for="c-41432346">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t have the resources on my laptop to compile a kernel</div><br/></div></div></div></div></div></div><div id="41431231" class="c"><input type="checkbox" id="c-41431231" checked=""/><div class="controls bullet"><span class="by">jackphilson</span><span>|</span><a href="#41432182">prev</a><span>|</span><a href="#41432265">next</a><span>|</span><label class="collapse" for="c-41431231">[-]</label><label class="expand" for="c-41431231">[7 more]</label></div><br/><div class="children"><div class="content">I wonder - why isn&#x27;t this talked about more? We have had tens of thousands of software companies, each with probably a dozen people focused on hyperoptimizing everything. Why hasn&#x27;t this point been talked about more on the internet to the point where it&#x27;s obvious today? And it&#x27;s not specifically about this, it&#x27;s more in general. Do people just learn this on their own, and not say anything? Or is the discussion related to this topic buried in some old forum somewhere?</div><br/><div id="41431818" class="c"><input type="checkbox" id="c-41431818" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41431231">parent</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41431818">[-]</label><label class="expand" for="c-41431818">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s talked about, just in the opposite direction.<p>I&#x27;ve left hardcoded strings (think Kafka event type names) in my source for this very reason, but after a round of code review they get squirreled away as constants in separate files because string repetition is bad or something.</div><br/><div id="41431980" class="c"><input type="checkbox" id="c-41431980" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41431818">parent</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41431980">[-]</label><label class="expand" for="c-41431980">[4 more]</label></div><br/><div class="children"><div class="content">Without constants, it&#x27;s too easy to let a typo sneak in or have inconvenience later replacing one &quot;event&quot; but not replacing an unrelated &quot;event&quot;. I&#x27;ll only do it if the string is used two times at most, but usually I&#x27;ll make a constant the first time and it doesn&#x27;t feel like any loss.</div><br/><div id="41432061" class="c"><input type="checkbox" id="c-41432061" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41431980">parent</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41432061">[-]</label><label class="expand" for="c-41432061">[3 more]</label></div><br/><div class="children"><div class="content">Yes, this is exactly what I was fighting against.<p>If I have three classes that interact with &quot;MyTable&quot;, then I can grep for places that interact with &quot;MyTable&quot; and I get back three classes.<p>After refactoring, the class which now knows about &quot;MyTable&quot; is Constants.java, which has no business knowing about &quot;MyTable&quot;.  Grepping it now turns up a false-positive and finds 0 of the actual usage sites (3 false-negatives).</div><br/><div id="41432604" class="c"><input type="checkbox" id="c-41432604" checked=""/><div class="controls bullet"><span class="by">NotMichaelBay</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41432061">parent</a><span>|</span><a href="#41432367">next</a><span>|</span><label class="collapse" for="c-41432604">[-]</label><label class="expand" for="c-41432604">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not exactly a false positive. It&#x27;s just a level of indirection, 1 more search by the constant name to find usages. What you sacrifice there you gain by having the compiler help find typos and the IDE help with autocompletion.</div><br/></div></div><div id="41432367" class="c"><input type="checkbox" id="c-41432367" checked=""/><div class="controls bullet"><span class="by">GeneralMayhem</span><span>|</span><a href="#41431231">root</a><span>|</span><a href="#41432061">parent</a><span>|</span><a href="#41432604">prev</a><span>|</span><a href="#41431438">next</a><span>|</span><label class="collapse" for="c-41432367">[-]</label><label class="expand" for="c-41432367">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but now you have the string constant as a symbol, which you can either grep for (in which case you&#x27;re delayed by one search, not the end of the world if you were going to unwind callstacks anyway) or, if you have an LSP, you can jump directly from it to users...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41432265" class="c"><input type="checkbox" id="c-41432265" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#41431231">prev</a><span>|</span><a href="#41431072">next</a><span>|</span><label class="collapse" for="c-41432265">[-]</label><label class="expand" for="c-41432265">[1 more]</label></div><br/><div class="children"><div class="content">As an avid grepper, I disagree with most of these specific recommendations. Use a tool that actual understands references. Don&#x27;t make the code harder to read for humans just to please grep.<p>As for identifiers, use &#x27;foo.?bar&#x27; case-insensitively.</div><br/></div></div><div id="41431072" class="c"><input type="checkbox" id="c-41431072" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41432265">prev</a><span>|</span><a href="#41432057">next</a><span>|</span><label class="collapse" for="c-41431072">[-]</label><label class="expand" for="c-41431072">[11 more]</label></div><br/><div class="children"><div class="content">A lot of this reads like code search tools could and should be a lot better. They probably will be with AI finding its way into everything. In the old days, people would Hungarian prefix types, but now the IDE mitigates that with color codes.</div><br/><div id="41431088" class="c"><input type="checkbox" id="c-41431088" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41431072">parent</a><span>|</span><a href="#41431102">next</a><span>|</span><label class="collapse" for="c-41431088">[-]</label><label class="expand" for="c-41431088">[6 more]</label></div><br/><div class="children"><div class="content">Do you have some ideas for how to make code search better?<p>Right now, code search is basically just text search. If you think code search tools “could and should” be a lot better, what kind of improvements are you thinking about? How would those improvements work?</div><br/><div id="41431142" class="c"><input type="checkbox" id="c-41431142" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431088">parent</a><span>|</span><a href="#41431299">next</a><span>|</span><label class="collapse" for="c-41431142">[-]</label><label class="expand" for="c-41431142">[3 more]</label></div><br/><div class="children"><div class="content">Not OP, but we wouldn&#x27;t need to worry so much about picking out distinct greppable names <i>if</i> (big if) there were tools that parsed the code to draw out concepts for us, ex:<p>1. The popular &quot;Find Usages&quot; which varies widely in accuracy  and reliability by language, IDE, and codebase meta-quirks.<p>2. Tools that show Callee&#x2F;Caller trees, and sometimes possible data-flows between variables.<p>3. DSLs to search hierarchies, like how XPath lets you find XML elements based on nesting, rather than relying on a distinctly greppable <i>single</i> tag-name for the leaf you&#x27;re interested in. (e.g. `&lt;Product&gt;&lt;Name&gt;` vs `&lt;ProductName&gt;`)<p>When things go well, the actual variable name no longer needs to restate certain aspects and relationships that can instead be found through metadata.<p>For example, `GiftCard.purchaser_customer_uuid` is nicely greppable, but you could relax that to `GiftCard.purchaser` if it had a static type of `UUID&lt;Customer&gt;`. Or perhaps you could go to the `Customer.uuid` definition and say &quot;Show me all variables that can populate or be-populated-by this one, up to X steps out, and excluding ones that are function scoped.&quot;<p>That said, I <i>do</i> advocate for &quot;greppability&quot; as a general practice, since I seldom trust that languages, tools, or institutions will come together in a way that makes it unnecessary.</div><br/><div id="41431855" class="c"><input type="checkbox" id="c-41431855" checked=""/><div class="controls bullet"><span class="by">alexpovel</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431142">parent</a><span>|</span><a href="#41431564">next</a><span>|</span><label class="collapse" for="c-41431855">[-]</label><label class="expand" for="c-41431855">[1 more]</label></div><br/><div class="children"><div class="content">Regarding your third point, I put together a tool capable of that to some degree.<p>It allows you to grep inside source code, but limit the search to e.g. “only docstrings inside class definitions”, among other things. That is, it allows nesting and is syntax aware. That example is for Python, but the tool speaks more languages (thanks to treesitter).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;alexpovel&#x2F;srgn&#x2F;blob&#x2F;main&#x2F;README.md#multiple-language-scopes">https:&#x2F;&#x2F;github.com&#x2F;alexpovel&#x2F;srgn&#x2F;blob&#x2F;main&#x2F;README.md#multip...</a></div><br/></div></div><div id="41431564" class="c"><input type="checkbox" id="c-41431564" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431142">parent</a><span>|</span><a href="#41431855">prev</a><span>|</span><a href="#41431299">next</a><span>|</span><label class="collapse" for="c-41431564">[-]</label><label class="expand" for="c-41431564">[1 more]</label></div><br/><div class="children"><div class="content">I guess I wasn’t thinking of “find usages”, but as the article points out, it’s hard to find usages if the usages are dynamic.<p>The solution—to write code which is <i>less</i> dynamic—helps code search and features like find usages.</div><br/></div></div></div></div><div id="41431299" class="c"><input type="checkbox" id="c-41431299" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431088">parent</a><span>|</span><a href="#41431142">prev</a><span>|</span><a href="#41431152">next</a><span>|</span><label class="collapse" for="c-41431299">[-]</label><label class="expand" for="c-41431299">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Right now, code search is basically just text search.<p>We have lots of code search that is much more syntax-aware than just text search, but it tends to be behind very limited UI, because we have all the tech to do much better code search, but no one has come up with a generally-usable UI for it, so we just have very specific instances -- like &quot;go to definition&quot;, &quot;find references&quot; , etc.<p>That takes all the same technological bits that would be need for, say, &quot;find all definitions of functions visible in the current scope whose name starts with &#x27;ban&#x27;&quot; or &quot;find all definitions of int8 constants visible in the current scope&quot;...but what&#x27;s the UI that makes that kind of searching outside of the kind of special cases now behind their own IDE menu items usable?</div><br/></div></div><div id="41431152" class="c"><input type="checkbox" id="c-41431152" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431088">parent</a><span>|</span><a href="#41431299">prev</a><span>|</span><a href="#41431102">next</a><span>|</span><label class="collapse" for="c-41431152">[-]</label><label class="expand" for="c-41431152">[1 more]</label></div><br/><div class="children"><div class="content">Vector embeddings.</div><br/></div></div></div></div><div id="41431102" class="c"><input type="checkbox" id="c-41431102" checked=""/><div class="controls bullet"><span class="by">ddfs123</span><span>|</span><a href="#41431072">parent</a><span>|</span><a href="#41431088">prev</a><span>|</span><a href="#41432057">next</a><span>|</span><label class="collapse" for="c-41431102">[-]</label><label class="expand" for="c-41431102">[4 more]</label></div><br/><div class="children"><div class="content">Unless you have syntax-aware grep support, I don&#x27;t see how searching nested key json could be better. But grep is the default installed. Not to mention ad-hoc languages that does not have any IDE support.</div><br/><div id="41431150" class="c"><input type="checkbox" id="c-41431150" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431102">parent</a><span>|</span><a href="#41431266">next</a><span>|</span><label class="collapse" for="c-41431150">[-]</label><label class="expand" for="c-41431150">[1 more]</label></div><br/><div class="children"><div class="content">If you put a lot of arbitrary constraints to not allow it to be better, sure. Enjoy.</div><br/></div></div><div id="41431266" class="c"><input type="checkbox" id="c-41431266" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431102">parent</a><span>|</span><a href="#41431150">prev</a><span>|</span><a href="#41431219">next</a><span>|</span><label class="collapse" for="c-41431266">[-]</label><label class="expand" for="c-41431266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ad-hoc languages<p>This is self-inflicted.</div><br/></div></div><div id="41431219" class="c"><input type="checkbox" id="c-41431219" checked=""/><div class="controls bullet"><span class="by">uasi</span><span>|</span><a href="#41431072">root</a><span>|</span><a href="#41431102">parent</a><span>|</span><a href="#41431266">prev</a><span>|</span><a href="#41432057">next</a><span>|</span><label class="collapse" for="c-41431219">[-]</label><label class="expand" for="c-41431219">[1 more]</label></div><br/><div class="children"><div class="content">gron makes nested JSON greppable <a href="https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron">https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron</a></div><br/></div></div></div></div></div></div><div id="41432057" class="c"><input type="checkbox" id="c-41432057" checked=""/><div class="controls bullet"><span class="by">shahzaibmushtaq</span><span>|</span><a href="#41431072">prev</a><span>|</span><a href="#41432097">next</a><span>|</span><label class="collapse" for="c-41432057">[-]</label><label class="expand" for="c-41432057">[2 more]</label></div><br/><div class="children"><div class="content">This reminds me of the <i>good practices and guidelines</i> in coding when I was learning to code, which also includes &quot;proper naming&quot; so you can easily find what you are looking for throughout the codebase.</div><br/><div id="41432302" class="c"><input type="checkbox" id="c-41432302" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#41432057">parent</a><span>|</span><a href="#41432097">next</a><span>|</span><label class="collapse" for="c-41432302">[-]</label><label class="expand" for="c-41432302">[1 more]</label></div><br/><div class="children"><div class="content">Me too.<p>But that&#x27;s also what makes me uncomfortable when reading this article. <i>Proper Naming</i> is truly an &quot;art&quot; of balancing trade-offs.<p>It takes domain expertise (Ubiquitous language), understanding of the users of the code (other devs, not end-users), and a lifetime of coding f*ups where naming something wrong turned out painful to balance these.<p>The author gives a nice example of a dynamic table naming. But their refactoring didn&#x27;t keep the behaviour the same (the else&#x2F;catch). So it&#x27;s hard to argue the first is better. And in this case, even without the else&#x2F;catch, I&#x27;d say the latter is better. But there will be cases where greppability is to balanced with readability, testability or refactorability. And in these cases, for me, greppability comes last.</div><br/></div></div></div></div><div id="41432097" class="c"><input type="checkbox" id="c-41432097" checked=""/><div class="controls bullet"><span class="by">anordal</span><span>|</span><a href="#41432057">prev</a><span>|</span><a href="#41432498">next</a><span>|</span><label class="collapse" for="c-41432097">[-]</label><label class="expand" for="c-41432097">[1 more]</label></div><br/><div class="children"><div class="content">Setting a variable by split identifier is surprisingly common in CMake (because functions can&#x27;t return a value):<p>&gt; set(${VAR}_VERSION ${VERSION})<p>This is the main reason I don&#x27;t like CMake.</div><br/></div></div><div id="41432498" class="c"><input type="checkbox" id="c-41432498" checked=""/><div class="controls bullet"><span class="by">emblaegh</span><span>|</span><a href="#41432097">prev</a><span>|</span><a href="#41432045">next</a><span>|</span><label class="collapse" for="c-41432498">[-]</label><label class="expand" for="c-41432498">[1 more]</label></div><br/><div class="children"><div class="content">Python people should think twice before implementing a `__call__` method if they want to improve greppability.</div><br/></div></div><div id="41432045" class="c"><input type="checkbox" id="c-41432045" checked=""/><div class="controls bullet"><span class="by">creesch</span><span>|</span><a href="#41432498">prev</a><span>|</span><a href="#41432318">next</a><span>|</span><label class="collapse" for="c-41432045">[-]</label><label class="expand" for="c-41432045">[4 more]</label></div><br/><div class="children"><div class="content">I fully understand the point the author is making. However, I am not going to sacrifice good JSON and make it flat just so someone can search for it more easily.  With the example they give, it is still readable because it is a simple data structure. But with more complex data their flat structure to me does not make it easy to parse and easier to make mistakes as well.</div><br/><div id="41432158" class="c"><input type="checkbox" id="c-41432158" checked=""/><div class="controls bullet"><span class="by">smartmic</span><span>|</span><a href="#41432045">parent</a><span>|</span><a href="#41432318">next</a><span>|</span><label class="collapse" for="c-41432158">[-]</label><label class="expand" for="c-41432158">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ofter a matter of having the right tool for the job. In your case, <a href="https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron">https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron</a> might be useful.</div><br/><div id="41432386" class="c"><input type="checkbox" id="c-41432386" checked=""/><div class="controls bullet"><span class="by">creesch</span><span>|</span><a href="#41432045">root</a><span>|</span><a href="#41432158">parent</a><span>|</span><a href="#41432409">next</a><span>|</span><label class="collapse" for="c-41432386">[-]</label><label class="expand" for="c-41432386">[1 more]</label></div><br/><div class="children"><div class="content">Well, I&#x27;d say that in the author&#x27;s case it might be more useful. ;) I never really had the inclination to grep for data like the author does.<p>I generally work from an IDE anyway, where it is clear that I am working with a value that is part of a JSON object and I can follow it back to the proper structure anyway.   In fact, the more I think about it, the more I feel like the article is written for a very specific use case and perspective. Almost to the point where the saying &quot;<i>if all you have is a hammer, everything looks like a nail</i>&quot; is applicable. Where if it doesn&#x27;t look enough like a nail it should be adjusted to look more like one instead of expanding your toolbox a bit.</div><br/></div></div></div></div></div></div><div id="41432318" class="c"><input type="checkbox" id="c-41432318" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41432045">prev</a><span>|</span><a href="#41431122">next</a><span>|</span><label class="collapse" for="c-41432318">[-]</label><label class="expand" for="c-41432318">[1 more]</label></div><br/><div class="children"><div class="content">One very simple way to make code less greppable is to use only single leter variables or other short variables that are very likely to be contained in a ton of other words.</div><br/></div></div><div id="41431122" class="c"><input type="checkbox" id="c-41431122" checked=""/><div class="controls bullet"><span class="by">recursivecaveat</span><span>|</span><a href="#41432318">prev</a><span>|</span><a href="#41431592">next</a><span>|</span><label class="collapse" for="c-41431122">[-]</label><label class="expand" for="c-41431122">[1 more]</label></div><br/><div class="children"><div class="content">A small, but underappreciated benefit of grammar changes like from the form `mytype myfun()` to `keyword myfun() sigil mytype`</div><br/></div></div><div id="41431592" class="c"><input type="checkbox" id="c-41431592" checked=""/><div class="controls bullet"><span class="by">elijahbenizzy</span><span>|</span><a href="#41431122">prev</a><span>|</span><a href="#41431883">next</a><span>|</span><label class="collapse" for="c-41431592">[-]</label><label class="expand" for="c-41431592">[1 more]</label></div><br/><div class="children"><div class="content">Heh, this was very much the design philosophy behind Hamilton (github.com&#x2F;dagworks-inc&#x2F;hamilton).<p>The basic idea was that if you have a data artifact (columns for dataframes initially), you should be able to ctrl-f and find it in your codebase. 1:1 mapping of data -&gt; function.<p>People take a long time to figure out that the readability gains from having greppability is worth whatever verbosity that comes, largely because they think of code too much as a craft (make it as small&#x2F;neat as possible) and not documentation for a live process...</div><br/></div></div><div id="41431883" class="c"><input type="checkbox" id="c-41431883" checked=""/><div class="controls bullet"><span class="by">mrb</span><span>|</span><a href="#41431592">prev</a><span>|</span><label class="collapse" for="c-41431883">[-]</label><label class="expand" for="c-41431883">[2 more]</label></div><br/><div class="children"><div class="content">I will always remember my professor explaining that greppability is the reason C++ casting operators use a long keyword: static_cast&lt;...&gt; const_cast&lt;...&gt;, etc as you can easily grep for &quot;_cast&quot; or the whole keyword.</div><br/></div></div></div></div></div></div></div></body></html>