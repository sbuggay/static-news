<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698483652248" as="style"/><link rel="stylesheet" href="styles.css?v=1698483652248"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://boston.conman.org/2023/10/25.1">A small warning about UDP based protocols</a> <span class="domain">(<a href="https://boston.conman.org">boston.conman.org</a>)</span></div><div class="subtext"><span>signa11</span> | <span>38 comments</span></div><br/><div><div id="38048267" class="c"><input type="checkbox" id="c-38048267" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#38047665">next</a><span>|</span><label class="collapse" for="c-38048267">[-]</label><label class="expand" for="c-38048267">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m starting to think that TCP is past its prime and UDP based protocols (like QUIC) are the way forward.<p>The problem is exacerbated by TLS encryption. It requires six packets, or three round trip times, to establish a TLS over TCP connection. That is hundreds of milliseconds before a single byte of payload can be transferred.<p>The QUIC protocol combines the three way handshake and the three way key exchange to half the time I takes to set up a connection and provides a fast start (0rtt) for resuming a previously configured connection.<p>Additionally TCP connections do not survive a changed IP address like when changing from wifi to mobile data.<p>The stream model of TCP with head of the line blocking is conceptually easy but ultimately the wrong model for transmitting blobs of data. Rejecting a valid packet because the order got shuffled is wasteful, when we could just as easily reassemble the packets on the receiver side (even outside the sliding window).<p>There are a lot of times when the stream model is a good choice (dynamically generated data) but I would argue that sending sized blobs (like images) is a larger volume (in terms of bytes transferred) of traffic.<p>But the OP is right, writing custom UDP protocol is fraught with peril. DDoS amplification is just one way to screw up.</div><br/></div></div><div id="38047665" class="c"><input type="checkbox" id="c-38047665" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#38048267">prev</a><span>|</span><a href="#38047074">next</a><span>|</span><label class="collapse" for="c-38047665">[-]</label><label class="expand" for="c-38047665">[8 more]</label></div><br/><div class="children"><div class="content">A couple commenters have disagreed with the author saying “That’s one reason for the TCP three-way handshake”. But I’ve been implementing uTP, the UDP protocol that torrents use (<a href="https:&#x2F;&#x2F;www.bittorrent.org&#x2F;beps&#x2F;bep_0029.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.bittorrent.org&#x2F;beps&#x2F;bep_0029.html</a>) and it seems to avoid amplification attacks thanks to a three-way handshake.<p>So the author seems correct to say it’s <i>one</i> (good) reason for the three-way handshake.<p>(It turns out when you want to spider libgen for all epubs for training data, the most straightforward way to do this, apart from downloading &gt;40TB, is to write your own torrent client that selectively recognizes epub files and fetches only those.)<p>The uTP spec (BEP 29, linked above) also gives a good overview of why UDP is sometimes the correct choice over TCP in modern times. uTP automatically throttles itself to yield excess bandwidth to any TCP connection that wants it. Imagine trying to write an app that uses all the bandwidth on your network, without impacting anyone else on the network. You’d find it quite hard. uTP does it by embedding time deltas in the packets and throttling itself whenever the timestamp goes over ~100ms, which indicates either a connection dropout or bandwidth saturation.<p>I.e. if your ping suddenly spikes, it’s because someone is hogging all the bandwidth. Normally you have to track down who’s doing it, like a detective hunting a murderer. But uTP knows that it’s the murderer, so it throttles itself back. Presto, perfect bandwidth utilization.<p>But why bother with UDP? Why can’t you do this with a TCP connection? Just measure the time deltas and throttle yourself if it spikes, right? Good question, and I don’t have a good answer. Perhaps one of you can give a persuasive one, lest you agree that ISPs should just throttle UDP by design.<p>It’s certainly simpler to solve this at a protocol level, but one could imagine a BEP that adds time deltas to the torrent spec and prevents sending pieces too quickly (“if the deltas spike, send fewer blocks per second&quot;). It might even be simpler than bothering to reimplement TCP over UDP. But perhaps there’s a good reason.<p>One idea that comes to mind is that the goal is to throttle sends <i>and</i> receives. You control your sends, but you’re at the mercy of the counterparty for receives. You’d need to keep throttle info for every peer, and notice when <i>their</i> pings spike, not just yours. Then you’d send fewer packets. But that’s what uTP does, and that doesn’t answer “Why do it in UDP instead of TCP?”</div><br/><div id="38048183" class="c"><input type="checkbox" id="c-38048183" checked=""/><div class="controls bullet"><span class="by">paulsutter</span><span>|</span><a href="#38047665">parent</a><span>|</span><a href="#38048105">next</a><span>|</span><label class="collapse" for="c-38048183">[-]</label><label class="expand" for="c-38048183">[1 more]</label></div><br/><div class="children"><div class="content">Latency due to head-of-line blocking is a big issue with TCP. Any packet loss causes a backup of all other data while waiting for retransmit. Window negotiation would make your control spotty because you’d be layering two different&#x2F;incompatible flow mechanisms<p>&gt; But why bother with UDP? Why can’t you do this with a TCP connection? Just measure the time deltas and throttle yourself if it spikes, right? Good question, and I don’t have a good answer.</div><br/></div></div><div id="38048105" class="c"><input type="checkbox" id="c-38048105" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#38047665">parent</a><span>|</span><a href="#38048183">prev</a><span>|</span><a href="#38047935">next</a><span>|</span><label class="collapse" for="c-38048105">[-]</label><label class="expand" for="c-38048105">[1 more]</label></div><br/><div class="children"><div class="content">It uses UDP instead of TCP because it does not care about in-order delivery of the data, only that it eventually has all of the data.<p>Fragmenting and coalescing the data happens at a higher layer, so there is no reason to duplicate that effort at the transport layer (which is needed to provide a efficient in-order stream abstraction).<p>TCP (and other protocols) presenting a in-order stream abstraction is beneficial in a lot of ways, but it impacts the design and guarantees you can make in a way that is harmful to a application that only cares about eventual completion.</div><br/></div></div><div id="38047935" class="c"><input type="checkbox" id="c-38047935" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#38047665">parent</a><span>|</span><a href="#38048105">prev</a><span>|</span><a href="#38048108">next</a><span>|</span><label class="collapse" for="c-38047935">[-]</label><label class="expand" for="c-38047935">[4 more]</label></div><br/><div class="children"><div class="content">Wait, doesn&#x27;t TCP have automatic throttling too?</div><br/><div id="38047991" class="c"><input type="checkbox" id="c-38047991" checked=""/><div class="controls bullet"><span class="by">diroussel</span><span>|</span><a href="#38047665">root</a><span>|</span><a href="#38047935">parent</a><span>|</span><a href="#38048253">next</a><span>|</span><label class="collapse" for="c-38047991">[-]</label><label class="expand" for="c-38047991">[1 more]</label></div><br/><div class="children"><div class="content">TCP&#x27;s throttling mechanisms are quite coarse compared to what is described above, and they don&#x27;t measure packet latency, only packet loss (after suitable timeout).<p>See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TCP_tuning" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TCP_tuning</a></div><br/></div></div><div id="38048253" class="c"><input type="checkbox" id="c-38048253" checked=""/><div class="controls bullet"><span class="by">amtamt</span><span>|</span><a href="#38047665">root</a><span>|</span><a href="#38047935">parent</a><span>|</span><a href="#38047991">prev</a><span>|</span><a href="#38047964">next</a><span>|</span><label class="collapse" for="c-38048253">[-]</label><label class="expand" for="c-38048253">[1 more]</label></div><br/><div class="children"><div class="content">Congestion control is a thing in TCP since beginning, so yes.. you are right<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TCP_congestion_control" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TCP_congestion_control</a></div><br/></div></div><div id="38047964" class="c"><input type="checkbox" id="c-38047964" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#38047665">root</a><span>|</span><a href="#38047935">parent</a><span>|</span><a href="#38048253">prev</a><span>|</span><a href="#38048108">next</a><span>|</span><label class="collapse" for="c-38047964">[-]</label><label class="expand" for="c-38047964">[1 more]</label></div><br/><div class="children"><div class="content">Sounds a bit like CoDel to me.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;CoDel" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;CoDel</a></div><br/></div></div></div></div><div id="38048108" class="c"><input type="checkbox" id="c-38048108" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#38047665">parent</a><span>|</span><a href="#38047935">prev</a><span>|</span><a href="#38047074">next</a><span>|</span><label class="collapse" for="c-38048108">[-]</label><label class="expand" for="c-38048108">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why bother with UDP? Perhaps one of you can give a persuasive one<p>Pretty much all video games use UDP.</div><br/></div></div></div></div><div id="38047074" class="c"><input type="checkbox" id="c-38047074" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#38047665">prev</a><span>|</span><a href="#38047019">next</a><span>|</span><label class="collapse" for="c-38047074">[-]</label><label class="expand" for="c-38047074">[2 more]</label></div><br/><div class="children"><div class="content">Speaking of denial of service, it looks like HN killed the guy&#x27;s server. <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231028021348&#x2F;https:&#x2F;&#x2F;boston.conman.org&#x2F;2023&#x2F;10&#x2F;25.1" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231028021348&#x2F;https:&#x2F;&#x2F;boston.co...</a></div><br/><div id="38047508" class="c"><input type="checkbox" id="c-38047508" checked=""/><div class="controls bullet"><span class="by">pronoiac</span><span>|</span><a href="#38047074">parent</a><span>|</span><a href="#38047019">next</a><span>|</span><label class="collapse" for="c-38047508">[-]</label><label class="expand" for="c-38047508">[1 more]</label></div><br/><div class="children"><div class="content">It responded eventually for me, but the Wayback Machine has it - <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231028021348&#x2F;https:&#x2F;&#x2F;boston.conman.org&#x2F;2023&#x2F;10&#x2F;25.1" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231028021348&#x2F;https:&#x2F;&#x2F;boston.co...</a></div><br/></div></div></div></div><div id="38047019" class="c"><input type="checkbox" id="c-38047019" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38047074">prev</a><span>|</span><a href="#38048018">next</a><span>|</span><label class="collapse" for="c-38047019">[-]</label><label class="expand" for="c-38047019">[1 more]</label></div><br/><div class="children"><div class="content">I mean, it’s definitely not one of the reasons for the TCP 3WH, though that may be a happy accident of it.</div><br/></div></div><div id="38048018" class="c"><input type="checkbox" id="c-38048018" checked=""/><div class="controls bullet"><span class="by">chmike</span><span>|</span><a href="#38047019">prev</a><span>|</span><a href="#38046988">next</a><span>|</span><label class="collapse" for="c-38048018">[-]</label><label class="expand" for="c-38048018">[3 more]</label></div><br/><div class="children"><div class="content">The problem result from the ability to forge a fake origin IP address. This can be avoided by adding a certificate for the IP address. It adds a processing and size overhead, but it also preserves the single round trip transaction.</div><br/><div id="38048048" class="c"><input type="checkbox" id="c-38048048" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#38048018">parent</a><span>|</span><a href="#38046988">next</a><span>|</span><label class="collapse" for="c-38048048">[-]</label><label class="expand" for="c-38048048">[2 more]</label></div><br/><div class="children"><div class="content">How do you do that and still allow access from anyone without any prior configuration?</div><br/><div id="38048250" class="c"><input type="checkbox" id="c-38048250" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#38048018">root</a><span>|</span><a href="#38048048">parent</a><span>|</span><a href="#38046988">next</a><span>|</span><label class="collapse" for="c-38048250">[-]</label><label class="expand" for="c-38048250">[1 more]</label></div><br/><div class="children"><div class="content">One way could be to require signing with a TLS certificate whose hostname resolves to the source IP(s).</div><br/></div></div></div></div></div></div><div id="38046988" class="c"><input type="checkbox" id="c-38046988" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38048018">prev</a><span>|</span><a href="#38046964">next</a><span>|</span><label class="collapse" for="c-38046988">[-]</label><label class="expand" for="c-38046988">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>That&#x27;s one reason for the TCP three-way handshake.</i><p>No it isn&#x27;t. The TCP three-way handshake precedes all imagination of these kinds of problems.<p>Edit: remember how that three-way handshake was susceptible to memory DoS attacks before SYN cookies were introduced to patch the problem!</div><br/><div id="38047369" class="c"><input type="checkbox" id="c-38047369" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#38046988">parent</a><span>|</span><a href="#38046964">next</a><span>|</span><label class="collapse" for="c-38047369">[-]</label><label class="expand" for="c-38047369">[1 more]</label></div><br/><div class="children"><div class="content">Maybe we should say amplification attacks are a reason why the three-way handshake hasn&#x27;t been removed.</div><br/></div></div></div></div><div id="38046964" class="c"><input type="checkbox" id="c-38046964" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#38046988">prev</a><span>|</span><a href="#38047129">next</a><span>|</span><label class="collapse" for="c-38046964">[-]</label><label class="expand" for="c-38046964">[7 more]</label></div><br/><div class="children"><div class="content">Do these amplification attacks also apply to WebRTC and WebTransport?</div><br/><div id="38048040" class="c"><input type="checkbox" id="c-38048040" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#38046964">parent</a><span>|</span><a href="#38047088">next</a><span>|</span><label class="collapse" for="c-38048040">[-]</label><label class="expand" for="c-38048040">[1 more]</label></div><br/><div class="children"><div class="content">WebTransport requires an established HTTP3 (and therefore QUIC) connection or an established HTTP2 (and therefore TCP) connection, so its vulnerability to reflection attacks corresponds to the vulnerability of the underlying handshakes.</div><br/></div></div><div id="38047088" class="c"><input type="checkbox" id="c-38047088" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38046964">parent</a><span>|</span><a href="#38048040">prev</a><span>|</span><a href="#38047015">next</a><span>|</span><label class="collapse" for="c-38047088">[-]</label><label class="expand" for="c-38047088">[1 more]</label></div><br/><div class="children"><div class="content">WebRTC generally goes through a probing process to verify two-way connectivity before sending media.<p>I not familiar with WebTransport.<p>My understanding of QUIC was that the handshake was designed so the client would pad their initial datagram such that the response was of similar size, avoiding a small request&#x2F;large response pattern. And that typical connection establishment did a key exchange on the first round trip; primarily for privacy, but also to confirm two way connectivity. I could be wrong though; especially around resumption and&#x2F;or connection agility, where a client moves addresses and the session moves with the client.</div><br/></div></div><div id="38047015" class="c"><input type="checkbox" id="c-38047015" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#38046964">parent</a><span>|</span><a href="#38047088">prev</a><span>|</span><a href="#38047129">next</a><span>|</span><label class="collapse" for="c-38047015">[-]</label><label class="expand" for="c-38047015">[4 more]</label></div><br/><div class="children"><div class="content">Am curious about QUIC and HTTP3 as well.</div><br/><div id="38047595" class="c"><input type="checkbox" id="c-38047595" checked=""/><div class="controls bullet"><span class="by">vasilvv</span><span>|</span><a href="#38046964">root</a><span>|</span><a href="#38047015">parent</a><span>|</span><a href="#38047050">next</a><span>|</span><label class="collapse" for="c-38047595">[-]</label><label class="expand" for="c-38047595">[1 more]</label></div><br/><div class="children"><div class="content">QUIC requires the initial handshake packets to be at least 1200 bytes, and sets the anti-amplification limit of 3x [0]. This means that the server can typically send up to 3600 bytes in response (unless the client&#x27;s handshake message exceeds one packet, which usually only happens if there is a post-quantum key share in it). 3600 bytes is usually enough, unless your certificate chain is too large, in which case you&#x27;d need to compress it. [1] is a nice overview of the problem.<p>(full disclosure: I worked on some of this stuff)<p>[0] <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9000#name-address-validation" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9000#name-address-v...</a><p>[1] <a href="https:&#x2F;&#x2F;www.fastly.com&#x2F;blog&#x2F;quic-handshake-tls-compression-certificates-extension-study" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.fastly.com&#x2F;blog&#x2F;quic-handshake-tls-compression-c...</a></div><br/></div></div><div id="38047050" class="c"><input type="checkbox" id="c-38047050" checked=""/><div class="controls bullet"><span class="by">janosdebugs</span><span>|</span><a href="#38046964">root</a><span>|</span><a href="#38047015">parent</a><span>|</span><a href="#38047595">prev</a><span>|</span><a href="#38047129">next</a><span>|</span><label class="collapse" for="c-38047050">[-]</label><label class="expand" for="c-38047050">[2 more]</label></div><br/><div class="children"><div class="content">QUIC explicitly mentions that it is vulnerable to amplification attacks in the RFC. It suggests sending an extra packet to mitigate, at which point I believe the advantage of QUIC is lost as far as establishing connections is concerned.</div><br/><div id="38048007" class="c"><input type="checkbox" id="c-38048007" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#38046964">root</a><span>|</span><a href="#38047050">parent</a><span>|</span><a href="#38047129">next</a><span>|</span><label class="collapse" for="c-38048007">[-]</label><label class="expand" for="c-38048007">[1 more]</label></div><br/><div class="children"><div class="content">I believe you&#x27;re referring to the stateless retry mechanism? It&#x27;s designed to be used only when the server is actually under attack (either as an amplification vector or exhaustion of its own connection capacity). The idea is that the server establishes some threshold for pending QUIC connections, and only if that is exceeded does it start requiring clients to complete the extra stateless, SYN-cookie style roundtrip to validate their source address. So it maintains the advantage of one less roundtrip than TCP+TLS unless the server is receiving large amounts of connections that are not progressing in a timely manner.</div><br/></div></div></div></div></div></div></div></div><div id="38047129" class="c"><input type="checkbox" id="c-38047129" checked=""/><div class="controls bullet"><span class="by">KirillPanov</span><span>|</span><a href="#38046964">prev</a><span>|</span><a href="#38047555">next</a><span>|</span><label class="collapse" for="c-38047129">[-]</label><label class="expand" for="c-38047129">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Any time you have a UDP-based protocol where a small packet to the server results in a large packet from the server will be exploited<p>In other news, water is wet.<p>Seriously folks, if you don&#x27;t already know this you shouldn&#x27;t be designing <i>any</i> protocols.  Datagram or stream-based.<p>&gt; That&#x27;s one reason for the TCP three-way handshake.<p>And its horrendous latency.<p>All of the mitigations for that open up resource exhaustion attacks; frying pan, meet fire.<p>There&#x27;s no free lunch.  Datagram protocols are not going away.</div><br/><div id="38047386" class="c"><input type="checkbox" id="c-38047386" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#38047129">parent</a><span>|</span><a href="#38047555">next</a><span>|</span><label class="collapse" for="c-38047386">[-]</label><label class="expand" for="c-38047386">[2 more]</label></div><br/><div class="children"><div class="content">I just checked Beej&#x27;s Guide and there&#x27;s no mention of amplification. I wouldn&#x27;t be surprised if TCP&#x2F;IP Illustrated doesn&#x27;t teach it either. This means most people won&#x27;t know about it and they won&#x27;t know that they don&#x27;t know.<p>The mitigation of requiring a &quot;SYN&quot; style packet to be MTU-sized sounds pretty good to me. It obviously uses a little more bandwidth but the network may be underutilized on the upstream path anyway.</div><br/><div id="38047566" class="c"><input type="checkbox" id="c-38047566" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#38047129">root</a><span>|</span><a href="#38047386">parent</a><span>|</span><a href="#38047555">next</a><span>|</span><label class="collapse" for="c-38047566">[-]</label><label class="expand" for="c-38047566">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I just checked Beej&#x27;s Guide and there&#x27;s no mention of amplification. I wouldn&#x27;t be surprised if TCP&#x2F;IP Illustrated doesn&#x27;t teach it either. This means most people won&#x27;t know about it and they won&#x27;t know that they don&#x27;t know.<p>The issue isn&#x27;t a lack of understanding of networking, it&#x27;s a lack of understanding of the threat model.</div><br/></div></div></div></div></div></div><div id="38047555" class="c"><input type="checkbox" id="c-38047555" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#38047129">prev</a><span>|</span><label class="collapse" for="c-38047555">[-]</label><label class="expand" for="c-38047555">[10 more]</label></div><br/><div class="children"><div class="content">None of this would be an issue if ISPs actually dropped UDP packets. They should run at a lower QoS by design. After all, the UDP spec explicitly calls out that it&#x27;s unreliable. Yet IRL nobody drops them, ever, except during mitigation.<p>Just drop them already. It&#x27;s been decades.</div><br/><div id="38047614" class="c"><input type="checkbox" id="c-38047614" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38048050">next</a><span>|</span><label class="collapse" for="c-38047614">[-]</label><label class="expand" for="c-38047614">[1 more]</label></div><br/><div class="children"><div class="content">&gt; None of this would be an issue if ISPs actually dropped UDP packets. They should run at a lower QoS by design. After all, the UDP spec explicitly calls out that it&#x27;s unreliable. Yet IRL nobody drops them, ever, except during mitigation.<p>There&#x27;s a difference between unreliable best-effort and &quot;just throw out packets indiscriminatly&quot;.<p>&gt; Just drop them already. It&#x27;s been decades.<p>... Decades since <i>what</i>? UDP is still very much in use</div><br/></div></div><div id="38048050" class="c"><input type="checkbox" id="c-38048050" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38047614">prev</a><span>|</span><a href="#38047780">next</a><span>|</span><label class="collapse" for="c-38048050">[-]</label><label class="expand" for="c-38048050">[1 more]</label></div><br/><div class="children"><div class="content">Amplification attacks would still be a problem even if ISPs were to de-prioritize UDP traffic (for which there is exactly 0 reason, but that&#x27;s another matter). They would still impact anyone talking over UDP, effectively saturating the &quot;UDP link&quot; even if they leave TCP unaffected. And there are some pretty important protocols people actually care about that work over UDP - DNS and RTP în particular.<p>Finally, in an ideal internet, ISPs would not have actually cared whether they are transporting UDP or TCP or SCTP or whatever else. The fact that it&#x27;s basically impossible to send an IP packet that is not one of the blessed protocols over the Internet is already a major corruption of the stack model. Further gimping UDP to make TCP the only viable option would be crazy.</div><br/></div></div><div id="38047780" class="c"><input type="checkbox" id="c-38047780" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38048050">prev</a><span>|</span><a href="#38047639">next</a><span>|</span><label class="collapse" for="c-38047780">[-]</label><label class="expand" for="c-38047780">[1 more]</label></div><br/><div class="children"><div class="content">Individual UDP packets are, and are supposed to be, exactly as unreliable as individual TCP packets.<p>Both of them should be dropped when buffers get over a small size, but otherwise should not be dropped.<p>Do you want TCP packets to just be dropped already, it&#x27;s been decades...?</div><br/></div></div><div id="38047639" class="c"><input type="checkbox" id="c-38047639" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38047780">prev</a><span>|</span><a href="#38047735">next</a><span>|</span><label class="collapse" for="c-38047639">[-]</label><label class="expand" for="c-38047639">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;U&quot; doesn&#x27;t stand for Unreliable. It&#x27;s basically the simplest possible packetization that doesn&#x27;t offer much of anything that the underlying IPv4&#x2F;IPv6 layer doesn&#x27;t, besides filtering out packets based on port numbers.<p>It&#x27;s very commonly used for games and video services, where applications can recover from the odd dropped or out-of-order packet. As the sibling comment mentions, what does &quot;It&#x27;s been decades?&quot; supposed to imply? It&#x27;s also been decades since TCP was invented, are you calling for its discontinuation too?</div><br/></div></div><div id="38047735" class="c"><input type="checkbox" id="c-38047735" checked=""/><div class="controls bullet"><span class="by">jerbear4328</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38047639">prev</a><span>|</span><a href="#38047751">next</a><span>|</span><label class="collapse" for="c-38047735">[-]</label><label class="expand" for="c-38047735">[1 more]</label></div><br/><div class="children"><div class="content">That is not a good idea at all. For example: the new HTTP&#x2F;3 over QUIC runs on top of UDP. There&#x27;s a good chance most modern websites you use regularly use UDP, and most games and other real-time programs rely solely on UDP.<p>UDP is unreliable because the raw transport mechanisms on the internet are unreliable. TCP helps control the transport of these packets, but if you need more speed or want to implement it in a better way, then UDP is necessary.</div><br/></div></div><div id="38047751" class="c"><input type="checkbox" id="c-38047751" checked=""/><div class="controls bullet"><span class="by">bouncycastle</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38047735">prev</a><span>|</span><a href="#38047983">next</a><span>|</span><label class="collapse" for="c-38047751">[-]</label><label class="expand" for="c-38047751">[2 more]</label></div><br/><div class="children"><div class="content">UDP is used by Wireguard, for example.<p>Quote from Wikipedia: &quot;WireGuard uses only UDP, due to the potential disadvantages of TCP-over-TCP. Tunneling TCP over a TCP-based connection is known as &quot;TCP-over-TCP&quot;, and doing so can induce a dramatic loss in transmission performance (a problem known as &quot;TCP meltdown&quot;).</div><br/><div id="38048121" class="c"><input type="checkbox" id="c-38048121" checked=""/><div class="controls bullet"><span class="by">snowstormsun</span><span>|</span><a href="#38047555">root</a><span>|</span><a href="#38047751">parent</a><span>|</span><a href="#38047983">next</a><span>|</span><label class="collapse" for="c-38048121">[-]</label><label class="expand" for="c-38048121">[1 more]</label></div><br/><div class="children"><div class="content">Wireguard also has a mechanism where it may choose (under high load) to respond with a cookie, which is the MAC of the requesting IP address. The sender then needs to resend his request with that cookie.<p><a href="https:&#x2F;&#x2F;www.wireguard.com&#x2F;papers&#x2F;wireguard.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.wireguard.com&#x2F;papers&#x2F;wireguard.pdf</a> (5.3)</div><br/></div></div></div></div><div id="38047983" class="c"><input type="checkbox" id="c-38047983" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38047751">prev</a><span>|</span><a href="#38047641">next</a><span>|</span><label class="collapse" for="c-38047983">[-]</label><label class="expand" for="c-38047983">[1 more]</label></div><br/><div class="children"><div class="content">UDP is needed exactly for real time data, like voice calls and games.<p>TCP cannot do it. It&#x27;s in order by design, which makes it useless for timely data.<p>If anything UDP should have higher QoS.</div><br/></div></div><div id="38047641" class="c"><input type="checkbox" id="c-38047641" checked=""/><div class="controls bullet"><span class="by">3c6bYDXLMj</span><span>|</span><a href="#38047555">parent</a><span>|</span><a href="#38047983">prev</a><span>|</span><label class="collapse" for="c-38047641">[-]</label><label class="expand" for="c-38047641">[1 more]</label></div><br/><div class="children"><div class="content">If you could put yourself in the shoes any position&#x2F;s in any organisation&#x2F;s necessary to implement your grand vision, what would you do? How would you do it?<p>This just sounds like the sort of absurd proposition that can only be made by people that don’t have a seat at the table.</div><br/></div></div></div></div></div></div></div></div></div></body></html>