<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716973278411" as="style"/><link rel="stylesheet" href="styles.css?v=1716973278411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://maheshba.bitbucket.io/blog/2024/05/08/2024-ThreeLaws.html">Three Laws of Software Complexity</a>Â <span class="domain">(<a href="https://maheshba.bitbucket.io">maheshba.bitbucket.io</a>)</span></div><div class="subtext"><span>r4um</span> | <span>10 comments</span></div><br/><div><div id="40509724" class="c"><input type="checkbox" id="c-40509724" checked=""/><div class="controls bullet"><span class="by">AllegedAlec</span><span>|</span><a href="#40509748">next</a><span>|</span><label class="collapse" for="c-40509724">[-]</label><label class="expand" for="c-40509724">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In my career, I have taken a particular approach based on building new systems from scratch (before they succumb to the three laws), but this is a lot harder than it sounds<p>This seems like an infeasible solution in most if not all real world cases I&#x27;ve seen. Especially if you have a system with 15 years of legacy and some thousands of man-years of effort put into them.<p>Now, the obvious &quot;don&#x27;t let it get to that point&quot; is a smug IT nerd answer I often see regarding this, but this seems like the kind of green-field startup thinking that doesn&#x27;t apply to 90+% of software development. We have an existing system. This needs to be maintained and extended because it&#x27;s our core business. We cannot just say &quot;oh it&#x27;s become too complex. Let&#x27;s go and spend the next few years creating a new product, so we&#x27;ll have a multi-year feature freeze&quot;.<p>The <i>only</i> feasible way I see to do anything even close to this is to split up the software into domain-like silos slowly and incrementally. At that point you can start <i>considering</i> rewriting silos as they become too complex&#x2F;cumbersome&#x2F;big. However, at that point you&#x27;re already doing complex, lengthy and generally risky refactoring, and speaking of it being a write from scratch is very obviously not true.</div><br/><div id="40509802" class="c"><input type="checkbox" id="c-40509802" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#40509724">parent</a><span>|</span><a href="#40509748">next</a><span>|</span><label class="collapse" for="c-40509802">[-]</label><label class="expand" for="c-40509802">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you. Too many of us developers tend to forget that the customer only looks at the features. Clean code, unit tests, rigorous processes... they are only as valuable as the rate of features they make possible.<p>Complexity and technical debt are our problem, and the customer could not care less about how we solve it, or even whether we solve it. As long as we are struggling with an old piece of sh*t, that&#x27;s good for us: it means the product is selling and the effort to maintain it still makes sense!<p>Selling without complexity and technical debt would be much better, I think we all agree on this, but it&#x27;s a receipt whose success I have never personally witnessed.</div><br/></div></div></div></div><div id="40509748" class="c"><input type="checkbox" id="c-40509748" checked=""/><div class="controls bullet"><span class="by">KSteffensen</span><span>|</span><a href="#40509724">prev</a><span>|</span><a href="#40509781">next</a><span>|</span><label class="collapse" for="c-40509748">[-]</label><label class="expand" for="c-40509748">[2 more]</label></div><br/><div class="children"><div class="content">First law implies that it is impossible to change a badly designed system into a well-designed system through incremental changes.<p>I disagree with this, it is certainly possible to improve the state of some system without starting from scratch.</div><br/><div id="40509770" class="c"><input type="checkbox" id="c-40509770" checked=""/><div class="controls bullet"><span class="by">pvdoom</span><span>|</span><a href="#40509748">parent</a><span>|</span><a href="#40509781">next</a><span>|</span><label class="collapse" for="c-40509770">[-]</label><label class="expand" for="c-40509770">[1 more]</label></div><br/><div class="children"><div class="content">I think we can look into the notion from complexity theory of attractor states. If you want to make a change, you need to shift your system enough that it moves into another state.<p>In more normal words - the codebase will fight your changes. And that means that small incremental changes may not be enough, and you will need at least a few big leaps.</div><br/></div></div></div></div><div id="40509781" class="c"><input type="checkbox" id="c-40509781" checked=""/><div class="controls bullet"><span class="by">pvdoom</span><span>|</span><a href="#40509748">prev</a><span>|</span><a href="#40509745">next</a><span>|</span><label class="collapse" for="c-40509781">[-]</label><label class="expand" for="c-40509781">[3 more]</label></div><br/><div class="children"><div class="content">Re: first law ... one thing I have been thinking a lot lately is just how much like gardening software is. But in gardening we are not afraid to trim the plants and put them in shape as we go. In software we end up just adding stuff on top, without regard for the overall design. There is this bias towards always adding rather than removing things, and the key to keep things in order is to remove things, to say no, etc.</div><br/><div id="40509887" class="c"><input type="checkbox" id="c-40509887" checked=""/><div class="controls bullet"><span class="by">benfortuna</span><span>|</span><a href="#40509781">parent</a><span>|</span><a href="#40509817">next</a><span>|</span><label class="collapse" for="c-40509887">[-]</label><label class="expand" for="c-40509887">[1 more]</label></div><br/><div class="children"><div class="content">This &quot;trimming&quot; is not just about features, but more generally to simplify and minimise the codebase (less code = less bugs).<p>Such refactoring is an essential part of maintaining software, regardless of how old or bloated it may be.</div><br/></div></div><div id="40509817" class="c"><input type="checkbox" id="c-40509817" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#40509781">parent</a><span>|</span><a href="#40509887">prev</a><span>|</span><a href="#40509745">next</a><span>|</span><label class="collapse" for="c-40509817">[-]</label><label class="expand" for="c-40509817">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the key to keep things in order is to remove things<p>As soon as you are ready to give up the income for those things you want to trim, please go on!</div><br/></div></div></div></div><div id="40509745" class="c"><input type="checkbox" id="c-40509745" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#40509781">prev</a><span>|</span><label class="collapse" for="c-40509745">[-]</label><label class="expand" for="c-40509745">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a well-designed system is an unstable, ephemeral state; whereas a badly designed system is a stable, persistent state<p>It&#x27;s kind of entropy: I wouldn&#x27;t say that a badly designed system is &quot;stable&quot;, it is just as unstable as a well-designed system and keep evolving, but there are many more ways to be &quot;badly designed&quot; than to be &quot;well designed&quot; so without actively fighting entropy, it&#x27;ll be unstable but consistently &quot;bad&quot;</div><br/><div id="40509769" class="c"><input type="checkbox" id="c-40509769" checked=""/><div class="controls bullet"><span class="by">dudeinjapan</span><span>|</span><a href="#40509745">parent</a><span>|</span><label class="collapse" for="c-40509769">[-]</label><label class="expand" for="c-40509769">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a consequence of near-term expedient decisions being taken, and not having the ability&#x2F;time&#x2F;confidence&#x2F;courage to make major refactors when needed.<p>At TableCheck we have a Ruby monolith app we&#x27;ve been working on for 11 years, and TBH it feels better&#x2F;cleaner today that it did 8 years ago. Granted we haven&#x27;t had a lot of personnel turnover and spend a lot of time on maintenance tasks.</div><br/></div></div></div></div></div></div></div></div></div></body></html>