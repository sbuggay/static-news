<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735981259235" as="style"/><link rel="stylesheet" href="styles.css?v=1735981259235"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://calendar.perfplanet.com/2024/breaking-up-with-long-tasks-or-how-i-learned-to-group-loops-and-wield-the-yield/">Breaking Up with Long Tasks or: how I learned to group loops and wield the yield</a>Â <span class="domain">(<a href="https://calendar.perfplanet.com">calendar.perfplanet.com</a>)</span></div><div class="subtext"><span>jcbhmr</span> | <span>22 comments</span></div><br/><div><div id="42592900" class="c"><input type="checkbox" id="c-42592900" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#42592629">next</a><span>|</span><label class="collapse" for="c-42592900">[-]</label><label class="expand" for="c-42592900">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s insane that &quot;don&#x27;t block the UI thread&quot; is so complicated. I never would have expected half the article to be about an edge case if the user is in a background tab.<p>What&#x27;s worse is I don&#x27;t even know how you&#x27;re supposed to know what the edge cases are without stumbling into them.  You shouldn&#x27;t have to know about APIs like document.hidden unless you specifically want to handle background tabs differently. They shouldn&#x27;t leak into the regular event loop.</div><br/><div id="42592916" class="c"><input type="checkbox" id="c-42592916" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42592900">parent</a><span>|</span><a href="#42592629">next</a><span>|</span><label class="collapse" for="c-42592916">[-]</label><label class="expand" for="c-42592916">[7 more]</label></div><br/><div class="children"><div class="content">I just wanna note it&#x27;s crazy that things confusing people a decade ago are still confusing people now. How fucking hard can the concept of a ui thread be?</div><br/><div id="42592943" class="c"><input type="checkbox" id="c-42592943" checked=""/><div class="controls bullet"><span class="by">hahn-kev</span><span>|</span><a href="#42592900">root</a><span>|</span><a href="#42592916">parent</a><span>|</span><a href="#42593141">next</a><span>|</span><label class="collapse" for="c-42592943">[-]</label><label class="expand" for="c-42592943">[5 more]</label></div><br/><div class="children"><div class="content">I think part of the problem is that there is no other thread (outside of service workers), so that&#x27;s why it&#x27;s hard. In C# I would just fire up another thread to do the work and I don&#x27;t have to worry about blocking the UI until I want to notify the UI from that thread. But I can&#x27;t fire up a separate thread in JS so everything is done on the UI thread</div><br/><div id="42593028" class="c"><input type="checkbox" id="c-42593028" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42592900">root</a><span>|</span><a href="#42592943">parent</a><span>|</span><a href="#42592965">next</a><span>|</span><label class="collapse" for="c-42593028">[-]</label><label class="expand" for="c-42593028">[2 more]</label></div><br/><div class="children"><div class="content">The browser as a runtime is the epitome of worse-is-better.</div><br/><div id="42593478" class="c"><input type="checkbox" id="c-42593478" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42592900">root</a><span>|</span><a href="#42593028">parent</a><span>|</span><a href="#42592965">next</a><span>|</span><label class="collapse" for="c-42593478">[-]</label><label class="expand" for="c-42593478">[1 more]</label></div><br/><div class="children"><div class="content">Fuck that lmao, I don&#x27;t want to kill myself</div><br/></div></div></div></div><div id="42592965" class="c"><input type="checkbox" id="c-42592965" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42592900">root</a><span>|</span><a href="#42592943">parent</a><span>|</span><a href="#42593028">prev</a><span>|</span><a href="#42593043">next</a><span>|</span><label class="collapse" for="c-42592965">[-]</label><label class="expand" for="c-42592965">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But I can&#x27;t fire up a separate thread in JS so everything is done on the UI thread<p>Yea targeting the web is nuts if you have other options!</div><br/></div></div><div id="42593043" class="c"><input type="checkbox" id="c-42593043" checked=""/><div class="controls bullet"><span class="by">rafram</span><span>|</span><a href="#42592900">root</a><span>|</span><a href="#42592943">parent</a><span>|</span><a href="#42592965">prev</a><span>|</span><a href="#42593141">next</a><span>|</span><label class="collapse" for="c-42593043">[-]</label><label class="expand" for="c-42593043">[1 more]</label></div><br/><div class="children"><div class="content">Outside of <i>workers</i>, of which service workers are one type.</div><br/></div></div></div></div></div></div></div></div><div id="42592629" class="c"><input type="checkbox" id="c-42592629" checked=""/><div class="controls bullet"><span class="by">leeoniya</span><span>|</span><a href="#42592900">prev</a><span>|</span><a href="#42592888">next</a><span>|</span><label class="collapse" for="c-42592629">[-]</label><label class="expand" for="c-42592629">[8 more]</label></div><br/><div class="children"><div class="content">the problem is that async-ification infects everything up the call chain. converting a synchronous loop to async may now require that you change a lot of your sync code above that loop into async code as well, which can complicate all sorts of stuff like debugging, profiling, error handling.<p>for this reason i always optimize the shit out of all synchronous code before resorting to async. and if you do need to go async after that, you might be better off just offloading that optimized synchronous op to a worker thread (or to wasm) to not block the UI.<p>modern JS vms are insanely fast when you pay attention to GC pressure, mem allocation, monomorphism, and dont use accidentally quadratic algos. it&#x27;s rare that i encounter a codebase that can&#x27;t be sped up by some large multiple without ever resorting to an async&#x2F;defer crutch.</div><br/><div id="42592835" class="c"><input type="checkbox" id="c-42592835" checked=""/><div class="controls bullet"><span class="by">MzHN</span><span>|</span><a href="#42592629">parent</a><span>|</span><a href="#42593416">next</a><span>|</span><label class="collapse" for="c-42592835">[-]</label><label class="expand" for="c-42592835">[1 more]</label></div><br/><div class="children"><div class="content">If this was any other language than JS I would agree but my personal experience with JS is the opposite.<p>In my experience almost everything in the JS world is already async. User interactions are async, requests are async, almost all NodeJS APIs are async. To me having to add more async in JS is a tiny barrier compared to what I&#x27;m facing in other languages that feel more synchronous to me.<p>Since there is already so much async I also feel like debugging, profiling and error handling are all pleasantly solved problems in JS.<p>Offloading to workers is also async so while there are many valid benefits to be gained, avoiding async does not seem like one of them to me.</div><br/></div></div><div id="42593416" class="c"><input type="checkbox" id="c-42593416" checked=""/><div class="controls bullet"><span class="by">bboygravity</span><span>|</span><a href="#42592629">parent</a><span>|</span><a href="#42592835">prev</a><span>|</span><a href="#42592673">next</a><span>|</span><label class="collapse" for="c-42593416">[-]</label><label class="expand" for="c-42593416">[2 more]</label></div><br/><div class="children"><div class="content">Does anyone know when we went from calling things serial and parallel execution to sync and async?<p>Was it before or after we started calling &quot;man-hours&quot; &quot;story points&quot;?</div><br/><div id="42593471" class="c"><input type="checkbox" id="c-42593471" checked=""/><div class="controls bullet"><span class="by">rplnt</span><span>|</span><a href="#42592629">root</a><span>|</span><a href="#42593416">parent</a><span>|</span><a href="#42592673">next</a><span>|</span><label class="collapse" for="c-42593471">[-]</label><label class="expand" for="c-42593471">[1 more]</label></div><br/><div class="children"><div class="content">Async and parallel are not the same thing. You can run code async and yet not parallel (one core, no i&#x2F;o).</div><br/></div></div></div></div><div id="42592673" class="c"><input type="checkbox" id="c-42592673" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#42592629">parent</a><span>|</span><a href="#42593416">prev</a><span>|</span><a href="#42592953">next</a><span>|</span><label class="collapse" for="c-42592673">[-]</label><label class="expand" for="c-42592673">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; you might be better off just offloading a synchronous op to a worker thread to not block the UI.</i><p>I believe it should be the answer. If your computations are tolerably fast, then you could do it without async, but if they are not, then it is better to use preemptive multitasking for them. The overhead on the kernel scheduler will be small, because you don&#x27;t start 10k of threads concurrently eating CPU time. Probably the overhead of starting a thread doesn&#x27;t matter either with long tasks. As a bonus you could also do blocking i&#x2F;o operations without thinking about blocking.</div><br/></div></div><div id="42592953" class="c"><input type="checkbox" id="c-42592953" checked=""/><div class="controls bullet"><span class="by">fenomas</span><span>|</span><a href="#42592629">parent</a><span>|</span><a href="#42592673">prev</a><span>|</span><a href="#42592721">next</a><span>|</span><label class="collapse" for="c-42592953">[-]</label><label class="expand" for="c-42592953">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you might be better off just offloading that optimized synchronous op to a worker thread (or to wasm) to not block the UI.<p>It works in principle, but note that this really complicates your build process. In particular, if you&#x27;re writing a library that other people will use as a dependency, there&#x27;s really no good way to use workers at all without affecting how people bundle their code using your library.</div><br/></div></div><div id="42592721" class="c"><input type="checkbox" id="c-42592721" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#42592629">parent</a><span>|</span><a href="#42592953">prev</a><span>|</span><a href="#42592888">next</a><span>|</span><label class="collapse" for="c-42592721">[-]</label><label class="expand" for="c-42592721">[2 more]</label></div><br/><div class="children"><div class="content">Is this a JS specific issue? I find python is decently friendly to having little pockets of async where it makes sense in what is otherwise a regular synchronous program.</div><br/><div id="42593187" class="c"><input type="checkbox" id="c-42593187" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#42592629">root</a><span>|</span><a href="#42592721">parent</a><span>|</span><a href="#42592888">next</a><span>|</span><label class="collapse" for="c-42593187">[-]</label><label class="expand" for="c-42593187">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say it&#x27;s the other way around. In JS, async is just syntax sugar on Promises, they still execute within the same event loop. So regardless of if you are in async or not, you always have to think about not blocking. This becomes a lot easier to reason about, because all code is from the beginning made to be non blocking. Whereas in python if you call a blocking sync function from async world you are up for trouble. The problem solved in the OP is the unusual case where you need to do some big sync computation.</div><br/></div></div></div></div></div></div><div id="42592888" class="c"><input type="checkbox" id="c-42592888" checked=""/><div class="controls bullet"><span class="by">neuroelectron</span><span>|</span><a href="#42592629">prev</a><span>|</span><a href="#42592742">next</a><span>|</span><label class="collapse" for="c-42592888">[-]</label><label class="expand" for="c-42592888">[2 more]</label></div><br/><div class="children"><div class="content">JS is terrible and this highlights the complexity in performance optimization.  Javascript is supposed to be simple and flexible for &quot;rapid development&quot; but instead you have to create a multi-implementation polyglot for your page to be serious at all.<p>But don&#x27;t let the performance benchmark fool you, the issue with JavaScript isn&#x27;t performance and it isn&#x27;t fixed with WebAsm.</div><br/><div id="42593012" class="c"><input type="checkbox" id="c-42593012" checked=""/><div class="controls bullet"><span class="by">aktuel</span><span>|</span><a href="#42592888">parent</a><span>|</span><a href="#42592742">next</a><span>|</span><label class="collapse" for="c-42593012">[-]</label><label class="expand" for="c-42593012">[1 more]</label></div><br/><div class="children"><div class="content">These issues pop up everywhere, not just with JS. You can (and people do) write horrendously complex and laggy software (e.g. using &quot;frameworks&quot;) in any language. Lots of excellent pieces of software are written in pure JS.</div><br/></div></div></div></div><div id="42592742" class="c"><input type="checkbox" id="c-42592742" checked=""/><div class="controls bullet"><span class="by">underyx</span><span>|</span><a href="#42592888">prev</a><span>|</span><label class="collapse" for="c-42592742">[-]</label><label class="expand" for="c-42592742">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You can think of [long tasks] like potholes on a road, forcing drivers to dodge them or risk damaging their carsâan unpleasant experience either way.<p>I wish people just published their raw draft text instead of having AI add nonsense analogies.</div><br/><div id="42592883" class="c"><input type="checkbox" id="c-42592883" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#42592742">parent</a><span>|</span><label class="collapse" for="c-42592883">[-]</label><label class="expand" for="c-42592883">[2 more]</label></div><br/><div class="children"><div class="content">Dev rel content has always had analogies in it.<p>It&#x27;s a big assumption that AI made that choice.</div><br/><div id="42593295" class="c"><input type="checkbox" id="c-42593295" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42592742">root</a><span>|</span><a href="#42592883">parent</a><span>|</span><label class="collapse" for="c-42593295">[-]</label><label class="expand" for="c-42593295">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s called a &quot;benefit of the doubt&quot;...</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>