<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734858060859" as="style"/><link rel="stylesheet" href="styles.css?v=1734858060859"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tigerbeetle.com/blog/2024-12-19-enum-of-arrays/">Enum of Arrays</a>Â <span class="domain">(<a href="https://tigerbeetle.com">tigerbeetle.com</a>)</span></div><div class="subtext"><span>signa11</span> | <span>24 comments</span></div><br/><div><div id="42485115" class="c"><input type="checkbox" id="c-42485115" checked=""/><div class="controls bullet"><span class="by">tugu77</span><span>|</span><a href="#42483912">next</a><span>|</span><label class="collapse" for="c-42485115">[-]</label><label class="expand" for="c-42485115">[1 more]</label></div><br/><div class="children"><div class="content">This thing should be a poster example of premature optimization. Sure you can squeeze a few milliseconds out in a performance critical task. Most things won&#x27;t measurably benefit though, while making all handling super awkward.<p>If your abstract domain description is fundamentally a collection of things that have a few parts each, then have your data type represent that, instead of turning it inside out for cache effects. If those become relevant at some point, try to abstract that away and do the optimized internal representation under the hood. But don&#x27;t preemptively design your data structures in a cumbersome way just in case. That&#x27;s bad advice.</div><br/></div></div><div id="42483912" class="c"><input type="checkbox" id="c-42483912" checked=""/><div class="controls bullet"><span class="by">moth-fuzz</span><span>|</span><a href="#42485115">prev</a><span>|</span><a href="#42483769">next</a><span>|</span><label class="collapse" for="c-42483912">[-]</label><label class="expand" for="c-42483912">[4 more]</label></div><br/><div class="children"><div class="content">The idea that arrays of structs are inherently more cache friendly and thus data-oriented-er is a bit reductive of the whole practice of data-oriented code. The point is to optimize data layout for <i>access patterns</i>. Putting fields of a struct into their own arrays is only actually an optimization <i>if</i> you&#x27;re only accessing that field in-bulk. And if so, why is it even in a struct in the first place? If you use all fields of a struct in your algorithm, then an array of structs is the optimal way.<p>All the same is true for enums.</div><br/><div id="42485029" class="c"><input type="checkbox" id="c-42485029" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#42483912">parent</a><span>|</span><a href="#42484810">next</a><span>|</span><label class="collapse" for="c-42485029">[-]</label><label class="expand" for="c-42485029">[1 more]</label></div><br/><div class="children"><div class="content">Access patterns matter, but just as important is to have less stuff to access. That&#x27;s why arrays-of-structs are considered cache friendly - columnar data layouts open the door to optimizations that significantly reduce memory footprint. You no longer waste memory with struct padding. Boolean fields can become bitsets. Enums can be bit-packed. Often-null optional fields can become sparse maps. 8-byte pointers can become narrower-sized indices into object pools.</div><br/></div></div><div id="42484189" class="c"><input type="checkbox" id="c-42484189" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#42483912">parent</a><span>|</span><a href="#42484810">prev</a><span>|</span><a href="#42483769">next</a><span>|</span><label class="collapse" for="c-42484189">[-]</label><label class="expand" for="c-42484189">[1 more]</label></div><br/><div class="children"><div class="content">Same with row-major vs. column major, accessing contiguous data is faster than non-contiguous data, so you should align your algorithms and data structures.</div><br/></div></div></div></div><div id="42483769" class="c"><input type="checkbox" id="c-42483769" checked=""/><div class="controls bullet"><span class="by">shwestrick</span><span>|</span><a href="#42483912">prev</a><span>|</span><a href="#42483873">next</a><span>|</span><label class="collapse" for="c-42483769">[-]</label><label class="expand" for="c-42483769">[3 more]</label></div><br/><div class="children"><div class="content">Worth mentioning that you can always safely switch between AoS and SoA. Either can represent the other; all you&#x27;ve done is transpose the data. The same is not true of AoE&#x2F;EoA. The AoE [Spam1, Egg1, Spam2, Spam3, Egg2] has no corresponding EoA that can represent it.<p>What they&#x27;re actually doing is an AoE =&gt; AoEoA transformation: find batches elements with the same tag and reorder the elements so that redundant tags can be eliminated. Essentially, a kind of run-length encoding. It&#x27;s a nice idea.</div><br/><div id="42485151" class="c"><input type="checkbox" id="c-42485151" checked=""/><div class="controls bullet"><span class="by">rlupi</span><span>|</span><a href="#42483769">parent</a><span>|</span><a href="#42483873">next</a><span>|</span><label class="collapse" for="c-42485151">[-]</label><label class="expand" for="c-42485151">[2 more]</label></div><br/><div class="children"><div class="content">Good insight.<p>Ah... category theory :-)<p>Array-of-Stuct (AoS) treats order in arrays as meaningful, arrays as lists, so AoS =&gt; Struct-of-Array (SoA) doesn&#x27;t loose information. It is a sound transformation because it is a homomorphism.<p>Some languages (homoiconic, or with macros or template support) can express this code transformation: e.g. Julia, <a href="https:&#x2F;&#x2F;github.com&#x2F;JuliaArrays&#x2F;StructArrays.jl">https:&#x2F;&#x2F;github.com&#x2F;JuliaArrays&#x2F;StructArrays.jl</a>, or Rust, <a href="https:&#x2F;&#x2F;www.abubalay.com&#x2F;blog&#x2F;2019&#x2F;02&#x2F;16&#x2F;struct-of-arrays" rel="nofollow">https:&#x2F;&#x2F;www.abubalay.com&#x2F;blog&#x2F;2019&#x2F;02&#x2F;16&#x2F;struct-of-arrays</a><p>In a sense, you can see this transformation through the concept of monads (although Haskell monads or F# computational expressions cannot directly express it, as far as I know). Then the corresponding category diagrams leads to sets or multi-sets (run-length encoding requires or implies some concept of identity, so unordered lists with repetitions = bags and multi-sets are equivalent in this specific context), as the right concept for Enums of Arrays.</div><br/><div id="42485210" class="c"><input type="checkbox" id="c-42485210" checked=""/><div class="controls bullet"><span class="by">mbrock</span><span>|</span><a href="#42483769">root</a><span>|</span><a href="#42485151">parent</a><span>|</span><a href="#42483873">next</a><span>|</span><label class="collapse" for="c-42485210">[-]</label><label class="expand" for="c-42485210">[1 more]</label></div><br/><div class="children"><div class="content">Zig can represent AoS to SoA very nicely, it&#x27;s a favored technique for the Zig compiler itself and well supported by the standard library where it&#x27;s known as a MultiArrayList.</div><br/></div></div></div></div></div></div><div id="42483873" class="c"><input type="checkbox" id="c-42483873" checked=""/><div class="controls bullet"><span class="by">fargle</span><span>|</span><a href="#42483769">prev</a><span>|</span><a href="#42484390">next</a><span>|</span><label class="collapse" for="c-42483873">[-]</label><label class="expand" for="c-42483873">[1 more]</label></div><br/><div class="children"><div class="content">an Enum of Arrays would be an enum where each enumerator was a product of each possible enumerator. there would be N^M enumerators where N is the length of the array and M is the number of enumerators. for example, if the original type was enum { red, green } then the enum of array[3] would have to be an enum containing the 8 enumerators:<p><pre><code>    { red-red-red, red-red-green, red-green-red, red-green-green ... green-green-green }
</code></pre>
so that&#x27;s essentially completely useless. i think the exact same problem would occur with array-of-tagged-union to tagged-union-to-array &quot;transformation&quot;.<p>you can&#x27;t just say &quot;hey: arrays and structs and unions are words and if you can do array of struct and struct of array <i>and</i> enum is also a similar word, then why not enum-of-array?&quot;.<p>while tfa talks about &quot;batches&quot; of items with the same tag, and the advantages therein, that isn&#x27;t something captured by the example given, at least without extending the EoA to a variable sized array of EoA and something else to track the number of items in a &quot;run&quot; (as in RLE).<p>this is better thought of as a data-structure problem than a type theory.</div><br/></div></div><div id="42484390" class="c"><input type="checkbox" id="c-42484390" checked=""/><div class="controls bullet"><span class="by">hashmush</span><span>|</span><a href="#42483873">prev</a><span>|</span><a href="#42482433">next</a><span>|</span><label class="collapse" for="c-42484390">[-]</label><label class="expand" for="c-42484390">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it, why wouldn&#x27;t you just store tag + count instead? Am I missing something?</div><br/></div></div><div id="42482433" class="c"><input type="checkbox" id="c-42482433" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#42484390">prev</a><span>|</span><a href="#42483295">next</a><span>|</span><label class="collapse" for="c-42482433">[-]</label><label class="expand" for="c-42482433">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;ve had the need for a uniformly tagged array of enums. Generally, when I do an AoS to SoA transform that includes tagged data, I just factor out the tag into its own array. In fact, if the tag is 2-valued, I just build a bitmap, rather than burning a whole byte. If the tag is a resource indicator, then I have a group of 1-hot bitmaps.</div><br/><div id="42482988" class="c"><input type="checkbox" id="c-42482988" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#42482433">parent</a><span>|</span><a href="#42483295">next</a><span>|</span><label class="collapse" for="c-42482988">[-]</label><label class="expand" for="c-42482988">[4 more]</label></div><br/><div class="children"><div class="content">The SoA transformation makes sense to me and is quite general. The EoA transformation on the other hand feels like a rare special case though it seems perhaps less rare for the OP.<p>Either way, these types of optimizations are typically marginal in the context of end to end performance of most programs. It&#x27;s good to have some knowledge of these kinds of techniques, but most of the time it makes sense to do the thing that is most straightforward to implement and optimize later once the program is already working. Of course if the problem maps neatly onto EoA then that should be preferred in the initial implementation. I though in my 30+ years of programming cannot think of a particular problem that I have solved that would have been enhanced by this.</div><br/><div id="42483190" class="c"><input type="checkbox" id="c-42483190" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#42482433">root</a><span>|</span><a href="#42482988">parent</a><span>|</span><a href="#42483761">next</a><span>|</span><label class="collapse" for="c-42483190">[-]</label><label class="expand" for="c-42483190">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an alternative to OOP. You can get there via a series of transformations:<p>1. Start with OOP (heap-allocated objects with shared base structs)<p>2. Transform to using tagged unions instead<p>3. Transform to the approach outlined in the OP (I call it the &quot;encoding&quot; approach in this talk: <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;649009599" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;649009599</a>)<p>It&#x27;s handy because you get to use an index to refer to an object, and you get serialization benefits. The zig compiler uses this pattern in quite a few places:<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c54fb6771429a7428f&#x2F;src&#x2F;Air.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c5...</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c54fb6771429a7428f&#x2F;src&#x2F;arch&#x2F;x86_64&#x2F;Mir.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c5...</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c54fb6771429a7428f&#x2F;lib&#x2F;std&#x2F;zig&#x2F;Ast.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c5...</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c54fb6771429a7428f&#x2F;src&#x2F;InternPool.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;77c63ac36034db577a9287c5...</a></div><br/></div></div><div id="42483761" class="c"><input type="checkbox" id="c-42483761" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#42482433">root</a><span>|</span><a href="#42482988">parent</a><span>|</span><a href="#42483190">prev</a><span>|</span><a href="#42483566">next</a><span>|</span><label class="collapse" for="c-42483761">[-]</label><label class="expand" for="c-42483761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I though in my 30+ years of programming cannot think of a particular problem that I have solved that would have been enhanced by this.<p>One example that I frequently deal with that can benefit from this is compiler data structures.</div><br/></div></div><div id="42483566" class="c"><input type="checkbox" id="c-42483566" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#42482433">root</a><span>|</span><a href="#42482988">parent</a><span>|</span><a href="#42483761">prev</a><span>|</span><a href="#42483295">next</a><span>|</span><label class="collapse" for="c-42483566">[-]</label><label class="expand" for="c-42483566">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t performance and memory usage generally enhanced by this?<p>So why not simply default to this instead of defaulting to Interfaces&#x2F;traits doing dynamic polymorphism?<p>Makes everyone a bit more happy.</div><br/></div></div></div></div></div></div><div id="42483295" class="c"><input type="checkbox" id="c-42483295" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#42482433">prev</a><span>|</span><a href="#42482754">next</a><span>|</span><label class="collapse" for="c-42483295">[-]</label><label class="expand" for="c-42483295">[1 more]</label></div><br/><div class="children"><div class="content">see also: Richard Fabian&#x27;s data-oriented design book -- the chapter on existential processing discusses enums<p><a href="https:&#x2F;&#x2F;www.dataorienteddesign.com&#x2F;dodbook&#x2F;node4.html" rel="nofollow">https:&#x2F;&#x2F;www.dataorienteddesign.com&#x2F;dodbook&#x2F;node4.html</a><p>Rough idea: model everything as relational data - define 1 table for each state. membership of a record in the table corresponding to state X implies that record is in the given state X.<p>&gt; the reason why you would put an enum in table form, is to reduce control flow impact. Given this, it&#x27;s when we aren&#x27;t using the enumerations to control instruction flow that it&#x27;s fine to leave them alone<p>An example of the latter might be some kind of state machine, where you can write branch-free code to determine the successor state from current state, and no other processing needs to branch on the state tag.</div><br/></div></div><div id="42482754" class="c"><input type="checkbox" id="c-42482754" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42483295">prev</a><span>|</span><a href="#42483083">next</a><span>|</span><label class="collapse" for="c-42482754">[-]</label><label class="expand" for="c-42482754">[6 more]</label></div><br/><div class="children"><div class="content">This is a somewhat, hmm, bilingual post.  The enum in question here is what Zig calls a tagged union, while Rust calls it an enum, with what Zig calls an enum being the degenerate case where the tag is the only payload.<p>I thought this would be about std.enum.EnumArray[0], an array of some T which is indexed by an enum.  I&#x27;ve gotten a lot of mileage out of those as well.  But it&#x27;s about std.MultiArrayList[1], as used with a tagged union.  I&#x27;ve had occasion to use that with structs, but not with unions, and didn&#x27;t actually know that you could, although finding out it makes sense.<p>Actually a variation on MultiArrayList which is optimized for homogenous collections of one specific union variant, since if that&#x27;s the useful way to structure the data then the tag would be redundant to store one of per element.<p>Good read, mostly wanted to add a few links for those who want to know more.  The comptime metaprogramming used in MultiArrayList is a great illustration of what Zig is capable of IMHO.<p>[0]: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;#std.enums.EnumArray" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;#std.enums.Enum...</a>
[1]: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;#std.multi_array_list.MultiArrayList" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;#std.multi_arra...</a></div><br/><div id="42482892" class="c"><input type="checkbox" id="c-42482892" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42482754">parent</a><span>|</span><a href="#42484963">next</a><span>|</span><label class="collapse" for="c-42482892">[-]</label><label class="expand" for="c-42482892">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is a somewhat, hmm, bilingual post. The enum in question here is what Zig calls a tagged union, while Rust calls it an enum, with what Zig calls an enum being the degenerate case where the tag is the only payload.<p>To be fair, I think that most languages typically use enum to refer to the same thing as Zig; if anything, Rust (and Swift, iirc) are somewhat outliers for using that term for tagged unions.</div><br/><div id="42483768" class="c"><input type="checkbox" id="c-42483768" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#42482754">root</a><span>|</span><a href="#42482892">parent</a><span>|</span><a href="#42484963">next</a><span>|</span><label class="collapse" for="c-42483768">[-]</label><label class="expand" for="c-42483768">[2 more]</label></div><br/><div class="children"><div class="content">Scala also calls them enums fyi. Personally, I wish everyone would call them variant types.</div><br/><div id="42484056" class="c"><input type="checkbox" id="c-42484056" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42482754">root</a><span>|</span><a href="#42483768">parent</a><span>|</span><a href="#42484963">next</a><span>|</span><label class="collapse" for="c-42484056">[-]</label><label class="expand" for="c-42484056">[1 more]</label></div><br/><div class="children"><div class="content">I often use the term &quot;sum types&quot; for them, since I think it helps explain why they&#x27;re useful compared to &quot;product&quot; types like structs or objects or tuples. I&#x27;ve heard people refer to them as &quot;algebraic&quot; types, but I don&#x27;t really like that as a term for them because that feels like it should refer to sum and product types as a categorization rather than one of the categories specifically. Unfortunately, &quot;sum type&quot; doesn&#x27;t really work super clearly in verbal conversations that often; people often tend to hear it as &quot;some types&quot;.</div><br/></div></div></div></div></div></div><div id="42484963" class="c"><input type="checkbox" id="c-42484963" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42482754">parent</a><span>|</span><a href="#42482892">prev</a><span>|</span><a href="#42482813">next</a><span>|</span><label class="collapse" for="c-42484963">[-]</label><label class="expand" for="c-42484963">[1 more]</label></div><br/><div class="children"><div class="content">In wit for wasm they call them variants, which makes more sense to me. Enum is kind of an odd name for them. <a href="https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html#variants" rel="nofollow">https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html...</a></div><br/></div></div><div id="42482813" class="c"><input type="checkbox" id="c-42482813" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#42482754">parent</a><span>|</span><a href="#42484963">prev</a><span>|</span><a href="#42483083">next</a><span>|</span><label class="collapse" for="c-42482813">[-]</label><label class="expand" for="c-42482813">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is a somewhat, hmm, bilingual post.<p>Yeah, I wish the author had just mentioned what language they were using in the blog post text. I was looking at it and I couldn&#x27;t identify it. Now I know it is Zig, but I&#x27;m not familiar with Zig so I can&#x27;t identify it by sight. I was looking at it and thinking &quot;this looks a bit like Rust but isn&#x27;t Rust&quot;.</div><br/></div></div></div></div><div id="42483083" class="c"><input type="checkbox" id="c-42483083" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#42482754">prev</a><span>|</span><label class="collapse" for="c-42483083">[-]</label><label class="expand" for="c-42483083">[1 more]</label></div><br/><div class="children"><div class="content">Now do a single class pointer for an array of values...</div><br/></div></div></div></div></div></div></div></body></html>