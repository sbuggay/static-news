<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702198857130" as="style"/><link rel="stylesheet" href="styles.css?v=1702198857130"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.paulgraham.com/progbot.html">Programming Bottom-Up (1993)</a> <span class="domain">(<a href="http://www.paulgraham.com">www.paulgraham.com</a>)</span></div><div class="subtext"><span>tzury</span> | <span>26 comments</span></div><br/><div><div id="38586832" class="c"><input type="checkbox" id="c-38586832" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#38586174">next</a><span>|</span><label class="collapse" for="c-38586832">[-]</label><label class="expand" for="c-38586832">[2 more]</label></div><br/><div class="children"><div class="content">If you want to see this principle in action, I’ve been updating Arc for the last five years. If you clone <a href="https:&#x2F;&#x2F;github.com&#x2F;shawwn&#x2F;sparc">https:&#x2F;&#x2F;github.com&#x2F;shawwn&#x2F;sparc</a>, you should be able to run bin&#x2F;arc news.arc and see a clone of hacker news running on <a href="http:&#x2F;&#x2F;localhost:8080" rel="nofollow noreferrer">http:&#x2F;&#x2F;localhost:8080</a>. No need to install anything if you’re on Linux or Mac; it downloads a minimal racket locally. Windows users just need to install racket normally.<p>I use it as a bookmark aggregator, since I can submit things and leave myself notes. The first account you create will become an admin, and any future accounts are regular users. Passwords are bcrypted rather than sha1’d. Windows works too, but for some reason the repl seems to block all other threads from making progress, so Microsoft users will have to run it with DEV=0 to disable the news.arc repl on startup.<p>It’s not ready to show yet in general, but there are a lot of advances. My design goal is that if pg ever sees it, he’d want to use it himself.<p>It incorporates some ideas from Bel, too. I’ll be doing a big write up of all the changes.<p>The biggest advance from a language standpoint is probably keyword arguments. If there’s any interest, I’ll go into more detail.<p>The biggest advance from a usability standpoint is that arc is now a thin wrapper over racket. There’s no FFI and no need to translate anything. Arc lists are racket lists. Ditto for hash tables and everything else. You can write racket code in arc by prefixing code #&#x27;(like this), which the arc compiler turns into a racket expression (like this). So #&#x27;(require (rename-in racket&#x2F;system [system racket-system])) will do what you’d expect it to do in racket. You can mix racket code and arc in two ways: (#&#x27;foo bar baz) will compile bar and baz as arc expressions, but will call foo in functional position. So (#&#x27;begin0 (+ &quot;x&quot; &#x27;y) &#x27;z) will give &quot;xy&quot;, because begin0 is a racket special form that returns its leftmost expression.<p>The other way is an equivalent of quasiquoting: #`(let ((x #,(obj a: 1))) x) will return a hash table with ‘a set to 1.<p>The unit tests in test.arc are probably the best way to see all the language features, but it’s hard to read at times. (The writeup will introduce each concept in a bel-like fashion, but it’s not ready yet.)<p>news.arc is where most of the power is on display. Making a new endpoint is extremely easy. And prompt.arc shows how you can write a dynamic application without using databases or needing to store any state. The state is in the closures.</div><br/><div id="38586906" class="c"><input type="checkbox" id="c-38586906" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#38586832">parent</a><span>|</span><a href="#38586174">next</a><span>|</span><label class="collapse" for="c-38586906">[-]</label><label class="expand" for="c-38586906">[1 more]</label></div><br/><div class="children"><div class="content">Speaking of closures, remember how HN used to run out of RAM because each page refresh would create new ones? That doesn&#x27;t happen here, because no new closure is created if both the lexical environment and the compiled code are identical. The number of fns are displayed at the bottom when you&#x27;re logged in as an admin, so you can verify nothing new is created when you refresh.<p>Dan has a good writeup about why HN got rid of them, but unfortunately I can&#x27;t seem to find it. There are still reasons to avoid them (e.g. if you need a stable url), but I&#x27;m happy that performance is no longer one of them.</div><br/></div></div></div></div><div id="38586174" class="c"><input type="checkbox" id="c-38586174" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38586832">prev</a><span>|</span><a href="#38587259">next</a><span>|</span><label class="collapse" for="c-38586174">[-]</label><label class="expand" for="c-38586174">[2 more]</label></div><br/><div class="children"><div class="content">For me the key thing is that if you are doing &quot;bottom-up&quot; programming, then those macros&#x2F;functions&#x2F;etc. should be abstract and not related to business rules. Else you are doing premature abstraction, and you&#x27;ll end up creating big rocks you have to carry on your back when you want to make a change.<p>As a consequence, I personally practice bottom-up very sparsely and carefully.</div><br/><div id="38588042" class="c"><input type="checkbox" id="c-38588042" checked=""/><div class="controls bullet"><span class="by">jinwoo68</span><span>|</span><a href="#38586174">parent</a><span>|</span><a href="#38587259">next</a><span>|</span><label class="collapse" for="c-38588042">[-]</label><label class="expand" for="c-38588042">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the bottom-up model denies the importance of the top-down architecture. In practice, you have pressures from both sides. You need to explore what&#x27;s possible at the bottom but also respect what&#x27;s required from the top. And they are complimentary. You explore what&#x27;s possible from the bottom and then you need to adjust how you should organize those possibilities according to the requirements from the top. At the end of the day, as everything else in the world, it&#x27;s all compromise.</div><br/></div></div></div></div><div id="38587259" class="c"><input type="checkbox" id="c-38587259" checked=""/><div class="controls bullet"><span class="by">ternaryoperator</span><span>|</span><a href="#38586174">prev</a><span>|</span><a href="#38586002">next</a><span>|</span><label class="collapse" for="c-38587259">[-]</label><label class="expand" for="c-38587259">[3 more]</label></div><br/><div class="children"><div class="content">The late Stan Kelly-Bootle, who wrote a witty humor column in UNIX Review for years, famously said (paraphrasing here): &quot;Everyone&#x27;s talking about top-down or bottom-up programming, but from what I see, it looks like it&#x27;s mostly bottom-down.&quot;</div><br/><div id="38588024" class="c"><input type="checkbox" id="c-38588024" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#38587259">parent</a><span>|</span><a href="#38588344">prev</a><span>|</span><a href="#38586002">next</a><span>|</span><label class="collapse" for="c-38588024">[-]</label><label class="expand" for="c-38588024">[1 more]</label></div><br/><div class="children"><div class="content">bottoms-up</div><br/></div></div></div></div><div id="38586002" class="c"><input type="checkbox" id="c-38586002" checked=""/><div class="controls bullet"><span class="by">smlavine</span><span>|</span><a href="#38587259">prev</a><span>|</span><a href="#38585823">next</a><span>|</span><label class="collapse" for="c-38586002">[-]</label><label class="expand" for="c-38586002">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard this about Lisp, but I don&#x27;t really get how this doesn&#x27;t apply to other languages. How is writing special operators in Lisp different from writing special functions in any other language?</div><br/><div id="38586240" class="c"><input type="checkbox" id="c-38586240" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38586002">parent</a><span>|</span><a href="#38586116">next</a><span>|</span><label class="collapse" for="c-38586240">[-]</label><label class="expand" for="c-38586240">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve heard this about Lisp, but I don&#x27;t really get how this doesn&#x27;t apply to other languages.<p>It can be, and he even says as much:<p>&gt;&gt; Bottom-up design is possible to a certain degree in languages other than Lisp. Whenever you see library functions, bottom-up design is happening.<p>I&#x27;ll also point to kazinator&#x27;s quote of Ken Thompson in the previous discussion linked by dang:<p>&gt;&gt; It is the way I think. I am a very bottom-up thinker. If you give me the right kind of Tinker Toys, I can imagine the building. I can sit there and see primitives and recognize their power to build structures a half mile high, if only I had just one more to make it functionally complete. I can see those kinds of things. The converse is true, too, I think. I can’t— from the building—imagine the Tinker Toys. When I see a top-down description of a system or language that has infinite libraries described by layers and layers, all I just see is a morass. I can’t get a feel for it. I can’t understand how the pieces fit; I can’t understand something presented to me that’s very complex. Maybe I do what I do because if I built anything more complicated, I couldn’t understand it. I really must break it down into little pieces. - Ken Thompson, Unix and Beyond: An Interview with Ken Thompson, 1999<p>And if you use a TDD style of development (in particular, but test-heavy in general with frequent use of unit and integration tests below the full end-to-end-test level) you&#x27;ll also likely stumble onto a similar bottom-up style of development.<p>I think, circa 1993, his emphasis on Lisp and bottom-up development made a lot more sense than it does today with the increasing availability of interactive development environments (essentially every dynamically typed language, pretty much; but even many others like Java and C#) and increased emphasis on test-heavy development methodologies.</div><br/></div></div><div id="38586116" class="c"><input type="checkbox" id="c-38586116" checked=""/><div class="controls bullet"><span class="by">jksmith</span><span>|</span><a href="#38586002">parent</a><span>|</span><a href="#38586240">prev</a><span>|</span><a href="#38586410">next</a><span>|</span><label class="collapse" for="c-38586116">[-]</label><label class="expand" for="c-38586116">[1 more]</label></div><br/><div class="children"><div class="content">Extreme reinforcement of your point: Read Leo Brodie&#x27;s classics &quot;Starting Forth&quot; and &quot;Thinking Forth.&quot;</div><br/></div></div><div id="38586410" class="c"><input type="checkbox" id="c-38586410" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#38586002">parent</a><span>|</span><a href="#38586116">prev</a><span>|</span><a href="#38586104">next</a><span>|</span><label class="collapse" for="c-38586410">[-]</label><label class="expand" for="c-38586410">[1 more]</label></div><br/><div class="children"><div class="content">A function call has runtime overhead that a macro may not. There are also things that can be difficult to express as a function in the language type system but that are straightforward to implement as a macro. Lisp isn&#x27;t the only language with a strong macro system but it disproportionately attracts programmers who value the power and expressivity that a strong macro system provides.<p>There are a number of reasons that bottom up programming in the style PG seems to be advocating for is not popular in industry. Industrial programming favors the median developer while bottom up is a technique that works best with small teams of skilled programmers. Big cos obviously prefer &quot;safe&quot; languages, but even startups are generally conservative due to the vc induced pressure towards hypergrowth, which also favors the median developer since hypergrowth requires hiring.<p>Writing good programs from the bottom up requires more skill[1], but can lead to substantially better programs by certain criteria. But it may also be considered inscrutable by the median developer. The median developer can also misuse the power afforded by the bottom up language and write something much worse than they would have been able to in a more conservative language. This isn&#x27;t a knock on the median developer, btw, just my perspective on why this style is rarely found in industry.<p>[1] neither LLMs nor stack overflow are of much help when you have essentially written a new language to solve your problem.</div><br/></div></div><div id="38586104" class="c"><input type="checkbox" id="c-38586104" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38586002">parent</a><span>|</span><a href="#38586410">prev</a><span>|</span><a href="#38585823">next</a><span>|</span><label class="collapse" for="c-38586104">[-]</label><label class="expand" for="c-38586104">[2 more]</label></div><br/><div class="children"><div class="content">PG has other essays where he claims it&#x27;s because the lisp version of operators can just do more things.<p>And that&#x27;s true, lisp macros are way more powerful than what most languages support. The newer ones (and some &quot;progressive&quot; old ones) got template systems that are almost as powerful, but the most used languages simply don&#x27;t have anything comparable.<p>That said, nowadays using a lot of that kind of feature is normally frowned upon.</div><br/><div id="38586294" class="c"><input type="checkbox" id="c-38586294" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#38586002">root</a><span>|</span><a href="#38586104">parent</a><span>|</span><a href="#38585823">next</a><span>|</span><label class="collapse" for="c-38586294">[-]</label><label class="expand" for="c-38586294">[1 more]</label></div><br/><div class="children"><div class="content">I have a theory it is frowned upon because there are not a lot of small shops left. Everyone wants be a cog at a big tech co where its leetcode interviews and code that large groups can (somewhat) easily maintain.<p>In these cases the languages used are generally uniform so your skills easily transfer and you aren&#x27;t suffering as many 200% problems by learning both the language and the authors peculiar add-ons.<p>Of course it still happens just not as easy with rigid languages such as Go.<p>It&#x27;s all tradeoffs.</div><br/></div></div></div></div></div></div><div id="38585823" class="c"><input type="checkbox" id="c-38585823" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38586002">prev</a><span>|</span><a href="#38588857">next</a><span>|</span><label class="collapse" for="c-38585823">[-]</label><label class="expand" for="c-38585823">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Programming Bottom-Up (1993)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16933030">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16933030</a> - April 2018 (64 comments)</div><br/></div></div><div id="38588857" class="c"><input type="checkbox" id="c-38588857" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38585823">prev</a><span>|</span><a href="#38587568">next</a><span>|</span><label class="collapse" for="c-38588857">[-]</label><label class="expand" for="c-38588857">[1 more]</label></div><br/><div class="children"><div class="content">You can enjoy the luxury of developing top-down, bottom-up, or sideways or whatever mainly because of the tools and environments that you have, and those were mainly developed bottom up.<p>Code you re-use is often ready-made bottom pieces.<p>Some code you reuse calls your code, like frameworks. They are middle.<p>You might be writing a plugin or extension to an application; then the top is decided and you&#x27;re making some middle or bottom thing.</div><br/></div></div><div id="38587568" class="c"><input type="checkbox" id="c-38587568" checked=""/><div class="controls bullet"><span class="by">cwilper</span><span>|</span><a href="#38588857">prev</a><span>|</span><a href="#38588461">next</a><span>|</span><label class="collapse" for="c-38587568">[-]</label><label class="expand" for="c-38587568">[4 more]</label></div><br/><div class="children"><div class="content">I used to approach problems bottom-up, and I often prefer it when I&#x27;m working on my own because I do feel I have a much deeper understanding of the system as a whole that way. But on larger teams, and especially teams with junior developers or communication boundaries, I find a top-down approach to be much easier to get everyone on board with.</div><br/><div id="38588076" class="c"><input type="checkbox" id="c-38588076" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#38587568">parent</a><span>|</span><a href="#38587902">prev</a><span>|</span><a href="#38588461">next</a><span>|</span><label class="collapse" for="c-38588076">[-]</label><label class="expand" for="c-38588076">[2 more]</label></div><br/><div class="children"><div class="content">top-down is impossible because real systems have no top.<p><a href="https:&#x2F;&#x2F;softwarequotes.com&#x2F;author&#x2F;bertrand-meyer" rel="nofollow noreferrer">https:&#x2F;&#x2F;softwarequotes.com&#x2F;author&#x2F;bertrand-meyer</a></div><br/><div id="38588197" class="c"><input type="checkbox" id="c-38588197" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38587568">root</a><span>|</span><a href="#38588076">parent</a><span>|</span><a href="#38588461">next</a><span>|</span><label class="collapse" for="c-38588197">[-]</label><label class="expand" for="c-38588197">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;bertrandmeyer.com&#x2F;OOSC2&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bertrandmeyer.com&#x2F;OOSC2&#x2F;</a> - The book being quoted is now available for free, the quote you&#x27;re referencing comes from page 108. (PDF page 138)</div><br/></div></div></div></div></div></div><div id="38588461" class="c"><input type="checkbox" id="c-38588461" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#38587568">prev</a><span>|</span><a href="#38586110">next</a><span>|</span><label class="collapse" for="c-38588461">[-]</label><label class="expand" for="c-38588461">[3 more]</label></div><br/><div class="children"><div class="content">I remember nodded excitedly along with this when I first read it maybe twenty years ago, and less so now, so I decided to go into my mental time machine and see if I could remember what was so exciting about it.<p>At the outset let me say that I know that Graham highly values Lisp&#x27;s ability to transform itself into the language you need, especially by using macros. And that&#x27;s nice, too, but it wasn&#x27;t what excited me. For me, it is summed up in this quote:<p>&gt; As you&#x27;re writing a program you may think &quot;I wish Lisp had such-and-such an operator.&quot; So you go and write it<p>I remember mentally screaming &quot;Yes! Yes!&quot; when I read this the first time, and wishing I could explain it to some of my coworkers. But who could possibly disagree with such a simple statement? When I read it, why did I think it would be hard to explain?<p>Thinking back, the conflict was between two perspectives on designing the modules or classes of a codebase: one says that you are implementing a Platonic ideal of the domain, another says you are implementing operations that support the functionality of the system.<p>In the eyes of many of my coworkers at the time, good domain code would have no traces of the specific needs of the program it was written for. It would have its own logical consistency, dictated by the reality of the domain. A Car class should behave like a car, and it should serve the needs of any future car-related programs our company wrote.<p>This was obviously an incomplete picture. For example, a Car class in a ride-share system probably doesn&#x27;t have a coefficient of drag, even though a real car does. But some people felt that the naive, incomplete picture captured such a profound and helpful ideal that it was better than a complete picture that acknowledged the demands of the program (kind of like it might be better to tell a four year old &quot;lying is bad&quot; rather than tell them that it&#x27;s super complicated and mommy and daddy lie all the time but only in the right ways for the right reasons.)<p>I hated the way this ideal glossed over the obvious truth that the supposedly neutral domain model was in fact very selective. Any Car class would specify a tiny and very specific subset of the behavior of a real car, and it would do so at a specific level of fidelity, which needed to support the functionality of the larger system. Because I hated pretending that we weren&#x27;t writing the low-level code for specific high-level needs, I found it refreshing that Paul Graham would so clearly put the needs of the program first. He wrote domain functionality on demand! And if he left coherence and maintainability of the low-level code as an unspoken exercise for the reader, that was no worse (and better in my mind) than leaving unspoken the connection between high-level functionality and low-level design.<p>Anyway, I was always confused that Graham called this &quot;bottom-up programming,&quot; because he explicitly goes top-down. He discovers a need at a higher level (&quot;As you&#x27;re writing a program you may think &#x27;I wish Lisp had such-and-such an operator&#x27;&quot;) and then he drops down to the lower level to provide it (&quot;So you go and write it&quot;). To me this is opposite of the approach that says you start at the bottom and implement a Platonic ideal of the domain, without first explicitly considering the needs of the program.</div><br/><div id="38588796" class="c"><input type="checkbox" id="c-38588796" checked=""/><div class="controls bullet"><span class="by">0xpgm</span><span>|</span><a href="#38588461">parent</a><span>|</span><a href="#38588521">next</a><span>|</span><label class="collapse" for="c-38588796">[-]</label><label class="expand" for="c-38588796">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Anyway, I was always confused that Graham called this &quot;bottom-up programming,&quot; because he explicitly goes top-down. He discovers a need at a higher level (&quot;As you&#x27;re writing a program you may think &#x27;I wish Lisp had such-and-such an operator&#x27;&quot;) and then he drops down to the lower level to provide it (&quot;So you go and write it&quot;). To me this is opposite of the approach that says you start at the bottom and implement a Platonic ideal of the domain, without first explicitly considering the needs of the program.<p>This sums up why I&#x27;ve never really understood this essay. I agreed with the technique but was mystified by why it was called bottom up programming when you first had to approach the problem top down to discover what you needed to implement.</div><br/></div></div><div id="38588521" class="c"><input type="checkbox" id="c-38588521" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#38588461">parent</a><span>|</span><a href="#38588796">prev</a><span>|</span><a href="#38586110">next</a><span>|</span><label class="collapse" for="c-38588521">[-]</label><label class="expand" for="c-38588521">[1 more]</label></div><br/><div class="children"><div class="content">There’s an interesting thread of truth in this, and you’ve touched on it. Paul always goes top down fist, and bottom up second. I don’t think he explained that very well.<p>Doing bottom-up first is fraught with danger, since you don’t know what you’ll need until you start writing an app. That’s why it’s so important to let the bottom-up approach be guided by the needs of an actual application. It rarely goes well any other way.<p>The problem isn’t starting top-down, but that people never do the bottom-up work that you uncover. They get around it in other ways, mostly by suffering. A lot of devs don’t even realize they’re suffering; they think it’s part of the work. Whereas if you pull apart the elements of your top-down program into their component parts, you’ll almost always end up with shorter programs that are more powerful. Sometimes exponentially so.</div><br/></div></div></div></div><div id="38589191" class="c"><input type="checkbox" id="c-38589191" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#38586110">prev</a><span>|</span><a href="#38586869">next</a><span>|</span><label class="collapse" for="c-38589191">[-]</label><label class="expand" for="c-38589191">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly Feynman applauds the bottom up design of the shuttle software[1].<p>[1] <a href="https:&#x2F;&#x2F;history.nasa.gov&#x2F;rogersrep&#x2F;v2appf.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;history.nasa.gov&#x2F;rogersrep&#x2F;v2appf.htm</a></div><br/></div></div><div id="38586869" class="c"><input type="checkbox" id="c-38586869" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#38589191">prev</a><span>|</span><label class="collapse" for="c-38586869">[-]</label><label class="expand" for="c-38586869">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Whenever you see library functions, bottom-up design is happening.<p>I&#x27;m glad he acknowledged that library functions is the majority implementation of &quot;bottom up design&quot;. In that case extracting primitive api functions &amp; layers composed of these functions is effective at reusing logic &amp; creating appropriate levels of abstraction.<p>That being said, many frameworks do not offer these layers of abstraction so create a sort of &quot;complexity lock in&quot;...where one has to use the entire framework in order to use a few useful parts of the framework. I find this complexity lock in to be unfortunate as it not only couples the programmer to the entire framework, even if the majority of the framework is not useful. It also creates noise in the conversation, making it more difficult to search for the appropriate solutions at the appropriate level of abstraction.<p>There is a cost to integrating other libraries into the framework.<p>Frameworks also tend to become an institution in search of increasing market share. This means there are changes done to the framework. Some of these changes are breaking changes that don&#x27;t necessarily improve the core development experience in meaningful ways.</div><br/></div></div></div></div></div></div></div></body></html>