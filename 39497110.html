<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708851659757" as="style"/><link rel="stylesheet" href="styles.css?v=1708851659757"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://without.boats/blog/asynchronous-clean-up/">Asynchronous clean-up</a> <span class="domain">(<a href="https://without.boats">without.boats</a>)</span></div><div class="subtext"><span>hermanradtke</span> | <span>9 comments</span></div><br/><div><div id="39499003" class="c"><input type="checkbox" id="c-39499003" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#39499011">next</a><span>|</span><label class="collapse" for="c-39499003">[-]</label><label class="expand" for="c-39499003">[1 more]</label></div><br/><div class="children"><div class="content">The problem can be solved by re-implementing the functionality of a destructor yourself. What do destructors do? They, along with constructors, implement stack-style control flow. You can do the same thing by creating your own stack container and pushing&#x2F;popping functions to it. It&#x27;s useful in Go, when constructing an object requires allocating multiple fallible resources:<p><pre><code>  func NewFoo() (*Foo, error) {
    var deferStack []func()
    defer func(){
      for i := 0; i &lt; len(deferStack); i++ {
        deferStack[len(deferStack)-1-i]()
      }
    }()
    bar, err := NewBar()
    if err != nil {
      return nil, err
    }
    deferStack = append(deferStack, func() { bar.Close() })

    baz, err := NewBaz(bar)
    if err != nil {
      return nil, err
    }
    deferStack = append(deferStack, func() { baz.Close() })

    quux, err := QuuxPoolAllocate()
    if err != nil {
      return nil, err
    }
    deferStack = append(deferStack, func() { QuuxPoolDeallocate(quux) })

    &#x2F;&#x2F; Do more stuff...
    
    deferStack = nil
    return &amp;Foo{baz, quux}, nil
  }
</code></pre>
Rust doesn&#x27;t have defer, but you can get similar behavior with an object that wraps a Vec of boxed closures and implements Drop.</div><br/></div></div><div id="39499011" class="c"><input type="checkbox" id="c-39499011" checked=""/><div class="controls bullet"><span class="by">u320</span><span>|</span><a href="#39499003">prev</a><span>|</span><a href="#39498510">next</a><span>|</span><label class="collapse" for="c-39499011">[-]</label><label class="expand" for="c-39499011">[1 more]</label></div><br/><div class="children"><div class="content">Reading about async Rust is like reading about a large complicated infrastructure project that keeps getting delays and cost overruns. Rust will end up spending a significant part of its complexity budget on async alone. I wonder if it&#x27;s worth it, for a problem that gets <i>significantly</i> easier if you are prepared to be just a bit more wasteful (allocations, memory, etc). Compare with Ocaml or Haskell for instance.</div><br/></div></div><div id="39498510" class="c"><input type="checkbox" id="c-39498510" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#39499011">prev</a><span>|</span><a href="#39498247">next</a><span>|</span><label class="collapse" for="c-39498510">[-]</label><label class="expand" for="c-39498510">[1 more]</label></div><br/><div class="children"><div class="content">I am likely not even at 10% of the competence of the author but I can&#x27;t help but notice the continuously mentioned struggle of &quot;but what if we cancel the cancellation?&quot; -- which to me seems to be the wrong question to ask. IMO it should not be possible. It should be <i>made</i> impossible by the compiler. The &quot;everything is cancellable&quot; rabbit hole is infinite and is not worth pursuing. Eventually the Rust core team will be inspecting CPU microcode and its bugs, or what&#x27;s the endgame exactly? So let&#x27;s not go there, I say.<p>I know that Rust does not have a runtime and it does not have a spec but I think the questions posed in the article hint at the need for either -- or even both at the same time (i.e. &quot;make a spec for the third party runtime implementors&quot;).<p>I am not saying &quot;imitate Golang or Erlang&quot;. I am saying: &quot;just pick a side already&quot;.<p>On a more intuitive level: to me it feels like Rust tries to be everything for everyone, and I think many of us know that will never work.<p>Choose. Commit. Double down. Make it work. Golang and Erlang did. Rust can do it as well.</div><br/></div></div><div id="39498247" class="c"><input type="checkbox" id="c-39498247" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39498510">prev</a><span>|</span><a href="#39498420">next</a><span>|</span><label class="collapse" for="c-39498247">[-]</label><label class="expand" for="c-39498247">[1 more]</label></div><br/><div class="children"><div class="content">This post is primarily about Rust but the issues raised generalize to async models in any programming language. The tradeoffs between approaches are severe enough that it is desirable, at least in a systems language, to preserve enough flexibility that the model generalizes to different contexts without loss of performance or robustness. Furthermore, async tends to erode modularity in code because async behavior, which is tightly coupled to internal design choices, becomes part of the functional contract. There are all kinds of interesting edge cases around things like bounding worst-case resource pseudo-leakage that you simply don’t need to think about in synchronous code.<p>This is not to suggest that async models are a bad idea. They just have a higher level of intrinsic complexity and language support is immature. The benefit is qualitatively better scalability and performance, so there is a purpose behind using async models.</div><br/></div></div><div id="39498420" class="c"><input type="checkbox" id="c-39498420" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#39498247">prev</a><span>|</span><a href="#39498038">next</a><span>|</span><label class="collapse" for="c-39498420">[-]</label><label class="expand" for="c-39498420">[1 more]</label></div><br/><div class="children"><div class="content">Seems java&#x27;s virtual thread is the only sane async model out there.</div><br/></div></div><div id="39498038" class="c"><input type="checkbox" id="c-39498038" checked=""/><div class="controls bullet"><span class="by">georgelyon</span><span>|</span><a href="#39498420">prev</a><span>|</span><a href="#39498213">next</a><span>|</span><label class="collapse" for="c-39498038">[-]</label><label class="expand" for="c-39498038">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been following a similar issue in Swift (which is informed by some learnings from the Rust side of things). Here is a link to the latest language complexity resulting from this: <a href="https:&#x2F;&#x2F;forums.swift.org&#x2F;t&#x2F;sub-pitch-task-local-values-in-isolated-synchronous-deinit-and-async-deinit&#x2F;70060&#x2F;5" rel="nofollow">https:&#x2F;&#x2F;forums.swift.org&#x2F;t&#x2F;sub-pitch-task-local-values-in-is...</a><p>There are a number of other proposals linked to this issue that can be referenced from that thread. I hope there is a next generation async model for future languages that is truly simple, because this all makes me think footguns are endemic to the current approach (which is broadly the same in Rust and Swift).</div><br/></div></div><div id="39498213" class="c"><input type="checkbox" id="c-39498213" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#39498038">prev</a><span>|</span><label class="collapse" for="c-39498213">[-]</label><label class="expand" for="c-39498213">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I can write all these posts and tell you with a straight face there’s no tradeoff because appeasing the borrow checker is NBD. I never think about appeasing the borrow checker when I write Rust.<p>Guy is in a bubble. He doesn&#x27;t realize that 99% of rust programmers don&#x27;t have the experience he does.</div><br/><div id="39498563" class="c"><input type="checkbox" id="c-39498563" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#39498213">parent</a><span>|</span><label class="collapse" for="c-39498563">[-]</label><label class="expand" for="c-39498563">[1 more]</label></div><br/><div class="children"><div class="content">With my experience of moderating the Rust Community Discord Server, it really doesn&#x27;t take long to get over the borrow checker. Most people are not writing code complicated enough to get stuck with the really complicated cases (unfortunately, yes, the borrow checker is not perfect) but it really is good enough for most people most of the time.</div><br/></div></div></div></div></div></div></div></div></div></body></html>