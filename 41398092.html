<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725267676795" as="style"/><link rel="stylesheet" href="styles.css?v=1725267676795"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zkintro.com/articles/programming-zkps-from-zero-to-hero">Programming Zero Knowledge Proofs: From Zero to Hero</a> <span class="domain">(<a href="https://zkintro.com">zkintro.com</a>)</span></div><div class="subtext"><span>oskarth</span> | <span>64 comments</span></div><br/><div><div id="41423690" class="c"><input type="checkbox" id="c-41423690" checked=""/><div class="controls bullet"><span class="by">zero_k</span><span>|</span><a href="#41421044">next</a><span>|</span><label class="collapse" for="c-41423690">[-]</label><label class="expand" for="c-41423690">[2 more]</label></div><br/><div class="children"><div class="content">If you wanna do it in a flexible way that is very easy to use and essentially the future of ZK, use Powdr [1]. Just write your code in rust nostd and be done with it. It&#x27;s a compiler, basically. Once you use it, you&#x27;ll never go back to hand-massaging polynomials. It&#x27;d be like writing assembly. Sure, some can do it, and it can be fun, but why do it if there are compilers out there to do the heavy lifting for you? :)<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;powdr-labs&#x2F;powdr">https:&#x2F;&#x2F;github.com&#x2F;powdr-labs&#x2F;powdr</a></div><br/><div id="41423720" class="c"><input type="checkbox" id="c-41423720" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41423690">parent</a><span>|</span><a href="#41421044">next</a><span>|</span><label class="collapse" for="c-41423720">[-]</label><label class="expand" for="c-41423720">[1 more]</label></div><br/><div class="children"><div class="content">For Rust, there is also Sunscreen.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Sunscreen-tech&#x2F;Sunscreen">https:&#x2F;&#x2F;github.com&#x2F;Sunscreen-tech&#x2F;Sunscreen</a></div><br/></div></div></div></div><div id="41421044" class="c"><input type="checkbox" id="c-41421044" checked=""/><div class="controls bullet"><span class="by">cosignal</span><span>|</span><a href="#41423690">prev</a><span>|</span><a href="#41421237">next</a><span>|</span><label class="collapse" for="c-41421044">[-]</label><label class="expand" for="c-41421044">[30 more]</label></div><br/><div class="children"><div class="content">As someone with zero knowledge regarding Zero Knowledge Proofs in a programming context, can someone give me a basic explanation regarding the utility? I do understand the basic principle of ZKP’s, but as yet I’m failing to understand how this would be applied in industry.</div><br/><div id="41423036" class="c"><input type="checkbox" id="c-41423036" checked=""/><div class="controls bullet"><span class="by">ruuda</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41422076">next</a><span>|</span><label class="collapse" for="c-41423036">[-]</label><label class="expand" for="c-41423036">[5 more]</label></div><br/><div class="children"><div class="content">A toy example: suppose we have some sudoku. You want to show publicly (maybe in a HN comment) that you know the solution, without revealing the solution itself, because then anybody would know it and be able to post that they know it. A zero-knowledge proof enables this. You could also post a hash of the solution, but then you need to know the solution already to verify a submission. (It would also enable others to copy your answers without really knowing the solution, though that can be fixed using a technique that zero-knowledge proofs also use, a blinding factor).<p>More useful cases include decoupling payment information from users, to preserve their privacy. You can prove that somebody paid for the action you want to perform, without identifying the payer. For example to offer cloud storage without knowing which data belongs to which user, so when there is a data breach or law enforcement order, the answer to &quot;tell me everything you know about user X&quot; is their payment history, but not which data is theirs.</div><br/><div id="41423142" class="c"><input type="checkbox" id="c-41423142" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41423036">parent</a><span>|</span><a href="#41423448">next</a><span>|</span><label class="collapse" for="c-41423142">[-]</label><label class="expand" for="c-41423142">[3 more]</label></div><br/><div class="children"><div class="content">One place I wish there was zero knowledge proofs involved, or even any kind of cryptography, is when you perform credit assessment for loans outside your bank: an external loan provide peeks at your full bank account history to assess whether you’re eligible. They don’t need to know where I buy my socks, or even how much money I have. Only that I have a big enough deposit and a steady enough cashflow.</div><br/><div id="41423193" class="c"><input type="checkbox" id="c-41423193" checked=""/><div class="controls bullet"><span class="by">edf13</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41423142">parent</a><span>|</span><a href="#41423448">next</a><span>|</span><label class="collapse" for="c-41423193">[-]</label><label class="expand" for="c-41423193">[2 more]</label></div><br/><div class="children"><div class="content">Where you spend can have an impact on a decision… e.g. you may have the income and savings but if you’re regularly spending on gambling that can be a red flag.</div><br/><div id="41423293" class="c"><input type="checkbox" id="c-41423293" checked=""/><div class="controls bullet"><span class="by">hbbio</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41423193">parent</a><span>|</span><a href="#41423448">next</a><span>|</span><label class="collapse" for="c-41423293">[-]</label><label class="expand" for="c-41423293">[1 more]</label></div><br/><div class="children"><div class="content">You can prove that too with zk!</div><br/></div></div></div></div></div></div><div id="41423448" class="c"><input type="checkbox" id="c-41423448" checked=""/><div class="controls bullet"><span class="by">roshankhan28</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41423036">parent</a><span>|</span><a href="#41423142">prev</a><span>|</span><a href="#41422076">next</a><span>|</span><label class="collapse" for="c-41423448">[-]</label><label class="expand" for="c-41423448">[1 more]</label></div><br/><div class="children"><div class="content">can this also be used in a session replay software? as in if someone from other team is trying to debug an app issue while watching a replay of the issue capture via DOM but is stuck because some PII data is not visible then can we implement this from user end ? like an OTP to access the PII but only on users consent?</div><br/></div></div></div></div><div id="41422076" class="c"><input type="checkbox" id="c-41422076" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41423036">prev</a><span>|</span><a href="#41421330">next</a><span>|</span><label class="collapse" for="c-41422076">[-]</label><label class="expand" for="c-41422076">[3 more]</label></div><br/><div class="children"><div class="content">For me, the most powerful use of ZKPs is proof of the output of general purpose computations of any kind.<p>You can run an arbitrarily large, arbitrary long program, and whatever the program outputs, you can make a tiny proof-signature that says &quot;this is the output you&#x27;ll get if you run this program yourself&quot;.<p>The proof-signatures are relatively small, and you can verify them on small devices in milliseconds.<p>Another computer can trust the claimed output without having to run the program itself, by verifying the proof-signature.<p>This scales to arbitrarily large computations, so for example if a supercomputer says &quot;I ran a quadrillion petaflops of your program for 1 year, and the result was the picture attached to this signature&quot;, you actually can verify that the picture is correct, quickly and efficiently - without having to trust the supplier.<p>It&#x27;s as good as if you re-ran the program yourself (up to cryptography-grade probabilities, which is good enough).<p>Or if the big computer says &quot;this entire Debian distribution of binary files was indeed compiled with this version of GCC&quot;, you can quickly verify that all the binaries are exactly what they should be - without having to trust anyone.<p>The proof process is rather slow, but it has gotten a lot faster over the last few years, and will continue to.<p>I was amazed when I learned that it&#x27;s possible to securely check an arbitrarily large computation&#x27;s output or result without running it yourself.<p>It was so counter to my intuition: it seemed like you would have to trust whoever makes the claim, or run it yourself. But you don&#x27;t!<p>(So amazed and intrigued that I had to learn how it&#x27;s done, and now part of my work these days is optimising the proof process.)</div><br/><div id="41422603" class="c"><input type="checkbox" id="c-41422603" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422076">parent</a><span>|</span><a href="#41421330">next</a><span>|</span><label class="collapse" for="c-41422603">[-]</label><label class="expand" for="c-41422603">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Or if the big computer says &quot;this entire Debian distribution of binary files was indeed compiled with this version of GCC&quot;, you can quickly verify that all the binaries are exactly what they should be - without having to trust anyone.<p>&gt; So amazed and intrigued that I had to learn how it&#x27;s done<p>Any chance you could just illustrate this somehow with a basic example? I just don&#x27;t see how you could possibly verify that a program is produced with GCC without going through approximately as much effort as it&#x27;d take to compile it.</div><br/><div id="41423327" class="c"><input type="checkbox" id="c-41423327" checked=""/><div class="controls bullet"><span class="by">lifeinthevoid</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422603">parent</a><span>|</span><a href="#41421330">next</a><span>|</span><label class="collapse" for="c-41423327">[-]</label><label class="expand" for="c-41423327">[1 more]</label></div><br/><div class="children"><div class="content">As far as I understand, you can&#x27;t just use any gcc binary as it exists today. The program needs to be represented as a specific, mathematical expression that is suitable for zero-knowledge proofs.</div><br/></div></div></div></div></div></div><div id="41421330" class="c"><input type="checkbox" id="c-41421330" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41422076">prev</a><span>|</span><a href="#41421342">next</a><span>|</span><label class="collapse" for="c-41421330">[-]</label><label class="expand" for="c-41421330">[2 more]</label></div><br/><div class="children"><div class="content">The way I always explain it to newcomers now is to start from digital signatures.<p>Digital signatures are useful, we all know that, now imagine if you could sign not only data, but also computation result. As in “I ran this code with these inputs and it produced that output”.<p>If you imagine that this would work, and it takes less time to verify that signature than running the program myself, you have a succinct proof.<p>If in addition you can hide some of the inputs you used, then you have a zero knowledge proof.<p>So ZKPs are “stronger” signatures as they can sign more than data. Sometimes a signature is enough, sometimes you need more. Sometimes you need privacy so you verify a signature inside a ZKP :D</div><br/></div></div><div id="41421342" class="c"><input type="checkbox" id="c-41421342" checked=""/><div class="controls bullet"><span class="by">coderintherye</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41421330">prev</a><span>|</span><a href="#41422250">next</a><span>|</span><label class="collapse" for="c-41421342">[-]</label><label class="expand" for="c-41421342">[1 more]</label></div><br/><div class="children"><div class="content">The most common example in the talks I&#x27;ve been to have been for verifying anonymous voting amongst a group that you want to verify is valid to vote in the process. ZKPs allow for doing this without needing a central authority to attest to the person&#x27;s credentials.<p>But it is early days and I think there&#x27;s going to be many more use cases in the future around data privacy. Take an example of credit bureaus. What if instead of a lender sending over all the personally identifiable information needed to do a lookup it could instead send a ZKP to prove it knows enough information about an individual to be authorized to retrieve their record, meaning instead of sending SSN, DOB, Address, Phone, Name, they could instead just send enough specific values in the hash of a combo of some of those fields to prove that the full hash is known but without exposing the full hash itself (along with the existing shared secret to have authorization do lookup a value in the credit bureau in the first place).</div><br/></div></div><div id="41422250" class="c"><input type="checkbox" id="c-41422250" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41421342">prev</a><span>|</span><a href="#41422406">next</a><span>|</span><label class="collapse" for="c-41422250">[-]</label><label class="expand" for="c-41422250">[1 more]</label></div><br/><div class="children"><div class="content">I come from a traditional finance background.  One underappreciated possible role for ZKP is in compliance.<p>Eg Goldman Sachs could encode all their compliance rules in a program, and publish  a proof that their books pass the check by that program, without revealing anything about their accounting.<p>More crypto focussed: suppose you build a &#x27;better FTX&#x27;.  You could publish a proof that you ain&#x27;t hiding an Alameda, ie that everyone who should have been liquidated actually got liquidated, and doesn&#x27;t get special treatment.<p>In a banking context, you could in theory also run your know-your-customer (KYC) rules against customer provided data, store the proof, and delete the original data.  That way, you still have proof that your customers don&#x27;t have ties to North Korea or Russia, but you can&#x27;t be compelled by anyone to reveal the data later (nor accidentally leak that data, etc).<p>Of course, for that latter application, you need a sharp lawyer to make sure that storing the proof instead of the original data is enough for your KYC obligations.<p>If you want to go further, you could have your customers run the KYC rules locally, so that their data never leaves their premises.<p>(For all these applications, you still have to have a mechanism that connects the real world to the inputs of the programs whose execution you are proving.<p>So eg Goldman Sachs would still need an auditor that checks that the assets and obligations they have in their balance sheet actually exist, but the auditor does not otherwise need to make judgement calls or apply any rules.)</div><br/></div></div><div id="41422406" class="c"><input type="checkbox" id="c-41422406" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41422250">prev</a><span>|</span><a href="#41421310">next</a><span>|</span><label class="collapse" for="c-41422406">[-]</label><label class="expand" for="c-41422406">[3 more]</label></div><br/><div class="children"><div class="content">I can see applications in multiplayer gamedev - imagine being able to run the whole game simulation on a clients machine and have them assert back to you that they killed 7 goblins, looted a rare sword from a chest, and died 3 times - and you could just trust them.<p>Your server costs would only need to be for the metaprogression&#x2F;persistence related stuff that could be done relatively infrequently based on updates from the client.</div><br/><div id="41422620" class="c"><input type="checkbox" id="c-41422620" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422406">parent</a><span>|</span><a href="#41422526">next</a><span>|</span><label class="collapse" for="c-41422620">[-]</label><label class="expand" for="c-41422620">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Exploring this in game worlds came up in a job interview a few years ago :)<p>ZK proofs are potentially a transformative tool for real-tine distributed systems in general, not just games. They potentially improve laency (&quot;ping&quot;), by changing the communication patterns in a distributed consensus system. That&#x27;s great for games and other real-time systems.</div><br/></div></div><div id="41422526" class="c"><input type="checkbox" id="c-41422526" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422406">parent</a><span>|</span><a href="#41422620">prev</a><span>|</span><a href="#41421310">next</a><span>|</span><label class="collapse" for="c-41422526">[-]</label><label class="expand" for="c-41422526">[1 more]</label></div><br/><div class="children"><div class="content">In theory that sounds awesome and I love the idea of ZKP. However, they have quite some overhead that defeats such applications, I think.</div><br/></div></div></div></div><div id="41421310" class="c"><input type="checkbox" id="c-41421310" checked=""/><div class="controls bullet"><span class="by">nowayno583</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41422406">prev</a><span>|</span><a href="#41421662">next</a><span>|</span><label class="collapse" for="c-41421310">[-]</label><label class="expand" for="c-41421310">[2 more]</label></div><br/><div class="children"><div class="content">Imagine you are Goldman Sachs and a client wants to make a 100mm USD wire transfer to one of their accounts at Citibank. How does citibank know that the account at GS has the money to cover this transfer?<p>Right now, the way this works is essentially through a lot of trust and some guarantees by the fed. This has some downsides: because you need a lot of confirmations, it makes transfers take longer. Also, small players can&#x27;t really get in on this system, so some regional banks are at a disadvantage.<p>How do you make this safer and more robust? GS obviously can&#x27;t send info on all of its clients accounts and balances to Citi. You could imagine a protocol where the client&#x2F;GS sends Citi a zkp to prove that the client has the money (as long as all inputs are agreed upon).<p>Of course, you don&#x27;t really need zkps. You could also have the fed keep a database on all money in all accounts (like they do in Brazil), so that the bank only has to ask the central bank to give you an ok. But that is a whole lot of power in the hands of a central authority, as well as a single point of failure, which is something banking systems should avoid imo</div><br/><div id="41422959" class="c"><input type="checkbox" id="c-41422959" checked=""/><div class="controls bullet"><span class="by">AmericanChopper</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41421310">parent</a><span>|</span><a href="#41421662">next</a><span>|</span><label class="collapse" for="c-41422959">[-]</label><label class="expand" for="c-41422959">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How does citibank know that the account at GS has the money to cover this transfer?<p>At the moment this is all handled with Swift, and I’m not sure you what you gain from adding ZKPs. Depending on the transaction you might send a Swift MT799 with a pre-advice letter, a proof of funds letter, or a blocked funds letter. Again depending on what you’re doing you might need a MT760 to send a bank guarantee or some sort of letter of credit, and finally a MT103 to initiate the actual transfer of funds.<p>At this point your counter party risk lies with the banking institution itself, and their willingness and ability to complete the transactions they have legally committed to, rather than the account holder, and this risk doesn’t go away with the addition of ZKPs.</div><br/></div></div></div></div><div id="41421662" class="c"><input type="checkbox" id="c-41421662" checked=""/><div class="controls bullet"><span class="by">badsandwitch</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41421310">prev</a><span>|</span><a href="#41422186">next</a><span>|</span><label class="collapse" for="c-41421662">[-]</label><label class="expand" for="c-41421662">[4 more]</label></div><br/><div class="children"><div class="content">It is currently possible to use ZKP&#x27;s to set up via a central authority a digital cash system where the bank notes are all anonymous and all transfers are anonymous.<p>The central authority in this scenario cannot discriminate between transactions - any function that would compare two or more transactions cannot glean any useful information that would allow to discriminate. And and security of the anonymity of past transactions will be reducible to the security of the cryptographic hash function used (the next best thing to Information-theoretic security). As for forging money, depending on what ZKP approach is used even a quantum computer will be insufficient.<p>The central authority can still print money and can obviously shut the entire system down.<p>It is interesting to ponder whether or not some government will decide to take such a step and surrender all control (except for the nuclear option) over how their currency is used. It will certainly boost demand for the currency.</div><br/><div id="41421991" class="c"><input type="checkbox" id="c-41421991" checked=""/><div class="controls bullet"><span class="by">ironSkillet</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41421662">parent</a><span>|</span><a href="#41422002">next</a><span>|</span><label class="collapse" for="c-41421991">[-]</label><label class="expand" for="c-41421991">[2 more]</label></div><br/><div class="children"><div class="content">Do you have any recommended references on this subject? Seems like this sort of system would be able to obfuscate a lot of metadata  that can be used to deanonymize activity. Very interesting.</div><br/><div id="41422346" class="c"><input type="checkbox" id="c-41422346" checked=""/><div class="controls bullet"><span class="by">badsandwitch</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41421991">parent</a><span>|</span><a href="#41422002">next</a><span>|</span><label class="collapse" for="c-41422346">[-]</label><label class="expand" for="c-41422346">[1 more]</label></div><br/><div class="children"><div class="content">Tornado Cash does this. And you can find articles on how it functions online. You can even read the smart contract that directly implements it.<p>Roughly: you have 2 secrets that you hash together and the central authority adds the result you disclosed to a list (either to print money or as part of a transaction to transfer money). To spend a note you reveal the hash of one of the secrets (to be added to a list of nullifiers to prevent double spend) and you do ZKP to demonstrate that you possess both of the secrets to *some* note from the public hash list and that the nullifier for that note is what you claim it is. Central authority rejects if nullifier is present in the list.<p>There are some other approaches to such a system, I believe the Tornado Cash one is the most elegant though it limits you to a discrete number of note denominations.<p>Note that the proof system Tornado Cash uses is not secure to a quantum computer and such a device will allow to &quot;print money&quot; - in reality, drain the smart contract.</div><br/></div></div></div></div></div></div><div id="41422186" class="c"><input type="checkbox" id="c-41422186" checked=""/><div class="controls bullet"><span class="by">shriphani</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41421662">prev</a><span>|</span><a href="#41421433">next</a><span>|</span><label class="collapse" for="c-41422186">[-]</label><label class="expand" for="c-41422186">[5 more]</label></div><br/><div class="children"><div class="content">Examples of things you can do with ZKPs:<p>- Anonymous credentials (this is what Signal does) - maintain an encrypted blob representing a group chat (members list etc all stay encrypted and Signal cannot tell who is in a group chat). A normal client can provide a zkp that they are in a particular group chat (the decrypted blob contains this member for example) and have a message delivered to other group members. Both the client and the recipient can keep their identities encrypted and the zkp proves the membership of the plaintext client &#x2F; recipient.<p>- Encrypt some metadata of a message sent to someone. You can build a ZKP that the plaintext behind the encrypted metadata satsifies some properties such as recipient is not in some blacklist (and so on). All this can be done by maintaining privacy because the metadata stays encrypted.<p>- Given an electronic medical record, you can prove that the record contains a vaccine without sending the record over the wire to some other party.<p>Lots more such ideas exist.<p>zkVMs are a good place to start playing with things.</div><br/><div id="41422211" class="c"><input type="checkbox" id="c-41422211" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422186">parent</a><span>|</span><a href="#41421433">next</a><span>|</span><label class="collapse" for="c-41422211">[-]</label><label class="expand" for="c-41422211">[4 more]</label></div><br/><div class="children"><div class="content">in your first example, how does Signal route messages in that model?</div><br/><div id="41422222" class="c"><input type="checkbox" id="c-41422222" checked=""/><div class="controls bullet"><span class="by">shriphani</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422211">parent</a><span>|</span><a href="#41421433">next</a><span>|</span><label class="collapse" for="c-41422222">[-]</label><label class="expand" for="c-41422222">[3 more]</label></div><br/><div class="children"><div class="content">sender specifies recipient but the signal server cannot tell a group-chat message from a non-group chat message.</div><br/><div id="41422902" class="c"><input type="checkbox" id="c-41422902" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422222">parent</a><span>|</span><a href="#41421433">next</a><span>|</span><label class="collapse" for="c-41422902">[-]</label><label class="expand" for="c-41422902">[2 more]</label></div><br/><div class="children"><div class="content">so in this world signal still knows I&#x27;m sending to N recipients? Or is the fanout happening in a different way?<p>I guess I&#x27;m wondering if Signal still basically has enough info to make good guesses at group existence.</div><br/><div id="41423059" class="c"><input type="checkbox" id="c-41423059" checked=""/><div class="controls bullet"><span class="by">shriphani</span><span>|</span><a href="#41421044">root</a><span>|</span><a href="#41422902">parent</a><span>|</span><a href="#41421433">next</a><span>|</span><label class="collapse" for="c-41423059">[-]</label><label class="expand" for="c-41423059">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think you are correct that the protocol isn&#x27;t safe from traffic analysis.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41421433" class="c"><input type="checkbox" id="c-41421433" checked=""/><div class="controls bullet"><span class="by">rtg4869</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41422186">prev</a><span>|</span><a href="#41421135">next</a><span>|</span><label class="collapse" for="c-41421433">[-]</label><label class="expand" for="c-41421433">[1 more]</label></div><br/><div class="children"><div class="content">This is a great explainer from one of the pioneers in this space, in case you weren&#x27;t already familiar with it: <a href="https:&#x2F;&#x2F;www.wired.com&#x2F;video&#x2F;watch&#x2F;5-levels-zero-knowledge-proof" rel="nofollow">https:&#x2F;&#x2F;www.wired.com&#x2F;video&#x2F;watch&#x2F;5-levels-zero-knowledge-pr...</a></div><br/></div></div><div id="41421135" class="c"><input type="checkbox" id="c-41421135" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41421433">prev</a><span>|</span><a href="#41421100">next</a><span>|</span><label class="collapse" for="c-41421135">[-]</label><label class="expand" for="c-41421135">[1 more]</label></div><br/><div class="children"><div class="content">“I do understand the basic principle of ZKPs, but as yet I’m failing to understand…”<p>Sounds you indeed have zero knowledge of zero-knowledge proofs. Congratulations!<p>If you want, I could prove to you that I know what zero-knowledge proofs are and how they’d be applied in industry, but you’d be no closer to understanding it. I would do it in a specific way that would basically impart zero knowledge to you, beyond the fact that I know what I’m talking about. Interested? :)</div><br/></div></div><div id="41421100" class="c"><input type="checkbox" id="c-41421100" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#41421044">parent</a><span>|</span><a href="#41421135">prev</a><span>|</span><a href="#41421237">next</a><span>|</span><label class="collapse" for="c-41421100">[-]</label><label class="expand" for="c-41421100">[1 more]</label></div><br/><div class="children"><div class="content">ZKPs are used for private balances in Solana. Someone can send you a million PYUSD using confidential transfers and your public balance remains 100 dollars.</div><br/></div></div></div></div><div id="41421237" class="c"><input type="checkbox" id="c-41421237" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#41421044">prev</a><span>|</span><a href="#41423150">next</a><span>|</span><label class="collapse" for="c-41421237">[-]</label><label class="expand" for="c-41421237">[4 more]</label></div><br/><div class="children"><div class="content">Another demonstration of Zero-Knowledge Proofs:<p>A paper-tech protocol for validating Sudoku solutions without revealing the solution:<p><a href="https:&#x2F;&#x2F;zudoku.xyz&#x2F;" rel="nofollow">https:&#x2F;&#x2F;zudoku.xyz&#x2F;</a></div><br/><div id="41423127" class="c"><input type="checkbox" id="c-41423127" checked=""/><div class="controls bullet"><span class="by">patrulek</span><span>|</span><a href="#41421237">parent</a><span>|</span><a href="#41421407">next</a><span>|</span><label class="collapse" for="c-41423127">[-]</label><label class="expand" for="c-41423127">[2 more]</label></div><br/><div class="children"><div class="content">So with ZK-proofs we may never be 100% sure something is true or not? Is it possible that this may be too computational expensive to have certainty at given (or above) level?</div><br/><div id="41423718" class="c"><input type="checkbox" id="c-41423718" checked=""/><div class="controls bullet"><span class="by">plopilop</span><span>|</span><a href="#41421237">root</a><span>|</span><a href="#41423127">parent</a><span>|</span><a href="#41421407">next</a><span>|</span><label class="collapse" for="c-41423718">[-]</label><label class="expand" for="c-41423718">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t necessary get 100% certainty but the probability of success increases exponentially with each new run.<p>Thus you can get very fast to a probability smaller than you quantum tunnelling through a wall</div><br/></div></div></div></div><div id="41421407" class="c"><input type="checkbox" id="c-41421407" checked=""/><div class="controls bullet"><span class="by">saboot</span><span>|</span><a href="#41421237">parent</a><span>|</span><a href="#41423127">prev</a><span>|</span><a href="#41423150">next</a><span>|</span><label class="collapse" for="c-41421407">[-]</label><label class="expand" for="c-41421407">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very cool! Here&#x27;s another cool application for nuclear arms control,
<a href="https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;nature13457" rel="nofollow">https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;nature13457</a></div><br/></div></div></div></div><div id="41423150" class="c"><input type="checkbox" id="c-41423150" checked=""/><div class="controls bullet"><span class="by">jmakov</span><span>|</span><a href="#41421237">prev</a><span>|</span><a href="#41423038">next</a><span>|</span><label class="collapse" for="c-41423150">[-]</label><label class="expand" for="c-41423150">[2 more]</label></div><br/><div class="children"><div class="content">Can I prove that I&#x27;m a part of an org and use this as SSO?</div><br/><div id="41423183" class="c"><input type="checkbox" id="c-41423183" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41423150">parent</a><span>|</span><a href="#41423038">next</a><span>|</span><label class="collapse" for="c-41423183">[-]</label><label class="expand" for="c-41423183">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but in that specific example you could also simply use a signature, as the fact that you are part of a single org reveals all information.<p>If you were part of multiple orgs and just want to prove you&#x27;re part of any of them without revealing which in particular, then a ZKP can help.</div><br/></div></div></div></div><div id="41423038" class="c"><input type="checkbox" id="c-41423038" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#41423150">prev</a><span>|</span><a href="#41421539">next</a><span>|</span><label class="collapse" for="c-41423038">[-]</label><label class="expand" for="c-41423038">[2 more]</label></div><br/><div class="children"><div class="content">What does everyone think about the &#x27;trusted&#x27; setup part of zero-knowledge proofs? Is this a deal breaker for some use-cases or can this phase be done without worrying that the entire process has been hijacked... As has been a core goal of many ah... &#x27;security&#x27; councils in the past.</div><br/><div id="41423394" class="c"><input type="checkbox" id="c-41423394" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#41423038">parent</a><span>|</span><a href="#41421539">next</a><span>|</span><label class="collapse" for="c-41423394">[-]</label><label class="expand" for="c-41423394">[1 more]</label></div><br/><div class="children"><div class="content">Only some kinds of ZKPs have that drawback; others don’t. There are many examples of such systems with transparent setup that are used in practice.<p>Even for some ZKP scheme that <i>do</i> require trusted setup, you can perform the setup in a multi-party way that allows anybody to contribute randomness, and as long as even one person is honest, the whole thing is private.</div><br/></div></div></div></div><div id="41421539" class="c"><input type="checkbox" id="c-41421539" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41423038">prev</a><span>|</span><a href="#41421090">next</a><span>|</span><label class="collapse" for="c-41421539">[-]</label><label class="expand" for="c-41421539">[5 more]</label></div><br/><div class="children"><div class="content">Are there any real uses of ZKP outside of blockcrap?</div><br/><div id="41421555" class="c"><input type="checkbox" id="c-41421555" checked=""/><div class="controls bullet"><span class="by">knowaveragejoe</span><span>|</span><a href="#41421539">parent</a><span>|</span><a href="#41421090">next</a><span>|</span><label class="collapse" for="c-41421555">[-]</label><label class="expand" for="c-41421555">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s several already shown in the comments.</div><br/><div id="41422220" class="c"><input type="checkbox" id="c-41422220" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41421539">root</a><span>|</span><a href="#41421555">parent</a><span>|</span><a href="#41421090">next</a><span>|</span><label class="collapse" for="c-41422220">[-]</label><label class="expand" for="c-41422220">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m asking about real actual examples, not handwaving.</div><br/><div id="41422287" class="c"><input type="checkbox" id="c-41422287" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41421539">root</a><span>|</span><a href="#41422220">parent</a><span>|</span><a href="#41423017">next</a><span>|</span><label class="collapse" for="c-41422287">[-]</label><label class="expand" for="c-41422287">[1 more]</label></div><br/><div class="children"><div class="content">They are useful from a mathematical point of view.  (And explore the relationship between P and NP, for example.)  Not sure if that counts as a &#x27;real use&#x27; to you.  See also <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PCP_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PCP_theorem</a><p>At the moment, producing a zero knowledge proof has roughly a million-fold overhead compared to running a program directly.  So there aren&#x27;t many applications where that&#x27;s acceptable.  So I am very grateful that the blockchain people are more than happy to throw money at the math here.  Very generous of them.<p>In principle, you can use ZKP for privacy preserving compliance work in real (ie traditional) finance.<p>To quote myself (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41422250">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41422250</a>):<p>&gt; Eg Goldman Sachs could encode all their compliance rules in a program, and publish a proof that their books pass the check by that program, without revealing anything about their accounting.<p>&gt; In a banking context, you could in theory also run your know-your-customer (KYC) rules against customer provided data, store the proof, and delete the original data. That way, you still have proof that your customers don&#x27;t have ties to North Korea or Russia, but you can&#x27;t be compelled by anyone to reveal the data later (nor accidentally leak that data, etc).<p>&gt; Of course, for that latter application, you need a sharp lawyer to make sure that storing the proof instead of the original data is enough for your KYC obligations.<p>&gt; If you want to go further, you could have your customers run the KYC rules locally, so that their data never leaves their premises.<p>&gt; (For all these applications, you still have to have a mechanism that connects the real world to the inputs of the programs whose execution you are proving.<p>&gt; So eg Goldman Sachs would still need an auditor that checks that the assets and obligations they have in their balance sheet actually exist, but the auditor does not otherwise need to make judgement calls or apply any rules.)</div><br/></div></div><div id="41423017" class="c"><input type="checkbox" id="c-41423017" checked=""/><div class="controls bullet"><span class="by">knowaveragejoe</span><span>|</span><a href="#41421539">root</a><span>|</span><a href="#41422220">parent</a><span>|</span><a href="#41422287">prev</a><span>|</span><a href="#41421090">next</a><span>|</span><label class="collapse" for="c-41423017">[-]</label><label class="expand" for="c-41423017">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused, did you read the other comments?</div><br/></div></div></div></div></div></div></div></div><div id="41421090" class="c"><input type="checkbox" id="c-41421090" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#41421539">prev</a><span>|</span><label class="collapse" for="c-41421090">[-]</label><label class="expand" for="c-41421090">[18 more]</label></div><br/><div class="children"><div class="content">&gt; We can take a digital identity card and prove that we are over 18 years old
&gt; Without revealing anything else, like your full name or address<p>If you are in this articles audience you would simply state the producer of the ID card signs a statement that the person is over 18. No ZKP needed.<p>The article like many others would be improved with a better example.</div><br/><div id="41421825" class="c"><input type="checkbox" id="c-41421825" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#41421090">parent</a><span>|</span><a href="#41422267">next</a><span>|</span><label class="collapse" for="c-41421825">[-]</label><label class="expand" for="c-41421825">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think a simple signature is sufficient if you want to maintain privacy with both the party you are trying to convince that you are over 18 <i>and</i> the party that signs the statement saying you are over 18.<p>If the signer keeps a copy of the signature and who they made it for, someone who gets a hold of that and the records of party you used the signature at they can find out who you are.<p>There are ZKP based protocols that allow for age verification where even if the party that attests to you age keeps records they do not find out where you are using that attestation, and the party you use the attesting with only finds out that you are above their age threshold and what attesting party you used.<p>I think that this can be done without ZKP if instead of simple signatures we use blind signatures.</div><br/></div></div><div id="41422267" class="c"><input type="checkbox" id="c-41422267" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41421090">parent</a><span>|</span><a href="#41421825">prev</a><span>|</span><a href="#41421166">next</a><span>|</span><label class="collapse" for="c-41422267">[-]</label><label class="expand" for="c-41422267">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you are in this articles audience you would simply state the producer of the ID card signs a statement that the person is over 18. No ZKP needed.<p>&gt; The article like many others would be improved with a better example.<p>It&#x27;s easy to make this example better:<p>Assume there are 50 different providers of ID cards, and Alice wants to convince Bob that she&#x27;s over 18 years old.<p>Bob trusts all 50 issuers, but Alice doesn&#x27;t want to reveal who her issuer is.<p>So here Alice could indeed get the supplier of her ID card to sign such a statement (and perhaps already have one prepared).  For ZKP, you can also assume that the ID card issuers are not co-operating (nor do they care about each other), and that different Bobs might trust different sets of providers, and that the sets of trusted providers might change over time.</div><br/></div></div><div id="41421166" class="c"><input type="checkbox" id="c-41421166" checked=""/><div class="controls bullet"><span class="by">JanisErdmanis</span><span>|</span><a href="#41421090">parent</a><span>|</span><a href="#41422267">prev</a><span>|</span><a href="#41423093">next</a><span>|</span><label class="collapse" for="c-41421166">[-]</label><label class="expand" for="c-41421166">[3 more]</label></div><br/><div class="children"><div class="content">I am also puzzled by this example of utility. It would be easy for the identity provider to separately sign all properties, assign each a unique identifier, and then return them to the users to use the signed identity properties as needed.</div><br/><div id="41422278" class="c"><input type="checkbox" id="c-41422278" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421166">parent</a><span>|</span><a href="#41422284">next</a><span>|</span><label class="collapse" for="c-41422278">[-]</label><label class="expand" for="c-41422278">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though with ZKP you could prove arbitrary logic on the properties, even those that the provider didn&#x27;t think of nor wants to support.<p>Eg you could prove that &#x27;either your age is a prime number or that you have green eyes and live in New York&#x27;.</div><br/></div></div><div id="41422284" class="c"><input type="checkbox" id="c-41422284" checked=""/><div class="controls bullet"><span class="by">A1kmm</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421166">parent</a><span>|</span><a href="#41422278">prev</a><span>|</span><a href="#41423093">next</a><span>|</span><label class="collapse" for="c-41422284">[-]</label><label class="expand" for="c-41422284">[1 more]</label></div><br/><div class="children"><div class="content">So the problem could be expressed as:<p>* The actors are: Individuals I_1, ..., I_n, businesses B_1, ..., B_m, and a central authority A.<p>* An individual I_j wants to prove to business B_k that A attests that DateOfBirth(I_j) &gt;= 20060902, and that I_j is in possession of a private key, where A attests that it has verified the linkage of the corresponding public key to I_j.<p>* I_j doesn&#x27;t want to provide any information about I_j&#x27;s identity except for the DateOfBirth(I_j) &gt;= 20060902 to B_k. That means, for example, I_j doesn&#x27;t want to reveal to B_k their ordinal j, nor a single public key that is used everywhere. This means, for example, B_k shouldn&#x27;t be able to collude with B_{k+1} to combine facts separately provided to the two businesses and build a profile of I_j.<p>* I_j also doesn&#x27;t want A to be able to collect information about the fact they provided information to B_k specifically.<p>With a ZKP, it is possible for a solution like:<p>* I_j generates a keypair P_1 (private) &#x2F; p_1 (public) and proves their identity out-of-band to A. A gives them a certificate C_1 typing p_1 to their ordinal j and their date of birth.<p>* I_j generates a new keypair P_2&#x2F;p_2 just for dealing with B_k.<p>* I_j generates a signed certificate C_2 using P_1, tying p_2 to their ordinal j.<p>* I_j generates a ZKP that there exists a (private input) certificate C_1 signed by A&#x27;s public key, and that certificate meets the constraint DateOfBirth(I_j) &gt;= 20060902, and there exists a (private input) public key p_1 which is referenced in C_1, and there exists a (private input) certificate C_2 signed by p_1, and that certificate references (public input) public key p_2, and sends the ZKP to B_k.<p>Now instead you could imagine a solution where A generates certificates for I_j, but that has some downsides:<p>* The properties to be signed might vary over time. The date of birth cutoff certainly would, and different businesses might want different properties.<p>* Just one certificate per property isn&#x27;t enough, because the certificate identifies which public key it relates to. That allows B_k and B_{k+1} to work out they have the same customer I_j. With the ZKP solution, the customer gives a different public key to each. You could work around this by having A provide lots of certificates upfront (inefficient), or by generating certificates on demand (but the A is needed to be involved online in the transaction, and it risks leaking information to A).<p>So the ZKP solution is, in many ways, simpler in that it removes a lot of constraints while implementing the desired properties, but there are other workarounds if you don&#x27;t have it.</div><br/></div></div></div></div><div id="41423093" class="c"><input type="checkbox" id="c-41423093" checked=""/><div class="controls bullet"><span class="by">piotr93</span><span>|</span><a href="#41421090">parent</a><span>|</span><a href="#41421166">prev</a><span>|</span><a href="#41421115">next</a><span>|</span><label class="collapse" for="c-41423093">[-]</label><label class="expand" for="c-41423093">[3 more]</label></div><br/><div class="children"><div class="content">A signature is a zkp. So your example is also a good example :)</div><br/><div id="41423196" class="c"><input type="checkbox" id="c-41423196" checked=""/><div class="controls bullet"><span class="by">somezero</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41423093">parent</a><span>|</span><a href="#41421115">next</a><span>|</span><label class="collapse" for="c-41423196">[-]</label><label class="expand" for="c-41423196">[2 more]</label></div><br/><div class="children"><div class="content">A signature is a PoK, but not ZK.</div><br/></div></div></div></div><div id="41421115" class="c"><input type="checkbox" id="c-41421115" checked=""/><div class="controls bullet"><span class="by">gchaincl</span><span>|</span><a href="#41421090">parent</a><span>|</span><a href="#41423093">prev</a><span>|</span><label class="collapse" for="c-41421115">[-]</label><label class="expand" for="c-41421115">[9 more]</label></div><br/><div class="children"><div class="content">I think the goal of this is that you can prove, so that your counter party does not need to rely on trust</div><br/><div id="41421200" class="c"><input type="checkbox" id="c-41421200" checked=""/><div class="controls bullet"><span class="by">rvrs</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421115">parent</a><span>|</span><label class="collapse" for="c-41421200">[-]</label><label class="expand" for="c-41421200">[8 more]</label></div><br/><div class="children"><div class="content">there are standards for &quot;verifiable credentials&quot; and &quot;verifiable presentations&quot; so that digital IDs can be issued and displayed (using a model analogous to web pki&#x2F;SSL certs), done in a decentralized and privacy-preserving way without ZKPs</div><br/><div id="41421297" class="c"><input type="checkbox" id="c-41421297" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421200">parent</a><span>|</span><label class="collapse" for="c-41421297">[-]</label><label class="expand" for="c-41421297">[7 more]</label></div><br/><div class="children"><div class="content"><i>Actually</i> this is only partially true (have implemented verifiable credientials and ZK on top).<p>VCs will allow you to verifiably specify your date of birth or maybe your passport number.<p>What ZK does is allows a third party to ask questions like &quot;is the date of birth of this person prior to 2-Sep-2006&quot; (ie, are they over 18) or &quot;is this person a passport holder for country X&quot; and the ZKP system can say yes or no without disclosing the actual birthdate or the passport number.<p>It&#x27;s is a real improvement in privacy, although I&#x27;m unconvinced it is worth the incredible inconvenience of implementing it.</div><br/><div id="41421576" class="c"><input type="checkbox" id="c-41421576" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421297">parent</a><span>|</span><a href="#41421505">next</a><span>|</span><label class="collapse" for="c-41421576">[-]</label><label class="expand" for="c-41421576">[4 more]</label></div><br/><div class="children"><div class="content">&gt; without disclosing the actual birthdate<p>What prevents the birthdate from being gleaned through a simple binary search? Or, if it&#x27;s specifically an &quot;over 18 today?&quot; query based on some decentralized timestamp source, what prevents the query from just being repeated every day until the result changes (assuming it returns &quot;under 18&quot; at first)?</div><br/><div id="41421726" class="c"><input type="checkbox" id="c-41421726" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421576">parent</a><span>|</span><a href="#41421700">next</a><span>|</span><label class="collapse" for="c-41421726">[-]</label><label class="expand" for="c-41421726">[1 more]</label></div><br/><div class="children"><div class="content">Just because someone asks, doesn&#x27;t mean one must answer.<p>&quot;Be liberal in what you receive, and strict in what you send.&quot;<p>The protocol would have to specify an authorized inquiry field or use validity by time, using a global consensus (current bitcoin block + challenges that take bitcoin_blocks block production rate on average to solve)</div><br/></div></div><div id="41421700" class="c"><input type="checkbox" id="c-41421700" checked=""/><div class="controls bullet"><span class="by">rvrs</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421576">parent</a><span>|</span><a href="#41421726">prev</a><span>|</span><a href="#41421505">next</a><span>|</span><label class="collapse" for="c-41421700">[-]</label><label class="expand" for="c-41421700">[2 more]</label></div><br/><div class="children"><div class="content">The holder of the credential would have to present it log(N) times. If someone asks to scan your id a bunch of times, wouldn&#x27;t you find it suspicious?</div><br/><div id="41422743" class="c"><input type="checkbox" id="c-41422743" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421700">parent</a><span>|</span><a href="#41421505">next</a><span>|</span><label class="collapse" for="c-41422743">[-]</label><label class="expand" for="c-41422743">[1 more]</label></div><br/><div class="children"><div class="content">Different &#x27;someone&#x27;s could conceivably collude to whittle down the result of the search, fingerprinting users via separate means to align the results. Or, less conspiratorially, one could present an apparently-poorly-designed interface where the credential is only valid for the current login session, then wait for a few cycles of the user clearing their browser cookies.<p>Perhaps a very explicit prompt &quot;This service wants to know if you&#x27;re &gt; <i>X</i> years old!&quot; might give up the trick, but then users would have to be trained not to click through it within milliseconds, which is never the most viable solution.</div><br/></div></div></div></div></div></div><div id="41421505" class="c"><input type="checkbox" id="c-41421505" checked=""/><div class="controls bullet"><span class="by">rvrs</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421297">parent</a><span>|</span><a href="#41421576">prev</a><span>|</span><label class="collapse" for="c-41421505">[-]</label><label class="expand" for="c-41421505">[2 more]</label></div><br/><div class="children"><div class="content">Neat, thanks! IIUC some credential standards like ISO 18013-5 (mDL) hack around this by allowing you to expose `is_over_X` claims for age gating<p>What did you implement VCs and ZK for?</div><br/><div id="41422572" class="c"><input type="checkbox" id="c-41422572" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#41421090">root</a><span>|</span><a href="#41421505">parent</a><span>|</span><label class="collapse" for="c-41422572">[-]</label><label class="expand" for="c-41422572">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What did you implement VCs and ZK for?<p>It was a crypto&#x2F;blockchain&#x2F;decentralized ID thing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>