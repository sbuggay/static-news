<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725267676795" as="style"/><link rel="stylesheet" href="styles.css?v=1725267676795"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xata.io/blog/postgres-webhooks-with-pgstream">Postgres Webhooks with Pgstream</a> <span class="domain">(<a href="https://xata.io">xata.io</a>)</span></div><div class="subtext"><span>mebcitto</span> | <span>17 comments</span></div><br/><div><div id="41419737" class="c"><input type="checkbox" id="c-41419737" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41419851">next</a><span>|</span><label class="collapse" for="c-41419737">[-]</label><label class="expand" for="c-41419737">[1 more]</label></div><br/><div class="children"><div class="content">The GitHub repo README gives a better sense of the capabilities of the pgstream system: <a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream?tab=readme-ov-file#architecture">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream?tab=readme-ov-file#archit...</a><p>For deployments at a more serious scale, it seems they support buffering WAL events into Kafka, similar to Debezium (the current leader for change data capture), to de-couple the replication slot reader on the Postgres side throughput from the event handlers you deliver the events to.<p>Pgstream seems more batteries-included compared to using Debezium to consume the PG log; Kafka is optional with pgstream and things like webhook delivery and OpenSearch indexing are packaged in, rather than being a “choose your own adventure” game with Kafka Streams middleware ecosystem jungle. If their offerings constraints work for your use-case, why not prefer it over Debezium since it seems easier? I’d rather write Go than Java&#x2F;JVM-language if I need to plug into the pipeline.<p>However at any sort of serious scale you’ll need the Kafka in there, and then I’m less sure you’d make use of the other plug and play stuff like the OpenSearch indexer or webhooks at all. Certainly as volume grows webhooks start to feel like a bad fit for CDC events at the level of a single row change; at least in my brief Debezium CDC experience, my consumer pulls batches of 1000+ changes at once from Kafka.<p>The other thing I don’t see is transaction metadata, maybe I shouldn’t worry much about it (not many people seem to be concerned) but I’d like my downstream consumer to have delayed consistency with my Postgres upstream, which means I need to consume record changes with the same transactional grouping as in Postgres, otherwise I’ll probably never be consistent in practice: <a href="https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;internal-consistency-in-streaming-systems&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;internal-consiste...</a></div><br/></div></div><div id="41419851" class="c"><input type="checkbox" id="c-41419851" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41419737">prev</a><span>|</span><a href="#41420284">next</a><span>|</span><label class="collapse" for="c-41419851">[-]</label><label class="expand" for="c-41419851">[8 more]</label></div><br/><div class="children"><div class="content">Implementing webhook deliveries is one of those things that&#x27;s way harder than you would initially imagine. The two things I always look for in systems like this are:<p>1. Can it handle deliveries to slow on unreliable endpoints? In particular, what happens if the external server is deliberately slow to respond - someone could be trying to crash your system by forcing it to deliver to slow-loading endpoints.<p>2. How are retries handled? If the server returns a 500, a good webhooks system will queue things up for re-delivery with an exponential backoff and try a few more times before giving up completely.<p>Point 1. only matters if you are delivering webhooks to untrusted endpoints - systems like GitHub where anyone can sign up for hook deliveries.<p>2. is more important.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351cf206c3de6843c079193e&#x2F;pkg&#x2F;wal&#x2F;processor&#x2F;webhook&#x2F;notifier&#x2F;webhook_notifier.go#L49-L51">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351c...</a> shows that the HTTP client can be configured with a timeout (which defaults to 10s <a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351cf206c3de6843c079193e&#x2F;pkg&#x2F;wal&#x2F;processor&#x2F;webhook&#x2F;notifier&#x2F;config.go#L22C26-L22C28">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351c...</a> )<p>From looking at <a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351cf206c3de6843c079193e&#x2F;pkg&#x2F;wal&#x2F;processor&#x2F;webhook&#x2F;notifier&#x2F;webhook_notifier.go#L182-L193">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351c...</a> it doesn&#x27;t look like this system handles retries.<p>Retrying would definitely be a useful addition. PostgreSQL is a great persistence store for recording failures and retry attempts, so that feature would be a good fit for this system.</div><br/><div id="41421189" class="c"><input type="checkbox" id="c-41421189" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#41419851">parent</a><span>|</span><a href="#41420518">next</a><span>|</span><label class="collapse" for="c-41421189">[-]</label><label class="expand" for="c-41421189">[3 more]</label></div><br/><div class="children"><div class="content">I think retries are sketchy. Sometimes they really are necessary, but sometimes the API can be designed around at-most-once semantics.<p>Even with a retry scheme, unless you are willing to retry indefinitely, there is always the problem of missed events to handle. If you need to handle this anyway, it might as well use this assumption to simplify the process and not attempt retries at all.<p>From a reliability perspective, it is hard to monitor whether the delivery is working if there is a variable event rate. Instead, designing it to have a synchronous endpoint the web hook server can call periodically to “catch up” has better reliability properties. Incidentally, this scheme handles at-most-once semantics pretty well, because the server can periodically catch up on all missed events.</div><br/><div id="41421469" class="c"><input type="checkbox" id="c-41421469" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41419851">root</a><span>|</span><a href="#41421189">parent</a><span>|</span><a href="#41420518">next</a><span>|</span><label class="collapse" for="c-41421469">[-]</label><label class="expand" for="c-41421469">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good call: having a &quot;catch me up&quot; API you can poll is a very robust way of dealing with missed events.<p>Implementing robust retries is a huge favor you can do for your clients though: knowing that they&#x27;ll get every event delivered eventually provided they return 200 codes for accepted events and error codes for everything else can massively simplify the code they need to write.</div><br/><div id="41423685" class="c"><input type="checkbox" id="c-41423685" checked=""/><div class="controls bullet"><span class="by">eminano</span><span>|</span><a href="#41419851">root</a><span>|</span><a href="#41421469">parent</a><span>|</span><a href="#41420518">next</a><span>|</span><label class="collapse" for="c-41423685">[-]</label><label class="expand" for="c-41423685">[1 more]</label></div><br/><div class="children"><div class="content">Hi there! I&#x27;m one of the authors of the pgstream project and found this thread very interesting.<p>I completely agree, retry handling can become critical when the application relies on all events being eventually delivered. I have created an issue in the repo (<a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;issues&#x2F;67">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;issues&#x2F;67</a>) to add support for notification retries.<p>Thanks for everyone&#x27;s feedback, it&#x27;s been very helpful!</div><br/></div></div></div></div></div></div><div id="41420518" class="c"><input type="checkbox" id="c-41420518" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41419851">parent</a><span>|</span><a href="#41421189">prev</a><span>|</span><a href="#41419898">next</a><span>|</span><label class="collapse" for="c-41420518">[-]</label><label class="expand" for="c-41420518">[2 more]</label></div><br/><div class="children"><div class="content">&gt;a good webhooks system will queue things up for re-delivery with an exponential backoff and try a few more times before giving up completely.<p>Microsoft&#x27;s Graph API also requires consumers to re-register webhooks every N days, a kind of &quot;heartbeat&quot; to make sure the webhooks aren&#x27;t sent to a dead server forever.</div><br/><div id="41423786" class="c"><input type="checkbox" id="c-41423786" checked=""/><div class="controls bullet"><span class="by">eminano</span><span>|</span><a href="#41419851">root</a><span>|</span><a href="#41420518">parent</a><span>|</span><a href="#41419898">next</a><span>|</span><label class="collapse" for="c-41423786">[-]</label><label class="expand" for="c-41423786">[1 more]</label></div><br/><div class="children"><div class="content">This is definitely an interesting idea. Pgstream does offer the ability to unsubscribe from the notifications (<a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;main&#x2F;pkg&#x2F;wal&#x2F;processor&#x2F;webhook&#x2F;subscription&#x2F;server&#x2F;subscription_server.go#L43">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;main&#x2F;pkg&#x2F;wal&#x2F;process...</a>), but it relies on the receiver actively making that request.<p>It can be annoying to have to re-subscribe every N days when your application is working as expected though. I wonder if one way to work around this could be to &quot;blacklist&quot; servers that have failed consistently for an amount of time. They could be deleted from the subscriptions table if they remain inactive once they&#x27;ve been blacklisted.<p>I have opened an issue in the repo to track this (<a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;issues&#x2F;68">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;issues&#x2F;68</a>), since it would be a critical feature to avoid denial-of-service attacks.<p>Thanks for your feedback!</div><br/></div></div></div></div><div id="41419898" class="c"><input type="checkbox" id="c-41419898" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#41419851">parent</a><span>|</span><a href="#41420518">prev</a><span>|</span><a href="#41420298">next</a><span>|</span><label class="collapse" for="c-41419898">[-]</label><label class="expand" for="c-41419898">[1 more]</label></div><br/><div class="children"><div class="content">Really any time you&#x27;re using a distributed system, you should ask yourself, do I need retries? Do I need circuit breakers? Do I need rate limits?<p>The answers are probably either &quot;yes&quot; or &quot;yes, but not yet.&quot;</div><br/></div></div><div id="41420298" class="c"><input type="checkbox" id="c-41420298" checked=""/><div class="controls bullet"><span class="by">tasn</span><span>|</span><a href="#41419851">parent</a><span>|</span><a href="#41419898">prev</a><span>|</span><a href="#41420284">next</a><span>|</span><label class="collapse" for="c-41420298">[-]</label><label class="expand" for="c-41420298">[1 more]</label></div><br/><div class="children"><div class="content">They should defo use Svix[1], I&#x27;ll reach out to the blog author, this looks like a cool blog post and use-case.<p>1: <a href="https:&#x2F;&#x2F;www.svix.com">https:&#x2F;&#x2F;www.svix.com</a></div><br/></div></div></div></div><div id="41420284" class="c"><input type="checkbox" id="c-41420284" checked=""/><div class="controls bullet"><span class="by">tazu</span><span>|</span><a href="#41419851">prev</a><span>|</span><a href="#41419753">next</a><span>|</span><label class="collapse" for="c-41420284">[-]</label><label class="expand" for="c-41420284">[2 more]</label></div><br/><div class="children"><div class="content">Curious if there&#x27;s a reason this extension is written in Go and not Zig? The blog posted [1] a few months ago about their cool Zig library for making extensions and I&#x27;ve been playing around with it. Is Zig just not mature enough?<p>[1]: <a href="https:&#x2F;&#x2F;xata.io&#x2F;blog&#x2F;introducing-pgzx" rel="nofollow">https:&#x2F;&#x2F;xata.io&#x2F;blog&#x2F;introducing-pgzx</a></div><br/><div id="41421070" class="c"><input type="checkbox" id="c-41421070" checked=""/><div class="controls bullet"><span class="by">gobblegobble2</span><span>|</span><a href="#41420284">parent</a><span>|</span><a href="#41419753">next</a><span>|</span><label class="collapse" for="c-41421070">[-]</label><label class="expand" for="c-41421070">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an extension. It&#x27;s a standalone app that connects to postgres and listens to a replication stream.</div><br/></div></div></div></div><div id="41419753" class="c"><input type="checkbox" id="c-41419753" checked=""/><div class="controls bullet"><span class="by">adamcharnock</span><span>|</span><a href="#41420284">prev</a><span>|</span><a href="#41420010">next</a><span>|</span><label class="collapse" for="c-41419753">[-]</label><label class="expand" for="c-41419753">[3 more]</label></div><br/><div class="children"><div class="content">A quick google didn’t reveal much about pgstream’s delivery semantics. Do these webhooks get called at most once, or at least once? I hope the latter, but in absence of information I’d guess it is the former.</div><br/><div id="41419830" class="c"><input type="checkbox" id="c-41419830" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41419753">parent</a><span>|</span><a href="#41420010">next</a><span>|</span><label class="collapse" for="c-41419830">[-]</label><label class="expand" for="c-41419830">[2 more]</label></div><br/><div class="children"><div class="content">It looks to me like it&#x27;s at-most-once. This code here <a href="https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351cf206c3de6843c079193e&#x2F;pkg&#x2F;wal&#x2F;processor&#x2F;webhook&#x2F;notifier&#x2F;webhook_notifier.go#L182-L193">https:&#x2F;&#x2F;github.com&#x2F;xataio&#x2F;pgstream&#x2F;blob&#x2F;bab0a8e665d37441351c...</a> logs an error if a delivery fails but does not appear to queue it for a second attempt.</div><br/><div id="41419844" class="c"><input type="checkbox" id="c-41419844" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41419753">root</a><span>|</span><a href="#41419830">parent</a><span>|</span><a href="#41420010">next</a><span>|</span><label class="collapse" for="c-41419844">[-]</label><label class="expand" for="c-41419844">[1 more]</label></div><br/><div class="children"><div class="content">Sad! Suitable for driving “best effort” use cases like reactive UI updates or stale-while-revalidate cache refreshes, but not usable for “business logic” like updating user access lists, billing, sending emails, or maintaining a secondary index of any sort.</div><br/></div></div></div></div></div></div><div id="41420010" class="c"><input type="checkbox" id="c-41420010" checked=""/><div class="controls bullet"><span class="by">canadiantim</span><span>|</span><a href="#41419753">prev</a><span>|</span><a href="#41420568">next</a><span>|</span><label class="collapse" for="c-41420010">[-]</label><label class="expand" for="c-41420010">[1 more]</label></div><br/><div class="children"><div class="content">Xata putting out some cool pg things. Is PG roll still looking good these days? Seemed pretty sexy last time I looked at it</div><br/></div></div><div id="41420568" class="c"><input type="checkbox" id="c-41420568" checked=""/><div class="controls bullet"><span class="by">oars</span><span>|</span><a href="#41420010">prev</a><span>|</span><label class="collapse" for="c-41420568">[-]</label><label class="expand" for="c-41420568">[1 more]</label></div><br/><div class="children"><div class="content">Postgres webhooks could be very usefulness for me. Thanks for sharing.</div><br/></div></div></div></div></div></div></div></body></html>