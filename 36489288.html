<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687856459805" as="style"/><link rel="stylesheet" href="styles.css?v=1687856459805"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rigtorp.se/ringbuffer/">Optimizing a ring buffer for throughput (2021)</a>Â <span class="domain">(<a href="https://rigtorp.se">rigtorp.se</a>)</span></div><div class="subtext"><span>signa11</span> | <span>17 comments</span></div><br/><div><div id="36490506" class="c"><input type="checkbox" id="c-36490506" checked=""/><div class="controls bullet"><span class="by">dnedic</span><span>|</span><a href="#36489991">next</a><span>|</span><label class="collapse" for="c-36490506">[-]</label><label class="expand" for="c-36490506">[1 more]</label></div><br/><div class="children"><div class="content">If you want more than a spsc queue, I&#x27;ve written `lockfree`, a collection of SPSC and MPMC data structures along the same principles the author here used:<a href="https:&#x2F;&#x2F;github.com&#x2F;DNedic&#x2F;lockfree">https:&#x2F;&#x2F;github.com&#x2F;DNedic&#x2F;lockfree</a>.<p>The library is written in standard C++11 (but additional API&#x27;s for higher C++ versions have been added), uses no dynamic allocation and is configurable so it is both big metal and deeply embedded friendly.</div><br/></div></div><div id="36489991" class="c"><input type="checkbox" id="c-36489991" checked=""/><div class="controls bullet"><span class="by">barbegal</span><span>|</span><a href="#36490506">prev</a><span>|</span><a href="#36490446">next</a><span>|</span><label class="collapse" for="c-36489991">[-]</label><label class="expand" for="c-36489991">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I chose to allow any queue size as opposed to allowing only sizes that are a power-of-two. This means that at least one queue item is unused in order to disambiguate between the empty queue and full queue state.<p>Don&#x27;t you still need an unused queue item even with a power of two size? Isn&#x27;t the point of having a power of two size that you can calculate the next item index in the buffer using binary rollover to go back to 0 as opposed to requiring a comparison and a branch.</div><br/><div id="36490453" class="c"><input type="checkbox" id="c-36490453" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36489991">parent</a><span>|</span><a href="#36490347">next</a><span>|</span><label class="collapse" for="c-36490453">[-]</label><label class="expand" for="c-36490453">[1 more]</label></div><br/><div class="children"><div class="content">You can distinguish full and empty using x-y=0 vs x-y=N if the length N is a power of two and smaller than the integer type holding indices x, y. No unused element needed then.</div><br/></div></div><div id="36490347" class="c"><input type="checkbox" id="c-36490347" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36489991">parent</a><span>|</span><a href="#36490453">prev</a><span>|</span><a href="#36490446">next</a><span>|</span><label class="collapse" for="c-36490347">[-]</label><label class="expand" for="c-36490347">[1 more]</label></div><br/><div class="children"><div class="content">Normally I use monotonically increasing indices to avoid the 1 element issue as there is no wraparound, then use masking to map them to actual buffer positions. With non-power of two sizes it becomes a more expensive operation, so you have to wrap on increment instead.</div><br/></div></div></div></div><div id="36490446" class="c"><input type="checkbox" id="c-36490446" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36489991">prev</a><span>|</span><a href="#36490498">next</a><span>|</span><label class="collapse" for="c-36490446">[-]</label><label class="expand" for="c-36490446">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this.<p>I used this multiproducer multiconsumer ringbuffer<p><a href="https:&#x2F;&#x2F;www.linuxjournal.com&#x2F;content&#x2F;lock-free-multi-producer-multi-consumer-queue-ring-buffer" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.linuxjournal.com&#x2F;content&#x2F;lock-free-multi-produce...</a><p>I am inspired by LMAX Disruptor. I like the idea of splitting all IO into two halves: submit and reply. At one point I was looking slides of some company who used LMAX Disruptor pattern for their IO and had high performance.<p>My extremely naive Java benchmark to test locks I get 35871639 locks per second on 12 threads with contention.<p>I want to create a message queue that uses ringbuffers to communicate between threads efficiently and elegantly and handles the splitting of IO in half. I want  to combine coroutines and threads together.</div><br/></div></div><div id="36490498" class="c"><input type="checkbox" id="c-36490498" checked=""/><div class="controls bullet"><span class="by">cafxx</span><span>|</span><a href="#36490446">prev</a><span>|</span><a href="#36490110">next</a><span>|</span><label class="collapse" for="c-36490498">[-]</label><label class="expand" for="c-36490498">[1 more]</label></div><br/><div class="children"><div class="content">A point that AFAICT is not articulated in the article is why the two cached fields should be in their own dedicated cache line (e.g. why readIdxCached_ can not share the cache line with writeIdx_).</div><br/></div></div><div id="36490110" class="c"><input type="checkbox" id="c-36490110" checked=""/><div class="controls bullet"><span class="by">jim90</span><span>|</span><a href="#36490498">prev</a><span>|</span><a href="#36490116">next</a><span>|</span><label class="collapse" for="c-36490110">[-]</label><label class="expand" for="c-36490110">[3 more]</label></div><br/><div class="children"><div class="content">There is a cool trick using virtual memory allowing fast and gapless ring buffers.<p>See this page (about half way down) <a href="https:&#x2F;&#x2F;ruby0x1.github.io&#x2F;machinery_blog_archive&#x2F;post&#x2F;virtual-memory-tricks&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ruby0x1.github.io&#x2F;machinery_blog_archive&#x2F;post&#x2F;virtua...</a></div><br/><div id="36490302" class="c"><input type="checkbox" id="c-36490302" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#36490110">parent</a><span>|</span><a href="#36490355">next</a><span>|</span><label class="collapse" for="c-36490302">[-]</label><label class="expand" for="c-36490302">[1 more]</label></div><br/><div class="children"><div class="content">It sprang from old mainframe implementations - there&#x27;s a 2002 (??) Virtual Ring Buffer in Phil Howard&#x27;s LibH collection (2007 snapshots of 2002 copyright code based on circa 1980 implementations IIRC):<p>* <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20140625200016&#x2F;http:&#x2F;&#x2F;libh.slashusr.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20140625200016&#x2F;http:&#x2F;&#x2F;libh.slash...</a><p>VRB:- These functions implement a basic virtual ring buffer system which allows the caller to put data in, and take data out, of a ring buffer, and always access the data directly in the buffer contiguously, without the caller or the functions doing any data copying to accomplish it.<p>* The &quot;Hero&quot; code<p><a href="http:&#x2F;&#x2F;libh.slashusr.org&#x2F;source&#x2F;vrb&#x2F;src&#x2F;lib&#x2F;h&#x2F;vrb_init.c" rel="nofollow noreferrer">http:&#x2F;&#x2F;libh.slashusr.org&#x2F;source&#x2F;vrb&#x2F;src&#x2F;lib&#x2F;h&#x2F;vrb_init.c</a><p>* Front &amp; back end source directories:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20100706121709&#x2F;http:&#x2F;&#x2F;libh.slashusr.org&#x2F;source&#x2F;vrb&#x2F;src&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20100706121709&#x2F;http:&#x2F;&#x2F;libh.slash...</a></div><br/></div></div><div id="36490355" class="c"><input type="checkbox" id="c-36490355" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36490110">parent</a><span>|</span><a href="#36490302">prev</a><span>|</span><a href="#36490116">next</a><span>|</span><label class="collapse" for="c-36490355">[-]</label><label class="expand" for="c-36490355">[1 more]</label></div><br/><div class="children"><div class="content">AKA the Magic Ring Buffer.</div><br/></div></div></div></div><div id="36490116" class="c"><input type="checkbox" id="c-36490116" checked=""/><div class="controls bullet"><span class="by">lovich</span><span>|</span><a href="#36490110">prev</a><span>|</span><a href="#36490200">next</a><span>|</span><label class="collapse" for="c-36490116">[-]</label><label class="expand" for="c-36490116">[4 more]</label></div><br/><div class="children"><div class="content">Is there any sort of guide for a webdev to learn enough c++&#x2F;c&#x2F;assembly&#x2F;hardware knowledge to understand this sort of blogpost deeply?<p>I am vaguely aware of some of the topics discussed in here like how when he mentions setting the write and read indices to the cache size he is referencing the L1 cache on the processor and how the L1 and L2 caches are different and every step up in memory on the processor is a order of magnitude difference in time to access. I know this about as well as the fact that I know that the stratosphere and troposphere are separate from the atmosphere, in that I know they exist but I don&#x27;t understand all the implications.<p>I&#x27;d like to learn more of this(relative to my own software layer) deep magic but I don&#x27;t know where to start.</div><br/><div id="36490428" class="c"><input type="checkbox" id="c-36490428" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#36490116">parent</a><span>|</span><a href="#36490281">next</a><span>|</span><label class="collapse" for="c-36490428">[-]</label><label class="expand" for="c-36490428">[1 more]</label></div><br/><div class="children"><div class="content">You stated all the implications, there&#x27;s not significantly more to cache coherence than what you discussed here.<p>Well, there&#x27;s significantly more if you&#x27;re trying to <i>implement</i> coherence as an architect, but for the software author that&#x27;s pretty much it.<p>Cache lines have a size, if you have a line that&#x27;s shared between two cores they keep needing perform an eviction each time one of the cores takes exclusive control to perform a write to that cache line, this is slow, the end.<p>If you want the definitive source for this stuff, the Intel Architecture SDM, Volume 3 Ch12 would be a place to start. Then the Intel Optimization manual, Ch 3.6&#x2F;3.7, and the Ch 2.x.y chapters for the micro-architecture which will describe the cache layout</div><br/></div></div><div id="36490281" class="c"><input type="checkbox" id="c-36490281" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36490116">parent</a><span>|</span><a href="#36490428">prev</a><span>|</span><a href="#36490200">next</a><span>|</span><label class="collapse" for="c-36490281">[-]</label><label class="expand" for="c-36490281">[2 more]</label></div><br/><div class="children"><div class="content">you can read the oft reposted What Every Programmer Should Know About Memory[0]. I also wrote a comment about this sort of thing recently which includes more links[1].<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36420502">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36420502</a><p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33760117">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33760117</a></div><br/><div id="36490412" class="c"><input type="checkbox" id="c-36490412" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#36490116">root</a><span>|</span><a href="#36490281">parent</a><span>|</span><a href="#36490200">next</a><span>|</span><label class="collapse" for="c-36490412">[-]</label><label class="expand" for="c-36490412">[1 more]</label></div><br/><div class="children"><div class="content">Great, now I need someone to recommend resources that would give me the foundation to understand any of your comment.</div><br/></div></div></div></div></div></div><div id="36490200" class="c"><input type="checkbox" id="c-36490200" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#36490116">prev</a><span>|</span><a href="#36490391">next</a><span>|</span><label class="collapse" for="c-36490200">[-]</label><label class="expand" for="c-36490200">[1 more]</label></div><br/><div class="children"><div class="content">I usually avoid solving that problem. Thereâs a good workaround â batch items, and either transfer ownership, or implement shared ownership, instead of copy.<p>For an example, look at how multimedia frameworks are designed: Media Foundation, gstreamer, ffmpeg, to lesser extent V4L2 and ASIO. For audio, they often handle samples coming at 48kHz, and they are usually heavily multithreaded, yet they donât have ring buffers for individual samples, their ring buffers are keeping batches of them.</div><br/></div></div><div id="36490391" class="c"><input type="checkbox" id="c-36490391" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36490200">prev</a><span>|</span><a href="#36490365">next</a><span>|</span><label class="collapse" for="c-36490391">[-]</label><label class="expand" for="c-36490391">[1 more]</label></div><br/><div class="children"><div class="content">Another simple trick is duplicating the buffer pointer field and buffer size field for consumer and producer (instead of having a single vector field). Paradoxically this makes the queue object smaller as it make use of the wasted padding used for cache alignment.</div><br/></div></div><div id="36490365" class="c"><input type="checkbox" id="c-36490365" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#36490391">prev</a><span>|</span><label class="collapse" for="c-36490365">[-]</label><label class="expand" for="c-36490365">[1 more]</label></div><br/><div class="children"><div class="content">The solution to your caching problem is more caching</div><br/></div></div></div></div></div></div></div></body></html>