<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711962074806" as="style"/><link rel="stylesheet" href="styles.css?v=1711962074806"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hsutter.github.io/cppfront/">Overview: What are Cpp2 and cppfront? How do I get and build cppfront?</a> <span class="domain">(<a href="https://hsutter.github.io">hsutter.github.io</a>)</span></div><div class="subtext"><span>cyber1</span> | <span>107 comments</span></div><br/><div><div id="39891064" class="c"><input type="checkbox" id="c-39891064" checked=""/><div class="controls bullet"><span class="by">grumpy_coder</span><span>|</span><a href="#39889048">next</a><span>|</span><label class="collapse" for="c-39891064">[-]</label><label class="expand" for="c-39891064">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a nice idea, but not clear that it can truly interoperate with vanilla C++ libs which I think is required.
Seems to be waiting for modules to be finalized, but whether cpp2 can call cpp, and cpp can call cpp2 without implementing half of a C++ compiler isn&#x27;t obvious.
<a href="https:&#x2F;&#x2F;github.com&#x2F;hsutter&#x2F;cppfront&#x2F;issues&#x2F;594">https:&#x2F;&#x2F;github.com&#x2F;hsutter&#x2F;cppfront&#x2F;issues&#x2F;594</a></div><br/></div></div><div id="39889048" class="c"><input type="checkbox" id="c-39889048" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#39891064">prev</a><span>|</span><a href="#39888701">next</a><span>|</span><label class="collapse" for="c-39889048">[-]</label><label class="expand" for="c-39889048">[7 more]</label></div><br/><div class="children"><div class="content">Someone on reddit said that the cpp2 repo was a bit old, and that is true, although he may have started this as an experiment influenced by typescript and left it on the side at some times.<p>Anyway I have no idea if cpp2 would get support from microsoft or other devs, but cpp2 seems like the most humble and &quot;least risky&quot; solution for the future of C++, and I really want it to be.<p>What I remember the most that Herb Sutter said in his cpp2 talk, is that it aims to avoid 95% of bad coding practices that C++ allows today.<p>It&#x27;s safe to say that beyond the valid criticism of C++, that it quite a good goal and it would improve C++, without using a new language, and that&#x27;s good, because a new language causes problems: new toolchains, new semantics, new specifics, no experience on a new language.<p>Cpp2 is not a new language, it is the same semantics of C++, except it has a new syntax and enforces good practices.<p>One very interesting point: in the future, cpp2 allows a cpp2-only compiler to be born, and it would still live next to C++ binaries without problem. That cpp2 compiler might probably be much faster since the cpp2 is a smaller stricter subset.</div><br/><div id="39891551" class="c"><input type="checkbox" id="c-39891551" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#39889048">parent</a><span>|</span><a href="#39890953">next</a><span>|</span><label class="collapse" for="c-39891551">[-]</label><label class="expand" for="c-39891551">[1 more]</label></div><br/><div class="children"><div class="content">How about Google&#x27;s Carbon language?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang</a></div><br/></div></div><div id="39890953" class="c"><input type="checkbox" id="c-39890953" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39889048">parent</a><span>|</span><a href="#39891551">prev</a><span>|</span><a href="#39891369">next</a><span>|</span><label class="collapse" for="c-39890953">[-]</label><label class="expand" for="c-39890953">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Anyway I have no idea if cpp2 would get support from microsoft or other devs…<p>Doesn’t he work for Microsoft?</div><br/><div id="39891585" class="c"><input type="checkbox" id="c-39891585" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#39889048">root</a><span>|</span><a href="#39890953">parent</a><span>|</span><a href="#39891369">next</a><span>|</span><label class="collapse" for="c-39891585">[-]</label><label class="expand" for="c-39891585">[1 more]</label></div><br/><div class="children"><div class="content">Yes but it’s his own personal project</div><br/></div></div></div></div><div id="39891369" class="c"><input type="checkbox" id="c-39891369" checked=""/><div class="controls bullet"><span class="by">petre</span><span>|</span><a href="#39889048">parent</a><span>|</span><a href="#39890953">prev</a><span>|</span><a href="#39888701">next</a><span>|</span><label class="collapse" for="c-39891369">[-]</label><label class="expand" for="c-39891369">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Anyway I have no idea if cpp2 would get support from microsoft or other devs, but cpp2 seems like the most humble and &quot;least risky&quot; solution for the future of C++, and I really want it to be.<p>That ship has sailed. They already have C#.</div><br/><div id="39891498" class="c"><input type="checkbox" id="c-39891498" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#39889048">root</a><span>|</span><a href="#39891369">parent</a><span>|</span><a href="#39891969">next</a><span>|</span><label class="collapse" for="c-39891498">[-]</label><label class="expand" for="c-39891498">[1 more]</label></div><br/><div class="children"><div class="content">To be fair C# is vastly different in terms of semantics compared to C++. There&#x27;s a lot of areas where it&#x27;s not viable to use C#, and IMHO it also has its own share of legacy and bad decisions from its &quot;Java clone&quot; days that make it impossible to prefer it to C++ sometimes.<p>Btw Microsoft is definitely interested into adopting new languages, just look all the effort they&#x27;ve been pouring into Rust lately.</div><br/></div></div><div id="39891969" class="c"><input type="checkbox" id="c-39891969" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39889048">root</a><span>|</span><a href="#39891369">parent</a><span>|</span><a href="#39891498">prev</a><span>|</span><a href="#39888701">next</a><span>|</span><label class="collapse" for="c-39891969">[-]</label><label class="expand" for="c-39891969">[1 more]</label></div><br/><div class="children"><div class="content">C# is so old by now, if it would be a good replacement for C++ at MS, it would already have replaced it.</div><br/></div></div></div></div></div></div><div id="39888701" class="c"><input type="checkbox" id="c-39888701" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#39889048">prev</a><span>|</span><a href="#39890395">next</a><span>|</span><label class="collapse" for="c-39888701">[-]</label><label class="expand" for="c-39888701">[5 more]</label></div><br/><div class="children"><div class="content">Unfortunately the first example already re-uses one of the less good parts of C++, the &quot;&lt;&lt;&quot; operator for std::cout, which always was a bit of a hack (including strange order of operations since &lt;&lt; normally is left shift)</div><br/><div id="39890304" class="c"><input type="checkbox" id="c-39890304" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39888701">parent</a><span>|</span><a href="#39888766">next</a><span>|</span><label class="collapse" for="c-39890304">[-]</label><label class="expand" for="c-39890304">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always thought that using &quot;&lt;&lt;&quot; in that manner was more of a way to show off the operator overloading feature than anything else.</div><br/></div></div><div id="39888766" class="c"><input type="checkbox" id="c-39888766" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#39888701">parent</a><span>|</span><a href="#39890304">prev</a><span>|</span><a href="#39890395">next</a><span>|</span><label class="collapse" for="c-39888766">[-]</label><label class="expand" for="c-39888766">[3 more]</label></div><br/><div class="children"><div class="content">Note that the &quot;&lt;&lt;&quot; operator for std::cout is not related to the language itself but related to the standard library.</div><br/><div id="39888818" class="c"><input type="checkbox" id="c-39888818" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#39888701">root</a><span>|</span><a href="#39888766">parent</a><span>|</span><a href="#39890395">next</a><span>|</span><label class="collapse" for="c-39888818">[-]</label><label class="expand" for="c-39888818">[2 more]</label></div><br/><div class="children"><div class="content">But in a &quot;C++ 2&quot; helloworld one would really expect to see std::println used instead [1].<p>[1] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;io&#x2F;println" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;io&#x2F;println</a></div><br/><div id="39890289" class="c"><input type="checkbox" id="c-39890289" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39888701">root</a><span>|</span><a href="#39888818">parent</a><span>|</span><a href="#39890395">next</a><span>|</span><label class="collapse" for="c-39890289">[-]</label><label class="expand" for="c-39890289">[1 more]</label></div><br/><div class="children"><div class="content">Cpp2 is part of the trend for would be &quot;C++ Successor languages&quot; from 2022. The std::println function was standardised in C++ 23, and implementations still don&#x27;t all provide it in full today.<p>So in effect Cpp2 pre-dates std::println. Herb will have been aware that it exists and is likely for C++ 23, but it doesn&#x27;t make sense to ship software which requires features you suspect won&#x27;t be widely available for several years. A &quot;Hello, world&quot; program should not be relying on bleeding edge features.</div><br/></div></div></div></div></div></div></div></div><div id="39890395" class="c"><input type="checkbox" id="c-39890395" checked=""/><div class="controls bullet"><span class="by">typ</span><span>|</span><a href="#39888701">prev</a><span>|</span><a href="#39888503">next</a><span>|</span><label class="collapse" for="c-39890395">[-]</label><label class="expand" for="c-39890395">[1 more]</label></div><br/><div class="children"><div class="content">Looks neat and convincing. But I think the goal (and effort) to make it into the C++ standard would hinder the momentum of adoption. I suspect it would have to go through a lot of politics and bikesheding before making any real-world impact.
Imagine that if Typescript had insisted to get accepted into the Emca standard before widespread adoption and promotion by Microsoft; it would probably still stay in the &#x27;experimental&#x27; stage.</div><br/></div></div><div id="39888503" class="c"><input type="checkbox" id="c-39888503" checked=""/><div class="controls bullet"><span class="by">superamadeus</span><span>|</span><a href="#39890395">prev</a><span>|</span><a href="#39888708">next</a><span>|</span><label class="collapse" for="c-39888503">[-]</label><label class="expand" for="c-39888503">[10 more]</label></div><br/><div class="children"><div class="content">Is there any discussion or in-depth explanation of the syntax choices? I understand that a goal was context free unambiguous parsing. But there are some things that surprise me.<p>For example, string interpolation:<p><pre><code>    &quot;Hello, (msg)$!\n&quot;
</code></pre>
Why “(msg)$” and not “$(msg)”? Surely the latter is easier to parse?</div><br/><div id="39888541" class="c"><input type="checkbox" id="c-39888541" checked=""/><div class="controls bullet"><span class="by">jiripospisil</span><span>|</span><a href="#39888503">parent</a><span>|</span><a href="#39888708">next</a><span>|</span><label class="collapse" for="c-39888541">[-]</label><label class="expand" for="c-39888541">[9 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;hsutter&#x2F;cppfront&#x2F;wiki&#x2F;Design-note:-Capture#q-why-use-postfix--for-capture-wouldnt---be-nicer-for-string-interpolation-like-python">https:&#x2F;&#x2F;github.com&#x2F;hsutter&#x2F;cppfront&#x2F;wiki&#x2F;Design-note:-Captur...</a></div><br/><div id="39890089" class="c"><input type="checkbox" id="c-39890089" checked=""/><div class="controls bullet"><span class="by">ralferoo</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39891653">next</a><span>|</span><label class="collapse" for="c-39890089">[-]</label><label class="expand" for="c-39890089">[1 more]</label></div><br/><div class="children"><div class="content">I think $() makes much more sense than ()$ in terms of parsing, when you see $ you&#x27;re looking for a single word token, and $( you&#x27;re parsing up to the matching )<p>Maybe it&#x27;s not much extra workload, but ()$ requires you to pattern-match all bracketed content in a string as a possible capture, and the parser can&#x27;t determine whether it&#x27;s a capture or not until the $ or a matching close bracket. Consider parsing &quot;((x)$)&quot; would require parsing the entire string to determine the first bracket wasn&#x27;t a capture, then we can treat just the first character as a literal, then we have to re-parse the rest of the string again, and can&#x27;t be sure it&#x27;s a capture until the $, and then we can evaluate it as a real expression and then continue with the final $.<p>Other interesting cases would be &quot;(x+(x)$)&quot; or even &quot;((x+(x)$)$)&quot;. I&#x27;m not sure I could easily predict the parsing of latter, but prefix and permitted unbracketed single word variable names &quot;(x+$x)&quot; is clearer and the second would either be &quot;(x+$(x)$)&quot; or &quot;($(x+$(x)))&quot; both of which are explicit using the prefix form and could simplify to &quot;(x+$x$)&quot; and &quot;($(x+$x))&quot; where the intent seems clearer.<p>There&#x27;s the precedent that many languages already use the prefix form which would help newcomers with familiarity, and in fact many of these languages wouldn&#x27;t even need the brackets and $var would be sufficient, and I can&#x27;t really see why the spec requires the brackets in the ()$ syntax in string literals but not for expressions in code.</div><br/></div></div><div id="39891653" class="c"><input type="checkbox" id="c-39891653" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39890089">prev</a><span>|</span><a href="#39890270">next</a><span>|</span><label class="collapse" for="c-39891653">[-]</label><label class="expand" for="c-39891653">[1 more]</label></div><br/><div class="children"><div class="content">Something about foolish consistencies…<p>The priorities of a programming language syntax are to be readable first, consistent second.<p>When it comes to syntax that is used more frequently then the importance of readability increases, and the importance of consistency drops, because people will become familiar with the syntax through frequency of use, so there is no need for them to be guided by consistency. Yet they will be reading the code more often.<p>When it comes to syntax that is used infrequently then consistency is of more importance because you want users to be able to intuit the syntax. Since it will be  infrequently used, the readability is of lesser impact.</div><br/></div></div><div id="39890270" class="c"><input type="checkbox" id="c-39890270" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39891653">prev</a><span>|</span><a href="#39889124">next</a><span>|</span><label class="collapse" for="c-39890270">[-]</label><label class="expand" for="c-39890270">[1 more]</label></div><br/><div class="children"><div class="content">That raises more questions though... Like, why does the capture syntax have to be attached to the captured element?<p>Rust for example has a single `move` syntax for all-capture vs. no-capture toggle, e.g. `|x| x + foo` (`foo` is stored as a reference) vs. `move |x| x + foo` (`foo` is moved into the closure). While I do want an additional mode for uniformly applying specific methods (typically `.clone()`) for captured elements, that is almost enough for typical closures.<p>Also, if my reading of the documentation is correct, `$` has to be attached to <i>each</i> occurrence of captured elements. Like, `:(i) = i + foo$ * (foo$ + 1)`. Doesn&#x27;t that look strange? It is even possible to mix two variants of captures like `:(i) = i + foo$ * (foo&amp;$* + 1)`, and it&#x27;s not entirely obvious to me what will happen to `foo$` when `foo&amp;$*` is updated. Treating these &quot;upvalues&quot; as a sort of an implicit structure (e.g. `$.foo`) is much more consistent, and a prefix form `$foo` can be regarded as its shorthand.</div><br/></div></div><div id="39889124" class="c"><input type="checkbox" id="c-39889124" checked=""/><div class="controls bullet"><span class="by">breatheoften</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39890270">prev</a><span>|</span><a href="#39888655">next</a><span>|</span><label class="collapse" for="c-39889124">[-]</label><label class="expand" for="c-39889124">[1 more]</label></div><br/><div class="children"><div class="content">What does &quot;for later use&quot; mean?<p>One thing I&#x27;ve noticed recently is that pretty much no language has a good way to simultaneously define a nested structure and assign that structure a name &quot;for later reuse&quot;.<p>For example -- suppose I&#x27;m dealing with some serialized data structure that come from some external system.  Very likely the data model behind this value involves &quot;nested values&quot; which have themselves have some type of which might be reused in multiple places by that external system.<p>When the goal is to just solve problems -- the approach i like to take is to focus on the values i want to consume and produce -- which might themselves contain lots of nested types each with some amount of reuse ...<p>I&#x27;d really like a language feature that supports simultaneously defining a type where it&#x27;s relevant within some other data structure _and also allows_ giving that embedded thing a name for independent reuse ...<p>I wonder if this postfix $ syntax is related to that use case at all ...<p>(... this comment a speculation based on names of things only without even reading the whole article ...)</div><br/></div></div><div id="39888655" class="c"><input type="checkbox" id="c-39888655" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39889124">prev</a><span>|</span><a href="#39890457">next</a><span>|</span><label class="collapse" for="c-39888655">[-]</label><label class="expand" for="c-39888655">[2 more]</label></div><br/><div class="children"><div class="content">Raises more questions honestly. This looks more different from today’s C++ than Rust.</div><br/><div id="39888986" class="c"><input type="checkbox" id="c-39888986" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888655">parent</a><span>|</span><a href="#39890457">next</a><span>|</span><label class="collapse" for="c-39888986">[-]</label><label class="expand" for="c-39888986">[1 more]</label></div><br/><div class="children"><div class="content">I feel like consistency goes too for losing the visual parsing benefits of special syntax. Otherwise, we might as well adopt lisp&#x27;s syntax.</div><br/></div></div></div></div><div id="39890457" class="c"><input type="checkbox" id="c-39890457" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39888655">prev</a><span>|</span><a href="#39889836">next</a><span>|</span><label class="collapse" for="c-39890457">[-]</label><label class="expand" for="c-39890457">[1 more]</label></div><br/><div class="children"><div class="content">I feel like there are more options than just the ones he listed. Like &quot;Hello ${name}&quot; or &quot;Hello `name`&quot; or &quot;Hello {`name`}&quot;...</div><br/></div></div><div id="39889836" class="c"><input type="checkbox" id="c-39889836" checked=""/><div class="controls bullet"><span class="by">superamadeus</span><span>|</span><a href="#39888503">root</a><span>|</span><a href="#39888541">parent</a><span>|</span><a href="#39890457">prev</a><span>|</span><a href="#39888708">next</a><span>|</span><label class="collapse" for="c-39889836">[-]</label><label class="expand" for="c-39889836">[1 more]</label></div><br/><div class="children"><div class="content">Oh, fantastic. Thank you!</div><br/></div></div></div></div></div></div><div id="39888708" class="c"><input type="checkbox" id="c-39888708" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#39888503">prev</a><span>|</span><a href="#39891877">next</a><span>|</span><label class="collapse" for="c-39888708">[-]</label><label class="expand" for="c-39888708">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Because ++ and -- always have in-place update semantics, we never need to remember &quot;use prefix ++&#x2F;-- unless you need a copy of the old value.&quot; If you do need a copy of the old value, just take the copy before calling ++&#x2F;--<p>I actually wish ++ and -- operators were removed.
This would simplify everything, nothing to remember whether it&#x27;s prefix or postfix operator, whether it copies something or not, you would just do &quot;value += 1&quot; and be done with it.<p>- Less mental overhead.<p>- Remove an extra way of doing the same thing.</div><br/><div id="39889827" class="c"><input type="checkbox" id="c-39889827" checked=""/><div class="controls bullet"><span class="by">nathanrf</span><span>|</span><a href="#39888708">parent</a><span>|</span><a href="#39888754">next</a><span>|</span><label class="collapse" for="c-39889827">[-]</label><label class="expand" for="c-39889827">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately, C++ uses ++ and -- for iterators, many of which cannot reasonably implement += or -=. This distinction is baked into the type system to tell whether or not an iterator supports efficient &quot;multiple advance&quot; (e.g. a linked list iterator doesn&#x27;t have += but a pointer into a contiguous vector does).<p>There&#x27;s no way to fix this in a reverse-compatible way for existing code (which is one of the constraints of cpp2- it must work with all existing C++ so that it is possible for existing projects to migrate regardless of size).</div><br/><div id="39890354" class="c"><input type="checkbox" id="c-39890354" checked=""/><div class="controls bullet"><span class="by">Rexxar</span><span>|</span><a href="#39888708">root</a><span>|</span><a href="#39889827">parent</a><span>|</span><a href="#39888754">next</a><span>|</span><label class="collapse" for="c-39890354">[-]</label><label class="expand" for="c-39890354">[1 more]</label></div><br/><div class="children"><div class="content">Making ++ or -- a statement that increment the target without returning a value should probably be enough for forward iterators.</div><br/></div></div></div></div><div id="39888754" class="c"><input type="checkbox" id="c-39888754" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#39888708">parent</a><span>|</span><a href="#39889827">prev</a><span>|</span><a href="#39888791">next</a><span>|</span><label class="collapse" for="c-39888754">[-]</label><label class="expand" for="c-39888754">[2 more]</label></div><br/><div class="children"><div class="content">That is the direction that Swift went: <a href="https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;0004-remove-pre-post-inc-decrement.md">https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;main&#x2F;proposals...</a></div><br/><div id="39888935" class="c"><input type="checkbox" id="c-39888935" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39888708">root</a><span>|</span><a href="#39888754">parent</a><span>|</span><a href="#39888791">next</a><span>|</span><label class="collapse" for="c-39888935">[-]</label><label class="expand" for="c-39888935">[1 more]</label></div><br/><div class="children"><div class="content">Rust and Go made the same choice. In Go, I think i++ is valid - but only as a statement, not an expression.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#inc_dec" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#inc_dec</a></div><br/></div></div></div></div><div id="39888791" class="c"><input type="checkbox" id="c-39888791" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#39888708">parent</a><span>|</span><a href="#39888754">prev</a><span>|</span><a href="#39891877">next</a><span>|</span><label class="collapse" for="c-39888791">[-]</label><label class="expand" for="c-39888791">[2 more]</label></div><br/><div class="children"><div class="content">But you would break the name!  C++ would be a syntax error!<p>I mean, there are people that already think that...</div><br/><div id="39888841" class="c"><input type="checkbox" id="c-39888841" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#39888708">root</a><span>|</span><a href="#39888791">parent</a><span>|</span><a href="#39891877">next</a><span>|</span><label class="collapse" for="c-39888841">[-]</label><label class="expand" for="c-39888841">[1 more]</label></div><br/><div class="children"><div class="content">We could allow overloading operator++ while not defining it on anything built-in....</div><br/></div></div></div></div></div></div><div id="39891877" class="c"><input type="checkbox" id="c-39891877" checked=""/><div class="controls bullet"><span class="by">dfgdfg34545456</span><span>|</span><a href="#39888708">prev</a><span>|</span><a href="#39889189">next</a><span>|</span><label class="collapse" for="c-39891877">[-]</label><label class="expand" for="c-39891877">[1 more]</label></div><br/><div class="children"><div class="content">Great new idea in cpp. Automated bounds checking in the hello world example sold me straight away. Try and do that as tersely Haskellers. I hope this project gets momentum.</div><br/></div></div><div id="39889189" class="c"><input type="checkbox" id="c-39889189" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#39891877">prev</a><span>|</span><a href="#39888482">next</a><span>|</span><label class="collapse" for="c-39889189">[-]</label><label class="expand" for="c-39889189">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &#x2F;&#x2F;  &#x27;BufferSize&#x27; is an object defined as a synonym for the value 1&#x27;000&#x27;000<p>&gt; BufferSize: i32 == 1&#x27;000&#x27;000;<p>So &quot;value : i32 = 10&quot; is variable, but &quot;value : i32 == 10&quot; is a constant.<p>The difference is so subtle I&#x27;m not sure I like it.<p>Later in the documentation you can find &quot;equals: (a, b) a == b;&quot; which is a function but it feels like I need to decipher it because &quot;==&quot; is not for alias in this case.<p>Retaking the example of &quot;equals: (a, b) a == b;&quot; it feels also odd to omit the braces because they are even enforced for if&#x2F;else branches.<p>I have to admit that everything was interesting until the &quot;Summary of function defaults&quot; part.</div><br/></div></div><div id="39888482" class="c"><input type="checkbox" id="c-39888482" checked=""/><div class="controls bullet"><span class="by">JNRowe</span><span>|</span><a href="#39889189">prev</a><span>|</span><a href="#39891726">next</a><span>|</span><label class="collapse" for="c-39888482">[-]</label><label class="expand" for="c-39888482">[1 more]</label></div><br/><div class="children"><div class="content">Sutter&#x27;s 2022 cppcon talk¹ is a <i>great</i> introduction to the topic, both the problems it attempts to solve and solutions it was&#x2F;is settling on.  One of those few talks that left me genuinely enthused about the topic.<p>[It is probably worth watching for the Compiler Explorer interjection toward the end alone -- Matt Godbolt Appreciation Society]<p>¹ <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ELeZAKCN4tY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ELeZAKCN4tY</a></div><br/></div></div><div id="39891726" class="c"><input type="checkbox" id="c-39891726" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#39888482">prev</a><span>|</span><a href="#39888600">next</a><span>|</span><label class="collapse" for="c-39891726">[-]</label><label class="expand" for="c-39891726">[1 more]</label></div><br/><div class="children"><div class="content">I like the idea, although many choices are arguable. For example, having to introduce mandatory&#x2F;prohibited white space around binary&#x2F;postfix operators (like &quot;&amp;&quot;) completely spoils the goal of having a more rational syntax.</div><br/></div></div><div id="39888600" class="c"><input type="checkbox" id="c-39888600" checked=""/><div class="controls bullet"><span class="by">pciexpgpu</span><span>|</span><a href="#39891726">prev</a><span>|</span><a href="#39888467">next</a><span>|</span><label class="collapse" for="c-39888600">[-]</label><label class="expand" for="c-39888600">[6 more]</label></div><br/><div class="children"><div class="content">I wonder how this compares with Carbon -&gt; C++ [0].<p>Carbon is (was?) a fantastic proposal, but not sure if it has lost steam since it was introduced or how well it is being adopted (be it inside Google or outside)?<p>Being able to incrementally&#x2F;interchangeably use&#x2F;call existing C++ code (and vice versa) seems like a great design choice (in Carbon) without having to introspect the actual generated code.<p>Not sure how easy it is to get the cppfront-generated C++ to bridge with existing C++ code (and vice versa)?<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang</a></div><br/><div id="39888888" class="c"><input type="checkbox" id="c-39888888" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#39888600">parent</a><span>|</span><a href="#39888933">next</a><span>|</span><label class="collapse" for="c-39888888">[-]</label><label class="expand" for="c-39888888">[3 more]</label></div><br/><div class="children"><div class="content">The roadmap for Carbon [0] mentions wanting to have basic, non-trivial programs written in Carbon by the end of 2024. They&#x27;re aiming for a v0.1 release in 2025. If it gains traction, they&#x27;re aiming for a v1.0 beyond 2027.<p>I don&#x27;t think anyone outside Google will seriously adopt this before it reaches v1.0. Even within Google, they may choose other options.<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;trunk&#x2F;docs&#x2F;project&#x2F;roadmap.md">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;trunk&#x2F;do...</a></div><br/><div id="39889362" class="c"><input type="checkbox" id="c-39889362" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39888600">root</a><span>|</span><a href="#39888888">parent</a><span>|</span><a href="#39888933">next</a><span>|</span><label class="collapse" for="c-39889362">[-]</label><label class="expand" for="c-39889362">[2 more]</label></div><br/><div class="children"><div class="content">Googles habit of dropping support for useful things make me not willing to trust them. I plan for my current code to be in use for at least 20 more years (i plan to retire before then), I don&#x27;t want to explain to my boss either why we are maintaining a compiler or why we must rewrite working code.</div><br/><div id="39890923" class="c"><input type="checkbox" id="c-39890923" checked=""/><div class="controls bullet"><span class="by">fractalb</span><span>|</span><a href="#39888600">root</a><span>|</span><a href="#39889362">parent</a><span>|</span><a href="#39888933">next</a><span>|</span><label class="collapse" for="c-39890923">[-]</label><label class="expand" for="c-39890923">[1 more]</label></div><br/><div class="children"><div class="content">I suspect you don&#x27;t touch Go code.</div><br/></div></div></div></div></div></div><div id="39888933" class="c"><input type="checkbox" id="c-39888933" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#39888600">parent</a><span>|</span><a href="#39888888">prev</a><span>|</span><a href="#39888685">next</a><span>|</span><label class="collapse" for="c-39888933">[-]</label><label class="expand" for="c-39888933">[1 more]</label></div><br/><div class="children"><div class="content">Herb Sutter briefly talked about why carbon was not a good contender, and I think remembering it was because of backward compatibility with C++.<p>At some point, keeping C++ semantics matters, since having different semantics would obviously prevent using previous C++ codebases, or make it more difficult to make those work together, and that may be why Carbon may not be a good choice.</div><br/></div></div><div id="39888685" class="c"><input type="checkbox" id="c-39888685" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39888600">parent</a><span>|</span><a href="#39888933">prev</a><span>|</span><a href="#39888467">next</a><span>|</span><label class="collapse" for="c-39888685">[-]</label><label class="expand" for="c-39888685">[1 more]</label></div><br/><div class="children"><div class="content">Carbon isn&#x27;t &quot;being adopted&quot;, it&#x27;s still being developed. Making a programming language takes time. Let them at least get to a point where they release some form of public beta (i.e a few more years, at least) before talking about adoption.</div><br/></div></div></div></div><div id="39888467" class="c"><input type="checkbox" id="c-39888467" checked=""/><div class="controls bullet"><span class="by">darknavi</span><span>|</span><a href="#39888600">prev</a><span>|</span><a href="#39888883">next</a><span>|</span><label class="collapse" for="c-39888467">[-]</label><label class="expand" for="c-39888467">[1 more]</label></div><br/><div class="children"><div class="content">I know some of the arguments around C++&#x2F;cpp2 are flawed, but I do love C++ and a project to move it forward with a step-change is exciting to me.<p>A few of my friends and I did Advent of Code in cpp2 this year and it was a (very buggy) blast.</div><br/></div></div><div id="39888883" class="c"><input type="checkbox" id="c-39888883" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39888467">prev</a><span>|</span><a href="#39888630">next</a><span>|</span><label class="collapse" for="c-39888883">[-]</label><label class="expand" for="c-39888883">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Cppfront, Herb Sutter&#x27;s proposal for a new C++ syntax</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32877814">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32877814</a> - Sept 2022 (545 comments)<p>and also <i>Cppfront: Autumn Update</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37719729">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37719729</a> - Sept 2023 (8 comments)</div><br/></div></div><div id="39888630" class="c"><input type="checkbox" id="c-39888630" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#39888883">prev</a><span>|</span><a href="#39890578">next</a><span>|</span><label class="collapse" for="c-39888630">[-]</label><label class="expand" for="c-39888630">[3 more]</label></div><br/><div class="children"><div class="content">I spent the other day writing an archetype entity component system which made heavy use of template metaprogramming. I try to avoid this if possible, but it was an exercise in seeing how performant I could make it, and so I wanted to offload as much work as I could manage to compile time and avoid things like virtual dispatch. API similar to the basic parts of entt.<p>My take away from the exercise is that this is not a language for human beings. I was successful in writing it, but it was extremely difficult and frustrating. Part of the frustration is because conceptually what I wanted to accomplish was not difficult, but figuring out how to express it was a nightmare. I am not new to the language, I&#x27;ve been writing C++ since 2009, it was the first language I learned and I&#x27;ve spent nearly every day of my life since then writing at least some C++ code. Even so, I can&#x27;t say that I truly understand this shit.<p>I&#x27;m hoping cpp2 brings us someplace closer to a language that mere mortals can understand. I don&#x27;t want the next generation writing C++.</div><br/><div id="39891762" class="c"><input type="checkbox" id="c-39891762" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#39888630">parent</a><span>|</span><a href="#39891837">next</a><span>|</span><label class="collapse" for="c-39891762">[-]</label><label class="expand" for="c-39891762">[1 more]</label></div><br/><div class="children"><div class="content">There are lots of languages for mere mortals. They are not compatible with C++, but that&#x27;s a feature. The next generation is largely not writing C++.</div><br/></div></div><div id="39891837" class="c"><input type="checkbox" id="c-39891837" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#39888630">parent</a><span>|</span><a href="#39891762">prev</a><span>|</span><a href="#39890578">next</a><span>|</span><label class="collapse" for="c-39891837">[-]</label><label class="expand" for="c-39891837">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I spent the other day writing an archetype entity component system which made heavy use of template metaprogramming. 
&gt;I&#x27;m hoping cpp2 brings us someplace closer to a language that mere mortals can understand.<p>Are you sure the problem is the language itself, and not the inherent complexity of that kind of metaprogramming? As far as I&#x27;m aware, Lisp is the language with the cleanest support for such metaprogramming, yet metaprogramming-heavy Lisp code is still quite hard to read. I&#x27;m not aware of a programming language in which a compile-time ECS would be easy to write&#x2F;read.</div><br/></div></div></div></div><div id="39890578" class="c"><input type="checkbox" id="c-39890578" checked=""/><div class="controls bullet"><span class="by">howtofly</span><span>|</span><a href="#39888630">prev</a><span>|</span><a href="#39889534">next</a><span>|</span><label class="collapse" for="c-39890578">[-]</label><label class="expand" for="c-39890578">[1 more]</label></div><br/><div class="children"><div class="content">Any good CMake integration besides <a href="https:&#x2F;&#x2F;github.com&#x2F;modern-cmake&#x2F;cppfront">https:&#x2F;&#x2F;github.com&#x2F;modern-cmake&#x2F;cppfront</a>?</div><br/></div></div><div id="39889534" class="c"><input type="checkbox" id="c-39889534" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#39890578">prev</a><span>|</span><a href="#39888659">next</a><span>|</span><label class="collapse" for="c-39889534">[-]</label><label class="expand" for="c-39889534">[2 more]</label></div><br/><div class="children"><div class="content">Unless I can step through original source code in debugger, watch variables etc. etc. I could not accept any source to source translator in my practice.</div><br/><div id="39889872" class="c"><input type="checkbox" id="c-39889872" checked=""/><div class="controls bullet"><span class="by">nathanrf</span><span>|</span><a href="#39889534">parent</a><span>|</span><a href="#39888659">next</a><span>|</span><label class="collapse" for="c-39889872">[-]</label><label class="expand" for="c-39889872">[1 more]</label></div><br/><div class="children"><div class="content">It is a good thing that cppfront lets you do that, then!<p>Cppfront generates #line pragmas which tell the generated .cpp file which source lines to &quot;blame&quot; for each piece of generated code. This isn&#x27;t something new and fancy for cppfront, it&#x27;s a bog-standard pragma that your debugger already understands. So it will work the exact same as your current debugging workflow even if you mix cpp and cpp2 source files.</div><br/></div></div></div></div><div id="39888659" class="c"><input type="checkbox" id="c-39888659" checked=""/><div class="controls bullet"><span class="by">crazypython</span><span>|</span><a href="#39889534">prev</a><span>|</span><a href="#39888491">next</a><span>|</span><label class="collapse" for="c-39888659">[-]</label><label class="expand" for="c-39888659">[1 more]</label></div><br/><div class="children"><div class="content">What are the tradeoffs between cpp2 and Carbon?</div><br/></div></div><div id="39888491" class="c"><input type="checkbox" id="c-39888491" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#39888659">prev</a><span>|</span><a href="#39888588">next</a><span>|</span><label class="collapse" for="c-39888491">[-]</label><label class="expand" for="c-39888491">[10 more]</label></div><br/><div class="children"><div class="content">Like Kotlin to Java<p>Or ReScript to OCaml<p>Or Gleam to Erlang</div><br/><div id="39888548" class="c"><input type="checkbox" id="c-39888548" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#39888491">parent</a><span>|</span><a href="#39891199">next</a><span>|</span><label class="collapse" for="c-39888548">[-]</label><label class="expand" for="c-39888548">[5 more]</label></div><br/><div class="children"><div class="content">Kotlin is a distinct language with new features that (I&#x27;m fairly sure) make it non-isomorphic to Java code though.  But I can&#x27;t speak on the others.</div><br/><div id="39888899" class="c"><input type="checkbox" id="c-39888899" checked=""/><div class="controls bullet"><span class="by">simon_void</span><span>|</span><a href="#39888491">root</a><span>|</span><a href="#39888548">parent</a><span>|</span><a href="#39891199">next</a><span>|</span><label class="collapse" for="c-39888899">[-]</label><label class="expand" for="c-39888899">[4 more]</label></div><br/><div class="children"><div class="content">not sure what &quot;(non)-isomorphic&quot; but Kotlin code is interoperable with Java code in both directions. You can easily call Java-code from Kotlin (but I guess that&#x27;s the easy direction) but you can also call Kotlin code from Java. There exist specific annotations to control how Kotlin code will be converted to bytecode and therefore be invoked from Java, e.g. a function in a Kotlin companion object would normally concerted into a function of a Singleton property called INSTANCE on the base class, but if you annotate it with @JvmStatic it will become a static method of that class in bytecode instead.
This means you can write a Kotlin lib that feels very normal to call from Java.
here&#x27;s the relevant part of the documentation: <a href="https:&#x2F;&#x2F;kotlinlang.org&#x2F;docs&#x2F;java-to-kotlin-interop.html" rel="nofollow">https:&#x2F;&#x2F;kotlinlang.org&#x2F;docs&#x2F;java-to-kotlin-interop.html</a>
So yes, Kotlin is considered to be a successor language, not just another language (also) compiling to the JVM.</div><br/><div id="39890006" class="c"><input type="checkbox" id="c-39890006" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#39888491">root</a><span>|</span><a href="#39888899">parent</a><span>|</span><a href="#39891199">next</a><span>|</span><label class="collapse" for="c-39890006">[-]</label><label class="expand" for="c-39890006">[3 more]</label></div><br/><div class="children"><div class="content">An isomorphism is a structure preserving 1:1 map between two sets or some other pair of structures.  While Java and Kotlin are interoperable (because they both target the JVM), they are not isomorphic for precisely the reasons you described.  If it was, then you could do round trip machine translation on the syntax in either direction and have a result that&#x27;s identical to the original.  You can&#x27;t do that because Kotlin extends Java in nontrivial semantic ways (for a concrete example, see Nothing in the article you linked).<p>Cpp2 isn&#x27;t trying to be a successor language to C++, the article states that it&#x27;s trying to present an identical feature set in a new skin where the best practices of modern C++ are more ergonomic without introducing any new functionality.</div><br/><div id="39890189" class="c"><input type="checkbox" id="c-39890189" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39888491">root</a><span>|</span><a href="#39890006">parent</a><span>|</span><a href="#39891199">next</a><span>|</span><label class="collapse" for="c-39890189">[-]</label><label class="expand" for="c-39890189">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Cpp2 isn&#x27;t trying to be a successor language to C++<p>Herb is trying to <i>sell</i> it as not a successor because for now that suits him better.<p>Because C++ is a general purpose language Herb can deliver a &quot;not a new feature&quot; that is so elaborate in practice you would never write the equivalent C++ by hand, but Herb can insist that since technically it can still be transpiled to C++ it&#x27;s not a different language... right up until that ceases to suit his agenda.<p>Under this model WUFFS (a higher performance yet entirely safe language for writing stuff like codecs and compression algorithms) doesn&#x27;t &quot;introduce any new functionality&quot; compared to C, since the present WUFFS-the-language is transpiled into C. But I think C programmers would be astonished to hear that <i>C</i> is now apparently higher performance than C and is able to guarantee it&#x27;s entirely safe...</div><br/><div id="39890984" class="c"><input type="checkbox" id="c-39890984" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#39888491">root</a><span>|</span><a href="#39890189">parent</a><span>|</span><a href="#39891199">next</a><span>|</span><label class="collapse" for="c-39890984">[-]</label><label class="expand" for="c-39890984">[1 more]</label></div><br/><div class="children"><div class="content">The linked article explicitly states<p>&gt; What it isn&#x27;t. Cpp2 is not a successor or alternate language [...]</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39891199" class="c"><input type="checkbox" id="c-39891199" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#39888491">parent</a><span>|</span><a href="#39888548">prev</a><span>|</span><a href="#39890195">next</a><span>|</span><label class="collapse" for="c-39891199">[-]</label><label class="expand" for="c-39891199">[1 more]</label></div><br/><div class="children"><div class="content">all of those compile to the respective languages&#x27; bytecodes, not to source code</div><br/></div></div><div id="39890195" class="c"><input type="checkbox" id="c-39890195" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39888491">parent</a><span>|</span><a href="#39891199">prev</a><span>|</span><a href="#39888690">next</a><span>|</span><label class="collapse" for="c-39890195">[-]</label><label class="expand" for="c-39890195">[1 more]</label></div><br/><div class="children"><div class="content">Surprised to see Gleam instead of Elixir, I haven&#x27;t heard of the former before.</div><br/></div></div><div id="39888690" class="c"><input type="checkbox" id="c-39888690" checked=""/><div class="controls bullet"><span class="by">Cerium</span><span>|</span><a href="#39888491">parent</a><span>|</span><a href="#39890195">prev</a><span>|</span><a href="#39888939">next</a><span>|</span><label class="collapse" for="c-39888690">[-]</label><label class="expand" for="c-39888690">[1 more]</label></div><br/><div class="children"><div class="content">Or, Cfront to C? :)</div><br/></div></div><div id="39888939" class="c"><input type="checkbox" id="c-39888939" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#39888491">parent</a><span>|</span><a href="#39888690">prev</a><span>|</span><a href="#39888588">next</a><span>|</span><label class="collapse" for="c-39888939">[-]</label><label class="expand" for="c-39888939">[1 more]</label></div><br/><div class="children"><div class="content">or more famously, typescript to javascript, which is the example Herb uses.</div><br/></div></div></div></div><div id="39888588" class="c"><input type="checkbox" id="c-39888588" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#39888491">prev</a><span>|</span><a href="#39888801">next</a><span>|</span><label class="collapse" for="c-39888588">[-]</label><label class="expand" for="c-39888588">[32 more]</label></div><br/><div class="children"><div class="content">Most of my personal issues aren&#x27;t with C++ syntax as such (although it also has many problems). My main gripes are:<p>1. Very slow compilation.<p>2. Poor encapsulation, adding private functions requires recompiling all dependents, see (1).<p>3. Comically huge symbols make debugging much harder than it needs to be -- today gdb OOM&#x27;d my 16GB laptop when trying to form a backtrace of a typical QT application coredump.<p>Unfortunately it doesn&#x27;t seem like cppfront can fix these issues. It may still be a worthwhile effort in other respects, of course.</div><br/><div id="39888898" class="c"><input type="checkbox" id="c-39888898" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#39888588">parent</a><span>|</span><a href="#39888706">next</a><span>|</span><label class="collapse" for="c-39888898">[-]</label><label class="expand" for="c-39888898">[2 more]</label></div><br/><div class="children"><div class="content">I laughed at (3)<p>Although QT is not a tiny framework, and I don&#x27;t really know if modern C++ tools are really good enough for this sort of problem, since C++11 to 20 probably caused those tools to explode in memory consumption<p>But I am not surprised at all. I remember around 2013, I would use bullet physics and the Ogre3D engine, and I had to tell visual C++ to increase its memory capacity because the compiler would refuse to continue.</div><br/><div id="39889862" class="c"><input type="checkbox" id="c-39889862" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888898">parent</a><span>|</span><a href="#39888706">next</a><span>|</span><label class="collapse" for="c-39889862">[-]</label><label class="expand" for="c-39889862">[1 more]</label></div><br/><div class="children"><div class="content">3) is forcing me to incorporate a symbol strip&#x2F;upload to sentry piping at $WORK because Eigen debug symbols cause our build sizes to explode.</div><br/></div></div></div></div><div id="39888706" class="c"><input type="checkbox" id="c-39888706" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#39888588">parent</a><span>|</span><a href="#39888898">prev</a><span>|</span><a href="#39888606">next</a><span>|</span><label class="collapse" for="c-39888706">[-]</label><label class="expand" for="c-39888706">[14 more]</label></div><br/><div class="children"><div class="content">Adding methods changes the vtable layout so there&#x27;s no way to not recompile all the dependents. There&#x27;s no solution to this unless private functions are guaranteed to not be virtual.</div><br/><div id="39889026" class="c"><input type="checkbox" id="c-39889026" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888706">parent</a><span>|</span><a href="#39891239">next</a><span>|</span><label class="collapse" for="c-39889026">[-]</label><label class="expand" for="c-39889026">[4 more]</label></div><br/><div class="children"><div class="content">There isn&#x27;t <i>that</i> much work the compiler should need to do. Ideally, a clever compiler could just update the vtables in some intermediate representation of the program and re-emit the binary. The C++ compiler today is so insanely wasteful - edit one header file and the compiler re-parses all the header files N^2 times. It should be possible to make a compiler thats way faster than any C++ compiler today.<p>Of course, the elephant in the room is the C++ preprocessor. I haven&#x27;t looked too closely into cppfront, but if I had the chance, I&#x27;d give the C macro system a bullet.<p>My favorite &quot;macro&quot; system by far is zig&#x27;s comptime, which is beautiful and elegant. Zig code can simply elect to be executed in the compiler instead of at runtime. For example, here&#x27;s how the print() function compiles in zig. Its a thing of beauty:<p><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#Case-Study-print-in-Zig" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#Case-Study-print-i...</a></div><br/><div id="39889081" class="c"><input type="checkbox" id="c-39889081" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39889026">parent</a><span>|</span><a href="#39890583">next</a><span>|</span><label class="collapse" for="c-39889081">[-]</label><label class="expand" for="c-39889081">[2 more]</label></div><br/><div class="children"><div class="content">The problem is reflection, including SFINAE. Code can branch on if a method exists.</div><br/><div id="39889691" class="c"><input type="checkbox" id="c-39889691" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39889081">parent</a><span>|</span><a href="#39890583">next</a><span>|</span><label class="collapse" for="c-39889691">[-]</label><label class="expand" for="c-39889691">[1 more]</label></div><br/><div class="children"><div class="content">So? It shouldn’t take seconds to make one change to the reflection database. Or update derived code.<p>Incremental compilation is fundamentally the same problem that web frameworks solve. There’s plenty of efficient ways to do it.</div><br/></div></div></div></div><div id="39890583" class="c"><input type="checkbox" id="c-39890583" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39889026">parent</a><span>|</span><a href="#39889081">prev</a><span>|</span><a href="#39891239">next</a><span>|</span><label class="collapse" for="c-39890583">[-]</label><label class="expand" for="c-39890583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The C++ compiler today is so insanely wasteful - edit one header file and the compiler re-parses all the header files N^2 times. It should be possible to make a compiler thats way faster than any C++ compiler today.<p>Well, yeah, that&#x27;s the problem that modules are supposed to solve. (AFAIK the only fully C++20-standard-compliant implementation of modules is in MSVC, although even Clang modules are adequate for drastically reducing compile times.)<p>You are still going to have to recompile all your dependent compilation units if the vtable layout changes, as mentioned elsewhere, since all of your callsites have to reflect any changes to vtable lookups.<p>&gt; My favorite &quot;macro&quot; system by far is zig&#x27;s comptime, which is beautiful and elegant. Zig code can simply elect to be executed in the compiler instead of at runtime. For example, here&#x27;s how the print() function compiles in zig. Its a thing of beauty:<p>How is this different from constexpr &#x2F; consteval in C++?<p>std::format (introduced in C++20) is implemented in a similar fashion in that the format string is checked at compile-time (number of args, types, etc), so there&#x27;s no good reason why C++ couldn&#x27;t have a print function that behaves the same way and is validated at compile-time [0]. Libraries such Abseil and folly certainly provide this.<p>[0] It seems that C++23&#x27;s std::print is not that function, oddly enough.</div><br/></div></div></div></div><div id="39891239" class="c"><input type="checkbox" id="c-39891239" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888706">parent</a><span>|</span><a href="#39889026">prev</a><span>|</span><a href="#39888968">next</a><span>|</span><label class="collapse" for="c-39891239">[-]</label><label class="expand" for="c-39891239">[1 more]</label></div><br/><div class="children"><div class="content">In typical c++ manner, we can’t have nice things because {obscure internal technicality that don’t impact the user in any way whatsoever}$. As a user I don’t care what a vtable is. Just make it work. Other languages don’t have this problem.<p>During release builds sure, optimize away with  LTO and whatever is needed to make it vroom. During development, waiting several minutes for a minor private function update is just absurd.</div><br/></div></div><div id="39888968" class="c"><input type="checkbox" id="c-39888968" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888706">parent</a><span>|</span><a href="#39891239">prev</a><span>|</span><a href="#39889973">next</a><span>|</span><label class="collapse" for="c-39888968">[-]</label><label class="expand" for="c-39888968">[1 more]</label></div><br/><div class="children"><div class="content">Wait, what? Virtual methods in C++ are opt-in. You only need the &#x27;final&#x27; keyword when you&#x27;re overriding a method in a child class.</div><br/></div></div><div id="39889973" class="c"><input type="checkbox" id="c-39889973" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888706">parent</a><span>|</span><a href="#39888968">prev</a><span>|</span><a href="#39888808">next</a><span>|</span><label class="collapse" for="c-39889973">[-]</label><label class="expand" for="c-39889973">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there are solutions, and the simplest one is replace the direct vtable lookup with an indirect one where the methods are referenced not by their numeric offsets in the vtable but via their symbolic names and the offset resolution is performed via a separate lookup table – not that dissimilar from how it is done in ELF shared libraries.<p>All of them will result in incurring a performance penalty, either at the runtime, or at the start-up time, or in the compiler&#x2F;linker, and memory blowouts. But it will solve the recompilation problem.</div><br/></div></div><div id="39888808" class="c"><input type="checkbox" id="c-39888808" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888706">parent</a><span>|</span><a href="#39889973">prev</a><span>|</span><a href="#39888606">next</a><span>|</span><label class="collapse" for="c-39888808">[-]</label><label class="expand" for="c-39888808">[6 more]</label></div><br/><div class="children"><div class="content">Um... isn&#x27;t that guaranteed?  What would it mean for a private function to be virtual?  It can&#x27;t be overridden by a different implementation in a child class...</div><br/><div id="39889028" class="c"><input type="checkbox" id="c-39889028" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888808">parent</a><span>|</span><a href="#39888907">next</a><span>|</span><label class="collapse" for="c-39889028">[-]</label><label class="expand" for="c-39889028">[4 more]</label></div><br/><div class="children"><div class="content">Yes, you can have a private virtual member function, and it can be overridden in a child class (unless declared final), apparently.<p>I too thought that sounded insane, so I just looked it up. I&#x27;ve been programming C++ for twenty five years and the thought of wanting to do this have never ever occurred to me...</div><br/><div id="39890732" class="c"><input type="checkbox" id="c-39890732" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39889028">parent</a><span>|</span><a href="#39889513">next</a><span>|</span><label class="collapse" for="c-39890732">[-]</label><label class="expand" for="c-39890732">[2 more]</label></div><br/><div class="children"><div class="content">It could make sense if you have a method that you want derived classes to be able to override but not to be able to call directly.<p>This is, admittedly, a pretty niche case but certainly not inconceivable.</div><br/><div id="39890856" class="c"><input type="checkbox" id="c-39890856" checked=""/><div class="controls bullet"><span class="by">zetafunction</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39890732">parent</a><span>|</span><a href="#39889513">next</a><span>|</span><label class="collapse" for="c-39890856">[-]</label><label class="expand" for="c-39890856">[1 more]</label></div><br/><div class="children"><div class="content">Except the derived class can simply change the visibility of the override, so...</div><br/></div></div></div></div><div id="39889513" class="c"><input type="checkbox" id="c-39889513" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39889028">parent</a><span>|</span><a href="#39890732">prev</a><span>|</span><a href="#39888907">next</a><span>|</span><label class="collapse" for="c-39889513">[-]</label><label class="expand" for="c-39889513">[1 more]</label></div><br/><div class="children"><div class="content">TIL.</div><br/></div></div></div></div><div id="39888907" class="c"><input type="checkbox" id="c-39888907" checked=""/><div class="controls bullet"><span class="by">zetafunction</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888808">parent</a><span>|</span><a href="#39889028">prev</a><span>|</span><a href="#39888606">next</a><span>|</span><label class="collapse" for="c-39888907">[-]</label><label class="expand" for="c-39888907">[1 more]</label></div><br/><div class="children"><div class="content">`final` prevents a child class from overriding a method. `private` does not.</div><br/></div></div></div></div></div></div><div id="39888606" class="c"><input type="checkbox" id="c-39888606" checked=""/><div class="controls bullet"><span class="by">ThouYS</span><span>|</span><a href="#39888588">parent</a><span>|</span><a href="#39888706">prev</a><span>|</span><a href="#39889806">next</a><span>|</span><label class="collapse" for="c-39888606">[-]</label><label class="expand" for="c-39888606">[13 more]</label></div><br/><div class="children"><div class="content">under what circumstances does (2) hold? for vanilla methods it&#x27;s no problem</div><br/><div id="39888693" class="c"><input type="checkbox" id="c-39888693" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888606">parent</a><span>|</span><a href="#39888677">next</a><span>|</span><label class="collapse" for="c-39888693">[-]</label><label class="expand" for="c-39888693">[5 more]</label></div><br/><div class="children"><div class="content">C++ build systems are typically based on file timestamps. Modifying a header file triggers recompilation of all translation units including that header.<p>There are workarounds like pimpl (aka. C style encapsulation). But this requires extra boilerplate and indirection. C++ modules might fix it at some point, but after 35 years of not having them in C++ most real life codebases aren&#x27;t set up that way and may never be.</div><br/><div id="39888820" class="c"><input type="checkbox" id="c-39888820" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888693">parent</a><span>|</span><a href="#39888677">next</a><span>|</span><label class="collapse" for="c-39888820">[-]</label><label class="expand" for="c-39888820">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think of pimpl as a tool for speeding up compilation, but for black box encapsulation.<p>If the compile time (when adding a method) is really an issue you can chop up and reconfigure your include files.  A pain, but perhaps saves you time in the long run.<p>Of course (<i>waves hands</i>) modules will magically improve things...someday.</div><br/><div id="39888912" class="c"><input type="checkbox" id="c-39888912" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888820">parent</a><span>|</span><a href="#39888677">next</a><span>|</span><label class="collapse" for="c-39888912">[-]</label><label class="expand" for="c-39888912">[3 more]</label></div><br/><div class="children"><div class="content">I think it can be both things.<p>Haven&#x27;t you ever seen someone do<p><pre><code>    struct Thing;
    struct OtherThing;
</code></pre>
in lieu of just including &quot;thing.h&quot;? I see it frequently in real life code bases and I can&#x27;t see a reason for it other than compilation time optimisation.</div><br/><div id="39888972" class="c"><input type="checkbox" id="c-39888972" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888912">parent</a><span>|</span><a href="#39889884">next</a><span>|</span><label class="collapse" for="c-39888972">[-]</label><label class="expand" for="c-39888972">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I do that all the time too.  But you can&#x27;t call a method (or look inside Thing, or pass it as an argument, only a pointer to it) without including the definition.<p>Hmm, there might be some interesting linker hacks to patch things up post compilation.  But then you&#x27;d want some way to do the forward declaration for cases where Thing could have been passed in registers...</div><br/></div></div><div id="39889884" class="c"><input type="checkbox" id="c-39889884" checked=""/><div class="controls bullet"><span class="by">DerekL</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888912">parent</a><span>|</span><a href="#39888972">prev</a><span>|</span><a href="#39888677">next</a><span>|</span><label class="collapse" for="c-39889884">[-]</label><label class="expand" for="c-39889884">[1 more]</label></div><br/><div class="children"><div class="content">This is sometimes required to break dependency cycles. Also, you can use this to rearrange declarations in the same file.</div><br/></div></div></div></div></div></div></div></div><div id="39888677" class="c"><input type="checkbox" id="c-39888677" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888606">parent</a><span>|</span><a href="#39888693">prev</a><span>|</span><a href="#39888722">next</a><span>|</span><label class="collapse" for="c-39888677">[-]</label><label class="expand" for="c-39888677">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; 2. Poor encapsulation, adding private functions requires recompiling all dependents<p>&gt;&gt; under what circumstances does (2) hold?<p>To add a private member variable or function, you need to put it in the class definition in the header file. Then anything that includes the header needs to be recompiled.</div><br/><div id="39888737" class="c"><input type="checkbox" id="c-39888737" checked=""/><div class="controls bullet"><span class="by">hkwerf</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888677">parent</a><span>|</span><a href="#39888702">next</a><span>|</span><label class="collapse" for="c-39888737">[-]</label><label class="expand" for="c-39888737">[2 more]</label></div><br/><div class="children"><div class="content">Admittedly, adding a private member <i>variable</i> changes the object size and thus the ABI and thus requires recompilation of dependencies.<p>Thinking about that, is there any case in which private functions can end up in a vtable? In that case, it&#x27;d break ABI too.</div><br/><div id="39888969" class="c"><input type="checkbox" id="c-39888969" checked=""/><div class="controls bullet"><span class="by">NekkoDroid</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888737">parent</a><span>|</span><a href="#39888702">next</a><span>|</span><label class="collapse" for="c-39888969">[-]</label><label class="expand" for="c-39888969">[1 more]</label></div><br/><div class="children"><div class="content">&gt; is there any case in which private functions can end up in a vtable?<p>Yes, but it generally isn&#x27;t something that is done.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;5oPovKzoT" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;5oPovKzoT</a></div><br/></div></div></div></div><div id="39888702" class="c"><input type="checkbox" id="c-39888702" checked=""/><div class="controls bullet"><span class="by">ThouYS</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888677">parent</a><span>|</span><a href="#39888737">prev</a><span>|</span><a href="#39888722">next</a><span>|</span><label class="collapse" for="c-39888702">[-]</label><label class="expand" for="c-39888702">[2 more]</label></div><br/><div class="children"><div class="content">they don&#x27;t need to be. dependents will continue functioning, because ABI hasn&#x27;t changed</div><br/><div id="39888731" class="c"><input type="checkbox" id="c-39888731" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888702">parent</a><span>|</span><a href="#39888722">next</a><span>|</span><label class="collapse" for="c-39888731">[-]</label><label class="expand" for="c-39888731">[1 more]</label></div><br/><div class="children"><div class="content">Now explain that to my build system.<p>But even if you managed to do that, first compilation is still much slower than it should be, because anlot of headers have to be included (transitively) to allow even declaring these fields and methods.</div><br/></div></div></div></div></div></div><div id="39888722" class="c"><input type="checkbox" id="c-39888722" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888606">parent</a><span>|</span><a href="#39888677">prev</a><span>|</span><a href="#39888664">next</a><span>|</span><label class="collapse" for="c-39888722">[-]</label><label class="expand" for="c-39888722">[1 more]</label></div><br/><div class="children"><div class="content">Adding private functions or fields requires changing the class declarations, which requires rebuilding any code that includes that class deckaration. It shouldn&#x27;t be like that, especially for methods which shouldnt change anything about the class ABI.<p>Even worse, this dependency is transitive. Dependencies to allow defining these private methods an fields are exposed too, forcing inclusion of headers to all members of the class, even if it&#x27;s only implementation details.</div><br/></div></div><div id="39888664" class="c"><input type="checkbox" id="c-39888664" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39888588">root</a><span>|</span><a href="#39888606">parent</a><span>|</span><a href="#39888722">prev</a><span>|</span><a href="#39889806">next</a><span>|</span><label class="collapse" for="c-39888664">[-]</label><label class="expand" for="c-39888664">[1 more]</label></div><br/><div class="children"><div class="content">If you touch a header, even private only, includers will rebuild. Modules might fix this.</div><br/></div></div></div></div><div id="39889806" class="c"><input type="checkbox" id="c-39889806" checked=""/><div class="controls bullet"><span class="by">jmac01</span><span>|</span><a href="#39888588">parent</a><span>|</span><a href="#39888606">prev</a><span>|</span><a href="#39890293">next</a><span>|</span><label class="collapse" for="c-39889806">[-]</label><label class="expand" for="c-39889806">[1 more]</label></div><br/><div class="children"><div class="content">How is dependency management not in this list hahaha holy crap c++ is so fucking shit to work with in this regard compared to another &quot;modern&quot; language.</div><br/></div></div></div></div><div id="39888801" class="c"><input type="checkbox" id="c-39888801" checked=""/><div class="controls bullet"><span class="by">fancyfredbot</span><span>|</span><a href="#39888588">prev</a><span>|</span><a href="#39889299">next</a><span>|</span><label class="collapse" for="c-39888801">[-]</label><label class="expand" for="c-39888801">[11 more]</label></div><br/><div class="children"><div class="content">It was when debugging a memory leak which occurred because I forgot to declare the base class destructor as virtual that I started to think C++ was a rather unfriendly language and not really designed to be easy to use.<p>Then a few years later I read the spec for std::launder that I realised C++ was not really designed to be understood.<p>It&#x27;s a shame because it&#x27;s actually a rather nice language in some ways. Here&#x27;s hoping that this project or something similar takes off and separates the good bits from the bad.</div><br/><div id="39889062" class="c"><input type="checkbox" id="c-39889062" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#39888801">parent</a><span>|</span><a href="#39888929">next</a><span>|</span><label class="collapse" for="c-39889062">[-]</label><label class="expand" for="c-39889062">[2 more]</label></div><br/><div class="children"><div class="content">The evolution of C++ has been a multi-decade history of dealing with difficult reality.<p>I have great hope that Herb can create with his cppfront project “The Very Best of C++” to carry that tremendous legacy forward.<p>If I was to throw my hat into a “C++ successor”, it would be <a href="https:&#x2F;&#x2F;www.hylo-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hylo-lang.org&#x2F;</a> with its “all the safeties” and “tell you when you’re doing it sub-optimal” approach.</div><br/><div id="39889887" class="c"><input type="checkbox" id="c-39889887" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39889062">parent</a><span>|</span><a href="#39888929">next</a><span>|</span><label class="collapse" for="c-39889887">[-]</label><label class="expand" for="c-39889887">[1 more]</label></div><br/><div class="children"><div class="content">Hylo is interesting in principle for exploring this particular notion (mutable value semantics) as a way to potentially write software without the lifetime annotations Rust needs.<p>But I don&#x27;t find it promising that after apologising in 2023 for missing their self-imposed 2022 deadline to ship something that works and other people can use, in Q2 2024 it doesn&#x27;t look like their new 2023 roadmap got done either. Maybe they&#x27;re going to eventually deliver this amazing thing. Maybe they&#x27;re just going to learn some lessons (probably for the Swift community) and never ship Hylo per se. Certainly 2025 &quot;Take over the world&quot; looks... ambitious with nine months left to do all the stuff left from 2023 and all the work described for 2024 on top.</div><br/></div></div></div></div><div id="39888929" class="c"><input type="checkbox" id="c-39888929" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39888801">parent</a><span>|</span><a href="#39889062">prev</a><span>|</span><a href="#39890295">next</a><span>|</span><label class="collapse" for="c-39888929">[-]</label><label class="expand" for="c-39888929">[7 more]</label></div><br/><div class="children"><div class="content">Yeah... its shocking to me how difficult it is to read the C++ standard library. Surely, the standard library is written by the authors of the language. It should be a positive example of how they hope their language is used, right?<p>Here&#x27;s the source of C++&#x27;s vector class:<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.6.2&#x2F;libstdc++&#x2F;api&#x2F;a01115_source.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.6.2&#x2F;libstdc++&#x2F;api&#x2F;a0111...</a><p>In comparison, vec in rust. (Note you need to scroll down a few pages to start seeing non-trivial functions. There&#x27;s a lot of block comments.):<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;src&#x2F;alloc&#x2F;vec&#x2F;mod.rs.html#398" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;src&#x2F;alloc&#x2F;vec&#x2F;mod.rs.html#398</a><p>Or list in Go:<p><a href="https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;master:src&#x2F;container&#x2F;list&#x2F;list.go" rel="nofollow">https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;master:src&#x2F;container&#x2F;li...</a><p>To my eye, that C++ code is by far the hardest code to read.</div><br/><div id="39889479" class="c"><input type="checkbox" id="c-39889479" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39888929">parent</a><span>|</span><a href="#39889382">next</a><span>|</span><label class="collapse" for="c-39889479">[-]</label><label class="expand" for="c-39889479">[1 more]</label></div><br/><div class="children"><div class="content">Notice that there are in practice <i>three</i> distinct implementations of the C++ standard library. They&#x27;re all awful to read though, here&#x27;s Microsoft&#x27;s std::vector <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;STL&#x2F;blob&#x2F;main&#x2F;stl&#x2F;inc&#x2F;vector">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;STL&#x2F;blob&#x2F;main&#x2F;stl&#x2F;inc&#x2F;vector</a><p>However you&#x27;re being slightly unfair because Rust&#x27;s Vec is just defined (opaquely) as a RawVec plus a length value, so let&#x27;s link RawVec, <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;src&#x2F;alloc&#x2F;raw_vec.rs.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;src&#x2F;alloc&#x2F;raw_vec.rs.html</a> -- RawVec is the part responsible for the messy problem of how to actually implement the growable array type.<p>Still, the existence of <i>three</i> C++ libraries with slightly different (or sometimes hugely different) quality of implementation means good C++ code can&#x27;t depend on much beyond what the ISO document promises, and yet it must guard against the nonsense inflicted by all three and by lacks of the larger language. In particular everything must use the reserved prefix so that it&#x27;s not smashed inadvertently by a macro, and lots of weird C++ idioms that preserve performance by sacrificing clarity of implementation are needed, even where you&#x27;d ordinarily sacrifice to get the development throughput win of everybody know what&#x27;s going on. For example you&#x27;ll see a lot of &quot;pair&quot; types bought into existence which are there to squirrel away a ZST that in C++ can&#x27;t exist, using the Empty Base Optimisation. In Rust the language has ZSTs so they can just write what they meant.</div><br/></div></div><div id="39889382" class="c"><input type="checkbox" id="c-39889382" checked=""/><div class="controls bullet"><span class="by">lanza</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39888929">parent</a><span>|</span><a href="#39889479">prev</a><span>|</span><a href="#39889466">next</a><span>|</span><label class="collapse" for="c-39889382">[-]</label><label class="expand" for="c-39889382">[1 more]</label></div><br/><div class="children"><div class="content">I work on clang and don&#x27;t know go yet still find the go version easier to read.</div><br/></div></div><div id="39889466" class="c"><input type="checkbox" id="c-39889466" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39888929">parent</a><span>|</span><a href="#39889382">prev</a><span>|</span><a href="#39889554">next</a><span>|</span><label class="collapse" for="c-39889466">[-]</label><label class="expand" for="c-39889466">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It should be a positive example of how they hope their language is used, right?<p>should it though? there&#x27;s a million ways to learn C++. Reading the std code definitely isn&#x27;t one - technically the std could be entirely compiler builtins. If you want to read positive examples take A Tour of C++ 3rd edition (<a href="https:&#x2F;&#x2F;www.amazon.ca&#x2F;Tour-C-Bjarne-Stroustrup&#x2F;dp&#x2F;0136816487" rel="nofollow">https:&#x2F;&#x2F;www.amazon.ca&#x2F;Tour-C-Bjarne-Stroustrup&#x2F;dp&#x2F;0136816487</a>)</div><br/><div id="39889648" class="c"><input type="checkbox" id="c-39889648" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39889466">parent</a><span>|</span><a href="#39889554">next</a><span>|</span><label class="collapse" for="c-39889648">[-]</label><label class="expand" for="c-39889648">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Do as I say, not as I do&quot; is known to be poor pedagogy.<p>If you find that expert practitioners don&#x27;t do the things you think students should be doing, it suggests that something is wrong and needs fixing. In the standard library implementations it&#x27;s <i>very obvious</i> that something is badly wrong, and yet for <i>decades</i> C++ has resisted the hard work of fixing it.</div><br/></div></div></div></div><div id="39889554" class="c"><input type="checkbox" id="c-39889554" checked=""/><div class="controls bullet"><span class="by">clnhlzmn</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39888929">parent</a><span>|</span><a href="#39889466">prev</a><span>|</span><a href="#39889478">next</a><span>|</span><label class="collapse" for="c-39889554">[-]</label><label class="expand" for="c-39889554">[1 more]</label></div><br/><div class="children"><div class="content">I think the c++ version could be more understandable but it’s as if the authors intentionally made it as obtuse as possible.</div><br/></div></div><div id="39889478" class="c"><input type="checkbox" id="c-39889478" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#39888801">root</a><span>|</span><a href="#39888929">parent</a><span>|</span><a href="#39889554">prev</a><span>|</span><a href="#39890295">next</a><span>|</span><label class="collapse" for="c-39889478">[-]</label><label class="expand" for="c-39889478">[1 more]</label></div><br/><div class="children"><div class="content">Part of the distinct &quot;C++ std&quot; style is due to naming rules and textual includes. Every name that&#x27;s not part of the standardized interface starts with __ because __foo and _Foo are blanket reserved names, so a user can&#x27;t complain that std:: explodes when he does &quot;#define _Base 0&quot;.</div><br/></div></div></div></div></div></div><div id="39889299" class="c"><input type="checkbox" id="c-39889299" checked=""/><div class="controls bullet"><span class="by">alexeiz</span><span>|</span><a href="#39888801">prev</a><span>|</span><a href="#39891352">next</a><span>|</span><label class="collapse" for="c-39889299">[-]</label><label class="expand" for="c-39889299">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How do I get and build cppfront?<p>&gt; g++ ...<p>Really?  You couldn&#x27;t create a basic cmake file for that?  When I see lazy unprofessional things like that, it makes me wonder if the whole project is on the same level of incompetence.</div><br/><div id="39889368" class="c"><input type="checkbox" id="c-39889368" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#39889299">parent</a><span>|</span><a href="#39891352">next</a><span>|</span><label class="collapse" for="c-39889368">[-]</label><label class="expand" for="c-39889368">[1 more]</label></div><br/><div class="children"><div class="content">Why would you use cmake to build a single file??</div><br/></div></div></div></div><div id="39891352" class="c"><input type="checkbox" id="c-39891352" checked=""/><div class="controls bullet"><span class="by">carlsborg</span><span>|</span><a href="#39889299">prev</a><span>|</span><label class="collapse" for="c-39891352">[-]</label><label class="expand" for="c-39891352">[1 more]</label></div><br/><div class="children"><div class="content">At this point the focus should be on making interop with python a first class feature.</div><br/></div></div></div></div></div></div></div></body></html>