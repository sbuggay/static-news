<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738573278853" as="style"/><link rel="stylesheet" href="styles.css?v=1738573278853"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3412r0.pdf">F-strings for C++26 proposal [pdf]</a> <span class="domain">(<a href="https://www.open-std.org">www.open-std.org</a>)</span></div><div class="subtext"><span>HeliumHydride</span> | <span>92 comments</span></div><br/><div><div id="42913317" class="c"><input type="checkbox" id="c-42913317" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42913108">next</a><span>|</span><label class="collapse" for="c-42913317">[-]</label><label class="expand" for="c-42913317">[11 more]</label></div><br/><div class="children"><div class="content">So the f-string literal produces a basic_formatted_string, which is basically a reified argument list for std::format, instead of a basic_string. This allows eg. println to be overloaded to operate on basic_formatted_string without allocating an intermediate string<p><pre><code>  std::println(&quot;Center is: {}&quot;, getCenter());
  std::println(f&quot;Center is: {getCenter()}&quot;);  &#x2F;&#x2F; same thing, no basic_string allocated
</code></pre>
In exchange we have the following problems<p><pre><code>  &#x2F;&#x2F; f-strings have unexpected type when using auto or type deduction.
  &#x2F;&#x2F; basic_string is expected here, but we get basic_formatted_string.
  &#x2F;&#x2F; This is especially bad because basic_formatted_string can contain
  &#x2F;&#x2F; dangling references.
  auto s = f&quot;Center is: {getCenter()}&quot;;

  &#x2F;&#x2F; f-strings won&#x27;t work in places where providing a string currently
  &#x2F;&#x2F; works by using implicit conversion. For example, filesystem methods
  &#x2F;&#x2F; take paths. Providing a string is okay, since it will be implicitly
  &#x2F;&#x2F; converted to a path, but an f-string would require two implicit
  &#x2F;&#x2F; conversions, first to a string, then to path.
  std::filesystem::exists(f&quot;file{n}.dat&quot;);  &#x2F;&#x2F; error, no matching overload
</code></pre>
There are two other proposals to fix these problems.</div><br/><div id="42915835" class="c"><input type="checkbox" id="c-42915835" checked=""/><div class="controls bullet"><span class="by">serbuvlad</span><span>|</span><a href="#42913317">parent</a><span>|</span><a href="#42916027">next</a><span>|</span><label class="collapse" for="c-42915835">[-]</label><label class="expand" for="c-42915835">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There are two other proposals to fix these problems.<p>Most new features of C++ are introduced to fix problems created by previously new features added to C++.</div><br/><div id="42916019" class="c"><input type="checkbox" id="c-42916019" checked=""/><div class="controls bullet"><span class="by">blux</span><span>|</span><a href="#42913317">root</a><span>|</span><a href="#42915835">parent</a><span>|</span><a href="#42916027">next</a><span>|</span><label class="collapse" for="c-42916019">[-]</label><label class="expand" for="c-42916019">[2 more]</label></div><br/><div class="children"><div class="content">This is becoming such a tiresome opinion. How are concepts fixing a problem created by previous features to the langue? What about ranges? Auto? Move semantics? Coroutines? Constexpr? Consteval? It is time for this narrative to stop.</div><br/><div id="42916033" class="c"><input type="checkbox" id="c-42916033" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#42913317">root</a><span>|</span><a href="#42916019">parent</a><span>|</span><a href="#42916027">next</a><span>|</span><label class="collapse" for="c-42916033">[-]</label><label class="expand" for="c-42916033">[1 more]</label></div><br/><div class="children"><div class="content">Honestly can&#x27;t tell if this is sarcasm. XD</div><br/></div></div></div></div></div></div><div id="42916027" class="c"><input type="checkbox" id="c-42916027" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#42913317">parent</a><span>|</span><a href="#42915835">prev</a><span>|</span><a href="#42915733">next</a><span>|</span><label class="collapse" for="c-42916027">[-]</label><label class="expand" for="c-42916027">[3 more]</label></div><br/><div class="children"><div class="content">One of the two other proposals is user defined type decay, which lets you choose what type auto will be deduced as. i.e. &quot;auto x = y&quot;, x might not have the type of y, instead it can be anything you choose…<p>This is like implicit type conversion on steroids. And all this because C++ lacks the basic safety features to avoid dangling pointers.<p>Stop using C++ already!</div><br/><div id="42916155" class="c"><input type="checkbox" id="c-42916155" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42913317">root</a><span>|</span><a href="#42916027">parent</a><span>|</span><a href="#42916074">next</a><span>|</span><label class="collapse" for="c-42916155">[-]</label><label class="expand" for="c-42916155">[1 more]</label></div><br/><div class="children"><div class="content">&gt; lacks the basic safety features to avoid dangling pointers<p>It doesn&#x27;t. Unfortunately, C++ programmers choose not to use basic safety features for performance reasons (or aesthetics, or disagreement with the idea that a language should take into account that a programmer might make a mistake, but at least performance is a good one), but C++ actually has quite a few tricks to prevent the memory management issues that cause C&#x2F;C++ bugs.<p>Using modern C++ safety features won&#x27;t completely prevent bugs and memory issues, just like using Rust won&#x27;t, but the mess that causes the worst bugs is the result of a choice, not the language itself.</div><br/></div></div><div id="42916074" class="c"><input type="checkbox" id="c-42916074" checked=""/><div class="controls bullet"><span class="by">thegrim33</span><span>|</span><a href="#42913317">root</a><span>|</span><a href="#42916027">parent</a><span>|</span><a href="#42916155">prev</a><span>|</span><a href="#42915733">next</a><span>|</span><label class="collapse" for="c-42916074">[-]</label><label class="expand" for="c-42916074">[1 more]</label></div><br/><div class="children"><div class="content">Smart pointers were added to the language 14 years ago. You&#x27;re free to use old C++ with raw pointers and manual memory management, risking dangling pointers, or use modern C++, which provides smart pointers to avoid those issues.</div><br/></div></div></div></div><div id="42915733" class="c"><input type="checkbox" id="c-42915733" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#42913317">parent</a><span>|</span><a href="#42916027">prev</a><span>|</span><a href="#42915722">next</a><span>|</span><label class="collapse" for="c-42915733">[-]</label><label class="expand" for="c-42915733">[2 more]</label></div><br/><div class="children"><div class="content">Hah. What&#x27;s interesting about this is that since it doesn&#x27;t require everything to actually be converted to a string, one can implement things other than just printing. So you could also implement interpretation, eg:<p><pre><code>  pylist = python(f&quot;[ y*{coef} for y in {pylist} if y &gt; {threshold}]&quot;)</code></pre></div><br/><div id="42916168" class="c"><input type="checkbox" id="c-42916168" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42913317">root</a><span>|</span><a href="#42915733">parent</a><span>|</span><a href="#42915722">next</a><span>|</span><label class="collapse" for="c-42916168">[-]</label><label class="expand" for="c-42916168">[1 more]</label></div><br/><div class="children"><div class="content">It also allow for things that will set off spidey senses in programmers everywhere despite theoretically being completely safe assuming mydb::sql() handles escaping in the format string:<p><pre><code>   cursor = mydb::sql(f&quot;UPDATE user SET password={password} WHERE user.id={userid}&quot;)</code></pre></div><br/></div></div></div></div><div id="42915722" class="c"><input type="checkbox" id="c-42915722" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42913317">parent</a><span>|</span><a href="#42915733">prev</a><span>|</span><a href="#42913399">next</a><span>|</span><label class="collapse" for="c-42915722">[-]</label><label class="expand" for="c-42915722">[1 more]</label></div><br/><div class="children"><div class="content">This seems pretty similar to Rust&#x27;s `format_args!` macro, which however avoids these issues by being much more verbose and thus something people are less likely to use like in those examples. It does however have issues due to the abundant use of temporaries, which makes it hard to use when not immediately passed to a function. I wonder if C++&#x27;s fstrings have the same issue.</div><br/></div></div><div id="42913399" class="c"><input type="checkbox" id="c-42913399" checked=""/><div class="controls bullet"><span class="by">HeliumHydride</span><span>|</span><a href="#42913317">parent</a><span>|</span><a href="#42915722">prev</a><span>|</span><a href="#42913108">next</a><span>|</span><label class="collapse" for="c-42913399">[-]</label><label class="expand" for="c-42913399">[1 more]</label></div><br/><div class="children"><div class="content">Yes. The basic idea is that there&#x27;s a specifier that allows a formatted string to transparently decay into an ordinary string (à la array-to-pointer decay) so that &quot;auto&quot; doesn&#x27;t produce dangling references, and so that chains of more than one implicit conversion can take place.</div><br/></div></div></div></div><div id="42913108" class="c"><input type="checkbox" id="c-42913108" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#42913317">prev</a><span>|</span><a href="#42915441">next</a><span>|</span><label class="collapse" for="c-42913108">[-]</label><label class="expand" for="c-42913108">[4 more]</label></div><br/><div class="children"><div class="content">Tangent: this sort of thing can be implemented without any change to libc++ (the runtime).  Updates to compiler versions are sometimes postponed by users with big codebases that treat a libc++ change as something major.<p>Why don&#x27;t we see gcc or clang or msvc back porting stuff like this to an older version with a sort of future tag. It&#x27;s normal to see __future__ in the python ecosystem, for instance.</div><br/><div id="42915561" class="c"><input type="checkbox" id="c-42915561" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42913108">parent</a><span>|</span><a href="#42913170">next</a><span>|</span><label class="collapse" for="c-42915561">[-]</label><label class="expand" for="c-42915561">[1 more]</label></div><br/><div class="children"><div class="content">Because C++, just like C, Ada, Cobol, Fortran, Modula-2, Pascal is an ISO driven language.<p>Whereas Python language evolution is driven by whatever CPython reference implementation does.<p>Compilers are free to do whatever they want, but then that code isn&#x27;t portable.</div><br/></div></div><div id="42913170" class="c"><input type="checkbox" id="c-42913170" checked=""/><div class="controls bullet"><span class="by">tart-lemonade</span><span>|</span><a href="#42913108">parent</a><span>|</span><a href="#42915561">prev</a><span>|</span><a href="#42915441">next</a><span>|</span><label class="collapse" for="c-42913170">[-]</label><label class="expand" for="c-42913170">[2 more]</label></div><br/><div class="children"><div class="content">If a codebase is fragile enough that libc++ changes have to be assumed breaking until proven otherwise, why take the risk? Presumably the application already has a &quot;standard&quot; way of formatting strings. If it ain&#x27;t broke yada yada</div><br/><div id="42913354" class="c"><input type="checkbox" id="c-42913354" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#42913108">root</a><span>|</span><a href="#42913170">parent</a><span>|</span><a href="#42915441">next</a><span>|</span><label class="collapse" for="c-42913354">[-]</label><label class="expand" for="c-42913354">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about assumed breaking, it&#x27;s that when you upgrade libc++ you can become incompatible at runtime with your distro or any other number of libraries outside your control in ways that are difficult to detect</div><br/></div></div></div></div></div></div><div id="42915441" class="c"><input type="checkbox" id="c-42915441" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#42913108">prev</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42915441">[-]</label><label class="expand" for="c-42915441">[12 more]</label></div><br/><div class="children"><div class="content">Like the compile time isn&#x27;t long enough. They should just let the compiler do the job like Wformat=2 and skip any preprocess and constexpr function.</div><br/><div id="42915573" class="c"><input type="checkbox" id="c-42915573" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42915441">parent</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42915573">[-]</label><label class="expand" for="c-42915573">[11 more]</label></div><br/><div class="children"><div class="content">It is fast enough when using precompiled headers, binary libraries, and best of all C++20 modules with C++23 modularised standard library.<p>Could it be better?  Most likely.</div><br/><div id="42915604" class="c"><input type="checkbox" id="c-42915604" checked=""/><div class="controls bullet"><span class="by">grandempire</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915573">parent</a><span>|</span><a href="#42915603">next</a><span>|</span><label class="collapse" for="c-42915604">[-]</label><label class="expand" for="c-42915604">[3 more]</label></div><br/><div class="children"><div class="content">&gt; best of all C++20 modules<p>Do any compilers besides VS support this?</div><br/><div id="42915631" class="c"><input type="checkbox" id="c-42915631" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915604">parent</a><span>|</span><a href="#42915689">next</a><span>|</span><label class="collapse" for="c-42915631">[-]</label><label class="expand" for="c-42915631">[1 more]</label></div><br/><div class="children"><div class="content">Clang with CMake and ninja as build system (cmake.js for nodejs does as well).<p>The only missing piece is that cmake is still in the process to support header units.<p>GCC is getting there.</div><br/></div></div><div id="42915689" class="c"><input type="checkbox" id="c-42915689" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915604">parent</a><span>|</span><a href="#42915631">prev</a><span>|</span><a href="#42915603">next</a><span>|</span><label class="collapse" for="c-42915689">[-]</label><label class="expand" for="c-42915689">[1 more]</label></div><br/><div class="children"><div class="content">GCC supports it with a flag. C++23&#x27;s import std is not there at all though.</div><br/></div></div></div></div><div id="42915603" class="c"><input type="checkbox" id="c-42915603" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915573">parent</a><span>|</span><a href="#42915604">prev</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42915603">[-]</label><label class="expand" for="c-42915603">[7 more]</label></div><br/><div class="children"><div class="content">C++ modules do not exist in practice and probably never will.</div><br/><div id="42915638" class="c"><input type="checkbox" id="c-42915638" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915603">parent</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42915638">[-]</label><label class="expand" for="c-42915638">[6 more]</label></div><br/><div class="children"><div class="content">Office team apparently is of another opinion, as Vulkan folks, and a few other early adopters.<p>You could just as well say that anything beyond C89 doesn&#x27;t exist, given its prevalence in some circles.</div><br/><div id="42915708" class="c"><input type="checkbox" id="c-42915708" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915638">parent</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42915708">[-]</label><label class="expand" for="c-42915708">[5 more]</label></div><br/><div class="children"><div class="content">Yes. There are a very small handful of early adopters in the year 2025 for a feature ostensibly added in C++20.<p>So, like I said, modules don’t exist in practice and I’d be shocked if in 2030 modules were considered normal.<p>C++11 was pretty game changing. C++14 and C++17 only took a few years to reach widespread adoption.<p>It’s very safe to require C++17 today. C++20 was a little slower and because of the modules fuckup it’s a bit inconsistent. But it’s largely fine to use.<p>C++23 probably needs another year or two. But also C++20 and beyond haven’t added much that’s worth upgrading for.</div><br/><div id="42915954" class="c"><input type="checkbox" id="c-42915954" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915708">parent</a><span>|</span><a href="#42915997">next</a><span>|</span><label class="collapse" for="c-42915954">[-]</label><label class="expand" for="c-42915954">[2 more]</label></div><br/><div class="children"><div class="content">Like I said, it is a matter of point of view, and yes such is the karma of ISO driven languages with multiple implementations, when one cares about cross platform code.<p>There are many folks that don&#x27;t care though, for them it is <i>&quot;one platform, one compiler, language standard is whatever my compiler allows me to do, including extensions&quot;</i>.<p>I am also quite bullish on the opinion that eventually,  C++26 might be the last standard, not that WG21 will stop working on new ones, rather that is what many will care about when using C++ in a polyglot environment, as it is already the case in mobile OS platforms, the two major desktop platforms and distributed computing (CNCF project landscape).<p>Why C++26 and not earlier? Reflection.</div><br/><div id="42916004" class="c"><input type="checkbox" id="c-42916004" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915954">parent</a><span>|</span><a href="#42915997">next</a><span>|</span><label class="collapse" for="c-42916004">[-]</label><label class="expand" for="c-42916004">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Reflection<p>Oh yes please! :-)</div><br/></div></div></div></div><div id="42915997" class="c"><input type="checkbox" id="c-42915997" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915708">parent</a><span>|</span><a href="#42915954">prev</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42915997">[-]</label><label class="expand" for="c-42915997">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  C++20 and beyond haven’t added much that’s worth upgrading for.<p>std::format is pretty nice (although not yet available on Ubuntu 24.04 LTS.<p>Lambda capture of parameter packs is actually huge!<p>And ... I think it still remains to be see what the outcome of modules will be.<p>One hopes (against hope) that the big payoff for modules will be in tool-ability of C++. IDE support for languages like C#, Java, typescript is vastly superior to C++ IDE tooling. Perhaps. Maybe. Modules will provide a path that will allow that to change. I don&#x27;t think the benefits of modules have yet fully played out.</div><br/><div id="42916109" class="c"><input type="checkbox" id="c-42916109" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42915441">root</a><span>|</span><a href="#42915997">parent</a><span>|</span><a href="#42915884">next</a><span>|</span><label class="collapse" for="c-42916109">[-]</label><label class="expand" for="c-42916109">[1 more]</label></div><br/><div class="children"><div class="content">Ironically C++ had such tooling in the past but got lost, a bit like Roman technology as the Empire felt.<p>Visual Age for C++ v4.0 had a Smalltalk like experience with a database storage for the code, and Lucid Energize C++ already had something that people now know as LSP (Cadillac on their implementation), with incremental compilation and linking (at method&#x2F;function level).<p>They failed commercially due to high prices and hardware requirements.<p>We have had C++ Builder for decades for GUI RAD development, Delphi&#x2F;VB style, but due to how Borland went after the enterprise and various changes of hands, very few are aware that it exists and its capabilities.<p>C++ Builder with VCL was Java&#x2F;.NET before these were even an idea looking for an implementation.<p>Problem now is that C++ has become a specialized tooling for high performance code, language runtimes, drivers and GPGPU, so you write 90% of the code in Java&#x2F;C#&#x2F;nodejs&#x2F;..... and then reach out to native libraries, for various reasons.<p>Still, Clion, Visual Studio, C++ Builder, are quite good as far as development experience goes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42915884" class="c"><input type="checkbox" id="c-42915884" checked=""/><div class="controls bullet"><span class="by">Laiho</span><span>|</span><a href="#42915441">prev</a><span>|</span><a href="#42916206">next</a><span>|</span><label class="collapse" for="c-42915884">[-]</label><label class="expand" for="c-42915884">[4 more]</label></div><br/><div class="children"><div class="content">Is it a coincidence that all these quality life things start to pop up after C++ is facing real competition for the first time? Seems a bit odd to add print after using std::out for 30 years.</div><br/><div id="42915888" class="c"><input type="checkbox" id="c-42915888" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#42915884">parent</a><span>|</span><a href="#42916206">next</a><span>|</span><label class="collapse" for="c-42915888">[-]</label><label class="expand" for="c-42915888">[3 more]</label></div><br/><div class="children"><div class="content">What is this referring to? I would imagine whatever you consider recent competition is actually not that recent.</div><br/><div id="42915899" class="c"><input type="checkbox" id="c-42915899" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#42915884">root</a><span>|</span><a href="#42915888">parent</a><span>|</span><a href="#42916206">next</a><span>|</span><label class="collapse" for="c-42915899">[-]</label><label class="expand" for="c-42915899">[2 more]</label></div><br/><div class="children"><div class="content">On the time scale of c++, rust is very recent. :-)</div><br/><div id="42916100" class="c"><input type="checkbox" id="c-42916100" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42915884">root</a><span>|</span><a href="#42915899">parent</a><span>|</span><a href="#42916206">next</a><span>|</span><label class="collapse" for="c-42916100">[-]</label><label class="expand" for="c-42916100">[1 more]</label></div><br/><div class="children"><div class="content">Nerd alt-history story: What if Graydon decides he should attend WG21 and so instead of Rust what we get is a decade of attempts to fix C++ and reform the process, followed by burn out?</div><br/></div></div></div></div></div></div></div></div><div id="42916206" class="c"><input type="checkbox" id="c-42916206" checked=""/><div class="controls bullet"><span class="by">nickysielicki</span><span>|</span><a href="#42915884">prev</a><span>|</span><a href="#42915898">next</a><span>|</span><label class="collapse" for="c-42916206">[-]</label><label class="expand" for="c-42916206">[1 more]</label></div><br/><div class="children"><div class="content">Reflection is going to change things so much.</div><br/></div></div><div id="42915898" class="c"><input type="checkbox" id="c-42915898" checked=""/><div class="controls bullet"><span class="by">biofox</span><span>|</span><a href="#42916206">prev</a><span>|</span><a href="#42913319">next</a><span>|</span><label class="collapse" for="c-42915898">[-]</label><label class="expand" for="c-42915898">[2 more]</label></div><br/><div class="children"><div class="content">Making any changes to the core language is a sensitive thing as it inevitably imposes new demands on compilers, a learning curve for all users of the language, and risks breaking compatibility and introducing unforeseen issues that will need to be fixed with future changes to the language.<p>Personally, I&#x27;d much prefer a smaller and more stable language.</div><br/><div id="42915960" class="c"><input type="checkbox" id="c-42915960" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42915898">parent</a><span>|</span><a href="#42913319">next</a><span>|</span><label class="collapse" for="c-42915960">[-]</label><label class="expand" for="c-42915960">[1 more]</label></div><br/><div class="children"><div class="content">Leaving curve can decrease as a result of better design, same re. the chance of those unforeseen issues (and it can even decrease the chance of existing bugs popping up)</div><br/></div></div></div></div><div id="42913319" class="c"><input type="checkbox" id="c-42913319" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#42915898">prev</a><span>|</span><a href="#42913701">next</a><span>|</span><label class="collapse" for="c-42913319">[-]</label><label class="expand" for="c-42913319">[5 more]</label></div><br/><div class="children"><div class="content">This links to a “decays_to” proposal:<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p3398r0.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p33...</a><p>And observes that this additional feature is needed to avoid dangling references.  And, as a long time C++ programmer, this illustrates one of the things I dislike most about C++.  In most languages, if you make a little mistake involving mixing up something that references something else with something that contains a copy, you end up with potential overhead or maybe accidental mutation.  In Rust,  you get a compiler error. In C++, you get use-after-free, and the code often even seems to work!<p>So now we expect people to type:<p><pre><code>    auto s = f&quot;{foo}&quot;;
</code></pre>
And those people expect s to act like a string. But the designers (reasonably!) do not want f to unconditionally produce an actual std::string for efficiency reasons, so there’s a proposal to allow f to produce a reference-like type (that’s a class value, not actually a reference), but for s to actually be std::string.<p>But, of course, more advanced users might know what they’re doing and want to bypass this hack, so:<p><pre><code>    explicit auto s = f&quot;{foo}&quot;;
</code></pre>
Does what they programmer actually typed: s captures foo by reference.<p>What could possibly go wrong?<p>(Rust IMO gets this exactly right: shared xor mutable means plus disallowing code that would be undefined behavior means that the cases like this where the code might do the wrong thing <i>don’t compile</i>.  Critically, none of this actually strictly requires Rust’s approach to memory management, although a GC’d version might end up with (deterministic) runtime errors instead unless some extra work is done to have stronger static checking. And I think other languages should learn from this.)</div><br/><div id="42913463" class="c"><input type="checkbox" id="c-42913463" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42913319">parent</a><span>|</span><a href="#42913767">next</a><span>|</span><label class="collapse" for="c-42913463">[-]</label><label class="expand" for="c-42913463">[2 more]</label></div><br/><div class="children"><div class="content">IOW I believe it&#x27;s the same thing as Rust&#x27;s format_args! macro, but trying to get away without needing a separate format! macro by using implicit conversions.</div><br/><div id="42913855" class="c"><input type="checkbox" id="c-42913855" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42913319">root</a><span>|</span><a href="#42913463">parent</a><span>|</span><a href="#42913767">next</a><span>|</span><label class="collapse" for="c-42913855">[-]</label><label class="expand" for="c-42913855">[1 more]</label></div><br/><div class="children"><div class="content">std::format_args! gets you a Arguments&lt;&#x27;a&gt; which we&#x27;ll note means it has an associated lifetime.<p>Today-I-learned, Arguments&lt;&#x27;a&gt; has a single useful function, which appeared before I learned Rust but only very recently became usable in compile time constants, as_str() -&gt; Option&lt;&amp;&#x27;static str&gt;<p>format_args!(&quot;Boo!&quot;).as_str() is Some(&quot;Boo!&quot;)<p>If you format a literal, this always works, if you format some non-literal the compiler <i>might</i> realise the answer is a compile time fixed string anyway and give you that string, but it might not even if you think it should and no promises are given.</div><br/></div></div></div></div><div id="42913767" class="c"><input type="checkbox" id="c-42913767" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42913319">parent</a><span>|</span><a href="#42913463">prev</a><span>|</span><a href="#42913701">next</a><span>|</span><label class="collapse" for="c-42913767">[-]</label><label class="expand" for="c-42913767">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But, of course, more advanced users might know what they’re doing and want to bypass this hack, so:<p><pre><code>    explicit auto s = f&quot;{foo}&quot;;
</code></pre>
&gt; Does what they programmer actually typed, so s captures foo by reference.<p>Wouldn&#x27;t this problem be best solved by... not declaring s to have a guess-what-I-mean type? If you want to be explicit about the type of s, why not just say what that type is? Wouldn&#x27;t that be <i>even more explicit</i> than &quot;explicit auto&quot;?</div><br/><div id="42913872" class="c"><input type="checkbox" id="c-42913872" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#42913319">root</a><span>|</span><a href="#42913767">parent</a><span>|</span><a href="#42913701">next</a><span>|</span><label class="collapse" for="c-42913872">[-]</label><label class="expand" for="c-42913872">[1 more]</label></div><br/><div class="children"><div class="content">A general issue with C++ (and many statically typed languages with generic) is hilariously long type names that may even be implementation details. Using auto can be a huge time saver and even necessary for some generic code. And people get in the habit of using it.</div><br/></div></div></div></div></div></div><div id="42913701" class="c"><input type="checkbox" id="c-42913701" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42913319">prev</a><span>|</span><a href="#42913084">next</a><span>|</span><label class="collapse" for="c-42913701">[-]</label><label class="expand" for="c-42913701">[18 more]</label></div><br/><div class="children"><div class="content">Somehow I manage to get by just fine with c++11. I have refactored more than a few codebases that use 17 or greater.<p>Strangely, the codebase became more maintainable afterwards.</div><br/><div id="42915454" class="c"><input type="checkbox" id="c-42915454" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#42913701">parent</a><span>|</span><a href="#42914230">next</a><span>|</span><label class="collapse" for="c-42915454">[-]</label><label class="expand" for="c-42915454">[3 more]</label></div><br/><div class="children"><div class="content">C++20&#x27;s concepts IMHO are a massive update over C++11. You can basically remove almost 90% of inheritance with them without incurring in any issue (you could do that earlier too, but at the expense of incredibly hard to read error messages - now that&#x27;s basically solved thanks to concepts).</div><br/><div id="42916045" class="c"><input type="checkbox" id="c-42916045" checked=""/><div class="controls bullet"><span class="by">derriz</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42915454">parent</a><span>|</span><a href="#42915711">next</a><span>|</span><label class="collapse" for="c-42916045">[-]</label><label class="expand" for="c-42916045">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t find the error messages produced by concepts much better than old school template errors.  Maybe I got used to the latter with experience and definitely the compilers got better at generating useful error messages for templates as the years passed.  On the other hand when I have to review code where a significant portion of the source relates to concepts, my heart sinks.<p>In my opinion, C++ &quot;concepts&quot; are the least useful C++20 addition to the language - awful syntax, redundancy everywhere (multiple ways of writing the same thing).  And for what?  Potentially better error messages?<p>Another gripe; of all the generic overloaded words available to describe this C++ feature, &quot;concept&quot; must be the least descriptive, least useful.  Why pick such a meaningless name that does absolutely nothing to even suggest what the feature does?</div><br/></div></div><div id="42915711" class="c"><input type="checkbox" id="c-42915711" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42915454">parent</a><span>|</span><a href="#42916045">prev</a><span>|</span><a href="#42914230">next</a><span>|</span><label class="collapse" for="c-42915711">[-]</label><label class="expand" for="c-42915711">[1 more]</label></div><br/><div class="children"><div class="content">C++ concepts are a failure due to them only checking one side of the contract. And the other is basically impossible to implement without breaking other parts of the language</div><br/></div></div></div></div><div id="42914230" class="c"><input type="checkbox" id="c-42914230" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#42913701">parent</a><span>|</span><a href="#42915454">prev</a><span>|</span><a href="#42913084">next</a><span>|</span><label class="collapse" for="c-42914230">[-]</label><label class="expand" for="c-42914230">[14 more]</label></div><br/><div class="children"><div class="content">Came here to post the same thing. C++11 was a major and <i>practical</i> step up from previous versions. I haven&#x27;t seen anything in future standards that looked like it a tool I&#x27;d use day-to-day building actual production software. Much of the subsequent versions added things probably interesting to compiler and language academics. &quot;Default constructible and assignable stateless lambdas?&quot; Really?</div><br/><div id="42914397" class="c"><input type="checkbox" id="c-42914397" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914230">parent</a><span>|</span><a href="#42914556">next</a><span>|</span><label class="collapse" for="c-42914397">[-]</label><label class="expand" for="c-42914397">[8 more]</label></div><br/><div class="children"><div class="content">Off the top of my head, C++17 brought slicker notation for nested namespaces, digit separators for numeric literals (so you can more easily read 1&#x27;000&#x27;000&#x27;000),  improvements in type deduction for pairs &#x2F; tuples (so std::make_pair &#x2F; make_tuple are basically unnecessary now), guarantees in the standard for copy elision &#x2F; return value optimization in specific circumstances,. Oh, and structured bindings (so you can now write `for (const auto&amp; [key, value] : map) { ... }`).<p>edit: I guess digit separators came in C++14, I&#x27;m always a little fuzzy there since at work, we jumped straight from 11 -&gt; 17.<p>C++20 brought a feature that C had decades prior: designated initializers, except it&#x27;s in a slightly crappier form. Also, spaceship operator (three-way comparison).<p>Looking at cppreference, it looks like C++17 also brought if constexpr, and standardized a bunch of nonstandard compiler extensions like [[fallthrough]]. C++20 continued standardizing more of those extensions, and also brought concepts &#x2F; constraints, which are a lot easier to use than template metaprogramming.<p>You&#x27;re at least somewhat right though -- none of these are paradigm shifts as C++11 was compared to C++03 (especially with the notion of ownership, especially in the context of std::unique_ptr and std::move).</div><br/><div id="42914537" class="c"><input type="checkbox" id="c-42914537" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914397">parent</a><span>|</span><a href="#42914977">next</a><span>|</span><label class="collapse" for="c-42914537">[-]</label><label class="expand" for="c-42914537">[4 more]</label></div><br/><div class="children"><div class="content">17 is worth it for std::filesystem alone. It also has optional and variant.</div><br/><div id="42915362" class="c"><input type="checkbox" id="c-42915362" checked=""/><div class="controls bullet"><span class="by">fsloth</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914537">parent</a><span>|</span><a href="#42914977">next</a><span>|</span><label class="collapse" for="c-42915362">[-]</label><label class="expand" for="c-42915362">[3 more]</label></div><br/><div class="children"><div class="content">Filesystem is great. It’s insane it took so long.<p>Optional is nice but slightly awkward in a non-garbage collected language.<p>IMO variant is one of those things that should not exist in standard.<p>It tries to implement discriminated union in C++ but that feature is lame without true pattern matching. And you can’t implement pattern matching without thorough syntax level support. So in my books it’s in this academic “let’s pretend a while we are using some other language…” category.<p>It’s _occassionally_ convenient for sure.</div><br/><div id="42916228" class="c"><input type="checkbox" id="c-42916228" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42915362">parent</a><span>|</span><a href="#42915600">next</a><span>|</span><label class="collapse" for="c-42916228">[-]</label><label class="expand" for="c-42916228">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It tries to implement discriminated union in C++ but that feature is lame without true pattern matching. And you can’t implement pattern matching without thorough syntax level support. So in my books it’s in this academic “let’s pretend a while we are using some other language…” category.<p>I agree, they should have made it a language&#x2F;syntax feature. However: if you wanna do a sum type, it does do that. I&#x27;d rather have that than nothing.</div><br/></div></div><div id="42915600" class="c"><input type="checkbox" id="c-42915600" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42915362">parent</a><span>|</span><a href="#42916228">prev</a><span>|</span><a href="#42914977">next</a><span>|</span><label class="collapse" for="c-42915600">[-]</label><label class="expand" for="c-42915600">[1 more]</label></div><br/><div class="children"><div class="content">Might still land on C++26, but most likely C++29, then you&#x27;ll have pattern matching.</div><br/></div></div></div></div></div></div><div id="42914977" class="c"><input type="checkbox" id="c-42914977" checked=""/><div class="controls bullet"><span class="by">darknavi</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914397">parent</a><span>|</span><a href="#42914537">prev</a><span>|</span><a href="#42914798">next</a><span>|</span><label class="collapse" for="c-42914977">[-]</label><label class="expand" for="c-42914977">[2 more]</label></div><br/><div class="children"><div class="content">Designated initializers are so nice.  Even though they have C++-isms like required order, it adds safety and readability to code.</div><br/><div id="42916087" class="c"><input type="checkbox" id="c-42916087" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914977">parent</a><span>|</span><a href="#42914798">next</a><span>|</span><label class="collapse" for="c-42916087">[-]</label><label class="expand" for="c-42916087">[1 more]</label></div><br/><div class="children"><div class="content">The safety and readability are nice; but WHY do they have to be in order? That is so typically clueless. Such an obvious feature, screwed up in a way that only a C++ committee member could.</div><br/></div></div></div></div></div></div><div id="42914556" class="c"><input type="checkbox" id="c-42914556" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914230">parent</a><span>|</span><a href="#42914397">prev</a><span>|</span><a href="#42914527">next</a><span>|</span><label class="collapse" for="c-42914556">[-]</label><label class="expand" for="c-42914556">[4 more]</label></div><br/><div class="children"><div class="content">constexpr in 11 vs 14 was night and day difference.</div><br/><div id="42914941" class="c"><input type="checkbox" id="c-42914941" checked=""/><div class="controls bullet"><span class="by">anonnon</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914556">parent</a><span>|</span><a href="#42914527">next</a><span>|</span><label class="collapse" for="c-42914941">[-]</label><label class="expand" for="c-42914941">[3 more]</label></div><br/><div class="children"><div class="content">constexpr &quot;if&quot; statements (C++20) are also a game-changer.</div><br/><div id="42915363" class="c"><input type="checkbox" id="c-42915363" checked=""/><div class="controls bullet"><span class="by">boguscoder</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914941">parent</a><span>|</span><a href="#42914527">next</a><span>|</span><label class="collapse" for="c-42915363">[-]</label><label class="expand" for="c-42915363">[2 more]</label></div><br/><div class="children"><div class="content">Those are c++17</div><br/><div id="42915619" class="c"><input type="checkbox" id="c-42915619" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42915363">parent</a><span>|</span><a href="#42914527">next</a><span>|</span><label class="collapse" for="c-42915619">[-]</label><label class="expand" for="c-42915619">[1 more]</label></div><br/><div class="children"><div class="content">Initially, C++20 and C++23 extended its use cases, and combined with concepts is a pretty sweet spot for compile time metaprogramming without SFINAE or tag dispatch tricks.<p>Much better than having yet another syntax for macros.</div><br/></div></div></div></div></div></div></div></div><div id="42914527" class="c"><input type="checkbox" id="c-42914527" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#42913701">root</a><span>|</span><a href="#42914230">parent</a><span>|</span><a href="#42914556">prev</a><span>|</span><a href="#42913084">next</a><span>|</span><label class="collapse" for="c-42914527">[-]</label><label class="expand" for="c-42914527">[1 more]</label></div><br/><div class="children"><div class="content">To me moving from C++11 to 17 and then 20 was just a matter of convenience. When digging on how to do this and that I&#x27;ve found few things that just saved my time here and there. Also couple of valuable libs I wanted to use required newer C++ versions.</div><br/></div></div></div></div></div></div><div id="42913084" class="c"><input type="checkbox" id="c-42913084" checked=""/><div class="controls bullet"><span class="by">puffybuf</span><span>|</span><a href="#42913701">prev</a><span>|</span><a href="#42916048">next</a><span>|</span><label class="collapse" for="c-42913084">[-]</label><label class="expand" for="c-42913084">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure boost::format can do this, though not inline in the string. Do we really need more complexity in cpp? isn&#x27;t it complex enough?</div><br/><div id="42913115" class="c"><input type="checkbox" id="c-42913115" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#42913084">parent</a><span>|</span><a href="#42913126">next</a><span>|</span><label class="collapse" for="c-42913115">[-]</label><label class="expand" for="c-42913115">[10 more]</label></div><br/><div class="children"><div class="content">This is the sort of change that adds complexity to the language but reduces complexity in the code written in the language. We take those</div><br/><div id="42914328" class="c"><input type="checkbox" id="c-42914328" checked=""/><div class="controls bullet"><span class="by">hackyhacky</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913115">parent</a><span>|</span><a href="#42913187">next</a><span>|</span><label class="collapse" for="c-42914328">[-]</label><label class="expand" for="c-42914328">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This is the sort of change that adds complexity to the language but reduces complexity in the code written in the language. We take those<p>An admirable statement of policy, but I&#x27;m not sure it&#x27;s possible. Adding complexity to the language means there are more gotchas and edge-cases that a programmer must consider, even if they don&#x27;t use the feature in question.</div><br/><div id="42915403" class="c"><input type="checkbox" id="c-42915403" checked=""/><div class="controls bullet"><span class="by">truncate</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42914328">parent</a><span>|</span><a href="#42915389">next</a><span>|</span><label class="collapse" for="c-42915403">[-]</label><label class="expand" for="c-42915403">[1 more]</label></div><br/><div class="children"><div class="content">Depends on case to case basis. I wouldn&#x27;t generalize it to every case. As a daily C++ engineer, I think overall many features added over the years have mostly been positive. There are features that I don&#x27;t use and I don&#x27;t think it really affects much. That said, I do get the sentiment of language becoming too syntactically complex.<p>I like this feature as string formatting is something frequently used and this certainly looks cleaner and quicker to write.</div><br/></div></div><div id="42915389" class="c"><input type="checkbox" id="c-42915389" checked=""/><div class="controls bullet"><span class="by">verall</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42914328">parent</a><span>|</span><a href="#42915403">prev</a><span>|</span><a href="#42913187">next</a><span>|</span><label class="collapse" for="c-42915389">[-]</label><label class="expand" for="c-42915389">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Adding complexity to the language means there are more gotchas and edge-cases that a programmer must consider, even if they don&#x27;t use the feature in question.<p>Since this is C++, this is not a problem we have to consider</div><br/><div id="42915578" class="c"><input type="checkbox" id="c-42915578" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42915389">parent</a><span>|</span><a href="#42913187">next</a><span>|</span><label class="collapse" for="c-42915578">[-]</label><label class="expand" for="c-42915578">[1 more]</label></div><br/><div class="children"><div class="content">This is a meme by now, yet it isn&#x27;t as if Python 3.13 is a simple as Python 1.0, Java 23 versus Java 1.0, .NET 9 with C# 13 versus .NET 1.0 with C# 1.0 and a Framework reboot,....</div><br/></div></div></div></div></div></div><div id="42913187" class="c"><input type="checkbox" id="c-42913187" checked=""/><div class="controls bullet"><span class="by">puffybuf</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913115">parent</a><span>|</span><a href="#42914328">prev</a><span>|</span><a href="#42913126">next</a><span>|</span><label class="collapse" for="c-42913187">[-]</label><label class="expand" for="c-42913187">[5 more]</label></div><br/><div class="children"><div class="content">how would this work with internationalized strings? especially if you have to change the order of things? You&#x27;d still need a string version with object ordering I would think</div><br/><div id="42913383" class="c"><input type="checkbox" id="c-42913383" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913187">parent</a><span>|</span><a href="#42913346">next</a><span>|</span><label class="collapse" for="c-42913383">[-]</label><label class="expand" for="c-42913383">[2 more]</label></div><br/><div class="children"><div class="content">f-strings are not an internationalization library.</div><br/><div id="42913809" class="c"><input type="checkbox" id="c-42913809" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913383">parent</a><span>|</span><a href="#42913346">next</a><span>|</span><label class="collapse" for="c-42913809">[-]</label><label class="expand" for="c-42913809">[1 more]</label></div><br/><div class="children"><div class="content">The question was, how would you use this if you have i18n requirements. Format strings are normally part of a translation. I think the bad answer is to embed the entire f-string for a translation as usual, except this can&#x27;t work because C++ f-strings would need to be compiled. The better answer is, don&#x27;t use f-strings for this because you don&#x27;t want translators to monkey around with code and you don&#x27;t want to compile 50 versions of your code.</div><br/></div></div></div></div><div id="42913346" class="c"><input type="checkbox" id="c-42913346" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913187">parent</a><span>|</span><a href="#42913383">prev</a><span>|</span><a href="#42913126">next</a><span>|</span><label class="collapse" for="c-42913346">[-]</label><label class="expand" for="c-42913346">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m skeptical that people would want to do this in a single expression.</div><br/><div id="42916149" class="c"><input type="checkbox" id="c-42916149" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913346">parent</a><span>|</span><a href="#42913126">next</a><span>|</span><label class="collapse" for="c-42916149">[-]</label><label class="expand" for="c-42916149">[1 more]</label></div><br/><div class="children"><div class="content">Do what? Allow translators to reorder the appearance of arguments in a translated format string? It&#x27;s a completely routine (and completely necessary) feature when 
doing translations.</div><br/></div></div></div></div></div></div></div></div><div id="42913126" class="c"><input type="checkbox" id="c-42913126" checked=""/><div class="controls bullet"><span class="by">HeliumHydride</span><span>|</span><a href="#42913084">parent</a><span>|</span><a href="#42913115">prev</a><span>|</span><a href="#42913154">next</a><span>|</span><label class="collapse" for="c-42913126">[-]</label><label class="expand" for="c-42913126">[2 more]</label></div><br/><div class="children"><div class="content">C++ also has std::format, which was introduced in C++20. This is just sugar on top of it, except it also returns a container type so that printing functions can have overloads that format into a file or stream directly from an f-string, instead of going through the overhead of a temporary string.</div><br/><div id="42916171" class="c"><input type="checkbox" id="c-42916171" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913126">parent</a><span>|</span><a href="#42913154">next</a><span>|</span><label class="collapse" for="c-42916171">[-]</label><label class="expand" for="c-42916171">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wonder what this mysterious application is that is doing heavy formatting of strings but can&#x27;t afford the overhead of a temporary string, and therefore requires horrifying and inscrutable and dangerous language extensions.</div><br/></div></div></div></div><div id="42913154" class="c"><input type="checkbox" id="c-42913154" checked=""/><div class="controls bullet"><span class="by">richrichardsson</span><span>|</span><a href="#42913084">parent</a><span>|</span><a href="#42913126">prev</a><span>|</span><a href="#42913129">next</a><span>|</span><label class="collapse" for="c-42913154">[-]</label><label class="expand" for="c-42913154">[3 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s less complex bringing in a 3rd party library and having to pass arguments?<p>fmt library can also do something similar, but still requires the complexity of adding the library and passing arguments.</div><br/><div id="42913199" class="c"><input type="checkbox" id="c-42913199" checked=""/><div class="controls bullet"><span class="by">hyperpl</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913154">parent</a><span>|</span><a href="#42913129">next</a><span>|</span><label class="collapse" for="c-42913199">[-]</label><label class="expand" for="c-42913199">[2 more]</label></div><br/><div class="children"><div class="content">especially bringing in boost which isn&#x27;t allowed in some codebases</div><br/><div id="42913533" class="c"><input type="checkbox" id="c-42913533" checked=""/><div class="controls bullet"><span class="by">krater23</span><span>|</span><a href="#42913084">root</a><span>|</span><a href="#42913199">parent</a><span>|</span><a href="#42913129">next</a><span>|</span><label class="collapse" for="c-42913533">[-]</label><label class="expand" for="c-42913533">[1 more]</label></div><br/><div class="children"><div class="content">boot is not allowed caused by the complexity. So some people disallow boost, here is the solution, just add the complexity directly to the language definition!</div><br/></div></div></div></div></div></div><div id="42913129" class="c"><input type="checkbox" id="c-42913129" checked=""/><div class="controls bullet"><span class="by">nikhilsimha</span><span>|</span><a href="#42913084">parent</a><span>|</span><a href="#42913154">prev</a><span>|</span><a href="#42916048">next</a><span>|</span><label class="collapse" for="c-42913129">[-]</label><label class="expand" for="c-42913129">[1 more]</label></div><br/><div class="children"><div class="content">just skimmed the proposal, dont see how inline rendered f-strings are more complicated than the alternative.</div><br/></div></div></div></div><div id="42916048" class="c"><input type="checkbox" id="c-42916048" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#42913084">prev</a><span>|</span><a href="#42913951">next</a><span>|</span><label class="collapse" for="c-42916048">[-]</label><label class="expand" for="c-42916048">[3 more]</label></div><br/><div class="children"><div class="content">Jesus. This is such a bad idea. Don&#x27;t repeat the mistakes of Python. Look at what Swift does and make a SANE system ffs.</div><br/><div id="42916255" class="c"><input type="checkbox" id="c-42916255" checked=""/><div class="controls bullet"><span class="by">VagabundoP</span><span>|</span><a href="#42916048">parent</a><span>|</span><a href="#42916177">next</a><span>|</span><label class="collapse" for="c-42916255">[-]</label><label class="expand" for="c-42916255">[1 more]</label></div><br/><div class="children"><div class="content">Most people really like python f-strings.<p>You might be on your own here.</div><br/></div></div><div id="42916177" class="c"><input type="checkbox" id="c-42916177" checked=""/><div class="controls bullet"><span class="by">hikarudo</span><span>|</span><a href="#42916048">parent</a><span>|</span><a href="#42916255">prev</a><span>|</span><a href="#42913951">next</a><span>|</span><label class="collapse" for="c-42916177">[-]</label><label class="expand" for="c-42916177">[1 more]</label></div><br/><div class="children"><div class="content">Sincere question: what&#x27;s wrong with Python f-strings?</div><br/></div></div></div></div><div id="42913951" class="c"><input type="checkbox" id="c-42913951" checked=""/><div class="controls bullet"><span class="by">andyg_blog</span><span>|</span><a href="#42916048">prev</a><span>|</span><a href="#42914665">next</a><span>|</span><label class="collapse" for="c-42913951">[-]</label><label class="expand" for="c-42913951">[1 more]</label></div><br/><div class="children"><div class="content">I agree that we should have safe-by-default &quot;decay&quot; behavior to a plain ol std::string, but I&#x27;m also picking up that many aren&#x27;t certain it&#x27;s a useful syntactic sugar in top of the fmt lib? Many other languages have this same syntax and it quickly becomes your go-to way to concatenate variables into a string. Even if it didn&#x27;t handle utf-8 out of the box, so what? The amount of utility is still worth it.</div><br/></div></div><div id="42914665" class="c"><input type="checkbox" id="c-42914665" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42913951">prev</a><span>|</span><a href="#42915502">next</a><span>|</span><label class="collapse" for="c-42914665">[-]</label><label class="expand" for="c-42914665">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to make an asinine prediction. We will be exploring F-strings in future languages in 100 years time, encountering the same problems and questions.<p>I still use printf semantics in Python3 despite trying to get with the program for symbolic string&#x2F;template logic. I don&#x27;t need to be told it&#x27;s better, I need some Philip-K-Dick level brain re-wiring not to reach for<p><pre><code>  &quot;%d things I hate about f-strings\n&quot; % (int(many())) 
</code></pre>
modes of thinking.</div><br/><div id="42916094" class="c"><input type="checkbox" id="c-42916094" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42914665">parent</a><span>|</span><a href="#42915502">next</a><span>|</span><label class="collapse" for="c-42916094">[-]</label><label class="expand" for="c-42916094">[1 more]</label></div><br/><div class="children"><div class="content">Bless compilers able to catch wrong format specifiers.</div><br/></div></div></div></div><div id="42915502" class="c"><input type="checkbox" id="c-42915502" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#42914665">prev</a><span>|</span><a href="#42914334">next</a><span>|</span><label class="collapse" for="c-42915502">[-]</label><label class="expand" for="c-42915502">[2 more]</label></div><br/><div class="children"><div class="content">Decline based on usage of pascalCase in the first example. How did that even happen?</div><br/><div id="42915717" class="c"><input type="checkbox" id="c-42915717" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#42915502">parent</a><span>|</span><a href="#42914334">next</a><span>|</span><label class="collapse" for="c-42915717">[-]</label><label class="expand" for="c-42915717">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t even PascalCase. This is camelCase.</div><br/></div></div></div></div><div id="42914334" class="c"><input type="checkbox" id="c-42914334" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42915502">prev</a><span>|</span><a href="#42914227">next</a><span>|</span><label class="collapse" for="c-42914334">[-]</label><label class="expand" for="c-42914334">[2 more]</label></div><br/><div class="children"><div class="content">Reinventing C#’s FormattableString and interpolated string handlers :)</div><br/><div id="42915994" class="c"><input type="checkbox" id="c-42915994" checked=""/><div class="controls bullet"><span class="by">pshirshov</span><span>|</span><a href="#42914334">parent</a><span>|</span><a href="#42914227">next</a><span>|</span><label class="collapse" for="c-42915994">[-]</label><label class="expand" for="c-42915994">[1 more]</label></div><br/><div class="children"><div class="content">C# wasn&#x27;t the first language which introduced such mechanism.</div><br/></div></div></div></div><div id="42914227" class="c"><input type="checkbox" id="c-42914227" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#42914334">prev</a><span>|</span><a href="#42913868">next</a><span>|</span><label class="collapse" for="c-42914227">[-]</label><label class="expand" for="c-42914227">[2 more]</label></div><br/><div class="children"><div class="content">So, the f-string in Python is &quot;spelled&quot; that way because another leading character was the only ASCII syntax left for such a thing.  It&#x27;s odd that PRQL and now potentially C++ might copy it.  In the PRQL case it was a new thing so they could have chosen anything, double quotes (like shell interpolation) or even backticks, that seem to make more sense.<p>Also the f- prefix was supposed to be short for format and pronounced that way.  But &quot;eff&quot; caught on and now devs the world over are calling them &quot;eff strings&quot; ... funny.  :-D</div><br/><div id="42916225" class="c"><input type="checkbox" id="c-42916225" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42914227">parent</a><span>|</span><a href="#42913868">next</a><span>|</span><label class="collapse" for="c-42916225">[-]</label><label class="expand" for="c-42916225">[1 more]</label></div><br/><div class="children"><div class="content">Why is it odd to copy a popular and fitting alternative? What&#x27;s the better one?</div><br/></div></div></div></div><div id="42913868" class="c"><input type="checkbox" id="c-42913868" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#42914227">prev</a><span>|</span><a href="#42914962">next</a><span>|</span><label class="collapse" for="c-42913868">[-]</label><label class="expand" for="c-42913868">[1 more]</label></div><br/><div class="children"><div class="content">When I saw the title I thought “F-strings” might be some novel variant of P—strings.  I was disappointed that this is just about formatting.  I really would prefer safer string handling in modern C&#x2F;++</div><br/></div></div><div id="42914962" class="c"><input type="checkbox" id="c-42914962" checked=""/><div class="controls bullet"><span class="by">alterom</span><span>|</span><a href="#42913868">prev</a><span>|</span><label class="collapse" for="c-42914962">[-]</label><label class="expand" for="c-42914962">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, I really missed ubiquitous C preprocessor macros in C++, so let&#x27;s bring them back, but now inside string literals. Sweet.<p>Seriously, I just keep being amazed that people are running with the idea of having a full-blown untyped and unchecked <i>formatting mini language</i> (that&#x27;s what libfmt, which became C++20 format, literally calls it) inside <i>string literals</i> — i.e., the part of the source code that you&#x27;re specifically telling the compiler to <i>not treat as code</i>.<p>Think about it for a minute.</div><br/><div id="42914989" class="c"><input type="checkbox" id="c-42914989" checked=""/><div class="controls bullet"><span class="by">HeliumHydride</span><span>|</span><a href="#42914962">parent</a><span>|</span><a href="#42915459">next</a><span>|</span><label class="collapse" for="c-42914989">[-]</label><label class="expand" for="c-42914989">[1 more]</label></div><br/><div class="children"><div class="content">Format strings in C++ are checked completely at compile time. There are no hacks or compiler intrinsics involved (like what C does for printf to verify format strings).</div><br/></div></div><div id="42915459" class="c"><input type="checkbox" id="c-42915459" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#42914962">parent</a><span>|</span><a href="#42914989">prev</a><span>|</span><a href="#42915039">next</a><span>|</span><label class="collapse" for="c-42915459">[-]</label><label class="expand" for="c-42915459">[1 more]</label></div><br/><div class="children"><div class="content">So basically doing the same at runtime for the last 55 years was somewhat OK?</div><br/></div></div><div id="42915039" class="c"><input type="checkbox" id="c-42915039" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#42914962">parent</a><span>|</span><a href="#42915459">prev</a><span>|</span><label class="collapse" for="c-42915039">[-]</label><label class="expand" for="c-42915039">[1 more]</label></div><br/><div class="children"><div class="content">Eh? C++20 format is checked at compile-time. This has been possible ever since string literals became constant expressions. These features are within the standard compile-time capabilities. People have done impressive compile-time parsing and codegen using it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>