<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725008476993" as="style"/><link rel="stylesheet" href="styles.css?v=1725008476993"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/rscott2049/pico-rmii-ethernet_nce">Raspberry Pi Pico does line rate 100M Ethernet</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>rscott2049</span> | <span>44 comments</span></div><br/><div><div id="41392727" class="c"><input type="checkbox" id="c-41392727" checked=""/><div class="controls bullet"><span class="by">ghayes</span><span>|</span><a href="#41392715">next</a><span>|</span><label class="collapse" for="c-41392727">[-]</label><label class="expand" for="c-41392727">[4 more]</label></div><br/><div class="children"><div class="content">I just started playing around with PIO and DMA on a Pico, and it’s really fun just how much you can do on the chip without invoking the main CPU. For context, PIO is a mini-language you can program at the edge of the chip that can directly respond to and write to external IO. DMA allows you to tell the chip to send a signal based on data in memory, and can be programmed to loop or interrupt to limit re-invoking. The linked repo uses these heavily for its fast Ethernet communication.</div><br/><div id="41393293" class="c"><input type="checkbox" id="c-41393293" checked=""/><div class="controls bullet"><span class="by">stackghost</span><span>|</span><a href="#41392727">parent</a><span>|</span><a href="#41392715">next</a><span>|</span><label class="collapse" for="c-41393293">[-]</label><label class="expand" for="c-41393293">[3 more]</label></div><br/><div class="children"><div class="content">For added clarity, the Pico includes an RP2040 which is where the PIO runs.</div><br/><div id="41394225" class="c"><input type="checkbox" id="c-41394225" checked=""/><div class="controls bullet"><span class="by">ghayes</span><span>|</span><a href="#41392727">root</a><span>|</span><a href="#41393293">parent</a><span>|</span><a href="#41392715">next</a><span>|</span><label class="collapse" for="c-41394225">[-]</label><label class="expand" for="c-41394225">[2 more]</label></div><br/><div class="children"><div class="content">Thanks, and you&#x27;re correct; not sure why you got downvoted for this. For anyone curious here are the data sheets for RP2040 [for original Pico] and RP2350 [for Pico 2], which describe the systems in detail.<p>RP2040: <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.pdf#%5B%7B%22num%22%3A313%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C841.89%2Cnull%5D" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.p...</a><p>RP2350: <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2350&#x2F;rp2350-datasheet.pdf#%5B%7B%22num%22%3A865%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C841.89%2Cnull%5D" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2350&#x2F;rp2350-datasheet.p...</a></div><br/><div id="41395085" class="c"><input type="checkbox" id="c-41395085" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#41392727">root</a><span>|</span><a href="#41394225">parent</a><span>|</span><a href="#41392715">next</a><span>|</span><label class="collapse" for="c-41395085">[-]</label><label class="expand" for="c-41395085">[1 more]</label></div><br/><div class="children"><div class="content">&quot;the Pico includes an RP2040 which is where the PIO runs&quot; to me sounds like it implies either<p>- The original Pico was not built around the RP2040 as its central part (&quot;includes&quot; sounds to me like it was an addition)<p>- The Pico 2 includes a RP2040 (in addition to the RP2350) which runs PIO<p>Neither of which are true. I&#x27;m guessing some other people had a similar reaction.</div><br/></div></div></div></div></div></div></div></div><div id="41392715" class="c"><input type="checkbox" id="c-41392715" checked=""/><div class="controls bullet"><span class="by">__michaelg</span><span>|</span><a href="#41392727">prev</a><span>|</span><a href="#41398500">next</a><span>|</span><label class="collapse" for="c-41392715">[-]</label><label class="expand" for="c-41392715">[3 more]</label></div><br/><div class="children"><div class="content">&gt; receive side uses a per-packet interrupt to finalize a received packet<p>This has made much faster systems not being able to process packets at line speed. A classic was that standard Gigabit network cards and contemporary CPUs were not able to process VoIP packets (which are tiny) at line speed, while they could easily download files (which are basically MTU-sized packets) at line speed.</div><br/><div id="41393449" class="c"><input type="checkbox" id="c-41393449" checked=""/><div class="controls bullet"><span class="by">rscott2049</span><span>|</span><a href="#41392715">parent</a><span>|</span><a href="#41393430">next</a><span>|</span><label class="collapse" for="c-41393449">[-]</label><label class="expand" for="c-41393449">[1 more]</label></div><br/><div class="children"><div class="content">Fortunately, the receive ISR isn&#x27;t cracking packets, just calculating a checksum and passing the packet on to LWIP. I wish there were two DMA sniffers, so that the checksum could be calculated by the DMA engine(s), as that&#x27;s where a lot of processor time is spent (event with a table driven CRC routine).</div><br/></div></div><div id="41393430" class="c"><input type="checkbox" id="c-41393430" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41392715">parent</a><span>|</span><a href="#41393449">prev</a><span>|</span><a href="#41398500">next</a><span>|</span><label class="collapse" for="c-41393430">[-]</label><label class="expand" for="c-41393430">[1 more]</label></div><br/><div class="children"><div class="content">Luckily the RP2040 has a dualcore CPU so one core can be dedicated entirely to receiving the interrupts, passing it to user code on the other core via a FIFO or whatever else you fancy.</div><br/></div></div></div></div><div id="41398500" class="c"><input type="checkbox" id="c-41398500" checked=""/><div class="controls bullet"><span class="by">gonzo</span><span>|</span><a href="#41392715">prev</a><span>|</span><a href="#41392819">next</a><span>|</span><label class="collapse" for="c-41398500">[-]</label><label class="expand" for="c-41398500">[9 more]</label></div><br/><div class="children"><div class="content">“Line rate” is not “fill the link with TCP”.  Line rate is “fill the link with 84 octet (including all overhead) frames.”<p>For 100M Ethernet this requires 148,809 packets per second.<p>Edit: for 1538 octet frames, one need only process 8,127 packets per second.</div><br/><div id="41398518" class="c"><input type="checkbox" id="c-41398518" checked=""/><div class="controls bullet"><span class="by">dark-star</span><span>|</span><a href="#41398500">parent</a><span>|</span><a href="#41392819">next</a><span>|</span><label class="collapse" for="c-41398518">[-]</label><label class="expand" for="c-41398518">[8 more]</label></div><br/><div class="children"><div class="content">&quot;Line rate&quot; is &quot;fill the 100Mbit link with 100 million bits each second&quot;. Of course the overhead is included in that, since the overhead also goes over the wire</div><br/><div id="41398621" class="c"><input type="checkbox" id="c-41398621" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398518">parent</a><span>|</span><a href="#41398590">next</a><span>|</span><label class="collapse" for="c-41398621">[-]</label><label class="expand" for="c-41398621">[4 more]</label></div><br/><div class="children"><div class="content">Smallest packet line rate is usually the definition network engineers use when discussing performance of devices.</div><br/><div id="41398714" class="c"><input type="checkbox" id="c-41398714" checked=""/><div class="controls bullet"><span class="by">gbil</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398621">parent</a><span>|</span><a href="#41398590">next</a><span>|</span><label class="collapse" for="c-41398714">[-]</label><label class="expand" for="c-41398714">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m many years away from such topics but I don&#x27;t remember this being the case, moreover specs for net equipment was (is) on pps with the details stating usually 2-3 packet size categories. I&#x27;m interested on some reference on what you wrote</div><br/><div id="41398830" class="c"><input type="checkbox" id="c-41398830" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398714">parent</a><span>|</span><a href="#41398864">next</a><span>|</span><label class="collapse" for="c-41398830">[-]</label><label class="expand" for="c-41398830">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.fmad.io&#x2F;blog&#x2F;what-is-10g-line-rate" rel="nofollow">https:&#x2F;&#x2F;www.fmad.io&#x2F;blog&#x2F;what-is-10g-line-rate</a><p>As the article calls it, the gold standard. If a device is capable of forwarding&#x2F;switching packets at the smallest packet size line rate on all interfaces at the same time you don&#x27;t have to think too much about its performance when designing your network. Haven&#x27;t worked much with hardware for a few years but it was common that Cisco switches were not capable of this.</div><br/></div></div><div id="41398864" class="c"><input type="checkbox" id="c-41398864" checked=""/><div class="controls bullet"><span class="by">nsteel</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398714">parent</a><span>|</span><a href="#41398830">prev</a><span>|</span><a href="#41398590">next</a><span>|</span><label class="collapse" for="c-41398864">[-]</label><label class="expand" for="c-41398864">[1 more]</label></div><br/><div class="children"><div class="content">Vendors I&#x27;ve seen usually use one of a few &quot;standard&quot; packet size mixes e.g. imix. Nobody uses smallest size frames because nobody can hit their headline perf numbers for that, and it&#x27;s not representative of real-world usage anyway.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Internet_Mix" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Internet_Mix</a></div><br/></div></div></div></div></div></div><div id="41398590" class="c"><input type="checkbox" id="c-41398590" checked=""/><div class="controls bullet"><span class="by">gonzo</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398518">parent</a><span>|</span><a href="#41398621">prev</a><span>|</span><a href="#41392819">next</a><span>|</span><label class="collapse" for="c-41398590">[-]</label><label class="expand" for="c-41398590">[3 more]</label></div><br/><div class="children"><div class="content">This is a lazy definition and won’t get you past “Go” when making network equipment.  Why not use 9000 byte “Jumbo” frames?  You’ll only need to process 1,383 packets per second to fill the link!</div><br/><div id="41398659" class="c"><input type="checkbox" id="c-41398659" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398590">parent</a><span>|</span><a href="#41392819">next</a><span>|</span><label class="collapse" for="c-41398659">[-]</label><label class="expand" for="c-41398659">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually what NAS vendors do.</div><br/><div id="41398725" class="c"><input type="checkbox" id="c-41398725" checked=""/><div class="controls bullet"><span class="by">gonzo</span><span>|</span><a href="#41398500">root</a><span>|</span><a href="#41398659">parent</a><span>|</span><a href="#41392819">next</a><span>|</span><label class="collapse" for="c-41398725">[-]</label><label class="expand" for="c-41398725">[1 more]</label></div><br/><div class="children"><div class="content">RPi Pico NAS at nearly 600Mbps!<p>What could go wrong?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41392819" class="c"><input type="checkbox" id="c-41392819" checked=""/><div class="controls bullet"><span class="by">montecarl</span><span>|</span><a href="#41398500">prev</a><span>|</span><a href="#41397904">next</a><span>|</span><label class="collapse" for="c-41392819">[-]</label><label class="expand" for="c-41392819">[10 more]</label></div><br/><div class="children"><div class="content">Why is the transfer rate non-linear with respect to the system clock? At 100 MHz the rate is 1.38 Mbit&#x2F;s and at 200 Mhz it is 65.4 Mbit&#x2F;s.</div><br/><div id="41393886" class="c"><input type="checkbox" id="c-41393886" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41392819">parent</a><span>|</span><a href="#41393077">next</a><span>|</span><label class="collapse" for="c-41393886">[-]</label><label class="expand" for="c-41393886">[7 more]</label></div><br/><div class="children"><div class="content">Latency kills...and Ethernet uses exponential backoff.</div><br/><div id="41394420" class="c"><input type="checkbox" id="c-41394420" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41392819">root</a><span>|</span><a href="#41393886">parent</a><span>|</span><a href="#41393077">next</a><span>|</span><label class="collapse" for="c-41394420">[-]</label><label class="expand" for="c-41394420">[6 more]</label></div><br/><div class="children"><div class="content">More specifically TCP uses exponential backoff. Ethernet will happily keep drowning you in packages at line rate, if I&#x27;m not mistaken.</div><br/><div id="41394781" class="c"><input type="checkbox" id="c-41394781" checked=""/><div class="controls bullet"><span class="by">daymanstep</span><span>|</span><a href="#41392819">root</a><span>|</span><a href="#41394420">parent</a><span>|</span><a href="#41397574">next</a><span>|</span><label class="collapse" for="c-41394781">[-]</label><label class="expand" for="c-41394781">[4 more]</label></div><br/><div class="children"><div class="content">CSMA&#x2F;CD does use exponential back off, though I&#x27;m not sure if anyone is still using it.</div><br/><div id="41394962" class="c"><input type="checkbox" id="c-41394962" checked=""/><div class="controls bullet"><span class="by">fach</span><span>|</span><a href="#41392819">root</a><span>|</span><a href="#41394781">parent</a><span>|</span><a href="#41397574">next</a><span>|</span><label class="collapse" for="c-41394962">[-]</label><label class="expand" for="c-41394962">[3 more]</label></div><br/><div class="children"><div class="content">This is only for half-duplex ethernet communication so no one apart from some archaic systems.</div><br/><div id="41396480" class="c"><input type="checkbox" id="c-41396480" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#41392819">root</a><span>|</span><a href="#41394962">parent</a><span>|</span><a href="#41397574">next</a><span>|</span><label class="collapse" for="c-41396480">[-]</label><label class="expand" for="c-41396480">[2 more]</label></div><br/><div class="children"><div class="content">Like WiFi?</div><br/><div id="41397357" class="c"><input type="checkbox" id="c-41397357" checked=""/><div class="controls bullet"><span class="by">edward28</span><span>|</span><a href="#41392819">root</a><span>|</span><a href="#41396480">parent</a><span>|</span><a href="#41397574">next</a><span>|</span><label class="collapse" for="c-41397357">[-]</label><label class="expand" for="c-41397357">[1 more]</label></div><br/><div class="children"><div class="content">CSMA&#x2F;CA but close.</div><br/></div></div></div></div></div></div></div></div><div id="41397574" class="c"><input type="checkbox" id="c-41397574" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#41392819">root</a><span>|</span><a href="#41394420">parent</a><span>|</span><a href="#41394781">prev</a><span>|</span><a href="#41393077">next</a><span>|</span><label class="collapse" for="c-41397574">[-]</label><label class="expand" for="c-41397574">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ethernet will happily keep drowning you in packages at line rate, if I&#x27;m not mistaken.<p>It&#x27;s a physical layer, so yeah, of course it will.</div><br/></div></div></div></div></div></div><div id="41393077" class="c"><input type="checkbox" id="c-41393077" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41392819">parent</a><span>|</span><a href="#41393886">prev</a><span>|</span><a href="#41393372">next</a><span>|</span><label class="collapse" for="c-41393077">[-]</label><label class="expand" for="c-41393077">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a lot of CRC errors or something. Just a guess.</div><br/></div></div><div id="41393372" class="c"><input type="checkbox" id="c-41393372" checked=""/><div class="controls bullet"><span class="by">rscott2049</span><span>|</span><a href="#41392819">parent</a><span>|</span><a href="#41393077">prev</a><span>|</span><a href="#41397904">next</a><span>|</span><label class="collapse" for="c-41393372">[-]</label><label class="expand" for="c-41393372">[1 more]</label></div><br/><div class="children"><div class="content">Wish I could answer that! All I can guess is that the slower processing speed creates a bottleneck in the LWIP stack somewhere...</div><br/></div></div></div></div><div id="41397904" class="c"><input type="checkbox" id="c-41397904" checked=""/><div class="controls bullet"><span class="by">dlenski</span><span>|</span><a href="#41392819">prev</a><span>|</span><a href="#41392680">next</a><span>|</span><label class="collapse" for="c-41397904">[-]</label><label class="expand" for="c-41397904">[2 more]</label></div><br/><div class="children"><div class="content">Usually I can grok the significance of almost any item on HN that catches my eye, but here I&#x27;m at a loss. Can someone explain why this matters?<p>As far as I can tell, someone has figured out how to send Ethernet packets at a relatively high rate using hardware with very limited CPU. Cool, but what can you _do with that_? If the RPi Pico has the juice to run interesting network _application-level traffic_ at line rate it&#x27;s more intriguing, but I doubt that anyone&#x27;s going to claim that can serve web traffic at line rate on this device, for example.<p>What am I missing?</div><br/><div id="41398641" class="c"><input type="checkbox" id="c-41398641" checked=""/><div class="controls bullet"><span class="by">boffinAudio</span><span>|</span><a href="#41397904">parent</a><span>|</span><a href="#41392680">next</a><span>|</span><label class="collapse" for="c-41398641">[-]</label><label class="expand" for="c-41398641">[1 more]</label></div><br/><div class="children"><div class="content">Its quite popular in the retro-computing scene, for example, to bring these old machines into the 21st century with modern microcontrollers being used to add peripheral support.<p>For example, the Oric-1&#x2F;Atmos computers recently got a project called &quot;LOCI&quot; which adds USB support to the 40-year old computer[1], by using an RP2040&#x27;s PIO capabilities to interface the 8-bit DATA bus with a microcontroller capable of acting as the &#x27;gateway&#x27; to all of the devices on the USB peripheral bus.<p>This is amazing, frankly.<p>And now, being able to do Ethernet in such a simple way means that hundreds of retro-computing platforms could be put on the Internet with relative ease ..<p>[1] - <a href="https:&#x2F;&#x2F;forum.defence-force.org&#x2F;viewtopic.php?t=2593&amp;sid=2d30a090c99cbc5f420a39dfcab11130" rel="nofollow">https:&#x2F;&#x2F;forum.defence-force.org&#x2F;viewtopic.php?t=2593&amp;sid=2d3...</a></div><br/></div></div></div></div><div id="41392680" class="c"><input type="checkbox" id="c-41392680" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41397904">prev</a><span>|</span><a href="#41393927">next</a><span>|</span><label class="collapse" for="c-41392680">[-]</label><label class="expand" for="c-41392680">[2 more]</label></div><br/><div class="children"><div class="content">Impressive.<p>At first I thought it was the new Pico 2 (RP2350), but no, it’s the old Pi Pico with RP2040.</div><br/><div id="41393472" class="c"><input type="checkbox" id="c-41393472" checked=""/><div class="controls bullet"><span class="by">rscott2049</span><span>|</span><a href="#41392680">parent</a><span>|</span><a href="#41393927">next</a><span>|</span><label class="collapse" for="c-41393472">[-]</label><label class="expand" for="c-41393472">[1 more]</label></div><br/><div class="children"><div class="content">I expect the RP2350 to perform much better in this scenario! At the minimum, one of the DMA channels should be eliminated, and I&#x27;m hoping the CRC calculation will
get faster.</div><br/></div></div></div></div><div id="41393927" class="c"><input type="checkbox" id="c-41393927" checked=""/><div class="controls bullet"><span class="by">molticrystal</span><span>|</span><a href="#41392680">prev</a><span>|</span><a href="#41393514">next</a><span>|</span><label class="collapse" for="c-41393927">[-]</label><label class="expand" for="c-41393927">[4 more]</label></div><br/><div class="children"><div class="content">I see some examples that show this can be used as a lite http daemon.<p>Is there enough room to have it control the ethernet port for another weaker or perhaps more powerful microcontroller?<p>Can you combine multiple picos with one being the ethernet stack and another that modifies certain packets?<p>Are there any other interesting things that can be done?</div><br/><div id="41395269" class="c"><input type="checkbox" id="c-41395269" checked=""/><div class="controls bullet"><span class="by">bangaladore</span><span>|</span><a href="#41393927">parent</a><span>|</span><a href="#41396310">next</a><span>|</span><label class="collapse" for="c-41395269">[-]</label><label class="expand" for="c-41395269">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there enough room to have it control the ethernet port for another weaker or perhaps more powerful microcontroller?<p>Well there is a whole unused core and plenty of built in SRAM. Seems like a good way to have an open-source version of Wiznet chips [1]. It could support full protocol offloading like Wiznet&#x27;s or a lower-level raw packet sender&#x2F;receiver like the ENC424J600.<p>[1] <a href="https:&#x2F;&#x2F;docs.wiznet.io&#x2F;Product&#x2F;iEthernet" rel="nofollow">https:&#x2F;&#x2F;docs.wiznet.io&#x2F;Product&#x2F;iEthernet</a></div><br/></div></div><div id="41396310" class="c"><input type="checkbox" id="c-41396310" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#41393927">parent</a><span>|</span><a href="#41395269">prev</a><span>|</span><a href="#41397437">next</a><span>|</span><label class="collapse" for="c-41396310">[-]</label><label class="expand" for="c-41396310">[1 more]</label></div><br/><div class="children"><div class="content">Make a package that has a rp2050 mounted on a microSD and you&#x27;ve got a NAS that nobody will ever find.<p>Back when I was doing a dumb-server&#x2F;smart-client desktop environment. Something like this would have been pretty cool.  It needed a tiny API to save files, but the bulk of the environment worked as a static server.</div><br/></div></div><div id="41397437" class="c"><input type="checkbox" id="c-41397437" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#41393927">parent</a><span>|</span><a href="#41396310">prev</a><span>|</span><a href="#41393514">next</a><span>|</span><label class="collapse" for="c-41397437">[-]</label><label class="expand" for="c-41397437">[1 more]</label></div><br/><div class="children"><div class="content">This stuff all already exists, Raspberry Pi Zero 2 W.  Board is slightly bigger than a Pico but has a full blown Linux system, 4 core arm64 cpu, 512MB ram, SD card slot, wifi, no ethernet though (add-ons are available).  Or you could use a larger Pi.</div><br/></div></div></div></div><div id="41393514" class="c"><input type="checkbox" id="c-41393514" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41393927">prev</a><span>|</span><a href="#41394130">next</a><span>|</span><label class="collapse" for="c-41393514">[-]</label><label class="expand" for="c-41393514">[2 more]</label></div><br/><div class="children"><div class="content">Very impressive!<p>It would be interesting to see a short writeup of what kind of magic was required to achieve this, as there have been multiple failed attempts before this.<p>I&#x27;m also curious about the performance boost from 2.81Mbit&#x2F;link failure at 150MHz to 65.4Mbit&#x2F;31.4Mbit at 200MHz. That doesn&#x27;t sound like basic processor bottlenecks, but rather some kind of catastrophic breakdown at a lower level? Does it just occasionally completely fail to lock onto an incoming clock signal or something?</div><br/><div id="41397081" class="c"><input type="checkbox" id="c-41397081" checked=""/><div class="controls bullet"><span class="by">rscott2049</span><span>|</span><a href="#41393514">parent</a><span>|</span><a href="#41394130">next</a><span>|</span><label class="collapse" for="c-41397081">[-]</label><label class="expand" for="c-41397081">[1 more]</label></div><br/><div class="children"><div class="content">I did some further investigating - it&#x27;s apparently due to not having enough setup
time on the RX pio SM. Even though the PIO clocking is fixed at 100 MHz, there are CRC errors at the lower system clocks. I tried changing the delay in the PIO instruction that starts the RX sampling, but that only made things worse (as expected). Also tried disabling the synchronizers with no improvement.</div><br/></div></div></div></div><div id="41394130" class="c"><input type="checkbox" id="c-41394130" checked=""/><div class="controls bullet"><span class="by">drones</span><span>|</span><a href="#41393514">prev</a><span>|</span><a href="#41394156">next</a><span>|</span><label class="collapse" for="c-41394130">[-]</label><label class="expand" for="c-41394130">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Achieves 94.9 Mbit&#x2F;sec when Pico is overclocked to 300 MHz, as measured by iperf<p>Is this an effective rate, or just the reflection of a hardware limit?</div><br/><div id="41398559" class="c"><input type="checkbox" id="c-41398559" checked=""/><div class="controls bullet"><span class="by">gonzo</span><span>|</span><a href="#41394130">parent</a><span>|</span><a href="#41394156">next</a><span>|</span><label class="collapse" for="c-41398559">[-]</label><label class="expand" for="c-41398559">[1 more]</label></div><br/><div class="children"><div class="content">A 1500 byte (octet) MTU frame is 1538 bytes “on the wire”.<p>7 byte preamble<p>1 byte SFD<p>6 byte dst MAC<p>6 byte src MAC<p>2 byte ethertype or length<p>46-1500 bytes of payload (ignoring “Jumbo” frames and 802.1q tags)<p>4 byte CRC<p>12 byte IFG (which is silence, but still counts for time on the wire)<p>Add it up and you have 1538 bytes “on the wire”.<p>TCP overhead for IPv4 is 20 bytes for IP(v4) (no options) and 20 bytes for TCP (again, no options).<p>So 1460 bytes of data for 1538 bytes on the wire. 1460&#x2F;1538 = 0.949284<p>So for 100M Ethernet, 94.9284Mbps is “perfect”.</div><br/></div></div></div></div><div id="41394156" class="c"><input type="checkbox" id="c-41394156" checked=""/><div class="controls bullet"><span class="by">thetinguy</span><span>|</span><a href="#41394130">prev</a><span>|</span><a href="#41391823">next</a><span>|</span><label class="collapse" for="c-41394156">[-]</label><label class="expand" for="c-41394156">[2 more]</label></div><br/><div class="children"><div class="content">Can it do 10BASE-T with no overclocking?</div><br/><div id="41394431" class="c"><input type="checkbox" id="c-41394431" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41394156">parent</a><span>|</span><a href="#41391823">next</a><span>|</span><label class="collapse" for="c-41394431">[-]</label><label class="expand" for="c-41394431">[1 more]</label></div><br/><div class="children"><div class="content">Yes, see for example the project which this repo acknowledges at the end.[0]<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;sandeepmistry&#x2F;pico-rmii-ethernet">https:&#x2F;&#x2F;github.com&#x2F;sandeepmistry&#x2F;pico-rmii-ethernet</a></div><br/></div></div></div></div><div id="41397320" class="c"><input type="checkbox" id="c-41397320" checked=""/><div class="controls bullet"><span class="by">RantyDave</span><span>|</span><a href="#41391823">prev</a><span>|</span><a href="#41398506">next</a><span>|</span><label class="collapse" for="c-41397320">[-]</label><label class="expand" for="c-41397320">[1 more]</label></div><br/><div class="children"><div class="content">This is a golden age of something.</div><br/></div></div><div id="41398506" class="c"><input type="checkbox" id="c-41398506" checked=""/><div class="controls bullet"><span class="by">dark-star</span><span>|</span><a href="#41397320">prev</a><span>|</span><label class="collapse" for="c-41398506">[-]</label><label class="expand" for="c-41398506">[1 more]</label></div><br/><div class="children"><div class="content">Back in the day, in the x86 world, there was this &quot;rule of thumb&quot; that you needed about 1GHz of CPU speed to saturate a 1Gbit network link. So a server with four 2GHz CPUs could saturate eight 1gbit links and still be somewhat useful.<p>This was AFAIR based on empirical knowledge, nothing scientific.<p>So a Pi Pico running at 300MHz pushing 100Mbit is something that is not totally unexpected, if you consider the low-power, low-cost CPU design in a Pi Pico (and the fact that you have to push the bits manually on the wire).<p>It&#x27;s still a nice feat that they pulled this off!</div><br/></div></div></div></div></div></div></div></body></html>