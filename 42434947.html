<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734426072227" as="style"/><link rel="stylesheet" href="styles.css?v=1734426072227"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://go.dev/blog/protobuf-opaque">Go Protobuf: The New Opaque API</a> <span class="domain">(<a href="https://go.dev">go.dev</a>)</span></div><div class="subtext"><span>secure</span> | <span>108 comments</span></div><br/><div><div id="42436071" class="c"><input type="checkbox" id="c-42436071" checked=""/><div class="controls bullet"><span class="by">dpeckett</span><span>|</span><a href="#42435461">next</a><span>|</span><label class="collapse" for="c-42436071">[-]</label><label class="expand" for="c-42436071">[22 more]</label></div><br/><div class="children"><div class="content">To be honest I kind of find myself drifting away from gRPC&#x2F;protobuf in my recent projects. I love the idea of an IDL for describing APIs and a great compiler&#x2F;codegen (protoc) but there&#x27;s just soo many idiosyncrasies baked into gRPC at this point that it often doesn&#x27;t feel worth it IMO.<p>Been increasingly using LSP style JSON-RPC 2.0, sure it&#x27;s got it&#x27;s quirks and is far from the most wire&#x2F;marshaling efficient approach but JSON codecs are ubiquitous and JSON-RPC is trivial to implement. In-fact I recently even wrote a stack allocated, server implementation for microcontrollers in Rust <a href="https:&#x2F;&#x2F;github.com&#x2F;OpenPSG&#x2F;embedded-jsonrpc">https:&#x2F;&#x2F;github.com&#x2F;OpenPSG&#x2F;embedded-jsonrpc</a>.<p>Varlink (<a href="https:&#x2F;&#x2F;varlink.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;varlink.org&#x2F;</a>) is another interesting approach, there&#x27;s reasons why they didn&#x27;t implement the full JSON-RPC spec but their IDL is pretty interesting.</div><br/><div id="42438439" class="c"><input type="checkbox" id="c-42438439" checked=""/><div class="controls bullet"><span class="by">bccdee</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42436618">next</a><span>|</span><label class="collapse" for="c-42438439">[-]</label><label class="expand" for="c-42438439">[1 more]</label></div><br/><div class="children"><div class="content">What I really like about protobuf is the DDL. Really clear schema evolution rules. Ironclad types. Protobuf moves its complexity into things like default zero values, which are irritating but readily apparent. With json, it&#x27;s superficially fine, but later on you discover that you need to be worrying about implementation-specific stuff like big ints getting mangled, or special parsing logic you need to set default values for string enums so that adding new values doesn&#x27;t break backwards compatibility. Json-schema exists but really isn&#x27;t built for these sorts of constraints, and if you try to use json-schema like protobuf, it can get pretty hairy.<p>Honestly, if protobuf just serialized to a strictly-specified subset of json, I&#x27;d be happy with that. I&#x27;m not in it for the fast ser&#x2F;de, and something human-readable could be good. But when multiple services maintained by different teams are passing messages around, a robust schema language is a MASSIVE help. I haven&#x27;t used Avro, but I assume it&#x27;s similarly useful.</div><br/></div></div><div id="42436618" class="c"><input type="checkbox" id="c-42436618" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42438439">prev</a><span>|</span><a href="#42437594">next</a><span>|</span><label class="collapse" for="c-42436618">[-]</label><label class="expand" for="c-42436618">[1 more]</label></div><br/><div class="children"><div class="content">My favorite serde format is Msgpack since it can be dropped in for an almost one-to-one replacement of JSON. There&#x27;s also CBOR which is based on MsgPack but has diverged a bit and added and a data definition language too (CDDL).<p>Take JSON-RPC and replace JSON with MsgPack for better handling of integer and float types. MsgPack&#x2F;CBOR are easy to parse in place directly into stack objects too. It&#x27;s super fast even on embedded. I&#x27;ve been shipping it for years in embedded projects using a Nim implementation for ESP32s (1) and later made a non-allocating version (2). It&#x27;s also generally easy to convert MsgPack&#x2F;CBOR to JSON for debugging, etc.<p>There&#x27;s also an IoT focused RPC based on CBOR that&#x27;s an IETF standard and a time series format (3). The RPC is used a fair bit in some projects.<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;elcritch&#x2F;nesper&#x2F;blob&#x2F;devel&#x2F;src&#x2F;nesper&#x2F;servers&#x2F;rpc&#x2F;rpcsocket_mpack.nim">https:&#x2F;&#x2F;github.com&#x2F;elcritch&#x2F;nesper&#x2F;blob&#x2F;devel&#x2F;src&#x2F;nesper&#x2F;ser...</a>
2: <a href="https:&#x2F;&#x2F;github.com&#x2F;EmbeddedNim&#x2F;fastrpc">https:&#x2F;&#x2F;github.com&#x2F;EmbeddedNim&#x2F;fastrpc</a>
3: <a href="https:&#x2F;&#x2F;hal.science&#x2F;hal-03800577v1&#x2F;file&#x2F;Towards_a_Standard_Time_Series_Representation_for_IoT_using_CBOR_Templates____Sebastian_Molina-18.pdf" rel="nofollow">https:&#x2F;&#x2F;hal.science&#x2F;hal-03800577v1&#x2F;file&#x2F;Towards_a_Standard_T...</a></div><br/></div></div><div id="42437594" class="c"><input type="checkbox" id="c-42437594" checked=""/><div class="controls bullet"><span class="by">perezd</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42436618">prev</a><span>|</span><a href="#42438122">next</a><span>|</span><label class="collapse" for="c-42437594">[-]</label><label class="expand" for="c-42437594">[5 more]</label></div><br/><div class="children"><div class="content">The better stack rn is buf + Connect RPC: <a href="https:&#x2F;&#x2F;connectrpc.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;connectrpc.com&#x2F;</a>
All the compatibility, you get JSON+HTTP &amp; gRPC, one platform.</div><br/><div id="42438103" class="c"><input type="checkbox" id="c-42438103" checked=""/><div class="controls bullet"><span class="by">rochacon</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42437594">parent</a><span>|</span><a href="#42438889">next</a><span>|</span><label class="collapse" for="c-42438103">[-]</label><label class="expand" for="c-42438103">[1 more]</label></div><br/><div class="children"><div class="content">ConnectRPC is very cool, thanks for sharing. I would like to add 2 other alternatives that I like:<p>- dRPC (by Storj): <a href="https:&#x2F;&#x2F;drpc.io" rel="nofollow">https:&#x2F;&#x2F;drpc.io</a>  (also compatible with gRPC)<p>- Twirp (by Twitch): <a href="https:&#x2F;&#x2F;github.com&#x2F;twitchtv&#x2F;twirp">https:&#x2F;&#x2F;github.com&#x2F;twitchtv&#x2F;twirp</a>  (no gRPC compatibility)</div><br/></div></div><div id="42438889" class="c"><input type="checkbox" id="c-42438889" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42437594">parent</a><span>|</span><a href="#42438103">prev</a><span>|</span><a href="#42439138">next</a><span>|</span><label class="collapse" for="c-42438889">[-]</label><label class="expand" for="c-42438889">[2 more]</label></div><br/><div class="children"><div class="content">Buf seems really nice, but I&#x27;m not completely sure what&#x27;s free and what&#x27;s not with the Buf platform, so I&#x27;m hesitant to make it a dependency for my little open source side project ideas. I should read the docs a bit more.</div><br/><div id="42439260" class="c"><input type="checkbox" id="c-42439260" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42438889">parent</a><span>|</span><a href="#42439138">next</a><span>|</span><label class="collapse" for="c-42439260">[-]</label><label class="expand" for="c-42439260">[1 more]</label></div><br/><div class="children"><div class="content">Buf CLI itself is licensed under a permissive Apache 2.0 License [0]. Since Buf is a compiler, its output cannot be copyrighted (similar to proprietary or GPL licensed compilers). DISCLAIMER: I am not a lawyer.<p>Buf distinguishes a few types of plugins: the most important being local and remote.
Local plugins are executables installed on your own machine, and Buf places no restrictions on use of those. 
Remote plugins are hosted on BSR (Buf Schema Registry) servers [1], which are rate limited. All remote plugins are also available as local plugins if you install them.<p>It&#x27;s worth to mention that the only time I&#x27;ve personally hit the rate limits of remote plugins is when I misconfigured makefile dependencies to run buf on every change of my code, instead of every change of proto definitions. So, for most development purposes, even remote plugins should be fine.<p>Additionally, BSR also offers hosting of user proto schemas and plugins, and this is where pricing comes in [2].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;bufbuild&#x2F;buf&#x2F;blob&#x2F;main&#x2F;LICENSE">https:&#x2F;&#x2F;github.com&#x2F;bufbuild&#x2F;buf&#x2F;blob&#x2F;main&#x2F;LICENSE</a><p>[1] <a href="https:&#x2F;&#x2F;buf.build&#x2F;blog&#x2F;remote-plugin-execution" rel="nofollow">https:&#x2F;&#x2F;buf.build&#x2F;blog&#x2F;remote-plugin-execution</a><p>[2] <a href="https:&#x2F;&#x2F;buf.build&#x2F;pricing" rel="nofollow">https:&#x2F;&#x2F;buf.build&#x2F;pricing</a></div><br/></div></div></div></div><div id="42439138" class="c"><input type="checkbox" id="c-42439138" checked=""/><div class="controls bullet"><span class="by">jeffrallen</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42437594">parent</a><span>|</span><a href="#42438889">prev</a><span>|</span><a href="#42438122">next</a><span>|</span><label class="collapse" for="c-42439138">[-]</label><label class="expand" for="c-42439138">[1 more]</label></div><br/><div class="children"><div class="content">Software lives forever. You have to take the long view, not the &quot;rn&quot; view. In the long view, NFS&#x27;s XDR or ASN.1 are just fine and could have been enough, if we didn&#x27;t keep reinventing things.</div><br/></div></div></div></div><div id="42438122" class="c"><input type="checkbox" id="c-42438122" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42437594">prev</a><span>|</span><a href="#42436517">next</a><span>|</span><label class="collapse" for="c-42438122">[-]</label><label class="expand" for="c-42438122">[3 more]</label></div><br/><div class="children"><div class="content">&gt; efficiency<p>State of the art for both gzipped json and protobufs is a few GB&#x2F;s. Details matter (big strings, arrays, and binary data will push protos to 2x-10x faster in typical cases), but it&#x27;s not the kind of landslide victory you&#x27;d get from a proper binary protocol. There isn&#x27;t much need to feel like you&#x27;re missing out.</div><br/><div id="42438737" class="c"><input type="checkbox" id="c-42438737" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42438122">parent</a><span>|</span><a href="#42436517">next</a><span>|</span><label class="collapse" for="c-42438737">[-]</label><label class="expand" for="c-42438737">[2 more]</label></div><br/><div class="children"><div class="content">Except gzip is tragically slow, so crippling protobuf by running it through gzip could indeed slow it down to json speeds.</div><br/><div id="42439172" class="c"><input type="checkbox" id="c-42439172" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42438737">parent</a><span>|</span><a href="#42436517">next</a><span>|</span><label class="collapse" for="c-42439172">[-]</label><label class="expand" for="c-42439172">[1 more]</label></div><br/><div class="children"><div class="content">&quot;gzipped json&quot; vs &quot;protobuf&quot;</div><br/></div></div></div></div></div></div><div id="42436517" class="c"><input type="checkbox" id="c-42436517" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42438122">prev</a><span>|</span><a href="#42436623">next</a><span>|</span><label class="collapse" for="c-42436517">[-]</label><label class="expand" for="c-42436517">[1 more]</label></div><br/><div class="children"><div class="content">Same; at my previous job for the serialisation format for our embedded devices over 2G&#x2F;4G&#x2F;LoRaWAN&#x2F;satellite I ended up landing on MessagePack, but that was partially because the &quot;schema&quot;&#x2F;typed deserialisation was all in the same language for both the firmware and the server (Nim, in this case) and directly shared source-to-source. That won&#x27;t work for a lot of cases of course, but it was quite nice for ours!</div><br/></div></div><div id="42436623" class="c"><input type="checkbox" id="c-42436623" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42436517">prev</a><span>|</span><a href="#42436278">next</a><span>|</span><label class="collapse" for="c-42436623">[-]</label><label class="expand" for="c-42436623">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I love the idea of an IDL for describing APIs and a great compiler&#x2F;codegen (protoc)<p>Me too. My context is that I end up using RPC-ish patterns when doing <i>slightly</i> out-of-the-ordinary web stuff, like websockets, iframe communications, and web workers.<p>In each of those situations you start with a bidirectional communication channel, but you have to build your own request-response layer if you need that. JSON-RPC is a good place to start, because the spec is basically just &quot;agree to use `id` to match up requests and responses&quot; and very little else of note.<p>I&#x27;ve been looking around for a &quot;minimum viable IDL&quot; to add to that, and I think my conclusion so far is &quot;just write out a TypeScript file&quot;. This works when all my software is web&#x2F;TypeScript anyway.</div><br/></div></div><div id="42436278" class="c"><input type="checkbox" id="c-42436278" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42436623">prev</a><span>|</span><a href="#42436724">next</a><span>|</span><label class="collapse" for="c-42436278">[-]</label><label class="expand" for="c-42436278">[7 more]</label></div><br/><div class="children"><div class="content">Apart from being text format, I&#x27;m not sure how well JSON-RPC handles doubles vs long integers and other types, where protobuf can be directed to handle them appropriately. That is a problem in JSON itself, so you may neeed to encode some numbers using... &quot;string&quot;</div><br/><div id="42436425" class="c"><input type="checkbox" id="c-42436425" checked=""/><div class="controls bullet"><span class="by">dpeckett</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436278">parent</a><span>|</span><a href="#42436724">next</a><span>|</span><label class="collapse" for="c-42436425">[-]</label><label class="expand" for="c-42436425">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say the success of REST kind of proves that&#x27;s something that for the most part can be worked around. Often comes down to the JSON codec itself, many codecs will allow unmarshalling&#x2F;marshalling fields straight into long int types.<p>Also JS now has BigInt types and the JSON decoder can be told to use them. So I&#x27;d argue it&#x27;s kind of a moot point at this stage.</div><br/><div id="42439433" class="c"><input type="checkbox" id="c-42439433" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436425">parent</a><span>|</span><a href="#42436542">next</a><span>|</span><label class="collapse" for="c-42439433">[-]</label><label class="expand" for="c-42439433">[1 more]</label></div><br/><div class="children"><div class="content">JS having BigInt type has nothing to do with JSON. Backend languages have had BigInt types forever. It isn&#x27;t relevant to JSON as a format.<p>Just one example: Azure Cosmos DB stores JSON documents. If you try to store integers larger than 53 bits there those integers will be silently rounded to 53 bits. I know someone who got burned by this very badly loosing their data; I was able to explain them exactly why...<p>JSON basically does not define what a number is; and that is a disaster for it as an API format.</div><br/></div></div><div id="42436542" class="c"><input type="checkbox" id="c-42436542" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436425">parent</a><span>|</span><a href="#42439433">prev</a><span>|</span><a href="#42438163">next</a><span>|</span><label class="collapse" for="c-42436542">[-]</label><label class="expand" for="c-42436542">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but you can work around gRPC&#x27;s issues too—&quot;workable&quot; might be the only bar that matters in practice, but it&#x27;s a remarkably <i>low</i> bar.<p>The risk with JSON is that <i>too</i> many systems understand it, and intermediate steps can mess up things like numeric precision as well as being inconsistent about handling things out of spec (field order, duplicate fields... etc). This definitely bites people in practice—I saw an experience report on that recently, but can&#x27;t find the link just now :&#x2F;</div><br/></div></div><div id="42438163" class="c"><input type="checkbox" id="c-42438163" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436425">parent</a><span>|</span><a href="#42436542">prev</a><span>|</span><a href="#42437389">next</a><span>|</span><label class="collapse" for="c-42438163">[-]</label><label class="expand" for="c-42438163">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say the success of REST<p>I think that you mean the success of JSON APIs.  REST is orthogonal to JSON&#x2F;Protobuf&#x2F;HTML&#x2F;XML&#x2F;S-expressions&#x2F;whatever.</div><br/></div></div><div id="42437389" class="c"><input type="checkbox" id="c-42437389" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436425">parent</a><span>|</span><a href="#42438163">prev</a><span>|</span><a href="#42436680">next</a><span>|</span><label class="collapse" for="c-42437389">[-]</label><label class="expand" for="c-42437389">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not, because some middleman (library, framework, etc.) would assume that JSON is really about sending integers as doubles, hence you are getting only 53 or was it 54 bits precision, and then you end up sending an integer as &quot;string&quot; - but then what is this really?<p>I get it, it&#x27;s probably not a concern for a lot of applications, but when comes to science, games, data it&#x27;s of big concern... and this excluding the fact that you have to convert back and forth that number a... number of times, and send it on the wire inefficiently - and also miss a way to send it more efficiently using gorilla encoding or something else like that.<p>JSON is great for a lot of things, but not for high throughput RPC.</div><br/></div></div><div id="42436680" class="c"><input type="checkbox" id="c-42436680" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436425">parent</a><span>|</span><a href="#42437389">prev</a><span>|</span><a href="#42436724">next</a><span>|</span><label class="collapse" for="c-42436680">[-]</label><label class="expand" for="c-42436680">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also JS now has BigInt types and the JSON decoder can be told to use them.<p>The parser needs to know when to parse as BigInt vs String.</div><br/></div></div></div></div></div></div><div id="42436724" class="c"><input type="checkbox" id="c-42436724" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#42436071">parent</a><span>|</span><a href="#42436278">prev</a><span>|</span><a href="#42435461">next</a><span>|</span><label class="collapse" for="c-42436724">[-]</label><label class="expand" for="c-42436724">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s sort of where I&#x27;ve landed too.  Protobufs would <i>seem</i> to fit the problem area well, but in practice the space between &quot;big-system non-performance-sensitive data transfer metaformat&quot;[1] and &quot;super-performance-sensitive custom binary parser&quot;[2] is... actually really small.<p>There are just very few spots that actually &quot;need&quot; protobuf at a level of urgency that would justify walking away from self-describing text formats (which is a big, big disadvantage for binary formats!).<p>[1] Something very well served by JSON<p>[2] Network routing, stateful packet inspection, on-the-fly transcoding.  Stuff that you&#x27;d never think to use a &quot;standard format&quot; for.</div><br/><div id="42438967" class="c"><input type="checkbox" id="c-42438967" checked=""/><div class="controls bullet"><span class="by">bboygravity</span><span>|</span><a href="#42436071">root</a><span>|</span><a href="#42436724">parent</a><span>|</span><a href="#42435461">next</a><span>|</span><label class="collapse" for="c-42438967">[-]</label><label class="expand" for="c-42438967">[1 more]</label></div><br/><div class="children"><div class="content">Add &quot;everything that communicates with a microcontroller&quot; to 2.<p>That means potentially: the majority of devices in the world.</div><br/></div></div></div></div></div></div><div id="42435461" class="c"><input type="checkbox" id="c-42435461" checked=""/><div class="controls bullet"><span class="by">kyrra</span><span>|</span><a href="#42436071">prev</a><span>|</span><a href="#42436948">next</a><span>|</span><label class="collapse" for="c-42435461">[-]</label><label class="expand" for="c-42435461">[9 more]</label></div><br/><div class="children"><div class="content">The opaque API brings some niceties that other languages have, specifically about initialization.  The Java impl for protobuf will never generate a NullPointerException, as calling `get` on a field would just return the default instance of that field.<p>The Go OpenAPI did not do this.  For many primative types, it was fine.  But for protobuf maps, you had to check if the map had been initialized yet in Go code before accessing it.  Meaning, with the Opaque API, you can start just adding items to a proto map in Go code without thinking about initialization.  (as the Opaque impl will init the map for you).<p>This is honestly something I wish Go itself would do.  Allowing for nil maps in Go is such a footgun.</div><br/><div id="42439632" class="c"><input type="checkbox" id="c-42439632" checked=""/><div class="controls bullet"><span class="by">usrnm</span><span>|</span><a href="#42435461">parent</a><span>|</span><a href="#42435707">next</a><span>|</span><label class="collapse" for="c-42439632">[-]</label><label class="expand" for="c-42439632">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so fun to watch go devs rediscover all the patterns that they so happily threw out in the beginning. It&#x27;s like watching a person grow up from a sunny little kid to a mature disgruntled alcoholic.</div><br/></div></div><div id="42435707" class="c"><input type="checkbox" id="c-42435707" checked=""/><div class="controls bullet"><span class="by">ynniv</span><span>|</span><a href="#42435461">parent</a><span>|</span><a href="#42439632">prev</a><span>|</span><a href="#42439127">next</a><span>|</span><label class="collapse" for="c-42435707">[-]</label><label class="expand" for="c-42435707">[6 more]</label></div><br/><div class="children"><div class="content"><i>The Java impl for protobuf will never generate a NullPointerException, as calling `get` on a field would just return the default instance of that field.</i><p>This was a mistake. You still want to check whether it was initialized most of the time, and when you do the wrong thing it&#x27;s even more difficult to see the error.</div><br/><div id="42435782" class="c"><input type="checkbox" id="c-42435782" checked=""/><div class="controls bullet"><span class="by">kyrra</span><span>|</span><a href="#42435461">root</a><span>|</span><a href="#42435707">parent</a><span>|</span><a href="#42439127">next</a><span>|</span><label class="collapse" for="c-42435782">[-]</label><label class="expand" for="c-42435782">[5 more]</label></div><br/><div class="children"><div class="content">Depends on your use.  If you are parsing a message you just received, I agree that you want to do a &quot;has&quot; check before accessing a field.  But when constructing a message, having to manually create all the options is really annoying.  (I do love the java builder pattern for protos).<p>But I do know the footgun of calling &quot;get&quot; on a Java Proto Builder without setting it, as that actually initializes the field to empty, and could call it to be emitted as such.<p>Such are the tradeoffs.  I&#x27;d prefer null-safety to accidental field setting (or thinking a field was set, when it really wasn&#x27;t).</div><br/><div id="42435976" class="c"><input type="checkbox" id="c-42435976" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#42435461">root</a><span>|</span><a href="#42435782">parent</a><span>|</span><a href="#42436481">next</a><span>|</span><label class="collapse" for="c-42435976">[-]</label><label class="expand" for="c-42435976">[3 more]</label></div><br/><div class="children"><div class="content">&gt; you want to do a &quot;has&quot; check before accessing a field<p>You should only do that if the semantics of the not-set field are different than the default value, which should be rare and documented on the field.</div><br/><div id="42437491" class="c"><input type="checkbox" id="c-42437491" checked=""/><div class="controls bullet"><span class="by">ynniv</span><span>|</span><a href="#42435461">root</a><span>|</span><a href="#42435976">parent</a><span>|</span><a href="#42436481">next</a><span>|</span><label class="collapse" for="c-42437491">[-]</label><label class="expand" for="c-42437491">[2 more]</label></div><br/><div class="children"><div class="content">I too enjoy defining my default attribute values at the protocol level, so they can never, ever be changed, and then defensively coding library functions in case the arguments are not constructed under the same semantic assumptions as I had years ago.<p>Also everything needs to be marked optional or you&#x27;ll need to restart the whole service mesh to change the schema.</div><br/><div id="42438278" class="c"><input type="checkbox" id="c-42438278" checked=""/><div class="controls bullet"><span class="by">kyrra</span><span>|</span><a href="#42435461">root</a><span>|</span><a href="#42437491">parent</a><span>|</span><a href="#42436481">next</a><span>|</span><label class="collapse" for="c-42438278">[-]</label><label class="expand" for="c-42438278">[1 more]</label></div><br/><div class="children"><div class="content">Default values in proto are considered an anti pattern and was removed from the language in proto3.<p>Agreed that protocol level required is bad, and it&#x27;s with proto3 made optional the default.<p>Our team enforces required fields via proto annotations, which can be much more flexible (we have transitional states to be able to upgrade or downgrade the check)</div><br/></div></div></div></div></div></div><div id="42436481" class="c"><input type="checkbox" id="c-42436481" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#42435461">root</a><span>|</span><a href="#42435782">parent</a><span>|</span><a href="#42435976">prev</a><span>|</span><a href="#42439127">next</a><span>|</span><label class="collapse" for="c-42436481">[-]</label><label class="expand" for="c-42436481">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Depends on your use.<p>Okay, but look… If I wanted that, I’d create a wrapper library for it and call it a day. But not by default, please.</div><br/></div></div></div></div></div></div><div id="42439127" class="c"><input type="checkbox" id="c-42439127" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42435461">parent</a><span>|</span><a href="#42435707">prev</a><span>|</span><a href="#42436948">next</a><span>|</span><label class="collapse" for="c-42439127">[-]</label><label class="expand" for="c-42439127">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  The Java impl for protobuf will never generate a NullPointerException, as calling `get` on a field would just return the default instance of that field.<p>This is NOT the solution lmao</div><br/></div></div></div></div><div id="42436948" class="c"><input type="checkbox" id="c-42436948" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#42435461">prev</a><span>|</span><a href="#42438974">next</a><span>|</span><label class="collapse" for="c-42436948">[-]</label><label class="expand" for="c-42436948">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting, to everyone but but the mega shops like Google, protobuf is a schema declaration tool. To the megashops its a performance tool.<p>For most of my projects, I use a web-framework I built on protobuf over the years but slowly got rid of a lot of the protobufy bits (besides the type + method declarations) and just switched to JSON as the wire format. http2, trailing headers, gigantic multi-MB files of getters, setters and embedded binary representations of the schemas, weird import behaviors, no wire error types, etc were too annoying.<p>Almost every project I&#x27;ve tracked that tries to solve the declarative schema problem seems to slowly die. Its a tough problem an opinionated one (what to do with enums? sum types? defaults? etc). Anyone know of any good ones that are chugging along? OpenAPI is too resty and JSONSchema doesn&#x27;t seem to care about RPC.</div><br/><div id="42439113" class="c"><input type="checkbox" id="c-42439113" checked=""/><div class="controls bullet"><span class="by">danans</span><span>|</span><a href="#42436948">parent</a><span>|</span><a href="#42437852">next</a><span>|</span><label class="collapse" for="c-42439113">[-]</label><label class="expand" for="c-42439113">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s interesting, to everyone but but the mega shops like Google, protobuf is a schema declaration tool<p>There are lots of other benefits for non performance-oriented teams and projects: the codegen makes it language independent and it&#x27;s pretty handy that you can share a single data model across all layers of your system.<p>If you don&#x27;t care about the wire format, the standard JSON representation makes it pair well with JSON native databases, so you can get strict schema management without the need need for any clunky ORM.</div><br/></div></div><div id="42437852" class="c"><input type="checkbox" id="c-42437852" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#42436948">parent</a><span>|</span><a href="#42439113">prev</a><span>|</span><a href="#42438974">next</a><span>|</span><label class="collapse" for="c-42437852">[-]</label><label class="expand" for="c-42437852">[2 more]</label></div><br/><div class="children"><div class="content">From Amazon: <a href="https:&#x2F;&#x2F;smithy.io&#x2F;2.0&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;smithy.io&#x2F;2.0&#x2F;index.html</a> (internally known as Coral)</div><br/><div id="42439122" class="c"><input type="checkbox" id="c-42439122" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42436948">root</a><span>|</span><a href="#42437852">parent</a><span>|</span><a href="#42438974">next</a><span>|</span><label class="collapse" for="c-42439122">[-]</label><label class="expand" for="c-42439122">[1 more]</label></div><br/><div class="children"><div class="content">nit: Coral and smithy are not comparable.<p>Coral is a schema definition language, yes. But it’s also a full rpc ecosystem.<p>Smithy at this point is only really an IDL that (in most cases, at least before I left) is “only” used to generate Coral models and then transitively Coral clients and services. The _vast_ majority of Amazon is still on “native” Coral</div><br/></div></div></div></div></div></div><div id="42438974" class="c"><input type="checkbox" id="c-42438974" checked=""/><div class="controls bullet"><span class="by">favflam</span><span>|</span><a href="#42436948">prev</a><span>|</span><a href="#42437666">next</a><span>|</span><label class="collapse" for="c-42438974">[-]</label><label class="expand" for="c-42438974">[1 more]</label></div><br/><div class="children"><div class="content">Oh, this is great.  I just did an implementation in gRPC in Go whereby I had to churn through 10MB&#x2F;s of data.  I could not implement any kind of memory pool and thus I had a lot of memory allocation issues which lead to bad memory usage and garbage collection eating up my CPU.</div><br/></div></div><div id="42437666" class="c"><input type="checkbox" id="c-42437666" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42438974">prev</a><span>|</span><a href="#42435204">next</a><span>|</span><label class="collapse" for="c-42437666">[-]</label><label class="expand" for="c-42437666">[3 more]</label></div><br/><div class="children"><div class="content">I recently used code-gen&#x27;d protobuf deser objects as the value type for an in-memory db and was considering flattening them into a more memory-efficient representation and using bitfields. That was for java though, not sure if they are doing the same thing there<p>Glad to see this change, for that use case it would&#x27;ve been perfect</div><br/><div id="42438614" class="c"><input type="checkbox" id="c-42438614" checked=""/><div class="controls bullet"><span class="by">fofoz</span><span>|</span><a href="#42437666">parent</a><span>|</span><a href="#42435204">next</a><span>|</span><label class="collapse" for="c-42438614">[-]</label><label class="expand" for="c-42438614">[2 more]</label></div><br/><div class="children"><div class="content">Have you considered this? 
<a href="https:&#x2F;&#x2F;flatbuffers.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flatbuffers.dev&#x2F;</a></div><br/><div id="42438832" class="c"><input type="checkbox" id="c-42438832" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42437666">root</a><span>|</span><a href="#42438614">parent</a><span>|</span><a href="#42435204">next</a><span>|</span><label class="collapse" for="c-42438832">[-]</label><label class="expand" for="c-42438832">[1 more]</label></div><br/><div class="children"><div class="content">at the time, no, but this would&#x27;ve been perfect :&#x2F;</div><br/></div></div></div></div></div></div><div id="42435204" class="c"><input type="checkbox" id="c-42435204" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42437666">prev</a><span>|</span><a href="#42438551">next</a><span>|</span><label class="collapse" for="c-42435204">[-]</label><label class="expand" for="c-42435204">[7 more]</label></div><br/><div class="children"><div class="content">I hate this API and Go&#x27;s handling of protocol buffers in general. Especially preparing test data for it makes for some of the most cumbersome and unwieldy files that you will ever come across. Combined with table driven testing you have thousands upon thousands of lines of data with an unbelievably long identifiers that can&#x27;t be inferred (e.g. in array literals) that is usually copy pasted around and slightly changed. Updating and understanding all of that is a nightmare and if you miss a coma or a brace somewhere, the compiler isn&#x27;t smart enough to point you to where so you get lines upon lines of syntax errors. But, being opaque has some advantages for sure.</div><br/><div id="42436467" class="c"><input type="checkbox" id="c-42436467" checked=""/><div class="controls bullet"><span class="by">GeneralMayhem</span><span>|</span><a href="#42435204">parent</a><span>|</span><a href="#42437631">next</a><span>|</span><label class="collapse" for="c-42436467">[-]</label><label class="expand" for="c-42436467">[2 more]</label></div><br/><div class="children"><div class="content">I find that the best way to set up test cases, regardless of language, is usually to use string constants in the proto text format (<a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;protobuf&#x2F;textformat-spec&#x2F;" rel="nofollow">https:&#x2F;&#x2F;protobuf.dev&#x2F;reference&#x2F;protobuf&#x2F;textformat-spec&#x2F;</a>). For arrays, and especially for oneofs, it&#x27;s <i>way</i> less verbose than how things are represented in Go, C++, or Java, and generally at least on par with the Python constructors. Maps are the only thing that suffer a bit, because they&#x27;re represented as a list of key-val pairs (like in the wire format) instead of an actual map. Your language&#x27;s compiler won&#x27;t help you debug, but the parse-text-proto function can point to the source of the issue on a line&#x2F;character level.<p>With Go generics - and equivalent in most other languages - you can write a 5-line helper function that takes a string in that format and either returns a valid proto value (using the generic type param to decide which type to unmarshal) or `t.Fatal()`s. You would never do this in production code, but as a way to represent hand-written proto values it&#x27;s pretty hard to beat.</div><br/><div id="42439549" class="c"><input type="checkbox" id="c-42439549" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42435204">root</a><span>|</span><a href="#42436467">parent</a><span>|</span><a href="#42437631">next</a><span>|</span><label class="collapse" for="c-42439549">[-]</label><label class="expand" for="c-42439549">[1 more]</label></div><br/><div class="children"><div class="content">Unless someone with authority in your workplace makes a rule against doing that…</div><br/></div></div></div></div><div id="42437631" class="c"><input type="checkbox" id="c-42437631" checked=""/><div class="controls bullet"><span class="by">lalaithion</span><span>|</span><a href="#42435204">parent</a><span>|</span><a href="#42436467">prev</a><span>|</span><a href="#42438720">next</a><span>|</span><label class="collapse" for="c-42437631">[-]</label><label class="expand" for="c-42437631">[1 more]</label></div><br/><div class="children"><div class="content">We put test inputs and outputs in testdata&#x2F;test_name.in.textpb and testdata&#x2F;test_name.out.textpb, respectively. Way nicer than defining both your inputs and your desired outputs in go code, even compared to not using protobuf at all, to the point where we occasionally write some proto definitions just for test inputs and outputs.</div><br/></div></div><div id="42438720" class="c"><input type="checkbox" id="c-42438720" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#42435204">parent</a><span>|</span><a href="#42437631">prev</a><span>|</span><a href="#42435594">next</a><span>|</span><label class="collapse" for="c-42438720">[-]</label><label class="expand" for="c-42438720">[1 more]</label></div><br/><div class="children"><div class="content">The testing practice I&#x27;ve seen is to have a testdata&#x2F; directory with a bunch of textprotos for different test cases. If you&#x27;re using Bazel, just include the entire directory glob as data dependency for the unit tests. The test tables are essentially just appropriately named textproto filenames that are unmarshaled into the proto message to be tested.<p>Then again I&#x27;ve also seen people do these thousand line in-code literal string protos which really grind my gears.</div><br/></div></div><div id="42435594" class="c"><input type="checkbox" id="c-42435594" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#42435204">parent</a><span>|</span><a href="#42438720">prev</a><span>|</span><a href="#42438551">next</a><span>|</span><label class="collapse" for="c-42435594">[-]</label><label class="expand" for="c-42435594">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used protocol buffers, but in general any kind of code generation produces awful code. I much prefer generating the machine spec (protocol buffers, in this case) from Go code rather than the other way around. It&#x27;s not a perfect solution, but it&#x27;s much better than dealing with generated code in my experience.</div><br/><div id="42437590" class="c"><input type="checkbox" id="c-42437590" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#42435204">root</a><span>|</span><a href="#42435594">parent</a><span>|</span><a href="#42438551">next</a><span>|</span><label class="collapse" for="c-42437590">[-]</label><label class="expand" for="c-42437590">[1 more]</label></div><br/><div class="children"><div class="content">Generated code tends to look very formulaic, but it doesn’t have to be unreadable. As a primative it is incredibly powerful, and can be easier to maintain than alternatives. You definitely need good build tooling though. Ideally you won’t need to look at the generated code and can infer the interface from the input file.</div><br/></div></div></div></div></div></div><div id="42435351" class="c"><input type="checkbox" id="c-42435351" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42438551">prev</a><span>|</span><a href="#42436872">next</a><span>|</span><label class="collapse" for="c-42435351">[-]</label><label class="expand" for="c-42435351">[16 more]</label></div><br/><div class="children"><div class="content">Protobuf 3 was bending over backwards to try to make the Go API make sense, but in the process it screwed up the API for C++, with many compromises. Then they changed course and made presence explicit again in proto 3.1. Now they are saying Go gets a C++-like API.<p>What I&#x27;d like is to rewind the time machine and undo all the path-dependent brain damage.</div><br/><div id="42435599" class="c"><input type="checkbox" id="c-42435599" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#42435351">parent</a><span>|</span><a href="#42435760">next</a><span>|</span><label class="collapse" for="c-42435599">[-]</label><label class="expand" for="c-42435599">[5 more]</label></div><br/><div class="children"><div class="content">When I was at Google around 2016, there was a significant push to convince folks that the proto3 implicit presence was superior to explicit presence.<p>Is there a design doc with the rationale for switching back to explicit presence for Edition 2023?<p>The closest docs I&#x27;ve found are <a href="https:&#x2F;&#x2F;buf.build&#x2F;blog&#x2F;protobuf-editions-are-here" rel="nofollow">https:&#x2F;&#x2F;buf.build&#x2F;blog&#x2F;protobuf-editions-are-here</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tree&#x2F;main&#x2F;docs&#x2F;design&#x2F;editions">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tree&#x2F;main&#x2F;docs&#x2F;d...</a>.</div><br/><div id="42438481" class="c"><input type="checkbox" id="c-42438481" checked=""/><div class="controls bullet"><span class="by">akshayshah</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42435599">parent</a><span>|</span><a href="#42435730">next</a><span>|</span><label class="collapse" for="c-42438481">[-]</label><label class="expand" for="c-42438481">[1 more]</label></div><br/><div class="children"><div class="content">Best bet is likely <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;docs&#x2F;field_presence.md">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;blob&#x2F;main&#x2F;docs&#x2F;f...</a>, which predates editions.</div><br/></div></div><div id="42435730" class="c"><input type="checkbox" id="c-42435730" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42435599">parent</a><span>|</span><a href="#42438481">prev</a><span>|</span><a href="#42435760">next</a><span>|</span><label class="collapse" for="c-42435730">[-]</label><label class="expand" for="c-42435730">[3 more]</label></div><br/><div class="children"><div class="content">I was only there for the debate you mentioned and not there for the reversal, so I dunno.</div><br/><div id="42436480" class="c"><input type="checkbox" id="c-42436480" checked=""/><div class="controls bullet"><span class="by">IX-103</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42435730">parent</a><span>|</span><a href="#42435760">next</a><span>|</span><label class="collapse" for="c-42436480">[-]</label><label class="expand" for="c-42436480">[2 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t there for the debate, but was there for the reversal. I don&#x27;t remember there being anything explicitly said about it. The only thing I can think of is that I know of some important projects that couldn&#x27;t migrate to proto3 because of this implicit field issue. So some people were still writing new code with proto2.</div><br/><div id="42437048" class="c"><input type="checkbox" id="c-42437048" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42436480">parent</a><span>|</span><a href="#42435760">next</a><span>|</span><label class="collapse" for="c-42437048">[-]</label><label class="expand" for="c-42437048">[1 more]</label></div><br/><div class="children"><div class="content">And... most of the important projects are still using proto2 and there is no realistic way to do interop between those two formats. IIRC, you cannot use proto2 enum in proto3 for some obscure technical reason! This creates a backsliding issue; you cannot migrate old protos with thousands of different messages, fields and enums where new proto2 messages to use them are added everyday.<p>This is an important distinction from the proto1-&gt;proto2 migration, which was in a much better compatibility situation yet still took years to complete. AFAIK, this is the main reason why the proto team decided to create a superset approach (edition) so migration can be handled as a flag at each message level.</div><br/></div></div></div></div></div></div></div></div><div id="42435760" class="c"><input type="checkbox" id="c-42435760" checked=""/><div class="controls bullet"><span class="by">jcdavis</span><span>|</span><a href="#42435351">parent</a><span>|</span><a href="#42435599">prev</a><span>|</span><a href="#42436011">next</a><span>|</span><label class="collapse" for="c-42435760">[-]</label><label class="expand" for="c-42435760">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it screwed up the API for C++, with many compromises<p>The implicit presence garbage screwed up the API for many languages, not just C++<p>What is wild is how obviously silly it was at the time, too - no hindsight was needed.</div><br/><div id="42439564" class="c"><input type="checkbox" id="c-42439564" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42435760">parent</a><span>|</span><a href="#42436011">next</a><span>|</span><label class="collapse" for="c-42439564">[-]</label><label class="expand" for="c-42439564">[1 more]</label></div><br/><div class="children"><div class="content">It was but when the wrong fool gets a say, they will mess a perfectly good thing up for everyone.<p>Organizations often promote fools who don’t second guess their beliefs and think they have it all figured out.</div><br/></div></div></div></div><div id="42436011" class="c"><input type="checkbox" id="c-42436011" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#42435351">parent</a><span>|</span><a href="#42435760">prev</a><span>|</span><a href="#42436127">next</a><span>|</span><label class="collapse" for="c-42436011">[-]</label><label class="expand" for="c-42436011">[4 more]</label></div><br/><div class="children"><div class="content">I work mainly in Python, it&#x27;s always seemed really bad that there are 3 main implementations of Protobufs, instead of the C++ being the real implementation and other platforms just dlopen&#x27;ing and using it (there are a million software engineering arguments around this; I&#x27;ve heard them all before, have my own opinions, and have listened to the opinions of people I disagree with).  It seems like the velocity of a project is the reciprocal of the number of independent implementations of a spec because any one of the implementations can slow down all the implementations (like what happened with proto3 around required and optional).<p>From what I can tell, a major source of the problem was that protobuf field semantics were absolutely critical to the scaling of google in the early days (as an inter-server protocol for rapidly evolving things like the search stack), but it&#x27;s also being used as a data modelling toolkit (as a way of representing data with a high level of fidelity).  And those two groups- along with the multiple language developers who don&#x27;t want to deal with native code- do not see eye to eye, and want to drive the spec in their preferred direction.<p>(FWIW nowadays I use pydantic for type descriptions and JSON for transport, but I really prefer having an external IDL unrelated to any specific programming language)</div><br/><div id="42437650" class="c"><input type="checkbox" id="c-42437650" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42436011">parent</a><span>|</span><a href="#42437294">next</a><span>|</span><label class="collapse" for="c-42437650">[-]</label><label class="expand" for="c-42437650">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It seems like the velocity of a project is the reciprocal of the number of independent implementations of a spec because any one of the implementations can slow down all the implementations (like what happened with proto3 around required and optional).<p>Velocity and stability&#x2F;maturity are in tension, sure. I think for a foundational protocol like protobuf you want the stability and reliability that come from multiple independent implementations more than you want it to be moving fast and breaking things.</div><br/><div id="42438751" class="c"><input type="checkbox" id="c-42438751" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42437650">parent</a><span>|</span><a href="#42437294">next</a><span>|</span><label class="collapse" for="c-42438751">[-]</label><label class="expand" for="c-42438751">[1 more]</label></div><br/><div class="children"><div class="content">Additionally calling C++ from other languages is a pain and you&#x27;re forced to make a bridge C API. Doing so from Go is even less than ideal from what I gather. It requires using cgo and forces Go to interface with C call stacks, slows down the compilation, etc.</div><br/></div></div></div></div><div id="42437294" class="c"><input type="checkbox" id="c-42437294" checked=""/><div class="controls bullet"><span class="by">charleslmunger</span><span>|</span><a href="#42435351">root</a><span>|</span><a href="#42436011">parent</a><span>|</span><a href="#42437650">prev</a><span>|</span><a href="#42436127">next</a><span>|</span><label class="collapse" for="c-42437294">[-]</label><label class="expand" for="c-42437294">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll be thrilled to hear about upb then, which was designed to be embeddable to power other languages without a from-scratch implementation - and now powers python protos.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tree&#x2F;main&#x2F;upb">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tree&#x2F;main&#x2F;upb</a></div><br/></div></div></div></div><div id="42436127" class="c"><input type="checkbox" id="c-42436127" checked=""/><div class="controls bullet"><span class="by">sbrother</span><span>|</span><a href="#42435351">parent</a><span>|</span><a href="#42436011">prev</a><span>|</span><a href="#42439161">next</a><span>|</span><label class="collapse" for="c-42436127">[-]</label><label class="expand" for="c-42436127">[1 more]</label></div><br/><div class="children"><div class="content">I still use proto2 if possible. The syntactic sugar around `oneof` wasn&#x27;t nice enough to merit dealing with proto3&#x27;s implicit presence -- maybe it is just because I learned proto2 with C++ and don&#x27;t use Go, but proto3 just seemed like a big step back and introduced footguns that weren&#x27;t there before. Happy to hear they are reverting some of those finally.</div><br/></div></div><div id="42439161" class="c"><input type="checkbox" id="c-42439161" checked=""/><div class="controls bullet"><span class="by">ein0p</span><span>|</span><a href="#42435351">parent</a><span>|</span><a href="#42436127">prev</a><span>|</span><a href="#42438335">next</a><span>|</span><label class="collapse" for="c-42439161">[-]</label><label class="expand" for="c-42439161">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see my comments on their proto3 design doc vindicated, lol. There were a lot of comments on that doc, far more than what you&#x27;d usually see. Some of those comments dealt with the misguided decision to basically drop nullability (that is, the `has_` methods) that proto2 had. The team then just deleted all the comments and disabled commenting on the doc and proceeded with their original design much to the consternation of their primary stakeholders.</div><br/></div></div><div id="42438335" class="c"><input type="checkbox" id="c-42438335" checked=""/><div class="controls bullet"><span class="by">boulos</span><span>|</span><a href="#42435351">parent</a><span>|</span><a href="#42439161">prev</a><span>|</span><a href="#42435586">next</a><span>|</span><label class="collapse" for="c-42438335">[-]</label><label class="expand" for="c-42438335">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how I remember it. I thought proto3 was all about <i>JSON</i> compatibility. No?</div><br/></div></div></div></div><div id="42436872" class="c"><input type="checkbox" id="c-42436872" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42435351">prev</a><span>|</span><a href="#42435249">next</a><span>|</span><label class="collapse" for="c-42436872">[-]</label><label class="expand" for="c-42436872">[1 more]</label></div><br/><div class="children"><div class="content">The absolute state of Go dragging down the entire gRPC stack with it. Oh well, at least we have quite a few competent replacements nowadays.</div><br/></div></div><div id="42435249" class="c"><input type="checkbox" id="c-42435249" checked=""/><div class="controls bullet"><span class="by">alakra</span><span>|</span><a href="#42436872">prev</a><span>|</span><a href="#42435283">next</a><span>|</span><label class="collapse" for="c-42435249">[-]</label><label class="expand" for="c-42435249">[3 more]</label></div><br/><div class="children"><div class="content">Is this like the FlatBuffers &quot;zero-copy&quot; deserialization?</div><br/><div id="42435338" class="c"><input type="checkbox" id="c-42435338" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42435249">parent</a><span>|</span><a href="#42435359">next</a><span>|</span><label class="collapse" for="c-42435338">[-]</label><label class="expand" for="c-42435338">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not done reading the article yet, but nothing so far indicates that this is zero-copy, just a more efficient internal representation</div><br/></div></div><div id="42435359" class="c"><input type="checkbox" id="c-42435359" checked=""/><div class="controls bullet"><span class="by">kyrra</span><span>|</span><a href="#42435249">parent</a><span>|</span><a href="#42435338">prev</a><span>|</span><a href="#42435283">next</a><span>|</span><label class="collapse" for="c-42435359">[-]</label><label class="expand" for="c-42435359">[1 more]</label></div><br/><div class="children"><div class="content">Nope.  This is just a different implementation that greatly improves the speed in various ways.</div><br/></div></div></div></div><div id="42435283" class="c"><input type="checkbox" id="c-42435283" checked=""/><div class="controls bullet"><span class="by">strawhatguy</span><span>|</span><a href="#42435249">prev</a><span>|</span><a href="#42436606">next</a><span>|</span><label class="collapse" for="c-42435283">[-]</label><label class="expand" for="c-42435283">[11 more]</label></div><br/><div class="children"><div class="content">Great, now there&#x27;s an API per struct&#x2F;message to learn and communicate throughout the codebase, with all the getters and setters.<p>A given struct is probably faster for protobuf parsing in the new layout, but the complexity of the code probably increases, and I can see this complexity easily negating these gains.</div><br/><div id="42435341" class="c"><input type="checkbox" id="c-42435341" checked=""/><div class="controls bullet"><span class="by">secure</span><span>|</span><a href="#42435283">parent</a><span>|</span><a href="#42435316">next</a><span>|</span><label class="collapse" for="c-42435341">[-]</label><label class="expand" for="c-42435341">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Great, now there&#x27;s an API per struct&#x2F;message to learn and communicate throughout the codebase, with all the getters and setters.<p>No, the general idea (and practical experience, at least for projects within Google) is that a codebase migrates completely from one API level to another. Only larger code bases will have to deal with different API levels. Even in such cases, your policy can remain “always use the Open API” unless you are interested in picking up the performance gains of the Opaque API.</div><br/></div></div><div id="42435316" class="c"><input type="checkbox" id="c-42435316" checked=""/><div class="controls bullet"><span class="by">hellcow</span><span>|</span><a href="#42435283">parent</a><span>|</span><a href="#42435341">prev</a><span>|</span><a href="#42435654">next</a><span>|</span><label class="collapse" for="c-42435316">[-]</label><label class="expand" for="c-42435316">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend transforming protobuf types to domain types at your API boundary. Then you have domain types through the whole application.</div><br/><div id="42437384" class="c"><input type="checkbox" id="c-42437384" checked=""/><div class="controls bullet"><span class="by">AYBABTME</span><span>|</span><a href="#42435283">root</a><span>|</span><a href="#42435316">parent</a><span>|</span><a href="#42435753">next</a><span>|</span><label class="collapse" for="c-42437384">[-]</label><label class="expand" for="c-42437384">[1 more]</label></div><br/><div class="children"><div class="content">I found that this ends up being a giant amount of useless code, and a ton of memory allocation noise, that only satisfied my desire for elegance. I&#x27;ve given up that approach and just use protobuf types throughout as the base type. I got sick of writing dumb conversion funcs.</div><br/></div></div><div id="42435753" class="c"><input type="checkbox" id="c-42435753" checked=""/><div class="controls bullet"><span class="by">mxey</span><span>|</span><a href="#42435283">root</a><span>|</span><a href="#42435316">parent</a><span>|</span><a href="#42437384">prev</a><span>|</span><a href="#42437616">next</a><span>|</span><label class="collapse" for="c-42435753">[-]</label><label class="expand" for="c-42435753">[4 more]</label></div><br/><div class="children"><div class="content">At which point I loose all the benefits of lazy decoding that the accessor methods can provide, so I could just decode directly into a sensible struct, except you can’t with Protobuf.</div><br/><div id="42435787" class="c"><input type="checkbox" id="c-42435787" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42435283">root</a><span>|</span><a href="#42435753">parent</a><span>|</span><a href="#42437616">next</a><span>|</span><label class="collapse" for="c-42435787">[-]</label><label class="expand" for="c-42435787">[3 more]</label></div><br/><div class="children"><div class="content">Accessor methods aren&#x27;t for lazy decoding but for more efficient memory layouts.</div><br/><div id="42435805" class="c"><input type="checkbox" id="c-42435805" checked=""/><div class="controls bullet"><span class="by">mxey</span><span>|</span><a href="#42435283">root</a><span>|</span><a href="#42435787">parent</a><span>|</span><a href="#42437616">next</a><span>|</span><label class="collapse" for="c-42435805">[-]</label><label class="expand" for="c-42435805">[2 more]</label></div><br/><div class="children"><div class="content">But that will also not transfer over to the domain struct</div><br/><div id="42439191" class="c"><input type="checkbox" id="c-42439191" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42435283">root</a><span>|</span><a href="#42435805">parent</a><span>|</span><a href="#42437616">next</a><span>|</span><label class="collapse" for="c-42439191">[-]</label><label class="expand" for="c-42439191">[1 more]</label></div><br/><div class="children"><div class="content">Well it depends. If your data model doesn&#x27;t include &quot;this bool is optional&quot;, you can just include the bool directly in the struct and get all the memory layout advantages, and then you decide in your protobuf -&gt; domain type conversion code whether it&#x27;s an error if that field is missing or if it just defaults to &#x27;false&#x27;. You only need to make ways for a field to be optional (such as naming it a pointer where nil represents &quot;missing&quot;) when that actually makes sense <i>in your data model</i>.</div><br/></div></div></div></div></div></div></div></div><div id="42437616" class="c"><input type="checkbox" id="c-42437616" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42435283">root</a><span>|</span><a href="#42435316">parent</a><span>|</span><a href="#42435753">prev</a><span>|</span><a href="#42435654">next</a><span>|</span><label class="collapse" for="c-42437616">[-]</label><label class="expand" for="c-42437616">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done this, it only makes sense to me if you&#x27;re trying to recycle some legacy code that&#x27;s already using the domain types. Or else there&#x27;s a bunch of extra conversion logic and unnecessary copying, feels like an antipattern</div><br/></div></div></div></div><div id="42435654" class="c"><input type="checkbox" id="c-42435654" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42435283">parent</a><span>|</span><a href="#42435316">prev</a><span>|</span><a href="#42435378">next</a><span>|</span><label class="collapse" for="c-42435654">[-]</label><label class="expand" for="c-42435654">[1 more]</label></div><br/><div class="children"><div class="content">I always used the getters anyway.  Given:<p><pre><code>   message M {
      string foo = 1;
   }
   message N {
       M bar = 2;
   }
</code></pre>
I find (new(M)).Bar.Foo panicking pretty annoying.  So I just made it a habit to m.GetBar().GetFoo() anyway.  If m.GetBar().SetFoo() works with the new API, that would be an improvement.<p>There are some options like nilaway if you want static analysis to prevent you from writing this sort of code, but it&#x27;s difficult to retrofit into an existing codebase that plays a little too fast and loose with nil values.  Having code authors and code reviewers do the work is simpler, though probably less accurate.<p>The generated code&#x27;s API has never really bothered me.  It is flexible enough to be clever.  I especially liked using proto3 for data types and then storing them in a kv store with an API like:<p><pre><code>   type WithID interface { GetId() []byte }

   func Put(tx *Tx, x WithID) error { ... }
   func Get(tx *Tx, id []byte) (WithId, error) { ... } 
</code></pre>
The autogenerated API is flexible enough for this sort of shenanigan, though it&#x27;s not something I would recommend except to have fun.</div><br/></div></div><div id="42435378" class="c"><input type="checkbox" id="c-42435378" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42435283">parent</a><span>|</span><a href="#42435654">prev</a><span>|</span><a href="#42436606">next</a><span>|</span><label class="collapse" for="c-42435378">[-]</label><label class="expand" for="c-42435378">[1 more]</label></div><br/><div class="children"><div class="content">I mean calling it &quot;a new API per message&quot; is a bit of an exaggeration... the &quot;API&quot; per message is still the same: something with some set of attributes. It&#x27;s just that those attributes are now set and accessed with getters and setters (with predictable names) rather than as struct fields. Once you know how to access fields on protobuf types in general, all message-specific info you need is which fields exist and what their types are, which was the case before too.</div><br/></div></div></div></div><div id="42436606" class="c"><input type="checkbox" id="c-42436606" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42435283">prev</a><span>|</span><a href="#42436388">next</a><span>|</span><label class="collapse" for="c-42436606">[-]</label><label class="expand" for="c-42436606">[6 more]</label></div><br/><div class="children"><div class="content">Thanks. I hate it.<p>Now you can not use normal Go struct initialization and you&#x27;ll have to write reams of Set calls.</div><br/><div id="42437556" class="c"><input type="checkbox" id="c-42437556" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#42436606">parent</a><span>|</span><a href="#42436735">next</a><span>|</span><label class="collapse" for="c-42437556">[-]</label><label class="expand" for="c-42437556">[4 more]</label></div><br/><div class="children"><div class="content">Like the sibling said, there&#x27;s a complimentary _builder struct generated with a Build() method. For instance, for the sample message in the blog post, here&#x27;s the public API of the generated _builder:<p><pre><code>  type LogEntry_builder struct {
   BackendServer *string
   RequestSize   *uint32
   IpAddress     *string
   &#x2F;&#x2F; contains filtered or unexported fields
  }

  func (b0 LogEntry_builder) Build() *LogEntry</code></pre></div><br/><div id="42437889" class="c"><input type="checkbox" id="c-42437889" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42436606">root</a><span>|</span><a href="#42437556">parent</a><span>|</span><a href="#42436735">next</a><span>|</span><label class="collapse" for="c-42437889">[-]</label><label class="expand" for="c-42437889">[3 more]</label></div><br/><div class="children"><div class="content">So they managed to screw up even that. The naming system is not idiomatic Go.<p>You still will need to create temporary objects (performance...) and for an unclear gain.</div><br/><div id="42438144" class="c"><input type="checkbox" id="c-42438144" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#42436606">root</a><span>|</span><a href="#42437889">parent</a><span>|</span><a href="#42436735">next</a><span>|</span><label class="collapse" for="c-42438144">[-]</label><label class="expand" for="c-42438144">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The naming system is not idiomatic Go.<p>Underscores are commonly used in names in generated code to avoid conflicts (this applies to all sorts of codegen, not just protobuf). You can easily have both Foo and FooBuilder messages in your protobuf. See also generated enum consts since day one of protobuf-gen-go.</div><br/><div id="42438636" class="c"><input type="checkbox" id="c-42438636" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42436606">root</a><span>|</span><a href="#42438144">parent</a><span>|</span><a href="#42436735">next</a><span>|</span><label class="collapse" for="c-42438636">[-]</label><label class="expand" for="c-42438636">[1 more]</label></div><br/><div class="children"><div class="content">&gt; used in names in generated code<p>Fair enough but now this name leaks out into code I have to type.  I don&#x27;t dig highly opinionated languages with tooling that complains at me over style guidelines breaking their own style guidelines to solve a problem that they themselves have created.<p>They painted themselves into a corner and their solution is for me to hit myself in the head with a hammer.</div><br/></div></div></div></div></div></div></div></div><div id="42436735" class="c"><input type="checkbox" id="c-42436735" checked=""/><div class="controls bullet"><span class="by">xyse53</span><span>|</span><a href="#42436606">parent</a><span>|</span><a href="#42437556">prev</a><span>|</span><a href="#42436388">next</a><span>|</span><label class="collapse" for="c-42436735">[-]</label><label class="expand" for="c-42436735">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not in the post but when this was rolled out internally at Google there was a corresponding builder struct to initialize from.</div><br/></div></div></div></div><div id="42436388" class="c"><input type="checkbox" id="c-42436388" checked=""/><div class="controls bullet"><span class="by">g0ld3nrati0</span><span>|</span><a href="#42436606">prev</a><span>|</span><a href="#42436155">next</a><span>|</span><label class="collapse" for="c-42436388">[-]</label><label class="expand" for="c-42436388">[6 more]</label></div><br/><div class="children"><div class="content">just curious, why do use protobuf instead of flatbuffers?</div><br/><div id="42438494" class="c"><input type="checkbox" id="c-42438494" checked=""/><div class="controls bullet"><span class="by">akshayshah</span><span>|</span><a href="#42436388">parent</a><span>|</span><a href="#42438646">next</a><span>|</span><label class="collapse" for="c-42438494">[-]</label><label class="expand" for="c-42438494">[2 more]</label></div><br/><div class="children"><div class="content">The whole FlatBuffers toolchain is wildly immature compared to Protobuf. Last I checked, flatc doesn’t even have a plugin system - all code generators had to be upstreamed into the compiler itself.</div><br/><div id="42438792" class="c"><input type="checkbox" id="c-42438792" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42436388">root</a><span>|</span><a href="#42438494">parent</a><span>|</span><a href="#42438646">next</a><span>|</span><label class="collapse" for="c-42438792">[-]</label><label class="expand" for="c-42438792">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t protoc mostly the same? I mean I know the code generators are separate binaries (which is quite annoying frankly) but protoc needs to know of them all upstream to expose options like --go_out and --go_opt, right?</div><br/></div></div></div></div><div id="42438646" class="c"><input type="checkbox" id="c-42438646" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#42436388">parent</a><span>|</span><a href="#42438494">prev</a><span>|</span><a href="#42437936">next</a><span>|</span><label class="collapse" for="c-42438646">[-]</label><label class="expand" for="c-42438646">[1 more]</label></div><br/><div class="children"><div class="content">If you work with both the ergonomic advantages of protobufs become quickly apparent - starting the first time you nest things a few times. Unless you are very very frequently not going to deserialize your entire messages and so can get huge benefits from the better selective-deser of only what a given consumer cares about at a certain time, I find using flatbuffers hard to justify.</div><br/></div></div><div id="42437936" class="c"><input type="checkbox" id="c-42437936" checked=""/><div class="controls bullet"><span class="by">tonyhart7</span><span>|</span><a href="#42436388">parent</a><span>|</span><a href="#42438646">prev</a><span>|</span><a href="#42436155">next</a><span>|</span><label class="collapse" for="c-42437936">[-]</label><label class="expand" for="c-42437936">[2 more]</label></div><br/><div class="children"><div class="content">Yeah idk why we didnt just send binary data representation therefore eliminate entire serialize and deserialize part</div><br/><div id="42439506" class="c"><input type="checkbox" id="c-42439506" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42436388">root</a><span>|</span><a href="#42437936">parent</a><span>|</span><a href="#42436155">next</a><span>|</span><label class="collapse" for="c-42439506">[-]</label><label class="expand" for="c-42439506">[1 more]</label></div><br/><div class="children"><div class="content">Which binary data representation? If I&#x27;m sending a Java object, do you think a C program will be able to just use it? Or for that matter, do you think two different C++ implementations, maybe on different platforms, will use the same binary representation of a class object?</div><br/></div></div></div></div></div></div><div id="42436155" class="c"><input type="checkbox" id="c-42436155" checked=""/><div class="controls bullet"><span class="by">tonymet</span><span>|</span><a href="#42436388">prev</a><span>|</span><a href="#42436805">next</a><span>|</span><label class="collapse" for="c-42436155">[-]</label><label class="expand" for="c-42436155">[3 more]</label></div><br/><div class="children"><div class="content">why is code generation under-utilized?  protobufs and other go tooling are great for code generation. Yet in practice i see few teams using it at scale.<p>Lots of teams creating rest &#x2F; json APIs, but very few who use code generation to provide compile-time protection.</div><br/><div id="42436346" class="c"><input type="checkbox" id="c-42436346" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#42436155">parent</a><span>|</span><a href="#42436377">next</a><span>|</span><label class="collapse" for="c-42436346">[-]</label><label class="expand" for="c-42436346">[1 more]</label></div><br/><div class="children"><div class="content">Code generation leaves a layer of abstraction between the API and the actual implementation which works great if that code generation is bug-free but if it&#x27;s not, you&#x27;re like... totally fucked. Most commonly people say you can read the generated code and step backwards but that&#x27;s like saying you can read the compiled JavaScript and it&#x27;s basically open source. That layer of abstraction is an underrated mental barrier.<p>Of course, code generation is still practical and I&#x27;m a lot more likely to trust a third-party writing a code generator like protobufs, OpenAPI specs, etc, but I would not trust an internal team to do so without a very good reason. I&#x27;ve worked on a few projects that lost hundreds of dev hours trying to maintain their code generator to avoid a tiny bit of copy&#x2F;paste.</div><br/></div></div><div id="42436377" class="c"><input type="checkbox" id="c-42436377" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42436155">parent</a><span>|</span><a href="#42436346">prev</a><span>|</span><a href="#42436805">next</a><span>|</span><label class="collapse" for="c-42436377">[-]</label><label class="expand" for="c-42436377">[1 more]</label></div><br/><div class="children"><div class="content">Code generation is under utilized because most people don&#x27;t have a build system good enough for it. Traditional make is fine: you just define dependencies and rules. But a lot of people want to use language-specific build systems and these often don&#x27;t have good support for code generation and dependency tracking for generated code.<p>Yet another subtlety is that when cross-compiling, you need to build the code generation tool for the local target always even though the main target could be a foreign architecture. And because the code generation tool and the main code could share dependencies, these dependencies need to be built twice for different targets. That again is something many build tools don&#x27;t support.</div><br/></div></div></div></div><div id="42436805" class="c"><input type="checkbox" id="c-42436805" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42436155">prev</a><span>|</span><a href="#42437366">next</a><span>|</span><label class="collapse" for="c-42436805">[-]</label><label class="expand" for="c-42436805">[1 more]</label></div><br/><div class="children"><div class="content">BTW, if you care so much about performance, then fix the freaking array representation. It should be simple `[]SomeStruct` instead of `[]*SomeStruct`.<p>This one small change can result in an order of magnitude improvement.</div><br/></div></div><div id="42437366" class="c"><input type="checkbox" id="c-42437366" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#42436805">prev</a><span>|</span><a href="#42436165">next</a><span>|</span><label class="collapse" for="c-42437366">[-]</label><label class="expand" for="c-42437366">[1 more]</label></div><br/><div class="children"><div class="content">I can’t wait to try this new Protobuf Enterprise Edition, with its sea of getters and setters ad nauseam. &#x2F;s<p>However I can get behind it for the lazy decoding which seems nice, though I doubt its actual usefulness for serious software (tm). As someone else already mentioned, an actual serious api (tm) will have business-scope types to uncouple the api definition from the implementation. And that’s how you keep sane as soon as you have to support multiple versions of the api.<p>Also, a lot of the benefits mentioned for footgun reductions smell like workarounds for the language shortcomings. Memory address comparisons, accidental pointer sharing and mutability, enums, optional handling, etc are already solved problems and where something like rust shines. (Disclaimer: I run several grpc apis written in rust in prod)</div><br/></div></div><div id="42436165" class="c"><input type="checkbox" id="c-42436165" checked=""/><div class="controls bullet"><span class="by">lakomen</span><span>|</span><a href="#42437366">prev</a><span>|</span><a href="#42438386">next</a><span>|</span><label class="collapse" for="c-42436165">[-]</label><label class="expand" for="c-42436165">[6 more]</label></div><br/><div class="children"><div class="content">Graphql won the race for me. Grpc is no longer relevant. Too many hurdles, no proper to and from Web support. You have to use some 3rd party non free service.</div><br/><div id="42436322" class="c"><input type="checkbox" id="c-42436322" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#42436165">parent</a><span>|</span><a href="#42436275">next</a><span>|</span><label class="collapse" for="c-42436322">[-]</label><label class="expand" for="c-42436322">[4 more]</label></div><br/><div class="children"><div class="content">Aren’t their usecases completely different?</div><br/><div id="42437659" class="c"><input type="checkbox" id="c-42437659" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42436165">root</a><span>|</span><a href="#42436322">parent</a><span>|</span><a href="#42437964">next</a><span>|</span><label class="collapse" for="c-42437659">[-]</label><label class="expand" for="c-42437659">[1 more]</label></div><br/><div class="children"><div class="content">No, they&#x27;re both possible choices for your basic client-server communication layer that you build everything else on. (I mean, technically gRPC rather than protobuf, but protobuf is the biggest part of gRPC).</div><br/></div></div><div id="42437964" class="c"><input type="checkbox" id="c-42437964" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42436165">root</a><span>|</span><a href="#42436322">parent</a><span>|</span><a href="#42437659">prev</a><span>|</span><a href="#42436349">next</a><span>|</span><label class="collapse" for="c-42437964">[-]</label><label class="expand" for="c-42437964">[1 more]</label></div><br/><div class="children"><div class="content">What are differences ?</div><br/></div></div><div id="42436349" class="c"><input type="checkbox" id="c-42436349" checked=""/><div class="controls bullet"><span class="by">asmor</span><span>|</span><a href="#42436165">root</a><span>|</span><a href="#42436322">parent</a><span>|</span><a href="#42437964">prev</a><span>|</span><a href="#42436275">next</a><span>|</span><label class="collapse" for="c-42436349">[-]</label><label class="expand" for="c-42436349">[1 more]</label></div><br/><div class="children"><div class="content">Intersects quite heavily if you&#x27;re defining a schema for your API</div><br/></div></div></div></div></div></div><div id="42438386" class="c"><input type="checkbox" id="c-42438386" checked=""/><div class="controls bullet"><span class="by">Naru41</span><span>|</span><a href="#42436165">prev</a><span>|</span><a href="#42438383">next</a><span>|</span><label class="collapse" for="c-42438386">[-]</label><label class="expand" for="c-42438386">[3 more]</label></div><br/><div class="children"><div class="content">Why not just use a naive struct from the beginning? memcpy is the fastest way to get serialize into a form that we can use in actual running program.</div><br/><div id="42438406" class="c"><input type="checkbox" id="c-42438406" checked=""/><div class="controls bullet"><span class="by">schmichael</span><span>|</span><a href="#42438386">parent</a><span>|</span><a href="#42438618">next</a><span>|</span><label class="collapse" for="c-42438406">[-]</label><label class="expand" for="c-42438406">[1 more]</label></div><br/><div class="children"><div class="content">The article goes into great detail about the benefits of an opaque api vs open structs. Somewhat unintuitively open structs are not necessarily the “fastest” largely due to pointers requiring heap allocations.
Opaque APIs can also be “faster” due to lazy loading and avoiding memcpy altogether. The latter appears in libraries like flat buffers but not here IIRC.</div><br/></div></div><div id="42438618" class="c"><input type="checkbox" id="c-42438618" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42438386">parent</a><span>|</span><a href="#42438406">prev</a><span>|</span><a href="#42438383">next</a><span>|</span><label class="collapse" for="c-42438618">[-]</label><label class="expand" for="c-42438618">[1 more]</label></div><br/><div class="children"><div class="content">&gt; memcpy is the fastest way<p>To bake endianess and alignment requirements into your protocol.</div><br/></div></div></div></div><div id="42438383" class="c"><input type="checkbox" id="c-42438383" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#42438386">prev</a><span>|</span><label class="collapse" for="c-42438383">[-]</label><label class="expand" for="c-42438383">[3 more]</label></div><br/><div class="children"><div class="content">This looks like an attempt to turn Go into Java&#x2F;C#.<p>I certainly won’t allow this to be used by the engineering teams under me.</div><br/><div id="42438477" class="c"><input type="checkbox" id="c-42438477" checked=""/><div class="controls bullet"><span class="by">pensatoio</span><span>|</span><a href="#42438383">parent</a><span>|</span><a href="#42438675">next</a><span>|</span><label class="collapse" for="c-42438477">[-]</label><label class="expand" for="c-42438477">[1 more]</label></div><br/><div class="children"><div class="content">Why? I&#x27;m going to encourage my engineers and other teams to use it. Using this API would 100% have prevented bugs created by accessing the generated structs directly, especially in the presence of an optional value.</div><br/></div></div><div id="42438675" class="c"><input type="checkbox" id="c-42438675" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#42438383">parent</a><span>|</span><a href="#42438477">prev</a><span>|</span><label class="collapse" for="c-42438675">[-]</label><label class="expand" for="c-42438675">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s attempt to provide a much more efficient and harder to misuse implementation to a project used in tons of places.</div><br/></div></div></div></div></div></div></div></div></div></body></html>