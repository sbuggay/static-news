<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733216467547" as="style"/><link rel="stylesheet" href="styles.css?v=1733216467547"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://chshersh.com/blog/2023-12-16-8-months-of-ocaml-after-8-years-of-haskell.html">8 months of OCaml after 8 years of Haskell in production (2023)</a> <span class="domain">(<a href="https://chshersh.com">chshersh.com</a>)</span></div><div class="subtext"><span>droideqa</span> | <span>148 comments</span></div><br/><div><div id="42304265" class="c"><input type="checkbox" id="c-42304265" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#42303796">next</a><span>|</span><label class="collapse" for="c-42304265">[-]</label><label class="expand" for="c-42304265">[1 more]</label></div><br/><div class="children"><div class="content">Both Haskell and OCaml are fantastic. It is really astonishing the degree to which advancement in mainstream programming languages these days is just copy pasting ideas from either.</div><br/></div></div><div id="42303796" class="c"><input type="checkbox" id="c-42303796" checked=""/><div class="controls bullet"><span class="by">penguin_booze</span><span>|</span><a href="#42304265">prev</a><span>|</span><a href="#42304014">next</a><span>|</span><label class="collapse" for="c-42303796">[-]</label><label class="expand" for="c-42303796">[6 more]</label></div><br/><div class="children"><div class="content">Like a moth to flame, I&#x27;m drawn to Haskell every 6 months or so. What drives me to it is its ability to express concepts (once you&#x27;re used to it) parsimoniously - like the point-free style in the example. Monads, I can understand&#x2F;manage. But by the time I hit Monad Transformers (and the n different packages available), the excitement turns into a headache.<p>It&#x27;s also a bummer that you need the containers package for basic DS. So, batteries not included, unlike Python. This also means that you need to use a package manager (stack or cabal) even for non-trivial programs, where a one-line ghci command line would have been more ergonomic.<p>That said, learning Haskell has had a very positive effect on how I think about and structure the programs I write in other languages (&quot;functional core, imperative shell&quot;). I don&#x27;t think I&#x27;ll ever program in Haskell in any semi-serious capacity. But these days, I get my daily functional fix from using jq on the command line.</div><br/><div id="42304053" class="c"><input type="checkbox" id="c-42304053" checked=""/><div class="controls bullet"><span class="by">MrMcCall</span><span>|</span><a href="#42303796">parent</a><span>|</span><a href="#42304052">next</a><span>|</span><label class="collapse" for="c-42304053">[-]</label><label class="expand" for="c-42304053">[1 more]</label></div><br/><div class="children"><div class="content">Back a decade+ ago when I was still using Microsoft in a corporate environment, I found F# and loved it because it changed how I thought about programming (in a very good way) with its being very concise, allowing me to naturally express algorithms, and giving the &quot;functional core, imperative shell&quot; functionality one can&#x27;t get in the old-and-new-school VS.NET solution sets that comprise a tiered client-server WCF-based model (thanks in large part to the utterly brilliant Juval Lowy&#x27;s IDesign approach).<p>Unfortunately, F# was very much a second-class citizen in the VS.NET space, so it was only useful for banging out tight C# classes in F# first, then translating them over to C#. (My fundamental db access classes were developed in F# then translated to C#; the crux were a parallel pair of isomorphic classes that did design-time swappable DB2 and SqlServer access.)<p>Beyond my refusal to use Microsoft for my OS anymore, it looks like F# has transitioned away from the original Don Syme authored minimal OCaml-based v2, into much more automagical v3+ stuff that I&#x27;m not interested in. They&#x27;re a brilliant design team, but well beyond what I need or want for my needs.<p>At the end of the day, it&#x27;s hard to keep things simple, yet effective, when the tool designers we depend on are always one-upping themselves. Somehow, it seems like a natural divergence as design tooling expands to meet the our expanding needs as devs. What&#x27;s good is that our perspective gets levelled-up, even if the tools either out-evolve our needs&#x2F;desires or just plain fail to meet them.</div><br/></div></div><div id="42304052" class="c"><input type="checkbox" id="c-42304052" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#42303796">parent</a><span>|</span><a href="#42304053">prev</a><span>|</span><a href="#42303888">next</a><span>|</span><label class="collapse" for="c-42304052">[-]</label><label class="expand" for="c-42304052">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s also a bummer that you need the containers package for basic DS. So, batteries not included<p>Batteries <i>are</i> included, because containers ships with every distribution of GHC, and you don&#x27;t need to use stack or cabal to expose it:<p><pre><code>    % ghci
    GHCi, version 9.4.8: https:&#x2F;&#x2F;www.haskell.org&#x2F;ghc&#x2F;  :? for help
    ghci&gt; import Data.Map
    ghci&gt; singleton 5 &quot;Hello&quot;
    fromList [(5,&quot;Hello&quot;)]
</code></pre>
Please try the same at your end and if it doesn&#x27;t work for you then you can let me know and I&#x27;ll try to help you resolve the issue.</div><br/></div></div><div id="42303888" class="c"><input type="checkbox" id="c-42303888" checked=""/><div class="controls bullet"><span class="by">thierrydamiba</span><span>|</span><a href="#42303796">parent</a><span>|</span><a href="#42304052">prev</a><span>|</span><a href="#42304014">next</a><span>|</span><label class="collapse" for="c-42303888">[-]</label><label class="expand" for="c-42303888">[3 more]</label></div><br/><div class="children"><div class="content">I feel like to use even the most basic python tools I need to use a package manager or find solutions for mix matched dependencies.<p>Is this problem unique to me?</div><br/><div id="42304124" class="c"><input type="checkbox" id="c-42304124" checked=""/><div class="controls bullet"><span class="by">reidrac</span><span>|</span><a href="#42303796">root</a><span>|</span><a href="#42303888">parent</a><span>|</span><a href="#42303992">next</a><span>|</span><label class="collapse" for="c-42304124">[-]</label><label class="expand" for="c-42304124">[1 more]</label></div><br/><div class="children"><div class="content">It all depends. For a quick script that I can write in 15 mins that uses an HTTP client, JSON and joins two APIs together, the standard library is OK.<p>To be fair, it could be almost a bash script (using curl and jq or something like that), but I&#x27;m more comfortable with Python.<p>So for one-off (or almost one-off) scripts, the standard library is worth avoiding dealing with dependencies.</div><br/></div></div><div id="42303992" class="c"><input type="checkbox" id="c-42303992" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#42303796">root</a><span>|</span><a href="#42303888">parent</a><span>|</span><a href="#42304124">prev</a><span>|</span><a href="#42304014">next</a><span>|</span><label class="collapse" for="c-42303992">[-]</label><label class="expand" for="c-42303992">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I feel nobody uses the standard library. Even for stuff like HTTP there is requests.</div><br/></div></div></div></div></div></div><div id="42304014" class="c"><input type="checkbox" id="c-42304014" checked=""/><div class="controls bullet"><span class="by">crvdgc</span><span>|</span><a href="#42303796">prev</a><span>|</span><a href="#42302834">next</a><span>|</span><label class="collapse" for="c-42304014">[-]</label><label class="expand" for="c-42304014">[1 more]</label></div><br/><div class="children"><div class="content">I made a similar transition (1 year Haskell, 2 year OCaml) and this pretty matches up my experience. Some more points:<p>1. Compiler speed: a clear win for OCaml<p>2. OCaml &#x27;s module system is more explicit (always qualified Map.find). Haskell&#x27;s type class system is more ergonomic (the instance is found through its type, so no explicit annotation needed, e.g. fmap fmap fmap, where the second must be the Reader&#x27;s fmap).<p>3. &gt; If I come to an existing OCaml project, the worst thing previous developers could do to it is have poor variable names, minimal documentation, and 200+ LOC functions. That’s fine, nothing extraordinary, I can handle that.<p>Though it&#x27;s not common, but functor-heavy codebase does give you a headache. On the other hand, unifying type class instances across packages is no fun either.<p>4. OCaml&#x27;s mixture of side effects and pure code tends to encourage using that in libraries and codebase. So expect more speed and more crashes.</div><br/></div></div><div id="42302834" class="c"><input type="checkbox" id="c-42302834" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42304014">prev</a><span>|</span><a href="#42302704">next</a><span>|</span><label class="collapse" for="c-42302834">[-]</label><label class="expand" for="c-42302834">[33 more]</label></div><br/><div class="children"><div class="content">Firstly, this doesn&#x27;t mention the thing that bothered me the most in my few encounters; how baroque and fluid the tooling is.<p>I have regularly run into code that can only be compiled by a rather narrow range of ghc versions; too old or too new and it just won&#x27;t.<p>&gt; Haskell probably has the most elegant syntax across all languages I’ve seen (maybe Idris is better because dependently typed code can become ugly in Haskell really quickly).<p>I have a general dislike for ML-type syntaxes, and Haskell is my least favorite of the ML-type syntaxes I have encountered.  Presumably there is some underlying set of principles that the author would like maximized that I assuredly do not.<p>&gt; There’s utter joy in expressing your ideas by typing as few characters as possible.<p>Disagree; if I did agree, then I would probably use something from the APL family or maybe Factor.</div><br/><div id="42303391" class="c"><input type="checkbox" id="c-42303391" checked=""/><div class="controls bullet"><span class="by">bbminner</span><span>|</span><a href="#42302834">parent</a><span>|</span><a href="#42303279">next</a><span>|</span><label class="collapse" for="c-42303391">[-]</label><label class="expand" for="c-42303391">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I have limited experience with FPs, and I can get a hang of what is happening in OCaml examples relatively easily, but Haskell examples feel more like something akin to Forth - if I really needed, I could parse it with my brain, but cryptic one liners like that feel more like &quot;puzzles&quot; than an actual useful program.</div><br/></div></div><div id="42303279" class="c"><input type="checkbox" id="c-42303279" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#42302834">parent</a><span>|</span><a href="#42303391">prev</a><span>|</span><a href="#42303075">next</a><span>|</span><label class="collapse" for="c-42303279">[-]</label><label class="expand" for="c-42303279">[14 more]</label></div><br/><div class="children"><div class="content">I wrote Haskell for a couple years and I _never_ figured out the indentation rules. The haskell people seemed confused that it was even possible to find it confusing<p>and then there’s “do” notation. I has three people tell me “it’s just a simple mechanical transformation from lambdas” oh yeah? how? they couldn’t explain that either</div><br/><div id="42303426" class="c"><input type="checkbox" id="c-42303426" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303974">next</a><span>|</span><label class="collapse" for="c-42303426">[-]</label><label class="expand" for="c-42303426">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    mySubroutine = do
      foo &lt;- mkFoo
      bar &lt;- mkbar foo
      mkBaz bar
    
    mySubroutineV2 =
      mkFoo &gt;&gt;= \foo -&gt;
        mkBar foo &gt;&gt;= \bar -&gt;
          mkBaz bar</code></pre></div><br/><div id="42303567" class="c"><input type="checkbox" id="c-42303567" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303426">parent</a><span>|</span><a href="#42303974">next</a><span>|</span><label class="collapse" for="c-42303567">[-]</label><label class="expand" for="c-42303567">[4 more]</label></div><br/><div class="children"><div class="content">Note that this is same desugaring for normal let<p><pre><code>  let x = y in F   &lt;===&gt;   (\x.F)(y)
</code></pre>
just replacing function application with a different function (&gt;&gt;=).</div><br/><div id="42303838" class="c"><input type="checkbox" id="c-42303838" checked=""/><div class="controls bullet"><span class="by">Athas</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303567">parent</a><span>|</span><a href="#42303863">next</a><span>|</span><label class="collapse" for="c-42303838">[-]</label><label class="expand" for="c-42303838">[1 more]</label></div><br/><div class="children"><div class="content">This is not the case in Haskell, because let-bindings can be self-referential, while lambdas cannot (without using a fixed point combinator). Also, in most functional languages, a let-binding causes type generalisation, which is not the case for a lambda.</div><br/></div></div><div id="42303863" class="c"><input type="checkbox" id="c-42303863" checked=""/><div class="controls bullet"><span class="by">chombier</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303567">parent</a><span>|</span><a href="#42303838">prev</a><span>|</span><a href="#42303752">next</a><span>|</span><label class="collapse" for="c-42303863">[-]</label><label class="expand" for="c-42303863">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly the same: `x` is given a polymorphic type (in F) in Haskell (restricted to values in ML) whereas the unannotated let-over-lambda will give `x`a monomorphic type.</div><br/></div></div><div id="42303752" class="c"><input type="checkbox" id="c-42303752" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303567">parent</a><span>|</span><a href="#42303863">prev</a><span>|</span><a href="#42303974">next</a><span>|</span><label class="collapse" for="c-42303752">[-]</label><label class="expand" for="c-42303752">[1 more]</label></div><br/><div class="children"><div class="content">You can desugar let bindings that way but often times (as I believe is the case in GHC) you have a `Let` term in your AST.</div><br/></div></div></div></div></div></div><div id="42303974" class="c"><input type="checkbox" id="c-42303974" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303426">prev</a><span>|</span><a href="#42304015">next</a><span>|</span><label class="collapse" for="c-42303974">[-]</label><label class="expand" for="c-42303974">[1 more]</label></div><br/><div class="children"><div class="content">The reason people can’t remember it on the spot is that it’s really not necessary to understand how do-notation desugars in order to use it.<p>People usually check it once, see that it is correct and forget about it.</div><br/></div></div><div id="42304015" class="c"><input type="checkbox" id="c-42304015" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303974">prev</a><span>|</span><a href="#42303895">next</a><span>|</span><label class="collapse" for="c-42304015">[-]</label><label class="expand" for="c-42304015">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a tutorial about do notation. Maybe it helps
<a href="https:&#x2F;&#x2F;elbear.com&#x2F;a-user-guide-for-haskell-monads" rel="nofollow">https:&#x2F;&#x2F;elbear.com&#x2F;a-user-guide-for-haskell-monads</a></div><br/></div></div><div id="42303895" class="c"><input type="checkbox" id="c-42303895" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42304015">prev</a><span>|</span><a href="#42303307">next</a><span>|</span><label class="collapse" for="c-42303895">[-]</label><label class="expand" for="c-42303895">[1 more]</label></div><br/><div class="children"><div class="content">Do-notation is not all that different—if anything, it is <i>simpler</i>—than async&#x2F;await syntax that&#x27;s gotten popular in a bunch of mainstream languages. I don&#x27;t know if that makes it easy or difficult in an absolute sense, but it isn&#x27;t any worse than Python&#x2F;JavaScript&#x2F;etc.<p>The indentation rules are definitely a mess though :&#x2F;</div><br/></div></div><div id="42303307" class="c"><input type="checkbox" id="c-42303307" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303895">prev</a><span>|</span><a href="#42303421">next</a><span>|</span><label class="collapse" for="c-42303307">[-]</label><label class="expand" for="c-42303307">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll agree about the weird Haskell indentation rules.<p>But do notation really is just syntactic sugar for a chain of &gt;&gt; and &gt;&gt;= applications (plus &quot;fail&quot; for invalid pattern matches). It&#x27;s not usually pretty or understandable to write it that way, but it&#x27;s a very simple translation. If the people you talked to couldn&#x27;t explain it to you, I think they maybe didn&#x27;t understand it well themselves.</div><br/></div></div><div id="42303421" class="c"><input type="checkbox" id="c-42303421" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303307">prev</a><span>|</span><a href="#42303317">next</a><span>|</span><label class="collapse" for="c-42303421">[-]</label><label class="expand" for="c-42303421">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and then there’s “do” notation. I has three people tell me “it’s just a simple mechanical transformation from lambdas” oh yeah? how? they couldn’t explain that either<p>Scala&#x27;s for&#x2F;yield (which is pretty similar) you can literally do an IDE action in IntelliJ to desugar it.<p>I forget the precise Haskell syntax, but do {a &lt;- x; b &lt;- y; c &lt;- z; w } is sugar for something like x &gt;&gt;= $ \a y &gt;&gt;= $ \b z &gt;&gt;= $ \c w . Hopefully the pattern is clear. Were there cases where you actually couldn&#x27;t see how to desugar something, or are you just nitpicking about them calling it a mechanical transformation without being to explain the precise rules?</div><br/></div></div><div id="42303700" class="c"><input type="checkbox" id="c-42303700" checked=""/><div class="controls bullet"><span class="by">worksonmymach</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303317">prev</a><span>|</span><a href="#42303931">next</a><span>|</span><label class="collapse" for="c-42303700">[-]</label><label class="expand" for="c-42303700">[1 more]</label></div><br/><div class="children"><div class="content">To understand &quot;do&quot; you need to understand the underlying &gt;&gt;= and return operators for your monad.<p>If you can use &gt;&gt;= and return to do it then &quot;do&quot; is indeed a mechanical transformation.<p>It is like await if you understand JS promises.</div><br/></div></div><div id="42303931" class="c"><input type="checkbox" id="c-42303931" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303279">parent</a><span>|</span><a href="#42303700">prev</a><span>|</span><a href="#42303075">next</a><span>|</span><label class="collapse" for="c-42303931">[-]</label><label class="expand" for="c-42303931">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I _never_ figured out the indentation rules<p>Weird.  Haskell&#x27;s my preferred language and I thought there was only one indentation rule - if something&#x27;s further to the right it&#x27;s part of the same expression, and if something&#x27;s down it&#x27;s a new expression.<p><pre><code>  f
   x
    y
  g z
</code></pre>
... With a slight addendum that you don&#x27;t need to write &#x27;let&#x27; on consecutive lines, e.g.<p><pre><code>  let x = ...
      y = ...</code></pre></div><br/></div></div></div></div><div id="42303075" class="c"><input type="checkbox" id="c-42303075" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#42302834">parent</a><span>|</span><a href="#42303279">prev</a><span>|</span><a href="#42302995">next</a><span>|</span><label class="collapse" for="c-42303075">[-]</label><label class="expand" for="c-42303075">[8 more]</label></div><br/><div class="children"><div class="content">That’s funny. I actually love Haskell syntax, it’s by far my favorite language to look at.</div><br/><div id="42303221" class="c"><input type="checkbox" id="c-42303221" checked=""/><div class="controls bullet"><span class="by">gooosle</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303075">parent</a><span>|</span><a href="#42302995">next</a><span>|</span><label class="collapse" for="c-42303221">[-]</label><label class="expand" for="c-42303221">[7 more]</label></div><br/><div class="children"><div class="content">People often say that before they realize how complex and messy real-world Haskell looks like. The indentation-based rules aren&#x27;t even defined anywhere except via imperative code in the implementation.</div><br/><div id="42303915" class="c"><input type="checkbox" id="c-42303915" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303221">parent</a><span>|</span><a href="#42304029">next</a><span>|</span><label class="collapse" for="c-42303915">[-]</label><label class="expand" for="c-42303915">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, isn&#x27;t this the definition? 10.3 of <a href="https:&#x2F;&#x2F;www.haskell.org&#x2F;onlinereport&#x2F;haskell2010&#x2F;haskellch10.html" rel="nofollow">https:&#x2F;&#x2F;www.haskell.org&#x2F;onlinereport&#x2F;haskell2010&#x2F;haskellch10...</a><p>&gt; The effect of layout is specified in this section by describing how to add braces and semicolons to a laid-out program.<p>I wasn&#x27;t going to actually read that in detail to see if it makes any sense, though, but it looks very detailed :).</div><br/></div></div><div id="42304029" class="c"><input type="checkbox" id="c-42304029" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303221">parent</a><span>|</span><a href="#42303915">prev</a><span>|</span><a href="#42304048">next</a><span>|</span><label class="collapse" for="c-42304029">[-]</label><label class="expand" for="c-42304029">[1 more]</label></div><br/><div class="children"><div class="content">Nothing forces it to be messy. A well-tended haskell codebase is great. On the oposite, I would say that a poor haskell codebase is painful, but far from being as painful as a poor java&#x2F;js codebase.<p>Anecdotally, in my years of haskell at separate places, I had to debug&#x2F;repl maybe had to repl once or twice. I wish I could say that of mycurrent java gig.</div><br/></div></div><div id="42304048" class="c"><input type="checkbox" id="c-42304048" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303221">parent</a><span>|</span><a href="#42304029">prev</a><span>|</span><a href="#42303715">next</a><span>|</span><label class="collapse" for="c-42304048">[-]</label><label class="expand" for="c-42304048">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written Haskell code in production and I still find the syntax the most eloquent. And you don&#x27;t have to know the indentation rules, you just pick them up from usage. Just like you don&#x27;t have to know the grammar rules.</div><br/></div></div><div id="42303715" class="c"><input type="checkbox" id="c-42303715" checked=""/><div class="controls bullet"><span class="by">worksonmymach</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303221">parent</a><span>|</span><a href="#42304048">prev</a><span>|</span><a href="#42303662">next</a><span>|</span><label class="collapse" for="c-42303715">[-]</label><label class="expand" for="c-42303715">[1 more]</label></div><br/><div class="children"><div class="content">Oh sir we call that &quot;operational semantics&quot;</div><br/></div></div><div id="42303662" class="c"><input type="checkbox" id="c-42303662" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303221">parent</a><span>|</span><a href="#42303715">prev</a><span>|</span><a href="#42302995">next</a><span>|</span><label class="collapse" for="c-42303662">[-]</label><label class="expand" for="c-42303662">[2 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s true, that&#x27;s such a disappointment. I always thought of Haskell as the pinnacle of mathematical discipline in programming (though too hard for me to wrap my head around!).</div><br/><div id="42304095" class="c"><input type="checkbox" id="c-42304095" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303662">parent</a><span>|</span><a href="#42302995">next</a><span>|</span><label class="collapse" for="c-42304095">[-]</label><label class="expand" for="c-42304095">[1 more]</label></div><br/><div class="children"><div class="content">Such a pinnacle would be Agda.
Haskell has mathematical holes.</div><br/></div></div></div></div></div></div></div></div><div id="42302995" class="c"><input type="checkbox" id="c-42302995" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#42302834">parent</a><span>|</span><a href="#42303075">prev</a><span>|</span><a href="#42302704">next</a><span>|</span><label class="collapse" for="c-42302995">[-]</label><label class="expand" for="c-42302995">[9 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting you dislike ML syntaxes when they&#x27;re generally thought to be the cleanest syntaxes. What syntax families do you generally like?<p>Also, Haskell isn&#x27;t really ML-syntax. I love MLs but find Haskell syntax pretty ugly.</div><br/><div id="42303871" class="c"><input type="checkbox" id="c-42303871" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42302995">parent</a><span>|</span><a href="#42303351">next</a><span>|</span><label class="collapse" for="c-42303871">[-]</label><label class="expand" for="c-42303871">[1 more]</label></div><br/><div class="children"><div class="content">I also dislike them. And I wouldn&#x27;t disagree about them being &quot;the cleanest&quot;, but cleanliness of syntax is only one concern. I also need to be able to mentally parse it, and on that from OCaml is very bad in my experience (haven&#x27;t used Haskell much so I can&#x27;t comment on that).<p>I&#x27;ve said this before but if you remove all punctuation and capitalisation from English it will make it look &quot;cleaner&quot;, but it will also make it awful to read.<p>Look how &quot;clean&quot; text is if you get rid of all the spaces!<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Scriptio_continua#&#x2F;media&#x2F;File%3AVergilius_Augusteus%2C_Georgica_141.jpg" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Scriptio_continua#&#x2F;media&#x2F;File%...</a><p>Clearly brilliant.</div><br/></div></div><div id="42303351" class="c"><input type="checkbox" id="c-42303351" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42302995">parent</a><span>|</span><a href="#42303871">prev</a><span>|</span><a href="#42303082">next</a><span>|</span><label class="collapse" for="c-42303351">[-]</label><label class="expand" for="c-42303351">[2 more]</label></div><br/><div class="children"><div class="content">I love most entries in the Lisp family.<p>I find Python to be quite readable as well.</div><br/><div id="42303367" class="c"><input type="checkbox" id="c-42303367" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303351">parent</a><span>|</span><a href="#42303082">next</a><span>|</span><label class="collapse" for="c-42303367">[-]</label><label class="expand" for="c-42303367">[1 more]</label></div><br/><div class="children"><div class="content">If you like Python and Lisps, then I&#x27;m surprised you don&#x27;t like F#. It is much more concise than Python, even for pure OOP programming.</div><br/></div></div></div></div><div id="42303082" class="c"><input type="checkbox" id="c-42303082" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42302995">parent</a><span>|</span><a href="#42303351">prev</a><span>|</span><a href="#42302704">next</a><span>|</span><label class="collapse" for="c-42303082">[-]</label><label class="expand" for="c-42303082">[5 more]</label></div><br/><div class="children"><div class="content">&gt; when they&#x27;re generally thought to be the cleanest syntaxes<p>That might be true for academics. But most engineers don&#x27;t consider ML syntax to be the cleanest, since most don&#x27;t know any ML language.</div><br/><div id="42303125" class="c"><input type="checkbox" id="c-42303125" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303082">parent</a><span>|</span><a href="#42303091">next</a><span>|</span><label class="collapse" for="c-42303125">[-]</label><label class="expand" for="c-42303125">[2 more]</label></div><br/><div class="children"><div class="content">MLs aren&#x27;t really academic languages aside from Standard ML. F# and OCaml are very pragmatic languages. The cleaner parts of Rust came from ML.<p>What syntaxes do engineers find clean? I don&#x27;t understand the distinction you&#x27;re making.</div><br/><div id="42303343" class="c"><input type="checkbox" id="c-42303343" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303125">parent</a><span>|</span><a href="#42303091">next</a><span>|</span><label class="collapse" for="c-42303343">[-]</label><label class="expand" for="c-42303343">[1 more]</label></div><br/><div class="children"><div class="content">I assume they mean:<p><pre><code>  * Python, Ruby, C#, Java, Go-style languages?
</code></pre>
I imagine <i>most</i> developers operate in neither ML languages nor Lisp-style languages.<p>The most advanced &quot;FP&quot; trick that I imagine most developers use is Fluent-style programming with a whole bunch of their language&#x27;s equivalent of:<p><pre><code>  variable
    .map do ... end
    .map do ... end
    .flatten
</code></pre>
Addendum: or maybe Linq in C#
Addendum 2:<p>And even the fluent-style trick in those languages tends to follow a similar pattern. Using Kotlin and Ruby as examples, since those are my (edit: main) languages,<p><pre><code>  variable
    .map do |i| something_with(i) end
    .map { |i| something_else(i) }
    .flatten
</code></pre>
shows familiar tricks. The dot operator implies that the thing previous to it has an action being done; and curly braces or the &quot;do&quot; operation both imply a block of some sort, and so a quick glance is easy to follow.<p>In Kotlin, this gets a little bit more confusing (yes, really) because it&#x27;s common to see:<p><pre><code>  variable
    .map { somethingWith(it) }
    .map { somethingElse(it) }
    .flatten()
</code></pre>
And now there&#x27;s this magic &quot;it&quot; variable, but that&#x27;s easy enough to guess from, especially with syntax highlighting.<p>Anything more advanced than that and the cognitive load for these language starts to rise for people that aren&#x27;t deep in them.<p>When you&#x27;re starting working with a new language, that does increase difficulty and may even be so much of a barrier that developers may not want to hop over.</div><br/></div></div></div></div><div id="42303091" class="c"><input type="checkbox" id="c-42303091" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303082">parent</a><span>|</span><a href="#42303125">prev</a><span>|</span><a href="#42302704">next</a><span>|</span><label class="collapse" for="c-42303091">[-]</label><label class="expand" for="c-42303091">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  most engineers don&#x27;t consider ML syntax to be the cleanest, since most don&#x27;t know any ML language.<p>This is like saying &quot;most uncontacted Amazonian tribes don&#x27;t like Shakespeare, because they&#x27;ve never read it&quot;. Sure, but why would we care about their opinion on this topic?</div><br/><div id="42303211" class="c"><input type="checkbox" id="c-42303211" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#42302834">root</a><span>|</span><a href="#42303091">parent</a><span>|</span><a href="#42302704">next</a><span>|</span><label class="collapse" for="c-42303211">[-]</label><label class="expand" for="c-42303211">[1 more]</label></div><br/><div class="children"><div class="content">They might think Shakespeare&#x27;s story are silly even if they did read it. In fact, there is at least one widely publicized instance where exactly the same thing happened with a culture that wasn&#x27;t exposed to Shakespeare before:<p><a href="https:&#x2F;&#x2F;law.ubalt.edu&#x2F;downloads&#x2F;law_downloads&#x2F;IRC_Shakespeare_in_the_Bush.pdf" rel="nofollow">https:&#x2F;&#x2F;law.ubalt.edu&#x2F;downloads&#x2F;law_downloads&#x2F;IRC_Shakespear...</a><p>The same idea is probably true with programmers who have grown used to C-like syntax or even Python-like or Ruby-like syntax. Syntax is at least in great part a cultural thing and your &quot;cultural background&quot; can affect your judgement in many cases:<p>1. Are braces good? Some programmers find them noisy and distracting and prefer end keywords or significant whitespace, but other programmers like the regularity and simplicity of marking all code blocks with braces.<p>2. Should the syntax strive for terseness or verbosity? Or perhaps try to keep a middle ground? At one end of the spectrum, Java is extremely verbose, but a lot of Java engineers (who have generally been exposed to at least one less-verbose language) are perfectly OK with it. The trick is that the main way that code gets typed in Java used to be copy-paste or IDE code generation (and nowadays with LLMs typing verbose code is even easier) and reading and navigating the code is done with the help of an IDE, so a lot of the effects of having a verbose language are mitigated. Diffs are harder to review, but in the Enterprise app world, which is Java&#x27;s bread and butter, code reviews are more of a rubber stamp (if they are done at all).<p>3. Lisp-like S-expression syntax is also highly controversial. Many people who are introduced with it hate it with passion, mostly because the most important syntax feature (the parentheses) is repeated so often that it can be hard to read, but advocates extol the amazing expressive power, where the same syntax can be use to express code and data and &quot;a DSL&quot; is basically just normal code.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42302704" class="c"><input type="checkbox" id="c-42302704" checked=""/><div class="controls bullet"><span class="by">zeendo</span><span>|</span><a href="#42302834">prev</a><span>|</span><a href="#42303621">next</a><span>|</span><label class="collapse" for="c-42302704">[-]</label><label class="expand" for="c-42302704">[4 more]</label></div><br/><div class="children"><div class="content">Being conservative in the language extensions you use&#x2F;allow in an organization is pretty important to maintaining usability of Haskell as a language.<p>Do we ever use TypeFamilies and DataKinds? Sure, but it&#x27;s very rare.<p><a href="https:&#x2F;&#x2F;www.simplehaskell.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.simplehaskell.org&#x2F;</a> is a pretty reasonable set of guidelines (though we opt for a more conservative approach ourselves)</div><br/><div id="42303014" class="c"><input type="checkbox" id="c-42303014" checked=""/><div class="controls bullet"><span class="by">rjh29</span><span>|</span><a href="#42302704">parent</a><span>|</span><a href="#42302898">next</a><span>|</span><label class="collapse" for="c-42303014">[-]</label><label class="expand" for="c-42303014">[2 more]</label></div><br/><div class="children"><div class="content">Seems similar to Perl, where there are about 20 ways to do any given thing, and 15 of those are deprecated or not recommended by the community.</div><br/><div id="42303951" class="c"><input type="checkbox" id="c-42303951" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42302704">root</a><span>|</span><a href="#42303014">parent</a><span>|</span><a href="#42302898">next</a><span>|</span><label class="collapse" for="c-42303951">[-]</label><label class="expand" for="c-42303951">[1 more]</label></div><br/><div class="children"><div class="content">It usually follows that the fancier stuff is done for a reason, not just artistic expression.<p>So it&#x27;s not that they&#x27;re not the best way, it&#x27;s just that not everyone knows how to do it that well.</div><br/></div></div></div></div><div id="42302898" class="c"><input type="checkbox" id="c-42302898" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#42302704">parent</a><span>|</span><a href="#42303014">prev</a><span>|</span><a href="#42303621">next</a><span>|</span><label class="collapse" for="c-42302898">[-]</label><label class="expand" for="c-42302898">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see some folks encouraging how to solve problems with less fancy features&#x2F;lang extentions (especially in commercial context), considering not all Haskell coders are programming language&#x2F;compiler nerds :)</div><br/></div></div></div></div><div id="42303621" class="c"><input type="checkbox" id="c-42303621" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#42302704">prev</a><span>|</span><a href="#42302738">next</a><span>|</span><label class="collapse" for="c-42303621">[-]</label><label class="expand" for="c-42303621">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    (…on Stripe API…)
    OCaml: 1 (last change was 8 years ago, so it’s more like zero)
</code></pre>
I’ve been using OCaml for some time, primarily for my pet project, but also and some minor at-work utilities. One such thing was interacting with Datadog which, unsurprisingly, doesn’t provide OCaml SDK.<p>In short: Experience was great. Not only implementing specs with provided specs while using OCaml tooling was fast but also when I got to the rate limiting, I’ve been able to refactor code in around 20 minutes and then it felt like magic transformation.<p>My take away from that experience is that I wouldn’t use library availability as a hard argument. Every external library is liability and if language provides comfortable tooling and helpers then probably having own code on use-adequate level of abstraction (instead of high level kitchen sink) might preferred.<p>For high number of external integration I would use something like Go instead, which has exactly that, but as an API implementer I’d prefer to use OCaml instead.</div><br/></div></div><div id="42302738" class="c"><input type="checkbox" id="c-42302738" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42303621">prev</a><span>|</span><a href="#42303909">next</a><span>|</span><label class="collapse" for="c-42302738">[-]</label><label class="expand" for="c-42302738">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Both Haskell and OCaml have kinda barebones standard libraries. […] Haskell doesn’t include Map and HashMap;<p>The Haskell standard library was split off into smaller parts. Map used to be part of the standard library. To date the containers package (which contains Map) is still pre-installed alongside the GHC compiler. So it should be considered part of the standard library.<p>Check out the documentation for GHC 3.02 <a href="https:&#x2F;&#x2F;downloads.haskell.org&#x2F;~ghc&#x2F;3.02&#x2F;docs&#x2F;users_guide&#x2F;users_guide-5.html#ss5.6" rel="nofollow">https:&#x2F;&#x2F;downloads.haskell.org&#x2F;~ghc&#x2F;3.02&#x2F;docs&#x2F;users_guide&#x2F;use...</a> it clearly shows a FiniteMap type being provided.</div><br/><div id="42302833" class="c"><input type="checkbox" id="c-42302833" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42302738">parent</a><span>|</span><a href="#42303909">next</a><span>|</span><label class="collapse" for="c-42302833">[-]</label><label class="expand" for="c-42302833">[6 more]</label></div><br/><div class="children"><div class="content">I have some sympathy for &quot;divide and conquer&quot; but for me, libc and libm and libffi seem like very good splits. libgnuc is just having a lend, libobjc is beginning to feel like I&#x27;m being trolled and when I learned about stdlib I decided to stop worrying.<p>There was a time when the fastest way to resolve circular dependencies in the library chain was to simply add -Lthing multiple times in sequence so that a subsequent library could be sure the name list of the priors were loaded, including the dependencies down &quot;right&quot; of it in the list.<p>Taking something as fundamental to what FP is like map&#x2F;reduce and saying &quot;this can live in an adjunct library&quot; feels like somebody took divide and conquer a litte too far.</div><br/><div id="42302939" class="c"><input type="checkbox" id="c-42302939" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#42302738">root</a><span>|</span><a href="#42302833">parent</a><span>|</span><a href="#42302862">next</a><span>|</span><label class="collapse" for="c-42302939">[-]</label><label class="expand" for="c-42302939">[1 more]</label></div><br/><div class="children"><div class="content">This is Map as in Data.Map.Map, not as in Data.Functor.fmap.</div><br/></div></div><div id="42302862" class="c"><input type="checkbox" id="c-42302862" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302738">root</a><span>|</span><a href="#42302833">parent</a><span>|</span><a href="#42302939">prev</a><span>|</span><a href="#42303909">next</a><span>|</span><label class="collapse" for="c-42302862">[-]</label><label class="expand" for="c-42302862">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Taking something as fundamental to what FP is like map&#x2F;reduce and saying &quot;this can live in an adjunct library&quot; feels like somebody took divide and conquer a litte too far.<p>What are you talking about?</div><br/><div id="42302878" class="c"><input type="checkbox" id="c-42302878" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42302738">root</a><span>|</span><a href="#42302862">parent</a><span>|</span><a href="#42303909">next</a><span>|</span><label class="collapse" for="c-42302878">[-]</label><label class="expand" for="c-42302878">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The Haskell standard library was split off into smaller parts. Map used to be part of the standard library. To date the containers package (which contains Map) is still pre-installed alongside the GHC compiler. So it should be considered part of the standard library.</i><p>See those words &quot;to date&quot; and &quot;considered&quot; Not Is, is considered, to date. Thats what I am talking about.</div><br/><div id="42303123" class="c"><input type="checkbox" id="c-42303123" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302738">root</a><span>|</span><a href="#42302878">parent</a><span>|</span><a href="#42303909">next</a><span>|</span><label class="collapse" for="c-42303123">[-]</label><label class="expand" for="c-42303123">[2 more]</label></div><br/><div class="children"><div class="content">Sure.  But what does Map have to do with map and reduce?</div><br/><div id="42303626" class="c"><input type="checkbox" id="c-42303626" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302738">root</a><span>|</span><a href="#42303123">parent</a><span>|</span><a href="#42303909">next</a><span>|</span><label class="collapse" for="c-42303626">[-]</label><label class="expand" for="c-42303626">[1 more]</label></div><br/><div class="children"><div class="content">To be less snarky: this might be a bit confusing to non-Haskellers.<p>The Map they are talking about here is a key-value-store datatype.  It has nothing to do with the &#x27;map&#x27; function.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42303909" class="c"><input type="checkbox" id="c-42303909" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#42302738">prev</a><span>|</span><a href="#42304160">next</a><span>|</span><label class="collapse" for="c-42303909">[-]</label><label class="expand" for="c-42303909">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s not exciting to write a GitHub API client and parse tons of JSON.<p>While buried in our monorepo, so not very accessible, we just open sourced our product that is written in Ocaml and we have a GitHub client that is generated from the OpenAPI schema.<p>It is separated out from any I&#x2F;O so it can be used in any I&#x2F;O context.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;terrateamio&#x2F;terrateam&#x2F;tree&#x2F;main&#x2F;code&#x2F;src&#x2F;githubc2">https:&#x2F;&#x2F;github.com&#x2F;terrateamio&#x2F;terrateam&#x2F;tree&#x2F;main&#x2F;code&#x2F;src&#x2F;...</a></div><br/></div></div><div id="42304160" class="c"><input type="checkbox" id="c-42304160" checked=""/><div class="controls bullet"><span class="by">hugodan</span><span>|</span><a href="#42303909">prev</a><span>|</span><a href="#42303404">next</a><span>|</span><label class="collapse" for="c-42304160">[-]</label><label class="expand" for="c-42304160">[1 more]</label></div><br/><div class="children"><div class="content">Haskell provides by far the best refactoring experience of all languages I’ve ever used.</div><br/></div></div><div id="42303404" class="c"><input type="checkbox" id="c-42303404" checked=""/><div class="controls bullet"><span class="by">bhargav</span><span>|</span><a href="#42304160">prev</a><span>|</span><a href="#42303768">next</a><span>|</span><label class="collapse" for="c-42303404">[-]</label><label class="expand" for="c-42303404">[17 more]</label></div><br/><div class="children"><div class="content">Maybe because I haven’t used languages like these in the past, but I hardly think this is elegant, much read readale. I would hate my life trying to parse code like this in a 10k LOC codebase.<p>strSum = sum . map read . words</div><br/><div id="42303450" class="c"><input type="checkbox" id="c-42303450" checked=""/><div class="controls bullet"><span class="by">fleshmonad</span><span>|</span><a href="#42303404">parent</a><span>|</span><a href="#42303473">next</a><span>|</span><label class="collapse" for="c-42303450">[-]</label><label class="expand" for="c-42303450">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually very readable once you get the hang of it. The transition from imperative paradigms to Haskell can be tough, but once you&#x27;ve overcome this barrier, the code reads effortlessly. In your example case: split the string into a list of words, that is tokenize based on spaces. Then map the read function onto this, which will parse each of the &quot;words&quot; in the list into some type. Annotations would likely be needed here. Then sum this list.<p>I much prefer this over 10 levels of class indirections or procedural style.</div><br/><div id="42303686" class="c"><input type="checkbox" id="c-42303686" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303450">parent</a><span>|</span><a href="#42303738">next</a><span>|</span><label class="collapse" for="c-42303686">[-]</label><label class="expand" for="c-42303686">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it the case that anything is very readable once you get the hang of it?
I think the problem is exactly in the &quot;get the hang of it&quot; part. For some languages, that&#x27;s really difficult, while for others it&#x27;s almost trivial. From my own experience, Haskell is very very difficult to &quot;get the hang of&quot; despite my multiple attempts, while something like Javascript is trivial for me (interestingly enough, except when it uses too much of the new FP patterns!) even when I do not program on it daily.</div><br/><div id="42303852" class="c"><input type="checkbox" id="c-42303852" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303686">parent</a><span>|</span><a href="#42303738">next</a><span>|</span><label class="collapse" for="c-42303852">[-]</label><label class="expand" for="c-42303852">[1 more]</label></div><br/><div class="children"><div class="content">This is like complaining that Spanish is so hard to learn while English is actually quite intuitive. Of course it’s easier to understand what you already know.</div><br/></div></div></div></div><div id="42303738" class="c"><input type="checkbox" id="c-42303738" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303450">parent</a><span>|</span><a href="#42303686">prev</a><span>|</span><a href="#42303473">next</a><span>|</span><label class="collapse" for="c-42303738">[-]</label><label class="expand" for="c-42303738">[2 more]</label></div><br/><div class="children"><div class="content">I really like the FP paradigm, but could you all stop using weird abbreviations and random characters as substitute for operations?<p>You don&#x27;t do programming with chalk on a wallboard, for crying out loud. Ideally, you are using a good IDE with syntax completion. Therefore, readability matters more than the ability to bang out commands in as few keystrokes as possible.</div><br/><div id="42304123" class="c"><input type="checkbox" id="c-42304123" checked=""/><div class="controls bullet"><span class="by">veqq</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303738">parent</a><span>|</span><a href="#42303473">next</a><span>|</span><label class="collapse" for="c-42304123">[-]</label><label class="expand" for="c-42304123">[1 more]</label></div><br/><div class="children"><div class="content">Iverson&#x27;s Notation as a Tool of Thought defends the opposite idea (and explains the reason for APL): <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25249563">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25249563</a><p>It&#x27;s about phase transitions. When you understand the system, shorter symbols are easier&#x2F;faster to reason with. If your primitives are well thought out for the domain, this notation will be the optimal way of understanding it!<p>On the other hand, longer names help on board new people. Theoretically, you could avoid this issue by transforming back and forth. Uiua e.g. lets you enter symbols by typing out their names. Typing &quot;sum = reduce add&quot; becomes: &quot;sum ← &#x2F;+&quot;. If you transform it back...<p>Imagine if you could encode the std lib with aliases!</div><br/></div></div></div></div></div></div><div id="42303473" class="c"><input type="checkbox" id="c-42303473" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#42303404">parent</a><span>|</span><a href="#42303450">prev</a><span>|</span><a href="#42304083">next</a><span>|</span><label class="collapse" for="c-42303473">[-]</label><label class="expand" for="c-42303473">[5 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re familiar with Haskell, this is something you can just look at and parse without thinking. It&#x27;s all basic Haskell syntax and concepts (function composition and partial application). I haven&#x27;t touched Haskell for a few years and I didn&#x27;t have any trouble interpreting it as &quot;strSum is a function that takes a single string argument, splits it by whitespace, interprets each chunk as a number, and returns the sum&quot;.</div><br/><div id="42303639" class="c"><input type="checkbox" id="c-42303639" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303473">parent</a><span>|</span><a href="#42304083">next</a><span>|</span><label class="collapse" for="c-42303639">[-]</label><label class="expand" for="c-42303639">[4 more]</label></div><br/><div class="children"><div class="content">I’m not familiar with Haskell and I could read almost all of that from it. No idea how you can tell it splits on white space though.</div><br/><div id="42304157" class="c"><input type="checkbox" id="c-42304157" checked=""/><div class="controls bullet"><span class="by">reidrac</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303639">parent</a><span>|</span><a href="#42303943">next</a><span>|</span><label class="collapse" for="c-42304157">[-]</label><label class="expand" for="c-42304157">[1 more]</label></div><br/><div class="children"><div class="content">As a Haskell noob, I had the same problem a few times. Essentially: there&#x27;s a function to do what you want to do, but good look finding it!<p>Someone thought &quot;words&quot; was the perfect name, and it wasn&#x27;t me!</div><br/></div></div><div id="42303943" class="c"><input type="checkbox" id="c-42303943" checked=""/><div class="controls bullet"><span class="by">dawidloubser</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303639">parent</a><span>|</span><a href="#42304157">prev</a><span>|</span><a href="#42303913">next</a><span>|</span><label class="collapse" for="c-42303943">[-]</label><label class="expand" for="c-42303943">[1 more]</label></div><br/><div class="children"><div class="content">I guess the more succinct the code, the more the reliance on understanding what a function actually does - either through experience, or by reading the docs. The <i>words</i> function is simply:<p><pre><code>  words :: String -&gt; [String]
</code></pre>
So that<p><pre><code>  words &quot;foo bar baz&quot;
  -- Produces: [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
</code></pre>
In my experience, both the blessing and the curse of Haskell&#x27;s incredible succinct expressiveness is that, like other specialised languages - for example using latin for succinctly-expressed legal terms - you need a strong understanding of the language and its standard library - similar to the library of commonly used &quot;legal terms&quot; in law circles - to participate meaningfully.<p>Haskell, and languages like Go (which anybody with a bit of programming experience can easily follow) have very different goals.<p>Like many in this discussion, I too have developed a love&#x2F;hate thing with Haskell. But boy, are the good parts <i>good</i> ...</div><br/></div></div><div id="42303913" class="c"><input type="checkbox" id="c-42303913" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303639">parent</a><span>|</span><a href="#42303943">prev</a><span>|</span><a href="#42304083">next</a><span>|</span><label class="collapse" for="c-42303913">[-]</label><label class="expand" for="c-42303913">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s where you just have to know what the &quot;words&quot; function from the standard library does.</div><br/></div></div></div></div></div></div><div id="42304083" class="c"><input type="checkbox" id="c-42304083" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#42303404">parent</a><span>|</span><a href="#42303473">prev</a><span>|</span><a href="#42303569">next</a><span>|</span><label class="collapse" for="c-42304083">[-]</label><label class="expand" for="c-42304083">[1 more]</label></div><br/><div class="children"><div class="content">You can see it as a pipeline where the output of the right-most
function is plugged into the input of the function to its left.</div><br/></div></div><div id="42303569" class="c"><input type="checkbox" id="c-42303569" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#42303404">parent</a><span>|</span><a href="#42304083">prev</a><span>|</span><a href="#42303433">next</a><span>|</span><label class="collapse" for="c-42303569">[-]</label><label class="expand" for="c-42303569">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe because I haven’t used languages like these in the past [...]<p>Yes, that definitely the case.<p>If you know what each function above does, including the function composition dot (.), then this is like reading English — assuming you know how to read English.</div><br/></div></div><div id="42303433" class="c"><input type="checkbox" id="c-42303433" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#42303404">parent</a><span>|</span><a href="#42303569">prev</a><span>|</span><a href="#42303812">next</a><span>|</span><label class="collapse" for="c-42303433">[-]</label><label class="expand" for="c-42303433">[2 more]</label></div><br/><div class="children"><div class="content">In a production application you generally don&#x27;t write code like that. I find it tends to be the opposite problem where you often see giant `do` blocks performing all sorts of monadic effects.</div><br/><div id="42303477" class="c"><input type="checkbox" id="c-42303477" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303433">parent</a><span>|</span><a href="#42303812">next</a><span>|</span><label class="collapse" for="c-42303477">[-]</label><label class="expand" for="c-42303477">[1 more]</label></div><br/><div class="children"><div class="content">You especially wouldn&#x27;t use `read`.</div><br/></div></div></div></div><div id="42303812" class="c"><input type="checkbox" id="c-42303812" checked=""/><div class="controls bullet"><span class="by">worksonmymach</span><span>|</span><a href="#42303404">parent</a><span>|</span><a href="#42303433">prev</a><span>|</span><a href="#42303768">next</a><span>|</span><label class="collapse" for="c-42303812">[-]</label><label class="expand" for="c-42303812">[2 more]</label></div><br/><div class="children"><div class="content">1. Change . to |<p>2. Reverse<p>Now you have:<p>words | map read | sum<p>Or..<p>$ cat words | map -e read | sum</div><br/><div id="42304240" class="c"><input type="checkbox" id="c-42304240" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#42303404">root</a><span>|</span><a href="#42303812">parent</a><span>|</span><a href="#42303768">next</a><span>|</span><label class="collapse" for="c-42304240">[-]</label><label class="expand" for="c-42304240">[1 more]</label></div><br/><div class="children"><div class="content">Would you propose the same change for nested function calls y = f(g(h(x))), changing it into y = x | h | g | f ?</div><br/></div></div></div></div></div></div><div id="42304060" class="c"><input type="checkbox" id="c-42304060" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42303768">prev</a><span>|</span><a href="#42302688">next</a><span>|</span><label class="collapse" for="c-42304060">[-]</label><label class="expand" for="c-42304060">[1 more]</label></div><br/><div class="children"><div class="content">Also opam nowadays is finally working on Windows, which is kind of great, Haskell used to have an advantage there.</div><br/></div></div><div id="42302688" class="c"><input type="checkbox" id="c-42302688" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#42304060">prev</a><span>|</span><a href="#42303754">next</a><span>|</span><label class="collapse" for="c-42302688">[-]</label><label class="expand" for="c-42302688">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I feel that I can focus on actually building stuff with this language.<p>This is very much how I felt when using Rust as a previous production Haskell user. I enjoyed aspects of Haskell, and I&#x27;m still very impressed with it, but it seems to call up a kind of perfectionism that I don&#x27;t experience nearly as much with other languages.</div><br/><div id="42303665" class="c"><input type="checkbox" id="c-42303665" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#42302688">parent</a><span>|</span><a href="#42303754">next</a><span>|</span><label class="collapse" for="c-42303665">[-]</label><label class="expand" for="c-42303665">[2 more]</label></div><br/><div class="children"><div class="content">IME, the trick with perfectionism is knowing when to apply it. I.e, don&#x27;t do it at the beginning but at the moment when the initial version starts falling through. Also, do it on the general area the issue lays (not &quot;everywhere&quot;).</div><br/><div id="42303848" class="c"><input type="checkbox" id="c-42303848" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#42302688">root</a><span>|</span><a href="#42303665">parent</a><span>|</span><a href="#42303754">next</a><span>|</span><label class="collapse" for="c-42303848">[-]</label><label class="expand" for="c-42303848">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely. But with Haskell in particular, there are endless expressiveness micro-optimizations like &quot;how can I write this point-free&quot;, &quot;is there a combinator that would allow expressing this differently&quot;, &quot;how can I express more of this in the type system&quot;...<p>I am sure it&#x27;s <i>possible</i> to write Haskell and just not fall into that trap, but I found that Haskell was <i>especially</i> prone to nerd-sniping the micro-optimizing part of my brain, in a way that other languages don&#x27;t.</div><br/></div></div></div></div></div></div><div id="42303754" class="c"><input type="checkbox" id="c-42303754" checked=""/><div class="controls bullet"><span class="by">chshersh</span><span>|</span><a href="#42302688">prev</a><span>|</span><a href="#42303553">next</a><span>|</span><label class="collapse" for="c-42303754">[-]</label><label class="expand" for="c-42303754">[3 more]</label></div><br/><div class="children"><div class="content">Hey,<p>Author here<p>Happy to answer any questions! At this point, I have 18 months of OCaml experience in production.</div><br/><div id="42303773" class="c"><input type="checkbox" id="c-42303773" checked=""/><div class="controls bullet"><span class="by">adamddev1</span><span>|</span><a href="#42303754">parent</a><span>|</span><a href="#42303553">next</a><span>|</span><label class="collapse" for="c-42303773">[-]</label><label class="expand" for="c-42303773">[2 more]</label></div><br/><div class="children"><div class="content">Great write-up and I must say a surprising conclusion and good case for OCaml. I also love Haskell but using it for a practical project I came up against some of the pain points mentioned here.
If I could suggest some Emglish grammar fixes to this great article, the word order needs to be flipped around for the interrogative sentences.<p>Wait, why doesn&#x27;t the standard library have docs at all for this version I use?<p>Instead of:<p>&gt; Wait, why the standard library doesn&#x27;t have docs at all for this version I use?<p>And<p>How can Haskellers live like that without these usability essentials?<p>Instead of:<p>&gt; How Haskellers can live like that without these usability essentials?</div><br/><div id="42303911" class="c"><input type="checkbox" id="c-42303911" checked=""/><div class="controls bullet"><span class="by">chshersh</span><span>|</span><a href="#42303754">root</a><span>|</span><a href="#42303773">parent</a><span>|</span><a href="#42303553">next</a><span>|</span><label class="collapse" for="c-42303911">[-]</label><label class="expand" for="c-42303911">[1 more]</label></div><br/><div class="children"><div class="content">Happy to hear you enjoyed the article!<p>Thanks for the suggestions! English is not my first language, so mistakes could happen. I hope it&#x27;s not too off-putting, and people can still learn something interesting from articles.<p>I&#x27;ll incorporate your suggestions :)</div><br/></div></div></div></div></div></div><div id="42303553" class="c"><input type="checkbox" id="c-42303553" checked=""/><div class="controls bullet"><span class="by">achou</span><span>|</span><a href="#42303754">prev</a><span>|</span><a href="#42303947">next</a><span>|</span><label class="collapse" for="c-42303553">[-]</label><label class="expand" for="c-42303553">[3 more]</label></div><br/><div class="children"><div class="content">What about performance? I wrote my thesis in OCaml and my recollection was that it had an amazing native code generating compiler that not infrequently output code that was almost as fast as C if you wrote it the right way. The story I heard about Haskell was far different at the time (admittedly decades ago).</div><br/><div id="42303634" class="c"><input type="checkbox" id="c-42303634" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#42303553">parent</a><span>|</span><a href="#42303947">next</a><span>|</span><label class="collapse" for="c-42303634">[-]</label><label class="expand" for="c-42303634">[2 more]</label></div><br/><div class="children"><div class="content">As with all garbage collected languages, optimizing comes down to removing allocations, in Haskell this means strictness and choice of data structures. You <i>can</i> make C-speed programs but you may need to work for it, and you&#x27;ll also need to know the compiler&#x2F;evaluation model you&#x27;re working against.</div><br/><div id="42303666" class="c"><input type="checkbox" id="c-42303666" checked=""/><div class="controls bullet"><span class="by">achou</span><span>|</span><a href="#42303553">root</a><span>|</span><a href="#42303634">parent</a><span>|</span><a href="#42303947">next</a><span>|</span><label class="collapse" for="c-42303666">[-]</label><label class="expand" for="c-42303666">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I think what I noticed was that even idiomatic OCaml code was relatively fast, maybe 2-3x slower than C, but plenty fast enough. Whereas I was under the impression that idiomatic Haskell was far more likely to have unexpected and harder to fix performance issues (e.g. requiring more of an architectural rewrite) because of its lazy evaluation model.</div><br/></div></div></div></div></div></div><div id="42303947" class="c"><input type="checkbox" id="c-42303947" checked=""/><div class="controls bullet"><span class="by">ceving</span><span>|</span><a href="#42303553">prev</a><span>|</span><a href="#42303129">next</a><span>|</span><label class="collapse" for="c-42303947">[-]</label><label class="expand" for="c-42303947">[1 more]</label></div><br/><div class="children"><div class="content">I like this:<p>&gt; A great standard library is a cornerstone of your PL success.</div><br/></div></div><div id="42303129" class="c"><input type="checkbox" id="c-42303129" checked=""/><div class="controls bullet"><span class="by">re-lre-l</span><span>|</span><a href="#42303947">prev</a><span>|</span><a href="#42303045">next</a><span>|</span><label class="collapse" for="c-42303129">[-]</label><label class="expand" for="c-42303129">[3 more]</label></div><br/><div class="children"><div class="content">Just curious - what is the niche for this languages and what&#x27;s the motivation to choose one?</div><br/><div id="42303311" class="c"><input type="checkbox" id="c-42303311" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#42303129">parent</a><span>|</span><a href="#42303174">next</a><span>|</span><label class="collapse" for="c-42303311">[-]</label><label class="expand" for="c-42303311">[1 more]</label></div><br/><div class="children"><div class="content">They’re not meant to be niche languages. They’re meant to be general purpose languages. They’re trying to use functional programming to achieve a high degree of correctness with short, readable programs.</div><br/></div></div><div id="42303174" class="c"><input type="checkbox" id="c-42303174" checked=""/><div class="controls bullet"><span class="by">jasinjames</span><span>|</span><a href="#42303129">parent</a><span>|</span><a href="#42303311">prev</a><span>|</span><a href="#42303045">next</a><span>|</span><label class="collapse" for="c-42303174">[-]</label><label class="expand" for="c-42303174">[1 more]</label></div><br/><div class="children"><div class="content">Compilers are a good one. I know Rust&#x27;s original compiler (before being self hosted) was implemented in OCaml. Darklang&#x27;s compiler was in OCaml as well.</div><br/></div></div></div></div><div id="42303045" class="c"><input type="checkbox" id="c-42303045" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42303129">prev</a><span>|</span><a href="#42302751">next</a><span>|</span><label class="collapse" for="c-42303045">[-]</label><label class="expand" for="c-42303045">[3 more]</label></div><br/><div class="children"><div class="content">I thought the main draw of OCaml is that it has imperative features such as for-loops, instead of trying to be purely functional like Haskell.  This probably made OCaml easier to pick up for people coming from other programming languages.</div><br/><div id="42303601" class="c"><input type="checkbox" id="c-42303601" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#42303045">parent</a><span>|</span><a href="#42303741">next</a><span>|</span><label class="collapse" for="c-42303601">[-]</label><label class="expand" for="c-42303601">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. The main draw of OCaml is that it isn&#x27;t pure like Haskell. Haskell&#x27;s purity is really what makes it weird (and great).</div><br/></div></div><div id="42303741" class="c"><input type="checkbox" id="c-42303741" checked=""/><div class="controls bullet"><span class="by">emoII</span><span>|</span><a href="#42303045">parent</a><span>|</span><a href="#42303601">prev</a><span>|</span><a href="#42302751">next</a><span>|</span><label class="collapse" for="c-42303741">[-]</label><label class="expand" for="c-42303741">[1 more]</label></div><br/><div class="children"><div class="content">For-loops and mutation are not really encouraged, often loops are implemented with recursion as in normal fp. The big difference to me is that OCaml doesn&#x27;t try to be pure, so you can perform side effects as needed, instead of forcing the user to jump through hurdles when trying to print to stdout</div><br/></div></div></div></div><div id="42302751" class="c"><input type="checkbox" id="c-42302751" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42303045">prev</a><span>|</span><a href="#42303416">next</a><span>|</span><label class="collapse" for="c-42302751">[-]</label><label class="expand" for="c-42302751">[5 more]</label></div><br/><div class="children"><div class="content">Missing from this post: string_of_int, int_of_string, +, +., etc. That alone is a massive turn-off for me, I&#x27;d rather write C at that point. Any modern language necessitates some kind of polymorphism and make user-defined types feel like first-class citizens.</div><br/><div id="42303065" class="c"><input type="checkbox" id="c-42303065" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#42302751">parent</a><span>|</span><a href="#42303377">next</a><span>|</span><label class="collapse" for="c-42303065">[-]</label><label class="expand" for="c-42303065">[1 more]</label></div><br/><div class="children"><div class="content">&gt; string_of_int, int_of_string<p>That didn&#x27;t bother me so much because i speak spanish and can read french. OCaml is of french origin. `string_of_int` is a bad english translation—should have been `string_from_int`.<p>I like F# where I can use the `int` or `string` functions:<p><pre><code>    let myString = &quot;2024&quot;
    let myInt = int myString
    let myStringAgain = string myInt</code></pre></div><br/></div></div><div id="42303377" class="c"><input type="checkbox" id="c-42303377" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#42302751">parent</a><span>|</span><a href="#42303065">prev</a><span>|</span><a href="#42302901">next</a><span>|</span><label class="collapse" for="c-42303377">[-]</label><label class="expand" for="c-42303377">[1 more]</label></div><br/><div class="children"><div class="content">The Ocaml library added a Int module with a function <i>to_string</i> (so <i>Int.to_string</i>) and a generic printer ages ago. There is also a (+) operator for Float in the float module which you can open in any scope if you so wish.<p>Ocaml obviously supports  polymorphism and an extremely expressive type system. The fact that operators are not polymorphic is purely a choice (and a good one).</div><br/></div></div><div id="42302901" class="c"><input type="checkbox" id="c-42302901" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42302751">parent</a><span>|</span><a href="#42303377">prev</a><span>|</span><a href="#42303416">next</a><span>|</span><label class="collapse" for="c-42302901">[-]</label><label class="expand" for="c-42302901">[2 more]</label></div><br/><div class="children"><div class="content">Interestingly enough, OCaml has a great polymorphism story in its OO system. Because it is structurally typed with nearly automatic inference, you can in fact write completely generic code like `x#y(z)`, which magically &quot;just works&quot; for any x that has a method y that accepts z - all inferred and statically type-checked.</div><br/><div id="42302929" class="c"><input type="checkbox" id="c-42302929" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42302751">root</a><span>|</span><a href="#42302901">parent</a><span>|</span><a href="#42303416">next</a><span>|</span><label class="collapse" for="c-42302929">[-]</label><label class="expand" for="c-42302929">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Why doesn&#x27;t the standard lib use that for the examples I listed?</div><br/></div></div></div></div></div></div><div id="42303416" class="c"><input type="checkbox" id="c-42303416" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42302751">prev</a><span>|</span><a href="#42302733">next</a><span>|</span><label class="collapse" for="c-42303416">[-]</label><label class="expand" for="c-42303416">[7 more]</label></div><br/><div class="children"><div class="content">The Haskell examples at the beginning are a bit weirdly chosen. You wouldn&#x27;t want to write code like that except in scripts etc. because it would crash the program if you encounter bad input.<p>The first example could be more idiomatically written as:<p><pre><code>  strSum :: String -&gt; Maybe Int
  strSum = fmap sum . sequence . fmap readMaybe . words
</code></pre>
(You&#x27;d also probably want to avoid String and use Text instead.)<p>For more complex parsing scenarios, the various parser combinator libraries can take a while to get used to (and I wish the community would standardise on one or two of them), but they&#x27;re extremely powerful.</div><br/><div id="42303706" class="c"><input type="checkbox" id="c-42303706" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42303416">parent</a><span>|</span><a href="#42303598">next</a><span>|</span><label class="collapse" for="c-42303706">[-]</label><label class="expand" for="c-42303706">[4 more]</label></div><br/><div class="children"><div class="content">Hm... for anything real, you would need to provide good error reports, i.e. why did it fail to parse. Code like this looks pretty, but once you add in good error reports, I feel like it tends to look almost exactly the same as in an imperative language?</div><br/><div id="42304207" class="c"><input type="checkbox" id="c-42304207" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42303416">root</a><span>|</span><a href="#42303706">parent</a><span>|</span><a href="#42304113">next</a><span>|</span><label class="collapse" for="c-42304207">[-]</label><label class="expand" for="c-42304207">[1 more]</label></div><br/><div class="children"><div class="content">For a real use case, consider using a parser library. If you ignore the boilerplate import stuff, it&#x27;s IMHO rather short and elegant - and not very imperative:<p><pre><code>  {-# LANGUAGE OverloadedStrings #-}

  import Data.Text (Text)
  import Data.Void (Void)
  import qualified Data.Text as T
  import Text.Megaparsec
  import Text.Megaparsec.Char
  import qualified Text.Megaparsec.Char.Lexer as L

  type Parser = Parsec Void Text

  numParser :: Parser [Integer]
  numParser = L.decimal `sepBy` space1

  -- just for demonstration purposes - this will print an ugly debug string, it can be customised
  main = putStrLn $ show $ parse numParser &quot;some-source-file.txt&quot; &quot;10 20  30 x&quot;

  -- this would print &quot;Right [10, 20, 30]&quot;
  -- main = putStrLn $ show $ parse numParser &quot;some-source-file.txt&quot; &quot;10 20  30&quot;</code></pre></div><br/></div></div><div id="42304113" class="c"><input type="checkbox" id="c-42304113" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42303416">root</a><span>|</span><a href="#42303706">parent</a><span>|</span><a href="#42304207">prev</a><span>|</span><a href="#42303598">next</a><span>|</span><label class="collapse" for="c-42304113">[-]</label><label class="expand" for="c-42304113">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  strSum :: String -&gt; Either String Int
  strSum = fmap sum . mapM readEither . words</code></pre></div><br/><div id="42304178" class="c"><input type="checkbox" id="c-42304178" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42303416">root</a><span>|</span><a href="#42304113">parent</a><span>|</span><a href="#42303598">next</a><span>|</span><label class="collapse" for="c-42304178">[-]</label><label class="expand" for="c-42304178">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t exactly give a good error message, though:<p><pre><code>  &gt; strSum &quot;10 20 x&quot;
  Left &quot;Prelude.read: no parse&quot;
</code></pre>
But yeah, I didn&#x27;t remember &quot;mapM&quot;. mapM f = sequence . fmap f, which is what I used.</div><br/></div></div></div></div></div></div><div id="42303598" class="c"><input type="checkbox" id="c-42303598" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#42303416">parent</a><span>|</span><a href="#42303706">prev</a><span>|</span><a href="#42302733">next</a><span>|</span><label class="collapse" for="c-42303598">[-]</label><label class="expand" for="c-42303598">[2 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s take that further: you wouldn&#x27;t want to use your code above either, because it would be impossible to tell <i>why</i> the parser failed. Which is going to be really frustrating once it fails. And if it doesn&#x27;t fail the first version is fine.</div><br/><div id="42303916" class="c"><input type="checkbox" id="c-42303916" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42303416">root</a><span>|</span><a href="#42303598">parent</a><span>|</span><a href="#42302733">next</a><span>|</span><label class="collapse" for="c-42303916">[-]</label><label class="expand" for="c-42303916">[1 more]</label></div><br/><div class="children"><div class="content">Sure, you can improve this by e.g.<p><pre><code>  import Data.Either.Combinators -- from the either package

  strSum :: String -&gt; Either String Int
  strSum = fmap sum . sequence . fmap tryReadInt . words
    where
      tryReadInt w = maybeToRight (&quot;not an integer &quot; ++ w) (readMaybe w)
</code></pre>
This keeps the bulk of the method the same. Being able to go e.g. from Maybe to Either with only few changes (as long as your code is sufficiently general) is one of the nice things you get from all the Haskell abstraction. You can&#x27;t really do that if you start with exceptions (unless you&#x27;re in IO).</div><br/></div></div></div></div></div></div><div id="42302733" class="c"><input type="checkbox" id="c-42302733" checked=""/><div class="controls bullet"><span class="by">sgt_bilko</span><span>|</span><a href="#42303416">prev</a><span>|</span><a href="#42302781">next</a><span>|</span><label class="collapse" for="c-42302733">[-]</label><label class="expand" for="c-42302733">[10 more]</label></div><br/><div class="children"><div class="content">Anyone built simple (but not trivial) projects with Haskell or OCaml with source that I can look at?</div><br/><div id="42304135" class="c"><input type="checkbox" id="c-42304135" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42303912">next</a><span>|</span><label class="collapse" for="c-42304135">[-]</label><label class="expand" for="c-42304135">[1 more]</label></div><br/><div class="children"><div class="content">An unfinished command-line client for Hacker News:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;LucianU&#x2F;hn-reader">https:&#x2F;&#x2F;github.com&#x2F;LucianU&#x2F;hn-reader</a></div><br/></div></div><div id="42303912" class="c"><input type="checkbox" id="c-42303912" checked=""/><div class="controls bullet"><span class="by">mega_dean</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42304135">prev</a><span>|</span><a href="#42303424">next</a><span>|</span><label class="collapse" for="c-42303912">[-]</label><label class="expand" for="c-42303912">[1 more]</label></div><br/><div class="children"><div class="content">I released a game using OCaml bindings to the Raylib library. I had never written OCaml before and I didn&#x27;t spend very much time refactoring, so the code is pretty messy and maybe isn&#x27;t the best example of the language. But some of it turned out pretty nice - the first ~90 lines of this file detect collisions between two shapes using the Separating Axis theorem: <a href="https:&#x2F;&#x2F;github.com&#x2F;mega-dean&#x2F;hallowdale&#x2F;blob&#x2F;main&#x2F;src&#x2F;collision.ml">https:&#x2F;&#x2F;github.com&#x2F;mega-dean&#x2F;hallowdale&#x2F;blob&#x2F;main&#x2F;src&#x2F;collis...</a></div><br/></div></div><div id="42303424" class="c"><input type="checkbox" id="c-42303424" checked=""/><div class="controls bullet"><span class="by">jlarocco</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42303912">prev</a><span>|</span><a href="#42303559">next</a><span>|</span><label class="collapse" for="c-42303424">[-]</label><label class="expand" for="c-42303424">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure a lot of people here have much better examples, but I wrote some basic regular expression and finite automata algorithms in Haskell a long time ago:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jl2&#x2F;Compiler-Algorithm-Code&#x2F;tree&#x2F;master&#x2F;haskell">https:&#x2F;&#x2F;github.com&#x2F;jl2&#x2F;Compiler-Algorithm-Code&#x2F;tree&#x2F;master&#x2F;h...</a><p>I tried it out and after renaming fold -&gt; foldr, it still builds and seems to work.  The main function takes a regex as a command line argument and creates a finite automata graph using GraphViz&#x27;s dot.<p>In the Compiler-Algorithm-Code&#x2F;haskell directory:<p><pre><code>    make
    .&#x2F;test &quot;(foo)+(bar)*(foo+)&quot; | dot -Tpdf -ofoobarfoo.pdf &amp;&amp; xdg-open foobarfoo.pdf</code></pre></div><br/></div></div><div id="42303559" class="c"><input type="checkbox" id="c-42303559" checked=""/><div class="controls bullet"><span class="by">broken_broken_</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42303424">prev</a><span>|</span><a href="#42303747">next</a><span>|</span><label class="collapse" for="c-42303559">[-]</label><label class="expand" for="c-42303559">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a Lox compiler and interpreter in OCaml a few years ago: <a href="https:&#x2F;&#x2F;github.com&#x2F;gaultier&#x2F;lox-ocaml">https:&#x2F;&#x2F;github.com&#x2F;gaultier&#x2F;lox-ocaml</a><p>No idea how it holds up, it was my first try at a compiler, but it’s quite small. I was following the Crafting Interpreters book.</div><br/></div></div><div id="42303747" class="c"><input type="checkbox" id="c-42303747" checked=""/><div class="controls bullet"><span class="by">chshersh</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42303559">prev</a><span>|</span><a href="#42302866">next</a><span>|</span><label class="collapse" for="c-42303747">[-]</label><label class="expand" for="c-42303747">[1 more]</label></div><br/><div class="children"><div class="content">You can check my (not finished) example of GitHub TUI built in OCaml:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;chshersh&#x2F;github-tui">https:&#x2F;&#x2F;github.com&#x2F;chshersh&#x2F;github-tui</a></div><br/></div></div><div id="42302866" class="c"><input type="checkbox" id="c-42302866" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42303747">prev</a><span>|</span><a href="#42303105">next</a><span>|</span><label class="collapse" for="c-42302866">[-]</label><label class="expand" for="c-42302866">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;matthiasgoergens&#x2F;Div7">https:&#x2F;&#x2F;github.com&#x2F;matthiasgoergens&#x2F;Div7</a> is a simple one that you might like.</div><br/><div id="42303128" class="c"><input type="checkbox" id="c-42303128" checked=""/><div class="controls bullet"><span class="by">stitched2gethr</span><span>|</span><a href="#42302733">root</a><span>|</span><a href="#42302866">parent</a><span>|</span><a href="#42303105">next</a><span>|</span><label class="collapse" for="c-42303128">[-]</label><label class="expand" for="c-42303128">[2 more]</label></div><br/><div class="children"><div class="content">This seems more on the trivial side to me.</div><br/><div id="42303368" class="c"><input type="checkbox" id="c-42303368" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302733">root</a><span>|</span><a href="#42303128">parent</a><span>|</span><a href="#42303105">next</a><span>|</span><label class="collapse" for="c-42303368">[-]</label><label class="expand" for="c-42303368">[1 more]</label></div><br/><div class="children"><div class="content">Yes, depends on where you draw the line.<p>XMonad is a bit bigger: <a href="https:&#x2F;&#x2F;github.com&#x2F;xmonad&#x2F;xmonad">https:&#x2F;&#x2F;github.com&#x2F;xmonad&#x2F;xmonad</a></div><br/></div></div></div></div></div></div><div id="42303105" class="c"><input type="checkbox" id="c-42303105" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#42302733">parent</a><span>|</span><a href="#42302866">prev</a><span>|</span><a href="#42302781">next</a><span>|</span><label class="collapse" for="c-42303105">[-]</label><label class="expand" for="c-42303105">[1 more]</label></div><br/><div class="children"><div class="content">I wrote this like ~10 years ago as a &quot;Hello World++&quot; type demo (basic key&#x2F;value server) in Haskell. It&#x27;s about 200 LoC, with a Haskell and Python client. <a href="http:&#x2F;&#x2F;github.com&#x2F;wyager&#x2F;neks">http:&#x2F;&#x2F;github.com&#x2F;wyager&#x2F;neks</a></div><br/></div></div></div></div><div id="42302781" class="c"><input type="checkbox" id="c-42302781" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#42302733">prev</a><span>|</span><a href="#42302742">next</a><span>|</span><label class="collapse" for="c-42302781">[-]</label><label class="expand" for="c-42302781">[1 more]</label></div><br/><div class="children"><div class="content">(2023) in case it looks familiar</div><br/></div></div><div id="42302742" class="c"><input type="checkbox" id="c-42302742" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42302781">prev</a><span>|</span><a href="#42302767">next</a><span>|</span><label class="collapse" for="c-42302742">[-]</label><label class="expand" for="c-42302742">[1 more]</label></div><br/><div class="children"><div class="content">Compiler messages:<p>The big difference here is that the OCaml compiler has a lot less work to do. It&#x27;s not that the Haskell error messages are inadequate (they are actually pretty good), but that the amount of compiler features and type gymnastics make the errors deeper and more complex. For example, if you get the parens wrong in a &gt;&gt; or &gt;&gt;=, you&#x27;ll get some rather cryptic error that only hits home once you&#x27;ve seen it a few times, as opposed to &quot;did you mean to put parens over there?&quot;</div><br/></div></div><div id="42302767" class="c"><input type="checkbox" id="c-42302767" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42302742">prev</a><span>|</span><a href="#42302672">next</a><span>|</span><label class="collapse" for="c-42302767">[-]</label><label class="expand" for="c-42302767">[10 more]</label></div><br/><div class="children"><div class="content">Massive amounts of headache could have been avoided by using “OCaml but with ecosystem and great tooling support” known as F# :)</div><br/><div id="42303428" class="c"><input type="checkbox" id="c-42303428" checked=""/><div class="controls bullet"><span class="by">sinkasapa</span><span>|</span><a href="#42302767">parent</a><span>|</span><a href="#42303183">next</a><span>|</span><label class="collapse" for="c-42303428">[-]</label><label class="expand" for="c-42303428">[1 more]</label></div><br/><div class="children"><div class="content">I got turned off of F# because it seemed like knowing C# libraries and tooling was assumed if one wanted to do anything non-trivial, kind of like some of the functional JVM languages always assume some amount of Java knowledge and use of Java tooling. F# seemed nice, but it didn&#x27;t seem like a real stand-alone language. Unlike Elm or Purescript, where one should also know JavaScript and its tooling, I don&#x27;t find learning all the C# and Java stuff independently compelling enough to use F#, Scala, Frege, etc.</div><br/></div></div><div id="42303183" class="c"><input type="checkbox" id="c-42303183" checked=""/><div class="controls bullet"><span class="by">phplovesong</span><span>|</span><a href="#42302767">parent</a><span>|</span><a href="#42303428">prev</a><span>|</span><a href="#42302983">next</a><span>|</span><label class="collapse" for="c-42303183">[-]</label><label class="expand" for="c-42303183">[2 more]</label></div><br/><div class="children"><div class="content">F# compiler is so slow.. a big turnoff coming from ocaml, where compile times are fast, even faster than Go or Haxe.</div><br/><div id="42303282" class="c"><input type="checkbox" id="c-42303282" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42302767">root</a><span>|</span><a href="#42303183">parent</a><span>|</span><a href="#42302983">next</a><span>|</span><label class="collapse" for="c-42303282">[-]</label><label class="expand" for="c-42303282">[1 more]</label></div><br/><div class="children"><div class="content">Relatively yes, but F# also happens to be faster than other FP languages and has access to a vast ecosystem unlike Haxe. I doubt the public looking at FP languages would appreciate Go :)<p>F# includes an optimizer that performs e.g. lambda inlining. Then, .NET compiles the assemblies themselves to a final application, be it native executable or otherwise, so I feel like relative compiler slowness is not a dealbreaker. It is also relatively quick at starting for executing F# script files with `dotnet fsi` (I&#x27;m happy that F# is included in standard .NET SDK, much different to e.g. Clojure or Scala), it&#x27;s slower to start than Python or Elixir shell but I can live with that.<p>This was also a good opportunity to write down a small workflow to use F# interactive to quickly build small native console applications thanks to FSharpPacker:<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;neon-sunset&#x2F;028937d82f2adaa6c1b93899e358e1c0" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;neon-sunset&#x2F;028937d82f2adaa6c1b93899...</a><p>In the example, the sample program calculates SHA256 hashes for all files matching the pattern at a specific path. On my M1 Pro MBP it does so at up to 4GB&#x2F;s while consuming 5-10 MiB of RAM.</div><br/></div></div></div></div><div id="42302983" class="c"><input type="checkbox" id="c-42302983" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#42302767">parent</a><span>|</span><a href="#42303183">prev</a><span>|</span><a href="#42303098">next</a><span>|</span><label class="collapse" for="c-42302983">[-]</label><label class="expand" for="c-42302983">[5 more]</label></div><br/><div class="children"><div class="content">I tried that about 10 years ago and spent 2 hours trying to open some files under Linux.<p>Then I gave up.  Have things improved?</div><br/><div id="42303086" class="c"><input type="checkbox" id="c-42303086" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#42302767">root</a><span>|</span><a href="#42302983">parent</a><span>|</span><a href="#42303031">next</a><span>|</span><label class="collapse" for="c-42303086">[-]</label><label class="expand" for="c-42303086">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t use it 10 years ago but I&#x27;ve been using it for the last 4 years on mac and linux exclusively.<p>Microsoft seems to be prioritizing &quot;cloud&quot; on all their developer products (rather than just windows). I don&#x27;t feel disadvantaged by NOT using dotnet on windows.</div><br/></div></div><div id="42303031" class="c"><input type="checkbox" id="c-42303031" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42302767">root</a><span>|</span><a href="#42302983">parent</a><span>|</span><a href="#42303086">prev</a><span>|</span><a href="#42303092">next</a><span>|</span><label class="collapse" for="c-42303031">[-]</label><label class="expand" for="c-42303031">[1 more]</label></div><br/><div class="children"><div class="content">The below should work as is:<p><pre><code>  sudo apt install dotnet9 # or dotnet-sdk-9.0 if the repo doesn&#x27;t have dotnet9 metapackage
  dotnet new console --language F#
</code></pre>
There is also a package for Avalonia that lets you write GUI applications in F#: <a href="https:&#x2F;&#x2F;funcui.avaloniaui.net" rel="nofollow">https:&#x2F;&#x2F;funcui.avaloniaui.net</a></div><br/></div></div><div id="42303092" class="c"><input type="checkbox" id="c-42303092" checked=""/><div class="controls bullet"><span class="by">spooneybarger</span><span>|</span><a href="#42302767">root</a><span>|</span><a href="#42302983">parent</a><span>|</span><a href="#42303031">prev</a><span>|</span><a href="#42303000">next</a><span>|</span><label class="collapse" for="c-42303092">[-]</label><label class="expand" for="c-42303092">[1 more]</label></div><br/><div class="children"><div class="content">Very much so.</div><br/></div></div><div id="42303000" class="c"><input type="checkbox" id="c-42303000" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#42302767">root</a><span>|</span><a href="#42302983">parent</a><span>|</span><a href="#42303092">prev</a><span>|</span><a href="#42303098">next</a><span>|</span><label class="collapse" for="c-42303000">[-]</label><label class="expand" for="c-42303000">[1 more]</label></div><br/><div class="children"><div class="content">Vastly. You were probably using Mono. .NET is now fully cross-platform and very good at being so.</div><br/></div></div></div></div><div id="42303098" class="c"><input type="checkbox" id="c-42303098" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#42302767">parent</a><span>|</span><a href="#42302983">prev</a><span>|</span><a href="#42302672">next</a><span>|</span><label class="collapse" for="c-42303098">[-]</label><label class="expand" for="c-42303098">[1 more]</label></div><br/><div class="children"><div class="content">F# is good because MSR used to hire a bunch of the top GHC devs and pay them to work on F# part-time. They put all their actual passion into Haskell.</div><br/></div></div></div></div><div id="42302672" class="c"><input type="checkbox" id="c-42302672" checked=""/><div class="controls bullet"><span class="by">agnishom</span><span>|</span><a href="#42302767">prev</a><span>|</span><a href="#42302827">next</a><span>|</span><label class="collapse" for="c-42302672">[-]</label><label class="expand" for="c-42302672">[22 more]</label></div><br/><div class="children"><div class="content">&gt; I’m interested in building stuff, not sitting near my pond on a warm summer day, thinking if TypeFamilies + DataKinds would be better than GADTs for making illegal states unrepresentable.<p>I feel differently. I would rather sit by the pond on a summer day rather than build stuff</div><br/><div id="42302713" class="c"><input type="checkbox" id="c-42302713" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42302672">parent</a><span>|</span><a href="#42302938">next</a><span>|</span><label class="collapse" for="c-42302713">[-]</label><label class="expand" for="c-42302713">[20 more]</label></div><br/><div class="children"><div class="content">Engineer vs mathematician. Haskell is the schizophrenic product.<p>&gt; If I come to an existing OCaml project, the worst thing previous developers could do to it is have poor variable names, minimal documentation, and 200+ LOC functions. That’s fine, nothing extraordinary, I can handle that.
&gt;
&gt; If I come to an existing Haskell project, the worst thing previous developer&gt;s could do… Well, my previous 8 years of Haskell experience can’t prepare me for that<p>This is kind of like Go vs C++, or &lt;anything&gt; vs Common Lisp. The former is a rather unsophisticated and limited language, not particularly educational or enlightening but good when you need N developers churning code and onboard M new ones while you&#x27;re at it. The latter is like tripping on LSD; it&#x27;s one hell of a trip and education, but unless you adopt specific guidelines, it&#x27;s going to be harder to get your friends on board. See, for example: <a href="https:&#x2F;&#x2F;www.parsonsmatt.org&#x2F;2019&#x2F;12&#x2F;26&#x2F;write_junior_code.html" rel="nofollow">https:&#x2F;&#x2F;www.parsonsmatt.org&#x2F;2019&#x2F;12&#x2F;26&#x2F;write_junior_code.htm...</a></div><br/><div id="42302997" class="c"><input type="checkbox" id="c-42302997" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302713">parent</a><span>|</span><a href="#42302947">next</a><span>|</span><label class="collapse" for="c-42302997">[-]</label><label class="expand" for="c-42302997">[3 more]</label></div><br/><div class="children"><div class="content">Go is good for onboarding people onto a project, but not much else.<p>There&#x27;s a reason Google is migrating Go services to Rust:<p><a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;03&#x2F;31&#x2F;rust_google_c&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;03&#x2F;31&#x2F;rust_google_c&#x2F;</a><p>&gt; <i>&quot;When we&#x27;ve rewritten systems from Go into Rust, we&#x27;ve found that it takes about the same size team about the same amount of time to build it,&quot; said Bergstrom. &quot;That is, there&#x27;s no loss in productivity when moving from Go to Rust. And the interesting thing is we do see some benefits from it.</i><p>&gt; <i>&quot;So we see reduced memory usage in the services that we&#x27;ve moved from Go ... and we see a decreased defect rate over time in those services that have been rewritten in Rust – so increasing correctness.&quot;</i><p>That matches my experience:  Go serivces tend to be tire fires, and churn developers on and off teams pretty fast.</div><br/><div id="42303201" class="c"><input type="checkbox" id="c-42303201" checked=""/><div class="controls bullet"><span class="by">krmboya</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302997">parent</a><span>|</span><a href="#42302947">next</a><span>|</span><label class="collapse" for="c-42303201">[-]</label><label class="expand" for="c-42303201">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Go&#x27;s concurrency model an advantage over other approaches?</div><br/><div id="42303290" class="c"><input type="checkbox" id="c-42303290" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42303201">parent</a><span>|</span><a href="#42302947">next</a><span>|</span><label class="collapse" for="c-42303290">[-]</label><label class="expand" for="c-42303290">[1 more]</label></div><br/><div class="children"><div class="content">When it exactly fits your problem, yes. But it&#x27;s not like you can&#x27;t express that model in Rust (in a more cumbersome way) when you need to.</div><br/></div></div></div></div></div></div><div id="42302947" class="c"><input type="checkbox" id="c-42302947" checked=""/><div class="controls bullet"><span class="by">enugu</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302713">parent</a><span>|</span><a href="#42302997">prev</a><span>|</span><a href="#42302756">next</a><span>|</span><label class="collapse" for="c-42302947">[-]</label><label class="expand" for="c-42302947">[4 more]</label></div><br/><div class="children"><div class="content">OCaml is not an unsophisticated language. It inherits the features of ML and has first class modules, which is not present by default in Haskell (present in backpack). Not having first class modules leads to a lot of issues.<p>Also, there is a better story for compilation to the web.</div><br/><div id="42303104" class="c"><input type="checkbox" id="c-42303104" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302947">parent</a><span>|</span><a href="#42302756">next</a><span>|</span><label class="collapse" for="c-42303104">[-]</label><label class="expand" for="c-42303104">[3 more]</label></div><br/><div class="children"><div class="content">OCaml&#x27;s type system is quite janky and simplistic compared to Haskell&#x27;s. The first class module system is fairly nice, although it leads to an annoying problem where now you kind of have two &quot;levels&quot; to the language (module level and normal level). This is arguably analogous to Haskell having a &quot;term level language&quot; and a &quot;type level language&quot;, where the type system is more prolog-y than the term language. Also, Haskell&#x27;s type system is powerful enough to do most of the things you&#x27;d want the OCaml module system for, and more. I do occasionally miss the OCaml module system, but not most of the time.</div><br/><div id="42303401" class="c"><input type="checkbox" id="c-42303401" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42303104">parent</a><span>|</span><a href="#42302756">next</a><span>|</span><label class="collapse" for="c-42303401">[-]</label><label class="expand" for="c-42303401">[2 more]</label></div><br/><div class="children"><div class="content">Conversely, the Ocaml module system is powerful enough to do all the things you had want to do with Haskell except the Ocaml module system is nice to use.<p>Anyway, the issue has nothing to do with relative powerfulness. The issue is that the Haskell community encourages practices which lead to unreadable code: lot of new operators, point-free, fancy abstraction. Meanwhile, the Ocaml community was always very different with a general dislike of overly fancy things when they were not unavoidable.</div><br/><div id="42303714" class="c"><input type="checkbox" id="c-42303714" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42303401">parent</a><span>|</span><a href="#42302756">next</a><span>|</span><label class="collapse" for="c-42303714">[-]</label><label class="expand" for="c-42303714">[1 more]</label></div><br/><div class="children"><div class="content">If by &quot;encourages&quot; you mean &quot;has features&quot;, then yes. The typical haskell shop doesn&#x27;t really encourage complex feature use, it&#x27;s the people learning&#x2F;online who don&#x27;t actually need to work within their solutions, do. That&#x27;s what seems to draw (some) people to haskell.</div><br/></div></div></div></div></div></div></div></div><div id="42302756" class="c"><input type="checkbox" id="c-42302756" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302713">parent</a><span>|</span><a href="#42302947">prev</a><span>|</span><a href="#42302938">next</a><span>|</span><label class="collapse" for="c-42302756">[-]</label><label class="expand" for="c-42302756">[12 more]</label></div><br/><div class="children"><div class="content">Learning a “pure” language is a <i>lot</i> like tripping on LSD.<p>The people who do it can’t stop talking about how great it was, but also can’t really explain why it was so great, and when they try it just sounds ridiculous, maybe even to them.  And then they finish by saying that you should drop acid too and then you’ll understand.</div><br/><div id="42304181" class="c"><input type="checkbox" id="c-42304181" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302756">parent</a><span>|</span><a href="#42302810">next</a><span>|</span><label class="collapse" for="c-42304181">[-]</label><label class="expand" for="c-42304181">[1 more]</label></div><br/><div class="children"><div class="content">&gt; also can’t really explain why it was so great<p>I like it when<p><pre><code>  assertTrue (f x)  -- passes in test
</code></pre>
means that<p><pre><code>  assertTrue (f x)  -- passes in prod</code></pre></div><br/></div></div><div id="42302810" class="c"><input type="checkbox" id="c-42302810" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302756">parent</a><span>|</span><a href="#42304181">prev</a><span>|</span><a href="#42302847">next</a><span>|</span><label class="collapse" for="c-42302810">[-]</label><label class="expand" for="c-42302810">[1 more]</label></div><br/><div class="children"><div class="content">The reality is people want what you produce when you&#x27;re sober, not having fantasy hallucinations.</div><br/></div></div><div id="42302847" class="c"><input type="checkbox" id="c-42302847" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302756">parent</a><span>|</span><a href="#42302810">prev</a><span>|</span><a href="#42302774">next</a><span>|</span><label class="collapse" for="c-42302847">[-]</label><label class="expand" for="c-42302847">[7 more]</label></div><br/><div class="children"><div class="content">Haskell isn&#x27;t all that pure.</div><br/><div id="42302897" class="c"><input type="checkbox" id="c-42302897" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302847">parent</a><span>|</span><a href="#42302774">next</a><span>|</span><label class="collapse" for="c-42302897">[-]</label><label class="expand" for="c-42302897">[6 more]</label></div><br/><div class="children"><div class="content">what do you mean by that? all functions in haskell are pure unless you explicitly use unsafePreformIO or similar (which is rare to ever have to do)</div><br/><div id="42303630" class="c"><input type="checkbox" id="c-42303630" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302897">parent</a><span>|</span><a href="#42303238">next</a><span>|</span><label class="collapse" for="c-42303630">[-]</label><label class="expand" for="c-42303630">[3 more]</label></div><br/><div class="children"><div class="content">They can still have side-effects like non-termination.<p>But I didn&#x27;t mean purity in that formal sense.  I meant that Haskell is plenty pragmatic in its design.</div><br/><div id="42304264" class="c"><input type="checkbox" id="c-42304264" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42303630">parent</a><span>|</span><a href="#42303728">next</a><span>|</span><label class="collapse" for="c-42304264">[-]</label><label class="expand" for="c-42304264">[1 more]</label></div><br/><div class="children"><div class="content">Lambda calculus is as pure as can be, and also has terms that don&#x27;t normalize. That is not considered a side effect.</div><br/></div></div><div id="42303728" class="c"><input type="checkbox" id="c-42303728" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42303630">parent</a><span>|</span><a href="#42304264">prev</a><span>|</span><a href="#42303238">next</a><span>|</span><label class="collapse" for="c-42303728">[-]</label><label class="expand" for="c-42303728">[1 more]</label></div><br/><div class="children"><div class="content">To me, &quot;pure&quot; means referential transparency: same input, same output. So an `Int -&gt; Int` function will return same result on same argument. So, similar to `Int -&gt; IO Int`, the function (action) will return an Int after interacting with outside world, `IO` tracking the fact that this is the case.</div><br/></div></div></div></div><div id="42303238" class="c"><input type="checkbox" id="c-42303238" checked=""/><div class="controls bullet"><span class="by">agnishom</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302897">parent</a><span>|</span><a href="#42303630">prev</a><span>|</span><a href="#42302774">next</a><span>|</span><label class="collapse" for="c-42303238">[-]</label><label class="expand" for="c-42303238">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have great support for Dependent Types</div><br/><div id="42303314" class="c"><input type="checkbox" id="c-42303314" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42303238">parent</a><span>|</span><a href="#42302774">next</a><span>|</span><label class="collapse" for="c-42303314">[-]</label><label class="expand" for="c-42303314">[1 more]</label></div><br/><div class="children"><div class="content">what does that have to do with purity?</div><br/></div></div></div></div></div></div></div></div><div id="42302774" class="c"><input type="checkbox" id="c-42302774" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302756">parent</a><span>|</span><a href="#42302847">prev</a><span>|</span><a href="#42302938">next</a><span>|</span><label class="collapse" for="c-42302774">[-]</label><label class="expand" for="c-42302774">[2 more]</label></div><br/><div class="children"><div class="content">&quot;You mean you&#x27;re going to make a copy of that every time?&quot;</div><br/><div id="42304165" class="c"><input type="checkbox" id="c-42304165" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42302672">root</a><span>|</span><a href="#42302774">parent</a><span>|</span><a href="#42302938">next</a><span>|</span><label class="collapse" for="c-42304165">[-]</label><label class="expand" for="c-42304165">[1 more]</label></div><br/><div class="children"><div class="content">Haha, can&#x27;t tell if you&#x27;re joking or not.<p>For anyone else reading - you don&#x27;t need to make a copy if you know your data isn&#x27;t going to change under your feet.<p><a href="https:&#x2F;&#x2F;dev.to&#x2F;kylec32&#x2F;effective-java-make-defensive-copies-when-necessary-4bd6" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;kylec32&#x2F;effective-java-make-defensive-copies-...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>