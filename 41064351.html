<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721984466086" as="style"/><link rel="stylesheet" href="styles.css?v=1721984466086"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/nodejs/node/pull/53725">Node.js adds experimental support for TypeScript</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>magnio</span> | <span>471 comments</span></div><br/><div><div id="41065376" class="c"><input type="checkbox" id="c-41065376" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41064729">next</a><span>|</span><label class="collapse" for="c-41065376">[-]</label><label class="expand" for="c-41065376">[51 more]</label></div><br/><div class="children"><div class="content">One thing to note is that it is impossible to strip types from TypeScript without a grammar of TypeScript. Stripping types is not a token-level operation, and the TypeScript grammar is changing all the time.<p>Consider for example: `foo &lt; bar &amp; baz &gt; ( x )`. In TypeScript 1.5 this parsed as (foo&lt;bar) &amp; (baz &gt; (x)) because bar&amp;baz wasn’t a valid type expression yet. When the type intersection operator was added, the parse changed to foo&lt;(bar &amp; baz)&gt;(x) which desugared to foo(x). I realise I’m going back in time here but it’s a nice simple example.<p>If you want to continue to use new TypeScript features you are going to need to keep compiling to JS, or else keep your node version up to date. For people who like to stick on node LTS releases this may be an unacceptable compromise.</div><br/><div id="41066967" class="c"><input type="checkbox" id="c-41066967" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41069567">next</a><span>|</span><label class="collapse" for="c-41066967">[-]</label><label class="expand" for="c-41066967">[4 more]</label></div><br/><div class="children"><div class="content">It looks like the team has already considered this in one regard<p>&gt; <i>There is already a precedent for something that Node.js support, that can be upgraded seperately, its NPM.
Node bundles a version of npm that can upgraded separately, we could do the same with our TypeScript transpiler.</i><p>&gt; <i>We could create a package that we bundle but that can also be downloaded from NPM, keep a stable version in core, but if TypeScript releases new features that we don&#x27;t support or breaking changes, or users want to use the new shiny experimental feature, they can upgrade it separately.
This ensures that users are not locked, but also provides support for a TypeScript version for the whole 3 years of the lifetime of Node.js release.</i><p><a href="https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;loaders&#x2F;issues&#x2F;217">https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;loaders&#x2F;issues&#x2F;217</a></div><br/><div id="41070524" class="c"><input type="checkbox" id="c-41070524" checked=""/><div class="controls bullet"><span class="by">SomeCallMeTim</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066967">parent</a><span>|</span><a href="#41069567">next</a><span>|</span><label class="collapse" for="c-41070524">[-]</label><label class="expand" for="c-41070524">[3 more]</label></div><br/><div class="children"><div class="content">As long as Node understands to use the project-specific version of TypeScript (i.e., the one in node_modules or the PNP equivalent), that should be fine.<p>But it would be a step backward to need to globally upgrade TypeScript (as you do with npm), since some older projects will <i>not</i> be compatible with newer versions of TypeScript.<p>Ask me how I know. ;)</div><br/><div id="41074773" class="c"><input type="checkbox" id="c-41074773" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41070524">parent</a><span>|</span><a href="#41071268">next</a><span>|</span><label class="collapse" for="c-41074773">[-]</label><label class="expand" for="c-41074773">[1 more]</label></div><br/><div class="children"><div class="content">I think Node’s strategy here is to not let perfect be the enemy of useful for some people.</div><br/></div></div><div id="41071268" class="c"><input type="checkbox" id="c-41071268" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41070524">parent</a><span>|</span><a href="#41074773">prev</a><span>|</span><a href="#41069567">next</a><span>|</span><label class="collapse" for="c-41071268">[-]</label><label class="expand" for="c-41071268">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As long as Node understands to use the project-specific version of TypeScript<p>It won&#x27;t, but in such a scenario, typescript would only be a type checker, wich is a entirely different endeavor than running typescript.</div><br/></div></div></div></div></div></div><div id="41069567" class="c"><input type="checkbox" id="c-41069567" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41066967">prev</a><span>|</span><a href="#41065710">next</a><span>|</span><label class="collapse" for="c-41069567">[-]</label><label class="expand" for="c-41069567">[9 more]</label></div><br/><div class="children"><div class="content">The syntax from the perspective of type <i>stripping</i> has been relatively stable for more versions of Typescript than it was unstable. You had to reach all the way back to 1.5 in part because it&#x27;s been very stable since about 2.x. The last major shift in syntax was probably Conditional Types in 2.8 adding the ternary if operator in type positions. (The type <i>model</i> if you were to try to typecheck rather than just type-strip has changed a lot since 2.x, but syntax has been generally stable. That&#x27;s where most of Typescript&#x27;s innovation has been in the type model&#x2F;type inferencing rather than in syntax.)<p>It&#x27;s still just (early in the process) Stage 1, but the majority of Typescript&#x27;s type syntax, for the purposes of type stripping (not type checking), <i>is</i> attempting to be somewhat standardized: <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations</a></div><br/><div id="41070251" class="c"><input type="checkbox" id="c-41070251" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41069567">parent</a><span>|</span><a href="#41065710">next</a><span>|</span><label class="collapse" for="c-41070251">[-]</label><label class="expand" for="c-41070251">[8 more]</label></div><br/><div class="children"><div class="content">They did <i>just</i> add a new keyword, satisfies, in 5.4. That would be a breaking change if you can’t upgrade the type stripper separately.</div><br/><div id="41071098" class="c"><input type="checkbox" id="c-41071098" checked=""/><div class="controls bullet"><span class="by">felixfbecker</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41070251">parent</a><span>|</span><a href="#41071032">next</a><span>|</span><label class="collapse" for="c-41071098">[-]</label><label class="expand" for="c-41071098">[6 more]</label></div><br/><div class="children"><div class="content">This is true, but in other cases they added keywords in ways that could work with type stripping. For example, the `as` keyword for casts has existed for a long time, and type stripping could strip everything after the `as` keyword with a minimal grammar.<p>When TypeScript added const declarations, they added it as `as const` so a type stripping could have still worked depending on how loosely it is implemented.<p>I think there is a world where type stripping exists (which the TS team has been in favor of) and the TS team might consider how it affects type stripping in future language design. For example, the `satisfies` keyword could have also been added by piggy-backing on the `as` keyword, like:<p><pre><code>    const foo = { bar: 1 } as subtype of Foo
</code></pre>
(I think not using `as` is a better fit semantically but this could be a trade-off to make for better type stripping backwards compatibility)</div><br/><div id="41076015" class="c"><input type="checkbox" id="c-41076015" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41071098">parent</a><span>|</span><a href="#41072069">next</a><span>|</span><label class="collapse" for="c-41076015">[-]</label><label class="expand" for="c-41076015">[1 more]</label></div><br/><div class="children"><div class="content">It can’t strip what’s after the as keyword without an up-to-date TS grammar, because `as` is an expression. The parser needs to know how to parse type expressions in order to know when the RHS of the `as` expression ends.<p>Let’s say that typescript adds a new type operator “wobble T”. What does this desugar to?<p><pre><code>    x as wobble
    T
</code></pre>
Without knowing about the new wobble syntax this would be parsed as `x as wobble; T` and desugar to `x; T`<p>With the new wobble syntax it would be parsed as `x as (wobble T);` according to JS semicolon insertion rules because the expression wobble is incomplete, and desugar to `x`</div><br/></div></div><div id="41072069" class="c"><input type="checkbox" id="c-41072069" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41071098">parent</a><span>|</span><a href="#41076015">prev</a><span>|</span><a href="#41071032">next</a><span>|</span><label class="collapse" for="c-41072069">[-]</label><label class="expand" for="c-41072069">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know a lot about parser theory, and would love to learn more about ways to make parsing resilient in cases like this one. Simple cases like &quot;ignore rest of line&quot; make sense to me, but I&#x27;m unsure about &quot;adversarial&quot; examples (in the sense that they are meant to beat simple heuristics). Would you mind explaining how e.g. your `as` stripping could work for one specific adversarial example?<p><pre><code>    function foo&lt;T&gt;() {
        return bar(
            null as unknown as T extends boolean
            ? true &#x2F;* ): *&#x2F;
            : (T extends string
                ? &quot;string&quot;
                : false
            )
            )
    }

    function bar(value: any): void {}
</code></pre>
Any solution I can come up with suffers from at least one of these issues:<p>- &quot;ignore rest of line&quot; will either fail or lead to incorrect results
- &quot;find matching parenthesis&quot; would have to parse comments inside types (probably doable, but could break with future TS additions)
- &quot;try finding end of non-JS code&quot; will inevitably trip up in some situations, and can get very expensive<p>I&#x27;d love a rough outline or links&#x2F;pointers, if you can find the time!<p>[0] TS Playground link: <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?#code&#x2F;AQ4MwVwOwYwFwJYHsriUgPAFQHwAoBKYAbwChQLgAnAUzgitQCMBDKvcyrqCAG1+AsAzsGgBrKEgDuqYcCzAaADzg0oAExFN0vGiyicuFAPzA4VCDWAB6AFTACALmC3rhoyGd4Fy1RpFC5ghQAObuHibAAESBVMEhUeERnuAsvEI0SVwEWZQ5FAC+pO6QsIgowKzsAG5pls76AJ5OwNVICOokRUA" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?#code&#x2F;AQ4MwVwOwYwFwJYHs...</a></div><br/><div id="41072923" class="c"><input type="checkbox" id="c-41072923" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41072069">parent</a><span>|</span><a href="#41071032">next</a><span>|</span><label class="collapse" for="c-41072923">[-]</label><label class="expand" for="c-41072923">[3 more]</label></div><br/><div class="children"><div class="content">Most parsers don&#x27;t actually work with &quot;lines&quot; as a unit, those are for user-formatting. Generally the sort of building blocks you are looking for are more along the lines of &quot;until end of expression&quot; or &quot;until end of statement&quot;. What defines an &quot;expression&quot; or a &quot;statement&quot; can be very complex depending on the parser and the language you are trying to parse.<p>In JS, because it is a fun example, &quot;end of statement&quot; is defined in large part by Automatic Semicolon Insertion (ASI), whether or not semicolons even exist in the source input. (Even if you use semicolons regularly in JS, JS will still insert its own semicolons. Semicolons don&#x27;t protect you from ASI.) ASI is also a useful example because it is an ancient example of a language design intentionally trying to be resilient. Some older JS parsers even would ignore bad statements and continue on the next statement based on ASI determined statement break. We generally like our JS to be much more strict than that today, but early JS was originally built to be a resilient language in some interesting ways.<p>One place to dive into that directly (in the middle of a deeper context of JS parser theory): <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Lexical_grammar#automatic_semicolon_insertion" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/><div id="41074354" class="c"><input type="checkbox" id="c-41074354" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41072923">parent</a><span>|</span><a href="#41071032">next</a><span>|</span><label class="collapse" for="c-41074354">[-]</label><label class="expand" for="c-41074354">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the response, but I&#x27;m aware of the basics. My question is pointed towards making language parsers resilient towards separately-evolving standards. How would you build a JS parser so that it correctly parses any new TS syntax, without changing behavior of valid code?<p>The example snippet I added is designed to violate the rules I could come up with. I&#x27;d specifically like to know: what are better rules to solve this specific case?</div><br/><div id="41076876" class="c"><input type="checkbox" id="c-41076876" checked=""/><div class="controls bullet"><span class="by">thanksgiving</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41074354">parent</a><span>|</span><a href="#41071032">next</a><span>|</span><label class="collapse" for="c-41076876">[-]</label><label class="expand" for="c-41076876">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How would you build a JS parser so that it correctly parses any new TS syntax, without changing behavior of valid code?<p>I don&#x27;t know anything about parsers besides what I learned from that one semester worth of introduction class I took in college but from what I understand of your question, I think the answer is you can&#x27;t simply because we can&#x27;t look into the future.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41071032" class="c"><input type="checkbox" id="c-41071032" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41070251">parent</a><span>|</span><a href="#41071098">prev</a><span>|</span><a href="#41065710">next</a><span>|</span><label class="collapse" for="c-41071032">[-]</label><label class="expand" for="c-41071032">[1 more]</label></div><br/><div class="children"><div class="content">But at least its a loud failure and not a silent different interpretation of the source as the example was. Still.</div><br/></div></div></div></div></div></div><div id="41065710" class="c"><input type="checkbox" id="c-41065710" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41069567">prev</a><span>|</span><a href="#41071127">next</a><span>|</span><label class="collapse" for="c-41065710">[-]</label><label class="expand" for="c-41065710">[9 more]</label></div><br/><div class="children"><div class="content">You would also have to update your compiler. I guess you could phrase this as: you can&#x27;t update your TS versions independently from your node.js version. But that&#x27;s probably not an issue.</div><br/><div id="41066110" class="c"><input type="checkbox" id="c-41066110" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41065710">parent</a><span>|</span><a href="#41068362">next</a><span>|</span><label class="collapse" for="c-41066110">[-]</label><label class="expand" for="c-41066110">[7 more]</label></div><br/><div class="children"><div class="content">It’s an issue because node has a system of LTS releases, whereas TypeScript has quarterly updates, so the release cadence is different.<p>Updating node is much more fraught than updating TypeScript. For example, it may break any native code modules. That’s why users are directed to use the LTS and not the most recent release, so that there’s enough time for libraries to add support for the new version.<p>On the other hand, I usually adopt a new TypeScript version as soon as it comes out.</div><br/><div id="41066548" class="c"><input type="checkbox" id="c-41066548" checked=""/><div class="controls bullet"><span class="by">satanacchio</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066110">parent</a><span>|</span><a href="#41066563">next</a><span>|</span><label class="collapse" for="c-41066548">[-]</label><label class="expand" for="c-41066548">[1 more]</label></div><br/><div class="children"><div class="content">I made it sure to decouple the transpiler from node itself, the transpiler is in a npm package called amaro, that is bundled in node. The goal is to allow user to upgrade amaro indipendently so we dont have to lock a ts version for the whole lifespan of a release</div><br/></div></div><div id="41066563" class="c"><input type="checkbox" id="c-41066563" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066110">parent</a><span>|</span><a href="#41066548">prev</a><span>|</span><a href="#41066178">next</a><span>|</span><label class="collapse" for="c-41066563">[-]</label><label class="expand" for="c-41066563">[3 more]</label></div><br/><div class="children"><div class="content">TypeScript feels &quot;boring&quot; enough at this point that being a few years behind isn&#x27;t gonna be an issue in most cases. For teams who want to stay on the absolute latest release of TypeScript but want to be more conservative with their Node version, external compilation will remain necessary; but for someone like me, where TypeScript has been &quot;good enough&quot; for many years that I&#x27;m not excited by new TypeScript releases, this feature will be really nice.<p>(&quot;Boring&quot; in this context is a compliment, by the way)<p>EDIT: Though reading other comments, it seems like you can update the typescript stripper independent of node? That makes this moot anyway</div><br/><div id="41066916" class="c"><input type="checkbox" id="c-41066916" checked=""/><div class="controls bullet"><span class="by">mu53</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066563">parent</a><span>|</span><a href="#41066178">next</a><span>|</span><label class="collapse" for="c-41066916">[-]</label><label class="expand" for="c-41066916">[2 more]</label></div><br/><div class="children"><div class="content">typescript is still evolving in dramatic ways. The 5.0 release has some really good improvements</div><br/><div id="41068125" class="c"><input type="checkbox" id="c-41068125" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066916">parent</a><span>|</span><a href="#41066178">next</a><span>|</span><label class="collapse" for="c-41068125">[-]</label><label class="expand" for="c-41068125">[1 more]</label></div><br/><div class="children"><div class="content">But at the same time, it&#x27;s good enough and has been good enough for many years. It&#x27;s like how I&#x27;m sure EcmaScript 2024 contains cool new stuff, but if node only supported ES6, I would have no trouble writing ES6.</div><br/></div></div></div></div></div></div><div id="41066178" class="c"><input type="checkbox" id="c-41066178" checked=""/><div class="controls bullet"><span class="by">another-dave</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066110">parent</a><span>|</span><a href="#41066563">prev</a><span>|</span><a href="#41068362">next</a><span>|</span><label class="collapse" for="c-41066178">[-]</label><label class="expand" for="c-41066178">[2 more]</label></div><br/><div class="children"><div class="content">Though I&#x27;d primarily see this as a feature for the REPL or manual scripts where I&#x27;m not going to mind doing a `nvm use X`.<p>For production use, I&#x27;d still put my TS files through a build pipeline as normal</div><br/><div id="41067931" class="c"><input type="checkbox" id="c-41067931" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066178">parent</a><span>|</span><a href="#41068362">next</a><span>|</span><label class="collapse" for="c-41067931">[-]</label><label class="expand" for="c-41067931">[1 more]</label></div><br/><div class="children"><div class="content">tangential protip: if you&#x27;re using nvm to manage node versions, take a look at fnm as a superior replacement. (It can read the same .nvmrc file to switch on cd into a given dir, but it&#x27;s faster and &quot;cleaner&quot; wrt impact on your shell.)</div><br/></div></div></div></div></div></div><div id="41068362" class="c"><input type="checkbox" id="c-41068362" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41065710">parent</a><span>|</span><a href="#41066110">prev</a><span>|</span><a href="#41071127">next</a><span>|</span><label class="collapse" for="c-41068362">[-]</label><label class="expand" for="c-41068362">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily.<p>With a couple exceptions (like enums), you can strip the types out of TypeScript and end up with valid JS. What you <i>could</i> do is stabilize the grammar, and release new versions of TypeScript using the same grammar. Maybe you need a flag to use LTS grammar in your tsconfig.json file.</div><br/></div></div></div></div><div id="41071127" class="c"><input type="checkbox" id="c-41071127" checked=""/><div class="controls bullet"><span class="by">felixfbecker</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41065710">prev</a><span>|</span><a href="#41068214">next</a><span>|</span><label class="collapse" for="c-41071127">[-]</label><label class="expand" for="c-41071127">[2 more]</label></div><br/><div class="children"><div class="content">I think the kind of teams that always stay on top of the latest TypeScript version and use the latest language features are also more likely to always stay on top of the latest Node versions. In my experience TypeScript upgrades actually more often need migrations&#x2F;fixes for new errors than Node upgrades.
Teams that don&#x27;t care about latest V8 and Node features and always stay on LTS probably also care less about the latest and greatest TypeScript features.</div><br/><div id="41072850" class="c"><input type="checkbox" id="c-41072850" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41071127">parent</a><span>|</span><a href="#41068214">next</a><span>|</span><label class="collapse" for="c-41072850">[-]</label><label class="expand" for="c-41072850">[1 more]</label></div><br/><div class="children"><div class="content">I work on a large app that’s both client &amp; server typescript called Notion.<p>We find Typescript much easier to upgrade than Node. New Node versions change performance characteristics of the app at runtime, and sometimes regress complex features like async hooks or have memory leaks. We tend to have multi-week rollout plans for new Node versions with side-by-side deploys to check metrics.<p>Typescript on the other hand someone can upgrade in a single PR, and once you get the types to check, you’re done and you merge. We just got to the latest TS version last week.</div><br/></div></div></div></div><div id="41068214" class="c"><input type="checkbox" id="c-41068214" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41071127">prev</a><span>|</span><a href="#41066359">next</a><span>|</span><label class="collapse" for="c-41068214">[-]</label><label class="expand" for="c-41068214">[15 more]</label></div><br/><div class="children"><div class="content">Using inequality signs as angled brackets really is a mistake isn&#x27;t it...</div><br/><div id="41068736" class="c"><input type="checkbox" id="c-41068736" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068214">parent</a><span>|</span><a href="#41068301">next</a><span>|</span><label class="collapse" for="c-41068736">[-]</label><label class="expand" for="c-41068736">[1 more]</label></div><br/><div class="children"><div class="content">Mistake isn&#x27;t the right word. It&#x27;s just a tradeoff.<p>There was no perfect solution available, so a tradeoff was necessary. You can disagree with this particular tradeoff, but had they gone another way some people would disagree with that as well. To be a mistake there would have had to have been an option available that was clearly better at the time.<p>Anyway, the idea that TS 5 should be backwards compatible with TS 1 is probably a bad one. Personally, I think packages with wide usage break backwards compatibility <i>far</i> too easily -- it puts everyone who uses it on an upgrade treadmill, so it should be done <i>very</i> judiciously. But even I wouldn&#x27;t argue that TS 1 should have been its final form.</div><br/></div></div><div id="41068301" class="c"><input type="checkbox" id="c-41068301" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068214">parent</a><span>|</span><a href="#41068736">prev</a><span>|</span><a href="#41070595">next</a><span>|</span><label class="collapse" for="c-41068301">[-]</label><label class="expand" for="c-41068301">[11 more]</label></div><br/><div class="children"><div class="content">I’ll flip this around… reusing comparison as angle brackets is the mistake. C++ ran into some issues too.<p>I think Rust made the really smart move of putting :: before any type parameters for functions. Go made the good move of using square brackets for type parameters.</div><br/><div id="41068485" class="c"><input type="checkbox" id="c-41068485" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068301">parent</a><span>|</span><a href="#41068742">next</a><span>|</span><label class="collapse" for="c-41068485">[-]</label><label class="expand" for="c-41068485">[9 more]</label></div><br/><div class="children"><div class="content">The problem can be traced back to ASCII&#x2F;typewriters only including three sets of paired characters, plus inequality signs, which is not enough for programming languages.<p>We really need five sets: grouping, arrays&#x2F;indexing, records, type parameters, and compound statements. Curly braces {} are also overloaded in JS for records and compound statements, leading to x =&gt; {} and x =&gt; ({}) meaning different things.<p>Square brackets wouldn&#x27;t work for parametric functions because f[T](x) already means get the element at index T and call it.</div><br/><div id="41071043" class="c"><input type="checkbox" id="c-41071043" checked=""/><div class="controls bullet"><span class="by">parasense</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068485">parent</a><span>|</span><a href="#41076266">next</a><span>|</span><label class="collapse" for="c-41071043">[-]</label><label class="expand" for="c-41071043">[4 more]</label></div><br/><div class="children"><div class="content">Paired characters...<p>That&#x27;s an interesting topic. Do you happen to know if UTF-8 contains more &quot;pair&quot; characters? In Latex we call these delimiteres, but that&#x27;s just my limited experience coming in from math side. I tend to agree that it would be helpful to have more kind of nesting&#x2F;pairing&#x2F;grouping&#x2F;delimiting characters. The problem is my imagination is limited to what I know from the ASCII world, and so it goes... no idea what new sets would look like.</div><br/><div id="41071751" class="c"><input type="checkbox" id="c-41071751" checked=""/><div class="controls bullet"><span class="by">pshc</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41071043">parent</a><span>|</span><a href="#41072452">next</a><span>|</span><label class="collapse" for="c-41071751">[-]</label><label class="expand" for="c-41071751">[1 more]</label></div><br/><div class="children"><div class="content">So many different pairs are available. I like Asian corner brackets 「」and French guillemets « ». The angle brackets 〈〉 are popular in CS&#x2F;math papers I think, though they might be confused with &lt;&gt;.</div><br/></div></div><div id="41072452" class="c"><input type="checkbox" id="c-41072452" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41071043">parent</a><span>|</span><a href="#41071751">prev</a><span>|</span><a href="#41075344">next</a><span>|</span><label class="collapse" for="c-41072452">[-]</label><label class="expand" for="c-41072452">[1 more]</label></div><br/><div class="children"><div class="content">Sure, you can use Canadian Aboriginal Syllabics!<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;5penft&#x2F;comment&#x2F;dcsq64p&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;5penft&#x2F;comment&#x2F;dcsq64...</a></div><br/></div></div><div id="41075344" class="c"><input type="checkbox" id="c-41075344" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41071043">parent</a><span>|</span><a href="#41072452">prev</a><span>|</span><a href="#41076266">next</a><span>|</span><label class="collapse" for="c-41075344">[-]</label><label class="expand" for="c-41075344">[1 more]</label></div><br/><div class="children"><div class="content">Nit: UTF-8 is a particular encoding. Unicode is a character system.<p>UTF-8, UTF-16, UTF-32 all have the same characters.</div><br/></div></div></div></div><div id="41076266" class="c"><input type="checkbox" id="c-41076266" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068485">parent</a><span>|</span><a href="#41071043">prev</a><span>|</span><a href="#41073968">next</a><span>|</span><label class="collapse" for="c-41076266">[-]</label><label class="expand" for="c-41076266">[1 more]</label></div><br/><div class="children"><div class="content">There is also the possibility to use digraphs such as &lt;: :&gt; or other combinations.<p>(And they could even converted to unicode by the code formatter)</div><br/></div></div><div id="41073968" class="c"><input type="checkbox" id="c-41073968" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068485">parent</a><span>|</span><a href="#41076266">prev</a><span>|</span><a href="#41069192">next</a><span>|</span><label class="collapse" for="c-41073968">[-]</label><label class="expand" for="c-41073968">[1 more]</label></div><br/><div class="children"><div class="content">Five sets, but at any given place in the syntax, not all five are possible. (I would add function calls to the list—so, six.)<p>In most languages, (grouping and compound statements) cannot syntactically appear in the same place as (indexing, records, type parameters, function calls). So we are immediately down to four.<p>Rust takes the approach that you use :: before type parameters, so they are easily distinguished from comparison operators at a syntactic level.<p>Go takes the approach that [] is just fine for type parameters—which seems pretty reasonable to me. In Go, there’s nothing that can be both indexed *and* take a type parameter.</div><br/></div></div><div id="41069192" class="c"><input type="checkbox" id="c-41069192" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068485">parent</a><span>|</span><a href="#41073968">prev</a><span>|</span><a href="#41069303">next</a><span>|</span><label class="collapse" for="c-41069192">[-]</label><label class="expand" for="c-41069192">[1 more]</label></div><br/><div class="children"><div class="content">I think the D syntax would work: f!T(x)</div><br/></div></div><div id="41069303" class="c"><input type="checkbox" id="c-41069303" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068485">parent</a><span>|</span><a href="#41069192">prev</a><span>|</span><a href="#41068742">next</a><span>|</span><label class="collapse" for="c-41069303">[-]</label><label class="expand" for="c-41069303">[1 more]</label></div><br/><div class="children"><div class="content">Everytime a standardization happens, part of human creativity gets suppressed. Before ASCII, people were inventing all sorts of symbols and even the alphabet was flexible to changes. After ASCII, we got stuck with a certain set of letters and symbols. Heck, even our keyboards haven&#x27;t changed that much since then. I really think we need more symbols than just &amp;@$#%^*}{][&lt;&gt;()&#x2F;\_~|</div><br/></div></div></div></div><div id="41068742" class="c"><input type="checkbox" id="c-41068742" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068301">parent</a><span>|</span><a href="#41068485">prev</a><span>|</span><a href="#41070595">next</a><span>|</span><label class="collapse" for="c-41068742">[-]</label><label class="expand" for="c-41068742">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re flipping it around, I think that&#x27;s exactly what OP was saying, just clearer.</div><br/></div></div></div></div><div id="41070595" class="c"><input type="checkbox" id="c-41070595" checked=""/><div class="controls bullet"><span class="by">SomeCallMeTim</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41068214">parent</a><span>|</span><a href="#41068301">prev</a><span>|</span><a href="#41066359">next</a><span>|</span><label class="collapse" for="c-41070595">[-]</label><label class="expand" for="c-41070595">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a TypeScript mistake.<p>You could argue that it was a C++ mistake. It makes parsing harder, but otherwise seems to work as expected, so I don&#x27;t consider it a mistake, but you could at least argue that way.<p>But regardless if it was a mistake in C++, it&#x27;s now a complete standard, used in C++, Java, C#, and other languages to denote type parameters.<p>I would argue that it would have been a mistake to break that standard. What would you have used, and in what way would that have been enough better to compensate for the increased difficulty in understanding TypeScript generics for users of almost every other popular language?</div><br/><div id="41070861" class="c"><input type="checkbox" id="c-41070861" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41070595">parent</a><span>|</span><a href="#41066359">next</a><span>|</span><label class="collapse" for="c-41070861">[-]</label><label class="expand" for="c-41070861">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely the right choice for Typescript. You could have gone the Scala route and used [] for generics, but that is so heavily used in ts&#x2F;js as arrays it would not have made any sense.</div><br/></div></div></div></div></div></div><div id="41066359" class="c"><input type="checkbox" id="c-41066359" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41068214">prev</a><span>|</span><a href="#41066238">next</a><span>|</span><label class="collapse" for="c-41066359">[-]</label><label class="expand" for="c-41066359">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s already the case for ECMAScript and I don&#x27;t see why TypeScript should be treated differently when Node.js has to transpile it to JavaScript and among other things ensure that there are no regressions that would break existing code.<p>Unlike Python typing it&#x27;s not only type erasure: enums, namespaces, decorators, access modifiers, helper functions and so on need to be transformed into their JavaScript equivalent.</div><br/></div></div><div id="41066238" class="c"><input type="checkbox" id="c-41066238" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41066359">prev</a><span>|</span><a href="#41067137">next</a><span>|</span><label class="collapse" for="c-41066238">[-]</label><label class="expand" for="c-41066238">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not worried about that too much to be honest.<p>To me beyond v4.4 or so, when it started being possible to create crazy recursive dependent types (the syntax was there since ~4.1 - it&#x27;s just that the compiler complained), there weren&#x27;t a lot of groundbreaking new features being added, so unless an external library requires a specific TS version to parse its type declarations, it doesn&#x27;t change much.</div><br/><div id="41066908" class="c"><input type="checkbox" id="c-41066908" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066238">parent</a><span>|</span><a href="#41067137">next</a><span>|</span><label class="collapse" for="c-41066908">[-]</label><label class="expand" for="c-41066908">[2 more]</label></div><br/><div class="children"><div class="content">&gt; crazy recursive dependent types<p>Some edge-cases involving those have bugfixes and ergonomy improvents I&#x27;ve run into on 5.x.</div><br/><div id="41076518" class="c"><input type="checkbox" id="c-41076518" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066908">parent</a><span>|</span><a href="#41067137">next</a><span>|</span><label class="collapse" for="c-41076518">[-]</label><label class="expand" for="c-41076518">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great to know, thank you.<p>That being said I regret every use of `infer` in application code.</div><br/></div></div></div></div></div></div><div id="41067137" class="c"><input type="checkbox" id="c-41067137" checked=""/><div class="controls bullet"><span class="by">getcrunk</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41066238">prev</a><span>|</span><a href="#41065697">next</a><span>|</span><label class="collapse" for="c-41067137">[-]</label><label class="expand" for="c-41067137">[1 more]</label></div><br/><div class="children"><div class="content">Do you really need to update all the time? Are the new features always that immediately important?</div><br/></div></div><div id="41065697" class="c"><input type="checkbox" id="c-41065697" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41067137">prev</a><span>|</span><a href="#41066008">next</a><span>|</span><label class="collapse" for="c-41065697">[-]</label><label class="expand" for="c-41065697">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible that internal SWC version will be versioned alongside Node, meaning TS syntax support won&#x27;t drift. Or am I missing something?</div><br/><div id="41066092" class="c"><input type="checkbox" id="c-41066092" checked=""/><div class="controls bullet"><span class="by">thecopy</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41065697">parent</a><span>|</span><a href="#41070567">next</a><span>|</span><label class="collapse" for="c-41066092">[-]</label><label class="expand" for="c-41066092">[2 more]</label></div><br/><div class="children"><div class="content">TypeScript evolves independent of Node, and the syntax you can use depends on your `typescript` version in the `package.json`</div><br/><div id="41066706" class="c"><input type="checkbox" id="c-41066706" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41066092">parent</a><span>|</span><a href="#41070567">next</a><span>|</span><label class="collapse" for="c-41066706">[-]</label><label class="expand" for="c-41066706">[1 more]</label></div><br/><div class="children"><div class="content">Not if SWC or your tooling doesn&#x27;t support it.</div><br/></div></div></div></div><div id="41070567" class="c"><input type="checkbox" id="c-41070567" checked=""/><div class="controls bullet"><span class="by">satanacchio</span><span>|</span><a href="#41065376">root</a><span>|</span><a href="#41065697">parent</a><span>|</span><a href="#41066092">prev</a><span>|</span><a href="#41066008">next</a><span>|</span><label class="collapse" for="c-41070567">[-]</label><label class="expand" for="c-41070567">[1 more]</label></div><br/><div class="children"><div class="content">yes but can also be upgraded separately as npm package</div><br/></div></div></div></div><div id="41073011" class="c"><input type="checkbox" id="c-41073011" checked=""/><div class="controls bullet"><span class="by">js4ever</span><span>|</span><a href="#41065376">parent</a><span>|</span><a href="#41066008">prev</a><span>|</span><a href="#41064729">next</a><span>|</span><label class="collapse" for="c-41073011">[-]</label><label class="expand" for="c-41073011">[1 more]</label></div><br/><div class="children"><div class="content">If only typescript could avoid changing syntax every 2 weeks.</div><br/></div></div></div></div><div id="41064729" class="c"><input type="checkbox" id="c-41064729" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41065376">prev</a><span>|</span><a href="#41070130">next</a><span>|</span><label class="collapse" for="c-41064729">[-]</label><label class="expand" for="c-41064729">[116 more]</label></div><br/><div class="children"><div class="content">If Node.js can run TypeScript files directly, then the TypeScript compiler won&#x27;t need to strip types and convert to JavaScript - it could be used solely as a type checker. This would be similar to the situation in Python, where type checkers check types and leave them intact, and the Python interpreter just ignores them.<p>It&#x27;s interesting, though, that this approach in Python has led to several (4?) different popular type checkers, which AFAIK all use the same type hint syntax but apply different semantics. However for JavaScript, TypeScript seems to have become the one-and-only popular type checker.<p>In Python, I&#x27;ve even heard of people writing types in source code but never checking them, essentially using type hints as a more convenient syntax for comments. Support for ignoring types in Node.js would make that approach possible in JavaScript as well.</div><br/><div id="41064736" class="c"><input type="checkbox" id="c-41064736" checked=""/><div class="controls bullet"><span class="by">winter_blue</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41076826">next</a><span>|</span><label class="collapse" for="c-41064736">[-]</label><label class="expand" for="c-41064736">[57 more]</label></div><br/><div class="children"><div class="content">Flow (by Facebook) used to be fairly significant in the JavaScript several years ago, but right now it&#x27;s somewhat clear that TypeScript has won rather handily.</div><br/><div id="41064927" class="c"><input type="checkbox" id="c-41064927" checked=""/><div class="controls bullet"><span class="by">mattnewton</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064736">parent</a><span>|</span><a href="#41069935">next</a><span>|</span><label class="collapse" for="c-41064927">[-]</label><label class="expand" for="c-41064927">[31 more]</label></div><br/><div class="children"><div class="content">Before that there was the closure compiler (Google) which had type annotations in comments. 
The annotation syntax in comments was a little clunky but overall that project was ahead of it&#x27;s time. 
Now I believe even inside google that has been transpiled to typescript (or typescript is being transpiled to closure, I can&#x27;t remember which - the point is that the typescript interface is what people are using for new code).</div><br/><div id="41065117" class="c"><input type="checkbox" id="c-41065117" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064927">parent</a><span>|</span><a href="#41065270">next</a><span>|</span><label class="collapse" for="c-41065117">[-]</label><label class="expand" for="c-41065117">[23 more]</label></div><br/><div class="children"><div class="content">Closure was also interesting because it integrated type checking and minification, which made minification significantly more useful.<p>With normal Javascript and typescript, you can&#x27;t minify property names, so `foo.bar.doSomethingVeryComplicated()` can only be turned into `a.bar.doSomethingVeryComplicated()`, not `a.b.c()`, like with Closure. This is because objects can be indexed by strings. Something like `foo.bar[function]()` is perfectly valid JS, where the value of `function` might come from the user.<p>A minifier can&#x27;t guarantee that such expressions won&#x27;t be used, so it cannot optimize property accesses. Because Closure was a type checker and a minifier at the same time, it could minify the properties declared as private, while leaving the public ones intact.</div><br/><div id="41069300" class="c"><input type="checkbox" id="c-41069300" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065117">parent</a><span>|</span><a href="#41067475">next</a><span>|</span><label class="collapse" for="c-41069300">[-]</label><label class="expand" for="c-41069300">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it could minify the properties declared as private, while leaving the public ones intact.<p>I don&#x27;t think it ever actually did this. It renamed all properties (you could use the index syntax to avoid this) and just used a global mapping to ensure that every source property name was consistently renamed (no matter what type it was on). I don&#x27;t think type information was ever actually used in minification.<p>So if you had two independent types that had a `getName` function the compiler would always give them the same minified name even though in theory their names could be different because they were fully independent types. The mapping was always bijective. This is suboptimal because short names like `a` could only be used for a single source name, leading to higher entropy names overall. Additionally names from the JS runtime were globally excluded from renaming. So any `.length` property would never be renamed in case it was `[].length`.</div><br/></div></div><div id="41067475" class="c"><input type="checkbox" id="c-41067475" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065117">parent</a><span>|</span><a href="#41069300">prev</a><span>|</span><a href="#41065370">next</a><span>|</span><label class="collapse" for="c-41067475">[-]</label><label class="expand" for="c-41067475">[18 more]</label></div><br/><div class="children"><div class="content">&gt; A minifier can&#x27;t guarantee that such expressions won&#x27;t be used, so it cannot optimize property accesses.<p>Given TypeScript’s type system is unsound, neither could it even if it tried, right? I guess Flow could, but well, here we are.</div><br/><div id="41072853" class="c"><input type="checkbox" id="c-41072853" checked=""/><div class="controls bullet"><span class="by">RyanCavanaugh</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067475">parent</a><span>|</span><a href="#41067996">next</a><span>|</span><label class="collapse" for="c-41072853">[-]</label><label class="expand" for="c-41072853">[2 more]</label></div><br/><div class="children"><div class="content">Flow&#x27;s type system isn&#x27;t sound either FWIW</div><br/><div id="41076654" class="c"><input type="checkbox" id="c-41076654" checked=""/><div class="controls bullet"><span class="by">price</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41072853">parent</a><span>|</span><a href="#41067996">next</a><span>|</span><label class="collapse" for="c-41076654">[-]</label><label class="expand" for="c-41076654">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Flow had the ambition to be sound but has never accomplished it.<p>If you read the Flow codebase and its Git history, you can see that it&#x27;s not for lack of trying, either — every couple of years there&#x27;s an ambitious new engineer with a new plan for how to make it happen. But it&#x27;s a real tough migration problem — it only works if they can provide a credible, appealing migration path to the other engineers across Facebook&#x2F;Meta&#x27;s giant JS codebase. Starting from a language like JS with all the dynamic tricks people use there, that&#x27;s a tough job.<p>(And naturally it&#x27;d be even harder if they were trying to get any wider community to migrate, outside their own employer.)</div><br/></div></div></div></div><div id="41067996" class="c"><input type="checkbox" id="c-41067996" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067475">parent</a><span>|</span><a href="#41072853">prev</a><span>|</span><a href="#41067538">next</a><span>|</span><label class="collapse" for="c-41067996">[-]</label><label class="expand" for="c-41067996">[14 more]</label></div><br/><div class="children"><div class="content">What do you mean by unsound exactly.<p>I&#x27;m asking because there&#x27;s no accepted definition of what an unsound type system is.<p>What I often see is that the word unsound is used to mean that a type system can accept types different to what has been declared, and in that case there&#x27;s nothing unsound about ts since it won&#x27;t allow you to do so.</div><br/><div id="41069387" class="c"><input type="checkbox" id="c-41069387" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067996">parent</a><span>|</span><a href="#41070615">next</a><span>|</span><label class="collapse" for="c-41069387">[-]</label><label class="expand" for="c-41069387">[4 more]</label></div><br/><div class="children"><div class="content">&gt; and in that case there&#x27;s nothing unsound about ts since it won&#x27;t allow you to do so<p>Consider this example (<a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?ssl=10&amp;ssc=1&amp;pln=1&amp;pc=1#code&#x2F;GYVwdgxgLglg9mABAWwKYGd0FUAOAVAC1QEEAnUgQwE8AKC8gLkTMqoB50pSYwBzRAD6IwIZACNUpAHwBKJgDc4MACaIA3gFgAUIl2J6pAHQ4Q6AjQDMMgNzaAvtu0QEnRJ2590TFtQ5cevFKIALyIANoA5MBwcBEANIgRYvQRALq2WmiYuIQk5NQ07gHoNo5azmCuXm7+fCE1HrzoYQBM6U4ucAA2qIZdcLyFhlBwADJwAO6SAMIU6Kg0MjLaQA" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?ssl=10&amp;ssc=1&amp;pln=1&amp;pc=1...</a>):<p><pre><code>  function messUpTheArray(arr: Array&lt;string | number&gt;): void {
      arr.push(3);
  }
  
  const strings: Array&lt;string&gt; = [&#x27;foo&#x27;, &#x27;bar&#x27;];
  messUpTheArray(strings);
  
  const s: string = strings[2];
  console.log(s.toLowerCase())
  </code></pre>
Could you explain how this isn&#x27;t the type system accepting types &quot;different to what has been declared&quot;? Kinda looks like TypeScript is happy to type check this, despite `s` being a `number` at runtime.</div><br/><div id="41070583" class="c"><input type="checkbox" id="c-41070583" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069387">parent</a><span>|</span><a href="#41070615">next</a><span>|</span><label class="collapse" for="c-41070583">[-]</label><label class="expand" for="c-41070583">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good example, albeit quite of a far-fetched one.<p>In Haskell land, where the type system is considered sound you have `head` functions of type `List a -&gt; a` that are unsound too, because the list might be empty.</div><br/><div id="41071530" class="c"><input type="checkbox" id="c-41071530" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41070583">parent</a><span>|</span><a href="#41073826">next</a><span>|</span><label class="collapse" for="c-41071530">[-]</label><label class="expand" for="c-41071530">[1 more]</label></div><br/><div class="children"><div class="content">That option also exists, you can just leave out the `messUpTheArray` lines and you get an error about how `undefined` also doesn&#x27;t have a `.toLowerCase()` method.<p>However this problem as stated is slightly different and has to do with a failure of OOP&#x2F;subtyping to actually intermingle with our expectations of covariance.<p>So to just use classic &quot;animal metaphor&quot; OOP, if you have an Animal class with Dog and Cat subclasses, and you create an IORef&lt;Cat&gt;, a cell that can contain a cat, you would like to provide that to an IORef&lt;Animal&gt; function because you want to think of the type as covariant: Cat is a subtype of Animal, F&lt;Cat&gt; should be a subtype of F&lt;Animal&gt;. The problem is that this function now has the blessing of the type system to store a Dog in the cell, which can be observed by the parts that still consider this an IORef&lt;Cat&gt;.<p>Put slightly differently, in OOP, the methods of IORef&lt;Cat&gt; all accept an implicit IORef&lt;Cat&gt; called `this`, if those methods are part of what define an IORef&lt;x&gt; then an IORef&lt;x&gt; is necessarily invariant, not covariant, in &lt;x&gt;. And then you can&#x27;t assume subtyping. So to be sound a subtype system would presumably have to actually mark contra&#x2F;covariance around <i>everything</i>, and TypeScript very intentionally documents that they <i>don&#x27;t</i> do this and are just trying to make a &quot;best effort&quot; pass because JavaScript has 0 types, and crappy types are better than no types, and we can&#x27;t wait for perfect types to replace the crappy types.</div><br/></div></div><div id="41073826" class="c"><input type="checkbox" id="c-41073826" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41070583">parent</a><span>|</span><a href="#41071530">prev</a><span>|</span><a href="#41070615">next</a><span>|</span><label class="collapse" for="c-41073826">[-]</label><label class="expand" for="c-41073826">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In Haskell land, where the type system is considered sound you have `head` functions of type `List a -&gt; a` that are unsound too, because the list might be empty.<p>Haskell&#x27;s `head` not is not an example of the type system being unsound (I stress this point because we&#x27;ve been talking about type system soundness, not something-else-soundness).<p>From the view of the type system, `head` is perfectly sound: if the list is empty, the resulting value is ⊥ (&quot;bottom&quot;). And ⊥ is an inhabitant of every type. Therefore, `head` returning ⊥ when given an empty list is perfectly fine. When you force ⊥ (i.e. use it <i>any</i> way whatsoever), an exception is thrown. See <a href="https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Bottom" rel="nofollow">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Bottom</a><p>This is very much <i>not</i> the same thing (or remotely analogous) to what we have in my TypeScript example. There, the code fails at runtime when I attempt to call `toLowerCase`, yes; what&#x27;s worse is the slightly different scenario where we succeed in calling something we shouldn&#x27;t:<p><pre><code>  class Person {
    name: string;
   
    constructor(name: string) {
      this.name = name;
    }
   
    kill() {
      console.log(&quot;Killing: &quot; + this.name);
    }
  }
  
  class Murderer extends Person { }
  
  class Innocent extends Person { }
  
  function populatePeopleFromDatabase(people: Array&lt;Innocent | Murderer&gt;): void {
      &#x2F;&#x2F; imagine this came from a real SQL query
      people.push(new Innocent(&quot;Bob&quot;));
  }
  
  
  function populateMurderersFromDatabase(people: Array&lt;Murderer&gt;): void {
      &#x2F;&#x2F; TODO(Aleck): come back and replace this with a query that only selects murderers.
      &#x2F;&#x2F;              i wanted to get the rest of the code in place, and this type checks,
      &#x2F;&#x2F;              so I&#x27;ll punt on this for now and come back later when I wrap my head
      &#x2F;&#x2F;              around the proper SQL.
      &#x2F;&#x2F;              we&#x27;re not actually using this anywhere just yet, so no biggie ¯\_(ツ)_&#x2F;¯
      populatePeopleFromDatabase(people);
  }
  
  &#x2F;&#x2F; ... some time later, Bob comes along and implements the murderer execution logic:
  const murderers: Array&lt;Murderer&gt; = [];
  populateMurderersFromDatabase(murderers);
  &#x2F;&#x2F; Bob is about to have a really shitty day:
  murderer.forEach((murderer) =&gt; murderer.kill());
</code></pre>
It is not possible to write an analogous example in Haskell using `head`.</div><br/></div></div></div></div></div></div><div id="41070615" class="c"><input type="checkbox" id="c-41070615" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067996">parent</a><span>|</span><a href="#41069387">prev</a><span>|</span><a href="#41069348">next</a><span>|</span><label class="collapse" for="c-41070615">[-]</label><label class="expand" for="c-41070615">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s no accepted definition of what an unsound type system is<p>Huh?<p>The cheeky answer would be that the definition here is the one the TypeScript documentation itself uses[1].<p>The useful answer is that there’s only one general definition that I’ve ever encountered: a type system is sound if no well-typed program encounters type errors during its execution. Importantly, that’s <i>not</i> a statement about the (static) type system in isolation: it’s tied to the language’s dynamic semantics.<p>The tricky part, of course, is defining “type error”. In theoretical contexts, it’s common to just not define any evaluation rules at all for outwardly ill-typed things (negating a list, say), thus the common phrasing that no well-typed program must get stuck (unable to evaluate further). In practical statically-typed languages, there are on occasion cases that are defined not to be type errors essentially by fiat, such as null pointer accesses in Java, or escape hatches, such as unsafeCoerce in practical implementations of Haskell.<p>Of course, ECMAScript just defines behaviour for <i>everything</i> (except violating invariants in proxy handlers, in which case, lol, good luck), so arguably every static type system for it is sound, even one that allows var foo: string = 42. Obviously that’s not a helpful point of view. I think it’s reasonable to say that whatever we count as erroneous situations must at the very least include all occurrences of ReferenceError and TypeError.<p>TypeScript prevents most of them, which is good enough for its linting use case, when the worst possible result is that a buggy program crashes. It would definitely not be good enough for Closure Compiler’s minification use case, when the worst possible result is that a correct program gets silently miscompiled (misminified?).<p>[1] <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;type-compatibility.html#a-note-on-soundness" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;type-compatibil...</a></div><br/></div></div><div id="41069348" class="c"><input type="checkbox" id="c-41069348" checked=""/><div class="controls bullet"><span class="by">sharlos201068</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067996">parent</a><span>|</span><a href="#41070615">prev</a><span>|</span><a href="#41067538">next</a><span>|</span><label class="collapse" for="c-41069348">[-]</label><label class="expand" for="c-41069348">[8 more]</label></div><br/><div class="children"><div class="content">That’s not correct, there’s several ways the actual type of a value differs from what typescript thinks it is. But soundness isn’t a goal of typescript.</div><br/><div id="41069706" class="c"><input type="checkbox" id="c-41069706" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069348">parent</a><span>|</span><a href="#41067538">next</a><span>|</span><label class="collapse" for="c-41069706">[-]</label><label class="expand" for="c-41069706">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s maybe useful to note in this discussion for some that &quot;soundness&quot; of a type system is a bit of technical&#x2F;theoretical jargon that in some cases has specific mathematical definitions and so &quot;unsound&quot; often sounds harsher (connotatively) than it means. The vast majority of type systems are &quot;unsound&quot; for very pragmatic reasons. Developers don&#x27;t often care to work in a &quot;sound&quot; type systems. Some of the &quot;most sound&quot; type systems we&#x27;ve collectively managed to build are in things like theorem provers and type assertion systems that some of us don&#x27;t always even consider useful for &quot;real&quot; software development.<p>Typescript is a bit more unsound than most because of the escape hatch `any` and because of the (intentional) disconnect between compiler and runtime environment. Even though &quot;unsound&quot; sounds like a bad thing to be, it&#x27;s a big part of why Typescript is so successful.</div><br/><div id="41076595" class="c"><input type="checkbox" id="c-41076595" checked=""/><div class="controls bullet"><span class="by">price</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069706">parent</a><span>|</span><a href="#41076651">next</a><span>|</span><label class="collapse" for="c-41076595">[-]</label><label class="expand" for="c-41076595">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing arcane or particularly theoretical about soundness. It means that if you have an expression of some type, and at runtime the expression evaluates to a value, the value will always be of that type.<p>For example if you have a Java expression of type MyClass, and it gets evaluated, then it must either throw (so that it doesn&#x27;t produce any value) or produce a value of type MyClass: either an instance of MyClass, or of one of its subclasses, or null. It will never produce an instance of some other class, or an int, or anything else that isn&#x27;t a valid value for the type MyClass.<p>In addition to helping human readers reason about the code, a sound type system is a big deal for a compiler: it makes it possible to compile the code AOT to fast native code, without inserting a bunch of runtime checks and dynamic dispatching to handle the fact that inevitably some of the types (but you don&#x27;t know which) are wrong.<p>The compiler implications are what motivated the Dart language&#x27;s developers to migrate from an unsound to a sound type system a few years ago:
<a href="https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;type-system#the-benefits-of-soundness" rel="nofollow">https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;type-system#the-benefits-of-soundn...</a>
so that they could compile Flutter apps AOT.  This didn&#x27;t require anyone to make their code resemble what you&#x27;d do in a theorem prover — it just means that, for example, all casts are checked, so that they throw if the value doesn&#x27;t turn out to have the type the cast wants to return.<p>TypeScript is unsound because when you have an expression with a type, that tells you nothing at all for sure about what the value of the expression can be — it might be of that type, or it might be anything else. It&#x27;s still valuable because you can maintain a codebase where the types are <i>mostly</i> accurate, and that&#x27;s enough to help a lot in reading and maintaining the code.</div><br/><div id="41076626" class="c"><input type="checkbox" id="c-41076626" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41076595">parent</a><span>|</span><a href="#41076651">next</a><span>|</span><label class="collapse" for="c-41076626">[-]</label><label class="expand" for="c-41076626">[2 more]</label></div><br/><div class="children"><div class="content">The key factor is that typescript is not a language, it is a notation system for a completely independent language.<p>The purpose of typescript is usefully type as much javascript as possible, to do both this and have a sound type system it would require to change javascript.</div><br/><div id="41076755" class="c"><input type="checkbox" id="c-41076755" checked=""/><div class="controls bullet"><span class="by">price</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41076626">parent</a><span>|</span><a href="#41076651">next</a><span>|</span><label class="collapse" for="c-41076755">[-]</label><label class="expand" for="c-41076755">[1 more]</label></div><br/><div class="children"><div class="content">Definitely to get the most ergonomic programming experience, while also having a sound type system, you&#x27;d need to change some of the semantics of the language.<p>A prime example is that if you index into an array of type `T[]`, JS semantics mean the value you get back could be undefined as well as a `T`. So to describe existing JS semantics in a sound type system, the type would have to be `T | undefined`, which would be a big pain. Alternatively you could make the type `T` and have that be sound, but only if you make the runtime semantics be that an out-of-bounds access throws instead of returning undefined.</div><br/></div></div></div></div></div></div><div id="41076651" class="c"><input type="checkbox" id="c-41076651" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069706">parent</a><span>|</span><a href="#41076595">prev</a><span>|</span><a href="#41067538">next</a><span>|</span><label class="collapse" for="c-41076651">[-]</label><label class="expand" for="c-41076651">[3 more]</label></div><br/><div class="children"><div class="content">any and unknown are perfectly sound, if they were the only types then soundness would be automatic.<p>The problem is that you can arbitrarily narrow types (and any can narrow to any type) eg: <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?#code&#x2F;DYUwLgBAzg9grgOwCYC4IEMEE8IF4IDaARABIjDAxEC6A3ALABQokIATmzG2gBQAeaALLoADgB4oYNgEsEAcwA0EBHAC2AI3YA+AJR4tEAN4QAxmnUwYoTBAC+eQqXKUaDZuAiJYiVBH5DRCSlZRWU1TTZdfSNTc0trBDsHYjIKKmoMKAxsNxZPBG9kACYHHhTndMzsrD10LJ5-CGFxSRl5JRUNbT1cA2MzCAsrEBtbHTcmIA" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?#code&#x2F;DYUwLgBAzg9grgOwC...</a></div><br/><div id="41076727" class="c"><input type="checkbox" id="c-41076727" checked=""/><div class="controls bullet"><span class="by">price</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41076651">parent</a><span>|</span><a href="#41067538">next</a><span>|</span><label class="collapse" for="c-41076727">[-]</label><label class="expand" for="c-41076727">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true but misleading: if &quot;any&quot; and &quot;unknown&quot; were the only types, then &quot;any&quot; would be indistinguishable from &quot;unknown&quot; and you&#x27;d really have just the one type. Which makes the type system sound because it doesn&#x27;t say anything.<p>If your type system has at least two types that aren&#x27;t the same as each other, then adding &quot;any&quot; makes it unsound right there. The essence of &quot;any&quot; is that it lets you take a value of one type and pretend it&#x27;s of any other type. Which is to say that &quot;any&quot; is basically the purified form of unsoundness.</div><br/><div id="41076940" class="c"><input type="checkbox" id="c-41076940" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41076727">parent</a><span>|</span><a href="#41067538">next</a><span>|</span><label class="collapse" for="c-41076940">[-]</label><label class="expand" for="c-41076940">[1 more]</label></div><br/><div class="children"><div class="content">a typing of any cannot be unsound because it is always correct, narrowing any can be unsound.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41067538" class="c"><input type="checkbox" id="c-41067538" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067475">parent</a><span>|</span><a href="#41067996">prev</a><span>|</span><a href="#41065370">next</a><span>|</span><label class="collapse" for="c-41067538">[-]</label><label class="expand" for="c-41067538">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically TS could… until it encounters an ‘any’ type in that code path, then it would have to give up.<p>But there are TSconfig options to ensure no use of any so with the right level of strictness it could happen.</div><br/></div></div></div></div><div id="41065370" class="c"><input type="checkbox" id="c-41065370" checked=""/><div class="controls bullet"><span class="by">wiktor-k</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065117">parent</a><span>|</span><a href="#41067475">prev</a><span>|</span><a href="#41069658">next</a><span>|</span><label class="collapse" for="c-41065370">[-]</label><label class="expand" for="c-41065370">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Something like `foo.bar[function]()` is perfectly valid JS,<p>A minor thing but `function` is a keyword in JS so technically it&#x27;s not a &quot;perfectly valid JS&quot;.</div><br/><div id="41065635" class="c"><input type="checkbox" id="c-41065635" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065370">parent</a><span>|</span><a href="#41069658">next</a><span>|</span><label class="collapse" for="c-41065635">[-]</label><label class="expand" for="c-41065635">[1 more]</label></div><br/><div class="children"><div class="content">Oh boy, just think functionName and it fits.</div><br/></div></div></div></div><div id="41069658" class="c"><input type="checkbox" id="c-41069658" checked=""/><div class="controls bullet"><span class="by">AprilArcus</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065117">parent</a><span>|</span><a href="#41065370">prev</a><span>|</span><a href="#41065270">next</a><span>|</span><label class="collapse" for="c-41069658">[-]</label><label class="expand" for="c-41069658">[1 more]</label></div><br/><div class="children"><div class="content">of course this created an interoperability nightmare with third party libraries, which irrevocably forked Google&#x27;s whole JS ecosystem from the community&#x27;s 20 years ago and turned their codebases into a miserable backwater.</div><br/></div></div></div></div><div id="41065270" class="c"><input type="checkbox" id="c-41065270" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064927">parent</a><span>|</span><a href="#41065117">prev</a><span>|</span><a href="#41067083">next</a><span>|</span><label class="collapse" for="c-41065270">[-]</label><label class="expand" for="c-41065270">[1 more]</label></div><br/><div class="children"><div class="content">Google’s Closure Library is fascinating too. It’s being retired, but if you want to build a rich text interface for email authoring that truly feels like Gmail, warts and all, you can just use a pre-compiled version of the library and follow <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;closure-library&#x2F;blob&#x2F;master&#x2F;closure&#x2F;goog&#x2F;demos&#x2F;editor&#x2F;editor.html">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;closure-library&#x2F;blob&#x2F;master&#x2F;closur...</a> within a more modern codebase!</div><br/></div></div><div id="41067083" class="c"><input type="checkbox" id="c-41067083" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064927">parent</a><span>|</span><a href="#41065270">prev</a><span>|</span><a href="#41064952">next</a><span>|</span><label class="collapse" for="c-41067083">[-]</label><label class="expand" for="c-41067083">[2 more]</label></div><br/><div class="children"><div class="content">Closure is almost a forgotten child of Google now. Does not even fully support ES2022 as of today. We are working hard to get rid of it completely. Surprise, lots of important projects still rely on it today.</div><br/><div id="41069953" class="c"><input type="checkbox" id="c-41069953" checked=""/><div class="controls bullet"><span class="by">jazzypants</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067083">parent</a><span>|</span><a href="#41064952">next</a><span>|</span><label class="collapse" for="c-41069953">[-]</label><label class="expand" for="c-41069953">[1 more]</label></div><br/><div class="children"><div class="content">This is true. For instance, React still uses Closure compiler in their build process.</div><br/></div></div></div></div><div id="41064952" class="c"><input type="checkbox" id="c-41064952" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064927">parent</a><span>|</span><a href="#41067083">prev</a><span>|</span><a href="#41069935">next</a><span>|</span><label class="collapse" for="c-41064952">[-]</label><label class="expand" for="c-41064952">[4 more]</label></div><br/><div class="children"><div class="content">Oh, Closure Compiler is such a throwback. I still remember staring at the project page on Google Code. Isn&#x27;t it like two decades old or even older by this point? Is it still alive?</div><br/><div id="41067122" class="c"><input type="checkbox" id="c-41067122" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064952">parent</a><span>|</span><a href="#41065405">next</a><span>|</span><label class="collapse" for="c-41067122">[-]</label><label class="expand" for="c-41067122">[1 more]</label></div><br/><div class="children"><div class="content">This can give you some hints of the current status of closure compiler:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;closure-compiler&#x2F;issues&#x2F;2731">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;closure-compiler&#x2F;issues&#x2F;2731</a><p>I happen to know this because we have some old projects that depend on this and are working hard to get rid of the dependency.<p>I wish Google either updates it or just mark the whole thing deprecated -- the world has already moved on anyway. Relating this to Google&#x27;s recent cost cutting, and seeing some other Google&#x27;s open source projects more or less getting abandoned, I have to say that today&#x27;s Google is definitely not the same company from two decades ago.</div><br/></div></div><div id="41065405" class="c"><input type="checkbox" id="c-41065405" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064952">parent</a><span>|</span><a href="#41067122">prev</a><span>|</span><a href="#41065035">next</a><span>|</span><label class="collapse" for="c-41065405">[-]</label><label class="expand" for="c-41065405">[1 more]</label></div><br/><div class="children"><div class="content">Closure is still used in Emscripten to optimize the generated Javascript shim file.</div><br/></div></div><div id="41065035" class="c"><input type="checkbox" id="c-41065035" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064952">parent</a><span>|</span><a href="#41065405">prev</a><span>|</span><a href="#41069935">next</a><span>|</span><label class="collapse" for="c-41065035">[-]</label><label class="expand" for="c-41065035">[1 more]</label></div><br/><div class="children"><div class="content">The compiler itself lives on but it works with TypeScript now rather than the JSDoc comments style approach which is officially EOL AFAIK.</div><br/></div></div></div></div></div></div><div id="41069935" class="c"><input type="checkbox" id="c-41069935" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064736">parent</a><span>|</span><a href="#41064927">prev</a><span>|</span><a href="#41067783">next</a><span>|</span><label class="collapse" for="c-41069935">[-]</label><label class="expand" for="c-41069935">[5 more]</label></div><br/><div class="children"><div class="content">There was no real competition, Flow was a practical internal tool with 0 marketing budget. Typescript is typical MS 3E strategy with a huge budget. Needless to say, Flow is much more practical and less intrusive, but marketing budget captured all the newbie devs.</div><br/><div id="41070159" class="c"><input type="checkbox" id="c-41070159" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069935">parent</a><span>|</span><a href="#41074843">next</a><span>|</span><label class="collapse" for="c-41070159">[-]</label><label class="expand" for="c-41070159">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>There was no real competition</i><p>There was: <i>Anders Hejlsberg and Lars Bak: TypeScript, JavaScript, and Dart</i> <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5AqbCQuK0gM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5AqbCQuK0gM</a> (2013).<p>Summary: <a href="https:&#x2F;&#x2F;g.co&#x2F;gemini&#x2F;share&#x2F;a60c3897bae1" rel="nofollow">https:&#x2F;&#x2F;g.co&#x2F;gemini&#x2F;share&#x2F;a60c3897bae1</a> &#x2F; <a href="https:&#x2F;&#x2F;archive.is&#x2F;qJ1wA" rel="nofollow">https:&#x2F;&#x2F;archive.is&#x2F;qJ1wA</a></div><br/></div></div><div id="41074843" class="c"><input type="checkbox" id="c-41074843" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069935">parent</a><span>|</span><a href="#41070159">prev</a><span>|</span><a href="#41071818">next</a><span>|</span><label class="collapse" for="c-41074843">[-]</label><label class="expand" for="c-41074843">[2 more]</label></div><br/><div class="children"><div class="content">Have to disagree. I tried Flow irrespective of marketing and didn’t think it was polished. Kept running into type situations that the language didn’t support well. Kept bugging out in my IDE. Had no elegance.</div><br/><div id="41076563" class="c"><input type="checkbox" id="c-41076563" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41074843">parent</a><span>|</span><a href="#41071818">next</a><span>|</span><label class="collapse" for="c-41076563">[-]</label><label class="expand" for="c-41076563">[1 more]</label></div><br/><div class="children"><div class="content">When I last used it, as a type system it was much better than TypeScript. A lot of flow features now exist in TypeScript though too.<p>One big annoyance with Flow I had is like you said: unpolished tooling. Another was frequent breaking changes (I don&#x27;t hold it against them too much, it was 0.x software after all)<p>Also because features diverged, you had to maintain type defs for multiple versions of flow for for multiple library versions. And then at one point, they also decided to convert internal errors to any types instead of displaying the error. That was the last straw for me, especially since I maintained a few flow type defs. I spent _so_ much of _my_ time just on type def maintenance for open source libraries already, with the any decay I like flying blind too. So I just switched to TS with its interior type system: it was good enough and others maintained library typedefs for me. But now the type systems are much more closely aligned (unless flow drifted), so switching to TS paid off in the end.</div><br/></div></div></div></div><div id="41071818" class="c"><input type="checkbox" id="c-41071818" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069935">parent</a><span>|</span><a href="#41074843">prev</a><span>|</span><a href="#41067783">next</a><span>|</span><label class="collapse" for="c-41071818">[-]</label><label class="expand" for="c-41071818">[1 more]</label></div><br/><div class="children"><div class="content">TypeScript was really <i>really</i> easy to get started with back in the day. It allows for incremental correctness, has good docs, and good tooling. On top of that a lot of beginner React tutorials started out with TypeScript, which onboarded a lot of new engineers to the TS ecosystem, and got them used to the niceties of TS (e.g. import syntax).</div><br/></div></div></div></div><div id="41067783" class="c"><input type="checkbox" id="c-41067783" checked=""/><div class="controls bullet"><span class="by">simplify</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064736">parent</a><span>|</span><a href="#41069935">prev</a><span>|</span><a href="#41068933">next</a><span>|</span><label class="collapse" for="c-41067783">[-]</label><label class="expand" for="c-41067783">[4 more]</label></div><br/><div class="children"><div class="content">Facebook never gave Flow enough resources, whereas Microsoft has had 10+ devs on TypeScript for a long time.</div><br/><div id="41069989" class="c"><input type="checkbox" id="c-41069989" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067783">parent</a><span>|</span><a href="#41068933">next</a><span>|</span><label class="collapse" for="c-41069989">[-]</label><label class="expand" for="c-41069989">[3 more]</label></div><br/><div class="children"><div class="content">Because Flow is an actual developer tool, not a rent-seeking landgrab with a marketing budget.</div><br/><div id="41072390" class="c"><input type="checkbox" id="c-41072390" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069989">parent</a><span>|</span><a href="#41073433">next</a><span>|</span><label class="collapse" for="c-41072390">[-]</label><label class="expand" for="c-41072390">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know what axe you have to grind, but TypeScript is firmly in the hands of the community now. There’s not much Microsoft could do to change that. In what way would it be rent-seeking?</div><br/></div></div><div id="41073433" class="c"><input type="checkbox" id="c-41073433" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069989">parent</a><span>|</span><a href="#41072390">prev</a><span>|</span><a href="#41068933">next</a><span>|</span><label class="collapse" for="c-41073433">[-]</label><label class="expand" for="c-41073433">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re paying rent for typescript, you&#x27;re doing it wrong.</div><br/></div></div></div></div></div></div><div id="41068933" class="c"><input type="checkbox" id="c-41068933" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064736">parent</a><span>|</span><a href="#41067783">prev</a><span>|</span><a href="#41076826">next</a><span>|</span><label class="collapse" for="c-41068933">[-]</label><label class="expand" for="c-41068933">[16 more]</label></div><br/><div class="children"><div class="content">Flow tries to be sound and that makes it infinitely better than TS where the creators openly threw the idea of soundness out the window from the very beginning.</div><br/><div id="41070470" class="c"><input type="checkbox" id="c-41070470" checked=""/><div class="controls bullet"><span class="by">dwb</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068933">parent</a><span>|</span><a href="#41069478">next</a><span>|</span><label class="collapse" for="c-41070470">[-]</label><label class="expand" for="c-41070470">[1 more]</label></div><br/><div class="children"><div class="content">This is a point in Flow&#x27;s favour. However! Seven years ago or so, when TypeScript was quite young and seemed inferior to Flow in almost all respects, I chose Flow for a large project. Since then, I spent inordinate amounts of time updating our code for the latest breaking Flow version, until one came along that would have taken too long to update for, so we just stayed on that one. We migrated to TypeScript a little while back and the practical effect has been much more and effective type checking through more coverage and support. TypeScript may be unsound, but it works better over all. We turn on the vast majority of the safety features to mitigate the unsoundness. And it&#x27;s developed by a team that are beholden to a large and vibrant user base, so any changes are generally well-managed. There&#x27;s no contest, really.</div><br/></div></div><div id="41069478" class="c"><input type="checkbox" id="c-41069478" checked=""/><div class="controls bullet"><span class="by">ahuth</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068933">parent</a><span>|</span><a href="#41070470">prev</a><span>|</span><a href="#41069992">next</a><span>|</span><label class="collapse" for="c-41069478">[-]</label><label class="expand" for="c-41069478">[1 more]</label></div><br/><div class="children"><div class="content">TS made the choice to be “just JS” + types, and lean into JS-isms.<p>Both choices are reasonable ones to make. Flow has some really cool stuff, and works great for a lot of people.<p>There’s no denying, though, that there’s TS has done something right (even if you personally dislike it)</div><br/></div></div><div id="41069992" class="c"><input type="checkbox" id="c-41069992" checked=""/><div class="controls bullet"><span class="by">idlephysicist</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068933">parent</a><span>|</span><a href="#41069478">prev</a><span>|</span><a href="#41069037">next</a><span>|</span><label class="collapse" for="c-41069992">[-]</label><label class="expand" for="c-41069992">[11 more]</label></div><br/><div class="children"><div class="content">Can you explain what you mean when you say &quot;to be sound&quot;?</div><br/><div id="41076462" class="c"><input type="checkbox" id="c-41076462" checked=""/><div class="controls bullet"><span class="by">price</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069992">parent</a><span>|</span><a href="#41070125">next</a><span>|</span><label class="collapse" for="c-41076462">[-]</label><label class="expand" for="c-41076462">[1 more]</label></div><br/><div class="children"><div class="content">When a language&#x27;s type system is sound, that means that if you have an expression with type &quot;string&quot;, then when you run the program the expression&#x27;s value will only ever be a string and never some other sort of value.<p>Or stated more abstractly: if an expression has type T, and at runtime the expression evaluates to a value v, then v has type T.<p>The language can still have runtime errors, like if you try to access an array out of bounds. The key is that such operations have to give an error — like by throwing, so that the expression doesn&#x27;t evaluate to any value at all — rather than returning a value that doesn&#x27;t fit the type.<p>Both TypeScript and Flow are unsound, because an expression with type &quot;string&quot; can always turn out to evaluate to null or a number or an object or anything else.  Flow had the ambition to be sound, which is honorable but they never accomplished it. TypeScript announced up front that they didn&#x27;t care about soundness:
<a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;type-compatibility.html#a-note-on-soundness" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;type-compatibil...</a><p>Soundness is valuable because it makes it possible to look at the types and reason about the program using them. An unsound type-checker like TypeScript or Flow can still be very useful to human readers if <i>most</i> of the types in a codebase are accurate, but you always have to keep that asterisk in the back of your head.<p>One very concrete consequence of soundness that it makes it possible to compile the code to fast native code. That&#x27;s what motivated Dart a few years ago to migrate from an unsound type system to a sound one:
<a href="https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;type-system" rel="nofollow">https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;type-system</a>
so that it could AOT-compile Flutter apps for speed.</div><br/></div></div><div id="41070125" class="c"><input type="checkbox" id="c-41070125" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069992">parent</a><span>|</span><a href="#41076462">prev</a><span>|</span><a href="#41069037">next</a><span>|</span><label class="collapse" for="c-41070125">[-]</label><label class="expand" for="c-41070125">[9 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an example of TypeScript failing to be sound - it should give a type error but it doesn&#x27;t. I believe Flow does indeed give a type error in this situation:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41069695">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41069695</a></div><br/><div id="41073425" class="c"><input type="checkbox" id="c-41073425" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41070125">parent</a><span>|</span><a href="#41069037">next</a><span>|</span><label class="collapse" for="c-41073425">[-]</label><label class="expand" for="c-41073425">[8 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to go even that far to find unsoundness in flow.<p><pre><code>    const arr = [&quot;abcd&quot;];
    const str = arr[1];
    const num = str.length; &#x2F;&#x2F; this throws
    console.log(num);
</code></pre>
For me, typescript is a pretty good balance.</div><br/><div id="41074955" class="c"><input type="checkbox" id="c-41074955" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41073425">parent</a><span>|</span><a href="#41074225">next</a><span>|</span><label class="collapse" for="c-41074955">[-]</label><label class="expand" for="c-41074955">[2 more]</label></div><br/><div class="children"><div class="content">I think this is not a very good example. Not only does it also throw in TS, but it even throws in Haskell which is pretty much the poster boy for sound type systems.<p>This isn&#x27;t a type error unless your type system is also encoding lengths, but most type systems aren&#x27;t going to do that and leave it to the runtime (I suspect the halting problem makes a general solution impossible).<p><pre><code>    main = putStrLn ([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]!!4)</code></pre></div><br/><div id="41075153" class="c"><input type="checkbox" id="c-41075153" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41074955">parent</a><span>|</span><a href="#41074225">next</a><span>|</span><label class="collapse" for="c-41075153">[-]</label><label class="expand" for="c-41075153">[1 more]</label></div><br/><div class="children"><div class="content">Yes it throws in typescript.  Typescript isn&#x27;t the the language chasing soundness at any cost.
This just illustrates the futility of chasing soundness.<p>Soundness is good as long as the type-checking benefit is worth the cost of the constraints in the language.
If the poster child for soundness isn&#x27;t able to account for this very simple and common scenario, then nothing will actually be able to deliever full soundness.<p>It&#x27;s just a question of how far down the spectrum you&#x27;re willing to go.  Pure js is too unsound for my taste.  Haskell is too constrained for my taste.
You might come to a different conclusion, but for me, typescript is a good balance.</div><br/></div></div></div></div><div id="41074225" class="c"><input type="checkbox" id="c-41074225" checked=""/><div class="controls bullet"><span class="by">fabiospampinato</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41073425">parent</a><span>|</span><a href="#41074955">prev</a><span>|</span><a href="#41069037">next</a><span>|</span><label class="collapse" for="c-41074225">[-]</label><label class="expand" for="c-41074225">[5 more]</label></div><br/><div class="children"><div class="content">Wait, so Flow is not actually sound and their website is lying? Or do they have some &quot;technically correct&quot; definition of &quot;sound&quot; that takes stuff like that into account?</div><br/><div id="41076784" class="c"><input type="checkbox" id="c-41076784" checked=""/><div class="controls bullet"><span class="by">price</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41074225">parent</a><span>|</span><a href="#41074272">next</a><span>|</span><label class="collapse" for="c-41076784">[-]</label><label class="expand" for="c-41076784">[1 more]</label></div><br/><div class="children"><div class="content">Flow is not sound. They have the ambition of trying to be sound (which I appreciate), but they&#x27;ve never accomplished it.<p>I went looking for where on their website they claim to be sound. There&#x27;s definitely some misleading wording here:
<a href="https:&#x2F;&#x2F;flow.org&#x2F;en&#x2F;docs&#x2F;lang&#x2F;types-and-expressions&#x2F;#toc-soundness-and-completeness" rel="nofollow">https:&#x2F;&#x2F;flow.org&#x2F;en&#x2F;docs&#x2F;lang&#x2F;types-and-expressions&#x2F;#toc-sou...</a>
but if you read the whole section, it ends up also acknowledging that it&#x27;s not entirely sound.</div><br/></div></div><div id="41074272" class="c"><input type="checkbox" id="c-41074272" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41074225">parent</a><span>|</span><a href="#41076784">prev</a><span>|</span><a href="#41074956">next</a><span>|</span><label class="collapse" for="c-41074272">[-]</label><label class="expand" for="c-41074272">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea about the lawyerly technicalities, but you can try it yourself to verify what I&#x27;m saying.<p><a href="https:&#x2F;&#x2F;flow.org&#x2F;try&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flow.org&#x2F;try&#x2F;</a><p>Compare these two programs.<p><pre><code>    const arr = [&quot;abcd&quot;];
    const str = arr[1];
    const num = str.length; &#x2F;&#x2F; this throws at runtime

    const arr = [new Date];
    const dt = arr[1];
    const num = dt.length; &#x2F;&#x2F; fails to type check</code></pre></div><br/></div></div><div id="41074956" class="c"><input type="checkbox" id="c-41074956" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41074225">parent</a><span>|</span><a href="#41074272">prev</a><span>|</span><a href="#41069037">next</a><span>|</span><label class="collapse" for="c-41074956">[-]</label><label class="expand" for="c-41074956">[2 more]</label></div><br/><div class="children"><div class="content">Even haskell will generate a runtime error for an out-of-bounds index<p><pre><code>    main = putStrLn ([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]!!4)</code></pre></div><br/><div id="41075180" class="c"><input type="checkbox" id="c-41075180" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41074956">parent</a><span>|</span><a href="#41069037">next</a><span>|</span><label class="collapse" for="c-41075180">[-]</label><label class="expand" for="c-41075180">[1 more]</label></div><br/><div class="children"><div class="content">This is different.  Neither flow, typescript, nor javascript generate a runtime error for an out of bounds index.  It&#x27;s explicitly allowed by the language.<p>The result of the an OOB access of an array is <i>specified</i> to be `undefined`.  The throw only happens later when the value is treated as the wrong type.<p>I don&#x27;t consider a runtime error to be a failure of the type system for OOB array access.  But in javascript, it&#x27;s explicitly allowed by specification.  It&#x27;s a failure of any type system that fails to account for this specified behavior in the language.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41069037" class="c"><input type="checkbox" id="c-41069037" checked=""/><div class="controls bullet"><span class="by">machiaweliczny</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068933">parent</a><span>|</span><a href="#41069992">prev</a><span>|</span><a href="#41069215">next</a><span>|</span><label class="collapse" for="c-41069037">[-]</label><label class="expand" for="c-41069037">[1 more]</label></div><br/><div class="children"><div class="content">But in practice is was crap</div><br/></div></div></div></div></div></div><div id="41076826" class="c"><input type="checkbox" id="c-41076826" checked=""/><div class="controls bullet"><span class="by">schwartzworld</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41064736">prev</a><span>|</span><a href="#41065301">next</a><span>|</span><label class="collapse" for="c-41076826">[-]</label><label class="expand" for="c-41076826">[1 more]</label></div><br/><div class="children"><div class="content">Incidentally, this is how the ecmascript proposal for introducing types to JS would work by default. The runtime would ignore the types when running code. If you want type checking, you’d have to reach for external tooling.</div><br/></div></div><div id="41065301" class="c"><input type="checkbox" id="c-41065301" checked=""/><div class="controls bullet"><span class="by">Doxin</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41076826">prev</a><span>|</span><a href="#41066034">next</a><span>|</span><label class="collapse" for="c-41065301">[-]</label><label class="expand" for="c-41065301">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In Python, I&#x27;ve even heard of people writing types in source code but never checking them, essentially using type hints as a more convenient syntax for comments.<p>Note that there&#x27;s IDEs that&#x27;ll use type hints to improve autocomplete and the like too, so even when not checking types it can make sense to add them in some places.</div><br/></div></div><div id="41066034" class="c"><input type="checkbox" id="c-41066034" checked=""/><div class="controls bullet"><span class="by">dobladov</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41065301">prev</a><span>|</span><a href="#41066307">next</a><span>|</span><label class="collapse" for="c-41066034">[-]</label><label class="expand" for="c-41066034">[20 more]</label></div><br/><div class="children"><div class="content">You can have this now adding types with JSDoc and validating them with typescript without compiling, you get faster builds and code that works everywhere without magic or need to strip anything else than comments.<p>The biggest pain point of using JSDoc at least for me was the import syntax, this has changed since Typescript 5.5, and it&#x27;s now not an issue anymore.</div><br/><div id="41076089" class="c"><input type="checkbox" id="c-41076089" checked=""/><div class="controls bullet"><span class="by">eezing</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066034">parent</a><span>|</span><a href="#41066120">next</a><span>|</span><label class="collapse" for="c-41076089">[-]</label><label class="expand" for="c-41076089">[1 more]</label></div><br/><div class="children"><div class="content">Good for annotating js files here and there, but lousy dx.</div><br/></div></div><div id="41066120" class="c"><input type="checkbox" id="c-41066120" checked=""/><div class="controls bullet"><span class="by">murmansk</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066034">parent</a><span>|</span><a href="#41076089">prev</a><span>|</span><a href="#41066750">next</a><span>|</span><label class="collapse" for="c-41066120">[-]</label><label class="expand" for="c-41066120">[14 more]</label></div><br/><div class="children"><div class="content">For god&#x27;s sake, please stop shilling JSDoc as a TS replacement. It is not. If you encounter anything more complicated than `A extends B`, JSDoc is a pain in the ass of huge intensity to write and maintain.</div><br/><div id="41067524" class="c"><input type="checkbox" id="c-41067524" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066120">parent</a><span>|</span><a href="#41066289">next</a><span>|</span><label class="collapse" for="c-41067524">[-]</label><label class="expand" for="c-41067524">[2 more]</label></div><br/><div class="children"><div class="content">I’ve had a lot of success combining JSDoc JS with .d.ts files. It’s kind of a Frankenstein philosophically (one half using TS and one half not) but the actual experience is great: still a very robust type system but no transpiling required.<p>In a world where ES modules are natively supported everywhere it’s a joy to have a project “just work” with zero build steps. It’s not worth it in a large project where you’re already using five other plugins in your build script anyway but for small projects it’s a breath of fresh air.</div><br/><div id="41072750" class="c"><input type="checkbox" id="c-41072750" checked=""/><div class="controls bullet"><span class="by">flanbiscuit</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067524">parent</a><span>|</span><a href="#41066289">next</a><span>|</span><label class="collapse" for="c-41072750">[-]</label><label class="expand" for="c-41072750">[1 more]</label></div><br/><div class="children"><div class="content">I do this as well. JSDoc is great for simple definitions, but as soon as you want to do something more complicated (generics, operators, access types, etc) you get stuck. The .d.ts are ignored because you&#x27;re only importing them within JSDoc comments.</div><br/></div></div></div></div><div id="41066289" class="c"><input type="checkbox" id="c-41066289" checked=""/><div class="controls bullet"><span class="by">dobladov</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066120">parent</a><span>|</span><a href="#41067524">prev</a><span>|</span><a href="#41069554">next</a><span>|</span><label class="collapse" for="c-41066289">[-]</label><label class="expand" for="c-41066289">[4 more]</label></div><br/><div class="children"><div class="content">You should write complex types in interfaces files where they belong, and there&#x27;s full typescript support.<p>I use this approach professionally in teams with many developers, and it works better for us than native TS.
Honestly give it a try, I was skeptical at first.</div><br/><div id="41067060" class="c"><input type="checkbox" id="c-41067060" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066289">parent</a><span>|</span><a href="#41069554">next</a><span>|</span><label class="collapse" for="c-41067060">[-]</label><label class="expand" for="c-41067060">[3 more]</label></div><br/><div class="children"><div class="content">In general JSDoc is just much more verbose and has more friction, even outside complex types. I recently finished a small (20 files&#x2F;3000 lines), strictly typed JS project using full JSDoc, and I really miss the experience of using the real TypeScript syntax. Pain points: annotating function parameter types (especially anonymous function), intermediate variable type and automatic type-only import, these are the ones that I can remember. Yes you can get 99% there with JSDoc and .d.ts files, but that&#x27;s painful.</div><br/><div id="41068560" class="c"><input type="checkbox" id="c-41068560" checked=""/><div class="controls bullet"><span class="by">dobladov</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067060">parent</a><span>|</span><a href="#41069554">next</a><span>|</span><label class="collapse" for="c-41068560">[-]</label><label class="expand" for="c-41068560">[2 more]</label></div><br/><div class="children"><div class="content">I use snippets to write those, yes it&#x27;s more verbose there&#x27;s not denying that.<p>For me the advantages of just having JS files and not worrying about more complex source-maps, build files, etc definitely makes it worth it.</div><br/><div id="41072832" class="c"><input type="checkbox" id="c-41072832" checked=""/><div class="controls bullet"><span class="by">FractalHQ</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068560">parent</a><span>|</span><a href="#41069554">next</a><span>|</span><label class="collapse" for="c-41072832">[-]</label><label class="expand" for="c-41072832">[1 more]</label></div><br/><div class="children"><div class="content">Source maps and build files are automatically generated when bundling which you need to do with or without typescript… so this argument always confuses me.  There is no tangible downside in my experience.. either way it’s just typing “pnpm build”.</div><br/></div></div></div></div></div></div></div></div><div id="41069554" class="c"><input type="checkbox" id="c-41069554" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066120">parent</a><span>|</span><a href="#41066289">prev</a><span>|</span><a href="#41067920">next</a><span>|</span><label class="collapse" for="c-41069554">[-]</label><label class="expand" for="c-41069554">[2 more]</label></div><br/><div class="children"><div class="content">JSDoc is also helpful in dealing with multiple argument option types for a function or constructor, which won&#x27;t show in TS alone.</div><br/><div id="41070230" class="c"><input type="checkbox" id="c-41070230" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069554">parent</a><span>|</span><a href="#41067920">next</a><span>|</span><label class="collapse" for="c-41070230">[-]</label><label class="expand" for="c-41070230">[1 more]</label></div><br/><div class="children"><div class="content">You can do it in TS.<p><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;functions.html#function-overloads" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;functions.htm...</a></div><br/></div></div></div></div><div id="41067920" class="c"><input type="checkbox" id="c-41067920" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066120">parent</a><span>|</span><a href="#41069554">prev</a><span>|</span><a href="#41068499">next</a><span>|</span><label class="collapse" for="c-41067920">[-]</label><label class="expand" for="c-41067920">[2 more]</label></div><br/><div class="children"><div class="content">Jsdoc is honestly fine for simple and smaller projects. But yeah, it’s definitely not nearly as expensive while being anywhere as succinct.</div><br/><div id="41070429" class="c"><input type="checkbox" id="c-41070429" checked=""/><div class="controls bullet"><span class="by">yard2010</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067920">parent</a><span>|</span><a href="#41068499">next</a><span>|</span><label class="collapse" for="c-41070429">[-]</label><label class="expand" for="c-41070429">[1 more]</label></div><br/><div class="children"><div class="content">JSDoc is for docs, TypeScript is a static type checker. How can these tools be used interchangeably?</div><br/></div></div></div></div><div id="41066174" class="c"><input type="checkbox" id="c-41066174" checked=""/><div class="controls bullet"><span class="by">adhamsalama</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066120">parent</a><span>|</span><a href="#41068499">prev</a><span>|</span><a href="#41066750">next</a><span>|</span><label class="collapse" for="c-41066174">[-]</label><label class="expand" for="c-41066174">[2 more]</label></div><br/><div class="children"><div class="content">You can write TypeScript types in JSDoc.</div><br/><div id="41067055" class="c"><input type="checkbox" id="c-41067055" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066174">parent</a><span>|</span><a href="#41066750">next</a><span>|</span><label class="collapse" for="c-41067055">[-]</label><label class="expand" for="c-41067055">[1 more]</label></div><br/><div class="children"><div class="content">You can’t write complex TypeScript types in JSDoc, which is what GP said.<p>The moment you need to declare or extend a type you’re done, you have to do so in a separate .ts file. It would be <i>possible</i> to do so and import it in JSDoc, but as mentioned before it’s a huge PITA on top of the PITA that writing types can already be (e.g. function&#x2F;callbacks&#x2F;generics)</div><br/></div></div></div></div></div></div><div id="41066750" class="c"><input type="checkbox" id="c-41066750" checked=""/><div class="controls bullet"><span class="by">itsmeste</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066034">parent</a><span>|</span><a href="#41066120">prev</a><span>|</span><a href="#41067965">next</a><span>|</span><label class="collapse" for="c-41066750">[-]</label><label class="expand" for="c-41066750">[2 more]</label></div><br/><div class="children"><div class="content">I strongly agree, but JSDoc isn&#x27;t &quot;the cool thing&quot;. So it&#x27;s left to be used by us, who care (and read their docs).</div><br/><div id="41068484" class="c"><input type="checkbox" id="c-41068484" checked=""/><div class="controls bullet"><span class="by">llimllib</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066750">parent</a><span>|</span><a href="#41067965">next</a><span>|</span><label class="collapse" for="c-41068484">[-]</label><label class="expand" for="c-41068484">[1 more]</label></div><br/><div class="children"><div class="content">The auto-export of declared types was what killed it for me</div><br/></div></div></div></div><div id="41067965" class="c"><input type="checkbox" id="c-41067965" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066034">parent</a><span>|</span><a href="#41066750">prev</a><span>|</span><a href="#41066307">next</a><span>|</span><label class="collapse" for="c-41067965">[-]</label><label class="expand" for="c-41067965">[2 more]</label></div><br/><div class="children"><div class="content">JSDoc absolutely does not scale and allows for very limited type programming.<p>It&#x27;s fine on toy projects, and somewhat I would say, for 99% of users that don&#x27;t even know what a mapped or intersection type is.</div><br/><div id="41068565" class="c"><input type="checkbox" id="c-41068565" checked=""/><div class="controls bullet"><span class="by">mablopoule</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41067965">parent</a><span>|</span><a href="#41066307">next</a><span>|</span><label class="collapse" for="c-41068565">[-]</label><label class="expand" for="c-41068565">[1 more]</label></div><br/><div class="children"><div class="content">JSDoc does not scale, but some projects are just better when they aren&#x27;t scaled.<p>JSDoc is indeed fine on toy project, or in fact any project (even prod-ready ones) that doesn&#x27;t warrant the trouble of adding NPM packages and transpilation steps.<p>Although they are rare, those type of small, feature-complete codebases do exists.</div><br/></div></div></div></div></div></div><div id="41066307" class="c"><input type="checkbox" id="c-41066307" checked=""/><div class="controls bullet"><span class="by">black3r</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41066034">prev</a><span>|</span><a href="#41065075">next</a><span>|</span><label class="collapse" for="c-41066307">[-]</label><label class="expand" for="c-41066307">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If Node.js can run TypeScript files directly, then the TypeScript compiler won&#x27;t need to strip types and convert to JavaScript<p>Node.JS isn&#x27;t the only JS runtime. You&#x27;ll still have to compile TS to JS for browsers until all the browsers can run TS directly. Although some bundlers already do that by using a non-official compiler, like SWC (the one Node&#x27;s trying out for this feature).<p>&gt; In Python, I&#x27;ve even heard of people writing types in source code but never checking them, essentially using type hints as a more convenient syntax for comments.<p>It&#x27;s not just comments. It&#x27;s also, like the name &quot;type hint&quot; suggests, a hint for your IDE to display better autocomplete options.</div><br/><div id="41066589" class="c"><input type="checkbox" id="c-41066589" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41066307">parent</a><span>|</span><a href="#41065075">next</a><span>|</span><label class="collapse" for="c-41066589">[-]</label><label class="expand" for="c-41066589">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It&#x27;s not just comments. It&#x27;s also a hint for your IDE to display better autocomplete options.</i><p>Ah yes, autocomplete is another benefit of machine-readable type hints. OTOH there&#x27;s an argument that another IDE feature, informational pop-ups, would be better if they paid more attention to comments and less to type hints:<p><a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;a-more-useful-and-less-divisive-future-for-typing&#x2F;34225&#x2F;32" rel="nofollow">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;a-more-useful-and-less-divisive...</a></div><br/></div></div></div></div><div id="41065075" class="c"><input type="checkbox" id="c-41065075" checked=""/><div class="controls bullet"><span class="by">phartenfeller</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41066307">prev</a><span>|</span><a href="#41064760">next</a><span>|</span><label class="collapse" for="c-41065075">[-]</label><label class="expand" for="c-41065075">[12 more]</label></div><br/><div class="children"><div class="content">There is an EcmaScript proposal to go in that direction: <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations</a><p>I think this should be part of the language spec.</div><br/><div id="41065439" class="c"><input type="checkbox" id="c-41065439" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065075">parent</a><span>|</span><a href="#41064760">next</a><span>|</span><label class="collapse" for="c-41065439">[-]</label><label class="expand" for="c-41065439">[11 more]</label></div><br/><div class="children"><div class="content">Beyond ugly. They should just make TS official and be done with it.<p>E: I thought it was JSDoc proposal. Ignore the comment.</div><br/><div id="41065652" class="c"><input type="checkbox" id="c-41065652" checked=""/><div class="controls bullet"><span class="by">blovescoffee</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065439">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41065652">[-]</label><label class="expand" for="c-41065652">[7 more]</label></div><br/><div class="children"><div class="content">I did only briefly look at the proposal. What did you find so ugly?</div><br/><div id="41065824" class="c"><input type="checkbox" id="c-41065824" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065652">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41065824">[-]</label><label class="expand" for="c-41065824">[6 more]</label></div><br/><div class="children"><div class="content">I misread the proposal. Thought it was for JSDoc.</div><br/><div id="41068554" class="c"><input type="checkbox" id="c-41068554" checked=""/><div class="controls bullet"><span class="by">meiraleal</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065824">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41068554">[-]</label><label class="expand" for="c-41068554">[5 more]</label></div><br/><div class="children"><div class="content">Misread no, you didn&#x27;t read.</div><br/><div id="41069331" class="c"><input type="checkbox" id="c-41069331" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068554">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41069331">[-]</label><label class="expand" for="c-41069331">[4 more]</label></div><br/><div class="children"><div class="content">Yeah. I saw JSDoc and closed it, lol.</div><br/><div id="41071924" class="c"><input type="checkbox" id="c-41071924" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41069331">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41071924">[-]</label><label class="expand" for="c-41071924">[3 more]</label></div><br/><div class="children"><div class="content">Specifically, you saw the section titled &quot;Limits of JSDoc Type Annotations&quot;?</div><br/><div id="41072360" class="c"><input type="checkbox" id="c-41072360" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41071924">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41072360">[-]</label><label class="expand" for="c-41072360">[2 more]</label></div><br/><div class="children"><div class="content">Specifically, I saw JSDoc syntax and it triggered me so much that I closed the page and threw my phone away in disgust at absurdness of even the idea that someone thought having something like this unironically is a remotely good idea.</div><br/><div id="41072854" class="c"><input type="checkbox" id="c-41072854" checked=""/><div class="controls bullet"><span class="by">FractalHQ</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41072360">parent</a><span>|</span><a href="#41065638">next</a><span>|</span><label class="collapse" for="c-41072854">[-]</label><label class="expand" for="c-41072854">[1 more]</label></div><br/><div class="children"><div class="content">I support this behavior as the only correct reaction.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41065638" class="c"><input type="checkbox" id="c-41065638" checked=""/><div class="controls bullet"><span class="by">padavanchik</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065439">parent</a><span>|</span><a href="#41065652">prev</a><span>|</span><a href="#41065627">next</a><span>|</span><label class="collapse" for="c-41065638">[-]</label><label class="expand" for="c-41065638">[1 more]</label></div><br/><div class="children"><div class="content">There is no language spec for TS. No alternative implementations. All we have is checker.ts. It&#x27;s ugly and slow.</div><br/></div></div><div id="41065627" class="c"><input type="checkbox" id="c-41065627" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065439">parent</a><span>|</span><a href="#41065638">prev</a><span>|</span><a href="#41064760">next</a><span>|</span><label class="collapse" for="c-41065627">[-]</label><label class="expand" for="c-41065627">[2 more]</label></div><br/><div class="children"><div class="content">What do you mean ugly? This basically <i>is</i> making Typescript official.<p>They just can&#x27;t have browsers doing the actual type checking because there isn&#x27;t a specification for how to do that, and writing one would be extremely complicated, and I&#x27;m not sure what the point would be anyway.</div><br/><div id="41065831" class="c"><input type="checkbox" id="c-41065831" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065627">parent</a><span>|</span><a href="#41064760">next</a><span>|</span><label class="collapse" for="c-41065831">[-]</label><label class="expand" for="c-41065831">[1 more]</label></div><br/><div class="children"><div class="content">I misread the proposal, tho it it was for JSDoc.</div><br/></div></div></div></div></div></div></div></div><div id="41064760" class="c"><input type="checkbox" id="c-41064760" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#41064729">parent</a><span>|</span><a href="#41065075">prev</a><span>|</span><a href="#41070130">next</a><span>|</span><label class="collapse" for="c-41064760">[-]</label><label class="expand" for="c-41064760">[22 more]</label></div><br/><div class="children"><div class="content">&gt; In Python, I&#x27;ve even heard of people writing types in source code but never checking them<p>This is my main approach. Type hints are wonderful for keeping code legible&#x2F;sane without going into full static type enforcement which can become cumbersome for rapid development.</div><br/><div id="41064851" class="c"><input type="checkbox" id="c-41064851" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064760">parent</a><span>|</span><a href="#41064992">next</a><span>|</span><label class="collapse" for="c-41064851">[-]</label><label class="expand" for="c-41064851">[17 more]</label></div><br/><div class="children"><div class="content">You can configure typescript to make typing optional. With that option set, you can literally rename .js files to .ts and everything &quot;compiles&quot; and just works. Adding this feature to nodejs means you don&#x27;t even have to set up tsc if you don&#x27;t want to.<p>But if I were putting in type hints like this, I&#x27;d still definitely want them to be statically checked. Its better to have no types at all than <i>wrong</i> types.</div><br/><div id="41065034" class="c"><input type="checkbox" id="c-41065034" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064851">parent</a><span>|</span><a href="#41066362">next</a><span>|</span><label class="collapse" for="c-41065034">[-]</label><label class="expand" for="c-41065034">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Its better to have no types at all than <i>wrong</i> types.<p>I agree - but the type systems of both Python and TypeScript are unsound, so all type hints can potentially be wrong. That&#x27;s one reason why I still mostly use untyped Python - I don&#x27;t think it&#x27;s worth the effort of writing type annotations if they&#x27;re just going to sit there and tell lies.<p>Or maybe the unsoundness is just a theoretical issue - are incorrect type hints much of a problem in practice?</div><br/><div id="41065106" class="c"><input type="checkbox" id="c-41065106" checked=""/><div class="controls bullet"><span class="by">zoul</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065034">parent</a><span>|</span><a href="#41065199">next</a><span>|</span><label class="collapse" for="c-41065106">[-]</label><label class="expand" for="c-41065106">[2 more]</label></div><br/><div class="children"><div class="content">In my experience unsoundness is almost never a problem in practice, see here for details:<p><a href="https:&#x2F;&#x2F;effectivetypescript.com&#x2F;2021&#x2F;05&#x2F;06&#x2F;unsoundness&#x2F;" rel="nofollow">https:&#x2F;&#x2F;effectivetypescript.com&#x2F;2021&#x2F;05&#x2F;06&#x2F;unsoundness&#x2F;</a></div><br/><div id="41072495" class="c"><input type="checkbox" id="c-41072495" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065106">parent</a><span>|</span><a href="#41065199">next</a><span>|</span><label class="collapse" for="c-41072495">[-]</label><label class="expand" for="c-41072495">[1 more]</label></div><br/><div class="children"><div class="content">Unsound types are never a problem until they are at which point you are staring at code that SHOULD be working, but is somehow breaking.</div><br/></div></div></div></div><div id="41065199" class="c"><input type="checkbox" id="c-41065199" checked=""/><div class="controls bullet"><span class="by">kcrwfrd_</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065034">parent</a><span>|</span><a href="#41065106">prev</a><span>|</span><a href="#41065108">next</a><span>|</span><label class="collapse" for="c-41065199">[-]</label><label class="expand" for="c-41065199">[9 more]</label></div><br/><div class="children"><div class="content">Is this “unsound”-ness that you’re referring to because it uses structural typing and not nominal typing?<p>Fwiw I’ve been working with TypeScript for 8+ years now and I’m pretty sure wrong type hints has never been a problem. TS is a God-send for working with a codebase.</div><br/><div id="41069695" class="c"><input type="checkbox" id="c-41069695" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065199">parent</a><span>|</span><a href="#41068522">next</a><span>|</span><label class="collapse" for="c-41069695">[-]</label><label class="expand" for="c-41069695">[1 more]</label></div><br/><div class="children"><div class="content">No, TypeScript is not unsound because it uses structural typing.<p>A language has a sound type system if every well-typed program behaves as defined by the language&#x27;s semantics during execution.<p>Go is structurally typed, and yet it is sound: code that successfully type checks is guaranteed to abide the semantics of the language.<p>TypeScript is unsound because code that type checks does <i>not</i> necessarily abide the semantics of the language:<p><pre><code>  function messUpTheArray(arr: Array&lt;string | number&gt;): void {
      arr.push(3);
  }
  
  const strings: Array&lt;string&gt; = [&#x27;foo&#x27;, &#x27;bar&#x27;];
  messUpTheArray(strings);
  
  const s: string = strings[2];
  console.log(s.toLowerCase())
</code></pre>
`strings` is declared as a `Array&lt;string&gt;`, but TypeScript is happy to insert a `number` into it. This is a contradiction, and an example of unsoundness.<p>`s` is declared as `string`, but TypeScript is happy to assign a `number` to it. This is a contradiction, and an example of unsoundness.<p>This code eventually fails at runtime when we try to call `s.toLowerCase()`, as `number` has no such function.<p>What we&#x27;re seeing here is that TypeScript will readily accept programs which violate its own rules. Any language that does this, whether nominally typed or structurally typed, is unsound.</div><br/></div></div><div id="41068522" class="c"><input type="checkbox" id="c-41068522" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065199">parent</a><span>|</span><a href="#41069695">prev</a><span>|</span><a href="#41065108">next</a><span>|</span><label class="collapse" for="c-41068522">[-]</label><label class="expand" for="c-41068522">[7 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not much connection. Typescript&#x27;s record types aren&#x27;t sound, but that&#x27;s far from its only source of unsoundness, and sound structural typing is perfectly possible.</div><br/><div id="41068617" class="c"><input type="checkbox" id="c-41068617" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068522">parent</a><span>|</span><a href="#41065108">next</a><span>|</span><label class="collapse" for="c-41068617">[-]</label><label class="expand" for="c-41068617">[6 more]</label></div><br/><div class="children"><div class="content">Soundness is also a highly theoretical issue that I&#x27;ve never once heard a professional TypeScript developer express concern about and have never once heard a single anecdote of it being an issue in real-world code that wasn&#x27;t specifically designed to show the unsoundness. It usually only comes up among PL people (who I count myself among) who are extremely into the theory but not regularly coding in the language.<p>Do you have an anecdote (just one!) of a case where TypeScript&#x27;s lack of type system soundness bit you on a real application? Or an anecdote you can link to from someone else?</div><br/><div id="41071247" class="c"><input type="checkbox" id="c-41071247" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068617">parent</a><span>|</span><a href="#41070379">next</a><span>|</span><label class="collapse" for="c-41071247">[-]</label><label class="expand" for="c-41071247">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Do you have an anecdote (just one!) of a case where TypeScript&#x27;s lack of type system soundness bit you on a real application?<p>Sure. The usual Java-style variance nonsense is probably the most common source, but I see you&#x27;re not bothered by that, so the next worst thing is likely object spreading. Here&#x27;s an anonymized version of something that cropped up in code review earlier this week:<p><pre><code>    const incomingValue: { name: string, updatedAt: number } = { name: &quot;foo&quot;, updatedAt: 0 }

    const intermediateValueWithPoorlyChosenSignature: { name: string } = incomingValue

    const outgoingValue: { name: string, updatedAt: string } = { updatedAt: new Date().toISOString() , ...intermediateValueWithPoorlyChosenSignature }</code></pre></div><br/><div id="41072556" class="c"><input type="checkbox" id="c-41072556" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41071247">parent</a><span>|</span><a href="#41070379">next</a><span>|</span><label class="collapse" for="c-41072556">[-]</label><label class="expand" for="c-41072556">[2 more]</label></div><br/><div class="children"><div class="content">I mean... yes, there&#x27;s a footgun there where you have to know to spread first and <i>then</i> add the new properties. That&#x27;s just a good practice in the general case: an intermediate type that fully described the data wouldn&#x27;t have saved you from overwriting it unless you actually looked closely at the type signature.<p>And yes, TypeScript types are &quot;at least these properties&quot; and not &quot;exactly these properties&quot;. That is by design and is frankly one reason why I <i>like</i> TypeScript over Java&#x2F;C#&#x2F;Kotlin.<p>I&#x27;d be very interested to know what you&#x27;d do to change the type system here to catch this. Are you proposing that types be exact bounds rather than lower bounds on what an object contains?</div><br/><div id="41076979" class="c"><input type="checkbox" id="c-41076979" checked=""/><div class="controls bullet"><span class="by">haskman</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41072556">parent</a><span>|</span><a href="#41070379">next</a><span>|</span><label class="collapse" for="c-41076979">[-]</label><label class="expand" for="c-41076979">[1 more]</label></div><br/><div class="children"><div class="content">Look into &quot;Row types&quot; and how PureScript, Haskell, and Elm (to a limited extent) do it.<p>&#x27;{foo :: Int | bar} is a record with a known property &#x27;foo&#x27; and some unspecified properties &#x27;bar&#x27;. You cannot pass a `{foo :: Int, bar :: Int}` into a function that expects `{foo :: Int}`.<p>A function that accepts any record with a field foo, changes foo, keeping other properties intact has the type<p><pre><code>    {foo :: Int | bar} -&gt; {foo :: Int | bar}</code></pre></div><br/></div></div></div></div></div></div><div id="41070379" class="c"><input type="checkbox" id="c-41070379" checked=""/><div class="controls bullet"><span class="by">kcrwfrd_</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41068617">parent</a><span>|</span><a href="#41071247">prev</a><span>|</span><a href="#41065108">next</a><span>|</span><label class="collapse" for="c-41070379">[-]</label><label class="expand" for="c-41070379">[2 more]</label></div><br/><div class="children"><div class="content">Ah someone else posted a link and I understand the unsoundness now.<p>The only time an issue ever came up for me was in dealing with arrays<p><pre><code>  let foo: number[] = [0, 1, 2]

  &#x2F;&#x2F; typed as number but it’s really undefined
  let bar = foo[3]
</code></pre>
But once you’re aware of the caveat it’s something you can deal with, and it certainly doesn’t negate the many massive benefits that TS confers over vanilla JS.</div><br/><div id="41070718" class="c"><input type="checkbox" id="c-41070718" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41070379">parent</a><span>|</span><a href="#41065108">next</a><span>|</span><label class="collapse" for="c-41070718">[-]</label><label class="expand" for="c-41070718">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that example is unsound in the same way that Java&#x27;s type system is unsound, it&#x27;s a compromise nearly all languages make to avoid forcing you to add checks when you know what you&#x27;re doing. That&#x27;s not the kind of problem that people usually are referring to when they single out TypeScript.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41065108" class="c"><input type="checkbox" id="c-41065108" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41065034">parent</a><span>|</span><a href="#41065199">prev</a><span>|</span><a href="#41066362">next</a><span>|</span><label class="collapse" for="c-41065108">[-]</label><label class="expand" for="c-41065108">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using TypeScript professionally for 6+ years and have only ever run into issues at the border between TypeScript and other systems (usually network, sometimes libraries that don&#x27;t come with types). There are a few edge cases that I&#x27;m aware of, but they don&#x27;t really come up in practice.</div><br/></div></div></div></div><div id="41066362" class="c"><input type="checkbox" id="c-41066362" checked=""/><div class="controls bullet"><span class="by">black3r</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064851">parent</a><span>|</span><a href="#41065034">prev</a><span>|</span><a href="#41064900">next</a><span>|</span><label class="collapse" for="c-41066362">[-]</label><label class="expand" for="c-41066362">[1 more]</label></div><br/><div class="children"><div class="content">Or you can configure the TS compiler to allow JS imports, then everything also compiles and works, but you can slowly convert your codebase from JS to TS file by file and be sure that all TS files are properly typed and all JS files are untyped instead of having everything as TS files where some are typed and some are not.</div><br/></div></div><div id="41064900" class="c"><input type="checkbox" id="c-41064900" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064851">parent</a><span>|</span><a href="#41066362">prev</a><span>|</span><a href="#41064992">next</a><span>|</span><label class="collapse" for="c-41064900">[-]</label><label class="expand" for="c-41064900">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I start projects by explicitly typing `any` all over the place and gradually refining things, so every type that&#x27;s specified is explicit and checked, I&#x27;m really enjoying that style.</div><br/><div id="41065119" class="c"><input type="checkbox" id="c-41065119" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064900">parent</a><span>|</span><a href="#41064992">next</a><span>|</span><label class="collapse" for="c-41065119">[-]</label><label class="expand" for="c-41065119">[1 more]</label></div><br/><div class="children"><div class="content">Combine this with an eslint config that nudges you about explicit any, and the typescript compiler option to disallow implicit any, and you&#x27;re well taken care of.</div><br/></div></div></div></div></div></div><div id="41064992" class="c"><input type="checkbox" id="c-41064992" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064760">parent</a><span>|</span><a href="#41064851">prev</a><span>|</span><a href="#41065021">next</a><span>|</span><label class="collapse" for="c-41064992">[-]</label><label class="expand" for="c-41064992">[1 more]</label></div><br/><div class="children"><div class="content">With this approach, do you still use Python&#x27;s standard syntax for type hints?<p><pre><code>    def mersenne(p: int): return 2**p - 1
</code></pre>
Or, given there&#x27;s no need for the type hints to be checker-friendly, do you make them more human-friendly, e.g:<p><pre><code>    def mersenne(p: &#x27;prime number&#x27;): return 2**p - 1</code></pre></div><br/></div></div><div id="41065021" class="c"><input type="checkbox" id="c-41065021" checked=""/><div class="controls bullet"><span class="by">Humphrey</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064760">parent</a><span>|</span><a href="#41064992">prev</a><span>|</span><a href="#41067684">next</a><span>|</span><label class="collapse" for="c-41065021">[-]</label><label class="expand" for="c-41065021">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.  And if you use a library that does lots of meta programming (like Django) then it&#x27;s impossible to pass all type errors.  Hopefully one day the type system will be powerful enough to write a Django project with passing tests.</div><br/></div></div><div id="41067684" class="c"><input type="checkbox" id="c-41067684" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064760">parent</a><span>|</span><a href="#41065021">prev</a><span>|</span><a href="#41072580">next</a><span>|</span><label class="collapse" for="c-41067684">[-]</label><label class="expand" for="c-41067684">[1 more]</label></div><br/><div class="children"><div class="content">IME if you aren&#x27;t checking them, they&#x27;re eventually going to be out of date.</div><br/></div></div><div id="41072580" class="c"><input type="checkbox" id="c-41072580" checked=""/><div class="controls bullet"><span class="by">rlt</span><span>|</span><a href="#41064729">root</a><span>|</span><a href="#41064760">parent</a><span>|</span><a href="#41067684">prev</a><span>|</span><a href="#41070130">next</a><span>|</span><label class="collapse" for="c-41072580">[-]</label><label class="expand" for="c-41072580">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t find TypeScript to be burdensome when rapidly iterating. Depending on how you&#x27;ve configured your dev environment you can just ignore type errors and still run the code.</div><br/></div></div></div></div></div></div><div id="41070130" class="c"><input type="checkbox" id="c-41070130" checked=""/><div class="controls bullet"><span class="by">unilynx</span><span>|</span><a href="#41064729">prev</a><span>|</span><a href="#41066554">next</a><span>|</span><label class="collapse" for="c-41070130">[-]</label><label class="expand" for="c-41070130">[19 more]</label></div><br/><div class="children"><div class="content">If this feature ever becomes the default (ie not behind a flag) - how will the NPM ecosystem respond? Will contributors still bother to build CJS end EJS versions when publishing a NPM module, or just slap an &#x27;engine: nodejs &gt;= 25&#x27; on the package.json and stop bothering with the build step before pushing to NPM ?<p>I <i>personally</i> would very much prefer if NPM modules that have their original code in TS and are currently transpiling would stop shipping dist&#x2F;<i>.cjs so I unambiguously know where to put my debugger&#x2F;console.log statements. And it would probably be very tempting to NPM contributors to not have to bother with a build step anymore.<p>But won&#x27;t this start a ripple effect through NPM where everyone will start to assume very quickly &#x27;everyone accepts TS files&#x27; - it only takes one of your dependencies for this effect to ripple through? It seems to me that nodejs can&#x27;t move this outside an opt-in-experimental-flag without the whole community implicitly expecting all consumers to accept TS files before you know it. And if they do, it will be just months before Firefox and Safari will be force to accept it too, so all JS compilers will have to discard TS type annotations<p>Which I would personally be happy with - we&#x27;re building transcompiling steps into NPM modules that convert the ts code into js and d.ts just to support some hypothetical JS user even though we&#x27;re using TS on the including side. But if node accepts </i>.ts files we could just remove those transpiling steps without ever noticing it... so what&#x27;s stopping NPM publishers from publishing js&#x2F;d.ts files without noticing they broke anything?</div><br/><div id="41072689" class="c"><input type="checkbox" id="c-41072689" checked=""/><div class="controls bullet"><span class="by">Omerd6</span><span>|</span><a href="#41070130">parent</a><span>|</span><a href="#41070540">next</a><span>|</span><label class="collapse" for="c-41072689">[-]</label><label class="expand" for="c-41072689">[4 more]</label></div><br/><div class="children"><div class="content">The legendary Ryan dahl is actually working on solving the exact problem you described by creating a new package registry called JSR.<p>Essentially what it does is allow you to upload your typescript code without a build step so when other devs install it they can see the source code of the module in it&#x27;s original typescript instead of transpiled JavaScript.</div><br/><div id="41073657" class="c"><input type="checkbox" id="c-41073657" checked=""/><div class="controls bullet"><span class="by">sam_perez</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41072689">parent</a><span>|</span><a href="#41074231">next</a><span>|</span><label class="collapse" for="c-41073657">[-]</label><label class="expand" for="c-41073657">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really cool. One of the benefits of the JS ecosystem is the ability to step through code and crack open your dependencies. Not sure if this would directly make this possible when running your projects&#x2F;tests, but it at least sounds like a step in that direction.</div><br/></div></div><div id="41074231" class="c"><input type="checkbox" id="c-41074231" checked=""/><div class="controls bullet"><span class="by">meowtimemania</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41072689">parent</a><span>|</span><a href="#41073657">prev</a><span>|</span><a href="#41070540">next</a><span>|</span><label class="collapse" for="c-41074231">[-]</label><label class="expand" for="c-41074231">[2 more]</label></div><br/><div class="children"><div class="content">it must install compiled and uncompiled versions? Otherwise node (without the above flag) would throw errors when it encounters types in node_modules</div><br/><div id="41074484" class="c"><input type="checkbox" id="c-41074484" checked=""/><div class="controls bullet"><span class="by">Omerd6</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41074231">parent</a><span>|</span><a href="#41070540">next</a><span>|</span><label class="collapse" for="c-41074484">[-]</label><label class="expand" for="c-41074484">[1 more]</label></div><br/><div class="children"><div class="content">I just checked and you are correct, in node it only installs the  compiled version.<p>Apparently you can only view the uncompiled source code in deno since it natively supports typescript.<p>My bad</div><br/></div></div></div></div></div></div><div id="41070540" class="c"><input type="checkbox" id="c-41070540" checked=""/><div class="controls bullet"><span class="by">satanacchio</span><span>|</span><a href="#41070130">parent</a><span>|</span><a href="#41072689">prev</a><span>|</span><a href="#41076127">next</a><span>|</span><label class="collapse" for="c-41070540">[-]</label><label class="expand" for="c-41070540">[1 more]</label></div><br/><div class="children"><div class="content">We dont support running .ts files in node_modules, this is one of the main constraints to avoid breaking the ecosystem</div><br/></div></div><div id="41076127" class="c"><input type="checkbox" id="c-41076127" checked=""/><div class="controls bullet"><span class="by">rnmkr</span><span>|</span><a href="#41070130">parent</a><span>|</span><a href="#41070540">prev</a><span>|</span><a href="#41070382">next</a><span>|</span><label class="collapse" for="c-41076127">[-]</label><label class="expand" for="c-41076127">[1 more]</label></div><br/><div class="children"><div class="content">I would love to ship my source code (.ts) to npm. But Typescript team was very much against this, as there&#x27;ll be tsconfig issues and other performance issues. But still fingers crossed.</div><br/></div></div><div id="41070382" class="c"><input type="checkbox" id="c-41070382" checked=""/><div class="controls bullet"><span class="by">nfriedly</span><span>|</span><a href="#41070130">parent</a><span>|</span><a href="#41076127">prev</a><span>|</span><a href="#41066554">next</a><span>|</span><label class="collapse" for="c-41070382">[-]</label><label class="expand" for="c-41070382">[12 more]</label></div><br/><div class="children"><div class="content">For the old libraries I maintain that are typescript and transpiled into .cjs and .mjs for npm, I&#x27;ll probably just start shipping all three versions.<p>For a new thing I was writing from scratch, yeah, I might just ship typescript and not bother transpiling.<p>[edit: Apparently not. TS is only for top-level things, not libraries in node_modules according to the sibling comment from satanacchio who I believe is the author of the PR that added TS support and a member of the Node.js Technical Steering Committee]</div><br/><div id="41070623" class="c"><input type="checkbox" id="c-41070623" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41070382">parent</a><span>|</span><a href="#41066554">next</a><span>|</span><label class="collapse" for="c-41070623">[-]</label><label class="expand" for="c-41070623">[11 more]</label></div><br/><div class="children"><div class="content">Why are you still transpiling to .cjs in 2024? ESM is supported in every LTS version of Node now. We can kill CJS, we have the power.</div><br/><div id="41071334" class="c"><input type="checkbox" id="c-41071334" checked=""/><div class="controls bullet"><span class="by">nfriedly</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41070623">parent</a><span>|</span><a href="#41076816">next</a><span>|</span><label class="collapse" for="c-41071334">[-]</label><label class="expand" for="c-41071334">[7 more]</label></div><br/><div class="children"><div class="content">Because I don&#x27;t like breaking things unnecessarily. Some of my libraries are 10 years old and depended upon by similarly old projects that are not using ESM and probably never will.<p>Besides, it&#x27;s already going through one transpilation step to go from TS to ESM, so adding a second one for CJS really isn&#x27;t that much hassle.<p>I think if node.js had made require() work with ESM, I could probably drop CJS. But since that&#x27;s probably never going to happen, I&#x27;m just going to continue shipping both versions for old projects and not worry about it.</div><br/><div id="41071600" class="c"><input type="checkbox" id="c-41071600" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41071334">parent</a><span>|</span><a href="#41071926">next</a><span>|</span><label class="collapse" for="c-41071600">[-]</label><label class="expand" for="c-41071600">[2 more]</label></div><br/><div class="children"><div class="content">&gt; adding a second one for CJS<p>Nobody is arguing for that. Once you ship ESM, you can continue shipping ESM.<p>In Node 22 you can even require() ES modules (with an experimental flag, at the moment)</div><br/><div id="41071776" class="c"><input type="checkbox" id="c-41071776" checked=""/><div class="controls bullet"><span class="by">nfriedly</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41071600">parent</a><span>|</span><a href="#41071926">next</a><span>|</span><label class="collapse" for="c-41071776">[-]</label><label class="expand" for="c-41071776">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; <i>adding a second one for CJS</i><p>&gt; <i>Nobody is arguing for that. Once you ship ESM, you can continue shipping ESM.</i><p>I&#x27;m not sure I follow you there. I did continue shipping ESM.<p>&gt; <i>In Node 22 you can even require() ES modules (with an experimental flag, at the moment)</i><p>Oh, I didn&#x27;t know about that, cool! Once it becomes un-flagged I might consider dropping CJS.</div><br/></div></div></div></div><div id="41071926" class="c"><input type="checkbox" id="c-41071926" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41071334">parent</a><span>|</span><a href="#41071600">prev</a><span>|</span><a href="#41076816">next</a><span>|</span><label class="collapse" for="c-41071926">[-]</label><label class="expand" for="c-41071926">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think if node.js had made require() work with ESM, I could probably drop CJS<p>Why is making downstream have to switch to `await import()` that big of a deal?<p>You can use async&#x2F;await in CJS just fine. Sure, sometimes you may need to resort to some ugly async IIFE wrappers because CJS doesn&#x27;t support top-level await like ESM does, but is that really such a big deal?<p>Sure, it&#x27;s a breaking change, but that&#x27;s what semver major bumps are for.<p>I just think that if projects want to stay in CJS they should learn how to use async&#x2F;await. I clearly don&#x27;t understand why CJS libraries feel a need synchronous require() for everything. (Though to be fair, <i>I&#x27;ve</i> also never intentionally written anything directly in CJS. I learned enough in the AMD days to avoid CJS like a plague.)</div><br/><div id="41072092" class="c"><input type="checkbox" id="c-41072092" checked=""/><div class="controls bullet"><span class="by">nfriedly</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41071926">parent</a><span>|</span><a href="#41076816">next</a><span>|</span><label class="collapse" for="c-41072092">[-]</label><label class="expand" for="c-41072092">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Why is making downstream have to switch to `await import()` that big of a deal?</i><p>&gt; <i>You can use async&#x2F;await in CJS just fine. Sure, sometimes you may need to resort to some ugly async IIFE wrappers because CJS doesn&#x27;t support top-level await like ESM does, but is that really such a big deal?</i><p>It might seem like a small amount of work, but for a library one must to multiply that small amount of work by the number of users who will have to repeat it. It can be a quite large amount in aggregate. And, for what benefit? So I can drop one line from my CI config? It just seems like a huge waste of everyone&#x27;s time.<p>Also, as a library user, I would (and occasionally do) get annoyed by seemingly unnecessary work foisted on my by a library author. It makes me consider whether or not I want to actually depend on that library, and sometimes the answer is no.</div><br/><div id="41072743" class="c"><input type="checkbox" id="c-41072743" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41072092">parent</a><span>|</span><a href="#41076816">next</a><span>|</span><label class="collapse" for="c-41072743">[-]</label><label class="expand" for="c-41072743">[2 more]</label></div><br/><div class="children"><div class="content">&gt; multiply that small amount of work by the number of users who will have to repeat it<p>This is probably where we have the biggest difference in our calculations. I know there&#x27;s a lot of pain in legacy CJS systems, but from my view (which is maybe more &quot;browser-oriented&quot;, which is maybe a bit more Deno&#x2F;Bun-influences, which comes from a &quot;Typescript-first&quot; mentality going way back to 0.x) it is more legacy &quot;giant balls of mud&quot; maintained by a sparse few developers. I don&#x27;t see this multiplicand as very big on the scale of library user count. Most CJS for years and years has been transpiled from Typescript or Rollup; most CJS only exists to be eaten by Webpack or other bundler, many of which today rewrite CJS to ESM anyway. From what I see a lot of CJS seems either transpiled out of habit (for some notion of supporting Node &lt; 10 that doesn&#x27;t make sense with current security support) or by accident (by a misconfigured tsconfig.json, for example, and then often looping back through a transpiler again back to ESM). The way we cut through the Gordian knot of we&#x27;re all doing too much transpilation to&#x2F;from CJS is to start eliminating automated transpilation to CJS in the first place. Which is why I find it useful every time to ask people what they are really trying to do when transpiling to .cjs today.<p>Of course, if your multiplicand is lines-of-code impacted, because I agree there are some great big huge piles of mud in CJS that are likely stuck that way for lack of developers&#x2F;maintainers and lack of time&#x2F;budget&#x2F;money, then worrying about the minority of users still intentionally using CJS is worth caring about, and my sympathies in that situation.<p>You, of course, know your library&#x27;s users better than me and maybe you do have a lot of CJS users that I just wouldn&#x27;t consider in my calculations. I&#x27;m not going to stop you from transpiling to CJS if you find that necessary for your library. That&#x27;s your judgment call. I just wanted to also make sure to ask the questions of &quot;do you really need to?&quot; and &quot;how many users do you actually think it will impact?&quot; out loud. Thanks a lot for the conversation on it, and I&#x27;m still going to be a radical banging the &quot;CJS Must Die&quot; drum, but I understand pragmatism and maintenance needs, especially those of legacy applications, and mostly just want to make sure the conversation is an active one and a lot less of passively transpiling stuff that doesn&#x27;t really need it.</div><br/><div id="41076162" class="c"><input type="checkbox" id="c-41076162" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41072743">parent</a><span>|</span><a href="#41076816">next</a><span>|</span><label class="collapse" for="c-41076162">[-]</label><label class="expand" for="c-41076162">[1 more]</label></div><br/><div class="children"><div class="content">Aight let me chime in here.<p>I&#x27;m a game developer. I make web games. We run our games with a simple nginx server that simply serves the wasm. We have some JavaScript libraries we use. They have to be raw dog .js.<p>I don&#x27;t even know what your &quot;ejs&quot; or &quot;cjs&quot; acronyms mean.<p>We use the discord JavaScript SDK. Discord only ships it as a node module or as .ts.<p>It&#x27;s a pain in our ass to update because we don&#x27;t know what those tools your talking about are and we don&#x27;t want to know. Just give me the damn .js</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41076816" class="c"><input type="checkbox" id="c-41076816" checked=""/><div class="controls bullet"><span class="by">joseferben</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41070623">parent</a><span>|</span><a href="#41071334">prev</a><span>|</span><a href="#41072354">next</a><span>|</span><label class="collapse" for="c-41076816">[-]</label><label class="expand" for="c-41076816">[1 more]</label></div><br/><div class="children"><div class="content">i wish it was that easy. i keep trying to default to esm on node projects but the ecosystem is not there yet, at least in the context of server side nodejs stuff.</div><br/></div></div><div id="41072354" class="c"><input type="checkbox" id="c-41072354" checked=""/><div class="controls bullet"><span class="by">thr0w</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41070623">parent</a><span>|</span><a href="#41076816">prev</a><span>|</span><a href="#41066554">next</a><span>|</span><label class="collapse" for="c-41072354">[-]</label><label class="expand" for="c-41072354">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ESM is supported in every LTS version of Node now. We can kill CJS, we have the power.<p>I&#x27;d rather kill ESM. And it&#x27;s not fully supported in Node. It doesn&#x27;t work in the REPL.</div><br/><div id="41074102" class="c"><input type="checkbox" id="c-41074102" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41070130">root</a><span>|</span><a href="#41072354">parent</a><span>|</span><a href="#41066554">next</a><span>|</span><label class="collapse" for="c-41074102">[-]</label><label class="expand" for="c-41074102">[1 more]</label></div><br/><div class="children"><div class="content">You can have a chat to all major browser vendors about killing ESM :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41066554" class="c"><input type="checkbox" id="c-41066554" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#41070130">prev</a><span>|</span><a href="#41064589">next</a><span>|</span><label class="collapse" for="c-41066554">[-]</label><label class="expand" for="c-41066554">[18 more]</label></div><br/><div class="children"><div class="content">Eventually, node might allow JS to introspect those types.<p>That would be a huge win. Right now in Python, great tools like pydantic exist because Python can introspect said types, and generate checks out of them.<p>This mean you can define simple types, and get:<p>- type checking
- run time data check
- api generation
- api document generation<p>Out of a single, standard notation.<p>Right now in JS, things like zod have to do:<p><pre><code>    const mySchema = z.string();
</code></pre>
Which is basically reinventing what typescript is already doing.</div><br/><div id="41066756" class="c"><input type="checkbox" id="c-41066756" checked=""/><div class="controls bullet"><span class="by">bythreads</span><span>|</span><a href="#41066554">parent</a><span>|</span><a href="#41066952">next</a><span>|</span><label class="collapse" for="c-41066756">[-]</label><label class="expand" for="c-41066756">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not entirely true. `z.string()` in Zod offers more than just type safety akin to TypeScript. TypeScript provides compile-time type checking, while Zod adds runtime validation and parsing.<p>For those unfamiliar:<p>`z.string()` effectively converts `mySchema` into a functional schema capable of parsing and validation.<p>For example:<p>`mySchema.parse(&quot;some data&quot;)` returns successfully.<p>`mySchema.parse(321)` throws an exception.<p>I&#x27;ve used it in places where you need runtime validation and in process verification - it works pretty well for that and you can extract the types from it via :<p>const A = z.string();
type A = z.infer&lt;typeof A&gt;; &#x2F;&#x2F; string<p>Meaning if you define your types in zod first, and infer their types from that you get compile and runtime type checking.<p>---<p>It a bit of an overkill for nimble and fast code bases though - but works wonders for situations where in process proofing needs to be done, and in all honesty it isn&#x27;t that big of a task to do this.</div><br/><div id="41067297" class="c"><input type="checkbox" id="c-41067297" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41066756">parent</a><span>|</span><a href="#41068080">next</a><span>|</span><label class="collapse" for="c-41067297">[-]</label><label class="expand" for="c-41067297">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Zod offers more than just type safety akin to TypeScript. TypeScript provides compile-time type checking, while Zod adds runtime validation and parsing.<p>Well of course it offers more, or you wouldn&#x27;t be installing a library.<p>The problem is that even when you&#x27;re expressing normal Typescript types, you have to use entirely different syntax.  It&#x27;s good that you can usually avoid double-definition, but it&#x27;s still a big barrier that shouldn&#x27;t be necessary.</div><br/></div></div><div id="41068080" class="c"><input type="checkbox" id="c-41068080" checked=""/><div class="controls bullet"><span class="by">tommy_axle</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41066756">parent</a><span>|</span><a href="#41067297">prev</a><span>|</span><a href="#41066952">next</a><span>|</span><label class="collapse" for="c-41068080">[-]</label><label class="expand" for="c-41068080">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also typescript-to-zod that makes it possible to generate the zod schemas from your types.</div><br/></div></div></div></div><div id="41066952" class="c"><input type="checkbox" id="c-41066952" checked=""/><div class="controls bullet"><span class="by">MrBazlow</span><span>|</span><a href="#41066554">parent</a><span>|</span><a href="#41066756">prev</a><span>|</span><a href="#41069109">next</a><span>|</span><label class="collapse" for="c-41066952">[-]</label><label class="expand" for="c-41066952">[1 more]</label></div><br/><div class="children"><div class="content">A lot of the focus by the TypeScript team is focused on alignment with the JavaScript language these days and novel new features such as run time types have all but been dismissed or at the very least pushed behind the TC39 JavaScript types proposal. Much like using decorators on variables outside of class structures was.<p>Having said that, TypeScript allows plugins, these are very rarely used as they augment the language by introducing other features that are transformed into the resulting JavaScript files. One plugin that relates to your suggestion of run time types is called Typia, it permits you to use your TypeScript type signatures at runtime with guards like `assert&lt;MyType&gt;(myValue)` where it intercepts the function call to construct an exhaustive if statement in the transpiled JavaScript checking the nature of the passed variable.<p>So while I don&#x27;t see it being a part of the language in the next four to six years, there are at least libraries out there already that allow you to do it today.</div><br/></div></div><div id="41069109" class="c"><input type="checkbox" id="c-41069109" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41066554">parent</a><span>|</span><a href="#41066952">prev</a><span>|</span><a href="#41066635">next</a><span>|</span><label class="collapse" for="c-41069109">[-]</label><label class="expand" for="c-41069109">[10 more]</label></div><br/><div class="children"><div class="content">If JS ever adds type checking, I hope it doesn&#x27;t choose Typescript.<p>We need a type system that is actually sound and TS is intentionally unsound. We need a type system that doesn&#x27;t allow bad coding practices like TS does. We need a type system that enforces program design that allows programs to be fast. We need a Hindley Milner type system.<p>If you want a module to be typed, add a `&quot;use type&quot;`. This should disallow bad parts of the language like type coercion. It should disallow things that hurt performance like changing object shape&#x2F;value type or making arrays of random collections of stuff. Incoming data from untyped modules would either coerce or throw errors if coercion can&#x27;t be done at which point the compiler can deeply-optimize the typed code because it would have far stronger type guarantees and wouldn&#x27;t have a risk of bailing out.</div><br/><div id="41076866" class="c"><input type="checkbox" id="c-41076866" checked=""/><div class="controls bullet"><span class="by">joseferben</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41069109">parent</a><span>|</span><a href="#41069499">next</a><span>|</span><label class="collapse" for="c-41076866">[-]</label><label class="expand" for="c-41076866">[1 more]</label></div><br/><div class="children"><div class="content">having written ocaml in production for a few years, i think soundness comes at a cost of dev ergonomics. at least with the type systems of today’s industry languages.<p>it blows my mind weekly how ergonomic and flexible typescript’s type system is. it allows me to write great apis for my team mates.<p>is it possible for the type checker to end up in an infinite loop or for a junior developer to abuse “as”? absolutely, but it doesn’t really matter in practice.<p>i wouldn’t want to run typescript in rockets or submarines tho!</div><br/></div></div><div id="41069499" class="c"><input type="checkbox" id="c-41069499" checked=""/><div class="controls bullet"><span class="by">ahuth</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41069109">parent</a><span>|</span><a href="#41076866">prev</a><span>|</span><a href="#41072989">next</a><span>|</span><label class="collapse" for="c-41069499">[-]</label><label class="expand" for="c-41069499">[7 more]</label></div><br/><div class="children"><div class="content">What bad coding practices does TS allow, and why are they bad?</div><br/><div id="41070889" class="c"><input type="checkbox" id="c-41070889" checked=""/><div class="controls bullet"><span class="by">DexesTTP</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41069499">parent</a><span>|</span><a href="#41070003">next</a><span>|</span><label class="collapse" for="c-41070889">[-]</label><label class="expand" for="c-41070889">[3 more]</label></div><br/><div class="children"><div class="content">TS allows you to pass a read-only object to a method taking a read-write value:<p><pre><code>    type A = { value: number; }
    function test(a: A) { a.value = 3; }
    function main() {
      const a: Readonly&lt;A&gt; = { value: 1 };
      &#x2F;&#x2F; a.value = 2; &lt;= this errors out
      test(a); &#x2F;&#x2F; this doesn&#x27;t error out
      console.log(a); &#x2F;&#x2F; shows 3
    }</code></pre></div><br/><div id="41076769" class="c"><input type="checkbox" id="c-41076769" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41070889">parent</a><span>|</span><a href="#41076050">next</a><span>|</span><label class="collapse" for="c-41076769">[-]</label><label class="expand" for="c-41076769">[1 more]</label></div><br/><div class="children"><div class="content">It seems super weird that this type checks, and it appears to be some sort of corner case explicitly implemented.<p>Normally typescript does not just allow implicit removal of a container type.<p>Like, you can&#x27;t pass Array&lt;A&gt; to a function that just takes A.</div><br/></div></div><div id="41076050" class="c"><input type="checkbox" id="c-41076050" checked=""/><div class="controls bullet"><span class="by">thoweofasdf</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41070889">parent</a><span>|</span><a href="#41076769">prev</a><span>|</span><a href="#41070003">next</a><span>|</span><label class="collapse" for="c-41076050">[-]</label><label class="expand" for="c-41076050">[1 more]</label></div><br/><div class="children"><div class="content">Nice find. Never ran into this because I haven&#x27;t mutated inputs in over 15 years.</div><br/></div></div></div></div><div id="41070003" class="c"><input type="checkbox" id="c-41070003" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41069499">parent</a><span>|</span><a href="#41070889">prev</a><span>|</span><a href="#41072989">next</a><span>|</span><label class="collapse" for="c-41070003">[-]</label><label class="expand" for="c-41070003">[3 more]</label></div><br/><div class="children"><div class="content">If there&#x27;s a bad way to write JS, TS has something available to make sure it&#x27;s typed.<p>Does TS help you keep your functions monomorphic so they&#x27;ll get optimized by the JIT? nope<p>Does TS keep your object shape from changing so it will get optimized by the JIT? it actively does the opposite giving TONS of tools that allow you to add, remove, modify, and otherwise mess up your objects and guarantee your code will never optimize beyond the basic bytecode (making it one or two orders of magnitude more slow than it could otherwise be).<p>TS doesn&#x27;t do anything to prevent or even discourage these kinds of bad decisions. They &quot;type soup&quot; many projects fall into is another symptom of this. The big reason the types become such a mess is because the underlying design is a mess. Instead of telling programmers &quot;fix your mess&quot;, TS just releases even more features so you can type the terrible code without fixing it.</div><br/><div id="41070936" class="c"><input type="checkbox" id="c-41070936" checked=""/><div class="controls bullet"><span class="by">tln</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41070003">parent</a><span>|</span><a href="#41072989">next</a><span>|</span><label class="collapse" for="c-41070936">[-]</label><label class="expand" for="c-41070936">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Does TS keep your object shape from changing so it will get optimized by the JIT? it actively does the opposite giving TONS of tools that allow you to add, remove, modify, and otherwise mess up your objects and guarantee your code will never optimize beyond the basic bytecode (making it one or two orders of magnitude more slow than it could otherwise be).<p>Can you elaborate or point to some of the tools? So I know what tools I may need to avoid</div><br/><div id="41072219" class="c"><input type="checkbox" id="c-41072219" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41070936">parent</a><span>|</span><a href="#41072989">next</a><span>|</span><label class="collapse" for="c-41072219">[-]</label><label class="expand" for="c-41072219">[1 more]</label></div><br/><div class="children"><div class="content">JS JITs use something called an inline cache (IC) to speed up the lookup of object shapes. JS JITs consider it to be a different shape if the keys are different (even if just one is added or removed), if the values of the same key are different types, and if the order of the keys change.<p>If you have a monomorphic function (1 type), the IC is very fast. If you have a polymorphic function (2-4 types), the IC function gets quite a bit slower. They call 5+ types megamorphic and it basically foregoes IC altogether and also disables most optimizations.<p>TS knows how many variants exist for a specific function and even knows how many of those variants are used. It should warn you when your functions are megamorphic, but that would instantly kill 90% of their type features because those features are actively BAD in JS.<p>Let&#x27;s illustrate this.<p><pre><code>    interface Foo {
      bar: string | string[]
      baz?: number
      blah?: boolean
    }
</code></pre>
Looks reasonably typical, but when we use it:<p><pre><code>    function useFoo(foo: Foo) { .... }

    useFoo({bar: &quot;abc&quot;, baz: 123, blah: true}) &#x2F;&#x2F;monomorphic
    useFoo({bar: &quot;abc&quot;, baz: 123})             &#x2F;&#x2F;now a slower polymorphic
    useFoo({bar: &quot;abc&quot;}) 
    useFoo({bar: [&quot;b&quot;], baz: 123}) 
    useFoo({bar: [&quot;b&quot;], baz: 123, blah: true}) &#x2F;&#x2F;we just fell off the performance cliff
</code></pre>
As you can see, getting bad performance is shockingly easy and if these calls were across five different files, they look similar enough that you&#x27;d have a hard time realizing things were slow.<p>Union&#x2F;intersection aren&#x27;t directly evil. Unions of a single type (eg, a union of strings) is actually great as it offers more specificity while not increasing function complexity. Even if they are a union of different primitive types, that is sometimes necessary and the cost you are paying is visible (though most JS devs are oblivious to the cost).<p>Optionals are somewhat more evil because they somewhat hide the price you are paying.<p>[key:string] is potentially evil. If you are using it as a kind of `any`, then it is probably evil, but if you are using it to indicate a map of strings to a type, then it&#x27;s perfectly fine.<p>keyof is great for narrowing the possible until you start passing those keys around the type system.<p>Template unions are also great for pumping out a giant string enum (though there is a definite people issue of making sure you&#x27;re only allowing what you want to allow), but if they get passed around the type system for use, they are probably evil.<p>Interface merging is evil. It allows your interface to spread across multiple places making it hard to follow and even harder to decide if it will make your code slow.<p>Overloads are evil. They pretend you have two different functions, but then just union everything together.<p>Conditional types are evil. They only exist for creating even more complex types and those types are basically guaranteed to be both impossible to fully understand and allow very slow code.<p>Mapped types are evil. As with conditional types, they exist to make complex an incomprehensible types that allow slow code.<p>Generics are the mother of all that is evil in TS. When you use a generic, you are allowing basically anything to be inserted which means your type is instantly megamorphic. If a piece of code uses generics, you should simply assume it is as slow as possible.<p>As an aside, overloads were a missed opportunity. In theory, TS could speed everything up by dynamically generating all those different function variants at compile time. In practice, the widespread use of generic everything means your 5mb of code would instantly bloat into 5gb of code. Overloads would be a great syntax to specify that you care enough about the performance of that specific function that you want to make multiple versions and link to the right one at compile time. Libraries like React that make most of their user-facing functions megamorphic could probably see a decent performance boost from this in projects that used TS (they already try to do this manually by using the megamorphic function to dispatch to a bunch of monomorphic functions).</div><br/></div></div></div></div></div></div></div></div><div id="41072989" class="c"><input type="checkbox" id="c-41072989" checked=""/><div class="controls bullet"><span class="by">iimblack</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41069109">parent</a><span>|</span><a href="#41069499">prev</a><span>|</span><a href="#41066635">next</a><span>|</span><label class="collapse" for="c-41072989">[-]</label><label class="expand" for="c-41072989">[1 more]</label></div><br/><div class="children"><div class="content">Rescript?</div><br/></div></div></div></div><div id="41066635" class="c"><input type="checkbox" id="c-41066635" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#41066554">parent</a><span>|</span><a href="#41069109">prev</a><span>|</span><a href="#41064589">next</a><span>|</span><label class="collapse" for="c-41066635">[-]</label><label class="expand" for="c-41066635">[3 more]</label></div><br/><div class="children"><div class="content">Does this mean Node can know if an exception is subclass of ValueError or an object is instance of SomeClass? I&#x27;m a TS newb, I thought types outside of array, object, number, string arent present in JS and Zod and typeguard functions return plain objects with &quot;trust me bro&quot;.</div><br/><div id="41066755" class="c"><input type="checkbox" id="c-41066755" checked=""/><div class="controls bullet"><span class="by">gampleman</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41066635">parent</a><span>|</span><a href="#41066746">next</a><span>|</span><label class="collapse" for="c-41066755">[-]</label><label class="expand" for="c-41066755">[1 more]</label></div><br/><div class="children"><div class="content">In JS, classes do retain runtime information. So the `instanceof` is a real runtime operator that works by checking the prototype chain of an object. So checking subclasses can be done at runtime.<p>However, in TS other type information is erased at compile time. So if you write<p><pre><code>    type Foo = &quot;a&quot; | &quot;b&quot;;
</code></pre>
the runtime code will see that just as a plain string.</div><br/></div></div><div id="41066746" class="c"><input type="checkbox" id="c-41066746" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#41066554">root</a><span>|</span><a href="#41066635">parent</a><span>|</span><a href="#41066755">prev</a><span>|</span><a href="#41064589">next</a><span>|</span><label class="collapse" for="c-41066746">[-]</label><label class="expand" for="c-41066746">[1 more]</label></div><br/><div class="children"><div class="content">You are right, they aren&#x27;t. In the JavaScript languages which is what gets actually executed, there are no typescript types.<p>The parent commenter was talking about a way for nodejs to provide, via an API, the content of type annotations on fields&#x2F;functions&#x2F;variables like in python.<p>However, in python the type annotations are a property of the object at run time, whereas they are completely stripped before execution for typescript.<p>So I&#x27;m not sure how it would work except by changing the typescript philosophy of &quot;not changing runtime execution&quot;</div><br/></div></div></div></div></div></div><div id="41064589" class="c"><input type="checkbox" id="c-41064589" checked=""/><div class="controls bullet"><span class="by">samtheprogram</span><span>|</span><a href="#41066554">prev</a><span>|</span><a href="#41065110">next</a><span>|</span><label class="collapse" for="c-41064589">[-]</label><label class="expand" for="c-41064589">[24 more]</label></div><br/><div class="children"><div class="content">Bun’s DX is pretty unprecedented in this space, and most of my use cases are now covered &#x2F; not causing Bun to crash (when actually using run-scripts with `bun run`).<p>Meanwhile, I can’t configure node to not require extensions on import, nor have tsc configured to automatically add .js extensions to its compiled output, without adding on a bundler… although native TypeScript support would remedy this nit quite a bit, I can’t imagine the user experience (or performance) to match Bun’s when it reaches stable.</div><br/><div id="41064704" class="c"><input type="checkbox" id="c-41064704" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41067102">next</a><span>|</span><label class="collapse" for="c-41064704">[-]</label><label class="expand" for="c-41064704">[8 more]</label></div><br/><div class="children"><div class="content">Extensions <i>should</i> be required. It&#x27;s not possible to do path searches over the network like you can on local disk, and network-attached VMs, like browsers, are a very, very important runtime for JavaScript.</div><br/><div id="41065051" class="c"><input type="checkbox" id="c-41065051" checked=""/><div class="controls bullet"><span class="by">leipert</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41064704">parent</a><span>|</span><a href="#41065231">next</a><span>|</span><label class="collapse" for="c-41065051">[-]</label><label class="expand" for="c-41065051">[2 more]</label></div><br/><div class="children"><div class="content">Also performance.<p>foo could mean foo&#x2F;index.js, foo.js at the minimum. So you have 2x the lookups. Oh no, wait we also potentially have mjs, cjs, jsx, ts and tsx.<p>So 12 times the stat checking for each import.</div><br/><div id="41071335" class="c"><input type="checkbox" id="c-41071335" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41065051">parent</a><span>|</span><a href="#41065231">next</a><span>|</span><label class="collapse" for="c-41071335">[-]</label><label class="expand" for="c-41071335">[1 more]</label></div><br/><div class="children"><div class="content">&gt; foo could mean foo&#x2F;index.js, foo.js at the minimum. So you have 2x the lookups.<p>Only in the worst case. If it&#x27;s foo.js there&#x27;s only one lookup.<p>&gt;  Oh no, wait we also potentially have mjs, cjs, jsx, ts and tsx. So 12 times the stat checking for each import.<p>Again, you&#x27;re only taking into account the worst case.</div><br/></div></div></div></div><div id="41065231" class="c"><input type="checkbox" id="c-41065231" checked=""/><div class="controls bullet"><span class="by">pfg_</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41064704">parent</a><span>|</span><a href="#41065051">prev</a><span>|</span><a href="#41065024">next</a><span>|</span><label class="collapse" for="c-41065231">[-]</label><label class="expand" for="c-41065231">[3 more]</label></div><br/><div class="children"><div class="content">Fortunately, code is generally bundled for browsers to reduce the number of network requests and total size of downloads. And node has access to the filesystem, so it can do path searches just fine if it wants to support existing code.</div><br/><div id="41070016" class="c"><input type="checkbox" id="c-41070016" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41065231">parent</a><span>|</span><a href="#41065024">next</a><span>|</span><label class="collapse" for="c-41070016">[-]</label><label class="expand" for="c-41070016">[2 more]</label></div><br/><div class="children"><div class="content">You probably don&#x27;t need a bundler in the browser anymore. We&#x27;re not yet to the point that is a popular &quot;mainstream&quot; opinion, but between massive improvements in browser connection handling (HTTP 1.1 connection sharing actually works in more places, HTTP&#x2F;2+) and very good ESM support in browser&#x27;s well optimized preloaders and caching engines (which can sometimes reduce download size <i>much better</i> than all-or-none bundles can, sure the trade-off is network requests but we are in a good place to take that trade-off), we&#x27;re at an exciting point where there is almost never a need to bundle in development environments, and it is increasingly an option to not bundle in production either. It is <i>worth</i> benchmarking today (I can&#x27;t tell you what your profiler tools will tell you) if you are really gaining as much from production bundles as you think you are. Not enough people are running those benchmarks, but some of them may already be surprised.<p>The Developer Experience of unbundled ESM is <i>great</i>. Of course you do need to do things like always use file extensions. But those aren&#x27;t hard changes to make, worth it for the better Developer Experience, and if it can help us start to wean off of mega-bundler tools as required production compile time steps.</div><br/><div id="41073588" class="c"><input type="checkbox" id="c-41073588" checked=""/><div class="controls bullet"><span class="by">tubs</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41070016">parent</a><span>|</span><a href="#41065024">next</a><span>|</span><label class="collapse" for="c-41073588">[-]</label><label class="expand" for="c-41073588">[1 more]</label></div><br/><div class="children"><div class="content">Meh. Even with h3 I still see more gains from reducing network requests than most other attempts I try. (One day s3 will support multiple ranges per request, if I wish hard enough).</div><br/></div></div></div></div></div></div><div id="41065024" class="c"><input type="checkbox" id="c-41065024" checked=""/><div class="controls bullet"><span class="by">samtheprogram</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41064704">parent</a><span>|</span><a href="#41065231">prev</a><span>|</span><a href="#41066582">next</a><span>|</span><label class="collapse" for="c-41065024">[-]</label><label class="expand" for="c-41065024">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense. I guess since using .js for the relevant imports just works in TypeScript I should be happy then…</div><br/></div></div><div id="41066582" class="c"><input type="checkbox" id="c-41066582" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41064704">parent</a><span>|</span><a href="#41065024">prev</a><span>|</span><a href="#41067102">next</a><span>|</span><label class="collapse" for="c-41066582">[-]</label><label class="expand" for="c-41066582">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, besides that, leaving out the extension also creates ambiguity when the same filename exists with multiple file extensions.</div><br/></div></div></div></div><div id="41067102" class="c"><input type="checkbox" id="c-41067102" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41064704">prev</a><span>|</span><a href="#41067629">next</a><span>|</span><label class="collapse" for="c-41067102">[-]</label><label class="expand" for="c-41067102">[1 more]</label></div><br/><div class="children"><div class="content">I like Bun a lot, but Deno is (still) the more mature, stable, capable (e.g. stable workers, http2) and depending on the use-case more performant option (V8 &gt; JSC). DX and tooling is top-notch. Deno can perform typchecking, btw. They bundle the TSC IIRC. Bun is the hype, but Deno is currently clearly the better option for serious endevours. Still, the vision and execution of Bun is impressive. Good for us devs.</div><br/></div></div><div id="41067629" class="c"><input type="checkbox" id="c-41067629" checked=""/><div class="controls bullet"><span class="by">XCSme</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41067102">prev</a><span>|</span><a href="#41075327">next</a><span>|</span><label class="collapse" for="c-41067629">[-]</label><label class="expand" for="c-41067629">[1 more]</label></div><br/><div class="children"><div class="content">I tried Bun twice, months apart, it never worked for me on Windows, failing to run &quot;bun install&quot;: <a href="https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Aoven-sh%2Fbun+bun+install&amp;type=issues">https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Aoven-sh%2Fbun+bun+install...</a></div><br/></div></div><div id="41065640" class="c"><input type="checkbox" id="c-41065640" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41075327">prev</a><span>|</span><a href="#41066004">next</a><span>|</span><label class="collapse" for="c-41065640">[-]</label><label class="expand" for="c-41065640">[2 more]</label></div><br/><div class="children"><div class="content">&gt; unprecedented<p>Well except for Deno...</div><br/><div id="41067117" class="c"><input type="checkbox" id="c-41067117" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41065640">parent</a><span>|</span><a href="#41066004">next</a><span>|</span><label class="collapse" for="c-41067117">[-]</label><label class="expand" for="c-41067117">[1 more]</label></div><br/><div class="children"><div class="content">Bun started with compatibility with NodeJS as a primary goal, whereas for Deno it took a while to be able to import npm stuff. (Of course there are fun WTF[0] errors with Bun, and I only tried Deno before the npm import feature landed.)<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;oven-sh&#x2F;bun&#x2F;issues&#x2F;11420">https:&#x2F;&#x2F;github.com&#x2F;oven-sh&#x2F;bun&#x2F;issues&#x2F;11420</a></div><br/></div></div></div></div><div id="41066004" class="c"><input type="checkbox" id="c-41066004" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41065640">prev</a><span>|</span><a href="#41066598">next</a><span>|</span><label class="collapse" for="c-41066004">[-]</label><label class="expand" for="c-41066004">[2 more]</label></div><br/><div class="children"><div class="content">Bun is pretty awesome.<p>However, the node:crypto module still doesn&#x27;t work 100%. So, I can&#x27;t use it yet.</div><br/><div id="41073652" class="c"><input type="checkbox" id="c-41073652" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41066004">parent</a><span>|</span><a href="#41066598">next</a><span>|</span><label class="collapse" for="c-41073652">[-]</label><label class="expand" for="c-41073652">[1 more]</label></div><br/><div class="children"><div class="content">The parallel implementation they do uncovers a number of unexpected behaviors in the node implementation.</div><br/></div></div></div></div><div id="41066598" class="c"><input type="checkbox" id="c-41066598" checked=""/><div class="controls bullet"><span class="by">oblio</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41066004">prev</a><span>|</span><a href="#41065347">next</a><span>|</span><label class="collapse" for="c-41066598">[-]</label><label class="expand" for="c-41066598">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Bun too raw? It&#x27;s built with Zig, which hasn&#x27;t even hit 1.0.</div><br/><div id="41066901" class="c"><input type="checkbox" id="c-41066901" checked=""/><div class="controls bullet"><span class="by">laxis96</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41066598">parent</a><span>|</span><a href="#41073654">next</a><span>|</span><label class="collapse" for="c-41066901">[-]</label><label class="expand" for="c-41066901">[2 more]</label></div><br/><div class="children"><div class="content">Probably had to stay in the oven a bit longer...<p>Jokes apart, Zig is moving forward a lot which is why it&#x27;s not 1.0 yet, but it doesn&#x27;t mean you can&#x27;t write safe and performant applications right now.<p>Zig is also a rather simple and straightforward language (like C) and has powerful compile-time code generation (like C macros, but without the awful preprocessor).</div><br/><div id="41068196" class="c"><input type="checkbox" id="c-41068196" checked=""/><div class="controls bullet"><span class="by">oblio</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41066901">parent</a><span>|</span><a href="#41073654">next</a><span>|</span><label class="collapse" for="c-41068196">[-]</label><label class="expand" for="c-41068196">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m more worried about compilation or stdlib bugs. In theory you can do lots of things with lots of things, but in practice there are all sorts of hidden limitations and bugs that tend to be noticed once a software product is past 1.0 and has been out in the wild for half a decade or more.</div><br/></div></div></div></div><div id="41073654" class="c"><input type="checkbox" id="c-41073654" checked=""/><div class="controls bullet"><span class="by">jokethrowaway</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41066598">parent</a><span>|</span><a href="#41066901">prev</a><span>|</span><a href="#41065347">next</a><span>|</span><label class="collapse" for="c-41073654">[-]</label><label class="expand" for="c-41073654">[2 more]</label></div><br/><div class="children"><div class="content">You still get segmentation faults. My biggest complain with bun is not having enough safety.<p>If you use frameworks written for node memory usage is very high and performance is meh.<p>If you use frameworks written for bun they smoke anything on node.<p>I&#x27;d definitely move over, just to get rid of the whole TypeScript &#x2F; cjs &#x2F; esm crap, but:<p>1. frontend support is poor (next.js &#x2F; solid.js - I can&#x27;t run anything fully on bun)<p>3. I still need to rewrite my backend app from a node.js framework to a bun one<p>4. for backend development the javascript ecosystem is losing the crown: if I wanted something safe I&#x27;d just write it in Rust (TS allows any random developer to write crap with any in it and it validates), if I&#x27;m doing something AI related I&#x27;d probably need python anyway and fastapi is not half bad</div><br/><div id="41076785" class="c"><input type="checkbox" id="c-41076785" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41073654">parent</a><span>|</span><a href="#41065347">next</a><span>|</span><label class="collapse" for="c-41076785">[-]</label><label class="expand" for="c-41076785">[1 more]</label></div><br/><div class="children"><div class="content">We use Bun in production for the entire stack and has done since v1 - only with minor hikups, that all trvivially has been fixed.<p>DX is great!<p>We use vite react ts, yoga, and prisma.</div><br/></div></div></div></div></div></div><div id="41065347" class="c"><input type="checkbox" id="c-41065347" checked=""/><div class="controls bullet"><span class="by">hackandthink</span><span>|</span><a href="#41064589">parent</a><span>|</span><a href="#41066598">prev</a><span>|</span><a href="#41065110">next</a><span>|</span><label class="collapse" for="c-41065347">[-]</label><label class="expand" for="c-41065347">[3 more]</label></div><br/><div class="children"><div class="content">&quot;nor have tsc configured to automatically add .js extensions to its compiled output&quot;<p>It seems to be the default now:<p><pre><code>  $echo &#x27;console.log(&quot;test&quot;)&#x27; &gt; t.ts
  $ tsc t.ts
  $ ls
  t.js  t.ts
  $ node t.js
  test</code></pre></div><br/><div id="41065590" class="c"><input type="checkbox" id="c-41065590" checked=""/><div class="controls bullet"><span class="by">boromisp</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41065347">parent</a><span>|</span><a href="#41065110">next</a><span>|</span><label class="collapse" for="c-41065590">[-]</label><label class="expand" for="c-41065590">[2 more]</label></div><br/><div class="children"><div class="content">What they probably meant was writing &#x27;import &quot;file.ts&quot;&#x27; and have tsc emit &#x27;import &quot;file.js&quot;&#x27;.
<a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;49083">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;49083</a></div><br/><div id="41070063" class="c"><input type="checkbox" id="c-41070063" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#41064589">root</a><span>|</span><a href="#41065590">parent</a><span>|</span><a href="#41065110">next</a><span>|</span><label class="collapse" for="c-41070063">[-]</label><label class="expand" for="c-41070063">[1 more]</label></div><br/><div class="children"><div class="content">Given the context of Node here will allow experimental type-stripping and will not be doing things like import rewriting, Typescript&#x27;s decision here to focus on &quot;users write .js in imports because that&#x27;s how the type-stripped file should look&quot; seems like the right call to me. Less work for a type-stripper because Typescript can already check if there is a .ts or .d.ts file for you if you use .js imports everywhere.</div><br/></div></div></div></div></div></div></div></div><div id="41065110" class="c"><input type="checkbox" id="c-41065110" checked=""/><div class="controls bullet"><span class="by">harshitaneja</span><span>|</span><a href="#41064589">prev</a><span>|</span><a href="#41064573">next</a><span>|</span><label class="collapse" for="c-41065110">[-]</label><label class="expand" for="c-41065110">[69 more]</label></div><br/><div class="children"><div class="content">I really enjoy typescript and have been yearning for a typescript runtime but I can&#x27;t help but laugh that I left java all those years ago to finally seek something a lot closer to java.<p>I guess we all just wanted java with JIT, more feature rich type system and gradual typing. Also for all the shortcomings of npm ecosystem, it is a lot less daunting and more fun to be using libraries in this ecosystem.<p>And surprisingly even though rust is on a different end of the language spectrum but yet it offers a similar feel.<p>Edit:  JIT was not the right terminology to use. I lazily wrote JIT. Apologies. What I meant to convey was the difference in startup times and run time between running something in JVM and V8. Java feels heavy but in javascript ecosystem it feels so nimble.</div><br/><div id="41065243" class="c"><input type="checkbox" id="c-41065243" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065178">next</a><span>|</span><label class="collapse" for="c-41065243">[-]</label><label class="expand" for="c-41065243">[4 more]</label></div><br/><div class="children"><div class="content">&gt; we all just wanted java with JIT<p>Java was literally the thing that made the term &quot;JIT&quot; popular, so I really don&#x27;t know what you were going for here.<p>Also I just can&#x27;t see how Typescript is in any way &quot;closer&quot; to Java - it&#x27;s incredibly different IMHO. The only thing they have in common is probably the &quot;Javascript&quot; misnomer and the fact both support imperative programming, but that&#x27;s it.</div><br/><div id="41065340" class="c"><input type="checkbox" id="c-41065340" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065243">parent</a><span>|</span><a href="#41065178">next</a><span>|</span><label class="collapse" for="c-41065340">[-]</label><label class="expand" for="c-41065340">[3 more]</label></div><br/><div class="children"><div class="content">Typescript’s optional and unsound type system also does nothing for a JIT beyond what it could already do for JavaScript, you can’t do optimization if your types are unreliable. However, I really really like how Typescript’s type system super charges developer productivity (type errors via the compiler and feedback via the IDE), and don’t mind this part of the design at all.</div><br/><div id="41065570" class="c"><input type="checkbox" id="c-41065570" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065340">parent</a><span>|</span><a href="#41065178">next</a><span>|</span><label class="collapse" for="c-41065570">[-]</label><label class="expand" for="c-41065570">[2 more]</label></div><br/><div class="children"><div class="content">You can use typescript types to compile functions. You just might need to deoptimize when you actually hit the function.</div><br/><div id="41075668" class="c"><input type="checkbox" id="c-41075668" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065570">parent</a><span>|</span><a href="#41065178">next</a><span>|</span><label class="collapse" for="c-41075668">[-]</label><label class="expand" for="c-41075668">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know if Vortex-style compilation ever worked in practice.</div><br/></div></div></div></div></div></div></div></div><div id="41065178" class="c"><input type="checkbox" id="c-41065178" checked=""/><div class="controls bullet"><span class="by">bufferoverflow</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065243">prev</a><span>|</span><a href="#41065198">next</a><span>|</span><label class="collapse" for="c-41065178">[-]</label><label class="expand" for="c-41065178">[13 more]</label></div><br/><div class="children"><div class="content">Typescript is way better than Java, in my experience. It&#x27;s a lot less verbose. A lot more flexible.</div><br/><div id="41065789" class="c"><input type="checkbox" id="c-41065789" checked=""/><div class="controls bullet"><span class="by">ZhongXina</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065178">parent</a><span>|</span><a href="#41065384">next</a><span>|</span><label class="collapse" for="c-41065789">[-]</label><label class="expand" for="c-41065789">[6 more]</label></div><br/><div class="children"><div class="content">Better for what? Quickly churning out short-lived code to get the next round of funding, definitely. Writing (and _supporting_) &quot;serious&quot; projects over the long term, which also require high performance and&#x2F;or high scalability, and can rip through terabytes of data if needed, definitely not. (All IMHO from lots of personal experience.)</div><br/><div id="41070105" class="c"><input type="checkbox" id="c-41070105" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065789">parent</a><span>|</span><a href="#41068308">next</a><span>|</span><label class="collapse" for="c-41070105">[-]</label><label class="expand" for="c-41070105">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good for things that don&#x27;t involve ripping through terabytes of data, which is actually a lot of things. And idk if I&#x27;d use Java for that either.</div><br/><div id="41072441" class="c"><input type="checkbox" id="c-41072441" checked=""/><div class="controls bullet"><span class="by">mcluck</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41070105">parent</a><span>|</span><a href="#41068308">next</a><span>|</span><label class="collapse" for="c-41072441">[-]</label><label class="expand" for="c-41072441">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually in this exact position right now. The vast majority of the time I write in TS but I have a need to process a whole lot of data so I went for Rust instead. Java is too much of a headache for me, personally</div><br/><div id="41073430" class="c"><input type="checkbox" id="c-41073430" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41072441">parent</a><span>|</span><a href="#41068308">next</a><span>|</span><label class="collapse" for="c-41073430">[-]</label><label class="expand" for="c-41073430">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Rust is fast, or you can go the other extreme with Python if you can put the heavy lifting on native modules.</div><br/></div></div></div></div></div></div><div id="41068308" class="c"><input type="checkbox" id="c-41068308" checked=""/><div class="controls bullet"><span class="by">viridian</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065789">parent</a><span>|</span><a href="#41070105">prev</a><span>|</span><a href="#41065384">next</a><span>|</span><label class="collapse" for="c-41068308">[-]</label><label class="expand" for="c-41068308">[2 more]</label></div><br/><div class="children"><div class="content">Depends on your architecture. For scaling out rather than up, node and python are both far more performant because the footprint of minimum viable environment is much smaller. When you need to serve anywhere from 10-200,000 requests a minute on the same system quickly, and efficiently, lambda&#x2F;azure functions&#x2F;google app engine backed by node or python is pretty ideal.<p>As an example, when my org needs to contact folks about potential mass shooter events, our SLA is 90 seconds. If we did it in cloud with java or .net, it&#x27;d be too slow to spin up. If we did it on prem, we&#x27;d be charged insane amounts just for the ability to instantly respond to low frequency black swan events, or it&#x27;d be too slow. This is a real story of how a Java dev team transitioned to using node for scale in the first place.</div><br/><div id="41068678" class="c"><input type="checkbox" id="c-41068678" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068308">parent</a><span>|</span><a href="#41065384">next</a><span>|</span><label class="collapse" for="c-41068678">[-]</label><label class="expand" for="c-41068678">[1 more]</label></div><br/><div class="children"><div class="content">Unlike Spring, JIT-based ASP.NET Core deployments spin up very fast (&lt;2-5s for even large-ish applications, the main bottleneck is how fast it can open connections to dependencies, load configuration, etc.). For AOT variant, the startup time is usually below 200ms if we don&#x27;t count the slowness of surrounding infra which applies to any language.<p>Of course CPU and RAM per request when compared to Node.js are not even close as Node is easily slower by a factor of 2-10.</div><br/></div></div></div></div></div></div><div id="41065384" class="c"><input type="checkbox" id="c-41065384" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065178">parent</a><span>|</span><a href="#41065789">prev</a><span>|</span><a href="#41065484">next</a><span>|</span><label class="collapse" for="c-41065384">[-]</label><label class="expand" for="c-41065384">[5 more]</label></div><br/><div class="children"><div class="content">They are not comparable. If anything, Kotlin is the equivalent in the JVM universe.</div><br/><div id="41065738" class="c"><input type="checkbox" id="c-41065738" checked=""/><div class="controls bullet"><span class="by">quonn</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065384">parent</a><span>|</span><a href="#41065484">next</a><span>|</span><label class="collapse" for="c-41065738">[-]</label><label class="expand" for="c-41065738">[4 more]</label></div><br/><div class="children"><div class="content">Kotlin is much closer to Java than to TypeScript even in terms of flexibility.</div><br/><div id="41065792" class="c"><input type="checkbox" id="c-41065792" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065738">parent</a><span>|</span><a href="#41065904">next</a><span>|</span><label class="collapse" for="c-41065792">[-]</label><label class="expand" for="c-41065792">[2 more]</label></div><br/><div class="children"><div class="content">To me &quot;Flexibility&quot; sounds a lot like &quot;The programmer always knows what he does&quot;.</div><br/><div id="41069804" class="c"><input type="checkbox" id="c-41069804" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065792">parent</a><span>|</span><a href="#41065904">next</a><span>|</span><label class="collapse" for="c-41069804">[-]</label><label class="expand" for="c-41069804">[1 more]</label></div><br/><div class="children"><div class="content">Flexibility means for me more something more like, I think I know what I want to do but I also know that I&#x27;m probably wrong about that, so for now let&#x27;s skip all the baroque protocol and let me make it work first. Once I&#x27;m sure I wrote what I actually wanted I&#x27;ll add types if only to get rid of some bugs, consider edge cases and earn nice code completions and auto-generated docs.</div><br/></div></div></div></div><div id="41065904" class="c"><input type="checkbox" id="c-41065904" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065738">parent</a><span>|</span><a href="#41065792">prev</a><span>|</span><a href="#41065484">next</a><span>|</span><label class="collapse" for="c-41065904">[-]</label><label class="expand" for="c-41065904">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but Kotlin is to Java as TypeScript is to JavaScript, which is the point I am making.</div><br/></div></div></div></div></div></div></div></div><div id="41065198" class="c"><input type="checkbox" id="c-41065198" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065178">prev</a><span>|</span><a href="#41065210">next</a><span>|</span><label class="collapse" for="c-41065198">[-]</label><label class="expand" for="c-41065198">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very glad to use typescript over java, personally - the ergonomics are so much better! Especially if you stray away from the somewhat incomplete classes thing (type support for decorator arguments isn&#x27;t great, for instance) and just focus on interfaces and functions.<p>One thing I miss that java has is runtime reflection of types though. Typescript&#x27;s ecosystem has a million different ways to get around that and they&#x27;re all a bit ugly imo.</div><br/></div></div><div id="41065210" class="c"><input type="checkbox" id="c-41065210" checked=""/><div class="controls bullet"><span class="by">zx8080</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065198">prev</a><span>|</span><a href="#41065525">next</a><span>|</span><label class="collapse" for="c-41065210">[-]</label><label class="expand" for="c-41065210">[28 more]</label></div><br/><div class="children"><div class="content">&gt; we all just wanted java with JIT, more feature rich type system<p>Java has JIT. How is TypeSript type system feature-richer than the Java one?</div><br/><div id="41065378" class="c"><input type="checkbox" id="c-41065378" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065210">parent</a><span>|</span><a href="#41065581">next</a><span>|</span><label class="collapse" for="c-41065378">[-]</label><label class="expand" for="c-41065378">[6 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;types-from-types.html" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;types-from-ty...</a><p><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;template-literal-types.html" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;template-lite...</a> alone puts TS over anything that Java has.</div><br/><div id="41066066" class="c"><input type="checkbox" id="c-41066066" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065378">parent</a><span>|</span><a href="#41067936">next</a><span>|</span><label class="collapse" for="c-41066066">[-]</label><label class="expand" for="c-41066066">[4 more]</label></div><br/><div class="children"><div class="content">&gt; alone puts TS over anything that Java has.<p>Virtual Threads alone challenge this assumption.<p>Syntax bloat is not a feature.</div><br/><div id="41066853" class="c"><input type="checkbox" id="c-41066853" checked=""/><div class="controls bullet"><span class="by">Byamarro</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41066066">parent</a><span>|</span><a href="#41066490">next</a><span>|</span><label class="collapse" for="c-41066853">[-]</label><label class="expand" for="c-41066853">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really a syntax bloat, the linked docs mention how to define strict string types and elaborate on type-level programming, something that is a very rare and powerful type-level capability.
As far as I understand Virtual Threads aren&#x27;t type oriented feature, which is basically the context for this thread.</div><br/></div></div><div id="41068267" class="c"><input type="checkbox" id="c-41068267" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41066066">parent</a><span>|</span><a href="#41066490">prev</a><span>|</span><a href="#41067936">next</a><span>|</span><label class="collapse" for="c-41068267">[-]</label><label class="expand" for="c-41068267">[1 more]</label></div><br/><div class="children"><div class="content">Virtual Threads are not a type system feature?</div><br/></div></div></div></div></div></div><div id="41065581" class="c"><input type="checkbox" id="c-41065581" checked=""/><div class="controls bullet"><span class="by">magnio</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065210">parent</a><span>|</span><a href="#41065378">prev</a><span>|</span><a href="#41065269">next</a><span>|</span><label class="collapse" for="c-41065581">[-]</label><label class="expand" for="c-41065581">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use them directly much, but template literal generic and contidiontal types is probably the closest a mainstream language has inched towards dependent types.<p>Some examples of TypeScript power:<p>- SQL database in TypeScript types: <a href="https:&#x2F;&#x2F;github.com&#x2F;codemix&#x2F;ts-sql">https:&#x2F;&#x2F;github.com&#x2F;codemix&#x2F;ts-sql</a><p>- Statically typed raw SQL queries: <a href="https:&#x2F;&#x2F;github.com&#x2F;andywer&#x2F;squid?tab=readme-ov-file#tag-function">https:&#x2F;&#x2F;github.com&#x2F;andywer&#x2F;squid?tab=readme-ov-file#tag-func...</a><p>- (Someone fill in your TS hackery for me)</div><br/><div id="41065686" class="c"><input type="checkbox" id="c-41065686" checked=""/><div class="controls bullet"><span class="by">Vaguely2178</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065581">parent</a><span>|</span><a href="#41065269">next</a><span>|</span><label class="collapse" for="c-41065686">[-]</label><label class="expand" for="c-41065686">[1 more]</label></div><br/><div class="children"><div class="content">There are various programming language interpreters that run entirely in the type system:<p>- BF: <a href="https:&#x2F;&#x2F;github.com&#x2F;susisu&#x2F;typefuck">https:&#x2F;&#x2F;github.com&#x2F;susisu&#x2F;typefuck</a><p>- Assembly: <a href="https:&#x2F;&#x2F;github.com&#x2F;judehunter&#x2F;ts-asm">https:&#x2F;&#x2F;github.com&#x2F;judehunter&#x2F;ts-asm</a></div><br/></div></div></div></div><div id="41065269" class="c"><input type="checkbox" id="c-41065269" checked=""/><div class="controls bullet"><span class="by">VMG</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065210">parent</a><span>|</span><a href="#41065581">prev</a><span>|</span><a href="#41065753">next</a><span>|</span><label class="collapse" for="c-41065269">[-]</label><label class="expand" for="c-41065269">[13 more]</label></div><br/><div class="children"><div class="content">1. *Type Inference*: TypeScript can automatically infer types from context, reducing the need for explicit type declarations.
2. *Union and Intersection Types*: Allows combining multiple types, offering more flexibility in defining data structures.
3. *Literal Types*: TypeScript supports exact values as types (e.g., specific strings or numbers), which can be useful for more precise type-checking.
4. *Type Aliases*: You can create custom, reusable types, enhancing code clarity and maintainability.
5. *Interfaces and Structural Typing*: Interfaces allow for flexible contracts, and TypeScript uses structural typing, where the type compatibility is based on the shape of the data rather than explicit type declarations.
6. *Mapped and Conditional Types*: These allow for dynamic type creation and manipulation, making the type system more powerful and expressive.
7. *Optional Properties and Strict Null Checks*: These provide better handling of undefined and null values.</div><br/><div id="41065374" class="c"><input type="checkbox" id="c-41065374" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065269">parent</a><span>|</span><a href="#41065753">next</a><span>|</span><label class="collapse" for="c-41065374">[-]</label><label class="expand" for="c-41065374">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just an copy-paste of some features, not a comparison with Java which does most of that too.</div><br/><div id="41065431" class="c"><input type="checkbox" id="c-41065431" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065374">parent</a><span>|</span><a href="#41068119">next</a><span>|</span><label class="collapse" for="c-41065431">[-]</label><label class="expand" for="c-41065431">[4 more]</label></div><br/><div class="children"><div class="content">Union types, structural typing, and conditional types are like a big chunck of what makes typescript typescript.<p>It is how TS is able to &quot;type&quot; a completely untyped language.<p>Just the support for union types is something that not even Haskell or Ocaml have.</div><br/><div id="41071439" class="c"><input type="checkbox" id="c-41071439" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065431">parent</a><span>|</span><a href="#41068119">next</a><span>|</span><label class="collapse" for="c-41071439">[-]</label><label class="expand" for="c-41071439">[3 more]</label></div><br/><div class="children"><div class="content">I am not familiar with TypeScript. Is there something that you can achieve with union types that you can’t with sum types or type classes in Haskell?</div><br/><div id="41072175" class="c"><input type="checkbox" id="c-41072175" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41071439">parent</a><span>|</span><a href="#41068119">next</a><span>|</span><label class="collapse" for="c-41072175">[-]</label><label class="expand" for="c-41072175">[2 more]</label></div><br/><div class="children"><div class="content">TL;DR: Typescript is unsound so it can add a lot more type-level features that would make a sound type system undecidable<p>Conceptually no, almost every useful union type can be easily converted to a sum type. In my opinion the difference is in the ergonomics and in the implicit structural subtyping.<p>For example a common union type is <i>number|string</i>, and the beatiful part is that to use a value of such a type you do not need to do any matching or mapping you can just use the value as it does not have a runtime wrapper, for example <i>(x:string|number)=&gt;JSON.stringify(x)</i> works perfectly fine.<p>Also you can have a function that takes as input a <i>Array&lt;string&gt;|number|null</i> and returns a string|number without having to declare different contructors for the input <i>number</i> type and the output <i>number</i> type<p>I believe that you can essentially implement this behaviour by generating enough typeclasses in Haskell, but regardless of the feasibility it, likely, would not be a good idea.<p>An example of something in between union types an Hindley–Milner sum types are Ocaml&#x27;s polymorphic variants types <a href="https:&#x2F;&#x2F;ocaml.org&#x2F;manual&#x2F;5.2&#x2F;types.html#sss:typexpr-polyvar" rel="nofollow">https:&#x2F;&#x2F;ocaml.org&#x2F;manual&#x2F;5.2&#x2F;types.html#sss:typexpr-polyvar</a> that are (I believe) more advanced than TS unions but also a lot less ergonomic to use.<p>And TS has much more eg intersection types you could have a function with type<p><pre><code>    (x:number)=&gt;string &amp; (x:string)=&gt;number
</code></pre>
meaning that it is <i>both</i> a function that maps number to strings and strings to numbers (again you can do this with typeclasses but it is a worse experience)<p>typescript also has very good support for value types for example there is the string type but also the &quot;hello&quot; type which is the type of only the string &quot;hello&quot;<p>All in all if someone told me that they implemented typescript in haskell typeclasses I would not call bullshit on them, but I would not believe that anyone would actually use it for anything</div><br/><div id="41072393" class="c"><input type="checkbox" id="c-41072393" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41072175">parent</a><span>|</span><a href="#41068119">next</a><span>|</span><label class="collapse" for="c-41072393">[-]</label><label class="expand" for="c-41072393">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example a common union type is number|string<p>So that&#x27;s like my beloved Perl then.</div><br/></div></div></div></div></div></div></div></div><div id="41068119" class="c"><input type="checkbox" id="c-41068119" checked=""/><div class="controls bullet"><span class="by">VMG</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065374">parent</a><span>|</span><a href="#41065431">prev</a><span>|</span><a href="#41065488">next</a><span>|</span><label class="collapse" for="c-41068119">[-]</label><label class="expand" for="c-41068119">[6 more]</label></div><br/><div class="children"><div class="content">most of that? name one</div><br/><div id="41068279" class="c"><input type="checkbox" id="c-41068279" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068119">parent</a><span>|</span><a href="#41065488">next</a><span>|</span><label class="collapse" for="c-41068279">[-]</label><label class="expand" for="c-41068279">[5 more]</label></div><br/><div class="children"><div class="content">Java has type inference. Also if a type alias is just a new name for a existing type, then you can always do something like<p><pre><code>  class MyNewClass extends OldClass {};
</code></pre>
(of course it&#x27;s not just a new name, it&#x27;s also a new class, but it&#x27;s also still a OldClass, and you are out of luck if OldClass is final or sealed)<p>Java also has interfaces, of course. And optional properties (using Optional) and strict null checks, when you want that, you can use it.</div><br/><div id="41068693" class="c"><input type="checkbox" id="c-41068693" checked=""/><div class="controls bullet"><span class="by">VMG</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068279">parent</a><span>|</span><a href="#41068684">next</a><span>|</span><label class="collapse" for="c-41068693">[-]</label><label class="expand" for="c-41068693">[3 more]</label></div><br/><div class="children"><div class="content">&gt; type inference<p>very limited, for instance you must declare the type of a public method<p>&gt; alias<p>as you point out it&#x27;s not<p>&gt; Java also has interfaces, of course<p>but you have to implement them explicitly<p>&gt; strict null checks, when you want that, you can use it<p>if we start accepting static analysis tools then C has null checks as well I guess</div><br/><div id="41069472" class="c"><input type="checkbox" id="c-41069472" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068693">parent</a><span>|</span><a href="#41068684">next</a><span>|</span><label class="collapse" for="c-41069472">[-]</label><label class="expand" for="c-41069472">[2 more]</label></div><br/><div class="children"><div class="content">&gt; as you point out it&#x27;s not<p>so what&#x27;s the difference except the name?<p>&gt; if we start accepting static analysis tools<p>I&#x27;m not talking about static analysis. In today&#x27;s Java you can write code that does not accept nulls, if you want to.</div><br/><div id="41070468" class="c"><input type="checkbox" id="c-41070468" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41069472">parent</a><span>|</span><a href="#41068684">next</a><span>|</span><label class="collapse" for="c-41070468">[-]</label><label class="expand" for="c-41070468">[1 more]</label></div><br/><div class="children"><div class="content">You cannot write code that will <i>fail to compile</i> `theEntryMethod(null)` unless you only use primitive types.  (You can, of course, make that method fail at runtime, but that&#x27;s not what&#x27;s being talked about here).</div><br/></div></div></div></div></div></div><div id="41068684" class="c"><input type="checkbox" id="c-41068684" checked=""/><div class="controls bullet"><span class="by">guipsp</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068279">parent</a><span>|</span><a href="#41068693">prev</a><span>|</span><a href="#41065488">next</a><span>|</span><label class="collapse" for="c-41068684">[-]</label><label class="expand" for="c-41068684">[1 more]</label></div><br/><div class="children"><div class="content">Using optional still has the secret third thing problem</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41065753" class="c"><input type="checkbox" id="c-41065753" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065210">parent</a><span>|</span><a href="#41065269">prev</a><span>|</span><a href="#41065525">next</a><span>|</span><label class="collapse" for="c-41065753">[-]</label><label class="expand" for="c-41065753">[6 more]</label></div><br/><div class="children"><div class="content">Java and Typescript have fundamentally different type systems, that lead to drastically different ways to approach types.<p>Utility types, like Partial&lt;T&gt;, are basically impossible to represent in Java except with almost-duplicated classes.</div><br/><div id="41068139" class="c"><input type="checkbox" id="c-41068139" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065753">parent</a><span>|</span><a href="#41065525">next</a><span>|</span><label class="collapse" for="c-41068139">[-]</label><label class="expand" for="c-41068139">[5 more]</label></div><br/><div class="children"><div class="content">&gt; drastically different ways to approach types<p>Exactly.<p>&gt; Partial&lt;T&gt;<p>Looking at that it&#x27;s just what a default POJO (with nullable properties) already is, so I&#x27;d see no need to represent that in Java.<p>Looks cool though and I like Typescript; my issue with it is that it needs transpiling to run. If it was a first-class citizen in an environment I would use it for my pet projects.</div><br/><div id="41070617" class="c"><input type="checkbox" id="c-41070617" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068139">parent</a><span>|</span><a href="#41069072">next</a><span>|</span><label class="collapse" for="c-41070617">[-]</label><label class="expand" for="c-41070617">[1 more]</label></div><br/><div class="children"><div class="content">Yep - all non-primitive types in Java are `TheType | null` - TypeScript actually allows you to strip out the `| null`, which then means that sometimes you want to add it back in.  So Java doesn&#x27;t have a need for `Partial&lt;T&gt;`, it has a need for `NonNull&lt;T&gt;` and it can&#x27;t express that at the type system level very easily right now (you can do it with type tagging and runtime checks inserted explicitly, but it&#x27;s not very ergonomic right now)<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;svieira&#x2F;9f8beeafb7bf4aa55d40c638532f4fd7" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;svieira&#x2F;9f8beeafb7bf4aa55d40c638532f...</a></div><br/></div></div><div id="41069072" class="c"><input type="checkbox" id="c-41069072" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41068139">parent</a><span>|</span><a href="#41070617">prev</a><span>|</span><a href="#41065525">next</a><span>|</span><label class="collapse" for="c-41069072">[-]</label><label class="expand" for="c-41069072">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s just what a default POJO (with nullable properties) already is<p>I think you missed the point. Partial&lt;T&gt; is an example of a &quot;mapped type&quot;, see the handbook for more explanation: <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;mapped-types.html" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;mapped-types....</a></div><br/><div id="41069496" class="c"><input type="checkbox" id="c-41069496" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41069072">parent</a><span>|</span><a href="#41065525">next</a><span>|</span><label class="collapse" for="c-41069496">[-]</label><label class="expand" for="c-41069496">[2 more]</label></div><br/><div class="children"><div class="content">I understand that much, just thinking aloud what problem would that solve in Java.</div><br/><div id="41069937" class="c"><input type="checkbox" id="c-41069937" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41069496">parent</a><span>|</span><a href="#41065525">next</a><span>|</span><label class="collapse" for="c-41069937">[-]</label><label class="expand" for="c-41069937">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s for when you need type that expresses partial data update for an object that has some fields required.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41065525" class="c"><input type="checkbox" id="c-41065525" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065210">prev</a><span>|</span><a href="#41065160">next</a><span>|</span><label class="collapse" for="c-41065525">[-]</label><label class="expand" for="c-41065525">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m somewhere here as well. Personally I think what I want is the stdlib (without the current legacy&#x2F; all but deprecated bits) and ecosystem of c# but with the ease and power of structural algebraic types. AoT is fine, with option for single binary. Ideally runtimeless with clever trimming. If it also ran jitted in the browser all the better.<p>I also want compiler&#x2F;type checker niceties like exhaustive pattern matching.</div><br/></div></div><div id="41065160" class="c"><input type="checkbox" id="c-41065160" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065525">prev</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41065160">[-]</label><label class="expand" for="c-41065160">[11 more]</label></div><br/><div class="children"><div class="content">Java does jit</div><br/><div id="41065222" class="c"><input type="checkbox" id="c-41065222" checked=""/><div class="controls bullet"><span class="by">harshitaneja</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065160">parent</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41065222">[-]</label><label class="expand" for="c-41065222">[10 more]</label></div><br/><div class="children"><div class="content">Yes, JIT was not the right terminology to use. I lazily wrote JIT. Apologies. What I meant to convey was the difference in startup times and run time between running something in JVM and V8. Java feels heavy but in javascript ecosystem it feels so nimble.</div><br/><div id="41065391" class="c"><input type="checkbox" id="c-41065391" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065222">parent</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41065391">[-]</label><label class="expand" for="c-41065391">[9 more]</label></div><br/><div class="children"><div class="content">Native Java via GraalVM starts up in milliseconds.</div><br/><div id="41065423" class="c"><input type="checkbox" id="c-41065423" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065391">parent</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41065423">[-]</label><label class="expand" for="c-41065423">[8 more]</label></div><br/><div class="children"><div class="content">And it has to go through slow compilation step. With Node you can have a cake and eat it too.</div><br/><div id="41066123" class="c"><input type="checkbox" id="c-41066123" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065423">parent</a><span>|</span><a href="#41066301">next</a><span>|</span><label class="collapse" for="c-41066123">[-]</label><label class="expand" for="c-41066123">[3 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t be serious about comparing the technological capabilities of the JVM and Node and objectively declare the latter as the winner.<p>Compilation times are also an absolute non-issue.<p>You don&#x27;t compile for development. You do it for production (in the rare circumstances that you need it).</div><br/><div id="41067356" class="c"><input type="checkbox" id="c-41067356" checked=""/><div class="controls bullet"><span class="by">harshitaneja</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41066123">parent</a><span>|</span><a href="#41066353">next</a><span>|</span><label class="collapse" for="c-41067356">[-]</label><label class="expand" for="c-41067356">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what I am trying to convey here. JVM is amazing and it is a feat that java is as fast as it is and javascript and v8 are order of magnitude slower.<p>Also even though I also found java too verbose, I kept believing that we need it to be so to write good software. I still enjoy java but it doesn&#x27;t compare to the ergonomics of typescript for me. And nimbleness of the experience according to me plays a decent role.<p>Currently for me, either I really care about performance and I default to rust for those applications or I need solutions where the product will evolve quickly over time and I need great DX over performance and I default to typescript for those.<p>Java definitely has a role to play but its role in my work has certainly diminished.</div><br/></div></div></div></div><div id="41066301" class="c"><input type="checkbox" id="c-41066301" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065423">parent</a><span>|</span><a href="#41066123">prev</a><span>|</span><a href="#41065865">next</a><span>|</span><label class="collapse" for="c-41066301">[-]</label><label class="expand" for="c-41066301">[1 more]</label></div><br/><div class="children"><div class="content">It does not &quot;have&quot; to go through such a step, by the way, because you can simply run such code on the JVM.</div><br/></div></div><div id="41065865" class="c"><input type="checkbox" id="c-41065865" checked=""/><div class="controls bullet"><span class="by">ZhongXina</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065423">parent</a><span>|</span><a href="#41066301">prev</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41065865">[-]</label><label class="expand" for="c-41065865">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re saying it like it&#x27;s an absolutely good thing. Some (many?) users would rather pay the cost upfront in compilation time (doesn&#x27;t really matter if it&#x27;s AOT or JIT) than pay the same cost many times over through a significantly slower runtime. JVM also scales up to supercomputers (and everything in between) if you want it to, so depending on your requirements a single-threaded alternative might not even be an option.</div><br/><div id="41065947" class="c"><input type="checkbox" id="c-41065947" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065865">parent</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41065947">[-]</label><label class="expand" for="c-41065947">[2 more]</label></div><br/><div class="children"><div class="content">I’ll use C++ or Rust for such use cases.</div><br/><div id="41066208" class="c"><input type="checkbox" id="c-41066208" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065947">parent</a><span>|</span><a href="#41065414">next</a><span>|</span><label class="collapse" for="c-41066208">[-]</label><label class="expand" for="c-41066208">[1 more]</label></div><br/><div class="children"><div class="content">Okay!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41065414" class="c"><input type="checkbox" id="c-41065414" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065160">prev</a><span>|</span><a href="#41066163">next</a><span>|</span><label class="collapse" for="c-41065414">[-]</label><label class="expand" for="c-41065414">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also for all the shortcomings of npm ecosystem, it is a lot less daunting and more fun to be using libraries in this ecosystem.<p>God I wish they’d just integrate something lightweight like npm into JDK.<p>It is beyond me why you have to install third-party heavy weight tool just to manage dependencies.</div><br/></div></div><div id="41066163" class="c"><input type="checkbox" id="c-41066163" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065414">prev</a><span>|</span><a href="#41070122">next</a><span>|</span><label class="collapse" for="c-41066163">[-]</label><label class="expand" for="c-41066163">[1 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s type system was just very limited, gradual typing is a poor tradeoff most of the time. I used to think there were advantages to something like Python, but once I found Scala I never went back.</div><br/></div></div><div id="41070122" class="c"><input type="checkbox" id="c-41070122" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41066163">prev</a><span>|</span><a href="#41065244">next</a><span>|</span><label class="collapse" for="c-41070122">[-]</label><label class="expand" for="c-41070122">[1 more]</label></div><br/><div class="children"><div class="content">The type system is a big part of what made Java cumbersome. It&#x27;s loosened up a little over the years. TS itself may allow partial typing, but when team&#x2F;company policies are involved, you&#x27;ll often end up being forced to type everything.</div><br/></div></div><div id="41065244" class="c"><input type="checkbox" id="c-41065244" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41070122">prev</a><span>|</span><a href="#41069710">next</a><span>|</span><label class="collapse" for="c-41065244">[-]</label><label class="expand" for="c-41065244">[2 more]</label></div><br/><div class="children"><div class="content">&gt; gradual typing<p>AKA dynamic typing. Unless it&#x27;s 100% static, it&#x27;s dynamic</div><br/><div id="41067154" class="c"><input type="checkbox" id="c-41067154" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065244">parent</a><span>|</span><a href="#41069710">next</a><span>|</span><label class="collapse" for="c-41067154">[-]</label><label class="expand" for="c-41067154">[1 more]</label></div><br/><div class="children"><div class="content">Gradual typing could still keep some static guarantees if the static part were sound, e.g. you couldn&#x27;t assign a dynamic-typed integer to a string-typed variable without checking the type at runtime first; which TypeScript isn&#x27;t.<p>Elixir&#x27;s new type system does much better here, as it determines whether a function actually guards for the right type at runtime (&quot;strong arrows&quot;) and propagates the guarantees, or lack thereof, accordingly.</div><br/></div></div></div></div><div id="41069710" class="c"><input type="checkbox" id="c-41069710" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065244">prev</a><span>|</span><a href="#41065211">next</a><span>|</span><label class="collapse" for="c-41069710">[-]</label><label class="expand" for="c-41069710">[1 more]</label></div><br/><div class="children"><div class="content">Gradual typing is the key. The problem with Java is that types are in your face way before you actually need them.<p>With TS you can prototype with JS and only after you know what you are looking for you can start to add types to find bugs and edge cases and want to get nice code completions for your stuff.</div><br/></div></div><div id="41065211" class="c"><input type="checkbox" id="c-41065211" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41069710">prev</a><span>|</span><a href="#41065818">next</a><span>|</span><label class="collapse" for="c-41065211">[-]</label><label class="expand" for="c-41065211">[1 more]</label></div><br/><div class="children"><div class="content">Not having an opaque tech stack encumbered by a patent minefield is another plus.</div><br/></div></div><div id="41065818" class="c"><input type="checkbox" id="c-41065818" checked=""/><div class="controls bullet"><span class="by">tomjen3</span><span>|</span><a href="#41065110">parent</a><span>|</span><a href="#41065211">prev</a><span>|</span><a href="#41064573">next</a><span>|</span><label class="collapse" for="c-41065818">[-]</label><label class="expand" for="c-41065818">[3 more]</label></div><br/><div class="children"><div class="content">The typesystem of Java was so laughably unpowerful that it severely constrained what you could write.<p>In Typescript you have far more freedom, and all the benefits of strong types.</div><br/><div id="41068034" class="c"><input type="checkbox" id="c-41068034" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065818">parent</a><span>|</span><a href="#41066130">next</a><span>|</span><label class="collapse" for="c-41068034">[-]</label><label class="expand" for="c-41068034">[1 more]</label></div><br/><div class="children"><div class="content">The fact that Java forced you to write types, and then made everything implicitly nullable so that you still get NullPointerExceptions at runtime after writing out all those types, was probably a big reason why dynamically-typed languages became popular.</div><br/></div></div><div id="41066130" class="c"><input type="checkbox" id="c-41066130" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41065110">root</a><span>|</span><a href="#41065818">parent</a><span>|</span><a href="#41068034">prev</a><span>|</span><a href="#41064573">next</a><span>|</span><label class="collapse" for="c-41066130">[-]</label><label class="expand" for="c-41066130">[1 more]</label></div><br/><div class="children"><div class="content">Strong types without strong typing that is.</div><br/></div></div></div></div></div></div><div id="41064573" class="c"><input type="checkbox" id="c-41064573" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#41065110">prev</a><span>|</span><a href="#41064671">next</a><span>|</span><label class="collapse" for="c-41064573">[-]</label><label class="expand" for="c-41064573">[24 more]</label></div><br/><div class="children"><div class="content">My favorite deno feature is coming to node directly. Awesome!<p>Maybe this means I don&#x27;t always have to install esbuild to strip types - very excited how this will make writing scripts in TypeScript that much easier to use. I lately have been prefering Python for one off scripts, but I do think personally TypeScript &gt; Python wrt types. And larger scripts really benefit from types especially when looking at them again after a few months.</div><br/><div id="41064623" class="c"><input type="checkbox" id="c-41064623" checked=""/><div class="controls bullet"><span class="by">yamumsahoe</span><span>|</span><a href="#41064573">parent</a><span>|</span><a href="#41066457">next</a><span>|</span><label class="collapse" for="c-41064623">[-]</label><label class="expand" for="c-41064623">[13 more]</label></div><br/><div class="children"><div class="content">btw if anyone is looking to run ts on node, there is tsx. there is also ts-node but i prefer tsx.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;privatenumber&#x2F;tsx">https:&#x2F;&#x2F;github.com&#x2F;privatenumber&#x2F;tsx</a></div><br/><div id="41065055" class="c"><input type="checkbox" id="c-41065055" checked=""/><div class="controls bullet"><span class="by">iansinnott</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064623">parent</a><span>|</span><a href="#41064840">next</a><span>|</span><label class="collapse" for="c-41065055">[-]</label><label class="expand" for="c-41065055">[6 more]</label></div><br/><div class="children"><div class="content">Seconded again. While tsx usually just works ts-node almost never just works. tsx is perhaps unfortunately named though so it may confuse people at first since it has nothing to do with jsx syntax.</div><br/><div id="41065162" class="c"><input type="checkbox" id="c-41065162" checked=""/><div class="controls bullet"><span class="by">jimvdv</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065055">parent</a><span>|</span><a href="#41070758">next</a><span>|</span><label class="collapse" for="c-41065162">[-]</label><label class="expand" for="c-41065162">[4 more]</label></div><br/><div class="children"><div class="content">Thank you for bringing this up, I almost ignored this project since I assumed it had something to do with TypeScript + JSX.<p>The JS ecosystem sure struggles with naming things.</div><br/><div id="41074339" class="c"><input type="checkbox" id="c-41074339" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065162">parent</a><span>|</span><a href="#41065287">next</a><span>|</span><label class="collapse" for="c-41074339">[-]</label><label class="expand" for="c-41074339">[1 more]</label></div><br/><div class="children"><div class="content">I own the npm package node-ts, which has thousands of installs per week just because people confuse it with ts-node.<p>I didn&#x27;t intend to typo-squat. Actually, my package is older than ts-node and was just a pun because it is an API for TeamSpeak written in TypeScript.</div><br/></div></div><div id="41065287" class="c"><input type="checkbox" id="c-41065287" checked=""/><div class="controls bullet"><span class="by">tommica</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065162">parent</a><span>|</span><a href="#41074339">prev</a><span>|</span><a href="#41070758">next</a><span>|</span><label class="collapse" for="c-41065287">[-]</label><label class="expand" for="c-41065287">[2 more]</label></div><br/><div class="children"><div class="content">The _programming_ ecosystem sure struggles with naming things.</div><br/><div id="41068516" class="c"><input type="checkbox" id="c-41068516" checked=""/><div class="controls bullet"><span class="by">jimvdv</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065287">parent</a><span>|</span><a href="#41070758">next</a><span>|</span><label class="collapse" for="c-41068516">[-]</label><label class="expand" for="c-41068516">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough</div><br/></div></div></div></div></div></div><div id="41070758" class="c"><input type="checkbox" id="c-41070758" checked=""/><div class="controls bullet"><span class="by">tills13</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065055">parent</a><span>|</span><a href="#41065162">prev</a><span>|</span><a href="#41064840">next</a><span>|</span><label class="collapse" for="c-41070758">[-]</label><label class="expand" for="c-41070758">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s named as such to mirror `npx`</div><br/></div></div></div></div><div id="41064840" class="c"><input type="checkbox" id="c-41064840" checked=""/><div class="controls bullet"><span class="by">jessym</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064623">parent</a><span>|</span><a href="#41065055">prev</a><span>|</span><a href="#41066836">next</a><span>|</span><label class="collapse" for="c-41064840">[-]</label><label class="expand" for="c-41064840">[1 more]</label></div><br/><div class="children"><div class="content">I second this. The tsx library is zero config and always &quot;just works&quot; in my experience, which puts it miles ahead of ts-node, imo.</div><br/></div></div><div id="41066836" class="c"><input type="checkbox" id="c-41066836" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064623">parent</a><span>|</span><a href="#41064840">prev</a><span>|</span><a href="#41066599">next</a><span>|</span><label class="collapse" for="c-41066836">[-]</label><label class="expand" for="c-41066836">[1 more]</label></div><br/><div class="children"><div class="content">Tsx’s only reset-in-console mode is &lt;Enter&gt;, which makes it impossible to develop cli apps in watch mode.<p>You cannot run tsx from a non-project cwd if you’re using tsconfig&#x2F;paths.<p>And personally I find its maintainers relatively unpleasant to message with. Leaves “you’re plebs” aftertaste most of the times.</div><br/></div></div><div id="41066599" class="c"><input type="checkbox" id="c-41066599" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064623">parent</a><span>|</span><a href="#41066836">prev</a><span>|</span><a href="#41066457">next</a><span>|</span><label class="collapse" for="c-41066599">[-]</label><label class="expand" for="c-41066599">[4 more]</label></div><br/><div class="children"><div class="content">tsx has very slow startup performance, I prefer <a href="https:&#x2F;&#x2F;github.com&#x2F;swc-project&#x2F;swc-node">https:&#x2F;&#x2F;github.com&#x2F;swc-project&#x2F;swc-node</a> which is around twice as fast.</div><br/><div id="41074228" class="c"><input type="checkbox" id="c-41074228" checked=""/><div class="controls bullet"><span class="by">dimgl</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41066599">parent</a><span>|</span><a href="#41067541">next</a><span>|</span><label class="collapse" for="c-41074228">[-]</label><label class="expand" for="c-41074228">[1 more]</label></div><br/><div class="children"><div class="content">We have not seen this whatsoever. How big is your project? `tsx` is almost instantaneous in a server-side project of ours.</div><br/></div></div><div id="41067541" class="c"><input type="checkbox" id="c-41067541" checked=""/><div class="controls bullet"><span class="by">herpdyderp</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41066599">parent</a><span>|</span><a href="#41074228">prev</a><span>|</span><a href="#41066457">next</a><span>|</span><label class="collapse" for="c-41067541">[-]</label><label class="expand" for="c-41067541">[2 more]</label></div><br/><div class="children"><div class="content">Does swc-node work with code coverage calculation libraries? For a long time tsx didn’t (and it’s still pretty finicky) so that kept me from using it.</div><br/><div id="41069043" class="c"><input type="checkbox" id="c-41069043" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41067541">parent</a><span>|</span><a href="#41066457">next</a><span>|</span><label class="collapse" for="c-41069043">[-]</label><label class="expand" for="c-41069043">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what features those need, but at least the stack traces are correct in swc-node, so maybe worth a try.</div><br/></div></div></div></div></div></div></div></div><div id="41066457" class="c"><input type="checkbox" id="c-41066457" checked=""/><div class="controls bullet"><span class="by">medv</span><span>|</span><a href="#41064573">parent</a><span>|</span><a href="#41064623">prev</a><span>|</span><a href="#41064596">next</a><span>|</span><label class="collapse" for="c-41066457">[-]</label><label class="expand" for="c-41066457">[2 more]</label></div><br/><div class="children"><div class="content">Have you tried <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;zx">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;zx</a>?</div><br/><div id="41066880" class="c"><input type="checkbox" id="c-41066880" checked=""/><div class="controls bullet"><span class="by">tnzk</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41066457">parent</a><span>|</span><a href="#41064596">next</a><span>|</span><label class="collapse" for="c-41066880">[-]</label><label class="expand" for="c-41066880">[1 more]</label></div><br/><div class="children"><div class="content">This seems very interesting approach to scripting. Does it basically provides with an alias to child_process.exec as $ and besides that I can write in the same way I&#x27;d do in Node?<p>&gt; Node.js standard library requires additional hassle before using<p>I read the hassle as having to setup Node runtime in advance, but zx requires npm to install so I&#x27;m not sure.</div><br/></div></div></div></div><div id="41064596" class="c"><input type="checkbox" id="c-41064596" checked=""/><div class="controls bullet"><span class="by">yamumsahoe</span><span>|</span><a href="#41064573">parent</a><span>|</span><a href="#41066457">prev</a><span>|</span><a href="#41064671">next</a><span>|</span><label class="collapse" for="c-41064596">[-]</label><label class="expand" for="c-41064596">[8 more]</label></div><br/><div class="children"><div class="content">correction: the only deno future that i want</div><br/><div id="41064956" class="c"><input type="checkbox" id="c-41064956" checked=""/><div class="controls bullet"><span class="by">sholladay</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064596">parent</a><span>|</span><a href="#41067140">next</a><span>|</span><label class="collapse" for="c-41064956">[-]</label><label class="expand" for="c-41064956">[6 more]</label></div><br/><div class="children"><div class="content">Deno has so many other great features. Most web standard APIs are available in Deno, for example. It can do URL imports. It has a built in linter, formatter, and test framework. Built in documentation generator. A much better built in web server.<p>Node is copying many of these features to varying degrees of success. But Deno is evolving, too.</div><br/><div id="41065135" class="c"><input type="checkbox" id="c-41065135" checked=""/><div class="controls bullet"><span class="by">johnny22</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064956">parent</a><span>|</span><a href="#41065248">next</a><span>|</span><label class="collapse" for="c-41065135">[-]</label><label class="expand" for="c-41065135">[4 more]</label></div><br/><div class="children"><div class="content">the url imports is one the things I don&#x27;t want.</div><br/><div id="41069743" class="c"><input type="checkbox" id="c-41069743" checked=""/><div class="controls bullet"><span class="by">sholladay</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065135">parent</a><span>|</span><a href="#41065241">next</a><span>|</span><label class="collapse" for="c-41069743">[-]</label><label class="expand" for="c-41069743">[2 more]</label></div><br/><div class="children"><div class="content">You want to be forced to use a centralized registry? I don’t know. URL imports also enable fully isomorphic modules. I think you would enjoy the freedom of URL imports if the ergonomics were better. For example, it should just default to <a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a> so you don’t have to type that. Import maps also help a lot with this, definitely use them. But they could be even better by having first-class support for templating the module version into the URL so that the version can be stored separately, alongside the module name. Popular hosts with well-known URL structures could have their URLs automatically templated so you only have to specify the host and not the rest of the URL.<p>In other words, the tooling could be better, but the fundamentals of URL imports are sound, IMO.</div><br/><div id="41070772" class="c"><input type="checkbox" id="c-41070772" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41069743">parent</a><span>|</span><a href="#41065241">next</a><span>|</span><label class="collapse" for="c-41070772">[-]</label><label class="expand" for="c-41070772">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. It should not default to &quot;<a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a>&quot; (I think defaulting to local files would be better).<p>Furthermore, I think that it should be made so that the &quot;hashed:&quot; scheme that I had invented (in the Scorpion protocol&#x2F;file-format specification document, although this scheme can be used independently of that) can also be usable.<p>And, popular hosts with well-known URL structures automatically templating also I would disagree, although it might do to allow any expressions in place of the string literals and then add functions for abbreviations of some of those URLs, if that would help (although I still think it is unnecessary).</div><br/></div></div></div></div><div id="41065241" class="c"><input type="checkbox" id="c-41065241" checked=""/><div class="controls bullet"><span class="by">niklasmtj</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41065135">parent</a><span>|</span><a href="#41069743">prev</a><span>|</span><a href="#41065248">next</a><span>|</span><label class="collapse" for="c-41065241">[-]</label><label class="expand" for="c-41065241">[1 more]</label></div><br/><div class="children"><div class="content">There are also the `npm:`, `node:` and `jsr:` specifiers now. So you <i>don&#x27;t</i> have to use the URL imports if you don&#x27;t feel them.</div><br/></div></div></div></div><div id="41065248" class="c"><input type="checkbox" id="c-41065248" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064956">parent</a><span>|</span><a href="#41065135">prev</a><span>|</span><a href="#41067140">next</a><span>|</span><label class="collapse" for="c-41065248">[-]</label><label class="expand" for="c-41065248">[1 more]</label></div><br/><div class="children"><div class="content">Node supports URL imports via the --experimental-network-imports command line option. There&#x27;s also a built in test runner now.</div><br/></div></div></div></div><div id="41067140" class="c"><input type="checkbox" id="c-41067140" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#41064573">root</a><span>|</span><a href="#41064596">parent</a><span>|</span><a href="#41064956">prev</a><span>|</span><a href="#41064671">next</a><span>|</span><label class="collapse" for="c-41067140">[-]</label><label class="expand" for="c-41067140">[1 more]</label></div><br/><div class="children"><div class="content">... and obviously the only one you know.<p>Kidding aside: You should really take an hour and check out the manual and std lib (<a href="https:&#x2F;&#x2F;jsr.io&#x2F;@std" rel="nofollow">https:&#x2F;&#x2F;jsr.io&#x2F;@std</a>). I was surprised how far Deno has come. A lot of pretty useful stuff you would otherwise need tons of NPM modules for.</div><br/></div></div></div></div></div></div><div id="41064671" class="c"><input type="checkbox" id="c-41064671" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41064573">prev</a><span>|</span><a href="#41066492">next</a><span>|</span><label class="collapse" for="c-41064671">[-]</label><label class="expand" for="c-41064671">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a really eventful month for Node. First they added node:sqlite in v22.5.0, and now TypeScript support is landing. I love the direction Node is heading in.</div><br/><div id="41066236" class="c"><input type="checkbox" id="c-41066236" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41064671">parent</a><span>|</span><a href="#41065069">next</a><span>|</span><label class="collapse" for="c-41066236">[-]</label><label class="expand" for="c-41066236">[3 more]</label></div><br/><div class="children"><div class="content">It is Bun influence &#x2F; competition I guess. Good for everyone.</div><br/><div id="41067511" class="c"><input type="checkbox" id="c-41067511" checked=""/><div class="controls bullet"><span class="by">mark_and_sweep</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41066236">parent</a><span>|</span><a href="#41065069">next</a><span>|</span><label class="collapse" for="c-41067511">[-]</label><label class="expand" for="c-41067511">[2 more]</label></div><br/><div class="children"><div class="content">I believe the competition started with Deno. But yes, Bun is part of the competition now, too.</div><br/><div id="41067584" class="c"><input type="checkbox" id="c-41067584" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41067511">parent</a><span>|</span><a href="#41065069">next</a><span>|</span><label class="collapse" for="c-41067584">[-]</label><label class="expand" for="c-41067584">[1 more]</label></div><br/><div class="children"><div class="content">Deno was doing its own thing though.<p>Bun came out swinging with strong Node.JS compatibility promises. I have simply replaced node with bun for most of my own work without much effort. The mental effort required is to use `bun` instead of `node` in command line for most of the trivial things.</div><br/></div></div></div></div></div></div><div id="41065069" class="c"><input type="checkbox" id="c-41065069" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064671">parent</a><span>|</span><a href="#41066236">prev</a><span>|</span><a href="#41066492">next</a><span>|</span><label class="collapse" for="c-41065069">[-]</label><label class="expand" for="c-41065069">[8 more]</label></div><br/><div class="children"><div class="content">The recently-added test runner is very cool too!</div><br/><div id="41065099" class="c"><input type="checkbox" id="c-41065099" checked=""/><div class="controls bullet"><span class="by">SwiftyBug</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41065069">parent</a><span>|</span><a href="#41066318">next</a><span>|</span><label class="collapse" for="c-41065099">[-]</label><label class="expand" for="c-41065099">[5 more]</label></div><br/><div class="children"><div class="content">YES. It was such a joy to be able to ditch Jest completely and run tests natively.</div><br/><div id="41065706" class="c"><input type="checkbox" id="c-41065706" checked=""/><div class="controls bullet"><span class="by">joseferben</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41065099">parent</a><span>|</span><a href="#41066318">next</a><span>|</span><label class="collapse" for="c-41065706">[-]</label><label class="expand" for="c-41065706">[4 more]</label></div><br/><div class="children"><div class="content">i tried that but had to revert to vitest, the native test runner feels incomplete atm.</div><br/><div id="41065795" class="c"><input type="checkbox" id="c-41065795" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41065706">parent</a><span>|</span><a href="#41066318">next</a><span>|</span><label class="collapse" for="c-41065795">[-]</label><label class="expand" for="c-41065795">[3 more]</label></div><br/><div class="children"><div class="content">What is missing for your use case or workflow?</div><br/><div id="41071627" class="c"><input type="checkbox" id="c-41071627" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41065795">parent</a><span>|</span><a href="#41066318">next</a><span>|</span><label class="collapse" for="c-41071627">[-]</label><label class="expand" for="c-41071627">[2 more]</label></div><br/><div class="children"><div class="content">Probably a bunch of assertion types and general DX. Node:test is just a feature, Vitest is a whole product. The former might be enough for small packages but nowhere near useful for anything non-trivial.</div><br/><div id="41075407" class="c"><input type="checkbox" id="c-41075407" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41071627">parent</a><span>|</span><a href="#41066318">next</a><span>|</span><label class="collapse" for="c-41075407">[-]</label><label class="expand" for="c-41075407">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough. We still use Jest at work for exactly those reasons. In my personal projects, I prefer to minimise dependencies rather than get every DX benefit I can.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41066318" class="c"><input type="checkbox" id="c-41066318" checked=""/><div class="controls bullet"><span class="by">conaclos</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41065069">parent</a><span>|</span><a href="#41065099">prev</a><span>|</span><a href="#41069913">next</a><span>|</span><label class="collapse" for="c-41066318">[-]</label><label class="expand" for="c-41066318">[1 more]</label></div><br/><div class="children"><div class="content">I tested it a few months ago. However, the output isn&#x27;t very human friendly.</div><br/></div></div><div id="41069913" class="c"><input type="checkbox" id="c-41069913" checked=""/><div class="controls bullet"><span class="by">herpdyderp</span><span>|</span><a href="#41064671">root</a><span>|</span><a href="#41065069">parent</a><span>|</span><a href="#41066318">prev</a><span>|</span><a href="#41066492">next</a><span>|</span><label class="collapse" for="c-41069913">[-]</label><label class="expand" for="c-41069913">[1 more]</label></div><br/><div class="children"><div class="content">I just started using it the other day and it’s a dream. I look forward to the eventual stability of their snapshot testing.</div><br/></div></div></div></div></div></div><div id="41066492" class="c"><input type="checkbox" id="c-41066492" checked=""/><div class="controls bullet"><span class="by">satanacchio</span><span>|</span><a href="#41064671">prev</a><span>|</span><a href="#41066463">next</a><span>|</span><label class="collapse" for="c-41066492">[-]</label><label class="expand" for="c-41066492">[4 more]</label></div><br/><div class="children"><div class="content">Hi I&#x27;m the author of the PR, AMA</div><br/><div id="41067608" class="c"><input type="checkbox" id="c-41067608" checked=""/><div class="controls bullet"><span class="by">mostafah</span><span>|</span><a href="#41066492">parent</a><span>|</span><a href="#41068709">next</a><span>|</span><label class="collapse" for="c-41067608">[-]</label><label class="expand" for="c-41067608">[1 more]</label></div><br/><div class="children"><div class="content">Thank you a lot. Great work. I know it’s still experimental, but over time it will have a big impact on developer experience and will simplify the development workflow for a lot of projects.</div><br/></div></div><div id="41068709" class="c"><input type="checkbox" id="c-41068709" checked=""/><div class="controls bullet"><span class="by">Shacklz</span><span>|</span><a href="#41066492">parent</a><span>|</span><a href="#41067608">prev</a><span>|</span><a href="#41066463">next</a><span>|</span><label class="collapse" for="c-41068709">[-]</label><label class="expand" for="c-41068709">[2 more]</label></div><br/><div class="children"><div class="content">Great work, many thanks!<p>Out of curiosity, what do you see as next steps, and what possible futures do you see for typescript in the node- and overall JS-ecosystem?</div><br/><div id="41069341" class="c"><input type="checkbox" id="c-41069341" checked=""/><div class="controls bullet"><span class="by">satanacchio</span><span>|</span><a href="#41066492">root</a><span>|</span><a href="#41068709">parent</a><span>|</span><a href="#41066463">next</a><span>|</span><label class="collapse" for="c-41069341">[-]</label><label class="expand" for="c-41069341">[1 more]</label></div><br/><div class="children"><div class="content">this is the roadmap <a href="https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;loaders&#x2F;issues&#x2F;217">https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;loaders&#x2F;issues&#x2F;217</a>.
We talked with the typescript team and we will give each other continous feedback on the progression. We made sure to take some precautions in order to avoid breaking the ecosystem. I still think in production, js is the way to go, so users should always transpile their ts files.</div><br/></div></div></div></div></div></div><div id="41066463" class="c"><input type="checkbox" id="c-41066463" checked=""/><div class="controls bullet"><span class="by">gaptoothclan</span><span>|</span><a href="#41066492">prev</a><span>|</span><a href="#41076216">next</a><span>|</span><label class="collapse" for="c-41066463">[-]</label><label class="expand" for="c-41066463">[9 more]</label></div><br/><div class="children"><div class="content">A long time ago I started converted to using node js for backend work, seemed to offer many benefits over writing code in PHP without bringing many problems of Java. I found node to be somewhat clunky and a language where you had to bolt it together to get the language you wanted. Eventually started writing golang and it felt much easier to write, sometimes way more verbose but the type safety just made coding simpler.<p>Typescript seemed like a good option but was just another bolt on, I am not sure what value you gain by using Typescript over Golang, you have nice defined types which is great but it does not solve other issues with the language that are resolved in golang (also solved in deno).<p>One large benefit of using node over golang is the speed of prototyping something which I think having to use type script largely negates, so I can not really decide if this is a good step forwards or is making node loose some qualities that made it a good choice in other ways.</div><br/><div id="41066604" class="c"><input type="checkbox" id="c-41066604" checked=""/><div class="controls bullet"><span class="by">bezier-curve</span><span>|</span><a href="#41066463">parent</a><span>|</span><a href="#41066529">next</a><span>|</span><label class="collapse" for="c-41066604">[-]</label><label class="expand" for="c-41066604">[3 more]</label></div><br/><div class="children"><div class="content">Typescript is safer JS. You&#x27;re still using JS with TS. The &quot;bolted on&quot; phrasing makes me think your issue may be more the absence of more opinionated frameworks like Django, that manage everything out of the box. I love using Django, but it&#x27;s a little harder to go off the beaten path with it.</div><br/><div id="41070177" class="c"><input type="checkbox" id="c-41070177" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#41066463">root</a><span>|</span><a href="#41066604">parent</a><span>|</span><a href="#41066637">next</a><span>|</span><label class="collapse" for="c-41070177">[-]</label><label class="expand" for="c-41070177">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Bolted on&quot; is how I&#x27;d describe it too. Using TS means messing a lot more with random config files. And standard tools like the NodeJS profiler don&#x27;t work with TS, which hopefully will change soon.<p>I&#x27;ve never used Django. Express seems a lot nicer.</div><br/></div></div><div id="41066637" class="c"><input type="checkbox" id="c-41066637" checked=""/><div class="controls bullet"><span class="by">gaptoothclan</span><span>|</span><a href="#41066463">root</a><span>|</span><a href="#41066604">parent</a><span>|</span><a href="#41070177">prev</a><span>|</span><a href="#41066529">next</a><span>|</span><label class="collapse" for="c-41066637">[-]</label><label class="expand" for="c-41066637">[1 more]</label></div><br/><div class="children"><div class="content">My phrasing there was a direct comparison of developer experience between golang and nodejs. Golang has a very complete core library, I try to avoid frameworks as much as possible. For me I rarely have to think about the language or ecosystem, everything I want or need is already part of the language, testing, linting are some great examples</div><br/></div></div></div></div><div id="41066529" class="c"><input type="checkbox" id="c-41066529" checked=""/><div class="controls bullet"><span class="by">__alias</span><span>|</span><a href="#41066463">parent</a><span>|</span><a href="#41066604">prev</a><span>|</span><a href="#41066503">next</a><span>|</span><label class="collapse" for="c-41066529">[-]</label><label class="expand" for="c-41066529">[3 more]</label></div><br/><div class="children"><div class="content">I mean the obvious answer is language familiarity, 
If your projects frontend code is in javascript&#x2F;typescript ( which it is ), then using node is an easy choice. Shared libraries, shared types, etc etc</div><br/><div id="41066611" class="c"><input type="checkbox" id="c-41066611" checked=""/><div class="controls bullet"><span class="by">gaptoothclan</span><span>|</span><a href="#41066463">root</a><span>|</span><a href="#41066529">parent</a><span>|</span><a href="#41066560">next</a><span>|</span><label class="collapse" for="c-41066611">[-]</label><label class="expand" for="c-41066611">[1 more]</label></div><br/><div class="children"><div class="content">I was in the paradigm, there was very little code reuse from front to backend, some time performing validation I would like to have that option, but I would not have that as a killer feature that determined the language I use.</div><br/></div></div><div id="41066560" class="c"><input type="checkbox" id="c-41066560" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41066463">root</a><span>|</span><a href="#41066529">parent</a><span>|</span><a href="#41066611">prev</a><span>|</span><a href="#41066503">next</a><span>|</span><label class="collapse" for="c-41066560">[-]</label><label class="expand" for="c-41066560">[1 more]</label></div><br/><div class="children"><div class="content">Lots of people do of course use other languages for the frontend. (Or go for thin frontends, ala HTMX )</div><br/></div></div></div></div><div id="41066503" class="c"><input type="checkbox" id="c-41066503" checked=""/><div class="controls bullet"><span class="by">_joel</span><span>|</span><a href="#41066463">parent</a><span>|</span><a href="#41066529">prev</a><span>|</span><a href="#41076216">next</a><span>|</span><label class="collapse" for="c-41066503">[-]</label><label class="expand" for="c-41066503">[2 more]</label></div><br/><div class="children"><div class="content">I guess if you already know Javascript, or have inhouse experience vs. learning Go. We use it with cdktf as previous fe experience, seemed logical vs. Go</div><br/><div id="41066585" class="c"><input type="checkbox" id="c-41066585" checked=""/><div class="controls bullet"><span class="by">gaptoothclan</span><span>|</span><a href="#41066463">root</a><span>|</span><a href="#41066503">parent</a><span>|</span><a href="#41076216">next</a><span>|</span><label class="collapse" for="c-41066585">[-]</label><label class="expand" for="c-41066585">[1 more]</label></div><br/><div class="children"><div class="content">sorry was going to add that there are probably more javascript developers in the jobs market, although there is a limit to the usefulness of these developers.<p>In the company I worked at we were fairly small and did not have huge applications running on node, so it made that journey easier</div><br/></div></div></div></div></div></div><div id="41076216" class="c"><input type="checkbox" id="c-41076216" checked=""/><div class="controls bullet"><span class="by">apatheticonion</span><span>|</span><a href="#41066463">prev</a><span>|</span><a href="#41064564">next</a><span>|</span><label class="collapse" for="c-41076216">[-]</label><label class="expand" for="c-41076216">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how this handles import resolution.<p>type: module requires file extensions and does not support importing folders like most people are used to so it will not be compatible with most existing Typescript code.<p>Will it transform esm import syntax into require statements?<p>I&#x27;d prefer it break existing code to enforce correctness</div><br/></div></div><div id="41064564" class="c"><input type="checkbox" id="c-41064564" checked=""/><div class="controls bullet"><span class="by">vithalreddy</span><span>|</span><a href="#41076216">prev</a><span>|</span><a href="#41064557">next</a><span>|</span><label class="collapse" for="c-41064564">[-]</label><label class="expand" for="c-41064564">[4 more]</label></div><br/><div class="children"><div class="content">Simply amazing!<p>I wonder bun and deno support for typescript played a big role here :)</div><br/><div id="41064708" class="c"><input type="checkbox" id="c-41064708" checked=""/><div class="controls bullet"><span class="by">matrixhelix</span><span>|</span><a href="#41064564">parent</a><span>|</span><a href="#41064606">next</a><span>|</span><label class="collapse" for="c-41064708">[-]</label><label class="expand" for="c-41064708">[1 more]</label></div><br/><div class="children"><div class="content">This is why competition is important</div><br/></div></div><div id="41064606" class="c"><input type="checkbox" id="c-41064606" checked=""/><div class="controls bullet"><span class="by">yamumsahoe</span><span>|</span><a href="#41064564">parent</a><span>|</span><a href="#41064708">prev</a><span>|</span><a href="#41064557">next</a><span>|</span><label class="collapse" for="c-41064606">[-]</label><label class="expand" for="c-41064606">[2 more]</label></div><br/><div class="children"><div class="content">i do wish nodejs adopts uwebsockets (totally what makes bun fast)</div><br/><div id="41067176" class="c"><input type="checkbox" id="c-41067176" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#41064564">root</a><span>|</span><a href="#41064606">parent</a><span>|</span><a href="#41064557">next</a><span>|</span><label class="collapse" for="c-41067176">[-]</label><label class="expand" for="c-41067176">[1 more]</label></div><br/><div class="children"><div class="content">Yes, many aren&#x27;t aware of that. If nodes webserver performance is not enough, you could always use uwebsocktsjs or hyperexpress with node.</div><br/></div></div></div></div></div></div><div id="41064557" class="c"><input type="checkbox" id="c-41064557" checked=""/><div class="controls bullet"><span class="by">me_vinayakakv</span><span>|</span><a href="#41064564">prev</a><span>|</span><a href="#41064692">next</a><span>|</span><label class="collapse" for="c-41064557">[-]</label><label class="expand" for="c-41064557">[11 more]</label></div><br/><div class="children"><div class="content">Nice to see Node.js getting parity on this with Deno and Bun</div><br/><div id="41064578" class="c"><input type="checkbox" id="c-41064578" checked=""/><div class="controls bullet"><span class="by">Klaster_1</span><span>|</span><a href="#41064557">parent</a><span>|</span><a href="#41064583">next</a><span>|</span><label class="collapse" for="c-41064578">[-]</label><label class="expand" for="c-41064578">[6 more]</label></div><br/><div class="children"><div class="content">This reminds me of io.js situation, where in the end major fork changes were incorporated into Node. This is why I am comfortable staying with Node and npm for my projects - the features will eventually trickle down anyway.</div><br/><div id="41065934" class="c"><input type="checkbox" id="c-41065934" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41064578">parent</a><span>|</span><a href="#41064613">next</a><span>|</span><label class="collapse" for="c-41065934">[-]</label><label class="expand" for="c-41065934">[1 more]</label></div><br/><div class="children"><div class="content">This is the “enterprise” approach and it’s a solid one in my book. I do think drop-ins like Bun and PNPM are always great, however, and we’ve adopted both where it has made sense. I don’t think Bun will make sense very often as it’s only when you really need the performance the added maintenance becomes worth it. Especially right now where it’s not exactly stable for a lot of things. PNPM however is often very great compared to NPM and doesn’t add much maintenance as the tooling essentially gives your developers a very similar experience.<p>I’m also not sure the features will eventually “tickle down”. I’m not sure NPM wants to adopt the advantages PNPM gives you as an example, and it’s probably a good thing too considering the basis of NPM is just a really solid system to build on top of which it wouldn’t be if it was very opinionated. One of the big issues Node has today is that it was very opinionated with CommonJS, which made sense at the time, but is a ginormous pain in the butt in the modern world. Though the blame is obviously not with Node alone.</div><br/></div></div><div id="41064613" class="c"><input type="checkbox" id="c-41064613" checked=""/><div class="controls bullet"><span class="by">ibash</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41064578">parent</a><span>|</span><a href="#41065934">prev</a><span>|</span><a href="#41064583">next</a><span>|</span><label class="collapse" for="c-41064613">[-]</label><label class="expand" for="c-41064613">[4 more]</label></div><br/><div class="children"><div class="content">But in the meantime you suffer for it.<p>How many days have you spent on webpack config? Or the package.json type property? Or yarn&#x2F;pnpm&#x2F;etc particulars?<p>I have spent too many.<p>Bun is quite nice.</div><br/><div id="41065101" class="c"><input type="checkbox" id="c-41065101" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41064613">parent</a><span>|</span><a href="#41064786">next</a><span>|</span><label class="collapse" for="c-41065101">[-]</label><label class="expand" for="c-41065101">[2 more]</label></div><br/><div class="children"><div class="content">Is Bun&#x27;s bundler on par with webpack for features? You can&#x27;t escape webpack* if you&#x27;re targeting frontend.<p>*Or vite, or whatever equivalent.</div><br/><div id="41068133" class="c"><input type="checkbox" id="c-41068133" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41065101">parent</a><span>|</span><a href="#41064786">next</a><span>|</span><label class="collapse" for="c-41068133">[-]</label><label class="expand" for="c-41068133">[1 more]</label></div><br/><div class="children"><div class="content">Using vite <i>is</i> escaping webpack!</div><br/></div></div></div></div><div id="41064786" class="c"><input type="checkbox" id="c-41064786" checked=""/><div class="controls bullet"><span class="by">Klaster_1</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41064613">parent</a><span>|</span><a href="#41065101">prev</a><span>|</span><a href="#41064583">next</a><span>|</span><label class="collapse" for="c-41064786">[-]</label><label class="expand" for="c-41064786">[1 more]</label></div><br/><div class="children"><div class="content">Very true, rising popularity of deno and bun clearly indicate that new runtimes solve real issues people have. That&#x27;s why I mentioned &quot;my projects&quot;, your experience may vary.</div><br/></div></div></div></div></div></div><div id="41064583" class="c"><input type="checkbox" id="c-41064583" checked=""/><div class="controls bullet"><span class="by">theflyinghorse</span><span>|</span><a href="#41064557">parent</a><span>|</span><a href="#41064578">prev</a><span>|</span><a href="#41064692">next</a><span>|</span><label class="collapse" for="c-41064583">[-]</label><label class="expand" for="c-41064583">[4 more]</label></div><br/><div class="children"><div class="content">On the topic of typescript - yes. However Bun has a lot more tools baked in than Node does at (bun test for instance). Would be real nice to see Node start adopting more ideas from Bun and others.</div><br/><div id="41064620" class="c"><input type="checkbox" id="c-41064620" checked=""/><div class="controls bullet"><span class="by">iecheruo</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41064583">parent</a><span>|</span><a href="#41065986">next</a><span>|</span><label class="collapse" for="c-41064620">[-]</label><label class="expand" for="c-41064620">[1 more]</label></div><br/><div class="children"><div class="content">Give node a closer look, it&#x27;s been quietly accruing those features.<p>node has a built in test runner now<p><a href="https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;test.html" rel="nofollow">https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;test.html</a></div><br/></div></div><div id="41065986" class="c"><input type="checkbox" id="c-41065986" checked=""/><div class="controls bullet"><span class="by">joshmanders</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41064583">parent</a><span>|</span><a href="#41064620">prev</a><span>|</span><a href="#41064692">next</a><span>|</span><label class="collapse" for="c-41065986">[-]</label><label class="expand" for="c-41065986">[2 more]</label></div><br/><div class="children"><div class="content">I find it interesting that everyone looks at Bun and shames Node saying they need to catch up to Bun and implement stuff Bun has but Node doesn&#x27;t, yet nobody is like Bun should catch up with feature parity of Node. Node isn&#x27;t trying to replace Bun, Bun is trying to replace Node so it should be the one who needs to match parity.</div><br/><div id="41066088" class="c"><input type="checkbox" id="c-41066088" checked=""/><div class="controls bullet"><span class="by">pfg_</span><span>|</span><a href="#41064557">root</a><span>|</span><a href="#41065986">parent</a><span>|</span><a href="#41064692">next</a><span>|</span><label class="collapse" for="c-41066088">[-]</label><label class="expand" for="c-41066088">[1 more]</label></div><br/><div class="children"><div class="content">Bun is doing that - every update usually has node compat fixes or improvements and the list of supported modules has gone up significantly since it was released</div><br/></div></div></div></div></div></div></div></div><div id="41064692" class="c"><input type="checkbox" id="c-41064692" checked=""/><div class="controls bullet"><span class="by">Shacklz</span><span>|</span><a href="#41064557">prev</a><span>|</span><a href="#41075919">next</a><span>|</span><label class="collapse" for="c-41064692">[-]</label><label class="expand" for="c-41064692">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m honestly giddy. This could be the (slow) beginning of a new era, where &quot;JS with types&quot; is finally a native thing.<p>I&#x27;m even willing to forgive all the mess that CJS vs. ESM is if they manage to pull this off.<p>I hope this sees widespread adoption&#x2F;usage, which might <i>finally</i> cause some movement to integrate TS into ecmascript after all. Some dynamically-typed language fanatics (which are, in my opinion, completely detached from the reality that static types are what the vast majority of devs want) still have an iron grip on TC39, this might be the start of their end. And good riddance.</div><br/><div id="41064845" class="c"><input type="checkbox" id="c-41064845" checked=""/><div class="controls bullet"><span class="by">yashap</span><span>|</span><a href="#41064692">parent</a><span>|</span><a href="#41065427">next</a><span>|</span><label class="collapse" for="c-41064845">[-]</label><label class="expand" for="c-41064845">[8 more]</label></div><br/><div class="children"><div class="content">Yeah, my personal experience is that easily 95% of devs I work with&#x2F;have met in person, if not closer to 99%, prefer statically typed languages. Maybe that’s a biased sample, but I do think the overall preference among devs is very strong. I also see JS slowly, more-or-less becoming TypeScript over time.</div><br/><div id="41064944" class="c"><input type="checkbox" id="c-41064944" checked=""/><div class="controls bullet"><span class="by">tstrimple</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41064845">parent</a><span>|</span><a href="#41065294">next</a><span>|</span><label class="collapse" for="c-41064944">[-]</label><label class="expand" for="c-41064944">[5 more]</label></div><br/><div class="children"><div class="content">My days of being a real software developer are long behind me. So I&#x27;m totally willing to accept that I&#x27;m wrong here. But when I build a POC in particular, there&#x27;s a LOT of power and flexibility granted by not giving a fuck about types.  Suddenly I can accept non well defined data types (depending on my implementation) and can persist data that otherwise would have taken code changes and approval processes to accept. I do believe there is a place for types, but to type all the things is folly. There are capabilities within JavaScript to handle both.</div><br/><div id="41065155" class="c"><input type="checkbox" id="c-41065155" checked=""/><div class="controls bullet"><span class="by">iamsaitam</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41064944">parent</a><span>|</span><a href="#41065799">next</a><span>|</span><label class="collapse" for="c-41065155">[-]</label><label class="expand" for="c-41065155">[1 more]</label></div><br/><div class="children"><div class="content">The malicious beauty of typescript is that at any point you can just declare something &quot;any&quot; and voilá, the guard rails are off.</div><br/></div></div><div id="41065799" class="c"><input type="checkbox" id="c-41065799" checked=""/><div class="controls bullet"><span class="by">miunau</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41064944">parent</a><span>|</span><a href="#41065155">prev</a><span>|</span><a href="#41068317">next</a><span>|</span><label class="collapse" for="c-41065799">[-]</label><label class="expand" for="c-41065799">[2 more]</label></div><br/><div class="children"><div class="content">Just use `any` or `unknown` when prototyping, then apply types once your happy paths start working for the first time to start catching the unhappy ones.</div><br/><div id="41068020" class="c"><input type="checkbox" id="c-41068020" checked=""/><div class="controls bullet"><span class="by">djeastm</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41065799">parent</a><span>|</span><a href="#41068317">next</a><span>|</span><label class="collapse" for="c-41068020">[-]</label><label class="expand" for="c-41068020">[1 more]</label></div><br/><div class="children"><div class="content">&gt;then apply types once your happy paths start working for the first time to start catching the unhappy ones.<p>I.e. the &quot;I&#x27;ll go back and add safety later&quot; strategy. Somehow I never seem to get around to doing it.</div><br/></div></div></div></div><div id="41068317" class="c"><input type="checkbox" id="c-41068317" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41064944">parent</a><span>|</span><a href="#41065799">prev</a><span>|</span><a href="#41065294">next</a><span>|</span><label class="collapse" for="c-41068317">[-]</label><label class="expand" for="c-41068317">[1 more]</label></div><br/><div class="children"><div class="content"><i>when I build a POC in particular, there&#x27;s a LOT of power and flexibility granted by not giving a fuck about types</i><p>I find the same thing, but only for <i>very</i> small throwaway scripts and the like. For anything beyond like 20 lines of code, I rapidly hit confusing cases like “is this parameter just a map, or a map or maps?” Then I add types and it makes sense again.</div><br/></div></div></div></div><div id="41065294" class="c"><input type="checkbox" id="c-41065294" checked=""/><div class="controls bullet"><span class="by">spaceheater</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41064845">parent</a><span>|</span><a href="#41064944">prev</a><span>|</span><a href="#41065427">next</a><span>|</span><label class="collapse" for="c-41065294">[-]</label><label class="expand" for="c-41065294">[2 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s make it 94 then. I think typescript is an abomination forced by java developers that don&#x27;t want to learn javascript.</div><br/><div id="41065493" class="c"><input type="checkbox" id="c-41065493" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41065294">parent</a><span>|</span><a href="#41065427">next</a><span>|</span><label class="collapse" for="c-41065493">[-]</label><label class="expand" for="c-41065493">[1 more]</label></div><br/><div class="children"><div class="content">Guard rails on a bridge are an abomination forced onto us by government because people don’t want to learn how to fly.</div><br/></div></div></div></div></div></div><div id="41065427" class="c"><input type="checkbox" id="c-41065427" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41064692">parent</a><span>|</span><a href="#41064845">prev</a><span>|</span><a href="#41075919">next</a><span>|</span><label class="collapse" for="c-41065427">[-]</label><label class="expand" for="c-41065427">[4 more]</label></div><br/><div class="children"><div class="content">&gt; the reality that static types are what the vast majority of devs want<p>[citation needed]</div><br/><div id="41065486" class="c"><input type="checkbox" id="c-41065486" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41065427">parent</a><span>|</span><a href="#41065688">next</a><span>|</span><label class="collapse" for="c-41065486">[-]</label><label class="expand" for="c-41065486">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations?tab=readme-ov-file#community-usage-and-demand">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations?tab=readme...</a><p>You’re welcome.</div><br/><div id="41069892" class="c"><input type="checkbox" id="c-41069892" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41065486">parent</a><span>|</span><a href="#41065688">next</a><span>|</span><label class="collapse" for="c-41069892">[-]</label><label class="expand" for="c-41069892">[1 more]</label></div><br/><div class="children"><div class="content">This is not what GP asked for. That&#x27;s the most requested feature from the state of JS survey.<p>I bet the percentage of web developers who want this are a tiny minority. There are just too many issues with this.<p>Static typing without the benefits of better runtime performance, soundness, strong typing etc. is basically just documentation&#x2F;comments with extra steps.<p>Also TS is a complex, moving target. Most devs don&#x27;t want to learn new fancy features every couple of months, but prefer stability guarantees. Several notable projects have moved away from TS. Even Ryan Dahl admitted that integrating Deno with TS was probably a mistake.<p>Meanwhile you have WASM slowly and steadily getting crucial features on a sound foundation.<p>I&#x27;m extremely cautious about TS and wary of the hype surrounding it.</div><br/></div></div></div></div><div id="41065688" class="c"><input type="checkbox" id="c-41065688" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#41064692">root</a><span>|</span><a href="#41065427">parent</a><span>|</span><a href="#41065486">prev</a><span>|</span><a href="#41075919">next</a><span>|</span><label class="collapse" for="c-41065688">[-]</label><label class="expand" for="c-41065688">[1 more]</label></div><br/><div class="children"><div class="content">The reaction emoji on the merged PR are not particularly ambiguous.</div><br/></div></div></div></div></div></div><div id="41075919" class="c"><input type="checkbox" id="c-41075919" checked=""/><div class="controls bullet"><span class="by">hpeter</span><span>|</span><a href="#41064692">prev</a><span>|</span><a href="#41069477">next</a><span>|</span><label class="collapse" for="c-41075919">[-]</label><label class="expand" for="c-41075919">[1 more]</label></div><br/><div class="children"><div class="content">So, how much slower is it than running js?</div><br/></div></div><div id="41069477" class="c"><input type="checkbox" id="c-41069477" checked=""/><div class="controls bullet"><span class="by">65n56nm5665m56</span><span>|</span><a href="#41075919">prev</a><span>|</span><a href="#41066556">next</a><span>|</span><label class="collapse" for="c-41069477">[-]</label><label class="expand" for="c-41069477">[6 more]</label></div><br/><div class="children"><div class="content">I beg of thee, do not do this. I get that people love typescript but I am already running into a problem where javascript resources are written in typescript by default with nothing for regular javascript. This is the same problem that happened when JQuery hit its peak popularity and an overwhelming amount of resources and guides amounted to &quot;Oh just do this in JQuery&quot;</div><br/><div id="41070099" class="c"><input type="checkbox" id="c-41070099" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41069477">parent</a><span>|</span><a href="#41069749">next</a><span>|</span><label class="collapse" for="c-41070099">[-]</label><label class="expand" for="c-41070099">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>javascript resources are written in typescript by default with nothing for regular javascript. This is the same problem that happened when JQuery hit its peak popularity</i><p>That&#x27;s definitely a potential issue - JavaScript is the fundamental standard, not JQuery and not TypeScript. Certainly there are situations where maximum forward-compatibility is important (learning resources are a good example) and for those, vanilla JavaScript is the best choice.<p>All of the old resources that relied on JQuery are now hopelessly outdated, whereas the contemporary ones that used plain JavaScript are as valid now as when they were written. I&#x27;m sure the same will be true of TypeScript vs JavaScript when the next big thing comes along.</div><br/><div id="41071413" class="c"><input type="checkbox" id="c-41071413" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#41069477">root</a><span>|</span><a href="#41070099">parent</a><span>|</span><a href="#41069749">next</a><span>|</span><label class="collapse" for="c-41071413">[-]</label><label class="expand" for="c-41071413">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the contemporary ones that used plain JavaScript are as valid now as when they were written.<p>True, but on the other hand, almost any JS code snippet written 20 years ago has better and more elegant alternatives today. APIs evolve all the time.</div><br/></div></div></div></div><div id="41069906" class="c"><input type="checkbox" id="c-41069906" checked=""/><div class="controls bullet"><span class="by">lolrsten349</span><span>|</span><a href="#41069477">parent</a><span>|</span><a href="#41069749">prev</a><span>|</span><a href="#41066556">next</a><span>|</span><label class="collapse" for="c-41069906">[-]</label><label class="expand" for="c-41069906">[2 more]</label></div><br/><div class="children"><div class="content">Tell me you&#x27;re out of touch without telling me that you&#x27;re out of touch.<p>jQuery was so popular because writing anymore than a few lines of vanilla JavaScript was an *awful* experience due to all differences in browsers.<p>When things eventually standardized-ish and jQuery became unnecessary, other libraries&#x2F;ecosystems popped up (e.g. React&#x2F;JSX) to make writing webapps easier because writing anymore than a few lines of vanilla JavaScript was still an *awful* experience.<p>When webapps grew in size and scope, other &quot;transpiled&quot; languages popped up (e.g. TypeScript) because writing anymore than a few lines of vanilla JavaScript is *still an awful* experience.<p>We&#x27;re stuck with JavaScript due to past decisions, but let&#x27;s not pretend it&#x27;s actually a good tool. If it were we wouldn&#x27;t need 50,000 tools&#x2F;frameworks&#x2F;transpiled languages to hide how terrible it is.</div><br/><div id="41071704" class="c"><input type="checkbox" id="c-41071704" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#41069477">root</a><span>|</span><a href="#41069906">parent</a><span>|</span><a href="#41066556">next</a><span>|</span><label class="collapse" for="c-41071704">[-]</label><label class="expand" for="c-41071704">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript is not terrible and I don’t understand where you got that from. Since ES2015 came out, it’s actually rather pleasant.</div><br/></div></div></div></div></div></div><div id="41066556" class="c"><input type="checkbox" id="c-41066556" checked=""/><div class="controls bullet"><span class="by">jvanveen</span><span>|</span><a href="#41069477">prev</a><span>|</span><a href="#41064605">next</a><span>|</span><label class="collapse" for="c-41066556">[-]</label><label class="expand" for="c-41066556">[2 more]</label></div><br/><div class="children"><div class="content">I just switched to Bun for typescript support, a free bundler and better performance. Iojs flashback all over :)</div><br/><div id="41067638" class="c"><input type="checkbox" id="c-41067638" checked=""/><div class="controls bullet"><span class="by">XCSme</span><span>|</span><a href="#41066556">parent</a><span>|</span><a href="#41064605">next</a><span>|</span><label class="collapse" for="c-41067638">[-]</label><label class="expand" for="c-41067638">[1 more]</label></div><br/><div class="children"><div class="content">Does Bun always work for you? For me, none of my projects worked to run &quot;bun install&quot; on.</div><br/></div></div></div></div><div id="41064605" class="c"><input type="checkbox" id="c-41064605" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41066556">prev</a><span>|</span><a href="#41064577">next</a><span>|</span><label class="collapse" for="c-41064605">[-]</label><label class="expand" for="c-41064605">[51 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about time for TC39 and Microsoft to standardize TypeScript as part of JavaScript. Not &quot;types as comments&quot; either, but actually TypeScript, minus the non-standard runtime semantics and modulo whatever changes are necessary to integrate the grammar.<p>So many runtimes and tools are integrating TypeScript now, and with multiple implementations, that a real standard is necessary. It&#x27;ll be much harder to evolve TypeScript because it&#x27;ll have to stay backwards compatible, but it&#x27;s grown to that point now, imo.</div><br/><div id="41064737" class="c"><input type="checkbox" id="c-41064737" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41076153">next</a><span>|</span><label class="collapse" for="c-41064737">[-]</label><label class="expand" for="c-41064737">[6 more]</label></div><br/><div class="children"><div class="content">I would rather let Typescript evolve a few more years before freezing its development via standardization</div><br/><div id="41064998" class="c"><input type="checkbox" id="c-41064998" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064737">parent</a><span>|</span><a href="#41067151">next</a><span>|</span><label class="collapse" for="c-41064998">[-]</label><label class="expand" for="c-41064998">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested to know what are some things that you (or anyone reading this) feels that Typescript is missing &#x2F; should change?</div><br/><div id="41067364" class="c"><input type="checkbox" id="c-41067364" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064998">parent</a><span>|</span><a href="#41072958">next</a><span>|</span><label class="collapse" for="c-41067364">[-]</label><label class="expand" for="c-41067364">[1 more]</label></div><br/><div class="children"><div class="content">One example:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;30551">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;30551</a><p>Which goes to <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;9998">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;9998</a> which captures a lot of such scenarios<p>And just a few releases ago there were some big problems with handling recursive types. I think most are fixed but there may still be a few around.<p>These are things that you run into on a daily basis if you write enough TypeScript.<p>I doubt we should standardize TypeScript before we have definitive solutions to all these. And I 100% agree with the parent&#x27;s comment.</div><br/></div></div><div id="41072958" class="c"><input type="checkbox" id="c-41072958" checked=""/><div class="controls bullet"><span class="by">low_tech_punk</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064998">parent</a><span>|</span><a href="#41067364">prev</a><span>|</span><a href="#41066375">next</a><span>|</span><label class="collapse" for="c-41072958">[-]</label><label class="expand" for="c-41072958">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s helpful to analyze TypeScript&#x27;s track record in deprecating features and creating breaking changes, which could be a big red flag to TC39. I&#x27;m all for typing support but my work is mostly prototyping on short lived projects. People maintaining production systems that will eventually become legacy systems might have a different opinion.</div><br/></div></div><div id="41066375" class="c"><input type="checkbox" id="c-41066375" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064998">parent</a><span>|</span><a href="#41072958">prev</a><span>|</span><a href="#41067151">next</a><span>|</span><label class="collapse" for="c-41066375">[-]</label><label class="expand" for="c-41066375">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a list and I don&#x27;t even write TS (or do much web dev in general), but I do follow their announcements and it seems every one of them brings new big type things.<p>Nevertheless, I don&#x27;t see TS support in e.g. browsers being anything useful, as in practice all JS code deployed is already packaged somehow, so the stage to convert TS to JS (and then also checking the types..) fits that just fine. It&#x27;s useful for hobbyists, but I don&#x27;t that is a reason enough to come up with a standard.</div><br/></div></div></div></div><div id="41067151" class="c"><input type="checkbox" id="c-41067151" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064737">parent</a><span>|</span><a href="#41064998">prev</a><span>|</span><a href="#41076153">next</a><span>|</span><label class="collapse" for="c-41067151">[-]</label><label class="expand" for="c-41067151">[1 more]</label></div><br/><div class="children"><div class="content">C++ and Java are quite good at churning out standard docs and new versions every few years. (Even Python is aiming to offer GIL-lessness!)</div><br/></div></div></div></div><div id="41076153" class="c"><input type="checkbox" id="c-41076153" checked=""/><div class="controls bullet"><span class="by">nektro</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41064737">prev</a><span>|</span><a href="#41064648">next</a><span>|</span><label class="collapse" for="c-41076153">[-]</label><label class="expand" for="c-41076153">[1 more]</label></div><br/><div class="children"><div class="content">TC39 standardizing TypeScript as part of JavaScript would be a critical error. TC39&#x27;s job is to look at all the options and make something better. TypeScript won out in popularity due to its tight integration with VSCode. it&#x27;s not necessarily the best route for the core language.</div><br/></div></div><div id="41064648" class="c"><input type="checkbox" id="c-41064648" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41076153">prev</a><span>|</span><a href="#41069170">next</a><span>|</span><label class="collapse" for="c-41064648">[-]</label><label class="expand" for="c-41064648">[18 more]</label></div><br/><div class="children"><div class="content">This has been proposed for several years now, but there&#x27;s been very little progress on it:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations</a></div><br/><div id="41064680" class="c"><input type="checkbox" id="c-41064680" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064648">parent</a><span>|</span><a href="#41069170">next</a><span>|</span><label class="collapse" for="c-41064680">[-]</label><label class="expand" for="c-41064680">[17 more]</label></div><br/><div class="children"><div class="content">That is &quot;types as comments&quot;, not standardizing TypeScript.</div><br/><div id="41064723" class="c"><input type="checkbox" id="c-41064723" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064680">parent</a><span>|</span><a href="#41069170">next</a><span>|</span><label class="collapse" for="c-41064723">[-]</label><label class="expand" for="c-41064723">[16 more]</label></div><br/><div class="children"><div class="content">It is explicitly not type as comments, it is type erasure</div><br/><div id="41065083" class="c"><input type="checkbox" id="c-41065083" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064723">parent</a><span>|</span><a href="#41067013">next</a><span>|</span><label class="collapse" for="c-41065083">[-]</label><label class="expand" for="c-41065083">[1 more]</label></div><br/><div class="children"><div class="content">That has no bearing on the comment you&#x27;re replying to.<p>The point is that the types could be TypeScript, Flow, Hegel, or something else. The browser won&#x27;t perform type checking, it will just ignore the types.<p>So, it is not standardising TypeScript.</div><br/></div></div><div id="41067013" class="c"><input type="checkbox" id="c-41067013" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064723">parent</a><span>|</span><a href="#41065083">prev</a><span>|</span><a href="#41065094">next</a><span>|</span><label class="collapse" for="c-41067013">[-]</label><label class="expand" for="c-41067013">[1 more]</label></div><br/><div class="children"><div class="content">It explicitly is, from the link<p>&gt; At runtime, a JavaScript engine ignores them, treating the <i>types as comments</i>.<p>The phrasing here is that the types are meaningless. They are just &quot;comments&quot; to the JS engine.</div><br/></div></div><div id="41065094" class="c"><input type="checkbox" id="c-41065094" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064723">parent</a><span>|</span><a href="#41067013">prev</a><span>|</span><a href="#41064778">next</a><span>|</span><label class="collapse" for="c-41065094">[-]</label><label class="expand" for="c-41065094">[1 more]</label></div><br/><div class="children"><div class="content">I believe you and several of your child comments might be confusing &quot;types as comments&quot; with &quot;types in comments&quot;.</div><br/></div></div><div id="41064778" class="c"><input type="checkbox" id="c-41064778" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064723">parent</a><span>|</span><a href="#41065094">prev</a><span>|</span><a href="#41069170">next</a><span>|</span><label class="collapse" for="c-41064778">[-]</label><label class="expand" for="c-41064778">[12 more]</label></div><br/><div class="children"><div class="content">&gt; This proposal aims to enable developers to add type annotations to their JavaScript code, allowing those annotations to be checked by a type checker that is external to JavaScript. At runtime, a JavaScript engine ignores them, treating the types as comments.</div><br/><div id="41064806" class="c"><input type="checkbox" id="c-41064806" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064778">parent</a><span>|</span><a href="#41069170">next</a><span>|</span><label class="collapse" for="c-41064806">[-]</label><label class="expand" for="c-41064806">[11 more]</label></div><br/><div class="children"><div class="content">Yes, that’s explaining what type erasure is. “type as comments” is what Flow supports, literal comments for type annotations.<p>I think we disagree on the terminology but agree on the goal of the proposal</div><br/><div id="41064883" class="c"><input type="checkbox" id="c-41064883" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064806">parent</a><span>|</span><a href="#41064865">next</a><span>|</span><label class="collapse" for="c-41064883">[-]</label><label class="expand" for="c-41064883">[1 more]</label></div><br/><div class="children"><div class="content">&quot;types as comments&quot; is the term that the champions and reviewers of this proposal have been using.<p>It refers to how the types are parsed: aside from some kind of standard start and end delimiters, the parser does not try to parse the expression-level type syntax. Type expressions are just strings of characters. This way you can have basically any syntax at all for types.</div><br/></div></div><div id="41064865" class="c"><input type="checkbox" id="c-41064865" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064806">parent</a><span>|</span><a href="#41064883">prev</a><span>|</span><a href="#41064832">next</a><span>|</span><label class="collapse" for="c-41064865">[-]</label><label class="expand" for="c-41064865">[3 more]</label></div><br/><div class="children"><div class="content">The proposal would explicitly treat supported type annotation syntax <i>as comments in the grammar</i>. It is definitely types as comments, even if it is <i>also</i> type erasure.<p>And it would apply to Flow’s type annotation syntax which is also not presently treated as comments, at least for the very large subset of that syntax which overlaps with the proposal.</div><br/><div id="41065948" class="c"><input type="checkbox" id="c-41065948" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064865">parent</a><span>|</span><a href="#41064832">next</a><span>|</span><label class="collapse" for="c-41065948">[-]</label><label class="expand" for="c-41065948">[2 more]</label></div><br/><div class="children"><div class="content">I meant <a href="https:&#x2F;&#x2F;flow.org&#x2F;en&#x2F;docs&#x2F;types&#x2F;comments&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flow.org&#x2F;en&#x2F;docs&#x2F;types&#x2F;comments&#x2F;</a></div><br/><div id="41069585" class="c"><input type="checkbox" id="c-41069585" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41065948">parent</a><span>|</span><a href="#41064832">next</a><span>|</span><label class="collapse" for="c-41069585">[-]</label><label class="expand" for="c-41069585">[1 more]</label></div><br/><div class="children"><div class="content">I know what you meant.</div><br/></div></div></div></div></div></div><div id="41064832" class="c"><input type="checkbox" id="c-41064832" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064806">parent</a><span>|</span><a href="#41064865">prev</a><span>|</span><a href="#41065086">next</a><span>|</span><label class="collapse" for="c-41064832">[-]</label><label class="expand" for="c-41064832">[5 more]</label></div><br/><div class="children"><div class="content">Types as comments is what jsdoc supports. Flow is compiled like typescript.<p>tsc <i>does</i> also support jsdoc though, so technically I think tsc is closer to supporting types as comments, though it&#x27;s possible Flow has this also.</div><br/><div id="41071611" class="c"><input type="checkbox" id="c-41071611" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064832">parent</a><span>|</span><a href="#41065941">next</a><span>|</span><label class="collapse" for="c-41071611">[-]</label><label class="expand" for="c-41071611">[2 more]</label></div><br/><div class="children"><div class="content">Types _in_ comments is different from types _as_ comments. &quot;Types as comments&quot; refers to how type expressions are parsed.</div><br/><div id="41072451" class="c"><input type="checkbox" id="c-41072451" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41071611">parent</a><span>|</span><a href="#41065941">next</a><span>|</span><label class="collapse" for="c-41072451">[-]</label><label class="expand" for="c-41072451">[1 more]</label></div><br/><div class="children"><div class="content">jsdoc is a format for supplying types (and annotations) as comments as well.<p>I think I get the distinction you&#x27;re trying to make, but I don&#x27;t think the nuance there is significant enough to merit differentiating the two.</div><br/></div></div></div></div><div id="41065941" class="c"><input type="checkbox" id="c-41065941" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064832">parent</a><span>|</span><a href="#41071611">prev</a><span>|</span><a href="#41065086">next</a><span>|</span><label class="collapse" for="c-41065941">[-]</label><label class="expand" for="c-41065941">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;flow.org&#x2F;en&#x2F;docs&#x2F;types&#x2F;comments&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flow.org&#x2F;en&#x2F;docs&#x2F;types&#x2F;comments&#x2F;</a></div><br/><div id="41071582" class="c"><input type="checkbox" id="c-41071582" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41065941">parent</a><span>|</span><a href="#41065086">next</a><span>|</span><label class="collapse" for="c-41071582">[-]</label><label class="expand" for="c-41071582">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I&#x27;ve never used flow and didn&#x27;t know this. I&#x27;ve only seen it used in the non-comment form.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41069170" class="c"><input type="checkbox" id="c-41069170" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41064648">prev</a><span>|</span><a href="#41068603">next</a><span>|</span><label class="collapse" for="c-41069170">[-]</label><label class="expand" for="c-41069170">[1 more]</label></div><br/><div class="children"><div class="content">TS is an intentionally unsound type system that tries to allow you to type your code no matter if it will run like garbage, is unreadably complex, and uses terrible parts of the language.<p>What TC39 needs is a type system that limits what you can do to things that are sound, performant, and good practice. TS is the exact opposite of this.</div><br/></div></div><div id="41068603" class="c"><input type="checkbox" id="c-41068603" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41069170">prev</a><span>|</span><a href="#41066615">next</a><span>|</span><label class="collapse" for="c-41068603">[-]</label><label class="expand" for="c-41068603">[1 more]</label></div><br/><div class="children"><div class="content">Another reason is probably performance. Executing TS would require a lot of extra CPU and even more energy than JS.<p>A lot of effort and money has been invested into JS engines. I wonder if making a TS native engine (which nobody has made yet) from scratch might make more sense than adapting JS engines to run TS.</div><br/></div></div><div id="41066615" class="c"><input type="checkbox" id="c-41066615" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41068603">prev</a><span>|</span><a href="#41064652">next</a><span>|</span><label class="collapse" for="c-41066615">[-]</label><label class="expand" for="c-41066615">[2 more]</label></div><br/><div class="children"><div class="content">Imho standardizing the syntax is enough and this is what <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations</a> does.<p>The type checker is immensely complex and should be left out so that other type checkers can be developed, e.g. similar to how it&#x27;s for Python today.</div><br/><div id="41071631" class="c"><input type="checkbox" id="c-41071631" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41066615">parent</a><span>|</span><a href="#41064652">next</a><span>|</span><label class="collapse" for="c-41071631">[-]</label><label class="expand" for="c-41071631">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t standardize the syntax, only types-as-comments. It would have to standardize some delimiters for type expressions, but that&#x27;s it.<p>I do think that the semantics should be standardized too, otherwise you have non-interoperable types. The goal should be that you can use two libraries together without having to make sure they use the same type-checker.</div><br/></div></div></div></div><div id="41064652" class="c"><input type="checkbox" id="c-41064652" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41066615">prev</a><span>|</span><a href="#41064639">next</a><span>|</span><label class="collapse" for="c-41064652">[-]</label><label class="expand" for="c-41064652">[3 more]</label></div><br/><div class="children"><div class="content">TypeScript used to have a standard.<p>Years and years ago. Now it&#x27;s whatever the compiler does.<p>Which to be fair, is evolving quite rapidly.</div><br/><div id="41064691" class="c"><input type="checkbox" id="c-41064691" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064652">parent</a><span>|</span><a href="#41064639">next</a><span>|</span><label class="collapse" for="c-41064691">[-]</label><label class="expand" for="c-41064691">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that was from 2016 or so. But a TypeScript spec is different than folding TypeScript into the ECMAScript standard. Some parts of TypeScript would have to be dropped or changed for that to work.</div><br/><div id="41064859" class="c"><input type="checkbox" id="c-41064859" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064691">parent</a><span>|</span><a href="#41064639">next</a><span>|</span><label class="collapse" for="c-41064859">[-]</label><label class="expand" for="c-41064859">[1 more]</label></div><br/><div class="children"><div class="content">Right, having a spec is easier (and effectively prerequisite) to your suggestion.<p>But they don&#x27;t have it.</div><br/></div></div></div></div></div></div><div id="41064639" class="c"><input type="checkbox" id="c-41064639" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41064652">prev</a><span>|</span><a href="#41064741">next</a><span>|</span><label class="collapse" for="c-41064639">[-]</label><label class="expand" for="c-41064639">[11 more]</label></div><br/><div class="children"><div class="content">its about time google chrome started making a typescript engine maybe? and get rid of JS in phases?</div><br/><div id="41065093" class="c"><input type="checkbox" id="c-41065093" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064639">parent</a><span>|</span><a href="#41064664">next</a><span>|</span><label class="collapse" for="c-41065093">[-]</label><label class="expand" for="c-41065093">[3 more]</label></div><br/><div class="children"><div class="content">This is a persistent meme that has no basis in reality. A TypeScript engine <i>is</i> a JavaScript engine, since everything that can be done in JS can be done in TS. It&#x27;s plausible, maybe, that there could be some additional optimisations on TS code where the engine is sufficiently happy with all types in a subset of the program. But that would be <i>on top of</i> all existing JS engine features, unless you want your engine&#x27;s performance to suddenly degrade if you stray outside the fully-statically-verifiabe-TS happy path.</div><br/><div id="41066380" class="c"><input type="checkbox" id="c-41066380" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41065093">parent</a><span>|</span><a href="#41064664">next</a><span>|</span><label class="collapse" for="c-41066380">[-]</label><label class="expand" for="c-41066380">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a pretty obtuse interpretation of the comment. Browsers natively being able to run Typescript code &#x2F; .ts files instead of requiring transpiling to plain Javascript would be a large boon to the TS ecosystem by making basically everything easier. Even if it&#x27;s just stripping the TS and running the plain JS it would already be helpful, but it running the typechecking beforehand would be wonderful.</div><br/><div id="41068194" class="c"><input type="checkbox" id="c-41068194" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41066380">parent</a><span>|</span><a href="#41064664">next</a><span>|</span><label class="collapse" for="c-41068194">[-]</label><label class="expand" for="c-41068194">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I was reading too much into the comment I replied to, but to me &quot;a typescript engine&quot; implied more than &quot;ignoring the types&quot; (which is the current TC39 proposal).<p>And I was replying based on what I&#x27;ve seen other people saying whenever the subject comes up; apologies if I misread.<p>Browsers doing type checking is a pretty fraught idea IMO, at least with Typescript and not some other statically typed language entirely.</div><br/></div></div></div></div></div></div><div id="41064664" class="c"><input type="checkbox" id="c-41064664" checked=""/><div class="controls bullet"><span class="by">jjk7</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064639">parent</a><span>|</span><a href="#41065093">prev</a><span>|</span><a href="#41065254">next</a><span>|</span><label class="collapse" for="c-41064664">[-]</label><label class="expand" for="c-41064664">[5 more]</label></div><br/><div class="children"><div class="content">There are a few optimizations that types can use but 99% of applications wouldn&#x27;t benefit from them anyways.</div><br/><div id="41064790" class="c"><input type="checkbox" id="c-41064790" checked=""/><div class="controls bullet"><span class="by">Shacklz</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064664">parent</a><span>|</span><a href="#41065539">next</a><span>|</span><label class="collapse" for="c-41064790">[-]</label><label class="expand" for="c-41064790">[3 more]</label></div><br/><div class="children"><div class="content">Taking one link out of the toolchain (tsc) would already be a huge blessing.<p>And naive me hopes for a future where in my web-app I can set a policy that any non-ts, type-incompliant code is not allowed to run.<p>The amount of exceptions I get in the console from terrible garbage-code outside of my control but that I have to include because enterprise is staggering. Would love to have a meta-setting which would just kill them if they can&#x27;t be arsed to even have a modicum of code-hygiene (sorry for the rant)</div><br/><div id="41066441" class="c"><input type="checkbox" id="c-41066441" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064790">parent</a><span>|</span><a href="#41065539">next</a><span>|</span><label class="collapse" for="c-41066441">[-]</label><label class="expand" for="c-41066441">[2 more]</label></div><br/><div class="children"><div class="content">Why is taking out the part that actually checks the types at the developer&#x27;s side a huge blessing?<p>Or if you are hoping to get the benefit of type checking in the browser itself (taking the same sweet time as tsc, but this time on every browser instead of once in the CI), then how long would you want to wait to be able to actually use the new typing functionality described in e.g. the latest TS annoucement? <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;typescript&#x2F;announcing-typescript-5-5&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;typescript&#x2F;announcing-typescr...</a> .<p>Because it would take a while until that would then become the standard and then become available in every browser. And you <i>still</i> need to provide the JS versions, because not every browser is going to support TS.<p>In the meanwhile you could just keep using tsc just as before and get access to new functionality immediately.<p>(I imagine you could run tsc in the browser right now if you really wanted to.)</div><br/><div id="41068629" class="c"><input type="checkbox" id="c-41068629" checked=""/><div class="controls bullet"><span class="by">Shacklz</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41066441">parent</a><span>|</span><a href="#41065539">next</a><span>|</span><label class="collapse" for="c-41068629">[-]</label><label class="expand" for="c-41068629">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why is taking out the part that actually checks the types at the developer&#x27;s side a huge blessing?<p>Oh, no, certainly we want to keep type-checking in the pipeline, somewhere.<p>However, if the browser &quot;understood&quot; typescript, your codebase could have immediate hot-reload, without any transpilation in-between. The type-checking could then be (and already is when using something like esbuild&#x2F;swc) an entirely separate process that happens independently.<p>Webpack&#x27;s HMR is pretty good, but not having to modify the code <i>at all</i> to have it work in the browser, that&#x27;d be much much better :)<p>... the browser being able to typecheck (and reject violating code) itself is certainly something I&#x27;d love to see eventually, but fully agreed, this is not happening anytime soon.</div><br/></div></div></div></div></div></div><div id="41065539" class="c"><input type="checkbox" id="c-41065539" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064664">parent</a><span>|</span><a href="#41064790">prev</a><span>|</span><a href="#41065254">next</a><span>|</span><label class="collapse" for="c-41065539">[-]</label><label class="expand" for="c-41065539">[1 more]</label></div><br/><div class="children"><div class="content">One advantage of Typescript in context of performance should be that it nudges one to not change the &#x27;shape&#x27; of runtime objects too much, this should allow less runtime overhead in JS engines because code doesn&#x27;t need to be re-jitted as often.<p>This doesn&#x27;t require the type annotations at runtime though, it&#x27;s just a side effect of code being written against a static type system.</div><br/></div></div></div></div><div id="41065254" class="c"><input type="checkbox" id="c-41065254" checked=""/><div class="controls bullet"><span class="by">mcintyre1994</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064639">parent</a><span>|</span><a href="#41064664">prev</a><span>|</span><a href="#41067440">next</a><span>|</span><label class="collapse" for="c-41065254">[-]</label><label class="expand" for="c-41065254">[1 more]</label></div><br/><div class="children"><div class="content">A lot of apps would (or at least should) still want to strip types for bundle size reasons though.<p>To take one extreme example, a library I work on includes an API for calling a JSON RPC server. Instead of manually implementing each call, we use a proxy object that converts any method call on it to a JSON RPC call. Then layer on types so given an RPC object you know every method on it and have typed input params and output. This means you can have any number of methods without increasing your bundle size, because all the types disappear at runtime. It also means you can add your own methods if you’re talking to a server that implements custom ones by just defining types. If you shipped this to the browser with the types then it’d be a much bigger bundle than without them.</div><br/></div></div><div id="41067440" class="c"><input type="checkbox" id="c-41067440" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064639">parent</a><span>|</span><a href="#41065254">prev</a><span>|</span><a href="#41064741">next</a><span>|</span><label class="collapse" for="c-41067440">[-]</label><label class="expand" for="c-41067440">[1 more]</label></div><br/><div class="children"><div class="content">My take as an outsider: Google has absolutely no interest in this, especially with their recent cost-cutting measures. Google cares about things that make the &quot;web&quot; better for the end users so that they can sell more ads, not developer tools. TypeScript or JavaScript doesn&#x27;t matter that much to Google, and actually Google probably doesn&#x27;t want to see TypeScript files distributed over network (which doesn&#x27;t make much sense in the first place). In all honesty, Microsoft understands development experience much better than Google and most other companies. They literally own Visual Studio, Visual Studio Code and GitHub and sell products&#x2F;services for money.</div><br/></div></div></div></div><div id="41064699" class="c"><input type="checkbox" id="c-41064699" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41064605">parent</a><span>|</span><a href="#41064741">prev</a><span>|</span><a href="#41064577">next</a><span>|</span><label class="collapse" for="c-41064699">[-]</label><label class="expand" for="c-41064699">[6 more]</label></div><br/><div class="children"><div class="content">i’m not sure i buy the “company floods the industry with broken tooling and deserves to be standardized” narrative.<p>yeah, the ecosystem sucks, but rewarding the system incentivized to co-opt the system will actually make things worse in the long run, not better.<p>for example, internet explorer failed why?</div><br/><div id="41064758" class="c"><input type="checkbox" id="c-41064758" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064699">parent</a><span>|</span><a href="#41064577">next</a><span>|</span><label class="collapse" for="c-41064758">[-]</label><label class="expand" for="c-41064758">[5 more]</label></div><br/><div class="children"><div class="content">What broken tooling are you talking about? tsc is broken?<p>IE failed because it was a horrible browser that didn’t evolve for years and was incompatible with major web standard developments. Nothing to do with typescript, an open source, best in class type system and type checker.</div><br/><div id="41064903" class="c"><input type="checkbox" id="c-41064903" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064758">parent</a><span>|</span><a href="#41065259">next</a><span>|</span><label class="collapse" for="c-41064903">[-]</label><label class="expand" for="c-41064903">[1 more]</label></div><br/><div class="children"><div class="content">IE failed because they tried to define the standard as themselves. i argue we’re witnessing that again from the same company that only gave up  that strategy once they had typescript, github, npm locked in.<p>i’m not bullish on political strategies being technical solutions, which is the premise.<p>typescript has nothing to do with internet explorer, true, but is it really not obvious that it is the same tactic as a different brand? become the standard, steer the committee.<p>and broken in that copying code between systems requires compatibility between configurations, which should be a red flag for any language.</div><br/></div></div><div id="41065259" class="c"><input type="checkbox" id="c-41065259" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41064758">parent</a><span>|</span><a href="#41064903">prev</a><span>|</span><a href="#41064577">next</a><span>|</span><label class="collapse" for="c-41065259">[-]</label><label class="expand" for="c-41065259">[3 more]</label></div><br/><div class="children"><div class="content">“During the transpilation process, no type checking is performed, and types are discarded.”<p>this node feature is primarily  around disregarding typescript in favor of the underlying javascript it represents.<p>that reminds me of this fun article:
<a href="https:&#x2F;&#x2F;www.richard-towers.com&#x2F;2023&#x2F;03&#x2F;11&#x2F;typescripting-the-technical-interview.html" rel="nofollow">https:&#x2F;&#x2F;www.richard-towers.com&#x2F;2023&#x2F;03&#x2F;11&#x2F;typescripting-the-...</a></div><br/><div id="41065915" class="c"><input type="checkbox" id="c-41065915" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41065259">parent</a><span>|</span><a href="#41064577">next</a><span>|</span><label class="collapse" for="c-41065915">[-]</label><label class="expand" for="c-41065915">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the feature is about being able to run typescript scripts. It’s not a type checker, it is similar to ts-node, deno, bun, etc. Typescript has been designed for that specific purpose.</div><br/><div id="41068246" class="c"><input type="checkbox" id="c-41068246" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41064605">root</a><span>|</span><a href="#41065915">parent</a><span>|</span><a href="#41064577">next</a><span>|</span><label class="collapse" for="c-41068246">[-]</label><label class="expand" for="c-41068246">[1 more]</label></div><br/><div class="children"><div class="content">seen and heard, my original point was that typescript is not poised to be a tc39 standard.<p>this is still a “runs some typescript” and “not runs every typescript file”<p>“ At least initially in this PR no trasformation is performed, meaning that using Enum, namespaces etc... will not be possible.”<p>this type of nuance is the core of why typescript is a headache for any organization with more than a single codebase— javascript is portable, typescript is in theory, but not in observed practice.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41064577" class="c"><input type="checkbox" id="c-41064577" checked=""/><div class="controls bullet"><span class="by">ofirg</span><span>|</span><a href="#41064605">prev</a><span>|</span><a href="#41069824">next</a><span>|</span><label class="collapse" for="c-41064577">[-]</label><label class="expand" for="c-41064577">[3 more]</label></div><br/><div class="children"><div class="content">support for typescript as long as you are only using it for type checking, not if you are also using features that are not supported in the javascript version you are targeting.</div><br/><div id="41065497" class="c"><input type="checkbox" id="c-41065497" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41064577">parent</a><span>|</span><a href="#41064625">next</a><span>|</span><label class="collapse" for="c-41065497">[-]</label><label class="expand" for="c-41065497">[1 more]</label></div><br/><div class="children"><div class="content">&gt; not if you are also using features that are not supported in the javascript version you are targeting.
reply<p>This is only &#x27;half-assed&#x27; anyway, TS will only emulate new language features on older JS target version, but not any Javascript <i>runtime</i> features (like new Object methods). For the latter you will still need a separate polyfill solution.</div><br/></div></div><div id="41064625" class="c"><input type="checkbox" id="c-41064625" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41064577">parent</a><span>|</span><a href="#41065497">prev</a><span>|</span><a href="#41069824">next</a><span>|</span><label class="collapse" for="c-41064625">[-]</label><label class="expand" for="c-41064625">[1 more]</label></div><br/><div class="children"><div class="content">That is what people use TypeScript for generally.<p>If you need JS syntax features that Node.js doesn&#x27;t support you can use tsc, babel, etc.<p>Because obviously unsupported features are unsupported, whether JS or TS.</div><br/></div></div></div></div><div id="41069824" class="c"><input type="checkbox" id="c-41069824" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41064577">prev</a><span>|</span><a href="#41064576">next</a><span>|</span><label class="collapse" for="c-41069824">[-]</label><label class="expand" for="c-41069824">[3 more]</label></div><br/><div class="children"><div class="content">I might be ignorant but wasn&#x27;t there a plan to add Typescript support to the browser itself?<p>In which case wouldn&#x27;t V8 support TS directly without needing to transpile?</div><br/><div id="41069888" class="c"><input type="checkbox" id="c-41069888" checked=""/><div class="controls bullet"><span class="by">herpdyderp</span><span>|</span><a href="#41069824">parent</a><span>|</span><a href="#41069955">next</a><span>|</span><label class="collapse" for="c-41069888">[-]</label><label class="expand" for="c-41069888">[1 more]</label></div><br/><div class="children"><div class="content">Yes. That is noted in the PR:<p>&gt; There is a TC39 proposal for type annotations<p>Which links to <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-type-annotations</a><p>It is a long ways off though.</div><br/></div></div><div id="41069955" class="c"><input type="checkbox" id="c-41069955" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#41069824">parent</a><span>|</span><a href="#41069888">prev</a><span>|</span><a href="#41064576">next</a><span>|</span><label class="collapse" for="c-41069955">[-]</label><label class="expand" for="c-41069955">[1 more]</label></div><br/><div class="children"><div class="content">all browsers would have to agree, the language would have to be very well defined and well supported across all those browsers.<p>that would be a lot of work<p>I would rather see new WASM features instead</div><br/></div></div></div></div><div id="41064576" class="c"><input type="checkbox" id="c-41064576" checked=""/><div class="controls bullet"><span class="by">deanc</span><span>|</span><a href="#41069824">prev</a><span>|</span><a href="#41065043">next</a><span>|</span><label class="collapse" for="c-41064576">[-]</label><label class="expand" for="c-41064576">[4 more]</label></div><br/><div class="children"><div class="content">So how does this work in practice? Does it strip types and yolo trying to run or will it spit out type errors?</div><br/><div id="41064642" class="c"><input type="checkbox" id="c-41064642" checked=""/><div class="controls bullet"><span class="by">bentruyman</span><span>|</span><a href="#41064576">parent</a><span>|</span><a href="#41064655">next</a><span>|</span><label class="collapse" for="c-41064642">[-]</label><label class="expand" for="c-41064642">[1 more]</label></div><br/><div class="children"><div class="content">If you read the third sentence of the PR, it says:<p>&gt; During the transpilation process, no type checking is performed, and types are discarded</div><br/></div></div><div id="41064655" class="c"><input type="checkbox" id="c-41064655" checked=""/><div class="controls bullet"><span class="by">Shacklz</span><span>|</span><a href="#41064576">parent</a><span>|</span><a href="#41064642">prev</a><span>|</span><a href="#41064624">next</a><span>|</span><label class="collapse" for="c-41064655">[-]</label><label class="expand" for="c-41064655">[1 more]</label></div><br/><div class="children"><div class="content">If I understood correctly they use a wrapper around swc to strip types, without any type-check being performed.<p>Which makes perfect sense to start out with; as typechecking with tsc is rather slow and can easily be delegated to the consumer.</div><br/></div></div><div id="41064624" class="c"><input type="checkbox" id="c-41064624" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#41064576">parent</a><span>|</span><a href="#41064655">prev</a><span>|</span><a href="#41065043">next</a><span>|</span><label class="collapse" for="c-41064624">[-]</label><label class="expand" for="c-41064624">[1 more]</label></div><br/><div class="children"><div class="content">Why would you describe that &quot;yolo&quot;? If you&#x27;re writing TS, you already have a TS linter that checks whether code has typing problems or not (at least, I certainly hope you do?). It&#x27;s not really Node&#x27;s job to do that linting, its job is to execute the JS that&#x27;s hiding in the TS. It&#x27;d be &quot;handy&quot; if it did, but it&#x27;d also be a bit weird when there are already TS linting tools. It&#x27;d just hold up landing any sort of TS support that much longer.</div><br/></div></div></div></div><div id="41065043" class="c"><input type="checkbox" id="c-41065043" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41064576">prev</a><span>|</span><a href="#41068638">next</a><span>|</span><label class="collapse" for="c-41065043">[-]</label><label class="expand" for="c-41065043">[4 more]</label></div><br/><div class="children"><div class="content">It would be nice for debugging if at least simple npms could just bundle their .ts files without any processing, so we could see the comments and types as they existed in the git repo. Apps can always minify them later.<p>(I use Deno, but also use some npms.)</div><br/><div id="41065447" class="c"><input type="checkbox" id="c-41065447" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41065043">parent</a><span>|</span><a href="#41068638">next</a><span>|</span><label class="collapse" for="c-41065447">[-]</label><label class="expand" for="c-41065447">[3 more]</label></div><br/><div class="children"><div class="content">You can simply create npm packages which contain only the &#x27;unprocessed&#x27; TS source files (or really any type of files - for instance I experimented with using npm as package for C&#x2F;C++ projects in the past, it works just fine). Pre-bundling or compiling from TS to JS is just a convention. And in case of bundling not a good one IMHO, because bundling should only be a final step in the top-level project. One good reason to compile the package content to .js&#x2F;.d.js&#x2F;.map files is that the resulting package is usable both in JS and TS projects.</div><br/><div id="41065871" class="c"><input type="checkbox" id="c-41065871" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41065043">root</a><span>|</span><a href="#41065447">parent</a><span>|</span><a href="#41068638">next</a><span>|</span><label class="collapse" for="c-41065871">[-]</label><label class="expand" for="c-41065871">[2 more]</label></div><br/><div class="children"><div class="content">The nice thing about this change to Node.js (when it’s no longer experimental) is that you could just distribute .ts files and JS projects could use them.</div><br/></div></div></div></div></div></div><div id="41068638" class="c"><input type="checkbox" id="c-41068638" checked=""/><div class="controls bullet"><span class="by">nthngy</span><span>|</span><a href="#41065043">prev</a><span>|</span><a href="#41065617">next</a><span>|</span><label class="collapse" for="c-41068638">[-]</label><label class="expand" for="c-41068638">[1 more]</label></div><br/><div class="children"><div class="content">IMAO writing (hard-coding) TypeScript is deprecated and a waste of time. With all tech available nowadays it is possible to do the entire type check automatically in the IDE, even more so now with the help of AI. It&#x27;s just a matter of time when we stop hard-coding type info. Better invest time and money in getting the IDE&#x27;s work better for us.</div><br/></div></div><div id="41065617" class="c"><input type="checkbox" id="c-41065617" checked=""/><div class="controls bullet"><span class="by">alabhyajindal</span><span>|</span><a href="#41068638">prev</a><span>|</span><a href="#41071743">next</a><span>|</span><label class="collapse" for="c-41065617">[-]</label><label class="expand" for="c-41065617">[1 more]</label></div><br/><div class="children"><div class="content">What next? Renaming Node.js to Node.ts?<p>I understand that built in TS support is very nice as provided by Bun. But I feel doing this in Node is going to take a long time.</div><br/></div></div><div id="41071743" class="c"><input type="checkbox" id="c-41071743" checked=""/><div class="controls bullet"><span class="by">olalonde</span><span>|</span><a href="#41065617">prev</a><span>|</span><a href="#41070241">next</a><span>|</span><label class="collapse" for="c-41071743">[-]</label><label class="expand" for="c-41071743">[1 more]</label></div><br/><div class="children"><div class="content">It just took 3 weeks to merge this? Seems really fast by Node.js standards. I assume it was discussed before the PR was opened?</div><br/></div></div><div id="41070241" class="c"><input type="checkbox" id="c-41070241" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#41071743">prev</a><span>|</span><a href="#41068640">next</a><span>|</span><label class="collapse" for="c-41070241">[-]</label><label class="expand" for="c-41070241">[1 more]</label></div><br/><div class="children"><div class="content">I feel like Deno and Bun have lit a fire under the Node team to finally modernize things people have been desperately wanting for years. Great to see!</div><br/></div></div><div id="41068640" class="c"><input type="checkbox" id="c-41068640" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41070241">prev</a><span>|</span><a href="#41066779">next</a><span>|</span><label class="collapse" for="c-41068640">[-]</label><label class="expand" for="c-41068640">[1 more]</label></div><br/><div class="children"><div class="content">If this means, that one day I don&#x27;t need to use a bundler any longer to make a website using TypeScript, I am all for it.</div><br/></div></div><div id="41066779" class="c"><input type="checkbox" id="c-41066779" checked=""/><div class="controls bullet"><span class="by">DrMiaow</span><span>|</span><a href="#41068640">prev</a><span>|</span><a href="#41064990">next</a><span>|</span><label class="collapse" for="c-41066779">[-]</label><label class="expand" for="c-41066779">[1 more]</label></div><br/><div class="children"><div class="content">Without some kind of transformation on `enum` isn&#x27;t this mostly useless? `enum` is heavily used in many TypeScript code-bases.</div><br/></div></div><div id="41064990" class="c"><input type="checkbox" id="c-41064990" checked=""/><div class="controls bullet"><span class="by">storafrid</span><span>|</span><a href="#41066779">prev</a><span>|</span><a href="#41069560">next</a><span>|</span><label class="collapse" for="c-41064990">[-]</label><label class="expand" for="c-41064990">[14 more]</label></div><br/><div class="children"><div class="content">I have mixed feelings about this. While I do use TS with Node.js today and absolutely like the concept, its type system is still far from something mature and stable like C#. We keep running into ceilings (EDIT: lack of completeness&#x2F;depth, not lack of complexity) all the time, and TypeScript questions on Stack Overflow is basically a library of workarounds. Mostly bad ones. So if I worked on Node.js I would prefer it to evolve more before actually marrying and having kids with it. But at the same time, I like the direction Node.js is taking.</div><br/><div id="41065033" class="c"><input type="checkbox" id="c-41065033" checked=""/><div class="controls bullet"><span class="by">coffeemug</span><span>|</span><a href="#41064990">parent</a><span>|</span><a href="#41065096">next</a><span>|</span><label class="collapse" for="c-41065033">[-]</label><label class="expand" for="c-41065033">[7 more]</label></div><br/><div class="children"><div class="content">What&#x27;s an example of a ceiling? Out of all the mass-market programming languages, TS arguably has the most advanced type system in the world. It&#x27;s a modern marvel that they got it working on top of Javascript.</div><br/><div id="41065389" class="c"><input type="checkbox" id="c-41065389" checked=""/><div class="controls bullet"><span class="by">storafrid</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065033">parent</a><span>|</span><a href="#41065078">next</a><span>|</span><label class="collapse" for="c-41065389">[-]</label><label class="expand" for="c-41065389">[1 more]</label></div><br/><div class="children"><div class="content">Certainly advanced, but not mature in my experience. Using e.g. classes and inferred generic function arguments, quickly reveals a lot of features that are missing. Often some similar feature is present but it lacks depth&#x2F;completeness. Lots of good discussions to read in TS repo on GitHub if you&#x27;re interested: Optional generic type inference, extends oneof, generic values, keyof a subset, conditional types, etc.<p>I want to emphasize that the reason we keep running into &quot;ceilings&quot; is probably because of its advanced type system. Libraries and frameworks are using those type features and when we can&#x27;t keep building on the type - we end up casting to unknown and reconstructing it. Which feels worse than not being able to construct that complex type at all.</div><br/></div></div><div id="41065078" class="c"><input type="checkbox" id="c-41065078" checked=""/><div class="controls bullet"><span class="by">bottlepalm</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065033">parent</a><span>|</span><a href="#41065389">prev</a><span>|</span><a href="#41065074">next</a><span>|</span><label class="collapse" for="c-41065078">[-]</label><label class="expand" for="c-41065078">[2 more]</label></div><br/><div class="children"><div class="content">I think it took the seemingly impossible challenge of bringing typing to a dynamic language that made typescript so powerful in the first place.<p>All other static languages start bottom up, simple to more complex, but end up getting boxed in by their own design. TypeScript started top down, trying to map itself on to a fully dynamic language. Never getting boxed in, just trying to &#x27;fill&#x27; the box that is all the possibilities of JavaScript. 10 years on and TypeScript is still exciting, making significant updates and improvements.</div><br/><div id="41065515" class="c"><input type="checkbox" id="c-41065515" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065078">parent</a><span>|</span><a href="#41065074">next</a><span>|</span><label class="collapse" for="c-41065515">[-]</label><label class="expand" for="c-41065515">[1 more]</label></div><br/><div class="children"><div class="content">Typescript isn&#x27;t particularly powerful compared to other <i>non-mainstream</i> languages, though, which is why the parent comment was careful to add that caveat. Which is to say that I&#x27;m not sure the idea that &quot;all other static languages&quot; start simple and get boxed in stands up.<p>You may have a point that Typescript would have been relegated to obscurity with all the others had it tried to start &quot;top down&quot; as a brand new language. There may be some truth that it is a necessity of a language to start simple in order to become accepted in the mainstream and that Typescript only made it because it rode on the coattails of a language that also started simple: Javascript.</div><br/></div></div></div></div><div id="41065074" class="c"><input type="checkbox" id="c-41065074" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065033">parent</a><span>|</span><a href="#41065078">prev</a><span>|</span><a href="#41065096">next</a><span>|</span><label class="collapse" for="c-41065074">[-]</label><label class="expand" for="c-41065074">[3 more]</label></div><br/><div class="children"><div class="content">I don’t know what you mean here by advanced? If you mean the sheer amount of fuckery they have to do in order to make it work with JS perhaps you have a point.<p>If you mean expressiveness or consistent or soundness then no, it’s actually very bad compared to almost anything else and I think the longer it goes on the more it starts to feel like a house of cards.<p>The upside I guess is that whenever Safari decides to get their shit together Web Assembly is well placed to get us out of the scenario where we are forced to use JS and as an extension Typescript at all for most things and actually good language choices with reliable type systems like Dart, Kotlin and C# all become viable options.<p>There is no way I’d choose JavaScript over those other options in the majority of scenarios unless I was forced to.</div><br/><div id="41065521" class="c"><input type="checkbox" id="c-41065521" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065074">parent</a><span>|</span><a href="#41065577">next</a><span>|</span><label class="collapse" for="c-41065521">[-]</label><label class="expand" for="c-41065521">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The upside I guess is that whenever Safari decides to get their shit together Web Assembly is well placed to get us out of the scenario where we are forced to use JS and as an extension Typescript at all for most things and actually good language choices with reliable type systems like Dart, Kotlin and C# all become viable options.<p>Out of those three only Dart has nice DX story compared to JS world.</div><br/></div></div></div></div></div></div><div id="41065096" class="c"><input type="checkbox" id="c-41065096" checked=""/><div class="controls bullet"><span class="by">SebastianKra</span><span>|</span><a href="#41064990">parent</a><span>|</span><a href="#41065033">prev</a><span>|</span><a href="#41065026">next</a><span>|</span><label class="collapse" for="c-41065096">[-]</label><label class="expand" for="c-41065096">[5 more]</label></div><br/><div class="children"><div class="content">This is the first time I&#x27;m hearing such a claim.<p>In C# you can&#x27;t work with optional generics because an optional reference type is different from an optional value type.<p>C#s poor type-inference often requires you to type out types thrice. You can&#x27;t declare constants or class members with type-inferrence.<p>The only way to define sum-types (A | B | C) is through intefaces and I&#x27;m pretty sure they can&#x27;t be sealed. Defining product-types (A &amp; B &amp; C) is impossible.</div><br/><div id="41065461" class="c"><input type="checkbox" id="c-41065461" checked=""/><div class="controls bullet"><span class="by">storafrid</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065096">parent</a><span>|</span><a href="#41065499">next</a><span>|</span><label class="collapse" for="c-41065461">[-]</label><label class="expand" for="c-41065461">[1 more]</label></div><br/><div class="children"><div class="content">Sorry I probably used the wrong term, not a native English speaker. I didn&#x27;t mean lack of complexity or lack of &quot;features&quot; but rather the lack of carefully thought-through feature &quot;depth&quot;. Like, we can infer generic arguments which is nice, but then we try doing that with some keyof complex type and it doesn&#x27;t work. And later we find an issue on GitHub saying that it&#x27;s not implemented. Which is fine, I love TS anyway and it&#x27;s evolving.</div><br/></div></div><div id="41065499" class="c"><input type="checkbox" id="c-41065499" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065096">parent</a><span>|</span><a href="#41065461">prev</a><span>|</span><a href="#41065026">next</a><span>|</span><label class="collapse" for="c-41065499">[-]</label><label class="expand" for="c-41065499">[3 more]</label></div><br/><div class="children"><div class="content">C# has record (product) types now.</div><br/><div id="41065898" class="c"><input type="checkbox" id="c-41065898" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065499">parent</a><span>|</span><a href="#41065026">next</a><span>|</span><label class="collapse" for="c-41065898">[-]</label><label class="expand" for="c-41065898">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure about the terminology here, but the &amp; in TS is much more than a record. You can use it to smush types together e.g.<p>{name: string} &amp; {birthday: Date}<p>becomes a single type with both properties.</div><br/><div id="41068370" class="c"><input type="checkbox" id="c-41068370" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#41064990">root</a><span>|</span><a href="#41065898">parent</a><span>|</span><a href="#41065026">next</a><span>|</span><label class="collapse" for="c-41068370">[-]</label><label class="expand" for="c-41068370">[1 more]</label></div><br/><div class="children"><div class="content">Product types are tuple types.<p>Record types are tuple types with names instead of indexes.<p>The TypeScript “&amp;” is another thing.</div><br/></div></div></div></div></div></div></div></div><div id="41065026" class="c"><input type="checkbox" id="c-41065026" checked=""/><div class="controls bullet"><span class="by">Zamicol</span><span>|</span><a href="#41064990">parent</a><span>|</span><a href="#41065096">prev</a><span>|</span><a href="#41069560">next</a><span>|</span><label class="collapse" for="c-41065026">[-]</label><label class="expand" for="c-41065026">[1 more]</label></div><br/><div class="children"><div class="content">Well said. Bearing that in mind, we&#x27;ve found that JSDoc is a reasonable substitution for some TypeScript applications; however, JSDoc has limitations that we&#x27;ve ran into frequently as well.</div><br/></div></div></div></div><div id="41069560" class="c"><input type="checkbox" id="c-41069560" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#41064990">prev</a><span>|</span><label class="collapse" for="c-41069560">[-]</label><label class="expand" for="c-41069560">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see this, and important to stay closer to parity with Deno and Bun.</div><br/></div></div></div></div></div></div></div></body></html>