<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733648455680" as="style"/><link rel="stylesheet" href="styles.css?v=1733648455680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://minimalmodeling.substack.com/p/historically-4nf-explanations-are">Historically, 4NF explanations are needlessly confusing</a> <span class="domain">(<a href="https://minimalmodeling.substack.com">minimalmodeling.substack.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>24 comments</span></div><br/><div><div id="42353237" class="c"><input type="checkbox" id="c-42353237" checked=""/><div class="controls bullet"><span class="by">jcrawfordor</span><span>|</span><a href="#42355043">next</a><span>|</span><label class="collapse" for="c-42353237">[-]</label><label class="expand" for="c-42353237">[5 more]</label></div><br/><div class="children"><div class="content">I think the typical presentation of 4NF makes more sense when you consider the ergonomics of data processing systems when relational modeling emerged. Predating computing, data processing was all centered around &quot;records.&quot; Relational databases are often also described in terms of &quot;records,&quot; relational modeling emerged out of an attempt to formalize data processing practices, the practitioners of the era were learning relational modeling from a data processing background, so it&#x27;s no surprise that relational concepts are often presented &quot;as opposed to&quot; the way things were done in data processing.<p>In traditional data processing systems, a &quot;record&quot; was far more independent than we think of in a relational database. Records were hand-punched onto cards or keyed onto magnetic tape to be sorted, summarized, or whatever operation you cared about by a data processing machine. In this environment, joins were extremely expensive operations, often requiring that the operator feed the card stack over and over again (a rather literal O(n^2)). So, the &quot;weird composed&quot; schema is absolutely what you would do. And a lot of computer software was built around the exact same concepts, which made sense anyway as computers often continued to use sequential-access storage devices with similar (but less severe) problems around joins. This era famously persisted for a long time, with relational modeling as an academic concept well predating successful implementations of relational databases.<p>One could argue that all of the normal forms are pretty much &quot;stop doing it the old sequential access (card-stack) way and use random access concepts (keys and joins) instead.&quot;<p>Of course that leaves the question of whether or not we should teach it that way... we don&#x27;t tend to tell students about how memory is now random access, so perhaps by the same turn the historical approach isn&#x27;t useful for teaching here. But it would undoubtedly be more effective if you give a little of the history.</div><br/><div id="42355880" class="c"><input type="checkbox" id="c-42355880" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#42353237">parent</a><span>|</span><a href="#42355614">next</a><span>|</span><label class="collapse" for="c-42355880">[-]</label><label class="expand" for="c-42355880">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how many people actually have seen those index card shelves[1] IRL. Everyone have heard enough of music box analogy, the Tacoma Narrows, etc, but I don&#x27;t remember this technology covered often enough.<p>One set of shelves has cards for books sorted by its ISBN. Another by titles, by authors, by keywords, ... libraries(of books, of employee records, of manufacturing blueprints...) would have had whole rooms worth of these shelves for <i>searching and indexing</i>.<p>Data normalization, SELECT, and JOIN, are just separating information on cards into separate shelves, hand picking cards, and laying out matching ones side by side on photocopiers. I&#x27;ve never had to mess with it, but apparently that was literally the <i>database</i>.<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Library_catalog" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Library_catalog</a></div><br/></div></div><div id="42355614" class="c"><input type="checkbox" id="c-42355614" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42353237">parent</a><span>|</span><a href="#42355880">prev</a><span>|</span><a href="#42353376">next</a><span>|</span><label class="collapse" for="c-42355614">[-]</label><label class="expand" for="c-42355614">[1 more]</label></div><br/><div class="children"><div class="content">Records had to be batched into blocks and blocks had to be organized for fast access on a spinning drum or platter.   This is why we have B+ trees for databases, and not simple binary trees or whatnot. You need the branching factor in order to reduce the seek times: each tree node traversal goes to a different block of records. If they are on the same track, it takes rotational latency to get to the block. If they are on a different track, seek time plus rotational latency.<p>Reducing rotational latency is why we got 7200 RPM and faster drives: going from 3600 to 7200 means any block is available twice as often at the drive head. It doesn&#x27;t matter how many or how few have been crammed onto the track; density doesn&#x27;t fix latency.</div><br/></div></div><div id="42353376" class="c"><input type="checkbox" id="c-42353376" checked=""/><div class="controls bullet"><span class="by">pessimizer</span><span>|</span><a href="#42353237">parent</a><span>|</span><a href="#42355614">prev</a><span>|</span><a href="#42355043">next</a><span>|</span><label class="collapse" for="c-42353376">[-]</label><label class="expand" for="c-42353376">[2 more]</label></div><br/><div class="children"><div class="content">What might be needless is the &quot;4&quot; in &quot;4NF,&quot; because the first three (and a half) are obsolete. Or rather, as you mention, were only relevant when things were read sequentially. &quot;Normalization&quot; is really fine on its own.<p>Things that aren&#x27;t normalized are &quot;ad hoc,&quot; or really just &quot;input.&quot;</div><br/><div id="42354506" class="c"><input type="checkbox" id="c-42354506" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#42353237">root</a><span>|</span><a href="#42353376">parent</a><span>|</span><a href="#42355043">next</a><span>|</span><label class="collapse" for="c-42354506">[-]</label><label class="expand" for="c-42354506">[1 more]</label></div><br/><div class="children"><div class="content">Sequential is still faster in a lot of cases even on SSDs and RAM (prefetching)</div><br/></div></div></div></div></div></div><div id="42355043" class="c"><input type="checkbox" id="c-42355043" checked=""/><div class="controls bullet"><span class="by">jklowden</span><span>|</span><a href="#42353237">prev</a><span>|</span><a href="#42354137">next</a><span>|</span><label class="collapse" for="c-42355043">[-]</label><label class="expand" for="c-42355043">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps TFA could explain what happened to math between 1977 and 2024.  Because the meaning of &quot;atomic&quot; didn’t change, nor did the meaning of 1NF. The author pretends to explain 4NF, but never actually begins. He calls himself an &quot;historian&quot;, which he might be.  But he betrays very little knowledge of the relational model.<p>Repeating fields, which he proclaims as some kind of innovation, violate 1NF.  They’re not atomic.  Maybe the easiest way to understand it is that the list of languages can’t be used in SQL. If one teacher speaks Italian and French, SQL won’t find WHERE LANGUAGE = ‘FRENCH’.  Nor will SQL join two teachers on that column.<p>SQL doesn’t recognize repeating fields in a column because it already has a way to represent them: as rows. That a teacher speaks two languages is not one fact, but two; not surprisingly, those two facts appear in two rows. ‘Twas true in in 1977. ‘Tis true today.  Thus ‘twill ever be.</div><br/></div></div><div id="42354137" class="c"><input type="checkbox" id="c-42354137" checked=""/><div class="controls bullet"><span class="by">Kerrick</span><span>|</span><a href="#42355043">prev</a><span>|</span><a href="#42353934">next</a><span>|</span><label class="collapse" for="c-42354137">[-]</label><label class="expand" for="c-42354137">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen this design again and again, but not in relational databases. I usually see it in spreadsheets. I would be completely unsurprised to see a three column Excel sheet with Employee, Skill, and Language headers. (<a href="https:&#x2F;&#x2F;kerricklong.com&#x2F;tmp&#x2F;demo-4nf-need.jpg" rel="nofollow">https:&#x2F;&#x2F;kerricklong.com&#x2F;tmp&#x2F;demo-4nf-need.jpg</a>) The spreadsheet designer’s intuition is that Skill and Language are lists, and Employee is a section header. Smith might have a few rows with his languages and skills listed, one per cell, in arbitrary top-to-bottom order and with no consideration for how language and skill in a row relate to each other—only to Smith. The Employee column has a single merged cell for Smith, a number of rows tall it needs to be to contain the largest of his lists. When migrating this from a spreadsheet to a database, you lose merged cells as a feature and can no longer rely on order—so you copy the value Smith to each cell that had been merged.</div><br/></div></div><div id="42353934" class="c"><input type="checkbox" id="c-42353934" checked=""/><div class="controls bullet"><span class="by">wpollock</span><span>|</span><a href="#42354137">prev</a><span>|</span><a href="#42355500">next</a><span>|</span><label class="collapse" for="c-42353934">[-]</label><label class="expand" for="c-42353934">[4 more]</label></div><br/><div class="children"><div class="content">It was and is still common to have non experts design databases.  And in many cases,  normal form doesn&#x27;t make sense.  Tables with hundreds or thousands of columns are commonly the best solution.<p>What is rarely stressed about NF is that update logic must exist someplace and if you don&#x27;t express the update rules in a database schema, it must be in the application code.  Subtle errors are more likely in that case.<p>In the 1990s I was a certified Novell networking instructor.  Every month their database mysteriously delist me.  The problem was never found but would have been prevented if their db was in normal form.  (Instead I was given the VP of education&#x27;s direct phone number and he kept my records on his desk. As soon as I saw that I was delist, I would call him and he had someone reenter my data.)<p>Adding fields to tables and trying to update all the application code seems cheaper than redesigning the schema.  At first.  Later, you just need to normalize tables that have evolved &quot;organically&quot;, so teaching the procedures for that is reasonable even in 2024.</div><br/><div id="42354059" class="c"><input type="checkbox" id="c-42354059" checked=""/><div class="controls bullet"><span class="by">danparsonson</span><span>|</span><a href="#42353934">parent</a><span>|</span><a href="#42355102">prev</a><span>|</span><a href="#42355500">next</a><span>|</span><label class="collapse" for="c-42354059">[-]</label><label class="expand" for="c-42354059">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  The problem was never found but would have been prevented if their db was in normal form.<p>Sorry to be pedantic - if they didn&#x27;t find the problem, how do we know that was the solution?</div><br/><div id="42354900" class="c"><input type="checkbox" id="c-42354900" checked=""/><div class="controls bullet"><span class="by">wpollock</span><span>|</span><a href="#42353934">root</a><span>|</span><a href="#42354059">parent</a><span>|</span><a href="#42355500">next</a><span>|</span><label class="collapse" for="c-42354900">[-]</label><label class="expand" for="c-42354900">[1 more]</label></div><br/><div class="children"><div class="content">I suppose I don&#x27;t know for sure.  But normal forms prevent false data creation and data loss, and I know their db was not normalized from conversations with their IT support, so it&#x27;s a pretty good guess.</div><br/></div></div></div></div></div></div><div id="42355500" class="c"><input type="checkbox" id="c-42355500" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#42353934">prev</a><span>|</span><a href="#42355604">next</a><span>|</span><label class="collapse" for="c-42355500">[-]</label><label class="expand" for="c-42355500">[1 more]</label></div><br/><div class="children"><div class="content">There are several issues with this:<p>1. 4NF is dependent on context. This context is described as dependencies.<p>In the example of employees, skills and languages the design with two separate &quot;link tables&quot; employee_skills and employee_language is not obvious at all without specifying requirements _first_. If there is a requirement that an employee skill depends on the language (ie. an employee can type in a particular language only) - the design with a single 3 attributes table is the right one.<p>2. Multivalued attributes discussion is missing several important aspects for example referential integrity. It is not at all obvious what should happen when a language is deleted from languages table. Once you start adding rules and language to specify referential integrity for multivalued attributes you very quickly end up with... splitting multivalued attributes into separate relations.</div><br/></div></div><div id="42355604" class="c"><input type="checkbox" id="c-42355604" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42355500">prev</a><span>|</span><a href="#42353064">next</a><span>|</span><label class="collapse" for="c-42355604">[-]</label><label class="expand" for="c-42355604">[1 more]</label></div><br/><div class="children"><div class="content">Every time I read explanations of any database anything, it looks childishly simplistic to what I&#x27;ve done with C pointers and structs.<p>Basically it all exists because of storage devices:<p>- large transfer factors (spinning platter hard drive track access, flash erase blocks)<p>- latency (spinning platter track to track seek, and rotational latency)<p>Once you have fast random access, it&#x27;s data structures and algorithms: forget the database cruft.</div><br/></div></div><div id="42353064" class="c"><input type="checkbox" id="c-42353064" checked=""/><div class="controls bullet"><span class="by">mgkimsal</span><span>|</span><a href="#42355604">prev</a><span>|</span><a href="#42354590">next</a><span>|</span><label class="collapse" for="c-42353064">[-]</label><label class="expand" for="c-42353064">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The existence of the theory implies that the “composed” design somehow arises, naively(?) or naturally.&quot;<p>Given how many first timers come up with really weird schema designs, I&#x27;m not necessarily surprised, although I agree presenting it as perhaps a default-but-wrong approach doesn&#x27;t help much.</div><br/></div></div><div id="42354590" class="c"><input type="checkbox" id="c-42354590" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42353064">prev</a><span>|</span><a href="#42353794">next</a><span>|</span><label class="collapse" for="c-42354590">[-]</label><label class="expand" for="c-42354590">[1 more]</label></div><br/><div class="children"><div class="content">What if the languages available <i>do</i> depend on what the lesson is about?  That would require the composed form.  Skipping it entirely is not the way to go.<p>You could start with decomposed and then compose it, I guess.  I don&#x27;t think either order is inherently easier to learn.<p>I agree that the wording of the normal forms, before getting to examples, is usually confusing.</div><br/></div></div><div id="42353794" class="c"><input type="checkbox" id="c-42353794" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#42354590">prev</a><span>|</span><a href="#42354215">next</a><span>|</span><label class="collapse" for="c-42353794">[-]</label><label class="expand" for="c-42353794">[4 more]</label></div><br/><div class="children"><div class="content">Excellent article.  1NF is part of the problem as the article mentions.<p>I&#x27;m seen some articles say that atomic in 1NF means you cannot have things that can be decomposed.  All that matters is that you can perform the relational algebra on the table and get a sensible result.<p>To the <i>why</i> of presenting normalisation from those wacky forms, I think that also comes from data ingestion.  You&#x27;ll get a list of attributes for an employee from their CV and might naively just load that &#x27;as is&#x27; into a table.</div><br/><div id="42354539" class="c"><input type="checkbox" id="c-42354539" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42353794">parent</a><span>|</span><a href="#42354215">next</a><span>|</span><label class="collapse" for="c-42354539">[-]</label><label class="expand" for="c-42354539">[3 more]</label></div><br/><div class="children"><div class="content">&gt; you cannot have things that can be decomposed.<p>Indeed. You couldn’t store integers because those are decomposable into bits.<p>Atomicity was always a BS concept, and Chris Date and Hugh Darwen themselves have written as much on this topic. It didn’t help that although Edgar Codd had a math background, a lot of things published on the relational model just didn’t have formal rigor, but people interpreted it as such.</div><br/><div id="42354877" class="c"><input type="checkbox" id="c-42354877" checked=""/><div class="controls bullet"><span class="by">webstrand</span><span>|</span><a href="#42353794">root</a><span>|</span><a href="#42354539">parent</a><span>|</span><a href="#42354617">next</a><span>|</span><label class="collapse" for="c-42354877">[-]</label><label class="expand" for="c-42354877">[1 more]</label></div><br/><div class="children"><div class="content">Technically you&#x27;re storing the order of the bits, which isn&#x27;t decomposable.</div><br/></div></div><div id="42354617" class="c"><input type="checkbox" id="c-42354617" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#42353794">root</a><span>|</span><a href="#42354539">parent</a><span>|</span><a href="#42354877">prev</a><span>|</span><a href="#42354215">next</a><span>|</span><label class="collapse" for="c-42354617">[-]</label><label class="expand" for="c-42354617">[1 more]</label></div><br/><div class="children"><div class="content">Well without atomicity you can&#x27;t have 1NF, and thus none of the latter. So let&#x27;s hope you never store a content of a text content of a configuration or log.</div><br/></div></div></div></div></div></div><div id="42354215" class="c"><input type="checkbox" id="c-42354215" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#42353794">prev</a><span>|</span><a href="#42353855">next</a><span>|</span><label class="collapse" for="c-42354215">[-]</label><label class="expand" for="c-42354215">[1 more]</label></div><br/><div class="children"><div class="content">The origin of classic explanation probably comes from people attempting to computerize paper forms.  The school would have profiles for each teacher, probably a series of pages in a manila folder stored in a filing cabinet, that was filled out by hand&#x2F;a typewriter.  A space for the name. A series of blanks to be filled in with a list of skills (that maxes out at however many blanks they could put on the page). A series of blanks for languages.  Woe is the teacher who knows more languages than the available blanks that are on the form!<p>People still create tables today (yes, even in 2024) like (teacher, skill, language) as the row definition.  Someone looks at the list of information they are collecting, conclude that the only axis they need to query on is the teacher, and make wide tables with many columns with disjoint purposes, that are then difficult to query and are inflexible.<p>Consider a library card catalog and the Dewey Decimal Classification system.  The cards are arranged in the drawers by the topics standardized in the DDC.  It looks like the major axis is the DDC numbering and their associated topics.  While a card catalog lets you search for specific books if you know the topic and the author, it can not easily tell you all the books by the same author, or the list of topics that an author covers.  Or find all the books that multiple authors have written together.  But if one was to take the card catalog as it existed and computerize it, the naïve implementation would look like the unnormalized or lower normalization forms. The explanation of the progression of increasing normalization tells you how to incrementally achieve normalization given a data schema that was heavily influenced by the limitations of physical reality, such that a card catalog is, into a system that does not have those constraints.<p>The example of storing the skills and language as a list <i>in a column</i> is grossly inefficient <i>in usage</i> (ignoring the inefficiencies in storage and performance) and ignores that the &quot;list&quot; in 4NF is actually the result set, the set of rows returned.  I suppose it <i>could</i> help one to think of the result set as horizontal columns (a list) rather than a vertical set of rows, but that&#x27;s more of a side effect of the data presentation than the relational algebra underpinnings.  Despite that databases like postgres let you query and index on expressions applied to a JSON-typed column, you end up with something more complex, with different methods of enforcing data hygiene at the row and the individual column level, because you&#x27;ve got <i>sets</i> of data in a single column, when the set is the defined by the rows.  4NF lets you answer way more questions about the data than you might initially anticipate.  I&#x27;ve worked with a number of schemas that someone else created with no or little normalization that literally <i>could not answer</i> the desired questions.  In this example, improper normalization results in finding out the skills of a teacher is easy, but finding out if the school is weak in any areas and what they should hire for is hard. But when the data is 4NF, you can answer questions easily in both directions without jumping through any data conversion hoops and you can have high confidence that the data remains hygienic.</div><br/></div></div><div id="42353855" class="c"><input type="checkbox" id="c-42353855" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42354215">prev</a><span>|</span><a href="#42354350">next</a><span>|</span><label class="collapse" for="c-42353855">[-]</label><label class="expand" for="c-42353855">[1 more]</label></div><br/><div class="children"><div class="content">A possible clue is that the weird composed form is, still, the only possible form in which you can actually get results out of your SQL database.<p>Perhaps people worked backwards from sample query results, reasoning that an output that looks like that should come from a table that looks like that. Of course that begs the question of why that ever seemed like a sensible format for output, but apparently the SQL establishment has never seen fit to change it, so either the SQL people are all idiots or there&#x27;s some advantage to that form.<p>(Yes, I know there is an obsolete meaning of that phrase still recorded in some dictionaries, but I prefer to use live English)</div><br/></div></div><div id="42354350" class="c"><input type="checkbox" id="c-42354350" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#42353855">prev</a><span>|</span><a href="#42354353">next</a><span>|</span><label class="collapse" for="c-42354350">[-]</label><label class="expand" for="c-42354350">[1 more]</label></div><br/><div class="children"><div class="content">Database normalization: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Database_normalization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Database_normalization</a><p>4NF: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fourth_normal_form" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fourth_normal_form</a></div><br/></div></div><div id="42354353" class="c"><input type="checkbox" id="c-42354353" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#42354350">prev</a><span>|</span><label class="collapse" for="c-42354353">[-]</label><label class="expand" for="c-42354353">[1 more]</label></div><br/><div class="children"><div class="content">When I learned quantum mechanics as part of a Chemistry BSc, it was broken down so as to be easier to digest. It made it much fucking harder for me. When I did it as a Phsyicist, they just laid out the math and it was super straightforward. I think back when they came up with 4NF, everyone was still trying to figure out what the fuck they were talking about, and so explanations were needlessly complicated.<p>Anyway, now with non-relational databases, 4NF can slow you down.</div><br/></div></div></div></div></div></div></div></body></html>