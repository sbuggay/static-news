<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695546059968" as="style"/><link rel="stylesheet" href="styles.css?v=1695546059968"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://agraphicsguynotes.com/posts/fiber_in_cpp_understanding_the_basics/">Fiber in C++: Understanding the Basics</a> <span class="domain">(<a href="https://agraphicsguynotes.com">agraphicsguynotes.com</a>)</span></div><div class="subtext"><span>ibobev</span> | <span>18 comments</span></div><br/><div><div id="37631215" class="c"><input type="checkbox" id="c-37631215" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#37630605">next</a><span>|</span><label class="collapse" for="c-37631215">[-]</label><label class="expand" for="c-37631215">[1 more]</label></div><br/><div class="children"><div class="content">Since coroutines have been in the standard since C++20, I wish he would have explained better what are the advantages of using a Fiber over a Coroutine.</div><br/></div></div><div id="37630605" class="c"><input type="checkbox" id="c-37630605" checked=""/><div class="controls bullet"><span class="by">hackyhacky</span><span>|</span><a href="#37631215">prev</a><span>|</span><a href="#37630972">next</a><span>|</span><label class="collapse" for="c-37630605">[-]</label><label class="expand" for="c-37630605">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused in how this article defines &quot;fiber.&quot; At the beginning of the article, fibers are described as a lightweight userspace thread, similar to what is provided in the runtimes of Haskell and Go, and has been recently revived in Java as &quot;virtual threads.&quot;<p>However, later in the article (after a long and apparently irrelevant digression about stack management), they describe Windows API functions that are required for using fibers and seem to suggest that fibers are OS-level, and not application-managed.<p>Am I missing something?<p>[edit: typo]</div><br/><div id="37631056" class="c"><input type="checkbox" id="c-37631056" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#37630605">parent</a><span>|</span><a href="#37630809">next</a><span>|</span><label class="collapse" for="c-37631056">[-]</label><label class="expand" for="c-37631056">[1 more]</label></div><br/><div class="children"><div class="content">The Windows fiber library is just that, a library. It&#x27;s not an OS component. It&#x27;s provided because stack switching in Windows is a somewhat fraught [1] and not officially documented procedure which requires modifying  the TIB [2].<p>Doing it correctly isn&#x27;t hard, and has been done many times in bullet-proof libs (notably boost::context), but MS would maybe rather you not.<p>[1]: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20080215-00&#x2F;?p=23443" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20080215-00&#x2F;?p=23...</a><p>[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Win32_Thread_Information_Block" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Win32_Thread_Information_Block</a></div><br/></div></div><div id="37630809" class="c"><input type="checkbox" id="c-37630809" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#37630605">parent</a><span>|</span><a href="#37631056">prev</a><span>|</span><a href="#37630793">next</a><span>|</span><label class="collapse" for="c-37630809">[-]</label><label class="expand" for="c-37630809">[1 more]</label></div><br/><div class="children"><div class="content">Windows has its own fibers facility which does some things for you but still leaves the scheduling to the application so it&#x27;s still fibers. It&#x27;s a little confusing in the article but they look at the Windows API as a kind of API template - what do you need to implement to have fibers. Then they describe their own implementation.</div><br/></div></div><div id="37630793" class="c"><input type="checkbox" id="c-37630793" checked=""/><div class="controls bullet"><span class="by">ojkelly</span><span>|</span><a href="#37630605">parent</a><span>|</span><a href="#37630809">prev</a><span>|</span><a href="#37630883">next</a><span>|</span><label class="collapse" for="c-37630793">[-]</label><label class="expand" for="c-37630793">[1 more]</label></div><br/><div class="children"><div class="content">My general understanding is that a fiber is a lightweight thread, and conceptually can be implemented inside any program that wants to schedule its own fibers.<p>They’re distinct from CPU threads.<p>When I last dived into fibers I discovered windows was trying to make them a thing quite a while ago which is why we have things like [0].<p>Fibers being virtual threads, are recursive. In the same way you can run a VM inside a VM, you could build fibers on top of fibers (which sounds like a recipe for unpredictable performance).<p>[0] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;procthread&#x2F;using-fibers" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;procthread&#x2F;u...</a></div><br/></div></div><div id="37630883" class="c"><input type="checkbox" id="c-37630883" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37630605">parent</a><span>|</span><a href="#37630793">prev</a><span>|</span><a href="#37630972">next</a><span>|</span><label class="collapse" for="c-37630883">[-]</label><label class="expand" for="c-37630883">[1 more]</label></div><br/><div class="children"><div class="content">Fiber is a concept in Windows API for user-space thread.<p>It was designed for MS SQL Server. It have a very confusing API and did not gain much use in 3rd party applications.</div><br/></div></div></div></div><div id="37630972" class="c"><input type="checkbox" id="c-37630972" checked=""/><div class="controls bullet"><span class="by">endorphine</span><span>|</span><a href="#37630605">prev</a><span>|</span><a href="#37630604">next</a><span>|</span><label class="collapse" for="c-37630972">[-]</label><label class="expand" for="c-37630972">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Fiber is quite a lightweight thread of execution. Like coroutine, fiber allows yielding at any point inside it. To some degree, we can regard fiber as a form of stackful coroutine [...]<p>Can someone explain what the &quot;stackful coroutine&quot; term means (ideally with an example)? And how can one implement it?</div><br/><div id="37631020" class="c"><input type="checkbox" id="c-37631020" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#37630972">parent</a><span>|</span><a href="#37631035">next</a><span>|</span><label class="collapse" for="c-37631020">[-]</label><label class="expand" for="c-37631020">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s exactly what it says, it&#x27;s a coroutine with its own stack.<p>A fiber isn&#x27;t <i>to some degree</i> a stackful coroutine, it <i>is</i> a stackful coroutine.<p>A stackless coroutine does not have a its own stack, it uses the calling context&#x27;s stack and therefore can only yield to the calling context from the top-level coroutine function. A stackful coroutine has its own stack, and so can yield to the calling context from anywhere.<p>As far as how to implement, I always liked Malte Skarupke&#x27;s blog post on the subject: <a href="https:&#x2F;&#x2F;probablydance.com&#x2F;2013&#x2F;02&#x2F;20&#x2F;handmade-coroutines-for-windows&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;probablydance.com&#x2F;2013&#x2F;02&#x2F;20&#x2F;handmade-coroutines-for...</a></div><br/></div></div><div id="37631035" class="c"><input type="checkbox" id="c-37631035" checked=""/><div class="controls bullet"><span class="by">nstbayless</span><span>|</span><a href="#37630972">parent</a><span>|</span><a href="#37631020">prev</a><span>|</span><a href="#37630604">next</a><span>|</span><label class="collapse" for="c-37631035">[-]</label><label class="expand" for="c-37631035">[1 more]</label></div><br/><div class="children"><div class="content">I assume it&#x27;s this:<p>In Python, coroutines cannot yield from within another function call: if coroutine A calls function B, B cannot yield. In Lua, it&#x27;s possible to yield a coroutine at any function depth: B can yield.<p>To implement something like this in a compiled language, you just need multiple stacks instead of the usual 1. Most architectures, such as x86, have a stack pointer register; when yielding a coroutine, just change the sp register to point to some other stack -- when resuming, restore the sp.<p>This is not a new concept. Pokémon on the gameboy did this for its UI fiber, for example.</div><br/></div></div></div></div><div id="37630604" class="c"><input type="checkbox" id="c-37630604" checked=""/><div class="controls bullet"><span class="by">IceMichael</span><span>|</span><a href="#37630972">prev</a><span>|</span><a href="#37630724">next</a><span>|</span><label class="collapse" for="c-37630604">[-]</label><label class="expand" for="c-37630604">[3 more]</label></div><br/><div class="children"><div class="content">Still looking for a lib that supports fibers... boost::asio is... well, boost, and therefore annoying. It also does not support it out of the box</div><br/><div id="37630962" class="c"><input type="checkbox" id="c-37630962" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37630604">parent</a><span>|</span><a href="#37631004">next</a><span>|</span><label class="collapse" for="c-37630962">[-]</label><label class="expand" for="c-37630962">[1 more]</label></div><br/><div class="children"><div class="content">Boost asio is available as a standalone lib as well. What do you mean it doesn&#x27;t support &quot;it&quot; out of the box?</div><br/></div></div><div id="37631004" class="c"><input type="checkbox" id="c-37631004" checked=""/><div class="controls bullet"><span class="by">yellow_lead</span><span>|</span><a href="#37630604">parent</a><span>|</span><a href="#37630962">prev</a><span>|</span><a href="#37630724">next</a><span>|</span><label class="collapse" for="c-37631004">[-]</label><label class="expand" for="c-37631004">[1 more]</label></div><br/><div class="children"><div class="content">Asio has strands which may be an alternative depending on the use case.</div><br/></div></div></div></div><div id="37630724" class="c"><input type="checkbox" id="c-37630724" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#37630604">prev</a><span>|</span><label class="collapse" for="c-37630724">[-]</label><label class="expand" for="c-37630724">[5 more]</label></div><br/><div class="children"><div class="content">Again, academia and the tech press overlook to talk about Actors, and we live in a world with poorly implemented pretend Actor subsets, without any of the true Actor features (work stealing, message passing etc, and best of all, no contention since no shared resources, other than Actor references).<p>Fibres, goroutines, promises, futures, job queues, etc, are poor substitutes for Actors.</div><br/><div id="37630829" class="c"><input type="checkbox" id="c-37630829" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#37630724">parent</a><span>|</span><a href="#37630920">next</a><span>|</span><label class="collapse" for="c-37630829">[-]</label><label class="expand" for="c-37630829">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fibres, goroutines, promises, futures, job queues, etc, are poor substitutes for Actors.<p>They are not necessarily substitutes, they are lower level primitives that allow more complex models, like Actors, to be implemented.<p>All execution models have trade offs; and sometimes we might prefer an execution model without deadlock, livelock and starvation. So for a general purpose language, a complex model like Actors is ideally a library and not enforced as the only way of achieving concurrency.</div><br/></div></div><div id="37630920" class="c"><input type="checkbox" id="c-37630920" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#37630724">parent</a><span>|</span><a href="#37630829">prev</a><span>|</span><a href="#37630748">next</a><span>|</span><label class="collapse" for="c-37630920">[-]</label><label class="expand" for="c-37630920">[2 more]</label></div><br/><div class="children"><div class="content">No shared resources can be a performance problem, I can see why there are rusts and vales efforts to come to a slightly different tradeoff.</div><br/><div id="37631188" class="c"><input type="checkbox" id="c-37631188" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#37630724">root</a><span>|</span><a href="#37630920">parent</a><span>|</span><a href="#37630748">next</a><span>|</span><label class="collapse" for="c-37631188">[-]</label><label class="expand" for="c-37631188">[1 more]</label></div><br/><div class="children"><div class="content">Pony&#x2F;Ponylang claims that they can do actors fast and safe (even safer than rust). There is a type system that allows one to share data between actors safely, or so they claim.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>