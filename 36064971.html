<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685005259881" as="style"/><link rel="stylesheet" href="styles.css?v=1685005259881"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xorvoid.com/sectorc.html">SectorC: A C Compiler in 512 bytes</a> <span class="domain">(<a href="https://xorvoid.com">xorvoid.com</a>)</span></div><div class="subtext"><span>xorvoid</span> | <span>48 comments</span></div><br/><div><div id="36066321" class="c"><input type="checkbox" id="c-36066321" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36065509">next</a><span>|</span><label class="collapse" for="c-36066321">[-]</label><label class="expand" for="c-36066321">[6 more]</label></div><br/><div class="children"><div class="content">I saw the repeating &#x27;A&#x27; at the end of the base64 text and thought &quot;it&#x27;s not even 512 bytes; it&#x27;s smaller!&quot;<p>That said, the title is just a little clickbaity --- it&#x27;s a C-subset compiler, and more accurately a JIT interpreter. There also appears to be no attempt at operator precedence. Nonetheless, it&#x27;s still an impressive technical achievement and shows the value of questioning common assumptions.<p>Finally, I feel tempted to offer a small size optimisation:<p><pre><code>    sub ax,2
</code></pre>
is 3 bytes whereas<p><pre><code>    dec ax
    dec ax
</code></pre>
is 2 bytes.<p>You may be able to use single-byte xchg&#x27;s with ax instead of movs, and the other thing which helps code density a lot in 16-bit code is to take advantage of the addressing modes and LEA to do 3-operand add immediates where possible.</div><br/><div id="36067080" class="c"><input type="checkbox" id="c-36067080" checked=""/><div class="controls bullet"><span class="by">xorvoid</span><span>|</span><a href="#36066321">parent</a><span>|</span><a href="#36066949">next</a><span>|</span><label class="collapse" for="c-36067080">[-]</label><label class="expand" for="c-36067080">[1 more]</label></div><br/><div class="children"><div class="content">Good tip! Yeah, there’s ~20 bytes unused at the end. I kept finding ways to squeeze out a few more and had to tell myself to stop and just publish it already. You could take this further if you really wanted. But it’s already sufficiently absurd.</div><br/></div></div><div id="36066949" class="c"><input type="checkbox" id="c-36066949" checked=""/><div class="controls bullet"><span class="by">kyberias</span><span>|</span><a href="#36066321">parent</a><span>|</span><a href="#36067080">prev</a><span>|</span><a href="#36065509">next</a><span>|</span><label class="collapse" for="c-36066949">[-]</label><label class="expand" for="c-36066949">[4 more]</label></div><br/><div class="children"><div class="content">What does Just In Time mean for an interpreter?</div><br/><div id="36067223" class="c"><input type="checkbox" id="c-36067223" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36066321">root</a><span>|</span><a href="#36066949">parent</a><span>|</span><a href="#36065509">next</a><span>|</span><label class="collapse" for="c-36067223">[-]</label><label class="expand" for="c-36067223">[3 more]</label></div><br/><div class="children"><div class="content">Compiling to machine instructions and then executing the compiled output, instead of executing the AST directly.</div><br/><div id="36067657" class="c"><input type="checkbox" id="c-36067657" checked=""/><div class="controls bullet"><span class="by">stefncb</span><span>|</span><a href="#36066321">root</a><span>|</span><a href="#36067223">parent</a><span>|</span><a href="#36065509">next</a><span>|</span><label class="collapse" for="c-36067657">[-]</label><label class="expand" for="c-36067657">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a just-in-time compiler.</div><br/><div id="36068413" class="c"><input type="checkbox" id="c-36068413" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#36066321">root</a><span>|</span><a href="#36067657">parent</a><span>|</span><a href="#36065509">next</a><span>|</span><label class="collapse" for="c-36068413">[-]</label><label class="expand" for="c-36068413">[1 more]</label></div><br/><div class="children"><div class="content">An interpreter with a JIT compiler is able to do more optimizations because it has the runtime context to make decisions, while a AOT (ahead of time) compiler will not know anything about what happens at runtime.<p>This is why some JIT&#x27;d languages (like Javascript) can be sometimes faster than C.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36065509" class="c"><input type="checkbox" id="c-36065509" checked=""/><div class="controls bullet"><span class="by">xonix</span><span>|</span><a href="#36066321">prev</a><span>|</span><a href="#36066426">next</a><span>|</span><label class="collapse" for="c-36065509">[-]</label><label class="expand" for="c-36065509">[10 more]</label></div><br/><div class="children"><div class="content">This reminded me the idea of compilers bootstrapping (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35714194" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35714194</a>). That is, now you can code in SectorC some slightly more advanced version of C capable of compiling TCC (<a href="https:&#x2F;&#x2F;bellard.org&#x2F;tcc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bellard.org&#x2F;tcc&#x2F;</a>), and then with TCC you can go forward to GCC and so on.</div><br/><div id="36065846" class="c"><input type="checkbox" id="c-36065846" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#36065509">parent</a><span>|</span><a href="#36067016">next</a><span>|</span><label class="collapse" for="c-36065846">[-]</label><label class="expand" for="c-36065846">[4 more]</label></div><br/><div class="children"><div class="content">Did you read about the guix full source bootstrap the other day? They&#x27;ve shrunk the bootstrap seed down to a 357-byte program:<p><a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;blog&#x2F;2023&#x2F;the-full-source-bootstrap-building-from-source-all-the-way-down&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;blog&#x2F;2023&#x2F;the-full-source-bootstrap-bui...</a></div><br/><div id="36066051" class="c"><input type="checkbox" id="c-36066051" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36065509">root</a><span>|</span><a href="#36065846">parent</a><span>|</span><a href="#36066199">next</a><span>|</span><label class="collapse" for="c-36066051">[-]</label><label class="expand" for="c-36066051">[1 more]</label></div><br/><div class="children"><div class="content">The bootstrap seed, <a href="https:&#x2F;&#x2F;github.com&#x2F;oriansj&#x2F;bootstrap-seeds&#x2F;blob&#x2F;master&#x2F;POSIX&#x2F;x86&#x2F;hex0_x86.hex0">https:&#x2F;&#x2F;github.com&#x2F;oriansj&#x2F;bootstrap-seeds&#x2F;blob&#x2F;master&#x2F;POSIX...</a>, is a tiny interpreter that takes a much larger program written in a special-purpose, bytecode-based language. This proceeds in turn once or twice more--special purpose program generating another interpreter for another special-purpose language--until you end up with a minimal Scheme interpreter, which then can be used to execute a C compiler program.<p>All of this is incredible work, but a minimal C-subset compiler in under 512 bytes of x86 assembly seems like a unique achievement as it includes non-trivial parsing and linking phases not required for that hex0 interpreter.</div><br/></div></div><div id="36066199" class="c"><input type="checkbox" id="c-36066199" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36065509">root</a><span>|</span><a href="#36065846">parent</a><span>|</span><a href="#36066051">prev</a><span>|</span><a href="#36066982">next</a><span>|</span><label class="collapse" for="c-36066199">[-]</label><label class="expand" for="c-36066199">[1 more]</label></div><br/><div class="children"><div class="content">From that article:<p>&gt; Even more recently (2018), the GNU C Library glibc-2.28 adds Python as a build requirement<p>I’m surprised they went with Python and not GNU software (e.g. Guile).<p>Edit: clicking through the link it sounds like this might be intended to replace other accumulated dependencies (Perl?) and stop supporting old versions of Python.</div><br/></div></div><div id="36066982" class="c"><input type="checkbox" id="c-36066982" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#36065509">root</a><span>|</span><a href="#36065846">parent</a><span>|</span><a href="#36066199">prev</a><span>|</span><a href="#36067016">next</a><span>|</span><label class="collapse" for="c-36066982">[-]</label><label class="expand" for="c-36066982">[1 more]</label></div><br/><div class="children"><div class="content">Is Nix incorporating this work as well? I fully support and want Guix to survive, but it seems well behind in mind share, and I would love if Nix could become similarly repeatable and reproducible.</div><br/></div></div></div></div><div id="36067016" class="c"><input type="checkbox" id="c-36067016" checked=""/><div class="controls bullet"><span class="by">xorvoid</span><span>|</span><a href="#36065509">parent</a><span>|</span><a href="#36065846">prev</a><span>|</span><a href="#36066208">next</a><span>|</span><label class="collapse" for="c-36067016">[-]</label><label class="expand" for="c-36067016">[1 more]</label></div><br/><div class="children"><div class="content">I’ve considered that. I’ve long been interested in bootstrapping. Lots of unpublished projects in the archive that I should also write up.<p>I considered writing a self-hosting compiler. It should be  doable without too much work. I was going to do one in BarelyC originally.<p>SectorC -&gt; TCC -&gt; GCC sounds fun. C all the way down, haha</div><br/></div></div><div id="36066208" class="c"><input type="checkbox" id="c-36066208" checked=""/><div class="controls bullet"><span class="by">plagiarist</span><span>|</span><a href="#36065509">parent</a><span>|</span><a href="#36067016">prev</a><span>|</span><a href="#36066202">next</a><span>|</span><label class="collapse" for="c-36066208">[-]</label><label class="expand" for="c-36066208">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps my favorite thing in all of computing is the authors of Lisp bootstrapping by writing an (academic) interpreter for Lisp in Lisp, and then realizing they could just compile that by hand.</div><br/></div></div><div id="36066202" class="c"><input type="checkbox" id="c-36066202" checked=""/><div class="controls bullet"><span class="by">bragr</span><span>|</span><a href="#36065509">parent</a><span>|</span><a href="#36066208">prev</a><span>|</span><a href="#36067911">next</a><span>|</span><label class="collapse" for="c-36066202">[-]</label><label class="expand" for="c-36066202">[2 more]</label></div><br/><div class="children"><div class="content">The TCC step seems unnecessary. If you&#x27;ve got a SectorC C compiler sufficient to compile TCC, it can probably compile the bootstrap compiler used in GCC&#x27;s 3 stage build process. The bigger issue is probably getting the ancillary tools up and running (a shell, make, coreutils, ...)<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;install&#x2F;build.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;install&#x2F;build.html</a></div><br/><div id="36068014" class="c"><input type="checkbox" id="c-36068014" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#36065509">root</a><span>|</span><a href="#36066202">parent</a><span>|</span><a href="#36067911">next</a><span>|</span><label class="collapse" for="c-36068014">[-]</label><label class="expand" for="c-36068014">[1 more]</label></div><br/><div class="children"><div class="content">The method described in the page you reference, does not exclude the possibility that the compiler you start with, contains malicious code, and recognizes that it is compiling the GCC code base. It is not true bootstrapping as described in [0]. If you read through [1] you will see that even getting a fairly recent version of TCC to compile is not that simple.<p>[0] <a href="https:&#x2F;&#x2F;bootstrappable.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bootstrappable.org&#x2F;</a>
[1] <a href="https:&#x2F;&#x2F;bootstrapping.miraheze.org&#x2F;wiki&#x2F;Live-bootstrap" rel="nofollow">https:&#x2F;&#x2F;bootstrapping.miraheze.org&#x2F;wiki&#x2F;Live-bootstrap</a></div><br/></div></div></div></div><div id="36067911" class="c"><input type="checkbox" id="c-36067911" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36065509">parent</a><span>|</span><a href="#36066202">prev</a><span>|</span><a href="#36066426">next</a><span>|</span><label class="collapse" for="c-36067911">[-]</label><label class="expand" for="c-36067911">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if anybody tried to maintain TCC</div><br/></div></div></div></div><div id="36066426" class="c"><input type="checkbox" id="c-36066426" checked=""/><div class="controls bullet"><span class="by">molticrystal</span><span>|</span><a href="#36065509">prev</a><span>|</span><a href="#36066769">next</a><span>|</span><label class="collapse" for="c-36066426">[-]</label><label class="expand" for="c-36066426">[2 more]</label></div><br/><div class="children"><div class="content">Now they just need to port something like oneKpaq to 16 bit or maybe something from the <i>extremely tiny decompressor</i> thread [1], just to test compression level to get an idea kpaq on its quickest setting(taking minutes instead of what could be days on its highest) reduced SectorC to 82.81% of its size, of course adding the 128 bit stub knocked it to 677 bytes.  It would be interesting to try it on the slowest takes day to bruteforce setting, but I&#x27;m not going to attempt that.<p>Some of the compressors in that forum thread since they are 32 bytes and such, might find it easier to get net gains.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;temisu&#x2F;oneKpaq">https:&#x2F;&#x2F;github.com&#x2F;temisu&#x2F;oneKpaq</a><p>[1] <a href="https:&#x2F;&#x2F;encode.su&#x2F;threads&#x2F;3387-(Extremely)-tiny-decompressors" rel="nofollow">https:&#x2F;&#x2F;encode.su&#x2F;threads&#x2F;3387-(Extremely)-tiny-decompressor...</a></div><br/><div id="36066635" class="c"><input type="checkbox" id="c-36066635" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36066426">parent</a><span>|</span><a href="#36066769">next</a><span>|</span><label class="collapse" for="c-36066635">[-]</label><label class="expand" for="c-36066635">[1 more]</label></div><br/><div class="children"><div class="content">LZ decompressors are tiny, as your second link discusses, but it is unlikely that they&#x27;ll find much redundancy that could easily be removed from the uncompressed program itself, thus removing the need to use them.</div><br/></div></div></div></div><div id="36066769" class="c"><input type="checkbox" id="c-36066769" checked=""/><div class="controls bullet"><span class="by">kvakil</span><span>|</span><a href="#36066426">prev</a><span>|</span><a href="#36066277">next</a><span>|</span><label class="collapse" for="c-36066769">[-]</label><label class="expand" for="c-36066769">[2 more]</label></div><br/><div class="children"><div class="content">wow, this is impressive.<p>I wrote a similar x86-16 assembler in &lt; 512 B of x86-16 assembly, and this seems much more difficult &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;kvakil&#x2F;0asm&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;kvakil&#x2F;0asm&#x2F;</a>&gt;. I did find a lot of similar tricks were helpful: using gadgets and hashes. Once trick I don&#x27;t see in sectorc which shaved quite a bit off of 0asm was self-modifying code, which 0asm uses to &quot;change&quot; to the second-pass of the assembler. (I wrote some other techniques here: &lt;<a href="https:&#x2F;&#x2F;kvakil.me&#x2F;posts&#x2F;asmkoan.html" rel="nofollow">https:&#x2F;&#x2F;kvakil.me&#x2F;posts&#x2F;asmkoan.html</a>&gt;.)<p>bootOS (&lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;nanochess&#x2F;bootOS">https:&#x2F;&#x2F;github.com&#x2F;nanochess&#x2F;bootOS</a>&gt;) and other tools by the author are also amazing works of assembly golf.</div><br/><div id="36067036" class="c"><input type="checkbox" id="c-36067036" checked=""/><div class="controls bullet"><span class="by">xorvoid</span><span>|</span><a href="#36066769">parent</a><span>|</span><a href="#36066277">next</a><span>|</span><label class="collapse" for="c-36067036">[-]</label><label class="expand" for="c-36067036">[1 more]</label></div><br/><div class="children"><div class="content">I considered self-modifying code, but somehow I kept finding more ways to squeeze bytes out. I’m half convinced that you could condense it another 50 ish bytes and add operator precedence or even local vars. But.. frankly.. I was ready to switch my attention to a new project.</div><br/></div></div></div></div><div id="36066277" class="c"><input type="checkbox" id="c-36066277" checked=""/><div class="controls bullet"><span class="by">kiwidrew</span><span>|</span><a href="#36066769">prev</a><span>|</span><a href="#36065640">next</a><span>|</span><label class="collapse" for="c-36066277">[-]</label><label class="expand" for="c-36066277">[2 more]</label></div><br/><div class="children"><div class="content">This is fascinating, I really did not think it was possible to implement even a tiny subset of C in just 512 bytes of x86 code.  Using atoi() as a generic hash function is a brilliantly awful hack!</div><br/><div id="36067702" class="c"><input type="checkbox" id="c-36067702" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#36066277">parent</a><span>|</span><a href="#36065640">next</a><span>|</span><label class="collapse" for="c-36067702">[-]</label><label class="expand" for="c-36067702">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this was great:<p><i>Hashes are perhaps the holy-grail of computer-science. With a good hash, we can just side-step all the hard problems by trading them for an even harder problem (hash collisions), and then we just ignore that harder problem. Brilliant. (sticks fingers in ears) </i></div><br/></div></div></div></div><div id="36065640" class="c"><input type="checkbox" id="c-36065640" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#36066277">prev</a><span>|</span><a href="#36067681">next</a><span>|</span><label class="collapse" for="c-36065640">[-]</label><label class="expand" for="c-36065640">[2 more]</label></div><br/><div class="children"><div class="content">Pretty nifty, nice work!<p>I&#x27;ll point out to any passerby that this C doesn&#x27;t support structs, so it&#x27;s unlikely you&#x27;d actually want to build anything in it.</div><br/><div id="36067087" class="c"><input type="checkbox" id="c-36067087" checked=""/><div class="controls bullet"><span class="by">NonEUCitizen</span><span>|</span><a href="#36065640">parent</a><span>|</span><a href="#36067681">next</a><span>|</span><label class="collapse" for="c-36067087">[-]</label><label class="expand" for="c-36067087">[1 more]</label></div><br/><div class="children"><div class="content">The C Star (C*) language from the selfie project also does not support structs, yet in 12KLOC of code they implemented a C Star compiler that can compile selfie (and outputs ELF files), an emulator that runs RISC-U (RISC-V subset), and a hypervisor.</div><br/></div></div></div></div><div id="36067681" class="c"><input type="checkbox" id="c-36067681" checked=""/><div class="controls bullet"><span class="by">wkz</span><span>|</span><a href="#36065640">prev</a><span>|</span><a href="#36066006">next</a><span>|</span><label class="collapse" for="c-36067681">[-]</label><label class="expand" for="c-36067681">[1 more]</label></div><br/><div class="children"><div class="content">Great writeup!<p>Especially liked this nugget:<p>&gt; (NOTE: This grammar is 704 bytes in ascii, 38% larger than it&#x27;s implementation!)</div><br/></div></div><div id="36066006" class="c"><input type="checkbox" id="c-36066006" checked=""/><div class="controls bullet"><span class="by">pgt</span><span>|</span><a href="#36067681">prev</a><span>|</span><a href="#36065709">next</a><span>|</span><label class="collapse" for="c-36066006">[-]</label><label class="expand" for="c-36066006">[1 more]</label></div><br/><div class="children"><div class="content">Reminds of the META II Metacompiler <a href="http:&#x2F;&#x2F;hcs64.com&#x2F;files&#x2F;pd1-3-schorre.pdf" rel="nofollow">http:&#x2F;&#x2F;hcs64.com&#x2F;files&#x2F;pd1-3-schorre.pdf</a></div><br/></div></div><div id="36065709" class="c"><input type="checkbox" id="c-36065709" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36066006">prev</a><span>|</span><a href="#36068293">next</a><span>|</span><label class="collapse" for="c-36065709">[-]</label><label class="expand" for="c-36065709">[1 more]</label></div><br/><div class="children"><div class="content">The conclusion table was resume building skill in and of itself.</div><br/></div></div><div id="36068293" class="c"><input type="checkbox" id="c-36068293" checked=""/><div class="controls bullet"><span class="by">pk-protect-ai</span><span>|</span><a href="#36065709">prev</a><span>|</span><a href="#36067252">next</a><span>|</span><label class="collapse" for="c-36068293">[-]</label><label class="expand" for="c-36068293">[1 more]</label></div><br/><div class="children"><div class="content">Amazing.</div><br/></div></div><div id="36067252" class="c"><input type="checkbox" id="c-36067252" checked=""/><div class="controls bullet"><span class="by">khazhoux</span><span>|</span><a href="#36068293">prev</a><span>|</span><a href="#36066337">next</a><span>|</span><label class="collapse" for="c-36067252">[-]</label><label class="expand" for="c-36067252">[1 more]</label></div><br/><div class="children"><div class="content">Bravo!  This was a wonderful read, xorvoid.</div><br/></div></div><div id="36066337" class="c"><input type="checkbox" id="c-36066337" checked=""/><div class="controls bullet"><span class="by">zoom6628</span><span>|</span><a href="#36067252">prev</a><span>|</span><a href="#36066916">next</a><span>|</span><label class="collapse" for="c-36066337">[-]</label><label class="expand" for="c-36066337">[1 more]</label></div><br/><div class="children"><div class="content">Great read and awesome achievement. Could see this being useful for smaller microcontrollers.</div><br/></div></div><div id="36066916" class="c"><input type="checkbox" id="c-36066916" checked=""/><div class="controls bullet"><span class="by">ezekiel68</span><span>|</span><a href="#36066337">prev</a><span>|</span><a href="#36066271">next</a><span>|</span><label class="collapse" for="c-36066916">[-]</label><label class="expand" for="c-36066916">[1 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t use this... are you even suckless?</div><br/></div></div><div id="36066271" class="c"><input type="checkbox" id="c-36066271" checked=""/><div class="controls bullet"><span class="by">Snelius</span><span>|</span><a href="#36066916">prev</a><span>|</span><a href="#36065631">next</a><span>|</span><label class="collapse" for="c-36066271">[-]</label><label class="expand" for="c-36066271">[1 more]</label></div><br/><div class="children"><div class="content">It was funny to read. Thx! :))</div><br/></div></div><div id="36065631" class="c"><input type="checkbox" id="c-36065631" checked=""/><div class="controls bullet"><span class="by">DesiLurker</span><span>|</span><a href="#36066271">prev</a><span>|</span><a href="#36065606">next</a><span>|</span><label class="collapse" for="c-36065631">[-]</label><label class="expand" for="c-36065631">[4 more]</label></div><br/><div class="children"><div class="content">something like this could be interesting for deep-space applications where you only have a bare metal environment with hardened processor and limited memory &amp; of course ping time of days (to earth).<p>or alternatively for embedding a C compiler inside a LLM to use the LLM as a form of virtual machine.</div><br/><div id="36067804" class="c"><input type="checkbox" id="c-36067804" checked=""/><div class="controls bullet"><span class="by">sgtnoodle</span><span>|</span><a href="#36065631">parent</a><span>|</span><a href="#36065679">next</a><span>|</span><label class="collapse" for="c-36067804">[-]</label><label class="expand" for="c-36067804">[1 more]</label></div><br/><div class="children"><div class="content">You mean like for retrofitting an existing satellite? It seems like we&#x27;re beyond the era of extremely constrained embedded environments, even for space hardware. Several hundred Mhz PowerPC based avionics computers with hundreds of MB of RAM seemed pretty common 15 years ago.<p>What would a C interpreter do that wouldn&#x27;t be done better by simply uploading a new compiled binary, though? The source code is most likely less space efficient than machine code.</div><br/></div></div><div id="36065679" class="c"><input type="checkbox" id="c-36065679" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36065631">parent</a><span>|</span><a href="#36067804">prev</a><span>|</span><a href="#36065606">next</a><span>|</span><label class="collapse" for="c-36065679">[-]</label><label class="expand" for="c-36065679">[2 more]</label></div><br/><div class="children"><div class="content">A 512 byte memory restriction and deploying an LLM could not be on further opposite sides of the spectrum. :D</div><br/><div id="36066022" class="c"><input type="checkbox" id="c-36066022" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36065631">root</a><span>|</span><a href="#36065679">parent</a><span>|</span><a href="#36065606">next</a><span>|</span><label class="collapse" for="c-36066022">[-]</label><label class="expand" for="c-36066022">[1 more]</label></div><br/><div class="children"><div class="content">LLM currently have fairly tight token restrictions for prompting. That said chatGPT could probably compile some C. Never tried though.</div><br/></div></div></div></div></div></div><div id="36065606" class="c"><input type="checkbox" id="c-36065606" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#36065631">prev</a><span>|</span><a href="#36067568">next</a><span>|</span><label class="collapse" for="c-36065606">[-]</label><label class="expand" for="c-36065606">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering if you can build an actual &quot;Linux from scratch&quot; with this as the lowest level, without the need to use a host system at all.</div><br/><div id="36068344" class="c"><input type="checkbox" id="c-36068344" checked=""/><div class="controls bullet"><span class="by">fosslinux</span><span>|</span><a href="#36065606">parent</a><span>|</span><a href="#36066279">next</a><span>|</span><label class="collapse" for="c-36068344">[-]</label><label class="expand" for="c-36068344">[1 more]</label></div><br/><div class="children"><div class="content">Not using this, but tangentially related is (full disclosure, i am a maintainer of this project) live-bootstrap, which uses about a KB of binary to do a full &quot;Linux from scratch&quot; style thing - read <a href="https:&#x2F;&#x2F;github.com&#x2F;fosslinux&#x2F;live-bootstrap&#x2F;blob&#x2F;master&#x2F;parts.rst">https:&#x2F;&#x2F;github.com&#x2F;fosslinux&#x2F;live-bootstrap&#x2F;blob&#x2F;master&#x2F;part...</a> for all 143 steps you have to go through to get there.</div><br/></div></div><div id="36066279" class="c"><input type="checkbox" id="c-36066279" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36065606">parent</a><span>|</span><a href="#36068344">prev</a><span>|</span><a href="#36065621">next</a><span>|</span><label class="collapse" for="c-36066279">[-]</label><label class="expand" for="c-36066279">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but wonder if this is written in x86-16 bit mode to implicitly use Real Mode BIOS functions and platform interfaces as well.<p>There&#x27;s something to be said for taking advantage of that existing code; but if that&#x27;s a dependency it should be part of the environment manifest.  Everything has (most things have) a context where it might be useful and that should be included in the explanation so a tool isn&#x27;t misused and so incorrect expectations aren&#x27;t set.</div><br/><div id="36067061" class="c"><input type="checkbox" id="c-36067061" checked=""/><div class="controls bullet"><span class="by">xorvoid</span><span>|</span><a href="#36065606">root</a><span>|</span><a href="#36066279">parent</a><span>|</span><a href="#36065621">next</a><span>|</span><label class="collapse" for="c-36067061">[-]</label><label class="expand" for="c-36067061">[2 more]</label></div><br/><div class="children"><div class="content">It’s written in x86-16 real mode because all immediates are smaller and switching to 32-bit mode takes a fair amount of code.<p>I would have preferred 32-bit mode because real mode is awkward with its seg:off addressing scheme.<p>Using the bios functions just allows it to have “not-boring” examples easily.</div><br/><div id="36067350" class="c"><input type="checkbox" id="c-36067350" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36065606">root</a><span>|</span><a href="#36067061">parent</a><span>|</span><a href="#36065621">next</a><span>|</span><label class="collapse" for="c-36067350">[-]</label><label class="expand" for="c-36067350">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, but it&#x27;s still a sort of library dependency.  Even for very tiny computers with a lot of hardware assistance, the basic ROM for communicating with the world in a useful way is bigger.</div><br/></div></div></div></div></div></div><div id="36065621" class="c"><input type="checkbox" id="c-36065621" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#36065606">parent</a><span>|</span><a href="#36066279">prev</a><span>|</span><a href="#36067568">next</a><span>|</span><label class="collapse" for="c-36065621">[-]</label><label class="expand" for="c-36065621">[5 more]</label></div><br/><div class="children"><div class="content">Without structs? Good luck...</div><br/><div id="36065638" class="c"><input type="checkbox" id="c-36065638" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#36065606">root</a><span>|</span><a href="#36065621">parent</a><span>|</span><a href="#36065639">next</a><span>|</span><label class="collapse" for="c-36065638">[-]</label><label class="expand" for="c-36065638">[2 more]</label></div><br/><div class="children"><div class="content">LFS already has several &quot;stepping stones&quot; where it walks through a whole set of C compilers from very old ones compiling slightly newer &#x2F; more capable ones and so on.<p>Perhaps with a few more &quot;layers of compilers&quot; on top you can get a very early GCC going.</div><br/><div id="36065832" class="c"><input type="checkbox" id="c-36065832" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36065606">root</a><span>|</span><a href="#36065638">parent</a><span>|</span><a href="#36065639">next</a><span>|</span><label class="collapse" for="c-36065832">[-]</label><label class="expand" for="c-36065832">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;Perhaps with a few more &quot;layers of compilers&quot; on top you can get a very early GCC going.&quot;<p>Applause. Best comment ;)</div><br/></div></div></div></div><div id="36065639" class="c"><input type="checkbox" id="c-36065639" checked=""/><div class="controls bullet"><span class="by">DesiLurker</span><span>|</span><a href="#36065606">root</a><span>|</span><a href="#36065621">parent</a><span>|</span><a href="#36065638">prev</a><span>|</span><a href="#36067568">next</a><span>|</span><label class="collapse" for="c-36065639">[-]</label><label class="expand" for="c-36065639">[2 more]</label></div><br/><div class="children"><div class="content">wonder how many extra bytes for structs?</div><br/><div id="36065689" class="c"><input type="checkbox" id="c-36065689" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#36065606">root</a><span>|</span><a href="#36065639">parent</a><span>|</span><a href="#36067568">next</a><span>|</span><label class="collapse" for="c-36065689">[-]</label><label class="expand" for="c-36065689">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, probably at least a 200-400 lines of C (another 512 bytes minimum? I don&#x27;t know the conversion).<p>The problem is not just declaring structs but accessing them, referencing them, accessing&#x2F;referencing fields and subfields, etc. That has to all be in the syntax. For such a minimal project you can ignore initialization.<p>I did all this while adding maybe 500 lines of C to GitHub.com&#x2F;vitiral&#x2F;fngi. Never tried for this level of minimalism though.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>