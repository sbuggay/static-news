<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685523667010" as="style"/><link rel="stylesheet" href="styles.css?v=1685523667010"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/openjdk/jdk/pull/14227">AVX512 intrinsics for JDK’s Arrays.sort methods</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>18 comments</span></div><br/><div><div id="36136046" class="c"><input type="checkbox" id="c-36136046" checked=""/><div class="controls bullet"><span class="by">anthony88</span><span>|</span><a href="#36135965">next</a><span>|</span><label class="collapse" for="c-36136046">[-]</label><label class="expand" for="c-36136046">[2 more]</label></div><br/><div class="children"><div class="content">Looking at the implementation, it is implemented in C++. I&#x27;d rather have an implementation using the new Vector API (still in incubation). It would be more Java like and provide a good demo for this new API.</div><br/><div id="36136072" class="c"><input type="checkbox" id="c-36136072" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36136046">parent</a><span>|</span><a href="#36135965">next</a><span>|</span><label class="collapse" for="c-36136072">[-]</label><label class="expand" for="c-36136072">[1 more]</label></div><br/><div class="children"><div class="content">This is an intrinsic JVM function though, not application code.</div><br/></div></div></div></div><div id="36135965" class="c"><input type="checkbox" id="c-36135965" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36136046">prev</a><span>|</span><a href="#36136035">next</a><span>|</span><label class="collapse" for="c-36135965">[-]</label><label class="expand" for="c-36135965">[4 more]</label></div><br/><div class="children"><div class="content">Does AVX512 still have the issue that it works for microbenchmarks but may pessimize real workloads because it reduces clock speeds?</div><br/><div id="36136058" class="c"><input type="checkbox" id="c-36136058" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36135965">parent</a><span>|</span><a href="#36136037">next</a><span>|</span><label class="collapse" for="c-36136058">[-]</label><label class="expand" for="c-36136058">[1 more]</label></div><br/><div class="children"><div class="content">In most cases even beside this issue, microbenchmarks are in general very difficult to interpret for a slew of reasons. I get the impetus to try and isolate a single variable, but in practice you&#x27;re often isolating away real world applicability of the result as well.<p>This is especially true for CPU and I&#x2F;O benchmarks that typically have an onion&#x27;s worth of caching layers in hardware and OS.</div><br/></div></div><div id="36136037" class="c"><input type="checkbox" id="c-36136037" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#36135965">parent</a><span>|</span><a href="#36136058">prev</a><span>|</span><a href="#36136054">next</a><span>|</span><label class="collapse" for="c-36136037">[-]</label><label class="expand" for="c-36136037">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the details, but for example, &quot;x265 disables AVX-512 support by default due to clock speed regressions on Intel Skylake-X systems&quot;[¹], which means that yes, this is an existing problem.<p>¹: <a href="https:&#x2F;&#x2F;chipsandcheese.com&#x2F;2023&#x2F;04&#x2F;16&#x2F;codecs-for-the-4k-era-hevc-av1-vvc-and-beyond" rel="nofollow">https:&#x2F;&#x2F;chipsandcheese.com&#x2F;2023&#x2F;04&#x2F;16&#x2F;codecs-for-the-4k-era-...</a></div><br/></div></div><div id="36136054" class="c"><input type="checkbox" id="c-36136054" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36135965">parent</a><span>|</span><a href="#36136037">prev</a><span>|</span><a href="#36136035">next</a><span>|</span><label class="collapse" for="c-36136054">[-]</label><label class="expand" for="c-36136054">[1 more]</label></div><br/><div class="children"><div class="content">Not for several years. If you’re still rocking Skylake you may have issues but beyond that, no, not really.</div><br/></div></div></div></div><div id="36136035" class="c"><input type="checkbox" id="c-36136035" checked=""/><div class="controls bullet"><span class="by">nraynaud</span><span>|</span><a href="#36135965">prev</a><span>|</span><a href="#36135862">next</a><span>|</span><label class="collapse" for="c-36136035">[-]</label><label class="expand" for="c-36136035">[1 more]</label></div><br/><div class="children"><div class="content">a weird detail is that javac seems to have crashed in the CI: <a href="https:&#x2F;&#x2F;github.com&#x2F;vamsi-parasa&#x2F;jdk&#x2F;actions&#x2F;runs&#x2F;5125771268&#x2F;jobs&#x2F;9219407026#step:5:854">https:&#x2F;&#x2F;github.com&#x2F;vamsi-parasa&#x2F;jdk&#x2F;actions&#x2F;runs&#x2F;5125771268&#x2F;...</a><p>I really don&#x27;t see why changing the JIT would influence the bytecode generation, I guess it&#x27;s a co-morbidity ?</div><br/></div></div><div id="36135862" class="c"><input type="checkbox" id="c-36135862" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#36136035">prev</a><span>|</span><a href="#36135915">next</a><span>|</span><label class="collapse" for="c-36135862">[-]</label><label class="expand" for="c-36135862">[4 more]</label></div><br/><div class="children"><div class="content">nice!<p>This is the sort of area where it feels the JVM has some under utilised potential, as these type of optimisations can take advantage of the strong guarantees of the JVM runtime.<p>Am curious though if it can work with other SIMD AVX versions since AVX512 is only selectively supported. And what&#x27;s the potential to go all the way and add OpenCL or CUDA implementations?</div><br/><div id="36135932" class="c"><input type="checkbox" id="c-36135932" checked=""/><div class="controls bullet"><span class="by">sakex</span><span>|</span><a href="#36135862">parent</a><span>|</span><a href="#36136088">next</a><span>|</span><label class="collapse" for="c-36135932">[-]</label><label class="expand" for="c-36135932">[1 more]</label></div><br/><div class="children"><div class="content">You typically wouldn&#x27;t want an OpenCL or CUDA implementation because developers expect their code to be running on a single core. If random functions started using multiple cores or running or the GPU, it would become very difficult to manage core allocation of highly parallel programs.<p>On the other hand, they could provide a different function (GPUSort for instance) but they shouldn&#x27;t replace the default one with different threading requirements.</div><br/></div></div><div id="36136088" class="c"><input type="checkbox" id="c-36136088" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#36135862">parent</a><span>|</span><a href="#36135932">prev</a><span>|</span><a href="#36136059">next</a><span>|</span><label class="collapse" for="c-36136088">[-]</label><label class="expand" for="c-36136088">[1 more]</label></div><br/><div class="children"><div class="content">There are all sorts of intrinsic in the JVM via feature detection.</div><br/></div></div><div id="36136059" class="c"><input type="checkbox" id="c-36136059" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#36135862">parent</a><span>|</span><a href="#36136088">prev</a><span>|</span><a href="#36135915">next</a><span>|</span><label class="collapse" for="c-36136059">[-]</label><label class="expand" for="c-36136059">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And what&#x27;s the potential to go all the way and add OpenCL or CUDA implementations?<p>Wouldn&#x27;t make sense outside of environments like Apple&#x27;s M-series SoCs or some gaming consoles that have unified memory between CPU and GPU. Normal Intel-based architectures would waste too much time shuffling data over PCIe.</div><br/></div></div></div></div><div id="36135915" class="c"><input type="checkbox" id="c-36135915" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36135862">prev</a><span>|</span><label class="collapse" for="c-36135915">[-]</label><label class="expand" for="c-36135915">[6 more]</label></div><br/><div class="children"><div class="content">Nice. I&#x27;m always slightly disappointed in the amount of optimization and intrinsics in the JDK for these kinds of fundamental and frequently-used methods, despite this always being one of the main arguments for JIT.</div><br/><div id="36135931" class="c"><input type="checkbox" id="c-36135931" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36135915">parent</a><span>|</span><a href="#36135948">next</a><span>|</span><label class="collapse" for="c-36135931">[-]</label><label class="expand" for="c-36135931">[2 more]</label></div><br/><div class="children"><div class="content">Why is it disappointing?</div><br/><div id="36136040" class="c"><input type="checkbox" id="c-36136040" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#36135915">root</a><span>|</span><a href="#36135931">parent</a><span>|</span><a href="#36135948">next</a><span>|</span><label class="collapse" for="c-36136040">[-]</label><label class="expand" for="c-36136040">[1 more]</label></div><br/><div class="children"><div class="content">Not GP, but in almost every introductory text to JIT compilers I&#x27;ve read there is a section called &quot;advantages and disadvantages&quot; and it almost always mentions that JIT compilers in theory have more information available than ahead-of-time compilers (ie all the information AOT compilers have and then also runtime information) and can use that information to safely do optimizations that AOT compilers cannot.<p>But then when you look at the actual code of JIT compilers, such JIT-only optimizations seem extremely rare. The JVM, surely one of the platforms that have had more than enough dollars and top-level CS talent thrown at it, even after ~20 years it still apparently lacks many optimizations that you&#x27;d expect to be in there if you&#x27;ve only read the introductory texts about it.</div><br/></div></div></div></div><div id="36135948" class="c"><input type="checkbox" id="c-36135948" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#36135915">parent</a><span>|</span><a href="#36135931">prev</a><span>|</span><label class="collapse" for="c-36135948">[-]</label><label class="expand" for="c-36135948">[3 more]</label></div><br/><div class="children"><div class="content">One would think such relatively low-hanging fruit (dispatching to an existing avx512 lib) would have been picked by now, considering the massive effort to improve the JVM in other areas (virtual threads, value objects, C interop, Graal, novel GCs).<p>Maybe Array.sort() isn’t that frequently used, as data sorting is often done by the database?</div><br/><div id="36136093" class="c"><input type="checkbox" id="c-36136093" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36135915">root</a><span>|</span><a href="#36135948">parent</a><span>|</span><a href="#36136050">next</a><span>|</span><label class="collapse" for="c-36136093">[-]</label><label class="expand" for="c-36136093">[1 more]</label></div><br/><div class="children"><div class="content">I think the number of applications that will see a measurable speed-up from this improvements is very small.<p>If you have an application that is truly bottlenecked the performance of number-sorting in any measurable way, then you most probably didn&#x27;t write it in Java. It&#x27;s not really a number crunching language for a variety of reasons.</div><br/></div></div><div id="36136050" class="c"><input type="checkbox" id="c-36136050" checked=""/><div class="controls bullet"><span class="by">carpenecopinum</span><span>|</span><a href="#36135915">root</a><span>|</span><a href="#36135948">parent</a><span>|</span><a href="#36136093">prev</a><span>|</span><label class="collapse" for="c-36136050">[-]</label><label class="expand" for="c-36136050">[1 more]</label></div><br/><div class="children"><div class="content">The big issue here (provided that I&#x27;m reading the PR correctly) is that it&#x27;s purely for arrays of the primitive number types. Whereas most real applications (that I&#x27;ve seen) will be sorting objects by some (potentially computed) property, be it an ID, a timestamp or a name. For all of these cases, the linked pull request won&#x27;t be doing anything useful.
The most useful application for this (outside of getting nicer numbers on a benchmark) that I see is computing the median&#x2F;quantiles of some property on a bunch of objects that aren&#x27;t already sorted by the interesting property.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>