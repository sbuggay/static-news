<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705741252715" as="style"/><link rel="stylesheet" href="styles.css?v=1705741252715"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tart.run/">Tart: VMs on macOS using Apple&#x27;s native Virtualization.Framework</a> <span class="domain">(<a href="https://tart.run">tart.run</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>124 comments</span></div><br/><div><div id="39062881" class="c"><input type="checkbox" id="c-39062881" checked=""/><div class="controls bullet"><span class="by">pseufaux</span><span>|</span><a href="#39062458">next</a><span>|</span><label class="collapse" for="c-39062881">[-]</label><label class="expand" for="c-39062881">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been experimenting with tart recently as a means of spinning up quick test environments for management workflows. I&#x27;ve been pleasantly surprised. There&#x27;s nothing seemingly special under the hood. It&#x27;s just a cli wrapper around Apple&#x27;s virtualization framework, but the UI is clean and the basic workflow to get from a IPSW to running VM is very straightforward.</div><br/><div id="39064717" class="c"><input type="checkbox" id="c-39064717" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#39062881">parent</a><span>|</span><a href="#39062458">next</a><span>|</span><label class="collapse" for="c-39064717">[-]</label><label class="expand" for="c-39064717">[2 more]</label></div><br/><div class="children"><div class="content">Their “special sauce” is a well thought-out cli interface.  It’s easy to understand, easy to remember, and the things one would need are implemented.<p>There are many other tools on GitHub which use Apple’s virtualization.framework to do this, but their UX is all horrific compared to tart.</div><br/><div id="39065561" class="c"><input type="checkbox" id="c-39065561" checked=""/><div class="controls bullet"><span class="by">fkorotkov</span><span>|</span><a href="#39062881">root</a><span>|</span><a href="#39064717">parent</a><span>|</span><a href="#39062458">next</a><span>|</span><label class="collapse" for="c-39065561">[-]</label><label class="expand" for="c-39065561">[1 more]</label></div><br/><div class="children"><div class="content">Also want to note availability of GitLab Executor, Buildkite plugin and many more integrations for all kinds of workflows.</div><br/></div></div></div></div></div></div><div id="39062458" class="c"><input type="checkbox" id="c-39062458" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#39062881">prev</a><span>|</span><a href="#39060758">next</a><span>|</span><label class="collapse" for="c-39062458">[-]</label><label class="expand" for="c-39062458">[1 more]</label></div><br/><div class="children"><div class="content">Orb also runs linux machines, a feature I miss for the first few weeks of using it!<p><a href="https:&#x2F;&#x2F;docs.orbstack.dev&#x2F;machines&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.orbstack.dev&#x2F;machines&#x2F;</a></div><br/></div></div><div id="39060758" class="c"><input type="checkbox" id="c-39060758" checked=""/><div class="controls bullet"><span class="by">jtotheh</span><span>|</span><a href="#39062458">prev</a><span>|</span><a href="#39060735">next</a><span>|</span><label class="collapse" for="c-39060758">[-]</label><label class="expand" for="c-39060758">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using UTM, it seems to work OK. I use arm64 images, I haven&#x27;t tried x86_64 images. Works for Windows and Debian.</div><br/><div id="39061329" class="c"><input type="checkbox" id="c-39061329" checked=""/><div class="controls bullet"><span class="by">treesknees</span><span>|</span><a href="#39060758">parent</a><span>|</span><a href="#39062792">next</a><span>|</span><label class="collapse" for="c-39061329">[-]</label><label class="expand" for="c-39061329">[5 more]</label></div><br/><div class="children"><div class="content">x86_64 runs using QEMU for emulation, and it&#x27;s incredibly slow. I&#x27;d call it practically unusable.</div><br/><div id="39061473" class="c"><input type="checkbox" id="c-39061473" checked=""/><div class="controls bullet"><span class="by">vsgherzi</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39061329">parent</a><span>|</span><a href="#39062792">next</a><span>|</span><label class="collapse" for="c-39061473">[-]</label><label class="expand" for="c-39061473">[4 more]</label></div><br/><div class="children"><div class="content">Hard agree, it does a decent job emulating an x86 container. However Angular builds were still painfully slow.</div><br/><div id="39061793" class="c"><input type="checkbox" id="c-39061793" checked=""/><div class="controls bullet"><span class="by">Cu3PO42</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39061473">parent</a><span>|</span><a href="#39062792">next</a><span>|</span><label class="collapse" for="c-39061793">[-]</label><label class="expand" for="c-39061793">[3 more]</label></div><br/><div class="children"><div class="content">For running an x64 container, I&#x27;d recommend running aarch64 Linux and then running the container using Rosetta 2, that yields significantly better performance than running everything through QEMU.</div><br/><div id="39064959" class="c"><input type="checkbox" id="c-39064959" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39061793">parent</a><span>|</span><a href="#39062792">next</a><span>|</span><label class="collapse" for="c-39064959">[-]</label><label class="expand" for="c-39064959">[2 more]</label></div><br/><div class="children"><div class="content">Wait what? I thought Rosetta 2 only worked in MacOS? Where does aarch64 Linux fit in this picture?</div><br/><div id="39064974" class="c"><input type="checkbox" id="c-39064974" checked=""/><div class="controls bullet"><span class="by">ThomasBb</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39064959">parent</a><span>|</span><a href="#39062792">next</a><span>|</span><label class="collapse" for="c-39064974">[-]</label><label class="expand" for="c-39064974">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;virtualization&#x2F;running_intel_binaries_in_linux_vms_with_rosetta" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;virtualization&#x2F;run...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39062792" class="c"><input type="checkbox" id="c-39062792" checked=""/><div class="controls bullet"><span class="by">hsshah</span><span>|</span><a href="#39060758">parent</a><span>|</span><a href="#39061329">prev</a><span>|</span><a href="#39061698">next</a><span>|</span><label class="collapse" for="c-39062792">[-]</label><label class="expand" for="c-39062792">[5 more]</label></div><br/><div class="children"><div class="content">After installing UTM, did your Mac experience a noticeable slow down, even when no VMs are running? It was frustrating enough for me to uninstall it altogether.</div><br/><div id="39064036" class="c"><input type="checkbox" id="c-39064036" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39062792">parent</a><span>|</span><a href="#39064060">next</a><span>|</span><label class="collapse" for="c-39064036">[-]</label><label class="expand" for="c-39064036">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using arm64 debian and nixos with no slow downs, 32GB memory. I don&#x27;t care to try x86_64 emulation personally, but the native linux version run well in my experience. The only annoying thing I&#x27;ve found was that while video would run smooth there was anywhere from 100-500ms delay in the sound playing youtube in the VM.</div><br/><div id="39065735" class="c"><input type="checkbox" id="c-39065735" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39064036">parent</a><span>|</span><a href="#39064060">next</a><span>|</span><label class="collapse" for="c-39065735">[-]</label><label class="expand" for="c-39065735">[1 more]</label></div><br/><div class="children"><div class="content">Slightly off topic but I tried nixos on a laptop with just 4GB and it ran out of memory doing a refresh of some sort (a nix noob at the moment)<p>My reading suggests I am stuffed but I feel the goal is worthwhile.  There does not seem to be a minimum ram requirement but if you had any pointers Inwoukd be grateful</div><br/></div></div></div></div><div id="39064060" class="c"><input type="checkbox" id="c-39064060" checked=""/><div class="controls bullet"><span class="by">millzlane</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39062792">parent</a><span>|</span><a href="#39064036">prev</a><span>|</span><a href="#39063228">next</a><span>|</span><label class="collapse" for="c-39064060">[-]</label><label class="expand" for="c-39064060">[1 more]</label></div><br/><div class="children"><div class="content">I have ollamam jellyfin and keep a utm with kali open at all times. I don&#x27;t notice any slowdowns.<p>Chip: Apple M1 Max
Total Number of Cores: 10 (8 performance and 2 efficiency)
Memory: 64 GB</div><br/></div></div><div id="39063228" class="c"><input type="checkbox" id="c-39063228" checked=""/><div class="controls bullet"><span class="by">zoom6628</span><span>|</span><a href="#39060758">root</a><span>|</span><a href="#39062792">parent</a><span>|</span><a href="#39064060">prev</a><span>|</span><a href="#39061698">next</a><span>|</span><label class="collapse" for="c-39063228">[-]</label><label class="expand" for="c-39063228">[1 more]</label></div><br/><div class="children"><div class="content">When using UTM on M2 MacBook. Blazing fast Debian vm and the host Mac.<p>The networking on other hand is doing my head in.</div><br/></div></div></div></div><div id="39061698" class="c"><input type="checkbox" id="c-39061698" checked=""/><div class="controls bullet"><span class="by">sillywalk</span><span>|</span><a href="#39060758">parent</a><span>|</span><a href="#39062792">prev</a><span>|</span><a href="#39064692">next</a><span>|</span><label class="collapse" for="c-39061698">[-]</label><label class="expand" for="c-39061698">[1 more]</label></div><br/><div class="children"><div class="content">MacOS 9 (PPC)runs OK. A little slow (macbook air m2)<p><a href="https:&#x2F;&#x2F;mac.getutm.app&#x2F;gallery&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mac.getutm.app&#x2F;gallery&#x2F;</a></div><br/></div></div><div id="39064692" class="c"><input type="checkbox" id="c-39064692" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#39060758">parent</a><span>|</span><a href="#39061698">prev</a><span>|</span><a href="#39063457">next</a><span>|</span><label class="collapse" for="c-39064692">[-]</label><label class="expand" for="c-39064692">[1 more]</label></div><br/><div class="children"><div class="content">UTM isn’t a direct analog to tart; tart is scriptable <i>extremely</i> easily and there’s an accompanying Packer plugin for it, so it’s a breeze to completely automate the creation of VM images, distribute them via a container registry, as well as create and destroy VMs created from those images.  It’s a single tool which does all the things an automated CI system needs to be able to do.</div><br/></div></div><div id="39063457" class="c"><input type="checkbox" id="c-39063457" checked=""/><div class="controls bullet"><span class="by">hrdwdmrbl</span><span>|</span><a href="#39060758">parent</a><span>|</span><a href="#39064692">prev</a><span>|</span><a href="#39060735">next</a><span>|</span><label class="collapse" for="c-39063457">[-]</label><label class="expand" for="c-39063457">[1 more]</label></div><br/><div class="children"><div class="content">Any idea how this compares with UTM in terms of features or what it&#x27;s intended use-case or strengths are?</div><br/></div></div></div></div><div id="39060735" class="c"><input type="checkbox" id="c-39060735" checked=""/><div class="controls bullet"><span class="by">bradgessler</span><span>|</span><a href="#39060758">prev</a><span>|</span><a href="#39059416">next</a><span>|</span><label class="collapse" for="c-39060735">[-]</label><label class="expand" for="c-39060735">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious why file system performance from the VM through the hypervisor to the host is so slow on macOS. Is this some sort of fundamental limitation or is it a case of &quot;Apple hasn&#x27;t made this a priority&quot;?<p>My knowledge could be out of date and maybe this is fixed, but I&#x27;ve tried using Docker on macOS and it&#x27;s almost unusable for dev environments with lots of files because of the file system performance.</div><br/><div id="39060987" class="c"><input type="checkbox" id="c-39060987" checked=""/><div class="controls bullet"><span class="by">JonathonW</span><span>|</span><a href="#39060735">parent</a><span>|</span><a href="#39063815">next</a><span>|</span><label class="collapse" for="c-39060987">[-]</label><label class="expand" for="c-39060987">[4 more]</label></div><br/><div class="children"><div class="content">How recently have you tried it?  The current best-performance option for bind mounts in Docker Desktop on macOS (VirtioFS, using Hypervisor.framework) didn&#x27;t become the default until June (for new installs) or September (for existing installs), and wasn&#x27;t available at all prior to December 2022.</div><br/><div id="39061281" class="c"><input type="checkbox" id="c-39061281" checked=""/><div class="controls bullet"><span class="by">bradgessler</span><span>|</span><a href="#39060735">root</a><span>|</span><a href="#39060987">parent</a><span>|</span><a href="#39063815">next</a><span>|</span><label class="collapse" for="c-39061281">[-]</label><label class="expand" for="c-39061281">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t tried it on a large project recently. How good is it?</div><br/><div id="39061691" class="c"><input type="checkbox" id="c-39061691" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#39060735">root</a><span>|</span><a href="#39061281">parent</a><span>|</span><a href="#39063815">next</a><span>|</span><label class="collapse" for="c-39061691">[-]</label><label class="expand" for="c-39061691">[2 more]</label></div><br/><div class="children"><div class="content">Better, but still a pain. Nothing compared to running Docker on Linux.</div><br/><div id="39062093" class="c"><input type="checkbox" id="c-39062093" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#39060735">root</a><span>|</span><a href="#39061691">parent</a><span>|</span><a href="#39063815">next</a><span>|</span><label class="collapse" for="c-39062093">[-]</label><label class="expand" for="c-39062093">[1 more]</label></div><br/><div class="children"><div class="content">But docker on Linux doesn&#x27;t involve any virtualization whatsoever so filesystem performance is 100% native</div><br/></div></div></div></div></div></div></div></div><div id="39063815" class="c"><input type="checkbox" id="c-39063815" checked=""/><div class="controls bullet"><span class="by">alanfranz</span><span>|</span><a href="#39060735">parent</a><span>|</span><a href="#39060987">prev</a><span>|</span><a href="#39062064">next</a><span>|</span><label class="collapse" for="c-39063815">[-]</label><label class="expand" for="c-39063815">[1 more]</label></div><br/><div class="children"><div class="content">Cross-OS fs performance is a problem, especially latency wise. It’s the same with parallels, virtualbox, vmware, across just any fs. Or, you can have problems with hardlinks as well.<p>I personally use mutagen to sync host and vm and it works great.</div><br/></div></div><div id="39062064" class="c"><input type="checkbox" id="c-39062064" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#39060735">parent</a><span>|</span><a href="#39063815">prev</a><span>|</span><a href="#39060994">next</a><span>|</span><label class="collapse" for="c-39062064">[-]</label><label class="expand" for="c-39062064">[1 more]</label></div><br/><div class="children"><div class="content">File performance in itself isn’t bad per se, but keeping two file trees in sync is a mess with Docker because every file operation needs to be duplicated or something. There’s some async stuff as well but ultimately most programs meant for Linux assume file access to be super fast so any sort of intermediate steps end up being slow (see also: git on Windows being dog slow)<p>You want super speedy docker on Mac? Run docker _inside_ a Linux vm. Even better, just use Linux!</div><br/></div></div><div id="39060994" class="c"><input type="checkbox" id="c-39060994" checked=""/><div class="controls bullet"><span class="by">omederos</span><span>|</span><a href="#39060735">parent</a><span>|</span><a href="#39062064">prev</a><span>|</span><a href="#39059416">next</a><span>|</span><label class="collapse" for="c-39060994">[-]</label><label class="expand" for="c-39060994">[1 more]</label></div><br/><div class="children"><div class="content">Did you have VirtioFS enabled when you tried it?</div><br/></div></div></div></div><div id="39059416" class="c"><input type="checkbox" id="c-39059416" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39060735">prev</a><span>|</span><a href="#39063595">next</a><span>|</span><label class="collapse" for="c-39059416">[-]</label><label class="expand" for="c-39059416">[31 more]</label></div><br/><div class="children"><div class="content">Now if only there was a simple solution for running z
X86&#x2F;64 vms.</div><br/><div id="39063164" class="c"><input type="checkbox" id="c-39063164" checked=""/><div class="controls bullet"><span class="by">therealmarv</span><span>|</span><a href="#39059416">parent</a><span>|</span><a href="#39059531">next</a><span>|</span><label class="collapse" for="c-39063164">[-]</label><label class="expand" for="c-39063164">[1 more]</label></div><br/><div class="children"><div class="content">Maybe not a 100% fit but since Docker 4.25 they run X86&#x2F;64 binaries with Rosetta 2 which should offer near native performance <a href="https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;docker-desktop-4-25&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;docker-desktop-4-25&#x2F;</a></div><br/></div></div><div id="39059531" class="c"><input type="checkbox" id="c-39059531" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059416">parent</a><span>|</span><a href="#39063164">prev</a><span>|</span><a href="#39063595">next</a><span>|</span><label class="collapse" for="c-39059531">[-]</label><label class="expand" for="c-39059531">[29 more]</label></div><br/><div class="children"><div class="content">The whole point of virtualization is you&#x27;re running as close as possible to directly on native hardware. That&#x27;s literally what makes virtualization distinct from emulation for VMs.<p>If you&#x27;re trying to run an x86 client OS you need an emulator, there&#x27;s just no way around it. If you just have some x86 binaries and don&#x27;t actually need a full x86 OS, they&#x27;ve made rosetta available for client linux VMs.</div><br/><div id="39060905" class="c"><input type="checkbox" id="c-39060905" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059531">parent</a><span>|</span><a href="#39059650">next</a><span>|</span><label class="collapse" for="c-39060905">[-]</label><label class="expand" for="c-39060905">[6 more]</label></div><br/><div class="children"><div class="content">The thing is, such an emulator exists, MacOS <i>itself</i> uses it to run old x86 MacOS apps transparently. Why is that as soon as that app happens to be, say, VMWare, the OS suddenly says nuh uh, not gonna do it?<p>The <i>technology</i> works, I run AAA x86 games on my Mac Studio via Crossover. Sure, the performance is a bit limited, but it&#x27;s limited by the nature of an integrated, albeit fairly powerful, GPU. It works surprisingly well considering many of these games are targeted at, say, 1000-series NVidia cards.<p>But wanting to run a 8GB Linux instance so I can run a local dev environment is an impossible ask? (Before anyone asks, no, ARM linux isn&#x27;t really a viable solution for...reasons I don&#x27;t feel like going into but are mostly boring and technical-debty).</div><br/><div id="39061143" class="c"><input type="checkbox" id="c-39061143" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060905">parent</a><span>|</span><a href="#39062006">next</a><span>|</span><label class="collapse" for="c-39061143">[-]</label><label class="expand" for="c-39061143">[1 more]</label></div><br/><div class="children"><div class="content">The canonical mechanism for running amd64 Linux processes appears to be to virtualise aarch64 and use binfmt-misc with Rosetta 2 to get emulation working.<p>It does make a certain amount of sense that Apple would have hardware virtualisation support for native VMs but not for emulated VMs.  I can imagine (but I&#x27;ve not checked) that support for emulation of the VT extensions is lacking.<p>As a random person on the Internet, I&#x27;m obviously overqualified to suggest that you use native virtualisation to run aarch64 Linux, then use Rosetta within that Linux VM to run whatever amd64 software virtualisation tool you prefer.  This is quite similar to what containerisation tooling does -- Docker (and similar) on aarch64 runs an ARM VM, then uses Rosetta inside that VM to run containers.  You don&#x27;t get a native amd64 kernel that way, but even without nested virtualisation you get a complete (namespaced) amd64 userspace.</div><br/></div></div><div id="39062006" class="c"><input type="checkbox" id="c-39062006" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060905">parent</a><span>|</span><a href="#39061143">prev</a><span>|</span><a href="#39061954">next</a><span>|</span><label class="collapse" for="c-39062006">[-]</label><label class="expand" for="c-39062006">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that&#x27;s not quite accurate.<p>Rosetta is an emulator (sorry &lt;marketing&gt;translator&lt;&#x2F;marketing&gt;) for userspace. Happily Apple actually provides direct support for linux in rosetta (as in it can parse linux binaries and libraries, etc can remap syscalls correctly, etc in linux VMs), and there&#x27;s even a WWDC video on how to integrate it, so that you can install an arm linux kernel, and then run x86_64 linux binaries via rosetta. Windows has its own translator so doesn&#x27;t need rosetta.<p>At a basic level the semantics of usermode x86 and usermode arm are identical, so you can basically say &quot;I just care about translating the x86 instructions to arm equivalents&quot;, and all the rest of the &quot;make this code run correctly&quot; semantics of the hardware (memory protection, etc) then just work.<p>That basically breaks down completely for kernel mode code, for a variety of reasons, at one level a lot of the things rosetta style translators can do for speed break down because they can&#x27;t just leverage memory protection any more. But at a more fundamental level your translator now needs to translate completely different mechanisms for how memory is accessed, how page tables are set up, how interrupts, are handled, etc. It&#x27;s hard to say exactly which bit would be the worst part, but likely memory protection - you could very easily end up in a state where your translator has to added non-hardware supported memory protection checks on every memory access, and that is slow. Significant silicon resources are expended (the extremely high performance and physically colocated TLBs, caches, etc) to make paged memory efficient, and suddenly you have actual code running and walking what (to the cpu) is just regular ram. So now what was previously a single memory access for the CPU involves a code loop with multiple (again, for the cpu) random memory accesses.<p>Those problems are why CPUs added explicit support for virtualization in the early 2000s. VMWare, etc started making virtual machines an actual viable product, because they were able to set things up so that the majority of code in the client OS was running directly on the host CPU. The problem they had for performance was essentially what I described above, only they didn&#x27;t have to also translate all of the instructions (I believe their implementation at the time did translate some instructions, especially kernel mode code, as part of their &quot;tolerable&quot; performance was being very clever, and of course the client os kernel is running in the host os&#x27;s user mode so definitely has to handle client kernel use of kernel mode only instructions). A lot of virtualization support in CPUs basically boils down to things like nested page tables, which lets your VM just say &quot;these are the page tables you should also be looking at while I&#x27;m running&quot;.<p>Now for cross architecture emulation that&#x27;s just not an option, as the problem is your client kernel is trying to construct the data structures used by its target cpu, and those data structures don&#x27;t match, and may or may not even have an equivalent, so there is no &quot;fix&quot; that doesn&#x27;t eventually boil down to the host architecture supporting the client architecture directly, and at that point you&#x27;re essentially adding multiple different implementations of the same features to the silicon which is astronomically expensive.<p>The far better solution is to say, make the child OS run a native to the host architecture kernel, and then have that do usermode translation like rosetta for application compatibility.</div><br/></div></div><div id="39061954" class="c"><input type="checkbox" id="c-39061954" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060905">parent</a><span>|</span><a href="#39062006">prev</a><span>|</span><a href="#39059650">next</a><span>|</span><label class="collapse" for="c-39061954">[-]</label><label class="expand" for="c-39061954">[3 more]</label></div><br/><div class="children"><div class="content">You can do it with QEMU using its emulation backend to emulate the entire x86 boot chain. It will be dozens (hundreds?) of times slower.<p>Hypervisors work efficiently because they allow you to &quot;nest&quot; certain functions inside of other userspace processes, which are typically only available to the operating system (with a higher privilege level), things like delivering interrupts efficiently, or managing page tables. The nesting means that the nested operating system is running on the same hardware in practice, and so it inherits many of the constraints of the host architecture. So, virtualization extensions can be seen as a kind of generalization of existing features, designed so that nesting them is efficient and secure.<p>For example, different architectures have different rules about how page tables are set up and how virtual memory page faults are handled in that environment. The entire memory mapped layout of the system is completely different. The entire memory model (TSO vs weak ordering) is different. There are strict correctness requirements. A linux kernel for x86 has specific x86 code to manage that and perform those sequences correctly. You cannot just translate x86 code to ARM code and hope the same sequence works; you have to emulate the entire processor environment, so that x86 code works as it should.<p>Rosetta does not emulate code; it is a binary translator. It translates x86 code to ARM code up front, then runs that. The only reason this works is because normal userspace programs have an ABI that dictates how they interoperate with each other across process and address space and function boundaries. When CrossOver runs an x86 game for example, it translates the x86 to ARM. That program then calls Metal APIs, libmetal.dylib or something, but that .dylib itself isn&#x27;t x86-to-ARM translated. It is simply &quot;pass through&quot; shim to your system-native Metal APIs. So the graphics stack achieves native performance; the application overhead comes from the x86-to-ARM translation, which needs to preserve the semantics of the original code.<p>Rosetta-for-Linux works the same way, because there is a stable ABI that exists between processes and function calls, and the Linux kernel ABI is considered stable (though not between architectures in some cases). It translates the x86-to-ARM, and then that binary is run and it gets to call into the native Linux kernel, which is not translated, etc. This basically works well in practice. It is also how Windows&#x27; x86-on-ARM emulation works.<p>If you want to emulate an entire x86 processor, including an x86 Linux kernel, you have to do exactly that, emulate it. Which includes the entire boot process, the memory model, CPU instructions that may not have efficient 1-to-1 translations, etc.<p>Unfortunately, what you are asking is not actually reasonably possible, in a technical sense. Your options are either to use Rosetta-on-Linux to translate your binary, or get an actual x86 Linux machine.</div><br/><div id="39062360" class="c"><input type="checkbox" id="c-39062360" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39061954">parent</a><span>|</span><a href="#39059650">next</a><span>|</span><label class="collapse" for="c-39062360">[-]</label><label class="expand" for="c-39062360">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rosetta does not emulate code; it is a binary translator. It translates x86 code to ARM code up front, then runs that. The only reason this works is because normal userspace programs have an ABI that dictates how they interoperate with each other across process and address space and function boundaries. When CrossOver runs an x86 game for example, it translates the x86 to ARM.<p>I don&#x27;t think this is true. I think code run under WINE is always JITted because it&#x27;s too much unlike a Mac binary.</div><br/><div id="39063084" class="c"><input type="checkbox" id="c-39063084" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39062360">parent</a><span>|</span><a href="#39059650">next</a><span>|</span><label class="collapse" for="c-39063084">[-]</label><label class="expand" for="c-39063084">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I feel like ([edit: removed personal detail that in hindsight isn&#x27;t really relevant in this specific discussion]) translation vs emulation is very close to a purely marketing distinction. I feel like the only thing that makes it a semantically valid distinction is if you take an interpretation of translation being explicitly the &quot;translated&quot; code is run as native code on the cpu, rather than as a loop written in native code that manually evaluating each original instruction. But that&#x27;s still iffy, as many things that people would absolutely call emulators nowadays are generating native code as well.<p>JIT vs non-JIT also isn&#x27;t really sufficient. Rosetta necessarily does runtime code generation as well[1], because Rosetta needs to support running code generated by x86_64 JITs at runtime (note that this is actually often slower than simply not using a JIT in the first place, to the extent that JavaScriptCore at least has a mechanism to ensure it does not use the JITs if its running under rosetta for this reason). Then as you say programs like WINE are definitionally not using platform binaries, so any code that they load and start to execute looks basically identical to &quot;this program generated code at runtime&quot;. I do wonder if there&#x27;s something that could be done either as some kind of Rosetta API to register a block of code as being logically static to allow some kind of caching, or by wine doing some fairly butchered rewriting to convert the windows objects into something that looks like &quot;normal&quot; machos to essentially trick rosetta into the AOT and&#x2F;or caching path.<p>[1] Until the 2023 rosetta update the linux VM support only supported JIT translation, that update added support for a more Mac like model where there&#x27;s a central daemon to handle loading binaries and libraries so they can be cached and shared</div><br/></div></div></div></div></div></div></div></div><div id="39059650" class="c"><input type="checkbox" id="c-39059650" checked=""/><div class="controls bullet"><span class="by">edgyquant</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059531">parent</a><span>|</span><a href="#39060905">prev</a><span>|</span><a href="#39059922">next</a><span>|</span><label class="collapse" for="c-39059650">[-]</label><label class="expand" for="c-39059650">[6 more]</label></div><br/><div class="children"><div class="content">Your terminology is off and you seem to be talking about a hypervisor or something.  Virtualization is just virtualizing computer hardware and emulation is one way to do it</div><br/><div id="39060276" class="c"><input type="checkbox" id="c-39060276" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059650">parent</a><span>|</span><a href="#39059922">next</a><span>|</span><label class="collapse" for="c-39060276">[-]</label><label class="expand" for="c-39060276">[5 more]</label></div><br/><div class="children"><div class="content">Sorry, I&#x27;m not sure what&#x27;s going on here, I replied to another comment about this and there&#x27;s multiple people stating that (s)he&#x27;s thinking of containers.<p>I think we have collective amnesia about what virtualisation actually <i>is</i> and why it&#x27;s distinct from containerisation.<p>Virtualisation is absolutely about &quot;skipping&quot; parts of the emulation chain to do direct calls to the CPU in a way that does not need to be translated; in this way it gets much closer to the hardware.<p><i>Containerisation</i> was considered faster still because instead of even having the 5% overhead not being able to use the same process scheduler in the kernel; you can share one.<p>Yes, containers are able to execute faster than VMs, but the parent is absolutely right that the entire point of virtualisation as a concept was to get closer to the CPU from inside an emulated computer.</div><br/><div id="39060387" class="c"><input type="checkbox" id="c-39060387" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060276">parent</a><span>|</span><a href="#39059922">next</a><span>|</span><label class="collapse" for="c-39060387">[-]</label><label class="expand" for="c-39060387">[4 more]</label></div><br/><div class="children"><div class="content">…or they edited their post afterwards ;)<p>I’ve been using containers for decades on FreeBSD and Solaris, long before Linux ever caught on. And virtualisation even longer.<p>In fact I have fond memories of using the first version of VMWare (which was a literal emulator at that point because x86 didn’t support virtualisation back in 1999) to run Windows 2000 from Linux.<p><pre><code>  So, like the others who responded, I definitely know the difference between virtualisation and containerisation.</code></pre></div><br/><div id="39060457" class="c"><input type="checkbox" id="c-39060457" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060387">parent</a><span>|</span><a href="#39065326">prev</a><span>|</span><a href="#39059922">next</a><span>|</span><label class="collapse" for="c-39060457">[-]</label><label class="expand" for="c-39060457">[2 more]</label></div><br/><div class="children"><div class="content">You have a similar background to me; though I used Zones on Solaris before Jails on FreeBSD.<p>I also used VMWare when it was an emulator and hated how abysmally slow it was</div><br/><div id="39060546" class="c"><input type="checkbox" id="c-39060546" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060457">parent</a><span>|</span><a href="#39059922">next</a><span>|</span><label class="collapse" for="c-39060546">[-]</label><label class="expand" for="c-39060546">[1 more]</label></div><br/><div class="children"><div class="content">Christ was is slow!!<p>I wasn’t using it for anything serious thankfully.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39059922" class="c"><input type="checkbox" id="c-39059922" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059531">parent</a><span>|</span><a href="#39059650">prev</a><span>|</span><a href="#39059668">next</a><span>|</span><label class="collapse" for="c-39059922">[-]</label><label class="expand" for="c-39059922">[14 more]</label></div><br/><div class="children"><div class="content">You’re thinking of containerisation. Virtualisation does abstract away direct interfaces with the hardware. And some virtual machines are literal emulators.</div><br/><div id="39059995" class="c"><input type="checkbox" id="c-39059995" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059922">parent</a><span>|</span><a href="#39059668">next</a><span>|</span><label class="collapse" for="c-39059995">[-]</label><label class="expand" for="c-39059995">[13 more]</label></div><br/><div class="children"><div class="content">No, he&#x27;s right.<p>Containerisation is distinct from virtualisation.<p>Virtualisation shares some areas with Emulation, but it&#x27;s essentially passing CPU instructions to the CPU <i>without translation</i> from some alternative CPU machine language.<p>The difference here is the level; in descending order:<p>* Containerisation emulates a userland environment, shares a OS&#x2F;Kernel interfaces.<p>* Virtualisation emulates hardware devices, but not CPU instructions; there are some &quot;para-virt&quot; providers (Xen) that will share even a kernel here, but this is not that.<p>* Emulation emulates an entire computer including its CPU</div><br/><div id="39060198" class="c"><input type="checkbox" id="c-39060198" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059995">parent</a><span>|</span><a href="#39060111">next</a><span>|</span><label class="collapse" for="c-39060198">[-]</label><label class="expand" for="c-39060198">[11 more]</label></div><br/><div class="children"><div class="content">I don’t think you’ve read the comment chain correctly because you’re literally just repeating what I just said.<p>Though you make a distinction between virtualisation and emulation when in fact they can be the same thing (they aren’t always, but sometimes they are. It just depends on the problem you’re trying to solve).</div><br/><div id="39060228" class="c"><input type="checkbox" id="c-39060228" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060198">parent</a><span>|</span><a href="#39060111">next</a><span>|</span><label class="collapse" for="c-39060228">[-]</label><label class="expand" for="c-39060228">[10 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The whole point of virtualization is you&#x27;re running <i>as close as possible to directly on native hardware. </i>That&#x27;s literally <i>what makes virtualization distinct from emulation for VMs.</i><p>&gt; You’re thinking of containerisation.<p>no.</div><br/><div id="39060259" class="c"><input type="checkbox" id="c-39060259" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060228">parent</a><span>|</span><a href="#39060111">next</a><span>|</span><label class="collapse" for="c-39060259">[-]</label><label class="expand" for="c-39060259">[9 more]</label></div><br/><div class="children"><div class="content">They edited their post. If you look at the comments others have made, you can see their original comment was much more ambiguous</div><br/><div id="39060303" class="c"><input type="checkbox" id="c-39060303" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060259">parent</a><span>|</span><a href="#39060111">next</a><span>|</span><label class="collapse" for="c-39060303">[-]</label><label class="expand" for="c-39060303">[8 more]</label></div><br/><div class="children"><div class="content">Is there a way to see original comments?</div><br/><div id="39060448" class="c"><input type="checkbox" id="c-39060448" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060303">parent</a><span>|</span><a href="#39063088">next</a><span>|</span><label class="collapse" for="c-39060448">[-]</label><label class="expand" for="c-39060448">[1 more]</label></div><br/><div class="children"><div class="content">Unlikely. It’s too recent for Wayback machine to cache.<p>Their post was ostensibly the same but much more vaguely worded. And if you say “virtualisation is about being as close to the hardware as possible” without much more detail to someone else who talks about wanted to run a VM with a different guest CPU, then it’s understandable that people will assume the reply is mixing up virtualisation with containerisation since there’s nothing in virtualisation that says you cannot emulate hardware in the guest. Whereas containerisation is very much intended to run natively on the hardware</div><br/></div></div><div id="39063088" class="c"><input type="checkbox" id="c-39063088" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39060303">parent</a><span>|</span><a href="#39060448">prev</a><span>|</span><a href="#39060111">next</a><span>|</span><label class="collapse" for="c-39063088">[-]</label><label class="expand" for="c-39063088">[6 more]</label></div><br/><div class="children"><div class="content">who&#x27;s post was edited? If they&#x27;re referring to my original one, then there&#x27;s only one possible edit I made, because I recall making a comment today that was missing a word, but I updated that instantly so there were no comments or anything, or really likelihood anyone had read it prior to my comment. My &quot;edit&quot; that now has to be an additional comment is at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39061507">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39061507</a> - I&#x27;m curious if you agree with my justification on treating virtualization is meaning explicitly non-emulated these days. From your other comments it seems you do agree with me, but I&#x27;d like to know how you feel about the rationale.<p>In response to the editing comment made, my rule for editing or changing comments is that if it&#x27;s not an instantaneous edit, then the edit should be marked. In response to this thread (the whole thing, not just the one leading down these branches) I did write a stupidly long addendum but spent so long trying to find old marketing material I then couldn&#x27;t make the edit \o&#x2F;<p>My more careful rule about editing is that if someone has replied to a comment, I won&#x27;t change the text that they replied to, unless the confusion is something very simple like a missing &quot;not&quot; or something where the original text was clearly wrong, and I&#x27;ll generally do some variation of &quot; .... [edit: not] ...&quot;. Otherwise I try to do it as adding additional text with a note saying the new text was added.<p>I find silent edits incredibly annoying, as it means you can&#x27;t tell if&#x2F;what has changed in a comment you replied to, and it allows for people to exhibit some really screwed up behaviour. Basically along the same lines as people brought up when apple added editing&#x2F;deleting to iMessage, where the original betas I think didn&#x27;t show edits&#x2F;deletion had occurred, nor what had been changed. I don&#x27;t think it&#x27;s reasonable in this day and age for sites like HN to not provide an edit history for comments.</div><br/><div id="39063288" class="c"><input type="checkbox" id="c-39063288" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39063088">parent</a><span>|</span><a href="#39063212">next</a><span>|</span><label class="collapse" for="c-39063288">[-]</label><label class="expand" for="c-39063288">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m curious if you agree with my justification on treating virtualization is meaning explicitly non-emulated these days.<p>I often see people try to make a distinction between hardware virtualisation and hardware emulation but the reality is they&#x27;re just different sides of the same coin. It&#x27;s like saying Typescript isn&#x27;t a compiled language because it doesn&#x27;t produce assembly like C would. Sometimes you need to emulate the entire CPU. Other times the guest and host CPUs are the same and that CPU supports hardware assisted virtualisation. But even AMD64 virtualisation solutions have to emulate some parts of the hardware stack (like the virtual network card) regardless of any paravirtalisation and other virt-extensions available by the CPU, GPU, and so on.<p>To compound the confusing jargon. All emulators are a virtual machine but not all virtual machines are emulators.<p>The distinction between containerisation and virtualisation is a lot easier to describe. Rather than placing hardware gaps (whether those hardware gaps are defined in software or hardware) like you do with virtualisation, instead you have all code running natively with only your kernel for protection.<p>I guess you could draw some parallels between modern hypervisors and kernels, but even hear, you wouldn&#x27;t run multiple kernels on top of each other in a container. However you would run multiple kernels on top of a hypervisor. The layer of separation is a lot different<p>Personally I view the things as being<p><pre><code>  1. containerisation
  2. virtualisation
    2a. hardware assisted
    2b. emulation
</code></pre>
ie emulation is a subset of virtualisation. Distinct in some ways but not an entirely new category in itself</div><br/><div id="39065356" class="c"><input type="checkbox" id="c-39065356" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39063288">parent</a><span>|</span><a href="#39065674">next</a><span>|</span><label class="collapse" for="c-39065356">[-]</label><label class="expand" for="c-39065356">[2 more]</label></div><br/><div class="children"><div class="content">This dichotomy of hardware assisted vs emulation is too simplistic though.<p>&gt; Sometimes you need to emulate the entire CPU. Other times the guest and host CPUs are the same and that CPU supports hardware assisted virtualisation.<p>You don&#x27;t need dedicated hardware assistance to do some amount of virtualization if you have an MMU and memory protection. This is how early VMware on x86 worked, it was not a full blown emulator, it did not need to emulate the entire CPU. Most guest code ran unaltered without emulation, only certain ring 0 code had to be emulated.<p>VMware ESX and workstation ran usably well back in the x86 days, I mean it was a viable product. It was not just an &quot;emulator&quot;, in contrast to something like BOCHS or early qemu.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_virtualization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_virtualization</a><p><a href="https:&#x2F;&#x2F;www.vmware.com&#x2F;pdf&#x2F;asplos235_adams.pdf" rel="nofollow">https:&#x2F;&#x2F;www.vmware.com&#x2F;pdf&#x2F;asplos235_adams.pdf</a><p>I don&#x27;t think an accurate categorization really. Emulation is  a technique that may be used in parts of the implementation for virtualization, but they&#x27;re different concepts, one is not a subset of the other.<p>&gt; All emulators are a virtual machine<p>No, I can emulate a single piece of hardware like a network adapter. I can emulate just a CPU core indepedent of a particular virtual environment.</div><br/><div id="39065781" class="c"><input type="checkbox" id="c-39065781" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39065356">parent</a><span>|</span><a href="#39065674">next</a><span>|</span><label class="collapse" for="c-39065781">[-]</label><label class="expand" for="c-39065781">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is how early VMware on x86 worked, it was not a full blown emulator, it did not need to emulate the entire CPU.<p>Of course it didn&#x27;t. But it did (and parts of it still does) emulate hardware. Which is my point.<p>&gt; This dichotomy of hardware assisted vs emulation is too simplistic though.<p>Is it though? Or is this need to define different aspects of virtualisation as entirely different fields effectively being too simplistic? I&#x27;m acknowledging that there is shared heritage and commonality between principles -- even to the extent that some directly borrow from the other.<p>You say &quot;dichotomy&quot; to refer to my comments yet you&#x27;re the one trying to divide a complex field into small pigeonholes without acknowledging that they&#x27;re intermingled. This is what PR people do to sell products to customers, not engineers like us.<p>&gt; VMware ESX and workstation ran usably well back in the x86 days<p>Workstation predates ESX by a few years and the 1.x versions of Workstation really didn&#x27;t run well _at all_. I used it personally, it was a bloody cool tech demo and even back then I could see the potential, but it was far too slow to use for anything serious. Particularly when UNIX and BSDs were still in vogue (albeit barely) and they had excellent support for application sandboxing via containerisation.<p>&gt; I don&#x27;t think an accurate categorization really. Emulation is a technique that may be used in parts of the implementation for virtualization,<p>So you agree with the technical description but not the categorisation?<p>&gt; but they&#x27;re different concepts, one is not a subset of the other.<p>That&#x27;s like saying DocumentDB and Postgres aren&#x27;t both databases because one is SQL and the other is not.<p>The concepts between emulation and virtualisation are similar enough that I&#x27;d argue that one is a subset of another. What you&#x27;re discussing is the implementation detail of <i>one</i> form of virtualisation -- baring in mind that there are other ways to run a virtual machine which we also haven&#x27;t covered here. You&#x27;ve even agreed yourself that a VM requires parts of the full machine to be emulated for it to work. So the only reason people don&#x27;t (still) refer to emulation as a subset of virtualisation is marketing.<p>&gt; It was not just an &quot;emulator&quot;, in contrast to something like BOCHS or early qemu.<p>I really don&#x27;t get what you&#x27;re trying to say with &quot;early qemu&quot;. qemu still does full emulation. It also supports virtualisation too. If anything, it&#x27;s another example of the point that I&#x27;m making which is that hardware virtualisation and emulation are too frequently intermingled for it to be sensible claiming they&#x27;re distinct categories of computing.<p>&gt; No, I can emulate a single piece of hardware like a network adapter. I can emulate just a CPU core indepedent of a particular virtual environment.<p>And that&#x27;s exactly why they&#x27;re a subset of virtual machines. I know this isn&#x27;t the common way to refer to a VM but I&#x27;d argue that an emulated hardware adapter is still a virtual machine because it takes input, returns output, and is sandboxed and self contained. In the pure mathematical sense, it is a virtual machine just like how some software runtimes are also classified as virtual machines.<p>I feel a lot of the issue here is down to businesses redefining common terms over the years to make their products seem extra special.</div><br/></div></div></div></div><div id="39065674" class="c"><input type="checkbox" id="c-39065674" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39063288">parent</a><span>|</span><a href="#39065356">prev</a><span>|</span><a href="#39063212">next</a><span>|</span><label class="collapse" for="c-39065674">[-]</label><label class="expand" for="c-39065674">[1 more]</label></div><br/><div class="children"><div class="content">1. containerization is often implemented these days in terms of partial virtualization, because the historical approach that were essentially a bunch of variations of chrooting were not sufficiently isolated to create a sufficient security boundary for a multiuser &quot;cloud&quot; hosting service.<p>2. virtualization, as my update&#x2F;comment up the thread said, the definition of virtualization being &quot;host os code runs directly on the cpu&quot; has been pretty much the standard definition for a couple of decades at this point. If you say you offer virtualization, but you implement it using an academically &quot;accurate&quot; definition that allows emulation I would imagine that you would have difficulty finding a user that accepts that definition. Again, as I&#x27;ve stated elsewhere &quot;hardware virtualization support&quot; that CPUs have acquired since the 90s is essentially multi-level page tables and cpu mode options so that a virtual machine runtime doesn&#x27;t need to rewrite kernel mode code. It has not meaningfully impacted user mode code at all.<p>It is not reasonable to reject the evolution of language when considering the meaning of a word, nor the context of the environment in which it is discussed. The fact that 30 years ago you could say an emulator was a virtual machine is not relevant today, where the terminology very clearly does not include ISA emulation. This is as true for modern tech terminology like &quot;virtualization&quot; as it is for other tech terminology. For example, no one would accept me presenting a person good at maths as a &quot;computer&quot; either, despite that being what it used to mean.</div><br/></div></div></div></div><div id="39063212" class="c"><input type="checkbox" id="c-39063212" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39063088">parent</a><span>|</span><a href="#39063288">prev</a><span>|</span><a href="#39060111">next</a><span>|</span><label class="collapse" for="c-39063212">[-]</label><label class="expand" for="c-39063212">[1 more]</label></div><br/><div class="children"><div class="content">u&#x2F;hnlmorg edited <i>one of their</i> comments in this chain I recognise right now.<p>They said “you are just saying what I said” but now it has been altered to a much more agreeable and less aggressive statement. Shenanigans.<p>nonetheless I believe it is yours that is being accused of being modified, and I do agree with you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39060111" class="c"><input type="checkbox" id="c-39060111" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059995">parent</a><span>|</span><a href="#39060198">prev</a><span>|</span><a href="#39059668">next</a><span>|</span><label class="collapse" for="c-39060111">[-]</label><label class="expand" for="c-39060111">[1 more]</label></div><br/><div class="children"><div class="content">Note that these aren&#x27;t necessarily layered: You can virtualize with emulation, but you can also emulate without virtualization, which is what e.g. Rosetta does on macOS, or QEMU&#x27;s userland emulation mode.</div><br/></div></div></div></div></div></div><div id="39059668" class="c"><input type="checkbox" id="c-39059668" checked=""/><div class="controls bullet"><span class="by">w0m</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059531">parent</a><span>|</span><a href="#39059922">prev</a><span>|</span><a href="#39061507">next</a><span>|</span><label class="collapse" for="c-39059668">[-]</label><label class="expand" for="c-39059668">[1 more]</label></div><br/><div class="children"><div class="content">virtualization != containerization.</div><br/></div></div><div id="39061507" class="c"><input type="checkbox" id="c-39061507" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059416">root</a><span>|</span><a href="#39059531">parent</a><span>|</span><a href="#39059668">prev</a><span>|</span><a href="#39063595">next</a><span>|</span><label class="collapse" for="c-39061507">[-]</label><label class="expand" for="c-39061507">[1 more]</label></div><br/><div class="children"><div class="content">This was going to be an addendum to the above comment, but I took to long trying hunt down old marketing material for Virtual PC, anyway here is the intended addendum.<p>[edit: Giant addendum starts here, in response to comments in replies, rather than saying variations on the same things over and over again. Nothing preceding this comment has been changed or edited from my original post. As I&#x27;ve said elsewhere, I really wish HN provided edit history on comments]<p>First off, for people saying I&#x27;m talking about containers, I was not considering them at all, I consider them as essentially tangential to the topic virtual machines and virtualization. I haven&#x27;t looked into modern container infrastructure to really understand the full nuances, my exceptionally vague understanding of the current state of the art is the original full-vm-per-container model docker, et al introduced has been improved somewhat to allow better resource sharing between clients and the host hardware than a full-vm provides but is still using some degree of virtualization provide better security boundaries than just basic chroot containers could ever do. I&#x27;m curious about exactly how much of a kernel modern container VMs have based on the comments in this thread, and if I ever have time between my job and long winded HN comments I&#x27;ll try to look into it - I’d love good references on exactly how kernel level operation is split and shared in modern container implementation .<p>Anyway, as commonly used virtualization means &quot;code in the VM runs directly of the host CPU”, and has done for more than two decades now. An academic definition of a virtual machine may include emulation, but if you see any company or person talking about supporting virtual machines, virtual hosts, or virtualized X in any medium - press, marketing, article (tech or non-tech press) - you will know that they are not talking about emulation. The reason is simply that the technical characteristics of an emulated machine are so drastically different that any use of emulation has to be explicitly called out. Hence absent any qualifier virtualization means the client code executes directly on the the host hardware. The introduction of hypervisors in the CPU simply meant that more things could be done directly on the host hardware without requiring expensive&#x2F;slow runtime support from the VM runtime, it did not change the semantics of what “virtual machine” meant vs emulation even at the time CPUs with direct support for virtualization entered the general market.<p>Back when VMWare first started out a big part of their marketing and performance messaging boiled down to &quot;Virtual Machine != emulation&quot; and that push was pretty much the death knell for a definition of “virtualization” and “virtual machine” including emulation. As that model took off, &quot;hypervisor&quot; was introduced to general industry as the term for the CPU mechanism to support virtualization more efficiently (I&#x27;m sure in specialized industries and academia it existed earlier) by allowing _more_ code to run directly, but for the most part there was no change to userspace code in the client machine. Most of the early “hypervisor”&#x2F;virtualization extensions (I believe on ARM they’re explicitly called the “virtualization extensions”, because virtualization does not mean emulation) were just making it easier for VM runtimes to avoid having to do anything to code running in kernel mode so that that code could be left to run directly on the host CPU as well.<p>The closest emulation ever got to &quot;virtualization&quot; in non-academic terminology that I recall is arguably &quot;Virtual PC for Mac&quot; (for young folk virtual pc was an x86 emulator for PPC macs that was eventually bought by MS IIRC), which said “virtual pc” in the product name. It did not however use the term virtualization, and was only ever described as explicitly emulation in the tech press, I certainly have no recollection of it ever even being described as a virtual machine even back during its window of relevance. I&#x27;d love to find actual marketing material from the era because I&#x27;m genuinely curious what it actually said, but the product name seems to have been reused over time so google search results are fairly terrible and my attempts in the wayback machine are also fairly scattershot :-&#x2F;<p>But if we look at the context, once apple moved to x86, from Day 1 the Parallels marketing that targeted the rapidly irrelevant &quot;virtual pc for Mac&quot; product talked about using virtualization rather than emulation to get better performance than virtual pc, but the rapid decline in the relevance of PPC meant that talking about not being emulation ceased being relevant because the meaning of a virtual machine in common language is native client running code directly on the host CPU.<p>So while an academic argument may have existed that virtualization included emulation in the past, the reality is that the meaning of virtualization in any non-academic context since basically the late 90s has been client code runs directly on the host CPU, not via emulation. Given that well established meaning, my statement that virtualization of a non-host-architecture OS is definitionally not possible is a reasonable statement, that is correct in the context of the modern use of the word virtualization (again we’re talking a couple of decades here, not some change in the last few months).<p>If you really want to argue with this, I want you to ask yourself how you would respond if you had leased a hundred virtualized x86 systems, and then found half of them were running at 10% the speed of the rest because they were actually emulated hardware, and then if you think that a lawyer for that company would be able to successfully argue that the definition of “virtualization include emulation” would pass muster when you could bring in reps from every other provider, and every commercial VM product and none of them involved emulation, and every article published for decades about how [cloud or otherwise] VMs work (none of which mention emulation). If you really think that your response would be “ah you got me”, or that that argument would work in court, then fair play to you, you’re ok with your definition and we’ll have to agree to disagree, but I think the vast majority of people in tech would disagree.</div><br/></div></div></div></div></div></div><div id="39063595" class="c"><input type="checkbox" id="c-39063595" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#39059416">prev</a><span>|</span><a href="#39059419">next</a><span>|</span><label class="collapse" for="c-39063595">[-]</label><label class="expand" for="c-39063595">[2 more]</label></div><br/><div class="children"><div class="content">Interesting that the macOS images are publicly available from GHCR. I would&#x27;ve thought that would cause legal problems.<p>As for storing images in an OCI registry, I can&#x27;t quite tell if Tart is layer-aware. If you pull a macOS image, modify it, and push it back to the registry, will Tart simply push a new layer with modifications? I&#x27;m guessing this isn&#x27;t possible.</div><br/><div id="39065593" class="c"><input type="checkbox" id="c-39065593" checked=""/><div class="controls bullet"><span class="by">fkorotkov</span><span>|</span><a href="#39063595">parent</a><span>|</span><a href="#39059419">next</a><span>|</span><label class="collapse" for="c-39065593">[-]</label><label class="expand" for="c-39065593">[1 more]</label></div><br/><div class="children"><div class="content">macOS EULA has some special wording around &quot;Permitted Developer Services&quot; allowing more flexibility:<p>&gt; Permitted Developer Services means continuous integration services, including but not limited to software development, building software from source, automated testing during software development, and running necessary developer tools to support such activities.<p>As for layering, Tart doesn&#x27;t support it at the moment. It seems APFS is not particularly good for layering but Tart uses sparsed files when storing VMs locally. Sparsed disk image file basically &quot;skips&quot; zero bytes which saves a lot.</div><br/></div></div></div></div><div id="39059419" class="c"><input type="checkbox" id="c-39059419" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#39063595">prev</a><span>|</span><a href="#39059272">next</a><span>|</span><label class="collapse" for="c-39059419">[-]</label><label class="expand" for="c-39059419">[3 more]</label></div><br/><div class="children"><div class="content">I was considering similar approach were I still stuck with Apple for work: make a Firecracker OCI runtime for MacOS. Fortunately Intune for Linux came around before I had to resort to that.</div><br/><div id="39059753" class="c"><input type="checkbox" id="c-39059753" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39059419">parent</a><span>|</span><a href="#39059272">next</a><span>|</span><label class="collapse" for="c-39059753">[-]</label><label class="expand" for="c-39059753">[2 more]</label></div><br/><div class="children"><div class="content">Virtualization.framework does most of the things Firecracker does on Linux. It&#x27;s not literally the same, of course, but it does a comparable amount of the work for you. Here&#x27;s an example application which uses it:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;apinske&#x2F;virt&#x2F;blob&#x2F;master&#x2F;virt&#x2F;virt&#x2F;main.swift">https:&#x2F;&#x2F;github.com&#x2F;apinske&#x2F;virt&#x2F;blob&#x2F;master&#x2F;virt&#x2F;virt&#x2F;main.s...</a><p>And yes, that&#x27;s really the whole thing. Once the VM is configured (which is what most of the code is concerned with), running it is fully handled by the framework.</div><br/><div id="39062039" class="c"><input type="checkbox" id="c-39062039" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#39059419">root</a><span>|</span><a href="#39059753">parent</a><span>|</span><a href="#39059272">next</a><span>|</span><label class="collapse" for="c-39062039">[-]</label><label class="expand" for="c-39062039">[1 more]</label></div><br/><div class="children"><div class="content">Firecracker is also the distro that makes assumptions (and therefore boot time wins) about being run inside the Firecracker VMM, as far as I understand it. You&#x27;d also need the OCI runtime, and a Docker-compatible socket would make tons of sense.</div><br/></div></div></div></div></div></div><div id="39059272" class="c"><input type="checkbox" id="c-39059272" checked=""/><div class="controls bullet"><span class="by">autoexecbat</span><span>|</span><a href="#39059419">prev</a><span>|</span><a href="#39064946">next</a><span>|</span><label class="collapse" for="c-39059272">[-]</label><label class="expand" for="c-39059272">[3 more]</label></div><br/><div class="children"><div class="content">I do like the idea of using container registries for VM images</div><br/><div id="39060677" class="c"><input type="checkbox" id="c-39060677" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39059272">parent</a><span>|</span><a href="#39064946">next</a><span>|</span><label class="collapse" for="c-39060677">[-]</label><label class="expand" for="c-39060677">[2 more]</label></div><br/><div class="children"><div class="content">I set up a workflow at $DAY_JOB for building the rootfs as a container and then &quot;promoting&quot; it to a vmdk and creating the ovf metadata file to allow it to be imported into VMWare as its own machine.<p>This was ~3 years ago and at least at the time I was annoyed at how little established tooling there seemed to be for doing an appliance image build offline— everyone was just like &quot;why? Boot some public cloud-init template and use that as the basis for your terraform&#x2F;ansible&#x2F;whatever. If you actually need an OVF then export it from VMWare and be done with it.&quot;<p>On the other hand, once I got down in the weeds with things, I did find there were some bits that were a bit hairy about the promotion process— especially with &quot;minimal&quot; containers that have no users or init system, not to mention of course no filesystem, kernel, or bootloader, there is a fair bit that you have to do with a typical container to ready it for becoming a real boy.</div><br/><div id="39061392" class="c"><input type="checkbox" id="c-39061392" checked=""/><div class="controls bullet"><span class="by">photonbeam</span><span>|</span><a href="#39059272">root</a><span>|</span><a href="#39060677">parent</a><span>|</span><a href="#39064946">next</a><span>|</span><label class="collapse" for="c-39061392">[-]</label><label class="expand" for="c-39061392">[1 more]</label></div><br/><div class="children"><div class="content">Could put everything into the image - I mean the registry for just storage&#x2F;transmission rather than reusing pre existing minimal container images</div><br/></div></div></div></div></div></div><div id="39064946" class="c"><input type="checkbox" id="c-39064946" checked=""/><div class="controls bullet"><span class="by">david_wpg</span><span>|</span><a href="#39059272">prev</a><span>|</span><a href="#39062910">next</a><span>|</span><label class="collapse" for="c-39064946">[-]</label><label class="expand" for="c-39064946">[2 more]</label></div><br/><div class="children"><div class="content">I adore tart. I&#x27;ve used it over a year for work. It works very well with Cirrus Labs&#x27; images.</div><br/><div id="39065717" class="c"><input type="checkbox" id="c-39065717" checked=""/><div class="controls bullet"><span class="by">stillworks</span><span>|</span><a href="#39064946">parent</a><span>|</span><a href="#39062910">next</a><span>|</span><label class="collapse" for="c-39065717">[-]</label><label class="expand" for="c-39065717">[1 more]</label></div><br/><div class="children"><div class="content">Can this be used to setup a dev Linux VM ? Run Jetbrains IDEs etc on the VM ?
And if I were to run PyTorch then will it have access to GPU &#x2F; MPS ?</div><br/></div></div></div></div><div id="39062910" class="c"><input type="checkbox" id="c-39062910" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39064946">prev</a><span>|</span><a href="#39063281">next</a><span>|</span><label class="collapse" for="c-39062910">[-]</label><label class="expand" for="c-39062910">[2 more]</label></div><br/><div class="children"><div class="content">Does anyone know if GPU passthrough is available in any kind of macOS guests? I was hoping to run fast LLM inference in containers or virt guests.</div><br/><div id="39062952" class="c"><input type="checkbox" id="c-39062952" checked=""/><div class="controls bullet"><span class="by">fkorotkov</span><span>|</span><a href="#39062910">parent</a><span>|</span><a href="#39063281">next</a><span>|</span><label class="collapse" for="c-39062952">[-]</label><label class="expand" for="c-39062952">[1 more]</label></div><br/><div class="children"><div class="content">There is a paravirtualized GPU available to macOS hosts. But it’s a bit limited and might not work for LLMs but worth trying since it might work.</div><br/></div></div></div></div><div id="39063281" class="c"><input type="checkbox" id="c-39063281" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#39062910">prev</a><span>|</span><a href="#39060569">next</a><span>|</span><label class="collapse" for="c-39063281">[-]</label><label class="expand" for="c-39063281">[1 more]</label></div><br/><div class="children"><div class="content">Hey, big shout to CirrusLabs and the CirrusCI people because it&#x27;s the coolest CI.<p>Edit: CirrusLabs is the org behind Tart I believe.</div><br/></div></div><div id="39060569" class="c"><input type="checkbox" id="c-39060569" checked=""/><div class="controls bullet"><span class="by">d3w4s9</span><span>|</span><a href="#39063281">prev</a><span>|</span><a href="#39061621">next</a><span>|</span><label class="collapse" for="c-39060569">[-]</label><label class="expand" for="c-39060569">[7 more]</label></div><br/><div class="children"><div class="content">Serious question: how far can you go with base model&#x27;s 8GB RAM?<p>Doing VM workflows is one reason I didn&#x27;t bother with recent Macbooks, as nice as they are. It is simply much cheaper to get a machine with removable RAM and then upgrade them later. Without going there, I can also build a decent ThinkPad T14 with 32GB for around $1,100 even though RAM is soldered.</div><br/><div id="39060687" class="c"><input type="checkbox" id="c-39060687" checked=""/><div class="controls bullet"><span class="by">mattl</span><span>|</span><a href="#39060569">parent</a><span>|</span><a href="#39061042">next</a><span>|</span><label class="collapse" for="c-39060687">[-]</label><label class="expand" for="c-39060687">[5 more]</label></div><br/><div class="children"><div class="content">I can edit video in Final Cut Pro on my 8GB M1 Mac Mini while doing other things.</div><br/><div id="39061001" class="c"><input type="checkbox" id="c-39061001" checked=""/><div class="controls bullet"><span class="by">foofie</span><span>|</span><a href="#39060569">root</a><span>|</span><a href="#39060687">parent</a><span>|</span><a href="#39061042">next</a><span>|</span><label class="collapse" for="c-39061001">[-]</label><label class="expand" for="c-39061001">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I can edit video in Final Cut Pro on my 8GB M1 Mac Mini while doing other things.<p>I can&#x27;t use IntelliJ or vscode with autocompletion on a 2023 MacBook Air with 8GB of RAM with a bunch of my projects.<p>The same projects run like a breeze on a cheap and very crappy Beelink minipc with 16GB of RAM whose total cost is lower than a RAM upgrade on a MacBook Air.</div><br/><div id="39061607" class="c"><input type="checkbox" id="c-39061607" checked=""/><div class="controls bullet"><span class="by">CharlesW</span><span>|</span><a href="#39060569">root</a><span>|</span><a href="#39061001">parent</a><span>|</span><a href="#39061164">next</a><span>|</span><label class="collapse" for="c-39061607">[-]</label><label class="expand" for="c-39061607">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I can&#x27;t use IntelliJ or vscode with autocompletion on a 2023 MacBook Air with 8GB of RAM with a bunch of my projects.</i><p>That&#x27;s surprising. (More developer anecdata: <a href="https:&#x2F;&#x2F;duncsand.medium.com&#x2F;is-apples-cheapest-macbook-good-enough-for-a-developer-a669ba173ebd" rel="nofollow">https:&#x2F;&#x2F;duncsand.medium.com&#x2F;is-apples-cheapest-macbook-good-...</a>)<p>Still, I&#x27;d absolutely recommend that devs and other creators spend the extra $200 for 16GB. And yes, it&#x27;s outrageously priced in comparison to buying matched sticks for your PC.</div><br/></div></div><div id="39061164" class="c"><input type="checkbox" id="c-39061164" checked=""/><div class="controls bullet"><span class="by">mattl</span><span>|</span><a href="#39060569">root</a><span>|</span><a href="#39061001">parent</a><span>|</span><a href="#39061607">prev</a><span>|</span><a href="#39061042">next</a><span>|</span><label class="collapse" for="c-39061164">[-]</label><label class="expand" for="c-39061164">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if a native editor like Panic&#x27;s Nova or BBEdit would work better than a Java or Electron app?</div><br/><div id="39062074" class="c"><input type="checkbox" id="c-39062074" checked=""/><div class="controls bullet"><span class="by">bluish29</span><span>|</span><a href="#39060569">root</a><span>|</span><a href="#39061164">parent</a><span>|</span><a href="#39061042">next</a><span>|</span><label class="collapse" for="c-39062074">[-]</label><label class="expand" for="c-39062074">[1 more]</label></div><br/><div class="children"><div class="content">Bbedit is a a lightweight editor compared to Intellij IDE. It is hard to compare both as they are on the same foot. But yes, if you can work with BBedit on a project go for it.<p>On the same note, sublime will still win editor performance competition on Mac and probably all platforms.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39060508" class="c"><input type="checkbox" id="c-39060508" checked=""/><div class="controls bullet"><span class="by">jamifsud</span><span>|</span><a href="#39061621">prev</a><span>|</span><a href="#39062219">next</a><span>|</span><label class="collapse" for="c-39060508">[-]</label><label class="expand" for="c-39060508">[4 more]</label></div><br/><div class="children"><div class="content">Are there any similar open source tools that allow you to manage MacOS VMs?  I&#x27;m aware of Lima &#x2F; Colima but it seems they&#x27;re for Linux only.</div><br/><div id="39060644" class="c"><input type="checkbox" id="c-39060644" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#39060508">parent</a><span>|</span><a href="#39061899">next</a><span>|</span><label class="collapse" for="c-39060644">[-]</label><label class="expand" for="c-39060644">[1 more]</label></div><br/><div class="children"><div class="content">UTM maybe?<p><a href="https:&#x2F;&#x2F;mac.getutm.app" rel="nofollow">https:&#x2F;&#x2F;mac.getutm.app</a></div><br/></div></div><div id="39061899" class="c"><input type="checkbox" id="c-39061899" checked=""/><div class="controls bullet"><span class="by">shoo_pl</span><span>|</span><a href="#39060508">parent</a><span>|</span><a href="#39060644">prev</a><span>|</span><a href="#39063942">next</a><span>|</span><label class="collapse" for="c-39061899">[-]</label><label class="expand" for="c-39061899">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there is VirtualBuddy and Viable (not sure if this one is Open Source):<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;insidegui&#x2F;VirtualBuddy">https:&#x2F;&#x2F;github.com&#x2F;insidegui&#x2F;VirtualBuddy</a>
- <a href="https:&#x2F;&#x2F;eclecticlight.co&#x2F;virtualisation-on-apple-silicon&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eclecticlight.co&#x2F;virtualisation-on-apple-silicon&#x2F;</a></div><br/></div></div><div id="39063942" class="c"><input type="checkbox" id="c-39063942" checked=""/><div class="controls bullet"><span class="by">alwillis</span><span>|</span><a href="#39060508">parent</a><span>|</span><a href="#39061899">prev</a><span>|</span><a href="#39062219">next</a><span>|</span><label class="collapse" for="c-39063942">[-]</label><label class="expand" for="c-39063942">[1 more]</label></div><br/><div class="children"><div class="content">I’d look at <a href="https:&#x2F;&#x2F;eclecticlight.co&#x2F;virtualisation-on-apple-silicon&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eclecticlight.co&#x2F;virtualisation-on-apple-silicon&#x2F;</a></div><br/></div></div></div></div><div id="39062219" class="c"><input type="checkbox" id="c-39062219" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#39060508">prev</a><span>|</span><a href="#39059623">next</a><span>|</span><label class="collapse" for="c-39062219">[-]</label><label class="expand" for="c-39062219">[1 more]</label></div><br/><div class="children"><div class="content">Has no one here heard of mutagen before? It solves our performance issue regarding syncing</div><br/></div></div><div id="39059623" class="c"><input type="checkbox" id="c-39059623" checked=""/><div class="controls bullet"><span class="by">isodev</span><span>|</span><a href="#39062219">prev</a><span>|</span><a href="#39061069">next</a><span>|</span><label class="collapse" for="c-39059623">[-]</label><label class="expand" for="c-39059623">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it - why would one pay for something that comes for free on every Mac? Bootstrapping one in Swift is quite straightforward and there are a number of tools and apps (with UI) like virt (<a href="https:&#x2F;&#x2F;github.com&#x2F;apinske&#x2F;virt">https:&#x2F;&#x2F;github.com&#x2F;apinske&#x2F;virt</a>)</div><br/><div id="39059780" class="c"><input type="checkbox" id="c-39059780" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39059623">parent</a><span>|</span><a href="#39061069">next</a><span>|</span><label class="collapse" for="c-39059780">[-]</label><label class="expand" for="c-39059780">[3 more]</label></div><br/><div class="children"><div class="content">I guess their selling point is the container registry?</div><br/><div id="39059884" class="c"><input type="checkbox" id="c-39059884" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#39059623">root</a><span>|</span><a href="#39059780">parent</a><span>|</span><a href="#39061069">next</a><span>|</span><label class="collapse" for="c-39059884">[-]</label><label class="expand" for="c-39059884">[2 more]</label></div><br/><div class="children"><div class="content">This tool used to be open (AGPLv3 for some reason; it’s not a network service) and they changed to this crap license once they realized they had something good.<p>The AGPL version is available in homebrew.</div><br/><div id="39065650" class="c"><input type="checkbox" id="c-39065650" checked=""/><div class="controls bullet"><span class="by">fkorotkov</span><span>|</span><a href="#39059623">root</a><span>|</span><a href="#39059884">parent</a><span>|</span><a href="#39061069">next</a><span>|</span><label class="collapse" for="c-39065650">[-]</label><label class="expand" for="c-39065650">[1 more]</label></div><br/><div class="children"><div class="content">Realization for the license change was a bit different. From day 1 we knew Tart is good and hoped to build a healthy ecosystem around it. Unfortunately, our enthusiasm  wasn&#x27;t met by big companies. You can check this blog post for more details <a href="https:&#x2F;&#x2F;tart.run&#x2F;blog&#x2F;2023&#x2F;02&#x2F;11&#x2F;changing-tart-license&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tart.run&#x2F;blog&#x2F;2023&#x2F;02&#x2F;11&#x2F;changing-tart-license&#x2F;</a>.<p>The free usage is pretty generous: free on any amount of personal computers including personal workstations and up to 100 cores (12 Mac Minis) when installed on servers. If your organizations needs a bigger installation then it&#x27;s probably values the product and can budget out a little bit to support it.</div><br/></div></div></div></div></div></div></div></div><div id="39061069" class="c"><input type="checkbox" id="c-39061069" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39059623">prev</a><span>|</span><a href="#39059614">next</a><span>|</span><label class="collapse" for="c-39061069">[-]</label><label class="expand" for="c-39061069">[4 more]</label></div><br/><div class="children"><div class="content">Is there a modern easy GUI that allows snapshots without reaching for QEMU?</div><br/><div id="39061123" class="c"><input type="checkbox" id="c-39061123" checked=""/><div class="controls bullet"><span class="by">lupinglade</span><span>|</span><a href="#39061069">parent</a><span>|</span><a href="#39059614">next</a><span>|</span><label class="collapse" for="c-39061123">[-]</label><label class="expand" for="c-39061123">[3 more]</label></div><br/><div class="children"><div class="content">Yes, VMTek does snapshots natively and takes advantage of APFS. We have a great graphical snapshot UI as well.</div><br/><div id="39064644" class="c"><input type="checkbox" id="c-39064644" checked=""/><div class="controls bullet"><span class="by">Khaine</span><span>|</span><a href="#39061069">root</a><span>|</span><a href="#39061123">parent</a><span>|</span><a href="#39061200">next</a><span>|</span><label class="collapse" for="c-39064644">[-]</label><label class="expand" for="c-39064644">[1 more]</label></div><br/><div class="children"><div class="content">Does VMTek support *BSDs (i.e. FreeBSD &#x2F; OpenBSD)</div><br/></div></div><div id="39061200" class="c"><input type="checkbox" id="c-39061200" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39061069">root</a><span>|</span><a href="#39061123">parent</a><span>|</span><a href="#39064644">prev</a><span>|</span><a href="#39059614">next</a><span>|</span><label class="collapse" for="c-39061200">[-]</label><label class="expand" for="c-39061200">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, thanks. I was looking for an open source solution though, sorry for not specifying.</div><br/></div></div></div></div></div></div><div id="39059614" class="c"><input type="checkbox" id="c-39059614" checked=""/><div class="controls bullet"><span class="by">navojoe</span><span>|</span><a href="#39061069">prev</a><span>|</span><a href="#39059661">next</a><span>|</span><label class="collapse" for="c-39059614">[-]</label><label class="expand" for="c-39059614">[6 more]</label></div><br/><div class="children"><div class="content">I tried the ubuntu lastest image, but don&#x27;t know what user and password use to log into.  Any idea?</div><br/><div id="39060595" class="c"><input type="checkbox" id="c-39060595" checked=""/><div class="controls bullet"><span class="by">pritambarhate</span><span>|</span><a href="#39059614">parent</a><span>|</span><a href="#39059953">next</a><span>|</span><label class="collapse" for="c-39060595">[-]</label><label class="expand" for="c-39060595">[1 more]</label></div><br/><div class="children"><div class="content">If you just need Ubuntu then you can try &quot;Multipass&quot; from Canonical (<a href="https:&#x2F;&#x2F;multipass.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;multipass.run&#x2F;</a>). Works quite well on my M2 Air. I haven&#x27;t tried using Linux GUI with it though as I need only terminal based VMs.</div><br/></div></div><div id="39059953" class="c"><input type="checkbox" id="c-39059953" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#39059614">parent</a><span>|</span><a href="#39060595">prev</a><span>|</span><a href="#39059661">next</a><span>|</span><label class="collapse" for="c-39059953">[-]</label><label class="expand" for="c-39059953">[4 more]</label></div><br/><div class="children"><div class="content">creativity, should be user ubuntu pass ubuntu</div><br/><div id="39060011" class="c"><input type="checkbox" id="c-39060011" checked=""/><div class="controls bullet"><span class="by">navojoe</span><span>|</span><a href="#39059614">root</a><span>|</span><a href="#39059953">parent</a><span>|</span><a href="#39059661">next</a><span>|</span><label class="collapse" for="c-39060011">[-]</label><label class="expand" for="c-39060011">[3 more]</label></div><br/><div class="children"><div class="content">I have tried user ubuntu with ... empty , pass, ubuntu. None of them works.</div><br/><div id="39061007" class="c"><input type="checkbox" id="c-39061007" checked=""/><div class="controls bullet"><span class="by">dps</span><span>|</span><a href="#39059614">root</a><span>|</span><a href="#39060011">parent</a><span>|</span><a href="#39059661">next</a><span>|</span><label class="collapse" for="c-39061007">[-]</label><label class="expand" for="c-39061007">[2 more]</label></div><br/><div class="children"><div class="content">admin&#x2F;admin worked for me</div><br/><div id="39061907" class="c"><input type="checkbox" id="c-39061907" checked=""/><div class="controls bullet"><span class="by">navojoe</span><span>|</span><a href="#39059614">root</a><span>|</span><a href="#39061007">parent</a><span>|</span><a href="#39059661">next</a><span>|</span><label class="collapse" for="c-39061907">[-]</label><label class="expand" for="c-39061907">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!  working now</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39059661" class="c"><input type="checkbox" id="c-39059661" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39059614">prev</a><span>|</span><a href="#39062955">next</a><span>|</span><label class="collapse" for="c-39059661">[-]</label><label class="expand" for="c-39059661">[4 more]</label></div><br/><div class="children"><div class="content">[addendum: per u&#x2F;pm215  Hypervisor.Framework does still apparently exist and supported on apple silicon apparently, I assume the absence of hardware docs just makes it miserable. OTOH maybe the Asahi GPU drivers, etc can work in that model? I really haven&#x27;t ever done anything substantially more than what the WWDC demos do so am not a deep fount of knowledge here :D, to avoid confusion with replies I have not edited or changed my original comment. I kind of wish that HN UX exposed edit histories for comments, or provided separate addendum&#x2F;correction options]<p>Virtualization.Framework is how you have to do virtualization on apple silicon as it is the userspace API layer that interacts with the kernel. There is no API you can use.<p>Virtualization.Framework is pretty much everything you need out of the box for a generic &quot;I have an isolated virtual machine&quot; model, basically it&#x27;s just missing a configuration UI and main()<p>There are a couple of WWDC sessions over the last few WWDCs on using the framework, configuring rosetta, and improvements in the 2023 OS update<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2022&#x2F;10002" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2022&#x2F;10002</a>
<a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2023&#x2F;10007" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2023&#x2F;10007</a><p>[1] commercial VM products probably require more work to compete in the market, things like the transparent desktop, window hosting, etc</div><br/><div id="39060170" class="c"><input type="checkbox" id="c-39060170" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39059661">parent</a><span>|</span><a href="#39060372">next</a><span>|</span><label class="collapse" for="c-39060170">[-]</label><label class="expand" for="c-39060170">[1 more]</label></div><br/><div class="children"><div class="content">Apple also documents the Virtualization framework fairly well at <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;virtualization" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;virtualization</a>, with links to various code samples.<p>For example, <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;virtualization&#x2F;running_linux_in_a_virtual_machine" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;virtualization&#x2F;run...</a>:<p><i>“This sample configures a virtual machine for a Linux-based operating system. You run the sample from the command line, and you specify the locations of the Linux kernel to run and initial RAM disk to load as command-line parameters. The sample configures the boot loader that the virtual machine requires to run the guest operating system, and it configures a console device to handle standard input and output. It then starts the virtual machine and exits when the Linux kernel shuts down.”</i></div><br/></div></div><div id="39060372" class="c"><input type="checkbox" id="c-39060372" checked=""/><div class="controls bullet"><span class="by">stuff4ben</span><span>|</span><a href="#39059661">parent</a><span>|</span><a href="#39060170">prev</a><span>|</span><a href="#39060434">next</a><span>|</span><label class="collapse" for="c-39060372">[-]</label><label class="expand" for="c-39060372">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! I really need a cheap way to spin up an Apple Silicon container to create binaries for an open source project on GitHub. I don&#x27;t want to spend money on an Apple Silicon runner in GitHub and I also don&#x27;t want to run the build directly on my M2 MacBook Pro along with my other development work.</div><br/></div></div><div id="39060434" class="c"><input type="checkbox" id="c-39060434" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#39059661">parent</a><span>|</span><a href="#39060372">prev</a><span>|</span><a href="#39062955">next</a><span>|</span><label class="collapse" for="c-39060434">[-]</label><label class="expand" for="c-39060434">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t <i>have</i> to use Virtualization.Framework. Hypervisor.Framework is the lower level API -- <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;hypervisor" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;hypervisor</a> ; QEMU uses that.</div><br/></div></div></div></div><div id="39062955" class="c"><input type="checkbox" id="c-39062955" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39059661">prev</a><span>|</span><a href="#39059572">next</a><span>|</span><label class="collapse" for="c-39062955">[-]</label><label class="expand" for="c-39062955">[11 more]</label></div><br/><div class="children"><div class="content">APPROPRIATELY-SIZED WARNING: The website and GitHub repo do not make it immediately obvious that this project isn&#x27;t open source* and that if you use it at work your company may have a bad time.<p>*: <a href="https:&#x2F;&#x2F;opensource.org&#x2F;osd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;opensource.org&#x2F;osd&#x2F;</a><p>I wonder if we could add something like crowd-voted tags to submissions, to include e.g. the license for software that has a GitHub link.</div><br/><div id="39064402" class="c"><input type="checkbox" id="c-39064402" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39063531">next</a><span>|</span><label class="collapse" for="c-39064402">[-]</label><label class="expand" for="c-39064402">[2 more]</label></div><br/><div class="children"><div class="content">Licenses like this inspire me to recreate it from scratch and redistribute under open source. Some would call this a “race to the bottom” but I see it as doing my part to contribute to chaos</div><br/><div id="39064704" class="c"><input type="checkbox" id="c-39064704" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#39062955">root</a><span>|</span><a href="#39064402">parent</a><span>|</span><a href="#39063531">next</a><span>|</span><label class="collapse" for="c-39064704">[-]</label><label class="expand" for="c-39064704">[1 more]</label></div><br/><div class="children"><div class="content">No need; prior to this license they licensed it under AGPLv3, even though it is not a network service.  You can use that version as-is or you could extend it.<p>Commits prior to the 1.0 release and the license change are there in GitHub, last I looked.</div><br/></div></div></div></div><div id="39063531" class="c"><input type="checkbox" id="c-39063531" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39064402">prev</a><span>|</span><a href="#39063231">next</a><span>|</span><label class="collapse" for="c-39063531">[-]</label><label class="expand" for="c-39063531">[1 more]</label></div><br/><div class="children"><div class="content">LICENSE file in the repo is also pretty clear in its intended limitations.<p>However for the license to be effective it probably needs to be rewritten to handle agents of organizations.  As it reads now, arguably 30 employees could deploy the software on 500 6-core mac&#x27;s without violating the license.</div><br/></div></div><div id="39063231" class="c"><input type="checkbox" id="c-39063231" checked=""/><div class="controls bullet"><span class="by">amanzi</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39063531">prev</a><span>|</span><a href="#39065074">next</a><span>|</span><label class="collapse" for="c-39063231">[-]</label><label class="expand" for="c-39063231">[2 more]</label></div><br/><div class="children"><div class="content">Seemed pretty obvious to me after looking at the &quot;Support &amp; Licensing&quot; section of the website. They explain it in clear terms.</div><br/></div></div><div id="39065074" class="c"><input type="checkbox" id="c-39065074" checked=""/><div class="controls bullet"><span class="by">filleduchaos</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39063231">prev</a><span>|</span><a href="#39064908">next</a><span>|</span><label class="collapse" for="c-39065074">[-]</label><label class="expand" for="c-39065074">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much nothing about the website and repo indicated that this is an open source project. Why would anyone just assume that it is? Hell, one of the quick links at the top of the home page is &quot;Support &amp; Licensing&quot;.<p>Open source licensing is still <i>licensing</i>. I feel like people increasingly treat it as &quot;yay freebies for me&quot; and not as actual licenses that you still have to look for, read, and comply with.</div><br/></div></div><div id="39064908" class="c"><input type="checkbox" id="c-39064908" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39065074">prev</a><span>|</span><a href="#39063907">next</a><span>|</span><label class="collapse" for="c-39064908">[-]</label><label class="expand" for="c-39064908">[1 more]</label></div><br/><div class="children"><div class="content"><i>if we could add something like crowd-voted tags to submissions</i><p>the repetitive license threads already add too much noise to most submissions (there are already two in this one) - anyone interested in using this can just read the license that comes with the repo. Just about every submission has more interesting things to discuss than license stuff.</div><br/></div></div><div id="39063907" class="c"><input type="checkbox" id="c-39063907" checked=""/><div class="controls bullet"><span class="by">taspeotis</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39064908">prev</a><span>|</span><a href="#39063696">next</a><span>|</span><label class="collapse" for="c-39063907">[-]</label><label class="expand" for="c-39063907">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;tart.run&#x2F;licensing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tart.run&#x2F;licensing&#x2F;</a></div><br/></div></div><div id="39063696" class="c"><input type="checkbox" id="c-39063696" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#39062955">parent</a><span>|</span><a href="#39063907">prev</a><span>|</span><a href="#39064896">next</a><span>|</span><label class="collapse" for="c-39063696">[-]</label><label class="expand" for="c-39063696">[1 more]</label></div><br/><div class="children"><div class="content">If you obtain and use software for <i>commercial purposes</i> without checking the licensing and usage terms, you need to grab a lawyer and have him give you a crash course at your leisure before some lawyers come knocking to <i>give</i> you a <i>crash</i> course at <i>their</i> leisure.</div><br/></div></div></div></div><div id="39059572" class="c"><input type="checkbox" id="c-39059572" checked=""/><div class="controls bullet"><span class="by">0x69420</span><span>|</span><a href="#39062955">prev</a><span>|</span><a href="#39060048">next</a><span>|</span><label class="collapse" for="c-39059572">[-]</label><label class="expand" for="c-39059572">[4 more]</label></div><br/><div class="children"><div class="content">heads up: it&#x27;s under one of those BSL-esque weirdo licenses [1] parameterised on seats and, get this, a seat is defined as a single CPU core (if you are not an individual). so don&#x27;t get any ideas about running it on more than 5 mac studios if you&#x27;re a university that wants to run CI for some open-source project along with those mirrors.<p>[1]: <a href="https:&#x2F;&#x2F;fair.io&#x2F;?a" rel="nofollow">https:&#x2F;&#x2F;fair.io&#x2F;?a</a></div><br/><div id="39060064" class="c"><input type="checkbox" id="c-39060064" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#39059572">parent</a><span>|</span><a href="#39060474">next</a><span>|</span><label class="collapse" for="c-39060064">[-]</label><label class="expand" for="c-39060064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What counts as “using” Fair Source licensed software with respect to the Use Limitation (e.g., 25-user limit)?<p>&gt; The license doesn’t define “use” exactly because the way people deploy software changes all the time. Instead, it relies on a common-sense definition. For example, executing the software, modifying the code, or accessing a running copy of the software constitutes “use.”<p>Appealing to common sense for a critical definition in a binding license agreement? What could go wrong!</div><br/></div></div><div id="39060474" class="c"><input type="checkbox" id="c-39060474" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#39059572">parent</a><span>|</span><a href="#39060064">prev</a><span>|</span><a href="#39061024">next</a><span>|</span><label class="collapse" for="c-39060474">[-]</label><label class="expand" for="c-39060474">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what the intended audience is. But for managing many instances among a few mac studios, it&#x27;s much better to invest an afternoon to get the right qemu command and just use that, instead of all these fancy UIs.</div><br/></div></div></div></div><div id="39060048" class="c"><input type="checkbox" id="c-39060048" checked=""/><div class="controls bullet"><span class="by">codetheory</span><span>|</span><a href="#39059572">prev</a><span>|</span><a href="#39061041">next</a><span>|</span><label class="collapse" for="c-39060048">[-]</label><label class="expand" for="c-39060048">[5 more]</label></div><br/><div class="children"><div class="content">Just use lima.
<a href="https:&#x2F;&#x2F;lima-vm.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lima-vm.io&#x2F;</a><p>You have an option to use Native or QEMU.</div><br/><div id="39060089" class="c"><input type="checkbox" id="c-39060089" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39060048">parent</a><span>|</span><a href="#39061109">next</a><span>|</span><label class="collapse" for="c-39060089">[-]</label><label class="expand" for="c-39060089">[1 more]</label></div><br/><div class="children"><div class="content">Or, if you&#x27;re doing containers (like Tart&#x2F;Virt): colima. (which uses lima, of course).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;abiosoft&#x2F;colima">https:&#x2F;&#x2F;github.com&#x2F;abiosoft&#x2F;colima</a></div><br/></div></div><div id="39061109" class="c"><input type="checkbox" id="c-39061109" checked=""/><div class="controls bullet"><span class="by">otherjason</span><span>|</span><a href="#39060048">parent</a><span>|</span><a href="#39060089">prev</a><span>|</span><a href="#39064909">next</a><span>|</span><label class="collapse" for="c-39061109">[-]</label><label class="expand" for="c-39061109">[1 more]</label></div><br/><div class="children"><div class="content">From a quick look at Lima, I don&#x27;t think it&#x27;s exactly the same thing. Tart allows running macOS and Linux VMs, while Lima seems focused on Linux VMs only. I don&#x27;t use Tart, but having infrastructure-as-code-like tooling that can be used to define macOS environments (and store the VMs in container registries) sounds useful and I&#x27;m not aware of another solution that does it.</div><br/></div></div><div id="39064909" class="c"><input type="checkbox" id="c-39064909" checked=""/><div class="controls bullet"><span class="by">latexr</span><span>|</span><a href="#39060048">parent</a><span>|</span><a href="#39061109">prev</a><span>|</span><a href="#39061033">next</a><span>|</span><label class="collapse" for="c-39064909">[-]</label><label class="expand" for="c-39064909">[1 more]</label></div><br/><div class="children"><div class="content">Does Lima only support Linux guests? The page seems to suggest so. Tart supports macOS guests too.</div><br/></div></div></div></div><div id="39061041" class="c"><input type="checkbox" id="c-39061041" checked=""/><div class="controls bullet"><span class="by">lupinglade</span><span>|</span><a href="#39060048">prev</a><span>|</span><label class="collapse" for="c-39061041">[-]</label><label class="expand" for="c-39061041">[2 more]</label></div><br/><div class="children"><div class="content">Also check out <a href="https:&#x2F;&#x2F;www.getvmtek.com" rel="nofollow">https:&#x2F;&#x2F;www.getvmtek.com</a> for something very polished. We just released a huge update a few days ago.</div><br/><div id="39063500" class="c"><input type="checkbox" id="c-39063500" checked=""/><div class="controls bullet"><span class="by">matrix_overload</span><span>|</span><a href="#39061041">parent</a><span>|</span><label class="collapse" for="c-39063500">[-]</label><label class="expand" for="c-39063500">[1 more]</label></div><br/><div class="children"><div class="content">Kind of a dark pattern to hide the license price (last line in the AppStore page -&gt; in-app purchases). Should be really prominently shown on the &quot;buy now&quot; page.<p>Also the features page is garbage. Wall of text with fairly generic stuff while it&#x27;s still unclear: Can it run Windows? Can it run Linux? Arm64, x64 or both? MacOS?<p>Your main competition is VMWare Fusion and Parallels. See what features they advertise, make sure you are better and cheaper. Currently it looks like a university project rather than a real product.</div><br/></div></div></div></div></div></div></div></div></div></body></html>