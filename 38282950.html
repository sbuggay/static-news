<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700125279412" as="style"/><link rel="stylesheet" href="styles.css?v=1700125279412"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2023/11/15/push-ifs-up-and-fors-down.html">Push ifs up and fors down</a>Â <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>celeritascelery</span> | <span>114 comments</span></div><br/><div><div id="38286565" class="c"><input type="checkbox" id="c-38286565" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38286253">next</a><span>|</span><label class="collapse" for="c-38286565">[-]</label><label class="expand" for="c-38286565">[5 more]</label></div><br/><div class="children"><div class="content">I was initially surprised by the pushback this article is getting.<p>Then I remembered that this is data-oriented design advice, and I imagine most people on this forum (myself included most of the time) are writing line-of-business web apps where this advice seems like nonsense. I had already internalised the context, and wasn&#x27;t planning to go apply this to my Laravel backend code.<p>A heuristic: if in your usual daily work you don&#x27;t need to think about the instruction cache, then you should probably ignore this advice.<p>If you haven&#x27;t yet and want to get a taste of when this advice matters, go find Mike Acton&#x27;s &quot;Typical C++ Bullshit&quot; and decipher the cryptic notes. This article is like an understandable distillation of that.<p>Despite what Casey Muratori is trying to argue (and I&#x27;m largely sympathetic to his efforts) most line-of-business software needs to optimise for changeability and correctness (&quot;programming over time&quot;) not performance.</div><br/><div id="38286793" class="c"><input type="checkbox" id="c-38286793" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#38286565">parent</a><span>|</span><a href="#38286956">next</a><span>|</span><label class="collapse" for="c-38286793">[-]</label><label class="expand" for="c-38286793">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, data-oriented design (DOD) always seems to get people riled up. I think it largely gets this type of reaction b&#x2F;c DOD implies that many aspects of the dominant object-oriented approach are wrong.<p>&gt; most line-of-business software needs to optimise for changeability and correctness, not performance.<p>It&#x27;s a shame that so many see changeability and performance in opposition with each other. I&#x27;ve yet to find compelling evidence that such is the case.</div><br/><div id="38287110" class="c"><input type="checkbox" id="c-38287110" checked=""/><div class="controls bullet"><span class="by">Gravityloss</span><span>|</span><a href="#38286565">root</a><span>|</span><a href="#38286793">parent</a><span>|</span><a href="#38286856">next</a><span>|</span><label class="collapse" for="c-38287110">[-]</label><label class="expand" for="c-38287110">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Is there an article showing how a clever one liner that is hard to read and an &quot;inefficient looking&quot; but easy to understand multiline explanation style code with proper variable names etc will result in the same compiled code?<p>I would assume compilers would be sufficiently advanced nowadays...</div><br/></div></div><div id="38286856" class="c"><input type="checkbox" id="c-38286856" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38286565">root</a><span>|</span><a href="#38286793">parent</a><span>|</span><a href="#38287110">prev</a><span>|</span><a href="#38286956">next</a><span>|</span><label class="collapse" for="c-38286856">[-]</label><label class="expand" for="c-38286856">[1 more]</label></div><br/><div class="children"><div class="content">Well it&#x27;s hard to argue about that tradeoff <i>in general</i>, but I think the existence of languages like Python, Ruby and PHP is compelling. Though I&#x27;d accept the argument that they help optimise for <i>neither</i> performance nor changeability!<p>My perspective is necessarily limited, but I often see optimisation as a case of &quot;vertical integration&quot; and changeability as about &quot;horizonal integration&quot;.<p>To make something fast, you can dig all the way down through all the layers and do the exact piece of work that is required with the minimum of useless faffing about for the CPU[0]. But to make something robust, you might want to e.g. validate all your inputs at each layer since you don&#x27;t know who&#x27;s going to call your method or service.<p>Regarding the DOD&#x2F;OOP wars, I really love this article, which argues that OOP doesn&#x27;t have to be bad[1]. I also think that when performance is a requirement, you just have to get more particular about your use of OOP. For example, the difference between Mesh and InstancedMesh[2] in THREE.js. Both are OOP, but have very different performance implications.<p>[0] Casey Muratori&#x27;s &quot;simple code, high performance&quot; video is an epic example of this. When the work he needed to do was &quot;this many specific floating point operations&quot;, it was so cool to see him strip away all the useless layers and do almost exactly and only those ops.<p>[1] <a href="https:&#x2F;&#x2F;www.gamedev.net&#x2F;blogs&#x2F;entry&#x2F;2265481-oop-is-dead-long-live-oop&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gamedev.net&#x2F;blogs&#x2F;entry&#x2F;2265481-oop-is-dead-long...</a><p>[2] <a href="https:&#x2F;&#x2F;threejs.org&#x2F;docs&#x2F;index.html?q=instanc#api&#x2F;en&#x2F;objects&#x2F;InstancedMesh" rel="nofollow noreferrer">https:&#x2F;&#x2F;threejs.org&#x2F;docs&#x2F;index.html?q=instanc#api&#x2F;en&#x2F;objects...</a></div><br/></div></div></div></div><div id="38286956" class="c"><input type="checkbox" id="c-38286956" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#38286565">parent</a><span>|</span><a href="#38286793">prev</a><span>|</span><a href="#38286253">next</a><span>|</span><label class="collapse" for="c-38286956">[-]</label><label class="expand" for="c-38286956">[1 more]</label></div><br/><div class="children"><div class="content">maybe - although most of the time, especially last few years, I write web apps and I push ifs up all the time because it allows for early return like the article says.<p>Determining that you need to do nothing should be done as soon as possible, especially in any system where performance is essential and web apps make more money the better their performance as a general rule.</div><br/></div></div></div></div><div id="38286253" class="c"><input type="checkbox" id="c-38286253" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#38286565">prev</a><span>|</span><a href="#38284630">next</a><span>|</span><label class="collapse" for="c-38286253">[-]</label><label class="expand" for="c-38286253">[13 more]</label></div><br/><div class="children"><div class="content">The more experience I get, the more I feel that too many programmers worry about making things pretty &quot;in the small&quot;, but not enough care about proper design of an entire codebase.<p>I&#x27;ll admit that I like a concise and well-crafted function just as much as many others, but articles like this one are probably the things that can lead to the kind of unproductive bikeshedding that is sometimes experienced in PRs and other discussions. I don&#x27;t care that much about whether your function is messy - or about where you put your ifs and fors (or if you use maps and filters instead), as long as the function is properly named, has a good interface (including expressive types), a clear purpose, is properly documented, doesn&#x27;t make excessive use of side effects etc.</div><br/><div id="38286903" class="c"><input type="checkbox" id="c-38286903" checked=""/><div class="controls bullet"><span class="by">joelthelion</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286308">next</a><span>|</span><label class="collapse" for="c-38286903">[-]</label><label class="expand" for="c-38286903">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  The more experience I get, the more I feel that too many programmers worry about making things pretty &quot;in the small&quot;, but not enough care about proper design of an entire codebase.<p>I&#x27;ve seen the reverse a lot, too. People who enjoy designing over-engineered cathedrals and can&#x27;t be bothered to think about the low-level efficiency of their algorithms.</div><br/><div id="38286968" class="c"><input type="checkbox" id="c-38286968" checked=""/><div class="controls bullet"><span class="by">maeln</span><span>|</span><a href="#38286253">root</a><span>|</span><a href="#38286903">parent</a><span>|</span><a href="#38287005">next</a><span>|</span><label class="collapse" for="c-38286968">[-]</label><label class="expand" for="c-38286968">[1 more]</label></div><br/><div class="children"><div class="content">In general, I feel like too many developer get caught up in dogma, &quot;best-practices&quot; that are effectively often unrealistic, and tend to adopt extremist way of thinking about the big and &#x2F; or the small picture. 
A lot of the &quot;dev culture&quot; feel like it lacks a sense of pragmatism.</div><br/></div></div><div id="38287005" class="c"><input type="checkbox" id="c-38287005" checked=""/><div class="controls bullet"><span class="by">antupis</span><span>|</span><a href="#38286253">root</a><span>|</span><a href="#38286903">parent</a><span>|</span><a href="#38286968">prev</a><span>|</span><a href="#38286308">next</a><span>|</span><label class="collapse" for="c-38287005">[-]</label><label class="expand" for="c-38287005">[1 more]</label></div><br/><div class="children"><div class="content">I think this tells more about company culture than the people themselves, some companies like small things, and others like cathedrals.</div><br/></div></div></div></div><div id="38286308" class="c"><input type="checkbox" id="c-38286308" checked=""/><div class="controls bullet"><span class="by">Leo_Germond</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286903">prev</a><span>|</span><a href="#38286545">next</a><span>|</span><label class="collapse" for="c-38286308">[-]</label><label class="expand" for="c-38286308">[4 more]</label></div><br/><div class="children"><div class="content">The advice about if up is not bikeshedding though, it is the exact kind of architectural choice you&#x27;re saying one should decide on. Don&#x27;t believe me ? Well imagine you have inputs, where should you validate them ? According to this rule of thumb it&#x27;s at the topmost level, when they are received. Well that seems super sensible, and it&#x27;s typically something that helps with understanding the code (rather than checking them at thw very last moment). Also for proofs that&#x27;s technically necessary to allow the preconditions to &quot;percolate up&quot;, which has the same effect of moving the if up.<p>So the first advice is definitely not bike shedding, the second one I&#x27;m not so clear though ;)</div><br/><div id="38286531" class="c"><input type="checkbox" id="c-38286531" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#38286253">root</a><span>|</span><a href="#38286308">parent</a><span>|</span><a href="#38286329">next</a><span>|</span><label class="collapse" for="c-38286531">[-]</label><label class="expand" for="c-38286531">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it is the exact kind of architectural choice you&#x27;re saying one should decide on.<p>While I can&#x27;t speak to what the OP had in mind, architectural concerns are definitely not inside a function.  Even connecting individual functions&#x2F;procedures barely registers at the smallest, most granular scale of architecture.<p>Of course, our programming languages for the most part don&#x27;t let us express architectural concerns...so here we are.</div><br/></div></div><div id="38286329" class="c"><input type="checkbox" id="c-38286329" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#38286253">root</a><span>|</span><a href="#38286308">parent</a><span>|</span><a href="#38286531">prev</a><span>|</span><a href="#38286545">next</a><span>|</span><label class="collapse" for="c-38286329">[-]</label><label class="expand" for="c-38286329">[2 more]</label></div><br/><div class="children"><div class="content">But the article wasn&#x27;t about &quot;validate inputs at the boundaries&quot; (which is a semantic concern), it was about &quot;push your ifs up&quot; (which is a syntactic concern).<p>I agree that in the provided example, those two seem to somewhat coincide (although it&#x27;s hard to say, given that the author makes an effort to give their functions names such as &quot;frobnicate&quot; that don&#x27;t indicate their purpose), but in the general case that doesn&#x27;t have to be true.</div><br/><div id="38286474" class="c"><input type="checkbox" id="c-38286474" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#38286253">root</a><span>|</span><a href="#38286329">parent</a><span>|</span><a href="#38286545">next</a><span>|</span><label class="collapse" for="c-38286474">[-]</label><label class="expand" for="c-38286474">[1 more]</label></div><br/><div class="children"><div class="content">Are we reading the same article? There is zero concern for syntax.<p>The first point is literally what you said. Write functions with clear interfaces. If your function doesn&#x27;t handle None, make its argument type reflect that (Walrus instead of Option&lt;Walrus&gt;).<p>The second point is about performance. Hoist branches out of loops, and process batches so any constant cost is amortized over the batch. Is that even controversial?<p>&gt; the author makes an effort to give their functions names such as &quot;frobnicate&quot;<p>Yes, and that&#x27;s good, because it keeps the focus on his actual points rather than the minutiae of a contrived example.</div><br/></div></div></div></div></div></div><div id="38286545" class="c"><input type="checkbox" id="c-38286545" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286308">prev</a><span>|</span><a href="#38286524">next</a><span>|</span><label class="collapse" for="c-38286545">[-]</label><label class="expand" for="c-38286545">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ... but not enough care about proper design of an entire codebase.<p>One reason is that we don&#x27;t have ways of meaningfully expressing components much larger than functions or that connect differently from functions in our programming languages.  At most we can aggregate functions together.  After that we&#x27;re on our own.</div><br/></div></div><div id="38286524" class="c"><input type="checkbox" id="c-38286524" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286545">prev</a><span>|</span><a href="#38286857">next</a><span>|</span><label class="collapse" for="c-38286524">[-]</label><label class="expand" for="c-38286524">[1 more]</label></div><br/><div class="children"><div class="content">To go along the same line of thought, too many think about the beatuy of the flower, instead of the whole florest.<p>The amount of hours occasionally wasted discussing this in PR, that add zero value to what the customer actually cares, e.g. does pressing the button print or not their monthly invoice.<p>Sure there is a balance to be had between completly unmaintainable code, and a piece of art to expose in the Louvre, however too many focus on the latter, instead of what is the customer getting out of their beautiful flower.</div><br/></div></div><div id="38286857" class="c"><input type="checkbox" id="c-38286857" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286524">prev</a><span>|</span><a href="#38286467">next</a><span>|</span><label class="collapse" for="c-38286857">[-]</label><label class="expand" for="c-38286857">[1 more]</label></div><br/><div class="children"><div class="content">Poor choice of words in TFA and a cursory read by a reader generated this misunderstanding. &quot;Up&quot; means &quot;to the caller&quot; for the author, but was probably understood as &quot;towards the beginning (of the function or file)&quot;.</div><br/></div></div><div id="38286467" class="c"><input type="checkbox" id="c-38286467" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286857">prev</a><span>|</span><a href="#38286278">next</a><span>|</span><label class="collapse" for="c-38286467">[-]</label><label class="expand" for="c-38286467">[1 more]</label></div><br/><div class="children"><div class="content">Programming language design also tends to focus on the small (e.g. optimizing the number of language keywords).</div><br/></div></div><div id="38286278" class="c"><input type="checkbox" id="c-38286278" checked=""/><div class="controls bullet"><span class="by">tangjurine</span><span>|</span><a href="#38286253">parent</a><span>|</span><a href="#38286467">prev</a><span>|</span><a href="#38284630">next</a><span>|</span><label class="collapse" for="c-38286278">[-]</label><label class="expand" for="c-38286278">[1 more]</label></div><br/><div class="children"><div class="content">Like there&#x27;s the stuff that can be refactored because the changes are local, or the places to change are clear.<p>And then the stuff that is a lot harder to refactor because you would need to change code in a lot of places, and the places that need to be changed aren&#x27;t clear. That&#x27;s probably more the proper design of a codebase stuff.</div><br/></div></div></div></div><div id="38284630" class="c"><input type="checkbox" id="c-38284630" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38286253">prev</a><span>|</span><a href="#38287140">next</a><span>|</span><label class="collapse" for="c-38284630">[-]</label><label class="expand" for="c-38284630">[22 more]</label></div><br/><div class="children"><div class="content">The first example is bad for reasons not related to ifs and fors.  In general, if you can, if you have a &quot;container&quot; for something, you should write functions on the contained, domain-level &quot;Thing&quot; rather than the container with the domain level thing.<p>As an example I work with - Clojure.  Sometimes I use agents.  I don&#x27;t write functions for agents, I write functions for things agents might contain.<p>Similar rules for Elixir.  My primary domain level functions don&#x27;t work off a PID.  They work off the underlying, domain-level data structures.  GenServer calls delegate to that where necessary.<p>This makes them more flexible, and tends to keep a cleaner distinction between a core domain (frobnicate the Walrus) and broader application concerns (maybe the Walrus is there, maybe not... oh yeah, also frobnicate it).</div><br/><div id="38284771" class="c"><input type="checkbox" id="c-38284771" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#38284630">parent</a><span>|</span><a href="#38286922">next</a><span>|</span><label class="collapse" for="c-38284771">[-]</label><label class="expand" for="c-38284771">[19 more]</label></div><br/><div class="children"><div class="content">Yeah. I think the given advice probably takes validation logic and floats it too high. It is of course nice to have early validation logic, but it is also nice when your functions don&#x27;t mysteriously crap out with some weird error but instead shout a validation error at you.<p>Haskell solves this with newtypes, âhere is a transparent container that certifies that you did the appropriate validation already,â that helps for this.<p>The advice that I really want to hammer into people&#x27;s heads is, prefer âsad ifs.â That is, I will almost always find this<p><pre><code>    if (something_is_wrong_in_way_1) {
      &#x2F;&#x2F; fix it or abort
    }
    if (something_is_wrong_in_way_2) {
      &#x2F;&#x2F; fix it or abort
    }
    if (something_is_wrong_in_way_3) {
      &#x2F;&#x2F; fix it or abort
    }
</code></pre>
more readable and maintainable than this<p><pre><code>    if (things_are_ok_in_way_1) {
      if (things_are_ok_in_way_2) {
        if (things_are_ok_in_way_3) {
          &#x2F;&#x2F; do the happy path!
        } else {
          &#x2F;&#x2F; fix or abort thing 3
          &#x2F;&#x2F; if fixed, do the happy path
        }
      } else {
        &#x2F;&#x2F; fix or abort thing 2
        &#x2F;&#x2F; if fixed, test way 3 again
        &#x2F;&#x2F; if way 3 is good do the happy path, else fix it
        &#x2F;&#x2F; ...
      }
    } else {
      &#x2F;&#x2F; ...
    }
</code></pre>
I feel like it&#x27;s in human nature to focus on the expected case, I want everyone whose code I meet to do the exact opposite, focus primarily on the unexpected. Every âifâ imposes a mental burden that I am keeping track of, and if you have to go to an external system to fetch that information, or you need to exit early with an error, I can immediately discharge that mental burden the moment I know about it, if the handling and the detection are right next to each other.</div><br/><div id="38285755" class="c"><input type="checkbox" id="c-38285755" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38286064">next</a><span>|</span><label class="collapse" for="c-38285755">[-]</label><label class="expand" for="c-38285755">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The advice that I really want to hammer into people&#x27;s heads is, prefer âsad ifs.â<p>I think this is the first time I&#x27;ve heard that name for this idea.  You&#x27;ll find more under the term &quot;guard clauses&quot; - it even has its own Wikipedia page:  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Guard_(computer_science)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Guard_(computer_science)</a></div><br/><div id="38286050" class="c"><input type="checkbox" id="c-38286050" checked=""/><div class="controls bullet"><span class="by">softfalcon</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38285755">parent</a><span>|</span><a href="#38286064">next</a><span>|</span><label class="collapse" for="c-38286050">[-]</label><label class="expand" for="c-38286050">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, same, also know this as guard clauses. But &quot;sad if&#x27;s&quot; is kind of adorable sounding, so I might start using it.</div><br/><div id="38286273" class="c"><input type="checkbox" id="c-38286273" checked=""/><div class="controls bullet"><span class="by">philbo</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38286050">parent</a><span>|</span><a href="#38286064">next</a><span>|</span><label class="collapse" for="c-38286273">[-]</label><label class="expand" for="c-38286273">[2 more]</label></div><br/><div class="children"><div class="content">pessimifs</div><br/><div id="38286838" class="c"><input type="checkbox" id="c-38286838" checked=""/><div class="controls bullet"><span class="by">867-5309</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38286273">parent</a><span>|</span><a href="#38286064">next</a><span>|</span><label class="collapse" for="c-38286838">[-]</label><label class="expand" for="c-38286838">[1 more]</label></div><br/><div class="children"><div class="content">depressifs?</div><br/></div></div></div></div></div></div></div></div><div id="38286064" class="c"><input type="checkbox" id="c-38286064" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38285755">prev</a><span>|</span><a href="#38285410">next</a><span>|</span><label class="collapse" for="c-38286064">[-]</label><label class="expand" for="c-38286064">[1 more]</label></div><br/><div class="children"><div class="content">I once had a CS teacher who hated early returns and break statements; they would always prefer the &quot;nested ifs&quot; approach. And they&#x27;re far from being alone - many others believe that path is cleaner.<p>I&#x27;m with the parent poster, though: if you can use control flow to keep the happy path the unindented path, and you have syntax highlighting to help you show that each guard clause actually does interrupt the control flow, it can often be significantly cleaner.<p>I also like to think of it in terms of &quot;railway oriented programming&quot; (<a href="https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;rop&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;rop&#x2F;</a> which is a must-read for anyone trying to wade into monads and functional programming IMO) - the &quot;happy path&quot; should be the path that it&#x27;s easiest for the train to go down, namely a straight line down the page. Only give yourself the headache of a sharp turn when you&#x27;re interrupting that path!</div><br/></div></div><div id="38285410" class="c"><input type="checkbox" id="c-38285410" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38286064">prev</a><span>|</span><a href="#38286043">next</a><span>|</span><label class="collapse" for="c-38285410">[-]</label><label class="expand" for="c-38285410">[6 more]</label></div><br/><div class="children"><div class="content">In short: avoid `else`.<p>Both what you mention, and also the case with :<p><pre><code>   if (...) {
     ...
   } else { 
     return 0; 
   }
</code></pre>
Which can become<p><pre><code>   if (...) {
     ...
   }

   return 0;</code></pre></div><br/><div id="38285452" class="c"><input type="checkbox" id="c-38285452" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38285410">parent</a><span>|</span><a href="#38286349">next</a><span>|</span><label class="collapse" for="c-38285452">[-]</label><label class="expand" for="c-38285452">[1 more]</label></div><br/><div class="children"><div class="content">Even better, if you&#x27;re using a language with pattern matching (rust, any ML, haskell), just put it in a single match with the happy case on top, and the error cases below.<p>To do this, you need to encode the distinction between happy and sad path in your types.  That&#x27;s good for all sorts of other reasons, so it&#x27;s not really a drawback.</div><br/></div></div><div id="38286349" class="c"><input type="checkbox" id="c-38286349" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38285410">parent</a><span>|</span><a href="#38285452">prev</a><span>|</span><a href="#38286021">next</a><span>|</span><label class="collapse" for="c-38286349">[-]</label><label class="expand" for="c-38286349">[1 more]</label></div><br/><div class="children"><div class="content">In functional languages like elixir there is no return though, and you are forced to use if-else structure</div><br/></div></div><div id="38286021" class="c"><input type="checkbox" id="c-38286021" checked=""/><div class="controls bullet"><span class="by">theteapot</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38285410">parent</a><span>|</span><a href="#38286349">prev</a><span>|</span><a href="#38286043">next</a><span>|</span><label class="collapse" for="c-38286021">[-]</label><label class="expand" for="c-38286021">[3 more]</label></div><br/><div class="children"><div class="content">What about `else if`? Not a fan?</div><br/><div id="38286333" class="c"><input type="checkbox" id="c-38286333" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38286021">parent</a><span>|</span><a href="#38286127">next</a><span>|</span><label class="collapse" for="c-38286333">[-]</label><label class="expand" for="c-38286333">[1 more]</label></div><br/><div class="children"><div class="content">Personally I only either use if statements that wrap a single line of logic, or a switch&#x2F;case statement where each branch is a single line of logic.<p>Most situations are handled by guard clauses, exhaustive type switching, or switching on logical cases. <i>Very</i> occasionally do I have to break this practice for a legitimate reason, but this keeps functions simple to read and to reason about.<p>I occasionally am unable to avoid an else, but I will always avoid else if. It puts too much reliance on remembering how this condition interacts with the one on the if statement above it, which can often be many lines away. Iâd infinitely rather use a case statement where all the alternatives are in an easily-understood table with every condition aligned on successive lines.</div><br/></div></div><div id="38286127" class="c"><input type="checkbox" id="c-38286127" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38286021">parent</a><span>|</span><a href="#38286333">prev</a><span>|</span><a href="#38286043">next</a><span>|</span><label class="collapse" for="c-38286127">[-]</label><label class="expand" for="c-38286127">[1 more]</label></div><br/><div class="children"><div class="content">Occasional vice for me.</div><br/></div></div></div></div></div></div><div id="38286043" class="c"><input type="checkbox" id="c-38286043" checked=""/><div class="controls bullet"><span class="by">softfalcon</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38285410">prev</a><span>|</span><a href="#38286293">next</a><span>|</span><label class="collapse" for="c-38286043">[-]</label><label class="expand" for="c-38286043">[1 more]</label></div><br/><div class="children"><div class="content">TIL: another word for &quot;guard clauses&quot; is &quot;sad if&#x27;s&quot;.</div><br/></div></div><div id="38286293" class="c"><input type="checkbox" id="c-38286293" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38286043">prev</a><span>|</span><a href="#38285689">next</a><span>|</span><label class="collapse" for="c-38286293">[-]</label><label class="expand" for="c-38286293">[1 more]</label></div><br/><div class="children"><div class="content">The author called out the newtype solution specifically in the first paragraph:<p>&gt; it could push the task of precondition checking to its caller, and <i>enforce via types</i> (or an assert) that the precondition holds<p>(Emphasis mine)</div><br/></div></div><div id="38285689" class="c"><input type="checkbox" id="c-38285689" checked=""/><div class="controls bullet"><span class="by">blandflakes</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38286293">prev</a><span>|</span><a href="#38286336">next</a><span>|</span><label class="collapse" for="c-38285689">[-]</label><label class="expand" for="c-38285689">[3 more]</label></div><br/><div class="children"><div class="content">I at first had the opposite reaction, which is that I spend a ton of time fighting inverted ifs! But my reaction is not incompatible with yours. It&#x27;s not, but it is related: I HATE reading:<p>if (!someCondition) {
  &#x2F;&#x2F; short amount of code
} else {
  &#x2F;&#x2F; longer happy path
}<p>The contextual overhead of having to invert a negative (i.e. !!someCondition) is just annoying.<p>I do agree that if (happy) { &#x2F;* tons of code <i>&#x2F; } else { &#x2F;</i> I forgot how we got here *&#x2F; } can also be an issue.</div><br/><div id="38285765" class="c"><input type="checkbox" id="c-38285765" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38285689">parent</a><span>|</span><a href="#38286336">next</a><span>|</span><label class="collapse" for="c-38285765">[-]</label><label class="expand" for="c-38285765">[2 more]</label></div><br/><div class="children"><div class="content">The key to the idea above is that you don&#x27;t have any &quot;else&quot; clause.  It&#x27;s an early return, raise an exception, or modify the data so it&#x27;s no longer bad.</div><br/><div id="38285796" class="c"><input type="checkbox" id="c-38285796" checked=""/><div class="controls bullet"><span class="by">blandflakes</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38285765">parent</a><span>|</span><a href="#38286336">next</a><span>|</span><label class="collapse" for="c-38285796">[-]</label><label class="expand" for="c-38285796">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s why I said I realized they weren&#x27;t quite the same situation, while adding another example of a situation where people create hard to follow structures.</div><br/></div></div></div></div></div></div><div id="38286336" class="c"><input type="checkbox" id="c-38286336" checked=""/><div class="controls bullet"><span class="by">slowmovintarget</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38285689">prev</a><span>|</span><a href="#38285443">next</a><span>|</span><label class="collapse" for="c-38286336">[-]</label><label class="expand" for="c-38286336">[1 more]</label></div><br/><div class="children"><div class="content">I recall avoiding multiple method exits (in Java) like the plague. They were hell to get through in a debugging session. But I guess we don&#x27;t use debuggers much any more.<p>When I began writing C# I recall my other team members &quot;refactoring&quot; my code to be shot through with multiple exits instead of a my collecting variable, because &quot;it looked nicer.&quot; When they asked me why I wrote it the way I did, I mentioned the Java debugger thing, and they kind of looked at me blankly and said, &quot;Huh, never thought of that.&quot;<p>Times change.</div><br/></div></div><div id="38285443" class="c"><input type="checkbox" id="c-38285443" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#38284630">root</a><span>|</span><a href="#38284771">parent</a><span>|</span><a href="#38286336">prev</a><span>|</span><a href="#38286922">next</a><span>|</span><label class="collapse" for="c-38285443">[-]</label><label class="expand" for="c-38285443">[1 more]</label></div><br/><div class="children"><div class="content">I usually move this up in an ETL process into a function I usually call &quot;Pre_Flight_Checklist.&quot;  Over the years this has gotten its own helper functions.  For example, if I am going to use a file, I have function that not only checks for the existence of the file, but that it <i>is</i> a file.  This function can also be fed an expected size range and date if &quot;freshness&quot; is expected.  If something is out of whack, an error message will mention that a file was expected at &#x2F;Adirectory&#x2F;Bdirectory&#x2F;Cdirectory&#x2F;filename.ext, but only &#x2F;Adirectory&#x2F;Bdirectory was found, nothing under it.  I believe in overly-explanatory error messages.<p>Now, I <i>do</i> run the risk of having things change out from under me, but putting all of the defensiveness up front allows the happy path and some alternatives to be more succinct in the code.<p>I keep finding new things to be paranoid about, though!</div><br/></div></div></div></div><div id="38286922" class="c"><input type="checkbox" id="c-38286922" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#38284630">parent</a><span>|</span><a href="#38284771">prev</a><span>|</span><a href="#38286594">next</a><span>|</span><label class="collapse" for="c-38286922">[-]</label><label class="expand" for="c-38286922">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As an example I work with - Clojure. Sometimes I use agents. I don&#x27;t write functions for agents, I write functions for things agents might contain.<p>I&#x27;m not following you. Do you have a better example?</div><br/></div></div><div id="38286594" class="c"><input type="checkbox" id="c-38286594" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#38284630">parent</a><span>|</span><a href="#38286922">prev</a><span>|</span><a href="#38287140">next</a><span>|</span><label class="collapse" for="c-38286594">[-]</label><label class="expand" for="c-38286594">[1 more]</label></div><br/><div class="children"><div class="content">Correct me if I am misunderstanding, you are saying the first example would be better if it was `walrus.frobnicate()`? Isn&#x27;t that a syntax preference more than an issue with the point the author is trying to make?</div><br/></div></div></div></div><div id="38287140" class="c"><input type="checkbox" id="c-38287140" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#38284630">prev</a><span>|</span><a href="#38283536">next</a><span>|</span><label class="collapse" for="c-38287140">[-]</label><label class="expand" for="c-38287140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If thereâs an if condition inside a function, consider if it could be moved to the caller instead<p>Haha, it is important to have logic where it is relevant. If performance is more relevant than semantics or maintainability do that. In all other cases favor locality, filter early and fscking kiss. Why is this news?</div><br/></div></div><div id="38283536" class="c"><input type="checkbox" id="c-38283536" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38287140">prev</a><span>|</span><a href="#38286654">next</a><span>|</span><label class="collapse" for="c-38283536">[-]</label><label class="expand" for="c-38283536">[7 more]</label></div><br/><div class="children"><div class="content">Pushing &quot;ifs&quot; up has the downside that the preconditions and postconditions are no longer directly visible in the definition of a function, and must then be checked at each call site. In bigger projects with multiple contributors, such functions could end up getting reused outside their intended context. The result is bugs.<p>One solution is some kind of contract framework, but then you end up rewriting the conditions twice, once in the contract and once in the code. The same is true with dependent types.<p>One idea I haven&#x27;t seen before is the idea of tagging regions of code as being part of some particular context, and defining functions that can only be called from that context.<p>Hypothetically in Python you could write:<p><pre><code>  @requires_context(&quot;VALIDATED_XY&quot;)
  def do_something(x, y):
      ...

  @contextmanager
  def validated_xy(x, y):
      if abs(x) &lt; 1 and abs(y) &lt; 1:
          with context(&quot;VALIDATED_XY&quot;):
              yield x, y
      else:
          raise ValueError(&quot;out of bounds&quot;)

 with validated_xy(0.5, 0.5) as x_safe, y_safe:
      do_something(x_safe, y_safe)

  # Error!
  do_something(0.5, 0.5)
</code></pre>
The language runtime has no knowledge of what the context actually means, but with appropriate tools (and testing), we could design our programs to only establish the desired context when a certain condition is met.<p>You could enforce this at the type level in a language like Haskell using something like the identity monad.<p>But even if it&#x27;s not enforced at the type level, it could be an interesting way to protect &quot;unsafe&quot; regions of code.</div><br/><div id="38283755" class="c"><input type="checkbox" id="c-38283755" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#38283536">parent</a><span>|</span><a href="#38284192">next</a><span>|</span><label class="collapse" for="c-38283755">[-]</label><label class="expand" for="c-38283755">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Pushing &quot;ifs&quot; up has the downside that the preconditions and postconditions are no longer directly visible in the definition of a function<p>You&#x27;re missing the second part of the author&#x27;s argument:<p>&quot;or it could push the task of precondition checking to its caller, <i>and enforce via types</i>&quot;<p>The precondition is therefore still directly visible in the function definition - just as part of the type signature rather than in an if statement.<p>The &quot;enforce preconditions via types&quot; is a common pattern in Rust (the language used in the article), and unlike checking with if statements, it&#x27;s a strict precondition that is checked at compile time rather than at runtime and you won&#x27;t even be able to compile your program if you don&#x27;t meet the pre-condition.</div><br/><div id="38285824" class="c"><input type="checkbox" id="c-38285824" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38283536">root</a><span>|</span><a href="#38283755">parent</a><span>|</span><a href="#38284192">next</a><span>|</span><label class="collapse" for="c-38285824">[-]</label><label class="expand" for="c-38285824">[1 more]</label></div><br/><div class="children"><div class="content">Definitely, that&#x27;s a pattern in many programming languages (including, increasingly, in Python). And in dependently-typed languages, you actually can obtain a proof of validity that gets erased at runtime, leaving nothing but basic unboxed data to be executed.<p>However that&#x27;s not always an option in all languages or situations, and it&#x27;s hard to encode conditions like &quot;must only be called while an event loop is running&quot; that way.<p>I&#x27;m envisioning this partly as kind of a catch-all&#x2F;fallback mechanism that can either be bolted on a language that doesn&#x27;t have these kinds of features. But it&#x27;s not always the case that you can effectively communicate contextual requirements through the types of function parameters, and this would cover that case as well.<p>If you want to reduce this to anything, it&#x27;s a workaround for not having monads in your language, with some tradeoffs around composability and dynamic extent.</div><br/></div></div></div></div><div id="38284192" class="c"><input type="checkbox" id="c-38284192" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#38283536">parent</a><span>|</span><a href="#38283755">prev</a><span>|</span><a href="#38283754">next</a><span>|</span><label class="collapse" for="c-38284192">[-]</label><label class="expand" for="c-38284192">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the intention of public vs private supposed to cover the &quot;tagging of code for a particular context&quot;?<p>Or maybe we need more specific semantics around this that can cross cut the domain that public and private (and protected in .NET ecosystems) cover?</div><br/><div id="38285812" class="c"><input type="checkbox" id="c-38285812" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38283536">root</a><span>|</span><a href="#38284192">parent</a><span>|</span><a href="#38283754">next</a><span>|</span><label class="collapse" for="c-38285812">[-]</label><label class="expand" for="c-38285812">[1 more]</label></div><br/><div class="children"><div class="content">Sure, this could definitely be a generalization of &quot;public&quot; and &quot;private&quot;.</div><br/></div></div></div></div><div id="38283754" class="c"><input type="checkbox" id="c-38283754" checked=""/><div class="controls bullet"><span class="by">timeon</span><span>|</span><a href="#38283536">parent</a><span>|</span><a href="#38284192">prev</a><span>|</span><a href="#38283957">next</a><span>|</span><label class="collapse" for="c-38283754">[-]</label><label class="expand" for="c-38283754">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In bigger projects with multiple contributors, such functions could end up getting reused outside their intended context. The result is bugs.<p>Yes but in this particular example `fn frobnicate(walrus: Walrus)` if you pass here anything other then owned Walrus then program would not compile. Even if it was something generic passing the arg would have to satisfy trait bounds. Definition of those bounds in function definition would be required by compiler based on how the argument will be used inside function.</div><br/></div></div><div id="38283957" class="c"><input type="checkbox" id="c-38283957" checked=""/><div class="controls bullet"><span class="by">tengbretson</span><span>|</span><a href="#38283536">parent</a><span>|</span><a href="#38283754">prev</a><span>|</span><a href="#38286654">next</a><span>|</span><label class="collapse" for="c-38283957">[-]</label><label class="expand" for="c-38283957">[1 more]</label></div><br/><div class="children"><div class="content">Branded types in typescript are an interesting way to do this.</div><br/></div></div></div></div><div id="38286654" class="c"><input type="checkbox" id="c-38286654" checked=""/><div class="controls bullet"><span class="by">vjk800</span><span>|</span><a href="#38283536">prev</a><span>|</span><a href="#38283573">next</a><span>|</span><label class="collapse" for="c-38286654">[-]</label><label class="expand" for="c-38286654">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised by how often programmers coming from software engineering background do this wrong. I started programming in science and there it&#x27;s absolutely necessary to think about this stuff. Doing for loops in a wrong order can be the difference between running your simulation in one hour instead of one week.<p>With this background, I instinctively do small-time optimization to all my codes by ordering for&#x27;s and if&#x27;s appropriately. Code that doesn&#x27;t do this right just <i>looks</i> wrong to me.</div><br/><div id="38286720" class="c"><input type="checkbox" id="c-38286720" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38286654">parent</a><span>|</span><a href="#38283573">next</a><span>|</span><label class="collapse" for="c-38286720">[-]</label><label class="expand" for="c-38286720">[1 more]</label></div><br/><div class="children"><div class="content">Watch out for a visit from the premature optimisation police!</div><br/></div></div></div></div><div id="38283573" class="c"><input type="checkbox" id="c-38283573" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#38286654">prev</a><span>|</span><a href="#38284824">next</a><span>|</span><label class="collapse" for="c-38283573">[-]</label><label class="expand" for="c-38283573">[7 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t quite say this is <i>bad</i> advice, but it isn&#x27;t necessarily good advice either.<p>I think it&#x27;s somewhat telling that the chosen language is Rust. The strong type system prevents a lot of defensive programming required in other languages. A C programmer who doesn&#x27;t check the validity of pointers passed to functions and subsequently causes a NULL dereference is not a C programmer I want on my team. So at least some `if`s should definitely be down (preferably in a way where errors bubble up well).<p>I feel less strongly about `for`s, but the fact that array arguments decay to pointers in C also makes me think that iteration should be up, not down. I can reliably know the length of an array in its originating function, but not in a function to which I pass it as an argument.</div><br/><div id="38284241" class="c"><input type="checkbox" id="c-38284241" checked=""/><div class="controls bullet"><span class="by">lytigas</span><span>|</span><a href="#38283573">parent</a><span>|</span><a href="#38286477">next</a><span>|</span><label class="collapse" for="c-38284241">[-]</label><label class="expand" for="c-38284241">[5 more]</label></div><br/><div class="children"><div class="content">&gt; A C programmer who doesn&#x27;t check the validity of pointers passed to functions and subsequently causes a NULL dereference is not a C programmer I want on my team.<p>I disagree. Interfaces in C need to carefully document their expectations and do exactly that amount of checking, not more. Documentation should replace a strong type system, not runtime checks. Code filled with NULL checks and other defensive maneuvers is far less readable. You could argue for more defensive checking at a library boundary, and this is exactly what the article pushes for: push these checks up.<p>Security-critical code may be different, but in most cases an accidental NULL dereference is fine and will be caught by tests, sanitizers, or fuzzing.</div><br/><div id="38284641" class="c"><input type="checkbox" id="c-38284641" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38283573">root</a><span>|</span><a href="#38284241">parent</a><span>|</span><a href="#38286477">next</a><span>|</span><label class="collapse" for="c-38284641">[-]</label><label class="expand" for="c-38284641">[4 more]</label></div><br/><div class="children"><div class="content">I agree with that.  If a function &quot;can&#x27;t&quot; be called with a null pointer, but is, that&#x27;s a very interesting bug that should expose itself as quickly as possible.  It is likely hiding a different and more difficult to detect bug.<p>Checking for null in every function is a pattern you get into when the codebase violates so many internal invariants so regularly that it can&#x27;t function without the null checks.  But this is hiding careless design and implementation, which is going to be an even bigger problem to grapple with than random crashes as the codebase evolves.<p>Ultimately, if your problem today is that your program crashes, your problem tomorrow will be that it returns incorrect results.  What&#x27;s easier for your monitoring system to detect, a crashed program, or days of returning the wrong answer 1% of the time?  The latter is really scary, depending on the program is supposed to do.  Charge the wrong credit card, grant access when something should be private, etc.  Those have much worse consequences than downtime.  (Of course, crashing on user data is a denial of service attack, so you can&#x27;t really do either.  To really win the programming game, you have to return correct results AND not crash all the time.)</div><br/><div id="38284945" class="c"><input type="checkbox" id="c-38284945" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#38283573">root</a><span>|</span><a href="#38284641">parent</a><span>|</span><a href="#38286477">next</a><span>|</span><label class="collapse" for="c-38284945">[-]</label><label class="expand" for="c-38284945">[3 more]</label></div><br/><div class="children"><div class="content">Yeah but, not checking for null in C can cause undefined behavior. One possible outcome of undefined behavior is that your program doesn&#x27;t even crash, but rather continues running in a weird state. So such a bug doesn&#x27;t always &quot;expose itself&quot;.<p>If we accept that bugs are inevitable, and that accidentally passing a null pointer to a function is a possible bug, then we also conclude that your code really should include non-null assertions that intentionally abort() the program. (Which run in debug&#x2F;staging mode but can be disabled in release&#x2F;production mode.)</div><br/><div id="38285289" class="c"><input type="checkbox" id="c-38285289" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38283573">root</a><span>|</span><a href="#38284945">parent</a><span>|</span><a href="#38285200">next</a><span>|</span><label class="collapse" for="c-38285289">[-]</label><label class="expand" for="c-38285289">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, Rust&#x27;s own standard library uses this method. There are lots of public-facing unsafe functions that can result in undefined behavior if called incorrectly. But if the standard library is compiled in debug mode (which currently requires the unstable flag -Zbuild-std), then it will activate assertions on many of these unsafe functions, so that they will print a message and abort the program if they detect invalid input.</div><br/></div></div><div id="38285200" class="c"><input type="checkbox" id="c-38285200" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38283573">root</a><span>|</span><a href="#38284945">parent</a><span>|</span><a href="#38285289">prev</a><span>|</span><a href="#38286477">next</a><span>|</span><label class="collapse" for="c-38285200">[-]</label><label class="expand" for="c-38285200">[1 more]</label></div><br/><div class="children"><div class="content">Very good point.  For C, I like the idea of sticking an assertion in there.</div><br/></div></div></div></div></div></div></div></div><div id="38286477" class="c"><input type="checkbox" id="c-38286477" checked=""/><div class="controls bullet"><span class="by">branko_d</span><span>|</span><a href="#38283573">parent</a><span>|</span><a href="#38284241">prev</a><span>|</span><a href="#38284824">next</a><span>|</span><label class="collapse" for="c-38286477">[-]</label><label class="expand" for="c-38286477">[1 more]</label></div><br/><div class="children"><div class="content">My rule of thumb is: if the type system doesn&#x27;t prevent an invalid value, it&#x27;s your responsibility to prevent it at run-time.<p>I&#x27;ve been writing a lot of T-SQL lately, which doesn&#x27;t let you declare a parameter or variable as NOT NULL. So it&#x27;s a good idea to check for NULLs as early as reasonable - usually at the top of the stored procedure (for parameters). Otherwise, a NULL might propagate unexpectedly deep into the call hierarchy and cause less-than-obvious problems.<p>Fortunately, the data in the table can be declared as NOT NULL, so these kinds of bugs will usually not corrupt the data, but catching them as early as possible makes life easier. However, if there is piece of logic that writes something to the database depending on the value of some parameter, and that parameter is unexpectedly NULL, that might lead to a wrong thing being written, or a necessary thing not being written at all, effectively corrupting the data.<p>So, defensive programming all the way, baby!</div><br/></div></div></div></div><div id="38284824" class="c"><input type="checkbox" id="c-38284824" checked=""/><div class="controls bullet"><span class="by">jasonjmcghee</span><span>|</span><a href="#38283573">prev</a><span>|</span><a href="#38286766">next</a><span>|</span><label class="collapse" for="c-38284824">[-]</label><label class="expand" for="c-38284824">[2 more]</label></div><br/><div class="children"><div class="content">I really thought the whole article was building up to a code example like<p><pre><code>  [fwalrus, twalrus] = split(walrus, condition)
  frobnicate_batch(fwalrus)
  transmogrify_batch(twalrus)
</code></pre>
And instead went for<p><pre><code>  if condition {
    for walrus in walruses {
      walrus.frobnicate()
    }
  } else {
    for walrus in walruses {
      walrus.transmogrify()
    }
  }</code></pre></div><br/><div id="38286584" class="c"><input type="checkbox" id="c-38286584" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38284824">parent</a><span>|</span><a href="#38286766">next</a><span>|</span><label class="collapse" for="c-38286584">[-]</label><label class="expand" for="c-38286584">[1 more]</label></div><br/><div class="children"><div class="content">Sort the data! Sort it! [1]<p>[1]: <a href="https:&#x2F;&#x2F;macton.smugmug.com&#x2F;Other&#x2F;2008-07-15-by-Eye-Fi&#x2F;n-xmKDH&#x2F;i-BRtRt6W&#x2F;A" rel="nofollow noreferrer">https:&#x2F;&#x2F;macton.smugmug.com&#x2F;Other&#x2F;2008-07-15-by-Eye-Fi&#x2F;n-xmKD...</a></div><br/></div></div></div></div><div id="38286766" class="c"><input type="checkbox" id="c-38286766" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38284824">prev</a><span>|</span><a href="#38283666">next</a><span>|</span><label class="collapse" for="c-38286766">[-]</label><label class="expand" for="c-38286766">[1 more]</label></div><br/><div class="children"><div class="content">The pushing-ifs-up assumes you are using a language where objects aren&#x27;t nullable. This doesn&#x27;t apply to most languages. Otherwise we would just get a potential null pointer exception when we don&#x27;t check for null inside the function.</div><br/></div></div><div id="38283666" class="c"><input type="checkbox" id="c-38283666" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#38286766">prev</a><span>|</span><a href="#38283568">next</a><span>|</span><label class="collapse" for="c-38283666">[-]</label><label class="expand" for="c-38283666">[3 more]</label></div><br/><div class="children"><div class="content">Without a proper context, this is fairly strange, and possibly even bad advice.<p>For loops and if statements are both control flow operations, so some of the arguments in the article make little sense.  The strongest argument seems to be about performance, but that should typically be one of the latest concerns, especially for rule-of-thumb advice.<p>Unfortunately, the author has managed to create a catchphrase out of it.  Let&#x27;s hope that doesn&#x27;t catch on.</div><br/><div id="38286328" class="c"><input type="checkbox" id="c-38286328" checked=""/><div class="controls bullet"><span class="by">koonsolo</span><span>|</span><a href="#38283666">parent</a><span>|</span><a href="#38283730">next</a><span>|</span><label class="collapse" for="c-38286328">[-]</label><label class="expand" for="c-38286328">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unfortunately, the author has managed to create a catchphrase out of it. Let&#x27;s hope that doesn&#x27;t catch on.<p>In you next pull request: &quot;Hey can you push this if up?&quot; :D.</div><br/></div></div><div id="38283730" class="c"><input type="checkbox" id="c-38283730" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#38283666">parent</a><span>|</span><a href="#38286328">prev</a><span>|</span><a href="#38283568">next</a><span>|</span><label class="collapse" for="c-38283730">[-]</label><label class="expand" for="c-38283730">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    try
        letâs hope
    catch
        not on</code></pre></div><br/></div></div></div></div><div id="38283568" class="c"><input type="checkbox" id="c-38283568" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#38283666">prev</a><span>|</span><a href="#38283628">next</a><span>|</span><label class="collapse" for="c-38283568">[-]</label><label class="expand" for="c-38283568">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced that such general rules can really apply to real-world code. I often see this kind of rules as ill-placed dogmas, because sadly even if this particular blog post start by saying these are <i>rule of thumbs</i> they&#x27;re not always taken this way by young programmers. A few weeks ago YouTube was constantly pushing to me a video called &quot;I&#x27;m a <i>never</i>-nester&quot; apparently of someone arguing that one should <i>never</i> nest ifs, which is, well, kind of ridiculous. Anyway, back at the specific advice from this post, for example, take this code from the article:<p><pre><code>    &#x2F;&#x2F; GOOD
    if condition {
      for walrus in walruses {
        walrus.frobnicate()
      }
    } else {
      for walrus in walruses {
        walrus.transmogrify()
      }
    }
    
    &#x2F;&#x2F; BAD
    for walrus in walruses {
      if condition {
        walrus.frobnicate()
      } else {
        walrus.transmogrify()
      }
    }
</code></pre>
In most cases where code is written in the &quot;BAD&quot;-labeled way, the `condition` part will depend on `walrus` and thus the `if` cannot actually be pushed up because if it can then it is quite obvious to anyone that you will be re-evaluating the same expression â the condition â over and over in the loop, and programmers have a natural tendency to avoid that. But junior programmers or students reading dogmatic-like wise-sounding rules may produce worse code to strictly follow these kind of advices.</div><br/><div id="38284071" class="c"><input type="checkbox" id="c-38284071" checked=""/><div class="controls bullet"><span class="by">ToValueFunfetti</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38285324">next</a><span>|</span><label class="collapse" for="c-38284071">[-]</label><label class="expand" for="c-38284071">[7 more]</label></div><br/><div class="children"><div class="content">Re: &#x27;never-nesting&#x27;, I&#x27;m not especially dogmatic, but I&#x27;ve never empirically seen a situation where this:<p><pre><code>  match (condition_a, condition_b){
   (true, true) =&gt; fn_a()
   (true, false) =&gt; fn_b()
   (false, true) =&gt; fn_c()
   (false, false) =&gt; fn_d()
  }
</code></pre>
isn&#x27;t preferable to this:<p><pre><code>  if condition_a {
     if condition_b {
       fn_a()
     } else {
       fn_b()
     }
  else if condition_b {
     fn_c()
  } else {
     fn_d()
  }
   </code></pre>
(Assuming the syntax is available)</div><br/><div id="38284681" class="c"><input type="checkbox" id="c-38284681" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38284071">parent</a><span>|</span><a href="#38284340">next</a><span>|</span><label class="collapse" for="c-38284681">[-]</label><label class="expand" for="c-38284681">[1 more]</label></div><br/><div class="children"><div class="content">I really prefer the flat variant cause it helps me ensure exhaustiveness. In the end people probably trained their brain to read the nested variant to the point it&#x27;s transparent to their neurons.</div><br/></div></div><div id="38284340" class="c"><input type="checkbox" id="c-38284340" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38284071">parent</a><span>|</span><a href="#38284681">prev</a><span>|</span><a href="#38284599">next</a><span>|</span><label class="collapse" for="c-38284340">[-]</label><label class="expand" for="c-38284340">[2 more]</label></div><br/><div class="children"><div class="content">I think the lines gets blurred when doing early exits and guard conditions.<p>For instance<p><pre><code>  if !condition_a &amp;&amp; !conditon_b {
    return fn_d() &#x2F;&#x2F; probably an error condition ?
  }

  if condition_a &amp;&amp; condition_b {
    return fn_a()
  }

  if condition_a {
   fn_b()
  } else {
   fn_c()
  }</code></pre></div><br/><div id="38284777" class="c"><input type="checkbox" id="c-38284777" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38284340">parent</a><span>|</span><a href="#38284599">next</a><span>|</span><label class="collapse" for="c-38284777">[-]</label><label class="expand" for="c-38284777">[1 more]</label></div><br/><div class="children"><div class="content">These 3 examples optimize to the the same thing because they generate identical instructions:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;a1Yq9rceE" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;a1Yq9rceE</a><p>Note: Inverting and rearranging conditions changes what LLVM decides to output, sometimes for the worse. --opt-level=s is counterproductive here.</div><br/></div></div></div></div><div id="38284599" class="c"><input type="checkbox" id="c-38284599" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38284071">parent</a><span>|</span><a href="#38284340">prev</a><span>|</span><a href="#38285250">next</a><span>|</span><label class="collapse" for="c-38284599">[-]</label><label class="expand" for="c-38284599">[1 more]</label></div><br/><div class="children"><div class="content">I think I would like the former syntax. Witness one of the several nested matching situations I run into:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;titzer&#x2F;wizard-engine&#x2F;blob&#x2F;master&#x2F;src&#x2F;engine&#x2F;Type.v3#L272">https:&#x2F;&#x2F;github.com&#x2F;titzer&#x2F;wizard-engine&#x2F;blob&#x2F;master&#x2F;src&#x2F;engi...</a><p>This would be much, much better if Virgil had pattern matching on tuples of ADTs.</div><br/></div></div><div id="38285250" class="c"><input type="checkbox" id="c-38285250" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38284071">parent</a><span>|</span><a href="#38284599">prev</a><span>|</span><a href="#38285324">next</a><span>|</span><label class="collapse" for="c-38285250">[-]</label><label class="expand" for="c-38285250">[2 more]</label></div><br/><div class="children"><div class="content">Oh no, hard disagree. The match implementation is far easier to reason about. I can see at a glance that if both condition_a and condition_b are true, call fn_a(). For the nested if version I have to trace each expression by hand.</div><br/><div id="38285790" class="c"><input type="checkbox" id="c-38285790" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38285250">parent</a><span>|</span><a href="#38285324">next</a><span>|</span><label class="collapse" for="c-38285790">[-]</label><label class="expand" for="c-38285790">[1 more]</label></div><br/><div class="children"><div class="content">They said &quot;isn&#x27;t&quot;, not &quot;is&quot;.  Double negative.  You two agree.</div><br/></div></div></div></div></div></div><div id="38285324" class="c"><input type="checkbox" id="c-38285324" checked=""/><div class="controls bullet"><span class="by">tacitusarc</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38284071">prev</a><span>|</span><a href="#38283771">next</a><span>|</span><label class="collapse" for="c-38285324">[-]</label><label class="expand" for="c-38285324">[2 more]</label></div><br/><div class="children"><div class="content">I think this is actually a great example of why `if` should be &quot;pushed up.&quot; The objective of the code is to perform an particular operation on the walrus, given a condition. The is actually ifs being instead of polymorphism and a type system. Why does the walrus have these two functions, which must be called in different scenarios? Why not have a single function, and two types, and the correct type is passed in? Even given the current structure, we could accomplish this:<p><pre><code>    &#x2F;&#x2F; There are better ways to accomplish this, depending on the language
    func frobnicate(walrus) {
        return walrus.frobnicate();
    }

    func transmogrify(walrus) {
        return walrus.transmogrify();
    }

    &#x2F;&#x2F; Somewhere high in the code
    if condition {
        processing_function = frobnicate
    } else {
        processing_function = transmogrify
    }


    &#x2F;&#x2F; Somewhere else in the code
    for walrus in walruses {
        processing_function()
    }
</code></pre>
If the decisions are made as early as possible, they do not need to be littered throughout the code. The guts of the code can run without branches, performing the same operations every time, the output only modified through the construction graph.<p>Of course, this is not a new idea: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4F72VULWFvc">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4F72VULWFvc</a><p>It was old 15 years ago.</div><br/><div id="38285496" class="c"><input type="checkbox" id="c-38285496" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#38283568">root</a><span>|</span><a href="#38285324">parent</a><span>|</span><a href="#38283771">next</a><span>|</span><label class="collapse" for="c-38285496">[-]</label><label class="expand" for="c-38285496">[1 more]</label></div><br/><div class="children"><div class="content">That pattern is not zero-cost: It breaks inlining and other compile-time optimizations.  It also can hurt maintainability and readability.  If the type of processing_function() is significantly generic, figuring out what is being called in the loop can be hard (as in undecidable; it is equivalent to the halting problem).<p>In an extreme case that I&#x27;ve seen in real code, processing_function() is called send(t: Object) -&gt; Object or recv(u: Object), and all non-trivial control flow in the system is laundered through those two function names.<p>So, you have 100&#x27;s or 1000&#x27;s of send, recv pairs, and grep (or even a fancy IDE) can&#x27;t match them up.</div><br/></div></div></div></div><div id="38283771" class="c"><input type="checkbox" id="c-38283771" checked=""/><div class="controls bullet"><span class="by">gsuuon</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38285324">prev</a><span>|</span><a href="#38285560">next</a><span>|</span><label class="collapse" for="c-38283771">[-]</label><label class="expand" for="c-38283771">[1 more]</label></div><br/><div class="children"><div class="content">The GOOD refactor would only work if the condition didn&#x27;t depend on `walrus` and helps to make that fact explicit. If you apply &quot;push fors down&quot; again you end up with:<p><pre><code>  if condition {
    frobnicate_batch(walruses)
  } else {
    transmogrify_batch(walruses)
  }</code></pre></div><br/></div></div><div id="38285560" class="c"><input type="checkbox" id="c-38285560" checked=""/><div class="controls bullet"><span class="by">swsieber</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38283771">prev</a><span>|</span><a href="#38285638">next</a><span>|</span><label class="collapse" for="c-38285560">[-]</label><label class="expand" for="c-38285560">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But junior programmers or students reading dogmatic-like wise-sounding rules may produce worse code to strictly follow these kind of advices.<p>Yes.<p>I for one am happy such articles exist. Thus one articulated something I&#x27;ve run into quite a few times without being able to fully articulate the issues. It seems like a nice mental model to have in my back pocket.<p>That said, I appreciate comments like your because I hope the dogmatic junior dev comes across it and hopefully becomes a little more nuanced.</div><br/></div></div><div id="38285638" class="c"><input type="checkbox" id="c-38285638" checked=""/><div class="controls bullet"><span class="by">tenahu</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38285560">prev</a><span>|</span><a href="#38284381">next</a><span>|</span><label class="collapse" for="c-38285638">[-]</label><label class="expand" for="c-38285638">[1 more]</label></div><br/><div class="children"><div class="content">That was my same thought. This example would only work in specific circumstances, so why present it as a rule,</div><br/></div></div><div id="38284381" class="c"><input type="checkbox" id="c-38284381" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38285638">prev</a><span>|</span><a href="#38285209">next</a><span>|</span><label class="collapse" for="c-38284381">[-]</label><label class="expand" for="c-38284381">[1 more]</label></div><br/><div class="children"><div class="content">&gt; saying these are rule of thumbs they&#x27;re not always taken this way by young programmers.<p>The important thing to learn about all ârules of thumbâ and âbest practicesâ is the WHY behind them. Programmers especially should not copy&#x2F;paste these things and apply them by rote.<p>RoT and BP blindly applied may well not be a good idea. As with everything âit dependsâ.</div><br/></div></div><div id="38285209" class="c"><input type="checkbox" id="c-38285209" checked=""/><div class="controls bullet"><span class="by">keithnz</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38284381">prev</a><span>|</span><a href="#38283655">next</a><span>|</span><label class="collapse" for="c-38285209">[-]</label><label class="expand" for="c-38285209">[1 more]</label></div><br/><div class="children"><div class="content">given it looks state mutating, I&#x27;d write this something like<p><pre><code>    walruses.apply(condition ? frobnicate : transmorfify)

</code></pre>
where apply does the looping.</div><br/></div></div><div id="38283655" class="c"><input type="checkbox" id="c-38283655" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#38283568">parent</a><span>|</span><a href="#38285209">prev</a><span>|</span><a href="#38283628">next</a><span>|</span><label class="collapse" for="c-38283655">[-]</label><label class="expand" for="c-38283655">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Also, most of the time, the form that is <i>easier to modify</i> is preferred, and even if `condition` does not <i>currently</i> depend on `walrus`, it is preferable for it to be easy to make it depend on `walrus` in the future.</div><br/></div></div></div></div><div id="38283628" class="c"><input type="checkbox" id="c-38283628" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#38283568">prev</a><span>|</span><a href="#38285190">next</a><span>|</span><label class="collapse" for="c-38283628">[-]</label><label class="expand" for="c-38283628">[4 more]</label></div><br/><div class="children"><div class="content">I wrote some batch (list) oriented code for a static analyzer recently.<p>It was great until I decided to change my AST representation from a tuple+discrimated union to a generic type with a corresponding interface i.e. the interface handled the first member of the tuple (graph data) and the generic type the second member (node data).<p>This solved a bunch of annoying problems with the tuple representation but all list-oriented code broke because the functions operating on a list of generics types couldn&#x27;t play nice with the functions operating on lists of interfaces.<p>I ended up switching to scalar functions pipelined between list functions because the generic type was more convenient to me than the list-oriented code. The reality is you often need to play with all the options until you find the &quot;right&quot; one for your use case, experience level and style.</div><br/><div id="38284162" class="c"><input type="checkbox" id="c-38284162" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#38283628">parent</a><span>|</span><a href="#38285190">next</a><span>|</span><label class="collapse" for="c-38284162">[-]</label><label class="expand" for="c-38284162">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, why couldn&#x27;t the list of generic types play nice with functions operating on lists of interfaces?</div><br/><div id="38286024" class="c"><input type="checkbox" id="c-38286024" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#38283628">root</a><span>|</span><a href="#38284162">parent</a><span>|</span><a href="#38285915">next</a><span>|</span><label class="collapse" for="c-38286024">[-]</label><label class="expand" for="c-38286024">[1 more]</label></div><br/><div class="children"><div class="content">Have a look here:  <a href="https:&#x2F;&#x2F;onecompiler.com&#x2F;fsharp&#x2F;3ztmx2uhr" rel="nofollow noreferrer">https:&#x2F;&#x2F;onecompiler.com&#x2F;fsharp&#x2F;3ztmx2uhr</a><p>Basically we want a &quot;Yes&quot; or a &quot;No&quot; when the family has children:<p><pre><code>    let kidsYN = family |&gt; numberOfChildren |&gt; yesOrNo
</code></pre>
But we get:<p><pre><code>    error FS0001: Type mismatch. Expecting a
      INode list    
    but given a
      Node&lt;Person&gt; list    
    The type &#x27;INode&#x27; does not match the type &#x27;Node&lt;Person&gt;&#x27;
</code></pre>
Forcing us to do:<p><pre><code>    let familyAsINode = family |&gt; List.map (fun n -&gt; n :&gt; INode)
</code></pre>
Sure you can wrap this up in a function but it&#x27;s ugly and annoying to have to use this everywhere and takes away from your logic. It ends up being better to split your &quot;batch&quot; and &quot;scalar&quot; operations and compose them e.g. by introducing a &quot;mapsum&quot; function:<p><pre><code>    let kidsYN2 = family |&gt; mapsum numberOfChildrenV2 |&gt; yesOrNo</code></pre></div><br/></div></div></div></div></div></div><div id="38285190" class="c"><input type="checkbox" id="c-38285190" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38283628">prev</a><span>|</span><a href="#38283780">next</a><span>|</span><label class="collapse" for="c-38285190">[-]</label><label class="expand" for="c-38285190">[8 more]</label></div><br/><div class="children"><div class="content">The idea of hoisting precondition ifs into the caller is terible!  Sure there are special cases where it&#x27;s a good idea (if nothing else it skips a function call) but in the common case you don&#x27;t want to this.<p>In a library you want to check preconditions at the external boundary so the actual implementation can proceed knowing there are no dangling pointers, or negative numbers, or whatever the internal assumptions may be.  Depending on the caller to do the check defeats the purpose.<p>Also in many cases you would need to violate encapsulation&#x2F;abstraction.  Consider a stupid case: `bool cache_this (T obj)`.  Let the cache manager itself check to see if the object is already there as it can probably touch the object fewer times.<p>I agree on the `for` case but it&#x27;s so trivial the article barely talks about it.  Basically it&#x27;s the same as the encapsulation case above.</div><br/><div id="38285388" class="c"><input type="checkbox" id="c-38285388" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38285190">parent</a><span>|</span><a href="#38285376">next</a><span>|</span><label class="collapse" for="c-38285388">[-]</label><label class="expand" for="c-38285388">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In a library you want to check preconditions at the external boundary so the actual implementation can proceed knowing there are no dangling pointers, or negative numbers, or whatever the internal assumptions may be. Depending on the caller to do the check defeats the purpose.<p>I think the idea is to instead address this with a type-safe interface, designed so that the external boundary physically cannot receive invalid input. The caller would then be responsible for its own if statements when constructing the input types from possibly-invalid raw values.<p>&gt; Also in many cases you would need to violate encapsulation&#x2F;abstraction. Consider a stupid case: `bool cache_this (T obj)`. Let the cache manager itself check to see if the object is already there as it can probably touch the object fewer times.<p>I don&#x27;t see the suggestion as encouraging such a thing: the &quot;cache_this&quot; check should only ever be performed when it&#x27;s known for certain that the user wants to access the cached object, so the entry point of the cache abstraction acts as a kind of boundary that the if statement depends on. And the if statement clearly shouldn&#x27;t be pushed above its own dependency.</div><br/><div id="38285438" class="c"><input type="checkbox" id="c-38285438" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#38285190">root</a><span>|</span><a href="#38285388">parent</a><span>|</span><a href="#38285376">next</a><span>|</span><label class="collapse" for="c-38285438">[-]</label><label class="expand" for="c-38285438">[2 more]</label></div><br/><div class="children"><div class="content">In cases where that doesn&#x27;t make sense:<p><pre><code>   let f = Some(get_a_u16());
   foo(f);

   ... 

   func foo(f: u16) -&gt; u16 {
      match f {
          None =&gt; 0,
          Some(f) =&gt; f * 1234
      }
   }
</code></pre>
I&#x27;d expect any reasonable compiler to include enough link time optimization and dead code elimination to compile the whole mess down to a single multiply instruction.</div><br/><div id="38285492" class="c"><input type="checkbox" id="c-38285492" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38285190">root</a><span>|</span><a href="#38285438">parent</a><span>|</span><a href="#38285376">next</a><span>|</span><label class="collapse" for="c-38285492">[-]</label><label class="expand" for="c-38285492">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see what you&#x27;re tying to show with your example? The typical case is, you start with a raw type in the caller (u16), and then you create a derived type (Option&lt;MultipliedU16&gt;) as a result of validation. Also, you&#x27;d ideally want to handle overflow errors in the multiplication, especially with something as small as a u16.<p>(And in case it helps anyone, for a trivial function to be inlined across crates in Rust, either the function must be marked with #[inline], or a special LTO option must be explicitly set in the Cargo profile. So often it&#x27;s a good idea to mark all public trivial utility functions in a crate with #[inline].)</div><br/></div></div></div></div></div></div><div id="38285376" class="c"><input type="checkbox" id="c-38285376" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38285190">parent</a><span>|</span><a href="#38285388">prev</a><span>|</span><a href="#38285571">next</a><span>|</span><label class="collapse" for="c-38285376">[-]</label><label class="expand" for="c-38285376">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a spirit to this. I.e. is it an &quot;if&quot; in spirit.<p>Preconditions are not really branches. They are usually `if (bad) throw;` type of thing. They could be replaced with `assert(!bad);`.<p>A branch would be a function like add_todo_or_calendaritem(is_todo: bool, ...) which would need to branch on is_todo.</div><br/></div></div><div id="38285571" class="c"><input type="checkbox" id="c-38285571" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#38285190">parent</a><span>|</span><a href="#38285376">prev</a><span>|</span><a href="#38285368">next</a><span>|</span><label class="collapse" for="c-38285571">[-]</label><label class="expand" for="c-38285571">[1 more]</label></div><br/><div class="children"><div class="content">A similar example of this is OpenAI&#x27;s API calls which don&#x27;t do response validation when you do function calling. Essentially, validating the response against the given function(s) is left to the user, leading to various implementations that just make the code noisy.<p>As an alternative, OpenAI could just make sure the true function call is run (first, validate that the response is a JSON, then make sure it&#x27;s a valid JSON against the provided JSON schema) in n tries, after which the API raises an error or returns None.</div><br/></div></div></div></div><div id="38283780" class="c"><input type="checkbox" id="c-38283780" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#38285190">prev</a><span>|</span><a href="#38286133">next</a><span>|</span><label class="collapse" for="c-38283780">[-]</label><label class="expand" for="c-38283780">[1 more]</label></div><br/><div class="children"><div class="content">Fors down sounds like a bad advice, and the rationale for it seems to be The Root of all Evil.<p>&quot;Fors up&quot; allows for composition, e.g. map. Fors down makes it clunky at best.</div><br/></div></div><div id="38286133" class="c"><input type="checkbox" id="c-38286133" checked=""/><div class="controls bullet"><span class="by">ilitirit</span><span>|</span><a href="#38283780">prev</a><span>|</span><a href="#38284314">next</a><span>|</span><label class="collapse" for="c-38286133">[-]</label><label class="expand" for="c-38286133">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad many people have identified why &quot;pushing ifs up&quot; is often bad advice. This article should give examples of when and why you should use <i>either</i> approach. Furthermore, I would argue that there&#x27;s far too little information and context presented here to even make a decision like that.What do `frobnicate` and `transmogrify` do? How many callers would need to perform these conditional checks? Do these if statements convey domain logic that should actually belong in the walrus class? If these checks need to be made often, would it make better sense to capture the call as a lambda and then only perform the check once instead of having a conditional for loop? Etc etc.</div><br/></div></div><div id="38284314" class="c"><input type="checkbox" id="c-38284314" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#38286133">prev</a><span>|</span><a href="#38284960">next</a><span>|</span><label class="collapse" for="c-38284314">[-]</label><label class="expand" for="c-38284314">[1 more]</label></div><br/><div class="children"><div class="content">This is kinda &quot;just&quot; predicate push-downs, for imperative code. Makes sense that the author is thinking about it given he is working on databases (tigerbeetle) and part of the motivation is performance.<p>Interesting that we push the ifs up but we push the predicates down! (And a &quot;predicate pushup&quot; sounds like you are adding some randomness to your exercise routine - one, two, skipping this one, four, ...).</div><br/></div></div><div id="38284960" class="c"><input type="checkbox" id="c-38284960" checked=""/><div class="controls bullet"><span class="by">anyonecancode</span><span>|</span><a href="#38284314">prev</a><span>|</span><a href="#38285202">next</a><span>|</span><label class="collapse" for="c-38284960">[-]</label><label class="expand" for="c-38284960">[1 more]</label></div><br/><div class="children"><div class="content">A good example of this I see a lot in a code base I&#x27;m currently working in is React components that conditionally render or not. I really can&#x27;t stand this pattern, and whenever I can I refactor that into having the component ALWAYS render, but have the caller decide whether or not to call the component.</div><br/></div></div><div id="38285202" class="c"><input type="checkbox" id="c-38285202" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#38284960">prev</a><span>|</span><a href="#38285294">next</a><span>|</span><label class="collapse" for="c-38285202">[-]</label><label class="expand" for="c-38285202">[1 more]</label></div><br/><div class="children"><div class="content">A beneficial side effect of this strategy (operating in batches with control logic out of the loop) is that you can also relatively easily distribute the work on many worker threads without touching the interface or the code structure.</div><br/></div></div><div id="38285294" class="c"><input type="checkbox" id="c-38285294" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38285202">prev</a><span>|</span><a href="#38283769">next</a><span>|</span><label class="collapse" for="c-38285294">[-]</label><label class="expand" for="c-38285294">[2 more]</label></div><br/><div class="children"><div class="content">This advice falls flat in case of validations. If a function is given some input and is supposed to work with it, how can it avoid if&#x2F;else and how can we move this logic one level up to the caller to ask the caller to verify every parameter before calling the function?<p>And if we keep pushing (thus pending the decision making) up, wouldn&#x27;t the top most function become a lot more complicated having a lot more logic pushed up from far down below?<p>That&#x27;s bad and impractical advice but now will pollute many pull requests with needless arguments.</div><br/><div id="38285339" class="c"><input type="checkbox" id="c-38285339" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38285294">parent</a><span>|</span><a href="#38283769">next</a><span>|</span><label class="collapse" for="c-38285339">[-]</label><label class="expand" for="c-38285339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a function is given some input and is supposed to work with it, how can it avoid if&#x2F;else and how can we move this logic one level up to the caller to ask the caller to verify every parameter before calling the function?<p>The usual way in idiomatic Rust would be to use type safety for this purpose: have the function accept special types for its input, and provide the caller secondary interfaces to construct these types. The constructors would then be responsible for inspecting and rejecting invalid input. This way, the caller can continue pushing the construction, and thus the if&#x2F;else statements for validation errors, upward to the ultimate source of the possibly-invalid values.<p>(This is also possible in C&#x2F;C++&#x2F;Java&#x2F;C#&#x2F;..., if not so idiomatic.)</div><br/></div></div></div></div><div id="38283769" class="c"><input type="checkbox" id="c-38283769" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38285294">prev</a><span>|</span><a href="#38284719">next</a><span>|</span><label class="collapse" for="c-38283769">[-]</label><label class="expand" for="c-38283769">[1 more]</label></div><br/><div class="children"><div class="content">One variation on this theme is to use subclass or function polymorphism. This lets you decouple (in time) (a) the code that decides what to do based on the condition from (b) the code that actually does what was decided. In TFAâs enum example, instead of the enum values you could pass the foo&#x2F;bar functions around as values (or instances of different subclasses implementing a common interface method as either foo or bar), and the place where the operation finally needs to be performed would invoke the passed-around function (or object). I.e., f() would return foo or bar as a function value, and g() would be passed the function value and simply invoke it instead of doing the `match` case distinction.<p>The drawback is that itâs then less clear in some parts of the code which implementation will be invoked. But the alternative is having to invoke the specific operation (directly or indirectly) immediately when the condition is determined. Itâs a trade-off that depends on the situation.</div><br/></div></div><div id="38285011" class="c"><input type="checkbox" id="c-38285011" checked=""/><div class="controls bullet"><span class="by">theteapot</span><span>|</span><a href="#38284719">prev</a><span>|</span><a href="#38286417">next</a><span>|</span><label class="collapse" for="c-38285011">[-]</label><label class="expand" for="c-38285011">[2 more]</label></div><br/><div class="children"><div class="content">Interesting that dependency inversion principal -- [1] is like an extreme case of pushing ifs up by encoding the if into the type interface implemention. Ultimately what you get with DI is pushing an if up some to ... somewhere.<p><pre><code>  # Somewhere:
  walruses = [new TransWalrus(), new FrobWalarus()], ...]
  ...
  for(walrus in walruses) { 
   walrus.transfrobnicaterify()
  }
</code></pre>
[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_inversion_principle" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_inversion_principle</a></div><br/><div id="38286032" class="c"><input type="checkbox" id="c-38286032" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#38285011">parent</a><span>|</span><a href="#38286417">next</a><span>|</span><label class="collapse" for="c-38286032">[-]</label><label class="expand" for="c-38286032">[1 more]</label></div><br/><div class="children"><div class="content">This only works when `frobnicate` and `transmogrify` have the same argument and return types</div><br/></div></div></div></div><div id="38286417" class="c"><input type="checkbox" id="c-38286417" checked=""/><div class="controls bullet"><span class="by">shanghaikid</span><span>|</span><a href="#38285011">prev</a><span>|</span><a href="#38285063">next</a><span>|</span><label class="collapse" for="c-38286417">[-]</label><label class="expand" for="c-38286417">[1 more]</label></div><br/><div class="children"><div class="content">no one likes &#x27;if&#x2F;else&#x27;,  moving &#x27;if&#x2F;else&#x27; inside&#x2F;outside a function is not a solution, if you are writing business logic or UI logic, we should try to avoid it as much as possible, only except when you are writing complex algorithm which the computational complexity is required.</div><br/></div></div><div id="38285063" class="c"><input type="checkbox" id="c-38285063" checked=""/><div class="controls bullet"><span class="by">bobmaxup</span><span>|</span><a href="#38286417">prev</a><span>|</span><a href="#38285648">next</a><span>|</span><label class="collapse" for="c-38285063">[-]</label><label class="expand" for="c-38285063">[1 more]</label></div><br/><div class="children"><div class="content">As with much programming advice, this is language dependent.<p>You might want branching structures when you have no overloading. You might want guards and other structures when your type checking is dynamic.</div><br/></div></div><div id="38283909" class="c"><input type="checkbox" id="c-38283909" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#38285648">prev</a><span>|</span><a href="#38285953">next</a><span>|</span><label class="collapse" for="c-38283909">[-]</label><label class="expand" for="c-38283909">[2 more]</label></div><br/><div class="children"><div class="content">Contrarily:<p>Push ifs down:<p><pre><code>  BAD:
    if (ptr) delete ptr;
  GOOD:
    delete ptr;
</code></pre>
Polymorphize your fors:<p><pre><code>  frobnicate (walrus);
  frobnicate (walruses) { for walrus in walruses frobnicate (walrus); }</code></pre></div><br/><div id="38285693" class="c"><input type="checkbox" id="c-38285693" checked=""/><div class="controls bullet"><span class="by">BenFrantzDale</span><span>|</span><a href="#38283909">parent</a><span>|</span><a href="#38285953">next</a><span>|</span><label class="collapse" for="c-38285693">[-]</label><label class="expand" for="c-38285693">[1 more]</label></div><br/><div class="children"><div class="content">I agrÃ©e with them and with you. It looks like they work in some poor language that doesnât allow overloading. Their example of `frobnicate`ing an optional being bad made me think: why not both? `void frobnicate(Foo&amp;); void frobnicate(std::optional&lt;Foo&gt;&amp; foo) { if (foo.has_value()) { frobnicate(foo); } }`. Now you can frobnicate `Foo`s and optional ones!</div><br/></div></div></div></div><div id="38285953" class="c"><input type="checkbox" id="c-38285953" checked=""/><div class="controls bullet"><span class="by">dg44768</span><span>|</span><a href="#38283909">prev</a><span>|</span><a href="#38284620">next</a><span>|</span><label class="collapse" for="c-38285953">[-]</label><label class="expand" for="c-38285953">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the article. Maybe Iâm confused, but why in the section near the end about how the two recommendations go together, why is the code this:<p>if condition {
  for walrus in walruses {
    walrus.frobnicate()
  }
} else {
  for walrus in walruses {
    walrus.transmogrify()
  }
}
and not this?<p>if condition {
    frobnicate_batch(walruses)
} else {
    transmogrify_batch(walruses)
}</div><br/></div></div><div id="38284620" class="c"><input type="checkbox" id="c-38284620" checked=""/><div class="controls bullet"><span class="by">jackblemming</span><span>|</span><a href="#38285953">prev</a><span>|</span><a href="#38284064">next</a><span>|</span><label class="collapse" for="c-38284620">[-]</label><label class="expand" for="c-38284620">[1 more]</label></div><br/><div class="children"><div class="content">âPut ifs were they minimize the net total Cyclomatic complexityâ<p>This is exactly what the factory design pattern is trying to achieve. Figure out the type of object to create and then use it everywhere vs a million different switch statements scattered around.<p>Also donât create batch functions unless you need to. Functions that work on a single item compose better with map-reduce.</div><br/></div></div><div id="38284064" class="c"><input type="checkbox" id="c-38284064" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#38284620">prev</a><span>|</span><a href="#38283305">next</a><span>|</span><label class="collapse" for="c-38284064">[-]</label><label class="expand" for="c-38284064">[1 more]</label></div><br/><div class="children"><div class="content">This is a variation of the âgolden rule of software qualityâ<p><a href="https:&#x2F;&#x2F;www.haskellforall.com&#x2F;2020&#x2F;07&#x2F;the-golden-rule-of-software-quality.html?m=1" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.haskellforall.com&#x2F;2020&#x2F;07&#x2F;the-golden-rule-of-sof...</a></div><br/></div></div><div id="38283305" class="c"><input type="checkbox" id="c-38283305" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#38284064">prev</a><span>|</span><label class="collapse" for="c-38283305">[-]</label><label class="expand" for="c-38283305">[3 more]</label></div><br/><div class="children"><div class="content">This kind of rule of thumb usually contains some mote of wisdom, but generally just creates the kind of thing I have to de-dogmatize from newer programmers.<p>Thereâs just always going to be a ton of cases where trying to adhere to this too rigidly is worse. And âjust know when not to listen to this adviceâ is basically the core complexity here.</div><br/><div id="38286353" class="c"><input type="checkbox" id="c-38286353" checked=""/><div class="controls bullet"><span class="by">gavmor</span><span>|</span><a href="#38283305">parent</a><span>|</span><a href="#38283748">next</a><span>|</span><label class="collapse" for="c-38286353">[-]</label><label class="expand" for="c-38286353">[1 more]</label></div><br/><div class="children"><div class="content">De-dogmatizing needs to happen, so what? I think these kinds of rules are helpful to play with; adopt them, ride them as far as they go, invert them for a day or year , see where that takes you. You learn their limits, so what? More grist for the palimpsest.</div><br/></div></div><div id="38283748" class="c"><input type="checkbox" id="c-38283748" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#38283305">parent</a><span>|</span><a href="#38286353">prev</a><span>|</span><label class="collapse" for="c-38283748">[-]</label><label class="expand" for="c-38283748">[1 more]</label></div><br/><div class="children"><div class="content">I think this article could be useful as a koan in a larger compilation.<p>Some of the koans should contradict each other.</div><br/></div></div></div></div></div></div></div></div></div></body></html>