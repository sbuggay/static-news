<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716454870978" as="style"/><link rel="stylesheet" href="styles.css?v=1716454870978"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thephd.dev/just-put-raii-in-c-bro-please-bro-just-one-more-destructor-bro-cmon-im-good-for-it">Why not just do simple C++ RAII in C?</a> <span class="domain">(<a href="https://thephd.dev">thephd.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>120 comments</span></div><br/><div><div id="40451445" class="c"><input type="checkbox" id="c-40451445" checked=""/><div class="controls bullet"><span class="by">guillaumec</span><span>|</span><a href="#40444695">next</a><span>|</span><label class="collapse" for="c-40451445">[-]</label><label class="expand" for="c-40451445">[5 more]</label></div><br/><div class="children"><div class="content">I notice more and more pushes to &#x27;improve&#x27; C and turn it into something it should not become.  I feel like the C++ community gave up on C++ because of the growing complexity and so turned to C with the hope of adding to it the good parts of C++ without the ugliness.  But this is of course hopeless: every added feature will create new issues that will be solved with new features until the language becomes too complex for anyone to fully understand.</div><br/><div id="40451548" class="c"><input type="checkbox" id="c-40451548" checked=""/><div class="controls bullet"><span class="by">fch42</span><span>|</span><a href="#40451445">parent</a><span>|</span><a href="#40444695">next</a><span>|</span><label class="collapse" for="c-40451548">[-]</label><label class="expand" for="c-40451548">[4 more]</label></div><br/><div class="children"><div class="content">The part in it that I don&#x27;t understand is ...<p>Again, &quot;traditionally&quot;, one could (ab)use C++ as &quot;C with extras&quot;. And it wasn&#x27;t uncommon, especially in resource constraint usecases, 
to do just that. C++ without STL or templates, or even C++ without new&#x2F;delete.<p>This &quot;is not C++&quot;, agree. Would a subset be enough for &quot;using it like C-with-RAII&quot; ?<p>Given the details and pitfalls the original author lists, I suspect not. It&#x27;s not just C programmers who &quot;do strange things&quot; and make odd choices. The language itself though &quot;lends itself to that&quot;. I&#x27;ve (had to) write code that sometimes-alloca&#x27;ed sometimes-malloc&#x27;ed the same thing and then &quot;tagged&quot; it to indicate whether it needed free() or &quot;just&quot; the implied drop. Another rather common antipattern is &quot;generic embedded payloads&quot; - the struct definition ending &quot;char data[1]&quot; just to be padded out by whatever creates it to whatever size (nevermind type) of that data.<p>Can you write _new_ C code that &quot;does RAII&quot; ? Probably. Just rewrite it in rust, or zig :-)
Can you somehow transmogrify language, compiler, standard lib so that you can recompile existing C code, it not to &quot;just get RAII&quot; then at least to give you meaningful compiler errors&#x2F;warnings that tell you how to change it ? I won&#x27;t put money on that.</div><br/><div id="40452053" class="c"><input type="checkbox" id="c-40452053" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#40451445">root</a><span>|</span><a href="#40451548">parent</a><span>|</span><a href="#40451767">next</a><span>|</span><label class="collapse" for="c-40452053">[-]</label><label class="expand" for="c-40452053">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can you write _new_ C code that &quot;does RAII&quot; ? Probably.<p>You can do &quot;manual&quot; goto-based RAII in C, and it has been done for decades. The end of your function needs to have a cascading layer of labels, undoing what has been done before:<p><pre><code>    if (!(x = create_x())) {
        goto cleanup;
    }

    if (!(y = create_y())) {
        goto cleanup_x;
    }

    if (!(z = create_z())) {
       goto cleanup_y;
    }

    do_something(x, y, z);

    cleanup_z:
    destroy_z(z);
    cleanup_y:
    destroy_y(y);
    cleanup_x:
    destroy_x(x);
    cleanup:
    return;
</code></pre>
It just takes more discipline and is more error-prone maintenance-wise.</div><br/><div id="40452192" class="c"><input type="checkbox" id="c-40452192" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40451445">root</a><span>|</span><a href="#40452053">parent</a><span>|</span><a href="#40451767">next</a><span>|</span><label class="collapse" for="c-40452192">[-]</label><label class="expand" for="c-40452192">[1 more]</label></div><br/><div class="children"><div class="content">except this misses the point of RAII.</div><br/></div></div></div></div><div id="40451767" class="c"><input type="checkbox" id="c-40451767" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40451445">root</a><span>|</span><a href="#40451548">parent</a><span>|</span><a href="#40452053">prev</a><span>|</span><a href="#40444695">next</a><span>|</span><label class="collapse" for="c-40451767">[-]</label><label class="expand" for="c-40451767">[1 more]</label></div><br/><div class="children"><div class="content">New&#x2F;delete were never that great to begin with and have now fallen out of style. Also, C++ is quite useful and powerful even without STL.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rX0ItVEVjHc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rX0ItVEVjHc</a><p>A classic which touches on such stuff.</div><br/></div></div></div></div></div></div><div id="40444695" class="c"><input type="checkbox" id="c-40444695" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#40451445">prev</a><span>|</span><a href="#40444945">next</a><span>|</span><label class="collapse" for="c-40444695">[-]</label><label class="expand" for="c-40444695">[14 more]</label></div><br/><div class="children"><div class="content">In other words, C structs and C++ structs are not the same thing (although C++ can usually handle C structs too). C structs are Plain Old Data. C++ structs are &quot;objects&quot; and there are pages and pages of rules in the C++ Standard about what that means, and there&#x27;s no way the C Standard can incorporate all that. And you can&#x27;t drag any C++ struct&#x2F;class features into C without dragging in all those rules with them.</div><br/><div id="40450745" class="c"><input type="checkbox" id="c-40450745" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40444695">parent</a><span>|</span><a href="#40444904">next</a><span>|</span><label class="collapse" for="c-40450745">[-]</label><label class="expand" for="c-40450745">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In other words, C structs and C++ structs are not the same thing (although C++ can usually handle C structs too). C structs are Plain Old Data. C++ structs are &quot;objects&quot; and there are pages and pages of rules in the C++ Standard about what that means, and there&#x27;s no way the C Standard can incorporate all that.<p>I think this glances over what structs actually are in C++, and unwittingly portrays them as something different.<p>Structs in C++ are definitely exact like structs in C. Or they can be, if that&#x27;s what you&#x27;re aiming for. If you include a C header file that defines a struct in a C++ program, you build it, and you use instances of that struct to pass them to C programs, everthing just works.<p>The detail you need to be mindful of is that C structs support a subset of all the features supported by C++ classes, and once you start to use those features C++ also allows implementations to forego some constraints.<p>If you expect to use a struct in C++ but still define it in a way that you make it include features that are not supported in C then you can&#x27;t pin that on the language.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;trivial-standard-layout-and-pod-types" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;trivial-standard-l...</a><p>Using C-like structs is a very common use case, to the point that the standard explicitly defines the concept of standard layout and builds upon that to specify the concept of a standard layout type. A struct&#x2F;class that is a standard layout type, which means it&#x27;s a POD type, corresponds exactly with C structs. They are explicitly defined in terms of retaining interoperability with other languages.</div><br/></div></div><div id="40444904" class="c"><input type="checkbox" id="c-40444904" checked=""/><div class="controls bullet"><span class="by">stonemetal12</span><span>|</span><a href="#40444695">parent</a><span>|</span><a href="#40450745">prev</a><span>|</span><a href="#40444945">next</a><span>|</span><label class="collapse" for="c-40444904">[-]</label><label class="expand" for="c-40444904">[11 more]</label></div><br/><div class="children"><div class="content">Yep. The only difference between struct and class in C++ is that class defaults to private while struct defaults to public.<p>100% of the using structs like they are C structs vs using class as objects is cultural not a part of the language.</div><br/><div id="40450830" class="c"><input type="checkbox" id="c-40450830" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40444904">parent</a><span>|</span><a href="#40445736">next</a><span>|</span><label class="collapse" for="c-40450830">[-]</label><label class="expand" for="c-40450830">[7 more]</label></div><br/><div class="children"><div class="content">&gt; 100% of the using structs like they are C structs vs using class as objects is cultural not a part of the language.<p>I think this take is completely wrong. There is nothing cultural about it. C++ was created as a strict superset of C, and thus from the inception it supported all features made available in C. This design goal remains true up to this day, and only started to diverge relatively recently when C was updated to include features that were not supported (yet) by C++.<p>When someone declares a plain old struct in C++, they are declaring a struct that is perfectly compatible and interoperable with C. This is by design. From the inception.</div><br/><div id="40451397" class="c"><input type="checkbox" id="c-40451397" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40450830">parent</a><span>|</span><a href="#40451744">next</a><span>|</span><label class="collapse" for="c-40451397">[-]</label><label class="expand" for="c-40451397">[5 more]</label></div><br/><div class="children"><div class="content">What if, after 20 years of C++, you spend 10 years doing python, only to go back to C++ and realise that all this private&#x2F;protected stuff is a crock and most of the time you are doing real work you just use struct and start typing your C++, virtual functions, constructors, destructors etc?<p>Just asking, for a friend.</div><br/><div id="40451777" class="c"><input type="checkbox" id="c-40451777" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40451397">parent</a><span>|</span><a href="#40451744">next</a><span>|</span><label class="collapse" for="c-40451777">[-]</label><label class="expand" for="c-40451777">[4 more]</label></div><br/><div class="children"><div class="content">&gt; you spend 10 years doing python, only to go back to C++ and realise that all this private&#x2F;protected stuff is a crock<p>Just a friendly reminder that two leading underscores wont protect your member functions in C++. Even if people insist that those are totally not supposed to be private in python.</div><br/><div id="40451908" class="c"><input type="checkbox" id="c-40451908" checked=""/><div class="controls bullet"><span class="by">nhatbui</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40451777">parent</a><span>|</span><a href="#40451812">next</a><span>|</span><label class="collapse" for="c-40451908">[-]</label><label class="expand" for="c-40451908">[2 more]</label></div><br/><div class="children"><div class="content">I think OP meant discarding public&#x2F;private constructs entirely, no protection, like in python.</div><br/><div id="40452241" class="c"><input type="checkbox" id="c-40452241" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40451908">parent</a><span>|</span><a href="#40451812">next</a><span>|</span><label class="collapse" for="c-40452241">[-]</label><label class="expand" for="c-40452241">[1 more]</label></div><br/><div class="children"><div class="content">Except python started mangling double underscore in a futile attempt to implement private members&#x2F;methods.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40445736" class="c"><input type="checkbox" id="c-40445736" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40444904">parent</a><span>|</span><a href="#40450830">prev</a><span>|</span><a href="#40450637">next</a><span>|</span><label class="collapse" for="c-40445736">[-]</label><label class="expand" for="c-40445736">[1 more]</label></div><br/><div class="children"><div class="content">Any similarly of keyword naming between C and C++ is purely coincidental. :P<p>C++ is somewhat unique in that it started out as a few extra features on top of C before gradually splitting off and mutating into a totally separate programming language.</div><br/></div></div><div id="40450637" class="c"><input type="checkbox" id="c-40450637" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40444904">parent</a><span>|</span><a href="#40445736">prev</a><span>|</span><a href="#40445700">next</a><span>|</span><label class="collapse" for="c-40450637">[-]</label><label class="expand" for="c-40450637">[1 more]</label></div><br/><div class="children"><div class="content">Support for POD (plain old datatype) structs in C++ is definitely part of the language.</div><br/></div></div><div id="40445700" class="c"><input type="checkbox" id="c-40445700" checked=""/><div class="controls bullet"><span class="by">SAHChandler</span><span>|</span><a href="#40444695">root</a><span>|</span><a href="#40444904">parent</a><span>|</span><a href="#40450637">prev</a><span>|</span><a href="#40444945">next</a><span>|</span><label class="collapse" for="c-40445700">[-]</label><label class="expand" for="c-40445700">[1 more]</label></div><br/><div class="children"><div class="content">The public vs. private aspect also affects inheritance. structs publicly inherit from base types by default, classes privately inherit from base types.</div><br/></div></div></div></div></div></div><div id="40444945" class="c"><input type="checkbox" id="c-40444945" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#40444695">prev</a><span>|</span><a href="#40444448">next</a><span>|</span><label class="collapse" for="c-40444945">[-]</label><label class="expand" for="c-40444945">[5 more]</label></div><br/><div class="children"><div class="content">I kind of emphatize with the author raging at &quot;just copy C++ bro&quot; proposals because at $TWO_JOBS_AGO I had to deal with an &quot;Architecture Team&quot; full of Very Senior(tm) people who would show up uninvited and give advice like &quot;did you know you can pee and poo at the same time?&quot;<p>Of course, but if you bothered at all to understand the constraints, you would have seen it is not actually that simple in our case.<p>And my project was several orders of magnitude simpler than the C standard.</div><br/><div id="40445858" class="c"><input type="checkbox" id="c-40445858" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#40444945">parent</a><span>|</span><a href="#40451279">next</a><span>|</span><label class="collapse" for="c-40445858">[-]</label><label class="expand" for="c-40445858">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this is an archetype. Show up out of nowhere, half-understand the problem, make a brain-dead suggestion, and then as soon as you point out the problems with that approach, they&#x27;re suddenly too busy with other things to respond.</div><br/></div></div><div id="40451279" class="c"><input type="checkbox" id="c-40451279" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40444945">parent</a><span>|</span><a href="#40445858">prev</a><span>|</span><a href="#40444448">next</a><span>|</span><label class="collapse" for="c-40451279">[-]</label><label class="expand" for="c-40451279">[3 more]</label></div><br/><div class="children"><div class="content">&gt; (...) I had to deal with an &quot;Architecture Team&quot; full of Very Senior(tm) people who would show up uninvited and give advice like &quot;did you know you can pee and poo at the same time?&quot;<p>It reads like you had experts giving you advise on how to improve things, and instead not only did you ignored their advise but you went to the extent of mindlessly disparaging their help.</div><br/><div id="40452076" class="c"><input type="checkbox" id="c-40452076" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#40444945">root</a><span>|</span><a href="#40451279">parent</a><span>|</span><a href="#40451779">next</a><span>|</span><label class="collapse" for="c-40452076">[-]</label><label class="expand" for="c-40452076">[1 more]</label></div><br/><div class="children"><div class="content">Nah, the other commenter had described the situation exactly right - after dropping the comments, the &quot;A-Team&quot; disappeared for a few months and never revisited our responses. It really feels like an archetype common at many companies.<p>They were doing it just to boost their egos and most of the teams in the company learned to ignore them. When the company ownership changed, the &quot;A-Team&quot; was the first under the chopping block because the new owners correctly saw that the high status they had was simply due to inertia of being first devs at the company and were not fullfiling any meaningful role in the present.</div><br/></div></div><div id="40451779" class="c"><input type="checkbox" id="c-40451779" checked=""/><div class="controls bullet"><span class="by">VBprogrammer</span><span>|</span><a href="#40444945">root</a><span>|</span><a href="#40451279">parent</a><span>|</span><a href="#40452076">prev</a><span>|</span><a href="#40444448">next</a><span>|</span><label class="collapse" for="c-40451779">[-]</label><label class="expand" for="c-40451779">[1 more]</label></div><br/><div class="children"><div class="content">I suspect if you don&#x27;t recognise this scenario you may be standing too close to the mirror.</div><br/></div></div></div></div></div></div><div id="40444448" class="c"><input type="checkbox" id="c-40444448" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#40444945">prev</a><span>|</span><a href="#40445688">next</a><span>|</span><label class="collapse" for="c-40444448">[-]</label><label class="expand" for="c-40444448">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue it barely works in C++ as well. I&#x27;ve seen so many poorly implemented classes that violate the very complicated 3&#x2F;5&#x2F;0 rule. It&#x27;s much easier to do RAII correctly in Rust since people aren&#x27;t constantly working with raw pointers and since objects which are moved somewhere else are not dropped like they are in C++.<p>One variant that I think might work even better than RAII or defer in a lot of languages is having a thread local &quot;context&quot; which you attach all cleanup actions to. It even works in C, you just define cleanup as a list of<p><pre><code>    typedef void(cleanup_function*)(void* context);

 which is saved as into a thread local. Unlike RAII, you don&#x27;t need to create a custom type for every cleanup action and unlike the call-with pattern from functional programming, lifetimes of these lists can be non-hierarchical.
</code></pre>
However, I&#x27;m still glad to see defer being considered for C. It&#x27;s a lot better than using goto for cleanup.</div><br/><div id="40444848" class="c"><input type="checkbox" id="c-40444848" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40444609">next</a><span>|</span><label class="collapse" for="c-40444848">[-]</label><label class="expand" for="c-40444848">[4 more]</label></div><br/><div class="children"><div class="content">&gt; that violate the very complicated 3&#x2F;5&#x2F;0 rule<p>Is it actually complicated? There’s only the rule of 0 - either your class isn’t managing resources directly &amp; has none of the 5 default methods defined explicitly (destructor, copy constructor&#x2F;assignment, move constructor&#x2F;assingment), or it manages 1 and exactly 1 resource and defines all 5. Following that simple rule gives you exception safety &amp; perfect RAII behavior. Of all the things in C++, it seemed like the most straightforward rule to follow mechanically.<p>BTW, the rule of 3 is from pre-C++11 - the addition of move construct&#x2F;move assignment makes it the rule of 5 which basically says if you define any of those default ones you must define all of them. But the rule of 0 is far stronger in that it gives you prescriptive mechanical rules to follow for resource management.<p>It’s much easier to do RAII correctly in Rust because of the ecosystem of the language + certain language features that make it more ergonomic (e.g. Borrow&#x2F;AsRef&#x2F;Deref) + some ownership guarantees around moves unless you make the type trivially copyable which won’t be the case when you own a resource.</div><br/><div id="40451003" class="c"><input type="checkbox" id="c-40451003" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40444448">root</a><span>|</span><a href="#40444848">parent</a><span>|</span><a href="#40444609">next</a><span>|</span><label class="collapse" for="c-40451003">[-]</label><label class="expand" for="c-40451003">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Is it actually complicated?<p>It is. There is no point in arguing otherwise.<p>To understand the problem, you need to understand why it is also a solution to much bigger problems.<p>C++ started as C with classes, and by design aimed at being perfectly compatible with C. But you want to improve developer experience, and bring to the table major architectural traits such as RAII. This in turn meant you add support for custom constructors, and customize how your instances are copied and destroyed. But you also want to be able to have everything just work out of the box without forcing developers to write boilerplate code. So you come up with the concept of special member functions which are automatically added by the compiler if they are trivial. However, forcing that upon every single situation can cause problems, so you have to come up with a strategy that suits all use cases and prevents serious bugs.<p>Consequently, you add a bunch of rules which boil down to a) if the class&#x2F;struct is trivial them compilers simply add trivial definitions of all special member functions s that you don&#x27;t have to, but once you define any of those special member functions yourself them the compiler steps back and let&#x27;s you do all the work.<p>Then C++ introduced move semantics. This refreshes the same problem as before. You need to retain compatibility with C, and you need to avoid boilerplate code, and on top of that you need to support all cases that originated the need for C++&#x27;s special member functions. But now you need to support move constructors and move assignment operators. Again, it&#x27;s fine if the compiler adds those automatically if it&#x27;s a trivial class&#x2F;struct, but if the class has custom constructors and destructors then surely you also need to handle moves in a special way, so the compiler steps back and lets you do all the work. On top of that, you add the fact that if you need custom code to copy your objects around, surely you need custom code to move them too, and thus the compiler steps back to let you do all the work.<p>On top of this, there are also some specific combinations of custom constructors&#x2F;destructors&#x2F;copy constructors&#x2F;copy assignment operators which let the compiler define move constructors&#x2F;move assignment operators.<p>It all makes absolutely sense if you are mindful of the design requirements. But if you just start to onboard onto C++ and barely know what a copy constructors is, all these aspects are arcane and sadistic. If you declare nothing then your class instances are copied and moved automatically, but once you add a constructor everything suddenly blows up and your code doesn&#x27;t even compile anymore. You spotted a bug where an instance of a child class isn&#x27;t being destroyed properly, and once you add a virtual destructor you suddenly have an unrelated function call throw compiler errors. You add a snazzy copy constructor that&#x27;s very performant and your performance tests suddenly start to blow up because of the performance hit if suddenly having to copy all instances instead of the compiler simply moving them. How do you sort out this nonsense?<p>The rule of 5 is a nice rule of thumb to allow developers to have a simple mental model over what they need to do to avoid a long list of issues, but you still have no control over what you&#x27;re doing. Things work, but work by sheer coincidence.</div><br/><div id="40451813" class="c"><input type="checkbox" id="c-40451813" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40444448">root</a><span>|</span><a href="#40451003">parent</a><span>|</span><a href="#40451666">next</a><span>|</span><label class="collapse" for="c-40451813">[-]</label><label class="expand" for="c-40451813">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is. There is no point in arguing otherwise.<p>Well, I don’t know how to respond to this. I clarified what the rules actually are (&lt; 1 paragraph) and following them blindly leads to correct results. You’ve brought in a whole bunch of nonsense about why C++ has become complex as a language - it’s not wrong but I’m failing to connect the dots as to how the rule of 0 itself is hard to follow or complex. I’m kind of taking as a given that whoever is writing the code is mildly familiar enough with C++ to understand RAII &amp; is trying to apply it correctly.<p>&gt; The rule of 5 is a nice rule of thumb to allow developers to have a simple mental model over what they need to do to avoid a long list of issues, but you still have no control over what you’re doing. Things work, but work by sheer coincidence.<p>First, as I’ve said multiple times, it’s the rule of 0. That’s the rule to follow to get correct composition of resource ownership &amp; it’s super simple. As for not having control, I really fail to see how that is - C++ famously gives you too much control and that’s the problem. As for things working by sheer coincidence, that’s like your opinion. To me “coincidence” wouldn’t explain how many lines of C++ code are running in production.<p>Look, I think C++ has a lot of warts which is why I prefer Rust these days. But the rule of 0 is not where I’d say C++’s complexity lies - if you think that is the case, I’d recommend you use another language because if you can’t grok the rule of 0, the other footguns that lie in wait will blow you away to smithereens.</div><br/></div></div><div id="40451666" class="c"><input type="checkbox" id="c-40451666" checked=""/><div class="controls bullet"><span class="by">tuyiown</span><span>|</span><a href="#40444448">root</a><span>|</span><a href="#40451003">parent</a><span>|</span><a href="#40451813">prev</a><span>|</span><a href="#40444609">next</a><span>|</span><label class="collapse" for="c-40451666">[-]</label><label class="expand" for="c-40451666">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Things work, but work by sheer coincidence<p>I wouldn&#x27;t be so dramatic. House of cards don&#x27;t stay put by coincidence !</div><br/></div></div></div></div></div></div><div id="40444609" class="c"><input type="checkbox" id="c-40444609" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40444848">prev</a><span>|</span><a href="#40444523">next</a><span>|</span><label class="collapse" for="c-40444609">[-]</label><label class="expand" for="c-40444609">[2 more]</label></div><br/><div class="children"><div class="content">Arena can be used to allocate many times but deallocate exactly once. In Zig:<p><pre><code>    test &quot;arena allocator&quot; {
        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer arena.deinit();
        const allocator = arena.allocator();

        _ = try allocator.alloc(u8, 1);
        _ = try allocator.alloc(u8, 10);
        _ = try allocator.alloc(u8, 100);
    }</code></pre></div><br/><div id="40445577" class="c"><input type="checkbox" id="c-40445577" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40444448">root</a><span>|</span><a href="#40444609">parent</a><span>|</span><a href="#40444523">next</a><span>|</span><label class="collapse" for="c-40445577">[-]</label><label class="expand" for="c-40445577">[1 more]</label></div><br/><div class="children"><div class="content">I’m a fan of Zig, but I just want to point out that creating dedicated allocators for managing specific regions&#x2F;chunks of memory or memory within specific application scopes (i.e., arenas) is just <i>another</i> memory allocation strategy rather than the ultimate solution to memory management issues. It comes with its own trade-offs and depends entirely on your use case. Also, it’s great that Zig has this battery included in its standard library, but arenas aren’t unique to Zig nor are they difficult to implement in any language that allows manual memory management. I’m just pointing this out because I keep seeing folks highlight this as a key feature of Zig over C.</div><br/></div></div></div></div><div id="40444523" class="c"><input type="checkbox" id="c-40444523" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40444609">prev</a><span>|</span><a href="#40450842">next</a><span>|</span><label class="collapse" for="c-40444523">[-]</label><label class="expand" for="c-40444523">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; &#x27;a thread local &quot;context&quot; which you attach all cleanup actions to&#x27;</i><p>Like the autorelease pool found in Objective-C of yore? I always liked that solution and sometimes implemented in plain C too.</div><br/></div></div><div id="40450842" class="c"><input type="checkbox" id="c-40450842" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40444523">prev</a><span>|</span><a href="#40445109">next</a><span>|</span><label class="collapse" for="c-40450842">[-]</label><label class="expand" for="c-40450842">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d argue it barely works in C++ as well. I&#x27;ve seen so many poorly implemented classes that violate the very complicated 3&#x2F;5&#x2F;0 rule.<p>I&#x27;m afraid you&#x27;re complaining about entirely unrelated things.<p>It&#x27;s one thing to claim that C++ structs have this or that trait. It&#x27;s a entirely different thing to try to pin bugs and developer mistakes on how a language is designed.</div><br/></div></div><div id="40445109" class="c"><input type="checkbox" id="c-40445109" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40450842">prev</a><span>|</span><a href="#40444565">next</a><span>|</span><label class="collapse" for="c-40445109">[-]</label><label class="expand" for="c-40445109">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen someone get the rule of 5 wrong, but the rule of 3 was a reaction to 10 years of hindsight to realise the default is wrong. Congradulations to rust for looking to see what was done wrong by their predisessors. you can&#x27;t really fault someone for making a mistake when nobody at the time knew it was a mistake.</div><br/></div></div><div id="40444565" class="c"><input type="checkbox" id="c-40444565" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40445109">prev</a><span>|</span><a href="#40444751">next</a><span>|</span><label class="collapse" for="c-40444565">[-]</label><label class="expand" for="c-40444565">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the example of &quot;what if you make a copy&quot; breaks in C++ in exactly the same way if you&#x27;re not careful.</div><br/></div></div><div id="40444751" class="c"><input type="checkbox" id="c-40444751" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#40444448">parent</a><span>|</span><a href="#40444565">prev</a><span>|</span><a href="#40445688">next</a><span>|</span><label class="collapse" for="c-40444751">[-]</label><label class="expand" for="c-40444751">[1 more]</label></div><br/><div class="children"><div class="content">My small brained comment is people use heap allocation when they should be using an arena allocation. And heap allocation shouldn&#x27;t return a pointer it should return a handle.</div><br/></div></div></div></div><div id="40445688" class="c"><input type="checkbox" id="c-40445688" checked=""/><div class="controls bullet"><span class="by">Measter</span><span>|</span><a href="#40444448">prev</a><span>|</span><a href="#40445004">next</a><span>|</span><label class="collapse" for="c-40445688">[-]</label><label class="expand" for="c-40445688">[4 more]</label></div><br/><div class="children"><div class="content">Maybe I just suck at reading, but I&#x27;m not sure I get the argument for why function overloading and constructors are required for RAII. Is it some interaction with C and C++&#x27;s object models that I clearly didn&#x27;t understand?</div><br/><div id="40451743" class="c"><input type="checkbox" id="c-40451743" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40445688">parent</a><span>|</span><a href="#40446135">next</a><span>|</span><label class="collapse" for="c-40451743">[-]</label><label class="expand" for="c-40451743">[1 more]</label></div><br/><div class="children"><div class="content">Nah the first half of the essay is basically irrelevant, you need to start below that, and what I consider the meat of the issue is the “copy” section about two thirds down.</div><br/></div></div><div id="40446135" class="c"><input type="checkbox" id="c-40446135" checked=""/><div class="controls bullet"><span class="by">defen</span><span>|</span><a href="#40445688">parent</a><span>|</span><a href="#40451743">prev</a><span>|</span><a href="#40445004">next</a><span>|</span><label class="collapse" for="c-40446135">[-]</label><label class="expand" for="c-40446135">[2 more]</label></div><br/><div class="children"><div class="content">Me attempting to summarize the article:<p>There are 2 ways to get C++-style RAII into C. The first way is to wholesale import the C++ object system into C (which means name mangling, all the different flavors of constructors, destructors, etc). Conceptually this would work, but it&#x27;s never going to happen, because implementing that would be literally more work than an entire conforming C99 compiler.<p>The second way is to just use some special function attributes to signify that a function runs when an object is created on the stack &#x2F; popped off the stack. This won&#x27;t work either because the C++ object system also solves lots of other problems that this simpler system just ignores (such as, what happens when you copy an object that has a constructor function).</div><br/><div id="40446519" class="c"><input type="checkbox" id="c-40446519" checked=""/><div class="controls bullet"><span class="by">Measter</span><span>|</span><a href="#40445688">root</a><span>|</span><a href="#40446135">parent</a><span>|</span><a href="#40445004">next</a><span>|</span><label class="collapse" for="c-40446519">[-]</label><label class="expand" for="c-40446519">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I missed the &quot;copy wholesale&quot; aspect.<p>When I started reading it, the first thing that came to my mind was the issue with copying the structs. The article started looking at the issue, but didn&#x27;t really follow further with the changes needed to make it work, which is that you start needing to introduce tracking which instance is responsible for the resources and providing a way to transfer that responsibility (a.k.a. ownership and move semantics).</div><br/></div></div></div></div></div></div><div id="40445004" class="c"><input type="checkbox" id="c-40445004" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#40445688">prev</a><span>|</span><a href="#40445600">next</a><span>|</span><label class="collapse" for="c-40445004">[-]</label><label class="expand" for="c-40445004">[5 more]</label></div><br/><div class="children"><div class="content">I wish there was some way that you could configure a C++ compiler to just disable certain features of the language, or enforce good practices.<p>But that&#x27;s already what linters&#x2F;static analyzers are doing? But then, why not integrate those tools directly in a C++ compiler instead?<p>With cpp2&#x2F;cppfront, Herb Sutter is already building some sort of a &quot;sane&quot; subset of the C++ language, maybe because you cannot achieve good practices without having a new syntax.<p>C++ seems to have the same problem of javascript: it has annoying &quot;don&#x27;t-do-that&quot; use cases, although it seems insanely more complicated to teach good C++ practices.</div><br/><div id="40447426" class="c"><input type="checkbox" id="c-40447426" checked=""/><div class="controls bullet"><span class="by">ThatGeoGuy</span><span>|</span><a href="#40445004">parent</a><span>|</span><a href="#40451459">next</a><span>|</span><label class="collapse" for="c-40447426">[-]</label><label class="expand" for="c-40447426">[1 more]</label></div><br/><div class="children"><div class="content">This is more or less what Sean Baxter was trying to do with <a href="https:&#x2F;&#x2F;www.circle-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.circle-lang.org&#x2F;</a>.<p>Of course, this requires  buying into a set of tooling and learning a lot of specific idioms. I can&#x27;t say I&#x27;ve used it, but from reading the docs it seems sound enough.</div><br/></div></div><div id="40451459" class="c"><input type="checkbox" id="c-40451459" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445004">parent</a><span>|</span><a href="#40447426">prev</a><span>|</span><a href="#40445164">next</a><span>|</span><label class="collapse" for="c-40451459">[-]</label><label class="expand" for="c-40451459">[2 more]</label></div><br/><div class="children"><div class="content">That is what static analysers are for.<p>The issue is developers that think they are useless tools.</div><br/><div id="40452112" class="c"><input type="checkbox" id="c-40452112" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#40445004">root</a><span>|</span><a href="#40451459">parent</a><span>|</span><a href="#40445164">next</a><span>|</span><label class="collapse" for="c-40452112">[-]</label><label class="expand" for="c-40452112">[1 more]</label></div><br/><div class="children"><div class="content">Usefully albeit depressingly, these days you can often get significantly easier buy-in if you call it a linter instead.</div><br/></div></div></div></div><div id="40445164" class="c"><input type="checkbox" id="c-40445164" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40445004">parent</a><span>|</span><a href="#40451459">prev</a><span>|</span><a href="#40445600">next</a><span>|</span><label class="collapse" for="c-40445164">[-]</label><label class="expand" for="c-40445164">[1 more]</label></div><br/><div class="children"><div class="content">You can write a compiler plugin that rejects constructs you don&#x27;t like. Even GCC doesn&#x27;t immediately lower the more complex (more controversial) C++ constructs. There&#x27;s an existing system headers mechanism, so it&#x27;s probably not that hard to skip this kind of feature restrictions for the standard library headers (where the banned constructs might be used to implement something that looks completely different at the surface).</div><br/></div></div></div></div><div id="40445600" class="c"><input type="checkbox" id="c-40445600" checked=""/><div class="controls bullet"><span class="by">nicebyte</span><span>|</span><a href="#40445004">prev</a><span>|</span><a href="#40444776">next</a><span>|</span><label class="collapse" for="c-40445600">[-]</label><label class="expand" for="c-40445600">[4 more]</label></div><br/><div class="children"><div class="content">I respect Jean-Heyd very much, but I&#x27;m unconvinced by this article.
First, the whole name mangling discussion is completely irrelevant to the issue and can be omitted.  Second, one could tack on both copy and move constructors on to C in order to solve the double-free issue, in much the same way regular ctors are tacked on in the email proposal. In fact, I would argue that it is _necessary_ because A in RAII stands for Acquisition not Allocation. &quot;Acquisition&quot; implies ownership, which can be transferred or shared, so your copies and moves _have_ to have a special meaning to them. The fact that the proposal is bad or incomplete does not mean that it is &quot;impossible&quot; to have RAII in C. I don&#x27;t claim that it _is_, but reading this did not reveal to me anything fundamental that would preclude RAII, only that all the preceding RAII proposals have been sloppy.</div><br/><div id="40451514" class="c"><input type="checkbox" id="c-40451514" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40445600">parent</a><span>|</span><a href="#40446363">next</a><span>|</span><label class="collapse" for="c-40451514">[-]</label><label class="expand" for="c-40451514">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it meanders to much to get to the point. Which is that RAII doesn&#x27;t work in C because unlike C++, which has a comprehensive type system mandated by a standard, a C program doesn&#x27;t &quot;know&quot; at runtime that a struct is composed of other (typed) fields so it can do a proper deep field copy (or destruction). And implementing that type system in C doesn&#x27;t seem feasible for practical and political reasons.<p>I think the actual question should be &quot;can C get automatic memory management like in C++ without having the equivalent of C++&#x27;s type system&quot;?<p>Though I can&#x27;t put my finger on it, my intuition says it can, if the interested people are willing to look deep enough.</div><br/><div id="40451988" class="c"><input type="checkbox" id="c-40451988" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#40445600">root</a><span>|</span><a href="#40451514">parent</a><span>|</span><a href="#40446363">next</a><span>|</span><label class="collapse" for="c-40451988">[-]</label><label class="expand" for="c-40451988">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a C program doesn&#x27;t &quot;know&quot; at runtime that a struct is composed of other (typed) fields so it can do a proper deep field copy (or destruction).<p>This doesn’t make sense: you don’t need runtime introspection to do this?</div><br/></div></div></div></div><div id="40446363" class="c"><input type="checkbox" id="c-40446363" checked=""/><div class="controls bullet"><span class="by">scott_s</span><span>|</span><a href="#40445600">parent</a><span>|</span><a href="#40451514">prev</a><span>|</span><a href="#40444776">next</a><span>|</span><label class="collapse" for="c-40446363">[-]</label><label class="expand" for="c-40446363">[1 more]</label></div><br/><div class="children"><div class="content">I found the arguments compelling. The discussion on &quot;Effective types&quot; and C not having a proper concept of objects is key.<p>Another way to think about it: even if you had defined constructors and destructors for a struct, you have not solved <i>when to call them</i>. C++&#x27;s answer to that question is its sophisticated object model. C does not have one, and in order to answer that question, it must. It&#x27;s worth noting that RAII was not a feature that was intentionally created in C++. Rather, astute early C++ developers realized it was a useful idiom made possible by C++&#x27;s object model.</div><br/></div></div></div></div><div id="40444776" class="c"><input type="checkbox" id="c-40444776" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#40445600">prev</a><span>|</span><a href="#40445037">next</a><span>|</span><label class="collapse" for="c-40444776">[-]</label><label class="expand" for="c-40444776">[4 more]</label></div><br/><div class="children"><div class="content">It would seem that if you want C with RAII, you...use C++ and limit the features you use. QED.</div><br/><div id="40445501" class="c"><input type="checkbox" id="c-40445501" checked=""/><div class="controls bullet"><span class="by">01100011</span><span>|</span><a href="#40444776">parent</a><span>|</span><a href="#40444921">next</a><span>|</span><label class="collapse" for="c-40445501">[-]</label><label class="expand" for="c-40445501">[1 more]</label></div><br/><div class="children"><div class="content">This is surprisingly common.  C++ is huge and filled with many features that are only understood by a small subset of folks and so many teams have restricted coding standards that define which features can be used and how.</div><br/></div></div><div id="40444921" class="c"><input type="checkbox" id="c-40444921" checked=""/><div class="controls bullet"><span class="by">manuel_w</span><span>|</span><a href="#40444776">parent</a><span>|</span><a href="#40445501">prev</a><span>|</span><a href="#40445037">next</a><span>|</span><label class="collapse" for="c-40444921">[-]</label><label class="expand" for="c-40444921">[2 more]</label></div><br/><div class="children"><div class="content">Sounds reasonable. In a project I used to work in I disabled stdlib, exceptions, RTTI. Not sure what else to disable to essentially have C with different syntax.</div><br/><div id="40445107" class="c"><input type="checkbox" id="c-40445107" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#40444776">root</a><span>|</span><a href="#40444921">parent</a><span>|</span><a href="#40445037">next</a><span>|</span><label class="collapse" for="c-40445107">[-]</label><label class="expand" for="c-40445107">[1 more]</label></div><br/><div class="children"><div class="content">extern “C” on everything, if you care about linking compatibility, gets you another chunk of the way there by also disabling overloading etc.</div><br/></div></div></div></div></div></div><div id="40445037" class="c"><input type="checkbox" id="c-40445037" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#40444776">prev</a><span>|</span><a href="#40445027">next</a><span>|</span><label class="collapse" for="c-40445037">[-]</label><label class="expand" for="c-40445037">[1 more]</label></div><br/><div class="children"><div class="content">&gt; “just ban simple automatic storage duration structure copying” is a terrible usability and horrific ergonomics decision to make<p>This sounds like a great idea to me! Rust disables implicit copying for structs with destructors, and together with move-by-default, it works really well. Unlike PoD structs, you don&#x27;t need to heap allocate them to ensure their uniqueness. Unlike copy constructors, you don&#x27;t need to worry about implicit copies. Unlike C++ move, there&#x27;s no moved-from junk value left behind.</div><br/></div></div><div id="40445027" class="c"><input type="checkbox" id="c-40445027" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40445037">prev</a><span>|</span><a href="#40444979">next</a><span>|</span><label class="collapse" for="c-40445027">[-]</label><label class="expand" for="c-40445027">[47 more]</label></div><br/><div class="children"><div class="content">C is the ultimate WYSIWYG language (provided you understand the semantics of your target architecture and assuming a non-buggy compiler). The language is relatively simple. The standard is accessible. I’d like it to remain that way. I don’t need C to adopt any other “modern” language features.<p>C11 provided a few worthwhile improvements (i.e., a proper memory model, alignment specification, standardized anonymous structures&#x2F;unions), but so many of the other additions, suggestions, and proposals I’ve seen will just ruin the minimal nature of C. In C++, a simple statement like `a = b++;` can mean multiple constructors being called, hidden allocations, unexpected exceptions, unclear object hierarchies, an overloaded `++`, an overloaded `=`, etc. Every time I wish I had some C++ feature in C, I just think about the cognitive overhead it’d bring with it, slap myself a couple times, and go back to loving simple ole C.<p>Please don’t ruin C.</div><br/><div id="40446012" class="c"><input type="checkbox" id="c-40446012" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40445438">next</a><span>|</span><label class="collapse" for="c-40446012">[-]</label><label class="expand" for="c-40446012">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Please don’t ruin C.<p>Exactly this. C++ folks should not approach C like a &quot;C++ lite&quot;. I appreciate the authors candid take on the subject.<p>As for defer, there is <i>some</i> existing precedent like GCC and Clang&#x27;s __attribute__((cleanup)), but - at least for me - a simple &quot;goto cleanup;&quot; is usually sufficient. If I understand N3199 [1] correctly, which is the authors proposal for introducing defer in C, then &quot;defer&quot; would be entirely a compile-time construct. Essentially just a code transformation to inject the necessary cleanup at the right spots. If you&#x27;re going to introduce defer to C then that does seem like the &quot;best&quot; approach IMO.<p>[1] <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n3199.htm" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n3199.htm</a></div><br/><div id="40451709" class="c"><input type="checkbox" id="c-40451709" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446012">parent</a><span>|</span><a href="#40445438">next</a><span>|</span><label class="collapse" for="c-40451709">[-]</label><label class="expand" for="c-40451709">[1 more]</label></div><br/><div class="children"><div class="content">We C++ devs haved moved away from C decades ago, and frankly dont even think of it any more, and will never go back. Its a relic of its time, like DOS, Amiga etc. RAII is a big feature we can no longer live without. The type system and overloading is fantastic. And std::vector is a magnificant feature. A language without these features is a relic for us C++ devs.<p>And yes, I also agree that C++ has WTF insanity, like 17 or so initialisation quirks, exceptions in general (primarily to address failures in constructers, surely there must be a better way, also OOM &#x2F; bad_alloc is a relic from the past), and unspecified sizes for default built in types (thats C heritage).</div><br/></div></div></div></div><div id="40445438" class="c"><input type="checkbox" id="c-40445438" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40446012">prev</a><span>|</span><a href="#40447037">next</a><span>|</span><label class="collapse" for="c-40445438">[-]</label><label class="expand" for="c-40445438">[26 more]</label></div><br/><div class="children"><div class="content">And presuming you avoid 100% of undefined behavior, which I&#x27;ve never seen a non-trivial C program succeed at. C is <i>way</i> too complicated in the real world. You don&#x27;t want C, you want a language that actually gives defined semantics to all combinations of language constructs.</div><br/><div id="40445725" class="c"><input type="checkbox" id="c-40445725" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445438">parent</a><span>|</span><a href="#40445689">next</a><span>|</span><label class="collapse" for="c-40445725">[-]</label><label class="expand" for="c-40445725">[4 more]</label></div><br/><div class="children"><div class="content">I feel the meme of &quot;Undefined Behavior&quot; has been massively exaggerated on the internet - the vast majority of examples appear to be extreme toy examples using the weirdest contrived constructs, or things that are <i>expected</i> to fault and you&#x27;re already using platform-specific information to know what that would look like (e.g. expecting a segmentation fault). It&#x27;s a Scary Boogyman That Will Kill You, not something that can be understood, managed, and avoided if necessary.<p>And even then there are tools to help define much of that - if you want well defined wrapped signed integers, great. If you want to trap on overflow, there&#x27;s an option for that. Lots of compiler warnings and other static analysis tools (that would just be default-rejected by the compiler today if it didn&#x27;t have historical baggage, but they exist and can be enabled to do that rejection).<p>Yes, there&#x27;s many issues with the ecosystem (and tooling - those options above <i>should</i> be default IMHO), but massively overstating them won&#x27;t actually help anyone make better software.<p>And other languages often have similar amounts of &quot;undefined behavior&quot; - but just don&#x27;t document it as such, relying on a single implementation being &quot;Defined Correct&quot;, and hope they&#x27;re not actually being relied on if anything changes. Just like C, only undocumentated.</div><br/><div id="40450050" class="c"><input type="checkbox" id="c-40450050" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445725">parent</a><span>|</span><a href="#40445689">next</a><span>|</span><label class="collapse" for="c-40450050">[-]</label><label class="expand" for="c-40450050">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t feel like the cause of most (all?) memory safety bugs has been &quot;massively exaggerated&quot;.</div><br/><div id="40450434" class="c"><input type="checkbox" id="c-40450434" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40450050">parent</a><span>|</span><a href="#40445689">next</a><span>|</span><label class="collapse" for="c-40450434">[-]</label><label class="expand" for="c-40450434">[2 more]</label></div><br/><div class="children"><div class="content">If you removed every case of &quot;Undefined Behavior&quot; from the C spec, you&#x27;d still have memory safety bugs. Because they&#x27;re orthogonal (though may be coupled if they come from the same core logic error).<p>This is what I mean by it becoming &quot;meme&quot; - things like &quot;Undefined Behavior&quot; or &quot;Memory Safety&quot; have become a discussion-ending &quot;Objective Badness&quot;, hiding the real intent - being &quot;Languages I Do No Like&quot; (or, most often, are a poor fit for the actual job I&#x27;m trying to do. Which is fine, but not rejecting that those jobs actually exist).<p>But they mean real things that we can improve in terms of software quality, and safety - but that&#x27;s rarely the intended result when those terms are now brought up. And many things we can do <i>right now</i> with existing systems to improve things, to not throw away huge amounts of already well-tested code. To do a staged improvement, and not let &quot;perfect&quot; be the enemy of better.</div><br/><div id="40451136" class="c"><input type="checkbox" id="c-40451136" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40450434">parent</a><span>|</span><a href="#40445689">next</a><span>|</span><label class="collapse" for="c-40451136">[-]</label><label class="expand" for="c-40451136">[1 more]</label></div><br/><div class="children"><div class="content">I suppose there are ways to make the undefined behavior defined that preserve memory unsafety, so you’re technically correct. In practice one would probably require safe crashes for OOB access etc.</div><br/></div></div></div></div></div></div></div></div><div id="40445689" class="c"><input type="checkbox" id="c-40445689" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445438">parent</a><span>|</span><a href="#40445725">prev</a><span>|</span><a href="#40451436">next</a><span>|</span><label class="collapse" for="c-40445689">[-]</label><label class="expand" for="c-40445689">[18 more]</label></div><br/><div class="children"><div class="content">&gt;you want a language that actually gives defined semantics to all combinations of language constructs<p>No, this is wrong. It&#x27;s a common misconception though. You would only want that in a hypothetical world where all computers are exactly the same.<p>Undefined and implementation defined behavior is what allows us to have performance at all. Here are some simple examples.<p>Suppose we want to make division by zero and null pointer dereference defined. Now every time you write a&#x2F;b or *x, the compiler will be forced to emit an extra branching check before this operation.<p>Something much more common---addition. What about signed overflow? Do you want the compiler to emit an overflow check in advance? Similar reasoning for shift instructions.<p>UB in the language specification allows compilers to optimize based on the assumption that the programs you write won&#x27;t have undefined behavior. If compilers are not able to do this, it becomes impossible to implement most optimizations we rely on. It&#x27;s a very core feature of modern language specifications, not an oversight you can fix by thinking about it for 10 minutes.</div><br/><div id="40445875" class="c"><input type="checkbox" id="c-40445875" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445689">parent</a><span>|</span><a href="#40445924">next</a><span>|</span><label class="collapse" for="c-40445875">[-]</label><label class="expand" for="c-40445875">[2 more]</label></div><br/><div class="children"><div class="content">&gt; UB in the language specification allows compilers to optimize based on the assumption that the programs you write won&#x27;t have undefined behavior.<p>Given that has proven to be a completely false assumption, I don&#x27;t think there&#x27;s a justification for compilers continuing to make it. Whatever performance gains they are making are simply not worth the unreliability they are courting.</div><br/><div id="40446297" class="c"><input type="checkbox" id="c-40446297" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445875">parent</a><span>|</span><a href="#40445924">next</a><span>|</span><label class="collapse" for="c-40446297">[-]</label><label class="expand" for="c-40446297">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Given that has proven to be a completely false assumption<p>This part is correct. The problem is in how to deal with this. If you want the compiler to correctly deal with code having undefined behavior, often the only possibility is to assume that all code has undefined behavior. That means, almost every operation gets a runtime branch. That is completely incompatible with how modern hardware works.<p>The rest is wrong, but again, this is a common misconception. Language designers and compiler writers are not idiots, contrary to popular belief. UB as a concept exists for a reason. It&#x27;s not for marginal performance boosts, it is to enable <i>any</i> compiler based transformation, and a notion of portability.</div><br/></div></div></div></div><div id="40445924" class="c"><input type="checkbox" id="c-40445924" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445689">parent</a><span>|</span><a href="#40445875">prev</a><span>|</span><a href="#40445788">next</a><span>|</span><label class="collapse" for="c-40445924">[-]</label><label class="expand" for="c-40445924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Suppose we want to make division by zero and null pointer dereference defined.<p>A good example is WebAssembly*—address 0x00000000 is a perfectly fine and well-defined address in linear memory. In practice though, most code you’ll come across targeting WebAssembly treats it as if dereferencing it is undefined behavior.<p>* Of course WebAssembly is a compiler target rather than a language, but it serves as a good example of the point you’re making.</div><br/></div></div><div id="40445788" class="c"><input type="checkbox" id="c-40445788" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445689">parent</a><span>|</span><a href="#40445924">prev</a><span>|</span><a href="#40450421">next</a><span>|</span><label class="collapse" for="c-40445788">[-]</label><label class="expand" for="c-40445788">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry I still don&#x27;t buy it. Can you please show me a use case where ignoring null pointer or overflow checks makes your product non-viable or uncompetitive?<p>Some of these checks could be removed by languages with better compilers and likely more restrictions. That is the better approach. As a user, I don&#x27;t want to run code that is potentially unsafe and&#x2F;or insecure.</div><br/><div id="40446192" class="c"><input type="checkbox" id="c-40446192" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445788">parent</a><span>|</span><a href="#40450421">next</a><span>|</span><label class="collapse" for="c-40446192">[-]</label><label class="expand" for="c-40446192">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not ignoring about ignoring null pointer or overflow checks, it&#x27;s having to necessarily insert these checks everywhere.</div><br/><div id="40446341" class="c"><input type="checkbox" id="c-40446341" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446192">parent</a><span>|</span><a href="#40450421">next</a><span>|</span><label class="collapse" for="c-40446341">[-]</label><label class="expand" for="c-40446341">[2 more]</label></div><br/><div class="children"><div class="content">We should build compilers that insert these checks for us (if they cannot statically determine them unnecessary). The ability to omit these checks doesn&#x27;t IMHO justify undefined behaviour.</div><br/><div id="40446360" class="c"><input type="checkbox" id="c-40446360" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446341">parent</a><span>|</span><a href="#40450421">next</a><span>|</span><label class="collapse" for="c-40446360">[-]</label><label class="expand" for="c-40446360">[1 more]</label></div><br/><div class="children"><div class="content">Well, good news is that you have optional modes in most compilers that do this.<p>You would not want to force these by default, nobody wants it. You can not statically determine them unnecessary in for the vast majority of code, even stuff as simple as `print(read(a) + read(b))`.</div><br/></div></div></div></div></div></div></div></div><div id="40450421" class="c"><input type="checkbox" id="c-40450421" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445689">parent</a><span>|</span><a href="#40445788">prev</a><span>|</span><a href="#40446240">next</a><span>|</span><label class="collapse" for="c-40450421">[-]</label><label class="expand" for="c-40450421">[4 more]</label></div><br/><div class="children"><div class="content">And yet somehow languages such as Rust, which have no UB (in the safe subset) manages to be within 5% of C and often faster in both real-world codebases and microbenchmarks.</div><br/><div id="40450832" class="c"><input type="checkbox" id="c-40450832" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40450421">parent</a><span>|</span><a href="#40446240">next</a><span>|</span><label class="collapse" for="c-40450832">[-]</label><label class="expand" for="c-40450832">[3 more]</label></div><br/><div class="children"><div class="content">It’s just a change in jargon for ‘marketing’ reasons.<p>For example: Rust will silently wrap signed integers in release mode even when it’s considered a bug and crashes in debug mode.</div><br/><div id="40450929" class="c"><input type="checkbox" id="c-40450929" checked=""/><div class="controls bullet"><span class="by">Slyfox33</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40450832">parent</a><span>|</span><a href="#40446240">next</a><span>|</span><label class="collapse" for="c-40450929">[-]</label><label class="expand" for="c-40450929">[2 more]</label></div><br/><div class="children"><div class="content">Signed overflow is not UB in rust. That&#x27;s not the same thing at all.</div><br/><div id="40450932" class="c"><input type="checkbox" id="c-40450932" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40450929">parent</a><span>|</span><a href="#40446240">next</a><span>|</span><label class="collapse" for="c-40450932">[-]</label><label class="expand" for="c-40450932">[1 more]</label></div><br/><div class="children"><div class="content">It’s not.<p>You have missed my point.</div><br/></div></div></div></div></div></div></div></div><div id="40446240" class="c"><input type="checkbox" id="c-40446240" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445689">parent</a><span>|</span><a href="#40450421">prev</a><span>|</span><a href="#40451436">next</a><span>|</span><label class="collapse" for="c-40446240">[-]</label><label class="expand" for="c-40446240">[6 more]</label></div><br/><div class="children"><div class="content">Zig, a language which is explicitly aimed at the same domain as C, has an improved semantics for all of these things.<p>If a pointer can be null, it must be an optional pointer, and you must in fact check before you dereference it.  This is what you want.  Is it ok to write a program which segfaults at random because you didn&#x27;t check for a pointer which can be null? Of course not.  If you don&#x27;t null-check the return value of e.g. malloc, your program is invalid.<p>But the benefit is in the other direction. Careful C checks for null before using a pointer, and keeping track of whether null has been checked is a manual process. This results in redundant null checks if you can&#x27;t statically prove (by staring at the code and thinking very hard) that it isn&#x27;t null.  So in practice you&#x27;re likely to have a combination of not checking and getting burned, and checking a pointer which was already checked. To do otherwise you have to understand the complete call graph, this is infeasible.<p>Zig doesn&#x27;t do any of this. If it&#x27;s a pointer, you can safely dereference it. If it&#x27;s an optional pointer, you <i>must</i> check, and then: it&#x27;s a pointer. Safe to pass down the call stack and freely use.  If you want C behavior you can always YOLO and just say `yoloptr.?.*`.<p>Overflow addition and divide by zero are <i>safety checked</i> undefined behavior, a critical concept in the specification. They will panic with a stack trace in debug and ReleaseSafe mode, and blow demons out of your nose in ReleaseFast and ReleaseSmall modes.  There&#x27;s also +% for guaranteed wraparound twos-complement overflow, and +| for saturating addition.  Also `@addWithOverflow` if your jam is checking the overflow bit.  Unwrapping an optional without checking it is also safety-checked UB: if you were wrong about the assumption that the payload carries a value, you&#x27;ll get a panic and stack trace on the line where you did `yolo.?`.<p>Shift operations require that the right hand side of the shift be a type log2(Type.bitwidth) of the left hand side. Zig allows integers of any width, so for a: u64, calling a &lt;&lt; b requires that b be a u6 or smaller.  Which is fine: if you know values will be within 0..63, you declare them u6, and if you want to shift on a byte, you truncate it: you were going to mask it anyway, right?  Zig simply refuses to let you forget this.  Addition of two u6 is just as fast as addition of the underlying bytes because of, you got it, safety-checked undefined behavior. In release mode it will just do what the chip does.<p>There&#x27;s a common theme here: some things require undefined behavior for performance. Zig does what it can to crash your program if that behavior is exhibited while you&#x27;re developing it.  Other things require that you take some well-defined actions or you&#x27;ll get UB: Zig tracks those in the type system.<p>You&#x27;ll note that undefined behavior is very much a part of the Zig specification, for the same reasons as in C. But that&#x27;s not a great excuse to make staying within the boundaries of defined behavior as pointlessly difficult as it is in C.</div><br/><div id="40450196" class="c"><input type="checkbox" id="c-40450196" checked=""/><div class="controls bullet"><span class="by">rperez333</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446240">parent</a><span>|</span><a href="#40451489">next</a><span>|</span><label class="collapse" for="c-40450196">[-]</label><label class="expand" for="c-40450196">[1 more]</label></div><br/><div class="children"><div class="content">I know nothing about Zig, but this is pretty interesting and looks well designed. Linus was recently very mad when someone suggested a new semantics for overflow:<p>——
I&#x27;m still entirely unconvinced.<p>The thing is, wrap-around is not only well-defined, it&#x27;s <i>common</i>, and
<i>EXPECTED</i>.<p>Example:<p><pre><code>   static inline u32 __hash_32_generic(u32 val)
   {
        return val * GOLDEN_RATIO_32;
   }
</code></pre>
and dammit, I absolutely DO NOT THINK we should annotate this as some
kind of &quot;special multiply&quot;.
—-<p>Full thread: <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;CAHk-=wi5YPwWA8f5RAf_Hi8iL0NhGJeL6MN6UFWwRMY8L6UDvQ@mail.gmail.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;CAHk-=wi5YPwWA8f5RAf_Hi8iL0NhGJ...</a></div><br/></div></div><div id="40451489" class="c"><input type="checkbox" id="c-40451489" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446240">parent</a><span>|</span><a href="#40450196">prev</a><span>|</span><a href="#40446342">next</a><span>|</span><label class="collapse" for="c-40451489">[-]</label><label class="expand" for="c-40451489">[1 more]</label></div><br/><div class="children"><div class="content">Even languages like Modula-2 and Ada, among others, had better semantics than C, but they didn&#x27;t come for free alongside UNIX.</div><br/></div></div><div id="40446342" class="c"><input type="checkbox" id="c-40446342" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446240">parent</a><span>|</span><a href="#40451489">prev</a><span>|</span><a href="#40451436">next</a><span>|</span><label class="collapse" for="c-40446342">[-]</label><label class="expand" for="c-40446342">[3 more]</label></div><br/><div class="children"><div class="content">Yes, you can surely improve things from C. C is not a benchmark for anything other than footguns per line of code.<p>The debug modes you mention are also available in various forms in C and C++ compilers. For example ASan and UBSan in clang will do exactly what you have described. The question is, then whether these belong in the language specification or left to individual tools.</div><br/><div id="40451496" class="c"><input type="checkbox" id="c-40451496" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446342">parent</a><span>|</span><a href="#40451436">next</a><span>|</span><label class="collapse" for="c-40451496">[-]</label><label class="expand" for="c-40451496">[2 more]</label></div><br/><div class="children"><div class="content">As proven multiple times throughout the computing history, individual tools are optional, and as such used less often than they actually should be.<p>Language specification is unavoidable when using said language.</div><br/><div id="40452183" class="c"><input type="checkbox" id="c-40452183" checked=""/><div class="controls bullet"><span class="by">lstodd</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40451496">parent</a><span>|</span><a href="#40451436">next</a><span>|</span><label class="collapse" for="c-40452183">[-]</label><label class="expand" for="c-40452183">[1 more]</label></div><br/><div class="children"><div class="content">mwahahaha. as if there is some divine &quot;language specification&quot; which all compilers adhere to on pain of eternal damnation.<p>no such thing ever existed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40451436" class="c"><input type="checkbox" id="c-40451436" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445438">parent</a><span>|</span><a href="#40445689">prev</a><span>|</span><a href="#40445615">next</a><span>|</span><label class="collapse" for="c-40451436">[-]</label><label class="expand" for="c-40451436">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; You don&#x27;t want C, you want a language that actually gives defined semantics to all combinations of language constructs.
</code></pre>
So, Zig?</div><br/></div></div><div id="40445615" class="c"><input type="checkbox" id="c-40445615" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445438">parent</a><span>|</span><a href="#40451436">prev</a><span>|</span><a href="#40447037">next</a><span>|</span><label class="collapse" for="c-40445615">[-]</label><label class="expand" for="c-40445615">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t necessarily want that. Forcing language-defined semantics on everything costs performance. Sorry, it just does, we can&#x27;t have it all. So, you can sacrifice performance for well-defined&#x27;ness, or you can choose not to - and the choice depends on the language _design goals_. As the design goals differ, so do the combinations of choices made for syntax and semantics.</div><br/><div id="40445828" class="c"><input type="checkbox" id="c-40445828" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445615">parent</a><span>|</span><a href="#40447037">next</a><span>|</span><label class="collapse" for="c-40445828">[-]</label><label class="expand" for="c-40445828">[1 more]</label></div><br/><div class="children"><div class="content">I think pretty much any amount of performance is worth sacrificing in order to get rid of the gnarly things UB can cause. Correctness is the first and most important thing in programming, because if you can&#x27;t be certain it works then it&#x27;s not very useful.</div><br/></div></div></div></div></div></div><div id="40447037" class="c"><input type="checkbox" id="c-40447037" checked=""/><div class="controls bullet"><span class="by">atn34</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40445438">prev</a><span>|</span><a href="#40451465">next</a><span>|</span><label class="collapse" for="c-40447037">[-]</label><label class="expand" for="c-40447037">[1 more]</label></div><br/><div class="children"><div class="content">&gt; provided you understand the semantics of your target architecture<p>Unless you&#x27;re writing inline assembly or intrinsics or something like that, the semantics of your target architecture are quite irrelevant. If you&#x27;re reasoning about the target architecture semantics that&#x27;s a pretty good indication that what you&#x27;re writing is undefined behavior. Reasoning about performance characteristics of your target architecture is definitely ok though.</div><br/></div></div><div id="40451465" class="c"><input type="checkbox" id="c-40451465" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40447037">prev</a><span>|</span><a href="#40445836">next</a><span>|</span><label class="collapse" for="c-40451465">[-]</label><label class="expand" for="c-40451465">[1 more]</label></div><br/><div class="children"><div class="content">Only if you mean C as defined by K&amp;R C, and its original use when porting UNIX.</div><br/></div></div><div id="40445836" class="c"><input type="checkbox" id="c-40445836" checked=""/><div class="controls bullet"><span class="by">theeandthy</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40451465">prev</a><span>|</span><a href="#40450992">next</a><span>|</span><label class="collapse" for="c-40445836">[-]</label><label class="expand" for="c-40445836">[4 more]</label></div><br/><div class="children"><div class="content">Agreed 100%. C is what it is and that’s a good thing.<p>However, if I were to request a feature to the core language it would be: NAMESPACES. This would clean up the code significantly without introducing confusing code paradigms.</div><br/><div id="40446212" class="c"><input type="checkbox" id="c-40446212" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445836">parent</a><span>|</span><a href="#40450992">next</a><span>|</span><label class="collapse" for="c-40446212">[-]</label><label class="expand" for="c-40446212">[3 more]</label></div><br/><div class="children"><div class="content">Namespaces are nice, but to my knowledge require name mangling which isn&#x27;t a thing in C. I&#x27;m curious what you mean by &quot;clean up the code significantly&quot; and &quot;confusing code paradigms&quot; because in C you typically prefix your functions to prevent name collisions which isn&#x27;t confusing or too noisy in my subjective opinion.</div><br/><div id="40451510" class="c"><input type="checkbox" id="c-40451510" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446212">parent</a><span>|</span><a href="#40447407">next</a><span>|</span><label class="collapse" for="c-40451510">[-]</label><label class="expand" for="c-40451510">[1 more]</label></div><br/><div class="children"><div class="content">Name mangling is an implementation detail to fit into UNIX linker design space, not the same approach as other compiled languages with modules, with their own linker.</div><br/></div></div><div id="40447407" class="c"><input type="checkbox" id="c-40447407" checked=""/><div class="controls bullet"><span class="by">theeandthy</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446212">parent</a><span>|</span><a href="#40451510">prev</a><span>|</span><a href="#40450992">next</a><span>|</span><label class="collapse" for="c-40447407">[-]</label><label class="expand" for="c-40447407">[1 more]</label></div><br/><div class="children"><div class="content">Yeah you’re right. I guess folks who want C++ stuff should just use C++…<p>I guess I should have reworded. I don’t expect that feature in C, but if I were to reinvent C today I would keep it the same but add namespace and mangling.<p>Adding an explicit prefix to every function call is a lot boilerplate when it’s all added up.</div><br/></div></div></div></div></div></div><div id="40450992" class="c"><input type="checkbox" id="c-40450992" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40445836">prev</a><span>|</span><a href="#40445839">next</a><span>|</span><label class="collapse" for="c-40450992">[-]</label><label class="expand" for="c-40450992">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  a simple statement like `a = b++;` can mean multiple constructors being called, hidden allocations, unexpected exceptions, unclear object hierarchies, an overloaded `++`, an overloaded `=`, etc.<p>its just mean if you need that logic, in C you would write lots of verbose less safe code.</div><br/></div></div><div id="40445839" class="c"><input type="checkbox" id="c-40445839" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40450992">prev</a><span>|</span><a href="#40445899">next</a><span>|</span><label class="collapse" for="c-40445839">[-]</label><label class="expand" for="c-40445839">[10 more]</label></div><br/><div class="children"><div class="content">&gt; a simple statement like `a = b++;` can mean multiple constructors being called, hidden allocations, unexpected exceptions [...]<p>Yes, nothing like that is possible in C<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;Ge4EqzznT" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;Ge4EqzznT</a></div><br/><div id="40446184" class="c"><input type="checkbox" id="c-40446184" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445839">parent</a><span>|</span><a href="#40446006">next</a><span>|</span><label class="collapse" for="c-40446184">[-]</label><label class="expand" for="c-40446184">[5 more]</label></div><br/><div class="children"><div class="content">The difference is that in C++ it&#x27;s expected that you&#x27;ll overload operators, provide implicit conversions and throw exceptions. Of course you can write terrible code in C but it is not common accepted practice to hide a longjmp in a macro disguised as an identifier.</div><br/><div id="40451539" class="c"><input type="checkbox" id="c-40451539" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446184">parent</a><span>|</span><a href="#40446421">next</a><span>|</span><label class="collapse" for="c-40451539">[-]</label><label class="expand" for="c-40451539">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, you hide longjump in a #define macro instead, with a do while block trick.</div><br/></div></div><div id="40446421" class="c"><input type="checkbox" id="c-40446421" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446184">parent</a><span>|</span><a href="#40451539">prev</a><span>|</span><a href="#40446295">next</a><span>|</span><label class="collapse" for="c-40446421">[-]</label><label class="expand" for="c-40446421">[2 more]</label></div><br/><div class="children"><div class="content">The funny thing is, examples of macro craziness only strengthen my point, because C++ inherits all of that <i>in addition to</i> its hidden behaviors and magical semantics. It’s rare to find serious C code doing a lot of crazy things behind macros. In my experience, the few exceptions I can think of include the GMP library and data structure-related code trying to emulate generics (mostly hash tables).</div><br/><div id="40446627" class="c"><input type="checkbox" id="c-40446627" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446421">parent</a><span>|</span><a href="#40446295">next</a><span>|</span><label class="collapse" for="c-40446627">[-]</label><label class="expand" for="c-40446627">[1 more]</label></div><br/><div class="children"><div class="content">Yes, C++ is a larger language for sure. But because it has better abstraction facilities, macro hackery is less common.</div><br/></div></div></div></div><div id="40446295" class="c"><input type="checkbox" id="c-40446295" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446184">parent</a><span>|</span><a href="#40446421">prev</a><span>|</span><a href="#40446006">next</a><span>|</span><label class="collapse" for="c-40446295">[-]</label><label class="expand" for="c-40446295">[1 more]</label></div><br/><div class="children"><div class="content">pthread_cleanup_{push,pop}</div><br/></div></div></div></div><div id="40446006" class="c"><input type="checkbox" id="c-40446006" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445839">parent</a><span>|</span><a href="#40446184">prev</a><span>|</span><a href="#40449167">next</a><span>|</span><label class="collapse" for="c-40446006">[-]</label><label class="expand" for="c-40446006">[2 more]</label></div><br/><div class="children"><div class="content">Haha. You can’t be serious—what’s the likelihood of running into C code like this in anything remotely serious (compared to the millions upon millions of lines of innocent-looking C++ code that does like a dozen different things under the hood)?</div><br/><div id="40446035" class="c"><input type="checkbox" id="c-40446035" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40446006">parent</a><span>|</span><a href="#40449167">next</a><span>|</span><label class="collapse" for="c-40446035">[-]</label><label class="expand" for="c-40446035">[1 more]</label></div><br/><div class="children"><div class="content">No true Scotsman.<p>I assume you haven&#x27;t looked at the expansion of errno lately?<p>edit: also<p><a href="https:&#x2F;&#x2F;github.com&#x2F;KxSystems&#x2F;kdb&#x2F;blob&#x2F;master&#x2F;c&#x2F;c&#x2F;k.h">https:&#x2F;&#x2F;github.com&#x2F;KxSystems&#x2F;kdb&#x2F;blob&#x2F;master&#x2F;c&#x2F;c&#x2F;k.h</a></div><br/></div></div></div></div><div id="40449167" class="c"><input type="checkbox" id="c-40449167" checked=""/><div class="controls bullet"><span class="by">fargle</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40445839">parent</a><span>|</span><a href="#40446006">prev</a><span>|</span><a href="#40445899">next</a><span>|</span><label class="collapse" for="c-40449167">[-]</label><label class="expand" for="c-40449167">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s a deliberately unfair comparison. operator overloading, constructors, assignments, etc. happen &quot;under-the-hood&quot; in c++ and are standard language features.<p>whereas you can see the user-defined macro definition of &quot;b&quot; at the top of the file. you can&#x27;t blame the c language for someone choosing to write something like that. sure it&#x27;s possible, but its your choice and responsibility if you do stupid things like this example.</div><br/><div id="40451473" class="c"><input type="checkbox" id="c-40451473" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40445027">root</a><span>|</span><a href="#40449167">parent</a><span>|</span><a href="#40445899">next</a><span>|</span><label class="collapse" for="c-40451473">[-]</label><label class="expand" for="c-40451473">[1 more]</label></div><br/><div class="children"><div class="content">Macros are also standard C features, and good luck figuring out that an identifier is a macro without IDE help when the definition is buried in some header.</div><br/></div></div></div></div></div></div><div id="40445899" class="c"><input type="checkbox" id="c-40445899" checked=""/><div class="controls bullet"><span class="by">tsegratis</span><span>|</span><a href="#40445027">parent</a><span>|</span><a href="#40445839">prev</a><span>|</span><a href="#40444979">next</a><span>|</span><label class="collapse" for="c-40445899">[-]</label><label class="expand" for="c-40445899">[1 more]</label></div><br/><div class="children"><div class="content">wishlist<p>1) labels as values in standard
2) control over memory position offsets, without linker script<p>other than that a few more compiler implementations offering things like checked array bounds, and a focus on correctness rather than accepting the occasional compiler bug<p>the rough edges like switch fallthrough are rough, but easy to work around. They don&#x27;t need fixing (-pedantic fixes it already, etc)<p>maybe more control over assembly generation, such as exposing compilation at runtime; but that is into the wishful end of wishlists</div><br/></div></div></div></div><div id="40444979" class="c"><input type="checkbox" id="c-40444979" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40445027">prev</a><span>|</span><a href="#40445139">next</a><span>|</span><label class="collapse" for="c-40444979">[-]</label><label class="expand" for="c-40444979">[5 more]</label></div><br/><div class="children"><div class="content">Is RAII even wanted?
I mean, in the name, &#x27;Resource acquisition is initialization&#x27; it talks about the initialization part.
But while not super versed in cpp, it looks like what everybody wants is actually the de-initialization part, which doesn&#x27;t seem to be inherent to RAII, no?<p>It&#x27;s a bit confusing to have a &#x27;thing&#x27; mention one mechanism in its name, but actually being valuable by ensuring some other mechanism</div><br/><div id="40445082" class="c"><input type="checkbox" id="c-40445082" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#40444979">parent</a><span>|</span><a href="#40445604">next</a><span>|</span><label class="collapse" for="c-40445082">[-]</label><label class="expand" for="c-40445082">[1 more]</label></div><br/><div class="children"><div class="content">I feel like most RAII fans will openly admit that it’s the worst name in the world for such an idea. The idea is that any time you acquire a resource, you should initialize an object with said resource. But I guess “resource allocation should always lead to object initialization” is too long.<p>The reason to do this is precisely so that the resource can be cleaned up at destruction of the object. So even if you had an acronym like RASALTOI, it would still probably be misleading</div><br/></div></div><div id="40445604" class="c"><input type="checkbox" id="c-40445604" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#40444979">parent</a><span>|</span><a href="#40445082">prev</a><span>|</span><a href="#40445270">next</a><span>|</span><label class="collapse" for="c-40445604">[-]</label><label class="expand" for="c-40445604">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a bit confusing to have a &#x27;thing&#x27; mention one mechanism in its name, but actually being valuable by ensuring some other mechanism.<p>Indeed!  When I was first learning C++, I found the term &quot;RAII&quot; quite confusing too.  However, after years of experience with this term, associating &quot;RAII&quot; with its intended meaning has become second nature.<p>Having said that, there is at least one way to make better sense of &quot;RAII&quot; and that is considering the fact that in RAII, holding a resource is a <i>class invariant</i>.  The resource is acquired during construction (initialisation) and released during destruction (which happens automatically when the object of the class goes out of scope).  Throughout the object&#x27;s lifetime, from construction to destruction, maintaining possession of the acquired resource is an invariant condition.<p>Although sounds simple in principle, this can get complicated pretty quickly, especially in the implementation of the copy assignment operator where we may need to carefully delete an existing resource before copying the new resource received by the operator.  Problems like this led to formulating more techniques for carefully managing the resources while satisfying the class invariant.  One such technique is the copy-and-swap idiom.<p>None of this is meant to justify the somewhat arbitrary term though.  In fact, there are at least two better alternative names for RAII: Scope-Based Resource Management (SBRM) and Constructor Acquires, Destructor Releases (CADR).</div><br/><div id="40450815" class="c"><input type="checkbox" id="c-40450815" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#40444979">root</a><span>|</span><a href="#40445604">parent</a><span>|</span><a href="#40445270">next</a><span>|</span><label class="collapse" for="c-40450815">[-]</label><label class="expand" for="c-40450815">[1 more]</label></div><br/><div class="children"><div class="content">CADR is far clearer.  Just like re-ordering it as Resource Initialization Is Acquisition.</div><br/></div></div></div></div><div id="40445270" class="c"><input type="checkbox" id="c-40445270" checked=""/><div class="controls bullet"><span class="by">NekkoDroid</span><span>|</span><a href="#40444979">parent</a><span>|</span><a href="#40445604">prev</a><span>|</span><a href="#40445139">next</a><span>|</span><label class="collapse" for="c-40445270">[-]</label><label class="expand" for="c-40445270">[1 more]</label></div><br/><div class="children"><div class="content">RAII is the worst name they could have selected and C++ devs openly admit that. Its more SBRM, Scope Based Resource Management.</div><br/></div></div></div></div><div id="40445139" class="c"><input type="checkbox" id="c-40445139" checked=""/><div class="controls bullet"><span class="by">potbelly83</span><span>|</span><a href="#40444979">prev</a><span>|</span><a href="#40445550">next</a><span>|</span><label class="collapse" for="c-40445139">[-]</label><label class="expand" for="c-40445139">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused why are they trying to implement name mangling in C? Are they trying to use the C++ compiler to implement the RAII assembly code and then link that back into C? Wouldn&#x27;t a smarter approach be to do a C version of what C++ does?</div><br/><div id="40445661" class="c"><input type="checkbox" id="c-40445661" checked=""/><div class="controls bullet"><span class="by">nicebyte</span><span>|</span><a href="#40445139">parent</a><span>|</span><a href="#40445262">next</a><span>|</span><label class="collapse" for="c-40445661">[-]</label><label class="expand" for="c-40445661">[2 more]</label></div><br/><div class="children"><div class="content">they&#x27;re not. they&#x27;re saying &quot;if we had constructors in c, we&#x27;d need a mechanism to allow multiple constructors for the same type&quot;. in c++ function overloading and mangling are used to get that, but it&#x27;s far from the only way something like that could be achieved. imo that whole part could be removed, it&#x27;s like a little distraction and doesn&#x27;t really have anything to do with the core of their argument.</div><br/><div id="40445992" class="c"><input type="checkbox" id="c-40445992" checked=""/><div class="controls bullet"><span class="by">potbelly83</span><span>|</span><a href="#40445139">root</a><span>|</span><a href="#40445661">parent</a><span>|</span><a href="#40445262">next</a><span>|</span><label class="collapse" for="c-40445992">[-]</label><label class="expand" for="c-40445992">[1 more]</label></div><br/><div class="children"><div class="content">thanks! appreciate the reply</div><br/></div></div></div></div><div id="40445262" class="c"><input type="checkbox" id="c-40445262" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40445139">parent</a><span>|</span><a href="#40445661">prev</a><span>|</span><a href="#40445550">next</a><span>|</span><label class="collapse" for="c-40445262">[-]</label><label class="expand" for="c-40445262">[1 more]</label></div><br/><div class="children"><div class="content">I thought the author covered that pretty well. How would you make sure that function calls and object lifetimes are managed correctly&#x2F;deterministically while also remaining compatible with existing C++ code and compilers without having to have `extern &quot;C&quot;` everywhere?<p>Edit: I just reread this comment and realized the beginning of it could come across as a bit condescending even though that wasn’t at all my intention. I’d edit it out, but I don’t like doing that, so my apologies if it did come across that way!</div><br/></div></div></div></div><div id="40445550" class="c"><input type="checkbox" id="c-40445550" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#40445139">prev</a><span>|</span><a href="#40444789">next</a><span>|</span><label class="collapse" for="c-40445550">[-]</label><label class="expand" for="c-40445550">[2 more]</label></div><br/><div class="children"><div class="content">A C++ code design note:<p>The initial example in the article is anti-idiomatic, because it imbues the larger class with a RAIIness which can be limited to just one element of it:<p><pre><code>    struct ObjectType {
      int a;
      double b;
      void* c;

      ObjectType() : a(1), b(2.2), c(malloc(30)) { }
      ~ObjectType() { free(c); }
    };

</code></pre>
It&#x27;s only the c member that really requires any special attention. In this particular case. So, there should be something like a `class void_buffer` which is a RAII class, and then:<p><pre><code>    struct ObjectType {
      int a;
      double b;
      void_buffer c;

      ObjectType() : a(1), b(2.2), c(30) { }
    };
</code></pre>
and actually, let&#x27;s just not sully the set of constructors, but rather have:<p><pre><code>    struct ObjectType {
      int a;
      double b;
      void_buffer c;

      static ObjectType make() { 
        return ObjectType{ 1, 2.2, 30 }; 
      }

    };
</code></pre>
and now instead of a complicated bespoke class we have the simplest of structs; the only complexity is in void_buffer.</div><br/><div id="40451413" class="c"><input type="checkbox" id="c-40451413" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#40445550">parent</a><span>|</span><a href="#40444789">next</a><span>|</span><label class="collapse" for="c-40451413">[-]</label><label class="expand" for="c-40451413">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s a property of C++. It tempts you to hide complexity under several layers of classes so you can have ... more classes, i guess? And job security, because it makes the code much harder to follow for whoever didn&#x27;t write it.</div><br/></div></div></div></div><div id="40444789" class="c"><input type="checkbox" id="c-40444789" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#40445550">prev</a><span>|</span><a href="#40448253">next</a><span>|</span><label class="collapse" for="c-40444789">[-]</label><label class="expand" for="c-40444789">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The utterly pervasive and constant feeling that a lot of people – way too many people – are really trying to invent these things from first principles and pretend like they were the first people to ever conceive of these ideas… it feels pretty miserable, all things considered. Going through life evaluating effectively no prior art in other languages, domains, C codebases as they exist today, just… anything.<p>Oh man, I hear ya. And in a lot more domains than computer language design. Is it inexperience? Impatience? The tendency for search results to be filled with low-quality and high-recency content? The prioritization of hot-take blog posts and Reddit comments over books?</div><br/></div></div><div id="40448253" class="c"><input type="checkbox" id="c-40448253" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#40444789">prev</a><span>|</span><a href="#40451431">next</a><span>|</span><label class="collapse" for="c-40448253">[-]</label><label class="expand" for="c-40448253">[1 more]</label></div><br/><div class="children"><div class="content">Because you can just use actual C++ lol...</div><br/></div></div><div id="40451431" class="c"><input type="checkbox" id="c-40451431" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40448253">prev</a><span>|</span><label class="collapse" for="c-40451431">[-]</label><label class="expand" for="c-40451431">[5 more]</label></div><br/><div class="children"><div class="content">C has scopes. Add destructors. That&#x27;s pretty much all you need to get most of the benefits of RAII.<p>You can add `defer` instead, but regardless, this has nothing to do with C++. You can implement safety features without having to copy the arguably worst language in the world, C++. I like C++, I wrote many larger projects in it, but it sucks to the very core. Just add RAII to C.</div><br/><div id="40451477" class="c"><input type="checkbox" id="c-40451477" checked=""/><div class="controls bullet"><span class="by">leduyquang753</span><span>|</span><a href="#40451431">parent</a><span>|</span><label class="collapse" for="c-40451477">[-]</label><label class="expand" for="c-40451477">[4 more]</label></div><br/><div class="children"><div class="content">Did you even read the article? The part where it talks about problems with destructors is about halfway through.</div><br/><div id="40451626" class="c"><input type="checkbox" id="c-40451626" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40451431">root</a><span>|</span><a href="#40451477">parent</a><span>|</span><a href="#40451592">next</a><span>|</span><label class="collapse" for="c-40451626">[-]</label><label class="expand" for="c-40451626">[1 more]</label></div><br/><div class="children"><div class="content">TBF the essay is rather strangely structured, the entire <i>two thirds</i> of the essay covering constructors and overloading has only ancillary relevance to the actual problem, Rust has neither and does RAII just fine after all (though it does have name mangling).<p>The author even acknowledges halfway through that it’s basically a strawman:<p>&gt; It’s not a bad argument; after all, the entire above argument hinges on the idea of stealing from C++ entirely and copying their semantics bit-for-bit.<p>To me, only after that does it engage with the underlying concept in a way which is engaging and convincing. But you’ve had to trawl through 2500 words to get to that point.</div><br/></div></div><div id="40451592" class="c"><input type="checkbox" id="c-40451592" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40451431">root</a><span>|</span><a href="#40451477">parent</a><span>|</span><a href="#40451626">prev</a><span>|</span><label class="collapse" for="c-40451592">[-]</label><label class="expand" for="c-40451592">[2 more]</label></div><br/><div class="children"><div class="content">They assume C++-like destructors. Other languages, like Zig, do a good job with syntax like `defer`</div><br/><div id="40451640" class="c"><input type="checkbox" id="c-40451640" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40451431">root</a><span>|</span><a href="#40451592">parent</a><span>|</span><label class="collapse" for="c-40451640">[-]</label><label class="expand" for="c-40451640">[1 more]</label></div><br/><div class="children"><div class="content">They don’t “assume” C++-like destructor, they’re the primary author of the N3199 “defer” proposal for C.<p>This is a response to people contacting &#x2F; criticising them asking for destructors instead of defer.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>