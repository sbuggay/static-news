<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734858060859" as="style"/><link rel="stylesheet" href="styles.css?v=1734858060859"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://paul.blasuc.ci/posts/fault-report.html">Fault Report – and alternative to Result in F#</a> <span class="domain">(<a href="https://paul.blasuc.ci">paul.blasuc.ci</a>)</span></div><div class="subtext"><span>fire_lake</span> | <span>13 comments</span></div><br/><div><div id="42484657" class="c"><input type="checkbox" id="c-42484657" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#42484619">next</a><span>|</span><label class="collapse" for="c-42484657">[-]</label><label class="expand" for="c-42484657">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a very long age since I wrote any F#, really enjoyed it at the time and it was for fun stuff, I wasn&#x27;t trying to deal with errors, just things like process a prefix trie in a cool way, but does<p><pre><code>  Result&lt;&#x27;T, &#x27;TError&gt; 
</code></pre>
really have no upper type bounds on TError?<p>I&#x27;m assuming that&#x27;s the case from the fact that he&#x27;s arguing for a basic interface (Does F# support structural typing, or do you need to say that AtlasError implements IError or whatevs?), and I&#x27;m really surprised there isn&#x27;t one.<p>Huh, would love to know why leaving it unbounded was decided upon. Might be I don&#x27;t quite grok the culture of F#.<p>This reminds me of a very common and awful Python pattern, where, as there&#x27;s no `message` attribute on the base error&#x2F;exception classes, despite every nearly every exception or error having one, this is the normal pattern to access it:<p><pre><code>  message = ex.args[0]
</code></pre>
It gets really fun when you get an IndexError because one exception had no message provided when instantiated, so then you find code like:<p><pre><code>  message = ex.args[0] if ex.args else None
</code></pre>
Yech.</div><br/><div id="42485092" class="c"><input type="checkbox" id="c-42485092" checked=""/><div class="controls bullet"><span class="by">smoothdeveloper</span><span>|</span><a href="#42484657">parent</a><span>|</span><a href="#42484723">next</a><span>|</span><label class="collapse" for="c-42485092">[-]</label><label class="expand" for="c-42485092">[2 more]</label></div><br/><div class="children"><div class="content">&#x2F;!\ this is just my perspective &#x2F;!\<p>&gt; would love to know why leaving it unbounded was decided upon. Might be I don&#x27;t quite grok the culture of F#.<p>You may look at more context in the discussions pertaining to the RFC: <a href="https:&#x2F;&#x2F;github.com&#x2F;fsharp&#x2F;fslang-design&#x2F;blob&#x2F;main&#x2F;FSharp-4.1&#x2F;FS-1004-result-type.md">https:&#x2F;&#x2F;github.com&#x2F;fsharp&#x2F;fslang-design&#x2F;blob&#x2F;main&#x2F;FSharp-4.1...</a><p>I think those are the main factors:<p>* &quot;Keep It Simple Stupid&quot; principle<p>* community pressure so that F# libraries could standardise on better things that Choice1Of2 = Ok and Choice2Of2 = Error, or using a bare tuple (which is very not clean for APIs)<p>* F# ought to remain flexible in terms of not pretending of totally abstracting away the fact that most of the dotnet base class library or the overall dotnet ecosystem, uses exceptions, it is not like Result type was created to abstract runtime exceptions away.<p>For all other needs, one is just one wrapper &#x2F; or abstraction (for library that don&#x27;t &quot;meet our standards&quot; in terms of exception safety) away, along with a bit of adhoc tooling around leveraging FSharp.Compiler.Service for sake of adding static analysis, for architecture astronauts, dealing with behemoth or safety critical codebases, requiring even more screws turned, but even there, F# (and so many other languages) may not meet the bar if those are the critical properties for a project involving code.<p>Overall, F# is just pragmatic for the 99.99%, and not trying too hard beside the steady core language idioms, and how the organic community wants it over time, to satisfy hypothetical and intellectual pursuits of the highest abstraction and safety.<p>The culture of F# is mostly about throwing productivity parties and being done with it (while not suffering so many of the wrong choices done by C, C++, Java and it&#x27;s famed sibbling, C#), rather than the higher conceptual type theory perfection that (sometimes ?) lead to code that is not less kludgy, or easier to maintain, in the grand scheme, for the masses of developers, that are not yet expert in Haskell, Scala, etc.<p>It is probably not too dissimilar to OCaml culture, while embracing some aspects that are familiar to more people, due to relationship with dotnet ecosystem.</div><br/><div id="42485156" class="c"><input type="checkbox" id="c-42485156" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#42484657">root</a><span>|</span><a href="#42485092">parent</a><span>|</span><a href="#42484723">next</a><span>|</span><label class="collapse" for="c-42485156">[-]</label><label class="expand" for="c-42485156">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, I&#x27;ll read your link, but really appreciate your perspective. :)</div><br/></div></div></div></div><div id="42484723" class="c"><input type="checkbox" id="c-42484723" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#42484657">parent</a><span>|</span><a href="#42485092">prev</a><span>|</span><a href="#42484619">next</a><span>|</span><label class="collapse" for="c-42484723">[-]</label><label class="expand" for="c-42484723">[4 more]</label></div><br/><div class="children"><div class="content">Rust leaves it unrestricted. As does Haskell (although I am lying a little most just choose to use Either for Result)<p>Rust actually gets some use out of it, for instance returning an alternative value instead of handling it as a pure failure.</div><br/><div id="42484754" class="c"><input type="checkbox" id="c-42484754" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#42484657">root</a><span>|</span><a href="#42484723">parent</a><span>|</span><a href="#42484619">next</a><span>|</span><label class="collapse" for="c-42484754">[-]</label><label class="expand" for="c-42484754">[3 more]</label></div><br/><div class="children"><div class="content">Oh true, I am really interested in those choices too.</div><br/><div id="42484811" class="c"><input type="checkbox" id="c-42484811" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#42484657">root</a><span>|</span><a href="#42484754">parent</a><span>|</span><a href="#42484619">next</a><span>|</span><label class="collapse" for="c-42484811">[-]</label><label class="expand" for="c-42484811">[2 more]</label></div><br/><div class="children"><div class="content">The case that comes most to mind for that in Rust is <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.slice.html#method.binary_search" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.slice.html#method.bi...</a></div><br/><div id="42485161" class="c"><input type="checkbox" id="c-42485161" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#42484657">root</a><span>|</span><a href="#42484811">parent</a><span>|</span><a href="#42484619">next</a><span>|</span><label class="collapse" for="c-42485161">[-]</label><label class="expand" for="c-42485161">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42484619" class="c"><input type="checkbox" id="c-42484619" checked=""/><div class="controls bullet"><span class="by">omcnoe</span><span>|</span><a href="#42484657">prev</a><span>|</span><a href="#42484664">next</a><span>|</span><label class="collapse" for="c-42484619">[-]</label><label class="expand" for="c-42484619">[2 more]</label></div><br/><div class="children"><div class="content">As a daily user of F# I&#x27;m not sold on this suggested alternative.
It seems to be trying to make it as easy as possible to make the Result type behave like exception handling, but I think there are some key downsides to the approach.<p>First, Result is often used in place of Choice only to communicate the intent that the 2nd case is an error case. Making it more work to use Result (by requiring the types used for the Error to implement some special interface) means programmers will simply use Choice instead.<p>But the bigger issue is that this suggested change would remove the ability to ensure that cases of an error type are exhaustively matched. They introduce the FailAs active pattern at the very end of the blog to deal with logic that wants to inspect the underlying error cases, but active patterns break the compilers ability to check if a match is exhaustive. This is a really useful property for program correctness, I can ensure that a caller of my function will receive a compiler error when a new error case is introduced that wasn&#x27;t previously handled.<p>I wonder if a better design for the error type could be some kind of error type set that could automatically collect possible error cases up the call stack, so that when confronted with an IFault you at least know what possible cases it could have. With some type inference help it might not even be that painful to deal with, the first example could automatically infer a type like Errors&lt;AtlasError, ForExError&gt;.<p>As touched on briefly in the article, the elephant in the room here is that changing the Result type doesn&#x27;t do anything to unify the two distinct worlds of exceptions vs error values that currently exist in F#. Dealing with obscure C# exception flow from F# has been the biggest source of subtle, hard to track down bugs in my production code.</div><br/><div id="42484743" class="c"><input type="checkbox" id="c-42484743" checked=""/><div class="controls bullet"><span class="by">needlesslygrim</span><span>|</span><a href="#42484619">parent</a><span>|</span><a href="#42484664">next</a><span>|</span><label class="collapse" for="c-42484743">[-]</label><label class="expand" for="c-42484743">[1 more]</label></div><br/><div class="children"><div class="content">I agree, this doesn&#x27;t seem to be much better than adding `throws Throwable` to all your methods that can fail in Java. The reason sum types are so useful for error handling is that all possible cases can be exhaustively checked against at compile time.</div><br/></div></div></div></div><div id="42484664" class="c"><input type="checkbox" id="c-42484664" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#42484619">prev</a><span>|</span><label class="collapse" for="c-42484664">[-]</label><label class="expand" for="c-42484664">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure this is isomorphic to Go&#x27;s err, right?<p>Report ~ res, err (well this bit not strictly, but in practice close enough)<p>IFault ~ Err (interface over a string repr, and a way to wrap a cause Err with err.Unwrap)<p>In my experience if you land on a design that looks like something either Go or F# does then you&#x27;re probably on the right track. :)</div><br/><div id="42485042" class="c"><input type="checkbox" id="c-42485042" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42484664">parent</a><span>|</span><a href="#42484812">next</a><span>|</span><label class="collapse" for="c-42485042">[-]</label><label class="expand" for="c-42485042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience if you land on a design that looks like something either Go or F# does then you&#x27;re probably on the right track<p>Well, let&#x27;s just say that our experiences are vastly different then, but I had to do a double take when I saw Go mentioned as a positive from a PL design perspective..<p>And no, Go can literally return both a value and an error at the same time, it has possibly the worst error handling out of any &quot;modern&quot; language.</div><br/></div></div><div id="42484812" class="c"><input type="checkbox" id="c-42484812" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42484664">parent</a><span>|</span><a href="#42485042">prev</a><span>|</span><label class="collapse" for="c-42484812">[-]</label><label class="expand" for="c-42484812">[1 more]</label></div><br/><div class="children"><div class="content">Go lets you ignore the errors and does not have tuples - only multi-variable returns so you can&#x27;t <i>not</i> deconstruct the return value (and can&#x27;t .map it as a result too).<p>I don&#x27;t think it&#x27;s fair to place the two next to each other.<p>F# also does exception handling (where it makes sense, though TryParse is more efficient):<p><pre><code>  let values = [&quot;abcd&quot;; &quot;1234&quot;]
  let number = try int values[0] with _ -&gt; 1337</code></pre></div><br/></div></div></div></div></div></div></div></div></div></body></html>