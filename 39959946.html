<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712566861305" as="style"/><link rel="stylesheet" href="styles.css?v=1712566861305"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://retrocomputing.stackexchange.com/questions/29787/did-any-processor-implement-an-integer-square-root-instruction">Did any processor implement an integer square root instruction?</a> <span class="domain">(<a href="https://retrocomputing.stackexchange.com">retrocomputing.stackexchange.com</a>)</span></div><div class="subtext"><span>rwallace</span> | <span>68 comments</span></div><br/><div><div id="39961024" class="c"><input type="checkbox" id="c-39961024" checked=""/><div class="controls bullet"><span class="by">corsix</span><span>|</span><a href="#39960237">next</a><span>|</span><label class="collapse" for="c-39961024">[-]</label><label class="expand" for="c-39961024">[9 more]</label></div><br/><div class="children"><div class="content">AArch64 NEON has the URSQRTE instruction, which gets closer to the OP&#x27;s question than you might think; view a 32-bit value as a fixed-precision integer with 32 fractional bits (so the representable range is evenly spaced 0 through 1-ε, where ε=2^-32), then URSQRTE computes the approximate inverse square root, halves it, then clamps it to the range 0 through 1-ε. Fixed-precision integers aren&#x27;t quite integers, and approximate inverse square root isn&#x27;t quite square root, but it might get you somewhere close.<p>The related FRSQRTE instruction is much more conventional, operating on 32-bit floats, again giving approximate inverse square root.</div><br/><div id="39961911" class="c"><input type="checkbox" id="c-39961911" checked=""/><div class="controls bullet"><span class="by">voidbert</span><span>|</span><a href="#39961024">parent</a><span>|</span><a href="#39960237">next</a><span>|</span><label class="collapse" for="c-39961911">[-]</label><label class="expand" for="c-39961911">[8 more]</label></div><br/><div class="children"><div class="content">What task benefits from using such a complex instruction so easily dividable in simpler ones for it to be present in aarch64?</div><br/><div id="39961944" class="c"><input type="checkbox" id="c-39961944" checked=""/><div class="controls bullet"><span class="by">nanidin</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39961911">parent</a><span>|</span><a href="#39962022">next</a><span>|</span><label class="collapse" for="c-39961944">[-]</label><label class="expand" for="c-39961944">[5 more]</label></div><br/><div class="children"><div class="content">Neon is SIMD so I would presume these instructions let you vectorize those calculations and do them in parallel on a lot of data more efficiently than if you broke it down into simpler operations and did them one by one.</div><br/><div id="39962180" class="c"><input type="checkbox" id="c-39962180" checked=""/><div class="controls bullet"><span class="by">voidbert</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39961944">parent</a><span>|</span><a href="#39962022">next</a><span>|</span><label class="collapse" for="c-39962180">[-]</label><label class="expand" for="c-39962180">[4 more]</label></div><br/><div class="children"><div class="content">Yes, but the part that got me was the halving of the result followed by the clamping. SIMD generally makes sense, but for something like this to exist usually there&#x27;s something very specific (like a certain video codec, for example) that greatly benefits from such a complex instruction.</div><br/><div id="39962220" class="c"><input type="checkbox" id="c-39962220" checked=""/><div class="controls bullet"><span class="by">creato</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39962180">parent</a><span>|</span><a href="#39964114">next</a><span>|</span><label class="collapse" for="c-39962220">[-]</label><label class="expand" for="c-39962220">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably not about avoiding extra instructions&#x2F;performance, but making the range of the result more useful and avoiding overflow. Or in other words, the entire instruction may be useless if you don&#x27;t do these things.</div><br/></div></div><div id="39964114" class="c"><input type="checkbox" id="c-39964114" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39962180">parent</a><span>|</span><a href="#39962220">prev</a><span>|</span><a href="#39965890">next</a><span>|</span><label class="collapse" for="c-39964114">[-]</label><label class="expand" for="c-39964114">[1 more]</label></div><br/><div class="children"><div class="content">The halving and clamping is nothing particularly remarkable in the context of usefully using fixed point numbers (scaled integers) to avoid overflow. Reciprocal square root itself is a fundamental operation for DSP algorithms and of course computer graphics.
This is a fairly generic instruction really, though FRSQRTE likely gets more real world use.</div><br/></div></div><div id="39965890" class="c"><input type="checkbox" id="c-39965890" checked=""/><div class="controls bullet"><span class="by">ekelsen</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39962180">parent</a><span>|</span><a href="#39964114">prev</a><span>|</span><a href="#39962022">next</a><span>|</span><label class="collapse" for="c-39965890">[-]</label><label class="expand" for="c-39965890">[1 more]</label></div><br/><div class="children"><div class="content">The halving could come from an intended use in a Newton Raphson iteration of a square root refinement.<p>See for example <a href="https:&#x2F;&#x2F;math.mit.edu&#x2F;~stevenj&#x2F;18.335&#x2F;newton-sqrt.pdf" rel="nofollow">https:&#x2F;&#x2F;math.mit.edu&#x2F;~stevenj&#x2F;18.335&#x2F;newton-sqrt.pdf</a><p>The initial guess is the approximate square root, but it needs to be halved as part of the calculation.</div><br/></div></div></div></div></div></div><div id="39962022" class="c"><input type="checkbox" id="c-39962022" checked=""/><div class="controls bullet"><span class="by">colechristensen</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39961911">parent</a><span>|</span><a href="#39961944">prev</a><span>|</span><a href="#39960237">next</a><span>|</span><label class="collapse" for="c-39962022">[-]</label><label class="expand" for="c-39962022">[2 more]</label></div><br/><div class="children"><div class="content">Inverse square root is for normalizing vectors particularly in computer graphics calculations, it needs to be run a whole lot very fast.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root#Motivation" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root#Mot...</a></div><br/><div id="39963235" class="c"><input type="checkbox" id="c-39963235" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39961024">root</a><span>|</span><a href="#39962022">parent</a><span>|</span><a href="#39960237">next</a><span>|</span><label class="collapse" for="c-39963235">[-]</label><label class="expand" for="c-39963235">[1 more]</label></div><br/><div class="children"><div class="content">Famously the magic constant in the Quake engine that nobody remembers inventing.<p>That article does say there’s an SSE instruction rsqrtss that is better.</div><br/></div></div></div></div></div></div></div></div><div id="39960237" class="c"><input type="checkbox" id="c-39960237" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#39961024">prev</a><span>|</span><a href="#39960252">next</a><span>|</span><label class="collapse" for="c-39960237">[-]</label><label class="expand" for="c-39960237">[27 more]</label></div><br/><div class="children"><div class="content">Is it possible in a single clock-cycle. Yes, with a very large lookup table. It is probably possible to reduce the size depending on how many serial logical gates can be executed within the clock-cycle. Think about that the binary root of 10000 is rather similar to that of 100 only with respect to different number of zero&#x27;s.</div><br/><div id="39960499" class="c"><input type="checkbox" id="c-39960499" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#39960237">parent</a><span>|</span><a href="#39960361">next</a><span>|</span><label class="collapse" for="c-39960499">[-]</label><label class="expand" for="c-39960499">[1 more]</label></div><br/><div class="children"><div class="content"><i>Floating</i> <i>point</i> <i>reciprocal</i> <i>square</i> <i>root</i> <i>estimate</i> (`frsqrte`) instructions are typically implemented as just such a table lookup, indexed by a few bits of the fraction and the LSB of the exponent.
The precision is typically limited to similar to bf16 (ARM, RISC-V) or fp16 (x86), so programs are expected to do a few Newton-Raphson iterations afterwards if they want more.</div><br/></div></div><div id="39960361" class="c"><input type="checkbox" id="c-39960361" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#39960237">parent</a><span>|</span><a href="#39960499">prev</a><span>|</span><a href="#39964434">next</a><span>|</span><label class="collapse" for="c-39960361">[-]</label><label class="expand" for="c-39960361">[2 more]</label></div><br/><div class="children"><div class="content">You can compute the integer square root in n&#x2F;2 iterations where n is the number of bits in the source using just shifts and adds. For each step, check if a new bit has to be set in the result n_old by computing<p>n2_new = (n_old + (1 &lt;&lt; bit))^2 = n2_old + (n_old &lt;&lt; (bit + 1)) + (1 &lt;&lt; (bit*2))<p>Then compare it with the source operand, and if it&#x27;s greater or equal: 1) set the bit in the result 2) update n2_old with n2_new<p>It can be done in n&#x2F;2 or perhaps n clock cycles with a suitable microcode instruction set and ALU. With some effort it can be optimized to reduce n to the index of the leftmost set bit in the operand.</div><br/><div id="39961291" class="c"><input type="checkbox" id="c-39961291" checked=""/><div class="controls bullet"><span class="by">masswerk</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960361">parent</a><span>|</span><a href="#39964434">next</a><span>|</span><label class="collapse" for="c-39961291">[-]</label><label class="expand" for="c-39961291">[1 more]</label></div><br/><div class="children"><div class="content">Compare the integer square root algorithm used in &quot;Spacewar!&quot; [1]. So, even by 1960 it should have been possible to implement a square root step instructions for each bit, much like division or multiplication shifts, and progress from this to full-fledged automatic operations by the use of a sub timing network. (I guess, it really depends on the economics of the individual use case, whether the effort does pay off or not, as you would amass a few additional hardware modules to accomplish this.)<p>[1] <a href="https:&#x2F;&#x2F;www.masswerk.at&#x2F;spacewar&#x2F;inside&#x2F;insidespacewar-pt6-gravity.html#square_roots" rel="nofollow">https:&#x2F;&#x2F;www.masswerk.at&#x2F;spacewar&#x2F;inside&#x2F;insidespacewar-pt6-g...</a></div><br/></div></div></div></div><div id="39964434" class="c"><input type="checkbox" id="c-39964434" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#39960237">parent</a><span>|</span><a href="#39960361">prev</a><span>|</span><a href="#39960352">next</a><span>|</span><label class="collapse" for="c-39964434">[-]</label><label class="expand" for="c-39964434">[3 more]</label></div><br/><div class="children"><div class="content">so, dumb question.<p>do lookups in large tables ever (practically, not theoretically) take one clock cycle?<p>If there&#x27;s a large lookup table, it would have to come from memory, which might mean cache and memory hierarchy delays, right?</div><br/><div id="39964724" class="c"><input type="checkbox" id="c-39964724" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39964434">parent</a><span>|</span><a href="#39960352">next</a><span>|</span><label class="collapse" for="c-39964724">[-]</label><label class="expand" for="c-39964724">[2 more]</label></div><br/><div class="children"><div class="content">If the table is in silicon, you can avoid this. Not sure if that is done in practice though.</div><br/></div></div></div></div><div id="39960352" class="c"><input type="checkbox" id="c-39960352" checked=""/><div class="controls bullet"><span class="by">WithinReason</span><span>|</span><a href="#39960237">parent</a><span>|</span><a href="#39964434">prev</a><span>|</span><a href="#39962554">next</a><span>|</span><label class="collapse" for="c-39960352">[-]</label><label class="expand" for="c-39960352">[19 more]</label></div><br/><div class="children"><div class="content">Sounds like it&#x27;s possible to run any algorithm in the world in 1 clock cycle.</div><br/><div id="39961490" class="c"><input type="checkbox" id="c-39961490" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960352">parent</a><span>|</span><a href="#39960449">next</a><span>|</span><label class="collapse" for="c-39961490">[-]</label><label class="expand" for="c-39961490">[2 more]</label></div><br/><div class="children"><div class="content">Yes.  In theory, any pure function can be turned into a lookup table.  And any lookup table that isn&#x27;t just random numbers can be turned into a more compact algorithm that spends compute to save space.<p>Such tables may be infeasible, though.  While a int8 -&gt; int8 table only needs 256 bytes, an int32 -&gt; int32 needs 16 gigabytes.</div><br/><div id="39962202" class="c"><input type="checkbox" id="c-39962202" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961490">parent</a><span>|</span><a href="#39960449">next</a><span>|</span><label class="collapse" for="c-39962202">[-]</label><label class="expand" for="c-39962202">[1 more]</label></div><br/><div class="children"><div class="content">Fractal functions are pure, but don’t lend themselves well to memoization nor lookup tables.</div><br/></div></div></div></div><div id="39960449" class="c"><input type="checkbox" id="c-39960449" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960352">parent</a><span>|</span><a href="#39961490">prev</a><span>|</span><a href="#39960560">next</a><span>|</span><label class="collapse" for="c-39960449">[-]</label><label class="expand" for="c-39960449">[10 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t, because eventually the size of your logic or table becomes larger than the distance a signal can propagate in one clock tick. Before that, it likely presents practical issues (eg, is it worth dedicating that much silicon)</div><br/><div id="39961464" class="c"><input type="checkbox" id="c-39961464" checked=""/><div class="controls bullet"><span class="by">willcipriano</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960449">parent</a><span>|</span><a href="#39960560">next</a><span>|</span><label class="collapse" for="c-39961464">[-]</label><label class="expand" for="c-39961464">[9 more]</label></div><br/><div class="children"><div class="content">Have slower ticks. A planet size CPU that runs at .5 hz but can work on impossibly large numbers.</div><br/><div id="39964917" class="c"><input type="checkbox" id="c-39964917" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961464">parent</a><span>|</span><a href="#39961658">next</a><span>|</span><label class="collapse" for="c-39964917">[-]</label><label class="expand" for="c-39964917">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Have slower ticks.<p>Yes, this solves the stated issue about huge lookup tables.<p>&gt; A planet size CPU that runs at .5 hz but can work on impossibly large numbers.<p>This doesn&#x27;t make much sense to me, though.<p>If your goal is &quot;any algorithm&quot;, you&#x27;ll often have to go a <i>lot</i> slower than .5Hz.  A hash-calculating circuit that&#x27;s built out of a single mountain of silicon could have a critical path that&#x27;s light-years long.<p>But if your goal is just &quot;work on impossibly large numbers&quot;, but it&#x27;s okay to take multiple ticks, then there&#x27;s no reason to drag the frequency down that low.  You can run a planet-scale CPU at 1GHz.  CPUs have no need for signals to go all the way across inside a single tick.</div><br/><div id="39966092" class="c"><input type="checkbox" id="c-39966092" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39964917">parent</a><span>|</span><a href="#39961658">next</a><span>|</span><label class="collapse" for="c-39966092">[-]</label><label class="expand" for="c-39966092">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;d need way better clocks and synchronization circuits than exist now though, but I don&#x27;t see any pure physical barriers.</div><br/><div id="39966209" class="c"><input type="checkbox" id="c-39966209" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39966092">parent</a><span>|</span><a href="#39961658">next</a><span>|</span><label class="collapse" for="c-39966209">[-]</label><label class="expand" for="c-39966209">[1 more]</label></div><br/><div class="children"><div class="content">The whole thing doesn&#x27;t need to be on the same clock domain.  You can put clock crossings every inch.</div><br/></div></div></div></div></div></div><div id="39961658" class="c"><input type="checkbox" id="c-39961658" checked=""/><div class="controls bullet"><span class="by">volemo</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961464">parent</a><span>|</span><a href="#39964917">prev</a><span>|</span><a href="#39961493">next</a><span>|</span><label class="collapse" for="c-39961658">[-]</label><label class="expand" for="c-39961658">[1 more]</label></div><br/><div class="children"><div class="content">And 27.7% [1] of the planet&#x27;s crust is silicon already!<p>[1] Britannica: Silicon</div><br/></div></div><div id="39961493" class="c"><input type="checkbox" id="c-39961493" checked=""/><div class="controls bullet"><span class="by">gameshot911</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961464">parent</a><span>|</span><a href="#39961658">prev</a><span>|</span><a href="#39960560">next</a><span>|</span><label class="collapse" for="c-39961493">[-]</label><label class="expand" for="c-39961493">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually a really fascinating science fiction idea!</div><br/><div id="39962740" class="c"><input type="checkbox" id="c-39962740" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961493">parent</a><span>|</span><a href="#39963070">next</a><span>|</span><label class="collapse" for="c-39962740">[-]</label><label class="expand" for="c-39962740">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Matrioshka_brain" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Matrioshka_brain</a><p>:-D<p>It&#x27;s a topic that has been explored quite a bit in science fiction literature.</div><br/></div></div><div id="39963070" class="c"><input type="checkbox" id="c-39963070" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961493">parent</a><span>|</span><a href="#39962740">prev</a><span>|</span><a href="#39961594">next</a><span>|</span><label class="collapse" for="c-39963070">[-]</label><label class="expand" for="c-39963070">[1 more]</label></div><br/><div class="children"><div class="content">Related to the fallacy of comparing what&#x27;s slow in our world with what&#x27;s computable in a simulation of it--there&#x27;s no requirement for time to tick similarly.</div><br/></div></div><div id="39961594" class="c"><input type="checkbox" id="c-39961594" checked=""/><div class="controls bullet"><span class="by">willcipriano</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39961493">parent</a><span>|</span><a href="#39963070">prev</a><span>|</span><a href="#39960560">next</a><span>|</span><label class="collapse" for="c-39961594">[-]</label><label class="expand" for="c-39961594">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sort of the plot of the Douglas Adam&#x27;s books.<p><a href="https:&#x2F;&#x2F;hitchhikers.fandom.com&#x2F;wiki&#x2F;Earth" rel="nofollow">https:&#x2F;&#x2F;hitchhikers.fandom.com&#x2F;wiki&#x2F;Earth</a></div><br/></div></div></div></div></div></div></div></div><div id="39960560" class="c"><input type="checkbox" id="c-39960560" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960352">parent</a><span>|</span><a href="#39960449">prev</a><span>|</span><a href="#39960453">next</a><span>|</span><label class="collapse" for="c-39960560">[-]</label><label class="expand" for="c-39960560">[3 more]</label></div><br/><div class="children"><div class="content">With a sufficiently large chip and a sufficiently slow clock, sure.</div><br/><div id="39960606" class="c"><input type="checkbox" id="c-39960606" checked=""/><div class="controls bullet"><span class="by">wheybags</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960560">parent</a><span>|</span><a href="#39960453">next</a><span>|</span><label class="collapse" for="c-39960606">[-]</label><label class="expand" for="c-39960606">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Give me a lut large enough and an infinite period of time to execute, and I shall simulate the world&quot;</div><br/><div id="39961343" class="c"><input type="checkbox" id="c-39961343" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960606">parent</a><span>|</span><a href="#39960453">next</a><span>|</span><label class="collapse" for="c-39961343">[-]</label><label class="expand" for="c-39961343">[1 more]</label></div><br/><div class="children"><div class="content">“Every cycle”</div><br/></div></div></div></div></div></div><div id="39960432" class="c"><input type="checkbox" id="c-39960432" checked=""/><div class="controls bullet"><span class="by">robinduckett</span><span>|</span><a href="#39960237">root</a><span>|</span><a href="#39960352">parent</a><span>|</span><a href="#39961487">prev</a><span>|</span><a href="#39962554">next</a><span>|</span><label class="collapse" for="c-39960432">[-]</label><label class="expand" for="c-39960432">[1 more]</label></div><br/><div class="children"><div class="content">I like the Quantum BogoSort as a proof of this &#x2F;s</div><br/></div></div></div></div><div id="39962554" class="c"><input type="checkbox" id="c-39962554" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#39960237">parent</a><span>|</span><a href="#39960352">prev</a><span>|</span><a href="#39960252">next</a><span>|</span><label class="collapse" for="c-39962554">[-]</label><label class="expand" for="c-39962554">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not as bad for integer square root; you only need to store N^0.5 entries in a greater&#x2F;lesser-than lookup table: N^2 for all the answers N.  Feasible for 16-bit integers, maybe for 32-bit, not for 64-bit.</div><br/></div></div></div></div><div id="39960252" class="c"><input type="checkbox" id="c-39960252" checked=""/><div class="controls bullet"><span class="by">treprinum</span><span>|</span><a href="#39960237">prev</a><span>|</span><a href="#39963241">next</a><span>|</span><label class="collapse" for="c-39960252">[-]</label><label class="expand" for="c-39960252">[11 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you use the sequence 1 + 3 + 5 + ... + 2k + 1 to get the integer square root of any integer number? It&#x27;s basically the k of the nearest lower number to your number in this sequence.</div><br/><div id="39960485" class="c"><input type="checkbox" id="c-39960485" checked=""/><div class="controls bullet"><span class="by">maxcoder4</span><span>|</span><a href="#39960252">parent</a><span>|</span><a href="#39961253">next</a><span>|</span><label class="collapse" for="c-39960485">[-]</label><label class="expand" for="c-39960485">[3 more]</label></div><br/><div class="children"><div class="content">Can you explain your idea? Your algorithm is correct by definition, but doing this naively would be very slow (even for 32bit number). At this point it would be much faster to just binsearch it.</div><br/><div id="39960744" class="c"><input type="checkbox" id="c-39960744" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39960252">root</a><span>|</span><a href="#39960485">parent</a><span>|</span><a href="#39961253">next</a><span>|</span><label class="collapse" for="c-39960744">[-]</label><label class="expand" for="c-39960744">[2 more]</label></div><br/><div class="children"><div class="content">For an example of binsearch algo, I recently dipped into this while switching some code from floats to fixed point arithmetic (reducing overall wasm blob size)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;serprex&#x2F;openEtG&#x2F;blob&#x2F;2011007dec2616d1a24d3de6dd7cad93478711dd&#x2F;src&#x2F;rs&#x2F;src&#x2F;aieval.rs#L17">https:&#x2F;&#x2F;github.com&#x2F;serprex&#x2F;openEtG&#x2F;blob&#x2F;2011007dec2616d1a24d...</a><p>Tho I could probably save binary size more by importing Math.sqrt from JS</div><br/><div id="39963103" class="c"><input type="checkbox" id="c-39963103" checked=""/><div class="controls bullet"><span class="by">smcameron</span><span>|</span><a href="#39960252">root</a><span>|</span><a href="#39960744">parent</a><span>|</span><a href="#39961253">next</a><span>|</span><label class="collapse" for="c-39963103">[-]</label><label class="expand" for="c-39963103">[1 more]</label></div><br/><div class="children"><div class="content">Recently, I had reason to dig around for a fixed point square root algorithm and found this: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;comp.lang.c&#x2F;c&#x2F;IpwKbw0MAxw&#x2F;m&#x2F;N1xhe5n1rFoJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;comp.lang.c&#x2F;c&#x2F;IpwKbw0MAxw&#x2F;m&#x2F;N1xh...</a></div><br/></div></div></div></div></div></div><div id="39961253" class="c"><input type="checkbox" id="c-39961253" checked=""/><div class="controls bullet"><span class="by">tomatocracy</span><span>|</span><a href="#39960252">parent</a><span>|</span><a href="#39960485">prev</a><span>|</span><a href="#39960695">next</a><span>|</span><label class="collapse" for="c-39961253">[-]</label><label class="expand" for="c-39961253">[1 more]</label></div><br/><div class="children"><div class="content">Better might be to use the expansion (x+y)^2=x^2+2xy+y^2 along with the observation that in any base, the square root of a 2n-digit number is at most n digits, as in the common method for calculating a square root &quot;by hand&quot; with pen and paper. If you did this 8 bits at a time then you only need a lookup table for roots of 8bit numbers.</div><br/></div></div><div id="39960695" class="c"><input type="checkbox" id="c-39960695" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#39960252">parent</a><span>|</span><a href="#39961253">prev</a><span>|</span><a href="#39960312">next</a><span>|</span><label class="collapse" for="c-39960695">[-]</label><label class="expand" for="c-39960695">[3 more]</label></div><br/><div class="children"><div class="content">And you would iterate through that sequence? That&#x27;s exponential time in the bit length of the input...</div><br/><div id="39960801" class="c"><input type="checkbox" id="c-39960801" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#39960252">root</a><span>|</span><a href="#39960695">parent</a><span>|</span><a href="#39960312">next</a><span>|</span><label class="collapse" for="c-39960801">[-]</label><label class="expand" for="c-39960801">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sqrt(n) - 1 additions for the n you&#x27;re trying to get the integer square root of. Memoization would make it constant time for any lesser n than the greatest n you&#x27;ve done this for. For greater n it&#x27;s sqrt(new_big_n - prev_big_n) - 1 more additions to memoize.<p>You&#x27;re right this isn&#x27;t practical, but fun to think about. Good refresher for those out of school for a while.</div><br/><div id="39962276" class="c"><input type="checkbox" id="c-39962276" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#39960252">root</a><span>|</span><a href="#39960801">parent</a><span>|</span><a href="#39960312">next</a><span>|</span><label class="collapse" for="c-39962276">[-]</label><label class="expand" for="c-39962276">[1 more]</label></div><br/><div class="children"><div class="content">Subtle detail of complexity analysis: the input is of length log(n), so taking n^k steps for any positive number k is exponential time.</div><br/></div></div></div></div></div></div><div id="39960312" class="c"><input type="checkbox" id="c-39960312" checked=""/><div class="controls bullet"><span class="by">HPsquared</span><span>|</span><a href="#39960252">parent</a><span>|</span><a href="#39960695">prev</a><span>|</span><a href="#39963241">next</a><span>|</span><label class="collapse" for="c-39960312">[-]</label><label class="expand" for="c-39960312">[3 more]</label></div><br/><div class="children"><div class="content">And this is one of those &quot;embarrassingly parallel&quot; tasks.</div><br/><div id="39960922" class="c"><input type="checkbox" id="c-39960922" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#39960252">root</a><span>|</span><a href="#39960312">parent</a><span>|</span><a href="#39962287">prev</a><span>|</span><a href="#39963241">next</a><span>|</span><label class="collapse" for="c-39960922">[-]</label><label class="expand" for="c-39960922">[1 more]</label></div><br/><div class="children"><div class="content">Yes. On a desert island we can have the whole village construct this table for newton-raphson guesses.<p>Combined with a cutting tool attached to a worm drive we will precisely count our turns (big radius crank for extra precision!) and begin manufacture of slide rules. Can never have too many scales and this is just one we shall etch into them!</div><br/></div></div></div></div></div></div><div id="39963241" class="c"><input type="checkbox" id="c-39963241" checked=""/><div class="controls bullet"><span class="by">msarnoff</span><span>|</span><a href="#39960252">prev</a><span>|</span><a href="#39960870">next</a><span>|</span><label class="collapse" for="c-39963241">[-]</label><label class="expand" for="c-39963241">[2 more]</label></div><br/><div class="children"><div class="content">If you wanted to expand the definition of “processor” to electromechanical contraptions, the Friden SRQ could perform square roots using just additions and shifts, with not a single electronic component other than a motor. And since you had to position the decimal points manually, it would _technically_ be an integer operation…<p>Video: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;o44a1ao5h8w" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;o44a1ao5h8w</a></div><br/></div></div><div id="39960870" class="c"><input type="checkbox" id="c-39960870" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#39963241">prev</a><span>|</span><a href="#39966405">next</a><span>|</span><label class="collapse" for="c-39960870">[-]</label><label class="expand" for="c-39960870">[3 more]</label></div><br/><div class="children"><div class="content">You need to read down a bit, but the answer “ENIAC” is hilarious.</div><br/><div id="39965353" class="c"><input type="checkbox" id="c-39965353" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#39960870">parent</a><span>|</span><a href="#39960944">next</a><span>|</span><label class="collapse" for="c-39965353">[-]</label><label class="expand" for="c-39965353">[1 more]</label></div><br/><div class="children"><div class="content">So many people assume that everything that came before they were at school was primitive, and barely chugged along :)<p>A little reading shows the opposite. Most of our smart ideas were already used in 1940s&#x2F;50s&#x2F;60s computers, and are recycled on our fab new chips!! Pipelining, out of order exec, multiple cores, etc.<p>That old-time hardware might have been a bit &quot;chunky&quot; but the architectures used some very smart techniques.</div><br/></div></div><div id="39960944" class="c"><input type="checkbox" id="c-39960944" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39960870">parent</a><span>|</span><a href="#39965353">prev</a><span>|</span><a href="#39966405">next</a><span>|</span><label class="collapse" for="c-39960944">[-]</label><label class="expand" for="c-39960944">[1 more]</label></div><br/><div class="children"><div class="content">hardware engineer humor lol</div><br/></div></div></div></div><div id="39966405" class="c"><input type="checkbox" id="c-39966405" checked=""/><div class="controls bullet"><span class="by">jlarcombe</span><span>|</span><a href="#39960870">prev</a><span>|</span><a href="#39963404">next</a><span>|</span><label class="collapse" for="c-39966405">[-]</label><label class="expand" for="c-39966405">[1 more]</label></div><br/><div class="children"><div class="content">Semi-related and of interest to 6502 fans, exhaustive analysis of square root algorithms: <a href="https:&#x2F;&#x2F;github.com&#x2F;TobyLobster&#x2F;sqrt_test">https:&#x2F;&#x2F;github.com&#x2F;TobyLobster&#x2F;sqrt_test</a></div><br/></div></div><div id="39963404" class="c"><input type="checkbox" id="c-39963404" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#39966405">prev</a><span>|</span><a href="#39963696">next</a><span>|</span><label class="collapse" for="c-39963404">[-]</label><label class="expand" for="c-39963404">[1 more]</label></div><br/><div class="children"><div class="content">2 ^ (1&#x2F;2 * Log2(X)) = sqrt(X)<p>You can get a really really rough approximation if you replace Log2(x) with &#x27;count leading zeroes&#x27;.  With a better approximation of Log(2), you can get closer to the answer.</div><br/></div></div><div id="39963696" class="c"><input type="checkbox" id="c-39963696" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#39963404">prev</a><span>|</span><a href="#39961261">next</a><span>|</span><label class="collapse" for="c-39963696">[-]</label><label class="expand" for="c-39963696">[1 more]</label></div><br/><div class="children"><div class="content">ARM VFP has VSQRT<p><a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;dui0473&#x2F;m&#x2F;vfp-instructions&#x2F;vsqrt" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;dui0473&#x2F;m&#x2F;vfp-instru...</a></div><br/></div></div><div id="39961261" class="c"><input type="checkbox" id="c-39961261" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#39963696">prev</a><span>|</span><a href="#39961048">next</a><span>|</span><label class="collapse" for="c-39961261">[-]</label><label class="expand" for="c-39961261">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, most (all?) fixed point DSP&#x27;s have a square root instruction and&#x2F;or helper instructions.</div><br/></div></div><div id="39961048" class="c"><input type="checkbox" id="c-39961048" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#39961261">prev</a><span>|</span><a href="#39960724">next</a><span>|</span><label class="collapse" for="c-39961048">[-]</label><label class="expand" for="c-39961048">[10 more]</label></div><br/><div class="children"><div class="content">For an approximate (very rough) answer, as opposed to one accurate to the nearest integer, a right shift by half the number of bits of the leading 1’s position will do, and of course nearly every processor has a shift instruction. I’m not sure how often processors haven’t had something like FLO (Find Leading One) or FFS (Find First Set) instruction, those seem ubiquitous as well.<p>The super rough approximation for some uses can be approximately as good as an accurate answer. When you just need a decent starting place for some further Newton-Raphson iteration, for example. (Of course the right-shift trick is a nice way to seed a more accurate square root calculation. :P)</div><br/><div id="39961135" class="c"><input type="checkbox" id="c-39961135" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#39961048">parent</a><span>|</span><a href="#39962374">next</a><span>|</span><label class="collapse" for="c-39961135">[-]</label><label class="expand" for="c-39961135">[8 more]</label></div><br/><div class="children"><div class="content">Is this where the DOOM reference comes in? Somewhat famous Internet story by now featuring Carmack and a magic 32 bit number.</div><br/><div id="39961264" class="c"><input type="checkbox" id="c-39961264" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39961135">parent</a><span>|</span><a href="#39961223">next</a><span>|</span><label class="collapse" for="c-39961264">[-]</label><label class="expand" for="c-39961264">[4 more]</label></div><br/><div class="children"><div class="content">You mean <i>Quake 3</i> and fast inverse square root? 
No. And it wasn’t Carmack.
<a href="https:&#x2F;&#x2F;www.beyond3d.com&#x2F;content&#x2F;articles&#x2F;15&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.beyond3d.com&#x2F;content&#x2F;articles&#x2F;15&#x2F;</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root</a></div><br/><div id="39961448" class="c"><input type="checkbox" id="c-39961448" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39961264">parent</a><span>|</span><a href="#39961223">next</a><span>|</span><label class="collapse" for="c-39961448">[-]</label><label class="expand" for="c-39961448">[3 more]</label></div><br/><div class="children"><div class="content">I wondered about the name of that function: surely it isn&#x27;t <i>inverse</i> square root? That would be &quot;squared&quot;. It&#x27;s &quot;1 over square root&quot; or something. So down the rabbit hole to see if it was always called that. Yup, in Wikipedia articles at least, but the first paper seems to be by Jim Blinn in 1997, without the term in the title. So let&#x27;s read the paper... Frustratingly, although I <i>am</i> an IEEE member, and I did subscribe to Computer Graphics and Applications in 1997, it won&#x27;t let me read the paper without paying again. So curious to hear from folks knowledgeable in the space if this was a mis-naming that stuck or I&#x27;m confused about the meaning of &quot;inverse&quot;. In my universe we used inverse in the context of functions and their inverses, and &quot;invert&quot; in the context of binary values (1s compliment of x is also called x inverted). Never to describe reciprocal.</div><br/><div id="39961897" class="c"><input type="checkbox" id="c-39961897" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39961448">parent</a><span>|</span><a href="#39961787">next</a><span>|</span><label class="collapse" for="c-39961897">[-]</label><label class="expand" for="c-39961897">[1 more]</label></div><br/><div class="children"><div class="content">It was called &quot;inverse square root&quot; as it is just another practical &quot;layer&quot; on top of &quot;inverse&quot; which is just meant to mean multiplicative inverse.<p>This is the original Blinn 97 BTW.
<a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20130309073539&#x2F;http:&#x2F;&#x2F;rufus.hackish.org&#x2F;~rufus&#x2F;FPtricks.pdf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20130309073539&#x2F;http:&#x2F;&#x2F;rufus.hack...</a><p>This seems to have been common usage. I never really thought about it as it was just so normal to refer to reciprocal as &quot;inverse&quot; in this context.<p>&gt; In my universe we used inverse in the context of functions and their inverses<p>Yes but, the other type of inverse that is so fundamental to CS in general, and especially geometry is a matrix inverse, which is again a multiplicative inverse, so it&#x27;s not too surprising how this usage became assumed in many contexts.</div><br/></div></div><div id="39961787" class="c"><input type="checkbox" id="c-39961787" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39961448">parent</a><span>|</span><a href="#39961897">prev</a><span>|</span><a href="#39961223">next</a><span>|</span><label class="collapse" for="c-39961787">[-]</label><label class="expand" for="c-39961787">[1 more]</label></div><br/><div class="children"><div class="content">I’ve heard inverse used to mean reciprocal often enough. And it’s technically accurate - a reciprocal is a multiplicative inverse. The problem is mainly that “inverse” is ambiguous, especially in this particular case (an inverse square root is a square!), whereas “reciprocal” is clear and unambiguous. Online you can find lots of uses of inverse, and questions about inverse vs reciprocal. So yes reciprocal is the better, more clear term to use here, but “inverse” to mean reciprocal does happen.</div><br/></div></div></div></div></div></div><div id="39961223" class="c"><input type="checkbox" id="c-39961223" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39961135">parent</a><span>|</span><a href="#39961264">prev</a><span>|</span><a href="#39962374">next</a><span>|</span><label class="collapse" for="c-39961223">[-]</label><label class="expand" for="c-39961223">[3 more]</label></div><br/><div class="children"><div class="content">Not really, that’s a very clever trick used on floating point numbers, and does the approximate reciprocal square root.<p>This right-shift thing is far simpler, not very clever, doesn’t involve magic numbers, and is much more well known than the “Quake trick”. There are easy ways to see it. One would be that multiplying a number by itself approximately doubles the number of digits. Therefore halving the number of digits is approximately the square root. You can get more technical and precise by noting that FFS(n) =~ log2(n), and if you remember logs, you know that exp(log(n)&#x2F;2) = n^(1&#x2F;2), so shifting right by FFS(n)&#x2F;2 is just mathematically approximately a square root.</div><br/><div id="39962290" class="c"><input type="checkbox" id="c-39962290" checked=""/><div class="controls bullet"><span class="by">creato</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39961223">parent</a><span>|</span><a href="#39962374">next</a><span>|</span><label class="collapse" for="c-39962290">[-]</label><label class="expand" for="c-39962290">[2 more]</label></div><br/><div class="children"><div class="content">They are more closely related than you suggest. Both methods are using an approximation of log2 to get an initial guess. One gets it from &quot;FPS(n)&quot;, the other gets it from the floating point representation of n, where you can roughly find the log2(n) by looking at the exponent of n in the float representation. You can also use the mantissa to refine the guess further.</div><br/><div id="39963050" class="c"><input type="checkbox" id="c-39963050" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#39961048">root</a><span>|</span><a href="#39962290">parent</a><span>|</span><a href="#39962374">next</a><span>|</span><label class="collapse" for="c-39963050">[-]</label><label class="expand" for="c-39963050">[1 more]</label></div><br/><div class="children"><div class="content">They are related a little, around the log2 (exponent), I totally agree. I guess I figured the magic number subtraction that turns it into n^(-1&#x2F;2) is so wild that it puts the Quake trick in a bit of a different class. This right shift thing is a lot older and there’s probably a lineage of ideas from the right shift on integers to the Quake trick. I discovered another fun one on my own that is probably already well known in bit-math circles, but simply inverting the bits of a floating point exponent is a very rough approximation to the reciprocal, good for a Newton initial guess.</div><br/></div></div></div></div></div></div></div></div><div id="39962374" class="c"><input type="checkbox" id="c-39962374" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#39961048">parent</a><span>|</span><a href="#39961135">prev</a><span>|</span><a href="#39960724">next</a><span>|</span><label class="collapse" for="c-39962374">[-]</label><label class="expand" for="c-39962374">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact, FFS (and its generalization, FNS) is in CUDA: <a href="https:&#x2F;&#x2F;docs.nvidia.com&#x2F;cuda&#x2F;cuda-math-api&#x2F;index.html#group__CUDA__MATH__INTRINSIC__INT_1gaf1eb22243e29e0b7222adee8ae7d4e4" rel="nofollow">https:&#x2F;&#x2F;docs.nvidia.com&#x2F;cuda&#x2F;cuda-math-api&#x2F;index.html#group_...</a><p>Another nice CUDA hardware intrinsic I like is log2.</div><br/></div></div></div></div></div></div></div></div></div></body></html>