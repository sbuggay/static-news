<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722502852513" as="style"/><link rel="stylesheet" href="styles.css?v=1722502852513"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/">Crafting Interpreters with Rust: On Garbage Collection</a> <span class="domain">(<a href="https://www.tunglevo.com">www.tunglevo.com</a>)</span></div><div class="subtext"><span>amalinovic</span> | <span>84 comments</span></div><br/><div><div id="41122746" class="c"><input type="checkbox" id="c-41122746" checked=""/><div class="controls bullet"><span class="by">scott_s</span><span>|</span><a href="#41119515">next</a><span>|</span><label class="collapse" for="c-41122746">[-]</label><label class="expand" for="c-41122746">[5 more]</label></div><br/><div class="children"><div class="content">In case the author reads this: please explicitly cite all of Nystrom&#x27;s figures. A link is not enough.<p>Even with a citation, I&#x27;m not quite comfortable just reusing someone else&#x27;s figures so many times when they&#x27;re doing so much heavy lifting. But an explicit citation is the minimum.</div><br/><div id="41123477" class="c"><input type="checkbox" id="c-41123477" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122746">parent</a><span>|</span><a href="#41123301">next</a><span>|</span><label class="collapse" for="c-41123477">[-]</label><label class="expand" for="c-41123477">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the suggestion. I updated it with more explicit citations. After seeing your comment, I just looked around and saw that no license was given for the images.<p>I should probably draw my own.</div><br/><div id="41125441" class="c"><input type="checkbox" id="c-41125441" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41122746">root</a><span>|</span><a href="#41123477">parent</a><span>|</span><a href="#41123301">next</a><span>|</span><label class="collapse" for="c-41125441">[-]</label><label class="expand" for="c-41125441">[2 more]</label></div><br/><div class="children"><div class="content">The license is here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;munificent&#x2F;craftinginterpreters&#x2F;blob&#x2F;master&#x2F;LICENSE">https:&#x2F;&#x2F;github.com&#x2F;munificent&#x2F;craftinginterpreters&#x2F;blob&#x2F;mast...</a><p>Though now that I look at it, I apparently completely forgot to specify how the images should be licensed. Oops.<p>It&#x27;s not a big deal and I really appreciate you reading and writing about the book, but I would prefer to not have the images reused without attribution.</div><br/><div id="41127235" class="c"><input type="checkbox" id="c-41127235" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122746">root</a><span>|</span><a href="#41125441">parent</a><span>|</span><a href="#41123301">next</a><span>|</span><label class="collapse" for="c-41127235">[-]</label><label class="expand" for="c-41127235">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for writing the book! I&#x27;ve had an amazing experience tinkering with it over the years.<p>I see that the license now includes images. I was unsure of how to have proper attribution and had just a link to a particular section of the book containing the image. I&#x27;ve updated it with a link to your profile, and now I should also add a link to the license.</div><br/></div></div></div></div></div></div><div id="41123301" class="c"><input type="checkbox" id="c-41123301" checked=""/><div class="controls bullet"><span class="by">imachine1980_</span><span>|</span><a href="#41122746">parent</a><span>|</span><a href="#41123477">prev</a><span>|</span><a href="#41119515">next</a><span>|</span><label class="collapse" for="c-41123301">[-]</label><label class="expand" for="c-41123301">[1 more]</label></div><br/><div class="children"><div class="content">idk if he&#x2F;she change it, but i see the name big and center after each use.</div><br/></div></div></div></div><div id="41119515" class="c"><input type="checkbox" id="c-41119515" checked=""/><div class="controls bullet"><span class="by">jlewallen</span><span>|</span><a href="#41122746">prev</a><span>|</span><a href="#41120703">next</a><span>|</span><label class="collapse" for="c-41119515">[-]</label><label class="expand" for="c-41119515">[12 more]</label></div><br/><div class="children"><div class="content">Crafting Interpreters is such an amazing work.<p>There&#x27;s at least one other Rust implementation of lox that I know of (<a href="https:&#x2F;&#x2F;github.com&#x2F;tdp2110&#x2F;crafting-interpreters-rs">https:&#x2F;&#x2F;github.com&#x2F;tdp2110&#x2F;crafting-interpreters-rs</a>) (no unsafe)<p>It&#x27;s always interesting to see how different people approach the problems in their own language or relative isolation. I agree with others here, the real value of the original work lies in avoiding copy and paste.</div><br/><div id="41119937" class="c"><input type="checkbox" id="c-41119937" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119515">parent</a><span>|</span><a href="#41120703">next</a><span>|</span><label class="collapse" for="c-41119937">[-]</label><label class="expand" for="c-41119937">[11 more]</label></div><br/><div class="children"><div class="content">There are a whole pile of Lox implementations in Rust (as well as many other lanugages):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;munificent&#x2F;craftinginterpreters&#x2F;wiki&#x2F;Lox-Implementations#rust">https:&#x2F;&#x2F;github.com&#x2F;munificent&#x2F;craftinginterpreters&#x2F;wiki&#x2F;Lox-...</a></div><br/><div id="41120463" class="c"><input type="checkbox" id="c-41120463" checked=""/><div class="controls bullet"><span class="by">timsneath</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41119937">parent</a><span>|</span><a href="#41126963">next</a><span>|</span><label class="collapse" for="c-41120463">[-]</label><label class="expand" for="c-41120463">[9 more]</label></div><br/><div class="children"><div class="content">Lox must have the highest ratio of (implementations : production usage) of any language on the planet. And I mean that as the highest praise -- it&#x27;s proven a fantastic teaching language, and your book is infectious at encouraging others to jump in and follow along in various different languages.<p>I&#x27;ve also found the exercise of implementing Lox in another language as highly instructive in learning how to write idiomatic code in that language. I continue to learn more about the best way to express patterns as I work on my own implementation. I&#x27;d recommend the journey to any professional developer for this side-benefit alone.</div><br/><div id="41121535" class="c"><input type="checkbox" id="c-41121535" checked=""/><div class="controls bullet"><span class="by">stevekemp</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41120463">parent</a><span>|</span><a href="#41121692">next</a><span>|</span><label class="collapse" for="c-41121535">[-]</label><label class="expand" for="c-41121535">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   &gt; Lox must have the highest ratio of (implementations : 
   &gt; production usage) of any language on the planet.
</code></pre>
It&#x27;s probably up there, for sure!  But I&#x27;d guess that there are a million toy Lisp implementations, and more people are interested in writing a FORTH interpreter than actually using one in production.  So I&#x27;d guess if we tried to get statistics it wouldn&#x27;t be at the top.<p>Though there&#x27;s probably a similar claim to be made for the Monkey-language from Torsten Bell, via his books on compilers and interpreters.<p><a href="https:&#x2F;&#x2F;monkeylang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;monkeylang.org&#x2F;</a></div><br/></div></div><div id="41121692" class="c"><input type="checkbox" id="c-41121692" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41120463">parent</a><span>|</span><a href="#41121535">prev</a><span>|</span><a href="#41123148">next</a><span>|</span><label class="collapse" for="c-41121692">[-]</label><label class="expand" for="c-41121692">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Lox must have the highest ratio of (implementations : production usage) of any language on the planet.</i><p>Maybe! It&#x27;s definitely getting there. I suspect &quot;semi-arbitrary subset of C&quot; still has me beat but who knows for how much longer.</div><br/><div id="41123303" class="c"><input type="checkbox" id="c-41123303" checked=""/><div class="controls bullet"><span class="by">leftyspook</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41121692">parent</a><span>|</span><a href="#41123148">next</a><span>|</span><label class="collapse" for="c-41123303">[-]</label><label class="expand" for="c-41123303">[4 more]</label></div><br/><div class="children"><div class="content">All praise Bob!<p>On a more serious note, have you thought about trying to aim lightning at the same spot again and write another book about implementing something most programmers take for granted?</div><br/><div id="41123609" class="c"><input type="checkbox" id="c-41123609" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41123303">parent</a><span>|</span><a href="#41123148">next</a><span>|</span><label class="collapse" for="c-41123609">[-]</label><label class="expand" for="c-41123609">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve definitely thought about writing a third book. I don&#x27;t know if it would be about &quot;something most programmers take for granted&quot;. I&#x27;m more interested in writing about whatever happens to excite me the most at that time.</div><br/><div id="41125174" class="c"><input type="checkbox" id="c-41125174" checked=""/><div class="controls bullet"><span class="by">leftyspook</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41123609">parent</a><span>|</span><a href="#41123148">next</a><span>|</span><label class="collapse" for="c-41125174">[-]</label><label class="expand" for="c-41125174">[2 more]</label></div><br/><div class="children"><div class="content">I may be projecting, but I feel like the kind of person to get excited about crafting interpreters wod also get excited about crafting databases or OSes.</div><br/><div id="41125444" class="c"><input type="checkbox" id="c-41125444" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41125174">parent</a><span>|</span><a href="#41123148">next</a><span>|</span><label class="collapse" for="c-41125444">[-]</label><label class="expand" for="c-41125444">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but alas I don&#x27;t know enough about either of those to write those books.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41123148" class="c"><input type="checkbox" id="c-41123148" checked=""/><div class="controls bullet"><span class="by">diffxx</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41120463">parent</a><span>|</span><a href="#41121692">prev</a><span>|</span><a href="#41125978">next</a><span>|</span><label class="collapse" for="c-41123148">[-]</label><label class="expand" for="c-41123148">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d imagine cool is up there as well: <a href="https:&#x2F;&#x2F;nguyenthanhvuh.github.io&#x2F;class-compilers&#x2F;cool.html" rel="nofollow">https:&#x2F;&#x2F;nguyenthanhvuh.github.io&#x2F;class-compilers&#x2F;cool.html</a></div><br/></div></div><div id="41125978" class="c"><input type="checkbox" id="c-41125978" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41120463">parent</a><span>|</span><a href="#41123148">prev</a><span>|</span><a href="#41126963">next</a><span>|</span><label class="collapse" for="c-41125978">[-]</label><label class="expand" for="c-41125978">[1 more]</label></div><br/><div class="children"><div class="content">I think Brainfuck might be more widespread. :)</div><br/></div></div></div></div><div id="41126963" class="c"><input type="checkbox" id="c-41126963" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#41119515">root</a><span>|</span><a href="#41119937">parent</a><span>|</span><a href="#41120463">prev</a><span>|</span><a href="#41120703">next</a><span>|</span><label class="collapse" for="c-41126963">[-]</label><label class="expand" for="c-41126963">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s so many languages and implementations that this could be used as a new Programming Language Popularity Ranking, with a bias towards languages people want to use or learn :D.</div><br/></div></div></div></div></div></div><div id="41120703" class="c"><input type="checkbox" id="c-41120703" checked=""/><div class="controls bullet"><span class="by">ceronman</span><span>|</span><a href="#41119515">prev</a><span>|</span><a href="#41119421">next</a><span>|</span><label class="collapse" for="c-41120703">[-]</label><label class="expand" for="c-41120703">[2 more]</label></div><br/><div class="children"><div class="content">Nice article. A couple of years ago I also implemented Lox in Rust. And I faced the exact same issues that the author describes here, and I also ended up with a very similar implementation.<p>I also wrote a post about it: <a href="https:&#x2F;&#x2F;ceronman.com&#x2F;2021&#x2F;07&#x2F;22&#x2F;my-experience-crafting-an-interpreter-with-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ceronman.com&#x2F;2021&#x2F;07&#x2F;22&#x2F;my-experience-crafting-an-in...</a><p>I ended up having two implementations: One in purely safe Rust and another one with unsafe.<p>Note that if you&#x27;re interesting in the &quot;object manager&quot; approach mentioned, I did that in my safe implementation, you can take a look at <a href="https:&#x2F;&#x2F;github.com&#x2F;ceronman&#x2F;loxido">https:&#x2F;&#x2F;github.com&#x2F;ceronman&#x2F;loxido</a></div><br/><div id="41121634" class="c"><input type="checkbox" id="c-41121634" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41120703">parent</a><span>|</span><a href="#41119421">next</a><span>|</span><label class="collapse" for="c-41121634">[-]</label><label class="expand" for="c-41121634">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d read your article, and it was lovely. It nudged me to just go unsafe and implement some of the data structures from scratch.</div><br/></div></div></div></div><div id="41119421" class="c"><input type="checkbox" id="c-41119421" checked=""/><div class="controls bullet"><span class="by">jcdavis</span><span>|</span><a href="#41120703">prev</a><span>|</span><a href="#41124622">next</a><span>|</span><label class="collapse" for="c-41119421">[-]</label><label class="expand" for="c-41119421">[13 more]</label></div><br/><div class="children"><div class="content">Fun writeup. When I went through and implement the book in rust (<a href="https:&#x2F;&#x2F;github.com&#x2F;jcdavis&#x2F;rulox">https:&#x2F;&#x2F;github.com&#x2F;jcdavis&#x2F;rulox</a>), I just used Rc and never really solved the cycle issue.<p>I&#x27;ll +1 and say I highly recommend going through Crafting Interpreters, particularly as a way of building non-trivial programs in languages you are less familiar with - If you just follow the java&#x2F;C example you are tempted to lean into copy&#x2F;pasting the samples, but figuring things out in other languages is a great experience.<p>I spent a longass time tracking down an issue with how the reference interpreter implementation defines tokens: <a href="https:&#x2F;&#x2F;github.com&#x2F;munificent&#x2F;craftinginterpreters&#x2F;issues&#x2F;1154">https:&#x2F;&#x2F;github.com&#x2F;munificent&#x2F;craftinginterpreters&#x2F;issues&#x2F;11...</a> which was frustrating but good debugging practice.</div><br/><div id="41119598" class="c"><input type="checkbox" id="c-41119598" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#41119421">parent</a><span>|</span><a href="#41120128">next</a><span>|</span><label class="collapse" for="c-41119598">[-]</label><label class="expand" for="c-41119598">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you just follow the java&#x2F;C example you are tempted to lean into copy&#x2F;pasting the samples, but figuring things out in other languages is a great experience.<p>I&#x27;ll echo this recommendation.<p>I haven&#x27;t gone through Crafting Interpreters yet (it&#x27;s on the bookshelf) but I did go through a big chunk of Building Git and instead of Ruby I did it in Rust, to get back into the language and go a little deeper.<p>It was really great and it gave me a lot more than if I&#x27;d just copy paste the code as you say.</div><br/></div></div><div id="41120128" class="c"><input type="checkbox" id="c-41120128" checked=""/><div class="controls bullet"><span class="by">ghosty141</span><span>|</span><a href="#41119421">parent</a><span>|</span><a href="#41119598">prev</a><span>|</span><a href="#41120561">next</a><span>|</span><label class="collapse" for="c-41120128">[-]</label><label class="expand" for="c-41120128">[10 more]</label></div><br/><div class="children"><div class="content">My only issue with Crafting Interpreters is that it relies too much on writing code and then explaining it instead of getting the concepts across first and then providing the code. Another thing I disliked was some code was structured in a way that it would go well with concepts that came further down the implementation which can lead to confusion since it seems overcomplicated&#x2F;overabstracted at first.</div><br/><div id="41121835" class="c"><input type="checkbox" id="c-41121835" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41120128">parent</a><span>|</span><a href="#41122777">next</a><span>|</span><label class="collapse" for="c-41121835">[-]</label><label class="expand" for="c-41121835">[3 more]</label></div><br/><div class="children"><div class="content">One of the biggest challenges with writing is linearizing: deciding what order to present the material so that it makes the most sense.<p>There&#x27;s really no perfect solution. Some readers prefer bottom up where they are given individual pieces they can understand which then get composed. Others prefer top down where they are given the high level problem being solved in terms of intermediate steps which then get incrementally defined. Some want to see code first so that they have something concrete to hang concepts off of. Others want concepts first and then to see the code as an illustration of it.<p>This is made even harder with Crafting Interpreters because the book&#x27;s central conceit is that every line of code in the interpreters is shown in the book. There&#x27;s nothing left to the reader. And, also, the book tries to give the user a program they can compile and run as often as possible as they work through things.<p>I did the best I could, but there are definitely some places where it&#x27;s really hard to figure out a good order. Sometimes the book explicitly says &quot;sorry, this won&#x27;t make sense but bear with me and we&#x27;ll circle back&quot;.<p>Also, at the macro structure, the entire book is organized into two parts where the first one is higher-level and more concept driven and then the second part circles all the way back to build the entire language from scratch again but at a much lower level of abstraction.<p>I appreciate your feedback. It&#x27;s a hard problem and a skill I&#x27;m always trying to improve.</div><br/><div id="41124688" class="c"><input type="checkbox" id="c-41124688" checked=""/><div class="controls bullet"><span class="by">liveranga</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41121835">parent</a><span>|</span><a href="#41122777">next</a><span>|</span><label class="collapse" for="c-41124688">[-]</label><label class="expand" for="c-41124688">[2 more]</label></div><br/><div class="children"><div class="content">Just to throw a positive word out there from one of the quiet majority of your readers, I think you absolutely nailed it with Crafting Interpreters.<p>It&#x27;s by far the best introductory book on this topic I&#x27;ve come across yet.  It&#x27;s a fun read and completely demystifies the &quot;magic&quot; of how interpreters work.</div><br/><div id="41125422" class="c"><input type="checkbox" id="c-41125422" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41124688">parent</a><span>|</span><a href="#41122777">next</a><span>|</span><label class="collapse" for="c-41125422">[-]</label><label class="expand" for="c-41125422">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! :D</div><br/></div></div></div></div></div></div><div id="41122777" class="c"><input type="checkbox" id="c-41122777" checked=""/><div class="controls bullet"><span class="by">scott_s</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41120128">parent</a><span>|</span><a href="#41121835">prev</a><span>|</span><a href="#41121002">next</a><span>|</span><label class="collapse" for="c-41122777">[-]</label><label class="expand" for="c-41122777">[1 more]</label></div><br/><div class="children"><div class="content">I <i>love</i> the code-first approach. It was a revelation to me when I first read Mark Pilgrim&#x27;s Dive Into Python (<a href="https:&#x2F;&#x2F;diveintopython3.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;diveintopython3.net&#x2F;</a>).</div><br/></div></div><div id="41121002" class="c"><input type="checkbox" id="c-41121002" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41120128">parent</a><span>|</span><a href="#41122777">prev</a><span>|</span><a href="#41120561">next</a><span>|</span><label class="collapse" for="c-41121002">[-]</label><label class="expand" for="c-41121002">[5 more]</label></div><br/><div class="children"><div class="content">My minor nit pick is that it uses mostly the Java language to implement a Java-like language. What have we gained? Surely something Python-like in C would be more rewarding, one would be gaining a level of abstraction.</div><br/><div id="41121777" class="c"><input type="checkbox" id="c-41121777" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41121002">parent</a><span>|</span><a href="#41120561">next</a><span>|</span><label class="collapse" for="c-41121777">[-]</label><label class="expand" for="c-41121777">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Surely something Python-like in C would be more rewarding, one would be gaining a level of abstraction.</i><p>That&#x27;s the second half of the book.</div><br/><div id="41122585" class="c"><input type="checkbox" id="c-41122585" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41121777">parent</a><span>|</span><a href="#41120561">next</a><span>|</span><label class="collapse" for="c-41122585">[-]</label><label class="expand" for="c-41122585">[3 more]</label></div><br/><div class="children"><div class="content">My apologies, that does indeed seem like a reasonable way of doing it.</div><br/><div id="41125447" class="c"><input type="checkbox" id="c-41125447" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41122585">parent</a><span>|</span><a href="#41120561">next</a><span>|</span><label class="collapse" for="c-41125447">[-]</label><label class="expand" for="c-41125447">[2 more]</label></div><br/><div class="children"><div class="content">Also, I should note that even in the first half of the book, the language isn&#x27;t Java-like. It has Java-ish syntax, but the semantics are much closer to JavaScript&#x2F;Python&#x2F;Lua.<p>In the first half, what we gain from implementing it in Java is mostly the garbage collector. The rest of the static and runtime semantics basically have to be implemented from scratch on top of the JVM.</div><br/><div id="41126731" class="c"><input type="checkbox" id="c-41126731" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#41119421">root</a><span>|</span><a href="#41125447">parent</a><span>|</span><a href="#41120561">next</a><span>|</span><label class="collapse" for="c-41126731">[-]</label><label class="expand" for="c-41126731">[1 more]</label></div><br/><div class="children"><div class="content">There is significance coverage of OOP features, hence my Java-like comment. I would have personally left OOP out for a beginner book, it isn&#x27;t really fundamental. Another advantage to using Java in the first half, could be to use Java closures to implement Lox closures.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41120561" class="c"><input type="checkbox" id="c-41120561" checked=""/><div class="controls bullet"><span class="by">Dowwie</span><span>|</span><a href="#41119421">parent</a><span>|</span><a href="#41120128">prev</a><span>|</span><a href="#41124622">next</a><span>|</span><label class="collapse" for="c-41120561">[-]</label><label class="expand" for="c-41120561">[1 more]</label></div><br/><div class="children"><div class="content">did you not want anyone to ever find rulox on github?  it has no descriptive information about it in the repo</div><br/></div></div></div></div><div id="41124622" class="c"><input type="checkbox" id="c-41124622" checked=""/><div class="controls bullet"><span class="by">harpiaharpyja</span><span>|</span><a href="#41119421">prev</a><span>|</span><a href="#41122337">next</a><span>|</span><label class="collapse" for="c-41124622">[-]</label><label class="expand" for="c-41124622">[2 more]</label></div><br/><div class="children"><div class="content">I did something very similar to this myself. My GC implementation was pretty heavily inspired by manishearth&#x27;s Rust GC.<p>My swing at the Crafting Intepreters in Rust can be found here: <a href="https:&#x2F;&#x2F;github.com&#x2F;mwerezak&#x2F;sphinx-lang">https:&#x2F;&#x2F;github.com&#x2F;mwerezak&#x2F;sphinx-lang</a><p>Although, at the time I was really interested in Lua&#x27;s syntax so for extra credit I designed a completely different syntax for Lox closer to Lua&#x27;s.<p>I&#x27;d love to revisit this project sometime and implement a register-based VM similar to Lua&#x27;s.</div><br/><div id="41127257" class="c"><input type="checkbox" id="c-41127257" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41124622">parent</a><span>|</span><a href="#41122337">next</a><span>|</span><label class="collapse" for="c-41127257">[-]</label><label class="expand" for="c-41127257">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing! That&#x27;s a much more interesting project compared to mine xD. I had the intuition that rust-gc could be implemented in a simpler fashion by not being generic. Glad to see someone actually had it done.</div><br/></div></div></div></div><div id="41122337" class="c"><input type="checkbox" id="c-41122337" checked=""/><div class="controls bullet"><span class="by">kaspermarstal</span><span>|</span><a href="#41124622">prev</a><span>|</span><a href="#41123171">next</a><span>|</span><label class="collapse" for="c-41122337">[-]</label><label class="expand" for="c-41122337">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Don’t ask me about covariance since I honestly don’t know the answer. I recommend reading the section on subtyping and variance and The Rustonomicon. I went through them a few times but still don’t entirely get all the details. Then, we can define each type of object like so:<p>Haha this is gold. We ALL do this ALL the time.</div><br/><div id="41124578" class="c"><input type="checkbox" id="c-41124578" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122337">parent</a><span>|</span><a href="#41123171">next</a><span>|</span><label class="collapse" for="c-41124578">[-]</label><label class="expand" for="c-41124578">[5 more]</label></div><br/><div class="children"><div class="content">haha, glad to know that I&#x27;m not the only one</div><br/><div id="41125454" class="c"><input type="checkbox" id="c-41125454" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41122337">root</a><span>|</span><a href="#41124578">parent</a><span>|</span><a href="#41126466">next</a><span>|</span><label class="collapse" for="c-41125454">[-]</label><label class="expand" for="c-41125454">[3 more]</label></div><br/><div class="children"><div class="content">I get tripped up by variance too and thinking about that stuff is literally my job. If it helps, I wrote a blog post recently about Go&#x27;s type system and it happens to touch in variance in a way that might help it click:<p><a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2023&#x2F;10&#x2F;19&#x2F;does-go-have-subtyping&#x2F;" rel="nofollow">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2023&#x2F;10&#x2F;19&#x2F;does-go-have-s...</a></div><br/><div id="41127271" class="c"><input type="checkbox" id="c-41127271" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122337">root</a><span>|</span><a href="#41125454">parent</a><span>|</span><a href="#41127105">next</a><span>|</span><label class="collapse" for="c-41127271">[-]</label><label class="expand" for="c-41127271">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing. I&#x27;ve enjoyed every single piece of your writing so far. This will be in the arsenal of materials I&#x27;ll use when I again get confused about variance.</div><br/></div></div><div id="41127105" class="c"><input type="checkbox" id="c-41127105" checked=""/><div class="controls bullet"><span class="by">spinningslate</span><span>|</span><a href="#41122337">root</a><span>|</span><a href="#41125454">parent</a><span>|</span><a href="#41127271">prev</a><span>|</span><a href="#41126466">next</a><span>|</span><label class="collapse" for="c-41127105">[-]</label><label class="expand" for="c-41127105">[1 more]</label></div><br/><div class="children"><div class="content">The very first sentence of that article got me excited:<p>&gt;I’ve been noodling on a static type system for my current hobby language.<p>As an inveterate language tinkerer for decades, Crafting Interpreters is like the intersection of Class A narcotic addiction, Feynman level understanding and religious enlightenment.  It&#x27;s in my top 3 favourite books of all time.<p>If you were to &#x2F;happen&#x2F; to write an extension&#x2F;follow up book that addressed static typing, then I can personally guarantee at least one sale.<p>Independent of that, thanks for the work as it stands.  My copy is healthily dog-eared and still gets lugged around on holidays for refresh reading.</div><br/></div></div></div></div><div id="41126466" class="c"><input type="checkbox" id="c-41126466" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41122337">root</a><span>|</span><a href="#41124578">parent</a><span>|</span><a href="#41125454">prev</a><span>|</span><a href="#41123171">next</a><span>|</span><label class="collapse" for="c-41126466">[-]</label><label class="expand" for="c-41126466">[1 more]</label></div><br/><div class="children"><div class="content">Definitely not the only one. I am not a stupid person*, but every single time I read the section on variance in the Nomicon I feel like an utter moron.<p>*source: trust me bro</div><br/></div></div></div></div></div></div><div id="41123171" class="c"><input type="checkbox" id="c-41123171" checked=""/><div class="controls bullet"><span class="by">nestorD</span><span>|</span><a href="#41122337">prev</a><span>|</span><a href="#41119887">next</a><span>|</span><label class="collapse" for="c-41123171">[-]</label><label class="expand" for="c-41123171">[1 more]</label></div><br/><div class="children"><div class="content">Note that there is quite a bit of thinking and available implementations of GC implementations available in Rust: <a href="https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2021&#x2F;04&#x2F;05&#x2F;a-tour-of-safe-tracing-gc-designs-in-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2021&#x2F;04&#x2F;05&#x2F;a-tour-of-safe...</a></div><br/></div></div><div id="41119887" class="c"><input type="checkbox" id="c-41119887" checked=""/><div class="controls bullet"><span class="by">samsartor</span><span>|</span><a href="#41123171">prev</a><span>|</span><a href="#41124205">next</a><span>|</span><label class="collapse" for="c-41119887">[-]</label><label class="expand" for="c-41119887">[1 more]</label></div><br/><div class="children"><div class="content">I have run into a lot of similar problems writing a state management framework for Rust (wip at <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;samsartor&#x2F;hornpipe" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;samsartor&#x2F;hornpipe</a>) and at one point despaired that I would have to abandon Rust and make a whole new reactive language. But the last couple years I&#x27;ve got it working really nicely with weak references and software transactional memory. Every reference is `Copy + Send + Sync + &#x27;static`. And you can mutate objects by having a transaction make a local bitwise copy, which will get atomically merged and swapped on commit. The old copy gets kept around for undo&#x2F;redo purposes. I&#x27;ve still got a boatload of algorithmic puzzles to solve to provide all the MVP features, which will take a while because it isn&#x27;t my full-time job. But the details seem technically sound.<p>I did write a blog post about some of my design thoughts, although it doesn&#x27;t dig into the technical guts: <a href="https:&#x2F;&#x2F;samsartor.com&#x2F;guis-3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;samsartor.com&#x2F;guis-3&#x2F;</a></div><br/></div></div><div id="41124205" class="c"><input type="checkbox" id="c-41124205" checked=""/><div class="controls bullet"><span class="by">ajeetdsouza</span><span>|</span><a href="#41119887">prev</a><span>|</span><a href="#41121276">next</a><span>|</span><label class="collapse" for="c-41124205">[-]</label><label class="expand" for="c-41124205">[2 more]</label></div><br/><div class="children"><div class="content">This is really well-written!<p>Shameless plug: you may want to check out Loxcraft: <a href="https:&#x2F;&#x2F;github.com&#x2F;ajeetdsouza&#x2F;loxcraft">https:&#x2F;&#x2F;github.com&#x2F;ajeetdsouza&#x2F;loxcraft</a><p>I too followed the path of &quot;ignore safe Rust for maximum performance&quot;. It got pretty close to the C version, even beating it on some benchmarks.</div><br/><div id="41124554" class="c"><input type="checkbox" id="c-41124554" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41124205">parent</a><span>|</span><a href="#41121276">next</a><span>|</span><label class="collapse" for="c-41124554">[-]</label><label class="expand" for="c-41124554">[1 more]</label></div><br/><div class="children"><div class="content">Nice, thanks for sharing. Definitely gonna look into how you do it, I couldn&#x27;t get as close to clox like you did</div><br/></div></div></div></div><div id="41121276" class="c"><input type="checkbox" id="c-41121276" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#41124205">prev</a><span>|</span><a href="#41120860">next</a><span>|</span><label class="collapse" for="c-41121276">[-]</label><label class="expand" for="c-41121276">[17 more]</label></div><br/><div class="children"><div class="content">&gt; How much memory is used for the stack and when it is freed can always be determined at compile-time.<p>Technically, not always. You can allocate on the stack at runtime, see &quot;alloca&quot; in C.<p>But is alloca even that useful in practice? I struggle to find a good example.</div><br/><div id="41122743" class="c"><input type="checkbox" id="c-41122743" checked=""/><div class="controls bullet"><span class="by">ozgrakkurt</span><span>|</span><a href="#41121276">parent</a><span>|</span><a href="#41122205">next</a><span>|</span><label class="collapse" for="c-41122743">[-]</label><label class="expand" for="c-41122743">[1 more]</label></div><br/><div class="children"><div class="content">This was used in linux kernel and they were removing it later because it was a huge pain as far as I can remember. Seems like it causes problems because entire system is built assuming stack&#x2F;heap work in a certain way.</div><br/></div></div><div id="41122205" class="c"><input type="checkbox" id="c-41122205" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41121276">parent</a><span>|</span><a href="#41122743">prev</a><span>|</span><a href="#41121334">next</a><span>|</span><label class="collapse" for="c-41122205">[-]</label><label class="expand" for="c-41122205">[2 more]</label></div><br/><div class="children"><div class="content">Oh right. I read about this once or twice and have never looked at it again. I&#x27;ve made the (wrong) assumption that this function needs some compile-time help. Is it all done at runtime? Or does that depend on the actual C implementation?</div><br/><div id="41124378" class="c"><input type="checkbox" id="c-41124378" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41122205">parent</a><span>|</span><a href="#41121334">next</a><span>|</span><label class="collapse" for="c-41124378">[-]</label><label class="expand" for="c-41124378">[1 more]</label></div><br/><div class="children"><div class="content">Stack allocation is always done at runtime. Baring special optimizations, the CPU and the code work together to (stack grows downward) decrement the CPU stack pointer register. This register keeps track of where the bottom of the stack is.<p>What is done at compile time by the compiler, is calculating the amount to decrement the CPU stack pointer register at runtime for every stack variables.<p>The compiler and alloca must work together, because optimization can easily break something here. For example, when a function return, the stack pointer register better be restored properly. Furthermore, in Rust you must not forget to call Drop::drop() for all types that have such a destructor.</div><br/></div></div></div></div><div id="41121334" class="c"><input type="checkbox" id="c-41121334" checked=""/><div class="controls bullet"><span class="by">tick_tock_tick</span><span>|</span><a href="#41121276">parent</a><span>|</span><a href="#41122205">prev</a><span>|</span><a href="#41120860">next</a><span>|</span><label class="collapse" for="c-41121334">[-]</label><label class="expand" for="c-41121334">[13 more]</label></div><br/><div class="children"><div class="content">I mean it&#x27;s basically the fastest allocation possible. It&#x27;s amazing under a very very unique situation.<p>- you need a lot of memory<p>- it needs to be as fast as possible<p>- it&#x27;s a leaf function that can never call another function<p>99.9% of the time those aren&#x27;t all true.</div><br/><div id="41124288" class="c"><input type="checkbox" id="c-41124288" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121334">parent</a><span>|</span><a href="#41121369">next</a><span>|</span><label class="collapse" for="c-41124288">[-]</label><label class="expand" for="c-41124288">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another reason: we need to do string stuff and we absolutely can&#x27;t stall. Malloc always has some chance of stalling due to heap fragmentation. The leaf function requirement is also not necessary. You just have to make sure you don&#x27;t alloca too much memory given how much is remaining on the stack and roughly how much memory you know subsequent calls will take.<p>It&#x27;s not all that much worse than using a huge, static stack allocation. In fact, there are cases where alloca is safer since you can take into account how much stack memory you already have available before incrementing the stack pointer.</div><br/><div id="41125762" class="c"><input type="checkbox" id="c-41125762" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41124288">parent</a><span>|</span><a href="#41121369">next</a><span>|</span><label class="collapse" for="c-41125762">[-]</label><label class="expand" for="c-41125762">[1 more]</label></div><br/><div class="children"><div class="content">With a huge static stack allocation the stack check must be done within a parent function instead of within the same function.<p>In any case it is up to you to do the stack check. Though alloca can easily be wrapped by a function running the check.<p>In Rust I would write a check stack function that takes a function&#x2F;closure as parameters. Within the closure, you are guaranteed to have at least the requested  stack space.<p>The compiler will inline it all nicely, while preserving the semantic of the stack allocation.</div><br/></div></div></div></div><div id="41121369" class="c"><input type="checkbox" id="c-41121369" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121334">parent</a><span>|</span><a href="#41124288">prev</a><span>|</span><a href="#41120860">next</a><span>|</span><label class="collapse" for="c-41121369">[-]</label><label class="expand" for="c-41121369">[10 more]</label></div><br/><div class="children"><div class="content">Why does it have to be a leaf function?</div><br/><div id="41121421" class="c"><input type="checkbox" id="c-41121421" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121369">parent</a><span>|</span><a href="#41120860">next</a><span>|</span><label class="collapse" for="c-41121421">[-]</label><label class="expand" for="c-41121421">[9 more]</label></div><br/><div class="children"><div class="content">So the massive stack grab isn&#x27;t permanent.<p>Conceptually, if the compiler could just inline all of the child calls, it&#x27;s fine. But if this call won&#x27;t return for a long time, or may be called again (even worse). You&#x27;re setting aside stack that you&#x27;ll never get back. Which is a memory leak, and your program will crash.</div><br/><div id="41123881" class="c"><input type="checkbox" id="c-41123881" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121421">parent</a><span>|</span><a href="#41123920">next</a><span>|</span><label class="collapse" for="c-41123881">[-]</label><label class="expand" for="c-41123881">[1 more]</label></div><br/><div class="children"><div class="content">The stack grab is as permanent as any other stack variable. There is nothing special about it. The only difference is that you can decide at runtime how much to add to the current stack frame.</div><br/></div></div><div id="41123920" class="c"><input type="checkbox" id="c-41123920" checked=""/><div class="controls bullet"><span class="by">mypalmike</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121421">parent</a><span>|</span><a href="#41123881">prev</a><span>|</span><a href="#41121548">next</a><span>|</span><label class="collapse" for="c-41123920">[-]</label><label class="expand" for="c-41123920">[5 more]</label></div><br/><div class="children"><div class="content">If the memory&#x27;s lifetime correctly coincides with the function (which is why you might use alloca in the first place), I don&#x27;t see how this would be a memory leak nor why it would lead to a crash. Maybe on systems which limit stack size...?</div><br/><div id="41124842" class="c"><input type="checkbox" id="c-41124842" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41123920">parent</a><span>|</span><a href="#41121548">next</a><span>|</span><label class="collapse" for="c-41124842">[-]</label><label class="expand" for="c-41124842">[4 more]</label></div><br/><div class="children"><div class="content">just don&#x27;t do this.<p><pre><code>  int a(){
    void* mem = allocal(some_number);
    b();
  }

  int b(){
    a();
  }
</code></pre>
if a() is a leaf (or can be trivially inlined) it&#x27;s fine!<p>on the other hand, if a() calls something else, that&#x27;s complicated, it&#x27;s way way harder to figure out why you&#x27;re crashing. I think you&#x27;ll segfault as a() eventually overwrites malloc&#x27;ed memory. but different systems are going to have different characteristics.<p>It&#x27;s not that you can&#x27;t, you just have to be real damn smart and make sure no one ever messes with your code.<p>or you can just make sure it&#x27;s a leaf. much easier rule, much easier to explain.</div><br/><div id="41125722" class="c"><input type="checkbox" id="c-41125722" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41124842">parent</a><span>|</span><a href="#41121548">next</a><span>|</span><label class="collapse" for="c-41125722">[-]</label><label class="expand" for="c-41125722">[3 more]</label></div><br/><div class="children"><div class="content">Your example behaves the same with or without alloca.<p>It will run until it runs out of stack. Or it might just run forever because the compiler optimized it as an infinite loop.<p>In any case, same behavior.</div><br/><div id="41125778" class="c"><input type="checkbox" id="c-41125778" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41125722">parent</a><span>|</span><a href="#41121548">next</a><span>|</span><label class="collapse" for="c-41125778">[-]</label><label class="expand" for="c-41125778">[2 more]</label></div><br/><div class="children"><div class="content">True. How would you modify it to get the point across?<p>Or am I crazy, and there is no point to being careful with alloca?</div><br/><div id="41125898" class="c"><input type="checkbox" id="c-41125898" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41125778">parent</a><span>|</span><a href="#41121548">next</a><span>|</span><label class="collapse" for="c-41125898">[-]</label><label class="expand" for="c-41125898">[1 more]</label></div><br/><div class="children"><div class="content">Maybe if alloca is used with a runtime value uncapped, a user could then trigger a stack overflow with too big of an allocation. This is the same problem when allocating on the heap, with the difference that the heap is a few order of magnitude larger.<p>That is really the only difference between `in foo[...N] = ...N` and alloca(n). alloca works with a value computed at runtime. And this value could be from an input.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41121548" class="c"><input type="checkbox" id="c-41121548" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121421">parent</a><span>|</span><a href="#41123920">prev</a><span>|</span><a href="#41120860">next</a><span>|</span><label class="collapse" for="c-41121548">[-]</label><label class="expand" for="c-41121548">[2 more]</label></div><br/><div class="children"><div class="content">That reasoning leads me to conclude the function should be short lived or the memory in use by all child functions, rather than it has to be a leaf function?</div><br/><div id="41122702" class="c"><input type="checkbox" id="c-41122702" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41121276">root</a><span>|</span><a href="#41121548">parent</a><span>|</span><a href="#41120860">next</a><span>|</span><label class="collapse" for="c-41122702">[-]</label><label class="expand" for="c-41122702">[1 more]</label></div><br/><div class="children"><div class="content">yeah. Leaf is a good rule of thumb, but if you need a little helper to do something it&#x27;s generally fine.<p>you really do need confidence the little helper can be fully inlined. if the helper is out of your control, and someone greatly expands its responsibility, it can suck.<p>So, yeah, effectively a leaf.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41120860" class="c"><input type="checkbox" id="c-41120860" checked=""/><div class="controls bullet"><span class="by">Daffodils</span><span>|</span><a href="#41121276">prev</a><span>|</span><a href="#41118791">next</a><span>|</span><label class="collapse" for="c-41120860">[-]</label><label class="expand" for="c-41120860">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to share that the Build your own Interpreters challenge on CodeCrafters is based on the Crafting Interpreters book and is free at the moment.<p>Link: <a href="https:&#x2F;&#x2F;app.codecrafters.io&#x2F;courses&#x2F;interpreter&#x2F;overview">https:&#x2F;&#x2F;app.codecrafters.io&#x2F;courses&#x2F;interpreter&#x2F;overview</a><p>(Disclaimer: I work for CodeCrafters, and built this challenge).</div><br/></div></div><div id="41118791" class="c"><input type="checkbox" id="c-41118791" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41120860">prev</a><span>|</span><a href="#41122472">next</a><span>|</span><label class="collapse" for="c-41118791">[-]</label><label class="expand" for="c-41118791">[11 more]</label></div><br/><div class="children"><div class="content">The other major issue with the Deref implementation is that `&amp;mut` needs to be an exclusive reference, and if you&#x27;re doing mark&#x2F;sweep of GC objects via references you break that invariant if you hold any `&amp;mut` across a GC call and are causing UB. In practice this probably doesn&#x27;t affect your program, but I suspect Miri would yell at you and there&#x27;s the off chance the compiler gets really tricky with inlining somewhere and you are inflicted with horrible pain.</div><br/><div id="41118853" class="c"><input type="checkbox" id="c-41118853" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41118791">parent</a><span>|</span><a href="#41122472">next</a><span>|</span><label class="collapse" for="c-41118853">[-]</label><label class="expand" for="c-41118853">[10 more]</label></div><br/><div class="children"><div class="content">Yeah true, this breaks all sorts of contracts that we have with Rust xD. But if mark-and-sweep is implemented correctly, then no reference is ever held across the GC. Though, there&#x27;s gonna be lots of pain debugging when you got it wrong, speaking from experience.<p>Do you have any resources about Rust inlining and the issues it might cause? I&#x27;d love to read more about that.</div><br/><div id="41120310" class="c"><input type="checkbox" id="c-41120310" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41118853">parent</a><span>|</span><a href="#41119096">next</a><span>|</span><label class="collapse" for="c-41120310">[-]</label><label class="expand" for="c-41120310">[3 more]</label></div><br/><div class="children"><div class="content">I would be really careful with those deref methods. They return references, not pointers, which means you need to follow the Rust rules:<p>- You can have any number of simultaneous readers,<p>- <i>Or</i> one writer and no readers.<p>- <i>But</i> if you ever break these rules, the world may burn.<p>Using unsafe and violating these rules is one of the cases where the Rust compiler can inflict worlds of misery: Incorrect code generation, CPUs seeing different versions of the same memory location, etc., depending on the exact context. Once you use &quot;unsafe&quot; and break the rules, Rust can be more dangerous than C. Rust even reserves the right to generate code using &quot;noalias&quot; (except doing so often triggers LLVM bugs, so it&#x27;s usually turned off).<p>&quot;Undefined behavior&quot; means &quot;anything at all can happen, and some of it is deeply weird and awful and counterintuitive.&quot;<p>You could enforce the borrowing rules at runtime by using std::cell::Cell in your heap objects, which is exactly what it exists for. Or you could package everything inside a tiny core module and audit it extremely carefully.</div><br/><div id="41124381" class="c"><input type="checkbox" id="c-41124381" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41120310">parent</a><span>|</span><a href="#41120642">next</a><span>|</span><label class="collapse" for="c-41124381">[-]</label><label class="expand" for="c-41124381">[1 more]</label></div><br/><div class="children"><div class="content">You would probably want to use RefCell instead of Cell. It allows you to safely upgrade into a &amp;mut using only a constant reference to RefCell, but it dynamically verifies that it&#x27;s actually safe using ref counting. The ref counting also isn&#x27;t too expensive since it isn&#x27;t atomic.</div><br/></div></div><div id="41120642" class="c"><input type="checkbox" id="c-41120642" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41120310">parent</a><span>|</span><a href="#41124381">prev</a><span>|</span><a href="#41119096">next</a><span>|</span><label class="collapse" for="c-41120642">[-]</label><label class="expand" for="c-41120642">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware of all the issues mentioned. But for this particular project, I simply don&#x27;t care as long as it passes Lox&#x27;s test suite xD. I went this path just to see how easy it is to get tripped by unsafe while knowing that there&#x27;s a technique to get safety with Pin&lt;T&gt; that this can get refactored into. I actually implemented this with Cell and RefCell but didn&#x27;t find that interesting.</div><br/></div></div></div></div><div id="41119096" class="c"><input type="checkbox" id="c-41119096" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41118853">parent</a><span>|</span><a href="#41120310">prev</a><span>|</span><a href="#41119006">next</a><span>|</span><label class="collapse" for="c-41119096">[-]</label><label class="expand" for="c-41119096">[4 more]</label></div><br/><div class="children"><div class="content">Mark and sweep doesn&#x27;t stop you from holding references across GC.<p>If you write e.g.<p>```
let obj = some_object();
let len : &amp;mut usize = &amp;mut obj.len; &#x2F;&#x2F; deref_mut
trigger_gc();
use(*len);
```<p>then you held a reference across the GC, and while it&#x27;s mark&#x2F;sweeping created an aliases `&amp;mut` to `len`.<p>Inlining was mention just because it causes function bodies to be splatting together, and so puts together code that is fine in isolation in a way that may allow Rust to observe UB: if `trigger_gc` was inlined for example then Rust has more information and code available at once, and might use the knowledge to apply some optimizations that are invalid because you caused UB.<p>Actually, looking at your code the much larger issue is that nothing stops you from doing<p>```
let obj = some_object();
let obj2 = obj.clone();
let len1 = &amp;mut obj.len;
let len2 = &amp;mut obj2.len;
let n = *len1;
*len2 = 0;
println!(&quot;{n}&quot;); &#x2F;&#x2F; what does this print?
```
because your Deref mut are just creating unconstrained borrow from pointer types that you can copy. This is almost definitely going to cause you bugs in the future, since it opens you up to accidentally writing iterator invalidation and other issues (and even worse than C++ does, because C++ doesn&#x27;t optimize references as heavily as Rust does borrows)</div><br/><div id="41119165" class="c"><input type="checkbox" id="c-41119165" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41119096">parent</a><span>|</span><a href="#41119006">next</a><span>|</span><label class="collapse" for="c-41119165">[-]</label><label class="expand" for="c-41119165">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s a self-enforced contract that objects of type Gc&lt;T&gt; are only ever touched by the virtual machine, but I get your point.</div><br/><div id="41121652" class="c"><input type="checkbox" id="c-41121652" checked=""/><div class="controls bullet"><span class="by">adrian17</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41119165">parent</a><span>|</span><a href="#41119006">next</a><span>|</span><label class="collapse" for="c-41121652">[-]</label><label class="expand" for="c-41121652">[2 more]</label></div><br/><div class="children"><div class="content">The issue is that it&#x27;s a simple footgun as soon as you start adding non-trivial native methods (say, string methods, array.map etc). The only way to make sure that they don&#x27;t exist is removing the DerefMut impl entirely.<p>It&#x27;s not just that it&#x27;s possible to break the code, but that lack of any checks makes it impossible to detect at either compile-time or runtime and have it &quot;appear to work&quot;.<p>One way to solve it to remove the DerefMut implementation and have it work more like Rc - as in, the user is forced to write `Gc&lt;Cell&lt;T&gt;&gt;` or `Gc&lt;RefCell&lt;T&gt;&gt;` if they want mutability. This solves the aliasing borrows issue at the cost of extra runtime checks with RefCell (and still doesn&#x27;t prevent you from unsoundly calling `sweep()` while holding a Gc)</div><br/><div id="41122105" class="c"><input type="checkbox" id="c-41122105" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41121652">parent</a><span>|</span><a href="#41119006">next</a><span>|</span><label class="collapse" for="c-41122105">[-]</label><label class="expand" for="c-41122105">[1 more]</label></div><br/><div class="children"><div class="content">I implemented exactly what you were saying here (<a href="https:&#x2F;&#x2F;github.com&#x2F;ltungv&#x2F;rox&#x2F;commit&#x2F;6a611e7acb3b36d0a3a4376f36b1774d7c032ad2#diff-6ec61590e2fd8e76c30e8f6fafef37660f5750b5f229775ad008e79945d71f2c">https:&#x2F;&#x2F;github.com&#x2F;ltungv&#x2F;rox&#x2F;commit&#x2F;6a611e7acb3b36d0a3a4376...</a>). But where&#x27;s the fun in that?</div><br/></div></div></div></div></div></div></div></div><div id="41119006" class="c"><input type="checkbox" id="c-41119006" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41118853">parent</a><span>|</span><a href="#41119096">prev</a><span>|</span><a href="#41122472">next</a><span>|</span><label class="collapse" for="c-41119006">[-]</label><label class="expand" for="c-41119006">[2 more]</label></div><br/><div class="children"><div class="content">With a borrowchecker what does GC let you do that is more ergonomic?  I have never used a borrowchecked and garbage colected language so I have no experience to consult.</div><br/><div id="41119167" class="c"><input type="checkbox" id="c-41119167" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41118791">root</a><span>|</span><a href="#41119006">parent</a><span>|</span><a href="#41122472">next</a><span>|</span><label class="collapse" for="c-41119167">[-]</label><label class="expand" for="c-41119167">[1 more]</label></div><br/><div class="children"><div class="content">The borrow-checker helps when you&#x27;re writing Rust code. But when writing an interpreter for another language, you kinda have to support its semantics. In Lox, there&#x27;s no move semantic, no borrowing, almost everything is a heap-allocated object, variables can alias, etc. Thus, you need to have a way to manage the memory of the implemented language without the borrow-checker. Here, the borrow-checker can help with implementing the GC safely and correctly, but I didn&#x27;t utilize it.</div><br/></div></div></div></div></div></div></div></div><div id="41122472" class="c"><input type="checkbox" id="c-41122472" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#41118791">prev</a><span>|</span><label class="collapse" for="c-41122472">[-]</label><label class="expand" for="c-41122472">[10 more]</label></div><br/><div class="children"><div class="content">TL;DR: Don&#x27;t use unsafe to break the rules. Use unsafe to enforce the rules in new ways.<p>Great journey. That&#x27;s the thing about &quot;unsafe&quot; and &quot;questionable parts&quot;... if they really are questionable, then don&#x27;t do &#x27;em. In this case, if it is the case that holding a reference to a GC object guarantees that that object can&#x27;t be freed, then it&#x27;s not questionable. Proving that to be case can be fun tho.<p>The question is: does my unsafe code allow violating the borrow rules?<p>Cell, RefCell, RwLock etc give you interior mutability, but there is no way to violate the borrow rules with them. On the surface, it looks like you are violating them because &quot;I have a non-mut thing that I can mutate&quot;.<p>If you build a thing that allows two distinct &amp;mut T&#x27;s to the same thing, then you are basically asking for a bug. Don&#x27;t use unsafe to break the rules. Use unsafe to enforce the rules in new ways.</div><br/><div id="41122857" class="c"><input type="checkbox" id="c-41122857" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122472">parent</a><span>|</span><label class="collapse" for="c-41122857">[-]</label><label class="expand" for="c-41122857">[9 more]</label></div><br/><div class="children"><div class="content">If someone else depends on this project, I&#x27;d definitely not implement the questionable stuff. You&#x27;re right that proving whether it&#x27;s safe can be lots of fun, and I&#x27;m planning to try it out.<p>Based on what I&#x27;ve read, it&#x27;s entirely possible. If my Rust knowledge is correct, there are 2 things that have to be proven - the object&#x27;s lifetime and the borrow rules.<p>Proving the lifetime can be done at compile-time based on what was discussed in these articles <a href="https:&#x2F;&#x2F;without.boats&#x2F;tags&#x2F;shifgrethor&#x2F;" rel="nofollow">https:&#x2F;&#x2F;without.boats&#x2F;tags&#x2F;shifgrethor&#x2F;</a>. But that still leaves us with proving that we don&#x27;t violate the borrow rules. AFAIK, the only way to do it in my implementation is with Cell and RefCell enforcing the borrow rules at runtime.<p>Before removing all the safety checks, I actually used Gc&lt;RefCell&lt;T&gt;&gt; for mutable objects, so the borrow rules were enforced but not the lifetime. However, I decided to remove RefCell&lt;T&gt; to have some fun and see how I could shoot myself in the foot.</div><br/><div id="41124543" class="c"><input type="checkbox" id="c-41124543" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41122857">parent</a><span>|</span><a href="#41124402">next</a><span>|</span><label class="collapse" for="c-41124543">[-]</label><label class="expand" for="c-41124543">[6 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t want to use `RefCell` for something like this- it is still too strict for Lox&#x27;s semantics.<p>Doing this properly means putting `GcData`&#x27;s fields (and&#x2F;or `ObjFun`&#x2F;`ObjClosure`&#x2F;etc&#x27;s fields) in plain `Cell`s, and using that for all mutation without ever forming any `&amp;mut` references.</div><br/><div id="41124649" class="c"><input type="checkbox" id="c-41124649" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41124543">parent</a><span>|</span><a href="#41124402">next</a><span>|</span><label class="collapse" for="c-41124649">[-]</label><label class="expand" for="c-41124649">[5 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on why it&#x27;s too strict? I got RefCell working and passed to test suite just fine. Maybe the suite don&#x27;t take into account some that&#x27;s specific to Rust.<p>If I remember correctly, there were some panics cause by RefCell borrows. But those got sorted out once I handled borrowing in the correct order.</div><br/><div id="41124826" class="c"><input type="checkbox" id="c-41124826" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41124649">parent</a><span>|</span><a href="#41124402">next</a><span>|</span><label class="collapse" for="c-41124826">[-]</label><label class="expand" for="c-41124826">[4 more]</label></div><br/><div class="children"><div class="content">I guess a better way to put it is, if you got Lox working with RefCells, then you didn&#x27;t need RefCells (or their overhead) to begin with - you must not have been holding those dynamic borrows any longer than a single VM instruction, or something close to that.</div><br/><div id="41124891" class="c"><input type="checkbox" id="c-41124891" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41124826">parent</a><span>|</span><a href="#41124402">next</a><span>|</span><label class="collapse" for="c-41124891">[-]</label><label class="expand" for="c-41124891">[3 more]</label></div><br/><div class="children"><div class="content">Yes, the borrows were only held for roughly a single instruction. But I don&#x27;t see how you can mutate the Table&#x2F;HashMap of fields in an object with only Cell tho</div><br/><div id="41124921" class="c"><input type="checkbox" id="c-41124921" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41124891">parent</a><span>|</span><a href="#41124402">next</a><span>|</span><label class="collapse" for="c-41124921">[-]</label><label class="expand" for="c-41124921">[2 more]</label></div><br/><div class="children"><div class="content">Technically it is possible to swap the HashMap out of the Cell, mutate it, and put it back, but that is maybe even worse than the RefCell.<p>What I would expect a production language implementation to do is build its own table that integrates its solution for interior mutability into its design. There are several other things (e.g. iterators, concurrent GC) that will also contribute to the need for a custom table, so (again for a production language) this is not too crazy.</div><br/><div id="41125159" class="c"><input type="checkbox" id="c-41125159" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41124921">parent</a><span>|</span><a href="#41124402">next</a><span>|</span><label class="collapse" for="c-41125159">[-]</label><label class="expand" for="c-41125159">[1 more]</label></div><br/><div class="children"><div class="content">Ah! I could imagine a table backed by an array of Cell since all the possible values in that table implement Copy. There is probably a better way for the table to have interior immutability. But I think I get what you were saying.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41124402" class="c"><input type="checkbox" id="c-41124402" checked=""/><div class="controls bullet"><span class="by">adrian17</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41122857">parent</a><span>|</span><a href="#41124543">prev</a><span>|</span><label class="collapse" for="c-41124402">[-]</label><label class="expand" for="c-41124402">[2 more]</label></div><br/><div class="children"><div class="content">Just for reference, the gc-arena crate (<a href="https:&#x2F;&#x2F;github.com&#x2F;kyren&#x2F;gc-arena">https:&#x2F;&#x2F;github.com&#x2F;kyren&#x2F;gc-arena</a>) we use in Ruffle&#x27;s Actionscript 1&#x2F;2&#x2F;3 interpreters and across the entire engine, does this. As far as we know, it&#x27;s safe and sound, at the cost of some limitations, mainly: to compile-time prevent sweeping while holding onto Gc references, every struct and function touching Gc objects passes an extra &#x27;gc lifetime. And not being able to run the GC at arbitrary time can be major issue depending on what you&#x27;re doing; in Ruffle we incrementally collect between frames and pray that no single frame will ever allocate enough to OOM in the middle of it :)<p>And yeah, RefCells everywhere.</div><br/><div id="41124699" class="c"><input type="checkbox" id="c-41124699" checked=""/><div class="controls bullet"><span class="by">ltungv</span><span>|</span><a href="#41122472">root</a><span>|</span><a href="#41124402">parent</a><span>|</span><label class="collapse" for="c-41124699">[-]</label><label class="expand" for="c-41124699">[1 more]</label></div><br/><div class="children"><div class="content">Thanks a lot for the insight. I think if I do it the way shifgrethor did, I can have GC at arbitrary time. But I&#x27;m not so sure about that.<p>With the way Rust may perform optimizations on the assumption of no alias, I guess there&#x27;s currently no way to avoid RefCell if we want to be 100% on the safe side.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>