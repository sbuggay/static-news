<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709629269954" as="style"/><link rel="stylesheet" href="styles.css?v=1709629269954"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://filamenthdl.com/">Filament – A Language for Fearless Hardware Design</a> <span class="domain">(<a href="https://filamenthdl.com">filamenthdl.com</a>)</span></div><div class="subtext"><span>nbrempel</span> | <span>14 comments</span></div><br/><div><div id="39600230" class="c"><input type="checkbox" id="c-39600230" checked=""/><div class="controls bullet"><span class="by">thrtythreeforty</span><span>|</span><a href="#39600602">next</a><span>|</span><label class="collapse" for="c-39600230">[-]</label><label class="expand" for="c-39600230">[3 more]</label></div><br/><div class="children"><div class="content">My experience with most &quot;neo HDLs&quot; is that they are all code generators which make the tedious part easy and don&#x27;t really end up touching the hard part.<p>This may be the first HDL I&#x27;ve seen that attempts to move the needle on catching bugs at compile time. (I&#x27;ve worked with several engineers, on hardware bugs which turned out to be pipelining errors, who did not understand what I meant by &quot;make this design error inexpressible.&quot;)  I have several pages of notes on what I&#x27;d do differently if I designed my own HDL - the typical software engineer hubris - and this is the first language I&#x27;ve seen that starts to line up with what I was thinking.<p>Another perennial area where bugs crop up are when crossing clock and reset domains.  The language ought to be able to make it so that you simply can&#x27;t make many kinds of clock domain errors - trying to read a signal from the wrong clock domain shouldn&#x27;t compile.  Dedicated &quot;unsafe&quot; primitives from a stdlib should perform the crossing <i>and</i> the type conversion.</div><br/><div id="39600747" class="c"><input type="checkbox" id="c-39600747" checked=""/><div class="controls bullet"><span class="by">FPGAhacker</span><span>|</span><a href="#39600230">parent</a><span>|</span><a href="#39600602">next</a><span>|</span><label class="collapse" for="c-39600747">[-]</label><label class="expand" for="c-39600747">[2 more]</label></div><br/><div class="children"><div class="content">Every time I see one of these pop up, the thought that software engineers are forever trying to avoid knowledge, understanding, and wisdom with another layer of abstraction comes to mind.<p>I’m all in favor of a better HDL. Verizon&#x2F;SystemVerilog is loaded with completely non-obvious landmines. I’ve been doing this so long I forget they are there, but it’s pretty painful seeing someone new to the language step on them.  But the alternative, VHDL has largely fallen out of favor in the  US.<p>You would be hard pressed to find a more strongly typed language than VHDL, but damn is it verbose.  None of the footguns, but you might get an RSA before you finish typing the code in. If you have ever given Ada a try, VHDL will look pretty familiar.<p>I know this may be a weird thing for software folks to think about, but writing HDL is a <i>tiny</i> part of digital design. In digital design, if done with discipline, writing the HDL is an almost mechanical process of translating the design.  In a design that might take a year, writing the code might be 3 weeks.<p>Done without discipline you will spend all your time debugging. Wondering why it worked in the lab an hour ago, but after lunch nothing works and you won’t be able to make sense of it.<p>Understanding basic combinational logic, then sequential logic, followed by state machines (which are the bread and butter of digital design), followed by understanding IO timing and timing constraints (a brain damaged “language” to itself) will take you far.<p>Domain crossing isn’t so bad if you have those fundamentals.<p>You can go through all the gyrations of language design in the world, but the language isn’t the hard part.<p>If you want to make the world of digital design a better place, more open, easier to break into, work on tools, not languages. I’d give a kidney for an open source timing diagrammer that could do simple setup and hold checks, create derived signals through Boolean combinations of other signals, and emulate a flop.<p>I’d do it, but I’ve tried and programming a gui is about the most painful thing I’ve done on a computer. So much work for so little payoff.</div><br/><div id="39600944" class="c"><input type="checkbox" id="c-39600944" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#39600230">root</a><span>|</span><a href="#39600747">parent</a><span>|</span><a href="#39600602">next</a><span>|</span><label class="collapse" for="c-39600944">[-]</label><label class="expand" for="c-39600944">[1 more]</label></div><br/><div class="children"><div class="content">But couldn&#x27;t there be languages where it was easier to express that design? Your description reminds me what it&#x27;s like to program in C.</div><br/></div></div></div></div></div></div><div id="39600602" class="c"><input type="checkbox" id="c-39600602" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#39600230">prev</a><span>|</span><a href="#39599732">next</a><span>|</span><label class="collapse" for="c-39600602">[-]</label><label class="expand" for="c-39600602">[3 more]</label></div><br/><div class="children"><div class="content">Very cool.<p>I was interested in the use of Filament to implement an entire RISC V processor (&quot;frisc&quot;) but the link [1] at the bottom of the readme is broken and some quick searches of both Github and the web turned up nothing. Does anyone know what&#x27;s up?<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;cucapra&#x2F;filament&#x2F;tree&#x2F;main&#x2F;frisc">https:&#x2F;&#x2F;github.com&#x2F;cucapra&#x2F;filament&#x2F;tree&#x2F;main&#x2F;frisc</a></div><br/><div id="39600772" class="c"><input type="checkbox" id="c-39600772" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#39600602">parent</a><span>|</span><a href="#39600808">next</a><span>|</span><label class="collapse" for="c-39600772">[-]</label><label class="expand" for="c-39600772">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s under &#x2F;apps in the repo: <a href="https:&#x2F;&#x2F;github.com&#x2F;cucapra&#x2F;filament&#x2F;tree&#x2F;f5da227a059f181b9964e0ea4af077573c7a1cf8&#x2F;apps&#x2F;frisc">https:&#x2F;&#x2F;github.com&#x2F;cucapra&#x2F;filament&#x2F;tree&#x2F;f5da227a059f181b996...</a></div><br/></div></div></div></div><div id="39599732" class="c"><input type="checkbox" id="c-39599732" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39600602">prev</a><span>|</span><a href="#39598681">next</a><span>|</span><label class="collapse" for="c-39599732">[-]</label><label class="expand" for="c-39599732">[4 more]</label></div><br/><div class="children"><div class="content">I never really understand how HDL works.<p>I meant, in software programming, we usually program by either specifying the sequence or dependency.<p>In hardware, nothing runs sequentially, and signals propagate _with delay_.  Everything happens at the same time, yet nothing run at the exact same moment. How could we express these chaos in for-loops and procedure look alikes?</div><br/><div id="39599791" class="c"><input type="checkbox" id="c-39599791" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#39599732">parent</a><span>|</span><a href="#39600278">next</a><span>|</span><label class="collapse" for="c-39599791">[-]</label><label class="expand" for="c-39599791">[2 more]</label></div><br/><div class="children"><div class="content">For loops are one of those things that just don&#x27;t really exist in hardware.<p>The way I like to think of hardware is as a machine that takes a giant blob of state, applies a pure function to it, and when the clock goes from low to high it replaces the original state with the new one and the process starts again.</div><br/><div id="39600103" class="c"><input type="checkbox" id="c-39600103" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#39599732">root</a><span>|</span><a href="#39599791">parent</a><span>|</span><a href="#39600278">next</a><span>|</span><label class="collapse" for="c-39600103">[-]</label><label class="expand" for="c-39600103">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For loops are one of those things that just don&#x27;t really exist in hardware.<p>Hardware for loops are just fine if you think of a for loop as existing in <i>space</i> rather than <i>time</i>--effectively it is always fully unrolled.<p>&gt; The way I like to think of hardware is as a machine that takes a giant blob of state, applies a pure function to it, and when the clock goes from low to high it replaces the original state with the new one and the process starts again.<p>That&#x27;s the way hardware guys think of it, too.  :)<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mealy_machine" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mealy_machine</a></div><br/></div></div></div></div><div id="39600278" class="c"><input type="checkbox" id="c-39600278" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#39599732">parent</a><span>|</span><a href="#39599791">prev</a><span>|</span><a href="#39598681">next</a><span>|</span><label class="collapse" for="c-39600278">[-]</label><label class="expand" for="c-39600278">[1 more]</label></div><br/><div class="children"><div class="content">Preface: My experience is in verilog so I&#x27;ll mostly be coming from there.<p>In most HDLs you have two kinds of code, procedural and continuous code.<p>Your continuous code is wires which propagate signals and continuous logic (basically pure functions). Since there aren&#x27;t any registers in this logic, that means you generally need to do timing analysis to make sure it never gets too long between any two given registers (or latches if you are clock stealing). In verilog you mostly do this via assign statements and module instantiations.<p>Your procedural code is register or latch based code. In verilog these are your always blocks. Here the code represents logic that occurs on every occurance of a given clock edge. The type of always block you use and which edge you specify changes exactly what happens but generally it means &quot;this code runs during this interval every time the clock does a specific transition&quot;. Your inputs are generally going to be registers or latches and your outputs will be as well. Anything that happens must do so fast enough for the logic in between to reach a steady state and long enough for it to catch the edge of the register, edge of the edge triggered latch, or level of the level triggered latch and set the register or latch. If that sounds complicated it kinda is but generally you just let your timing analyzer figure it out and complain if stuff is too slow.<p>Now outside your normal procedural code there are some other ones you see occasionally. There are also initial blocks which only run once and repeat blocks which only run a set number of times but with both you can pause or wait for a condition before proceeding. And there are also forever blocks. In all three of these blocks you can specify timings and delays for things. The most common use for forever blocks for example is to declare a clock that runs at a specified frequency. And initial blocks are used to do setup (such as start the clock loop, set initial values, etc).<p>Now as to how you do loops and procedural logic? You use registers to break it up. That&#x27;s what those always blocks are for. Your always block does a little bit of work each time and you use a state machine to codify where in the loop or procedural logic you are. In general FSMs (finite state machines) become your friend in HDL work very quickly.</div><br/></div></div></div></div><div id="39598681" class="c"><input type="checkbox" id="c-39598681" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#39599732">prev</a><span>|</span><a href="#39599100">next</a><span>|</span><label class="collapse" for="c-39598681">[-]</label><label class="expand" for="c-39598681">[1 more]</label></div><br/><div class="children"><div class="content">I think this is super interesting.  Kind of like a rust style language for symbolic logic.<p>The timing aspect is super interesting, though I wonder if a compiler given an fpga and a program could optimize the hard parts on an fpga and run the rest on a risc V core.</div><br/></div></div><div id="39599100" class="c"><input type="checkbox" id="c-39599100" checked=""/><div class="controls bullet"><span class="by">speps</span><span>|</span><a href="#39598681">prev</a><span>|</span><a href="#39599513">next</a><span>|</span><label class="collapse" for="c-39599100">[-]</label><label class="expand" for="c-39599100">[1 more]</label></div><br/><div class="children"><div class="content">Also: Filament is a real-time physically-based renderer written in C++. It is mobile-first, but also multi-platform.<p><a href="https:&#x2F;&#x2F;google.github.io&#x2F;filament&#x2F;" rel="nofollow">https:&#x2F;&#x2F;google.github.io&#x2F;filament&#x2F;</a></div><br/></div></div><div id="39599513" class="c"><input type="checkbox" id="c-39599513" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#39599100">prev</a><span>|</span><label class="collapse" for="c-39599513">[-]</label><label class="expand" for="c-39599513">[1 more]</label></div><br/><div class="children"><div class="content">There’s some fun pl work in this project</div><br/></div></div></div></div></div></div></div></body></html>