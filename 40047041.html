<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713258059254" as="style"/><link rel="stylesheet" href="styles.css?v=1713258059254"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/johang/btfs">BTFS: BitTorrent Filesystem</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>pyinstallwoes</span> | <span>61 comments</span></div><br/><div><div id="40049416" class="c"><input type="checkbox" id="c-40049416" checked=""/><div class="controls bullet"><span class="by">apichat</span><span>|</span><a href="#40049081">next</a><span>|</span><label class="collapse" for="c-40049416">[-]</label><label class="expand" for="c-40049416">[1 more]</label></div><br/><div class="children"><div class="content">This tool should be upgrade to use Bittorrent v2 new functions.<p><a href="https:&#x2F;&#x2F;blog.libtorrent.org&#x2F;2020&#x2F;09&#x2F;bittorrent-v2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.libtorrent.org&#x2F;2020&#x2F;09&#x2F;bittorrent-v2&#x2F;</a><p>Especially merkle hash trees which enable :<p>- per-file hash trees
- directory structure</div><br/></div></div><div id="40049081" class="c"><input type="checkbox" id="c-40049081" checked=""/><div class="controls bullet"><span class="by">sktrdie</span><span>|</span><a href="#40049416">prev</a><span>|</span><a href="#40048084">next</a><span>|</span><label class="collapse" for="c-40049081">[-]</label><label class="expand" for="c-40049081">[1 more]</label></div><br/><div class="children"><div class="content">Or even better store data as an sqlite file that is full-text-search indexed. Then  you can full-text search the torrent on demand: <a href="https:&#x2F;&#x2F;github.com&#x2F;bittorrent&#x2F;sqltorrent">https:&#x2F;&#x2F;github.com&#x2F;bittorrent&#x2F;sqltorrent</a></div><br/></div></div><div id="40048084" class="c"><input type="checkbox" id="c-40048084" checked=""/><div class="controls bullet"><span class="by">Kerbonut</span><span>|</span><a href="#40049081">prev</a><span>|</span><a href="#40047042">next</a><span>|</span><label class="collapse" for="c-40048084">[-]</label><label class="expand" for="c-40048084">[10 more]</label></div><br/><div class="children"><div class="content">I dream of having a BTFS that will fix my &quot;damaged&quot; media files. E.g. ones I media shift, if my disk was scratched and portions are missing, or if the codec options I picked suck, it could download the &quot;damaged&quot; portions of my media and fix it seamlessly.</div><br/><div id="40049704" class="c"><input type="checkbox" id="c-40049704" checked=""/><div class="controls bullet"><span class="by">kelchm</span><span>|</span><a href="#40048084">parent</a><span>|</span><a href="#40048319">next</a><span>|</span><label class="collapse" for="c-40049704">[-]</label><label class="expand" for="c-40049704">[1 more]</label></div><br/><div class="children"><div class="content">Not the same as what you are talking about, but your comment reminded me of AccurateRip [1] which I used to make extensive use of back when I was ripping hundreds of CDs every year.<p>1: <a href="http:&#x2F;&#x2F;www.accuraterip.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.accuraterip.com&#x2F;</a></div><br/></div></div><div id="40048319" class="c"><input type="checkbox" id="c-40048319" checked=""/><div class="controls bullet"><span class="by">pigpang</span><span>|</span><a href="#40048084">parent</a><span>|</span><a href="#40049704">prev</a><span>|</span><a href="#40048100">next</a><span>|</span><label class="collapse" for="c-40048319">[-]</label><label class="expand" for="c-40048319">[6 more]</label></div><br/><div class="children"><div class="content">How you will calculate hash of file, when it broken, to lookup for?</div><br/><div id="40049684" class="c"><input type="checkbox" id="c-40049684" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#40048084">root</a><span>|</span><a href="#40048319">parent</a><span>|</span><a href="#40048340">next</a><span>|</span><label class="collapse" for="c-40049684">[-]</label><label class="expand" for="c-40049684">[1 more]</label></div><br/><div class="children"><div class="content">You have all the hashes in the .torrent file. All you need is a regular check with it<p>(but then the .torrent file itself has to be stored on a storage that resists bit flipping)</div><br/></div></div><div id="40048340" class="c"><input type="checkbox" id="c-40048340" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40048084">root</a><span>|</span><a href="#40048319">parent</a><span>|</span><a href="#40049684">prev</a><span>|</span><a href="#40048530">next</a><span>|</span><label class="collapse" for="c-40048340">[-]</label><label class="expand" for="c-40048340">[1 more]</label></div><br/><div class="children"><div class="content">You could do a rolling hash and say that a chunk with a given hash should appear between two other chunks of certain hashes</div><br/></div></div><div id="40048530" class="c"><input type="checkbox" id="c-40048530" checked=""/><div class="controls bullet"><span class="by">everfree</span><span>|</span><a href="#40048084">root</a><span>|</span><a href="#40048319">parent</a><span>|</span><a href="#40048340">prev</a><span>|</span><a href="#40049440">next</a><span>|</span><label class="collapse" for="c-40048530">[-]</label><label class="expand" for="c-40048530">[1 more]</label></div><br/><div class="children"><div class="content">Just hash it before it&#x27;s broken.</div><br/></div></div><div id="40049440" class="c"><input type="checkbox" id="c-40049440" checked=""/><div class="controls bullet"><span class="by">alex_duf</span><span>|</span><a href="#40048084">root</a><span>|</span><a href="#40048319">parent</a><span>|</span><a href="#40048530">prev</a><span>|</span><a href="#40048573">next</a><span>|</span><label class="collapse" for="c-40049440">[-]</label><label class="expand" for="c-40049440">[1 more]</label></div><br/><div class="children"><div class="content">if you store the merkle tree that was used to download it, you&#x27;ll be able to know exactly which chunk of the file got a bit flip.</div><br/></div></div><div id="40048573" class="c"><input type="checkbox" id="c-40048573" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#40048084">root</a><span>|</span><a href="#40048319">parent</a><span>|</span><a href="#40049440">prev</a><span>|</span><a href="#40048100">next</a><span>|</span><label class="collapse" for="c-40048573">[-]</label><label class="expand" for="c-40048573">[1 more]</label></div><br/><div class="children"><div class="content">Just use the sector number(s) of the damaged parts.</div><br/></div></div></div></div><div id="40048100" class="c"><input type="checkbox" id="c-40048100" checked=""/><div class="controls bullet"><span class="by">gosub100</span><span>|</span><a href="#40048084">parent</a><span>|</span><a href="#40048319">prev</a><span>|</span><a href="#40047042">next</a><span>|</span><label class="collapse" for="c-40048100">[-]</label><label class="expand" for="c-40048100">[2 more]</label></div><br/><div class="children"><div class="content">another use of this is to share media after I&#x27;ve imported it into my library. if I voluntarily scan hashes of all my media, if a smart torrent client could offer those files only (so a partial torrent because I always remove the superfluous files) it would help seed a lot of rare media files.</div><br/><div id="40048140" class="c"><input type="checkbox" id="c-40048140" checked=""/><div class="controls bullet"><span class="by">Stephen304</span><span>|</span><a href="#40048084">root</a><span>|</span><a href="#40048100">parent</a><span>|</span><a href="#40047042">next</a><span>|</span><label class="collapse" for="c-40048140">[-]</label><label class="expand" for="c-40048140">[1 more]</label></div><br/><div class="children"><div class="content">This happens to be one of the pipe dream roadmap milestones for bitmagnet: <a href="https:&#x2F;&#x2F;bitmagnet.io&#x2F;#pipe-dream-features" rel="nofollow">https:&#x2F;&#x2F;bitmagnet.io&#x2F;#pipe-dream-features</a><p>I used to use magnetico and wanted to make something that would use crawled info hashes to fetch the metadata and retrieve the file listing, then search a folder for any matching files. You&#x27;d probably want to pre-hash everything in the folder and cache the hashes.<p>I hope bitmagnet gets that ability, it would be super cool</div><br/></div></div></div></div></div></div><div id="40047042" class="c"><input type="checkbox" id="c-40047042" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#40048084">prev</a><span>|</span><a href="#40049293">next</a><span>|</span><label class="collapse" for="c-40047042">[-]</label><label class="expand" for="c-40047042">[15 more]</label></div><br/><div class="children"><div class="content">Submitting because I&#x27;m surprised why this isn&#x27;t used more... couldn&#x27;t we build a virtualmachine&#x2F;OS&#x27;s as an overlay on BTFS? Seems like an interesting direction.</div><br/><div id="40047793" class="c"><input type="checkbox" id="c-40047793" checked=""/><div class="controls bullet"><span class="by">Jhsto</span><span>|</span><a href="#40047042">parent</a><span>|</span><a href="#40047823">next</a><span>|</span><label class="collapse" for="c-40047793">[-]</label><label class="expand" for="c-40047793">[4 more]</label></div><br/><div class="children"><div class="content">Just the other week I used Nix on my laptop to derive PXE boot images, uploaded those to IPFS, and netbooted my server in another country over a public IPFS mirror. The initrd gets mounted as read-only overlayfs on boot. My configs are public: <a href="https:&#x2F;&#x2F;github.com&#x2F;jhvst&#x2F;nix-config">https:&#x2F;&#x2F;github.com&#x2F;jhvst&#x2F;nix-config</a><p>I plan to write documentation of the IPFS process including the PXE router config later at <a href="https:&#x2F;&#x2F;github.com&#x2F;majbacka-labs&#x2F;nixos.fi">https:&#x2F;&#x2F;github.com&#x2F;majbacka-labs&#x2F;nixos.fi</a> -- we might also run a small public build server for peoples Flake configs, who are interested in trying out this process.</div><br/><div id="40048161" class="c"><input type="checkbox" id="c-40048161" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047793">parent</a><span>|</span><a href="#40049285">next</a><span>|</span><label class="collapse" for="c-40048161">[-]</label><label class="expand" for="c-40048161">[1 more]</label></div><br/><div class="children"><div class="content">I laughed when I saw that your readme jumps straight into some category theory. FYI others might cry instead.<p>You&#x27;re doing some cool things here.</div><br/></div></div><div id="40049285" class="c"><input type="checkbox" id="c-40049285" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047793">parent</a><span>|</span><a href="#40048161">prev</a><span>|</span><a href="#40048864">next</a><span>|</span><label class="collapse" for="c-40049285">[-]</label><label class="expand" for="c-40049285">[1 more]</label></div><br/><div class="children"><div class="content">&gt;A prominent direction in the Linux distribution scene lately has been the concept of immutable desktop operating systems. Recent examples include Fedora Silverblue (2018) and Vanilla OS (2022). But, on my anecdotal understanding of the timelines concerning Linux distros, both are spiritual successors to CoreOS (2013).<p>Remember in the late 90&#x27;s booting server off a CD-ROM was the thing.</div><br/></div></div><div id="40048864" class="c"><input type="checkbox" id="c-40048864" checked=""/><div class="controls bullet"><span class="by">jquaint</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047793">parent</a><span>|</span><a href="#40049285">prev</a><span>|</span><a href="#40047823">next</a><span>|</span><label class="collapse" for="c-40048864">[-]</label><label class="expand" for="c-40048864">[1 more]</label></div><br/><div class="children"><div class="content">This is really cool. Plan to take some inspiration from your config!</div><br/></div></div></div></div><div id="40047823" class="c"><input type="checkbox" id="c-40047823" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40047042">parent</a><span>|</span><a href="#40047793">prev</a><span>|</span><a href="#40047733">next</a><span>|</span><label class="collapse" for="c-40047823">[-]</label><label class="expand" for="c-40047823">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an overlay provider itself, but uber&#x2F;kraken is a &quot;P2P Docker registry capable of distributing TBs of data in seconds&quot;. It uses the bittorrent protocol to deliver docker images to large clusters.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;uber&#x2F;kraken">https:&#x2F;&#x2F;github.com&#x2F;uber&#x2F;kraken</a></div><br/><div id="40049472" class="c"><input type="checkbox" id="c-40049472" checked=""/><div class="controls bullet"><span class="by">apichat</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047823">parent</a><span>|</span><a href="#40049544">next</a><span>|</span><label class="collapse" for="c-40049472">[-]</label><label class="expand" for="c-40049472">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;uber&#x2F;kraken?tab=readme-ov-file#comparison-with-other-projects">https:&#x2F;&#x2F;github.com&#x2F;uber&#x2F;kraken?tab=readme-ov-file#comparison...</a><p>&quot;Kraken was initially built with a BitTorrent driver, however, we ended up implementing our P2P driver based on BitTorrent protocol to allow for tighter integration with storage solutions and more control over performance optimizations.<p>Kraken&#x27;s problem space is slightly different than what BitTorrent was designed for. Kraken&#x27;s goal is to reduce global max download time and communication overhead in a stable environment, while BitTorrent was designed for an unpredictable and adversarial environment, so it needs to preserve more copies of scarce data and defend against malicious or bad behaving peers.<p>Despite the differences, we re-examine Kraken&#x27;s protocol from time to time, and if it&#x27;s feasible, we hope to make it compatible with BitTorrent again.&quot;</div><br/></div></div><div id="40049544" class="c"><input type="checkbox" id="c-40049544" checked=""/><div class="controls bullet"><span class="by">phillebaba</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047823">parent</a><span>|</span><a href="#40049472">prev</a><span>|</span><a href="#40048173">next</a><span>|</span><label class="collapse" for="c-40049544">[-]</label><label class="expand" for="c-40049544">[1 more]</label></div><br/><div class="children"><div class="content">Kraken is sadly a dead project, with little work being done. For example support for Containerd is non-existent or just not documented.<p>I created Spegel to fill the gap but focus on the P2P registry component without the overhead of running a stateful application.
<a href="https:&#x2F;&#x2F;github.com&#x2F;spegel-org&#x2F;spegel">https:&#x2F;&#x2F;github.com&#x2F;spegel-org&#x2F;spegel</a></div><br/></div></div><div id="40048173" class="c"><input type="checkbox" id="c-40048173" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047823">parent</a><span>|</span><a href="#40049544">prev</a><span>|</span><a href="#40047733">next</a><span>|</span><label class="collapse" for="c-40048173">[-]</label><label class="expand" for="c-40048173">[1 more]</label></div><br/><div class="children"><div class="content">The problem with being a docker registry is that you&#x27;re still having to double-dip: distribute to the registry, then docker pull.<p>But you shouldn&#x27;t need to: you should be able to do the same thing with a docker graph driver, so there is no registry - even daemon should perceive the local registry as &quot;already available&quot;, even though in reality it&#x27;s going to just download the parts it needs as it overlay mounts the image layers.<p>Which would actually potentially save a ton of bandwidth, since the stuff <i>in</i> an image is usually quite different to the stuff any given application needs (i.e. I usually base off Ubuntu, but if I&#x27;m only throwing a Go binary in there plus wanting debugging tools maybe available, then in most executions the actual image pulled to the local disk would be very small).</div><br/></div></div></div></div><div id="40047733" class="c"><input type="checkbox" id="c-40047733" checked=""/><div class="controls bullet"><span class="by">retzkek</span><span>|</span><a href="#40047042">parent</a><span>|</span><a href="#40047823">prev</a><span>|</span><a href="#40047477">next</a><span>|</span><label class="collapse" for="c-40047733">[-]</label><label class="expand" for="c-40047733">[1 more]</label></div><br/><div class="children"><div class="content">CVMFS is a mature entry in that space, heavily used in the physics community to distribute software and container images, allowing simple and efficient sharing of computing resources. <a href="https:&#x2F;&#x2F;cernvm.cern.ch&#x2F;fs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cernvm.cern.ch&#x2F;fs&#x2F;</a></div><br/></div></div><div id="40047477" class="c"><input type="checkbox" id="c-40047477" checked=""/><div class="controls bullet"><span class="by">idle_zealot</span><span>|</span><a href="#40047042">parent</a><span>|</span><a href="#40047733">prev</a><span>|</span><a href="#40049293">next</a><span>|</span><label class="collapse" for="c-40047477">[-]</label><label class="expand" for="c-40047477">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I see the point. A read-only filesystem that downloads files on-the-fly is neat, but doesn&#x27;t sound practical in most situations.</div><br/><div id="40047534" class="c"><input type="checkbox" id="c-40047534" checked=""/><div class="controls bullet"><span class="by">crest</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047477">parent</a><span>|</span><a href="#40047678">next</a><span>|</span><label class="collapse" for="c-40047534">[-]</label><label class="expand" for="c-40047534">[1 more]</label></div><br/><div class="children"><div class="content">It can be an essential component, but for on-site replication you need to coordinate your caches to make the most of your available capacity. There&#x27;re efforts to implement this on top IPFS to have mutually trusted nodes elect a leader deciding who should pin what to ensure you keep enough intact copies of everything in the distributed cache, but like so many things IPFS it started out interesting, died from feature creep and &quot;visions&quot; instead of working code.</div><br/></div></div><div id="40047678" class="c"><input type="checkbox" id="c-40047678" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047477">parent</a><span>|</span><a href="#40047534">prev</a><span>|</span><a href="#40049293">next</a><span>|</span><label class="collapse" for="c-40047678">[-]</label><label class="expand" for="c-40047678">[3 more]</label></div><br/><div class="children"><div class="content">Imagine that any computation is a hash, then every possible thing becomes memoized not distinguishing between data&#x2F;code. Then as a consequence you have durability, cache, security to an extent, verifiability through peers (could be trusted or degrees away from peers you trust).</div><br/><div id="40047702" class="c"><input type="checkbox" id="c-40047702" checked=""/><div class="controls bullet"><span class="by">gameman144</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047678">parent</a><span>|</span><a href="#40049293">next</a><span>|</span><label class="collapse" for="c-40047702">[-]</label><label class="expand" for="c-40047702">[2 more]</label></div><br/><div class="children"><div class="content">Is every computation <i>worth</i> memoizing? I can think of very few computations I do that others would care about, and in those cases there&#x27;s already a much more efficient caching layer fronting the data anyway.</div><br/><div id="40049474" class="c"><input type="checkbox" id="c-40049474" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#40047042">root</a><span>|</span><a href="#40047702">parent</a><span>|</span><a href="#40049293">next</a><span>|</span><label class="collapse" for="c-40049474">[-]</label><label class="expand" for="c-40049474">[1 more]</label></div><br/><div class="children"><div class="content">Why not? I think there is some interesting research here at the computationally level &#x2F; distributed that could lead to some interesting architecture and discoveries.<p>Fully distributed OS&#x27;s&#x2F;Virtual Machines&#x2F;LLM&#x27;s&#x2F;Neural Networks<p>If LLM&#x27;s are token predictors for language, what happens when you do token prediction for computation across a distributed network? Then run a NN on the cache and clustering itself? Lots of potential use cases.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40049293" class="c"><input type="checkbox" id="c-40049293" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40047042">prev</a><span>|</span><a href="#40048993">next</a><span>|</span><label class="collapse" for="c-40049293">[-]</label><label class="expand" for="c-40049293">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a similar idea for block devices:
<a href="https:&#x2F;&#x2F;libguestfs.org&#x2F;nbdkit-torrent-plugin.1.html" rel="nofollow">https:&#x2F;&#x2F;libguestfs.org&#x2F;nbdkit-torrent-plugin.1.html</a><p>It lets you create a block device (&#x2F;dev&#x2F;nbd0) backed by a torrent.  Blocks are fetched in the background, or on demand (by prioritizing blocks according to recent read requests).<p>In practice it works - you can even boot a VM from it - but it&#x27;s quite slow unless you have lots of seeds.  There&#x27;s a danger, particularly with VMs, that you can hit time outs waiting for a block to be read, unless you adjust some guest kernel parameters.<p>There are some bootable examples in that page if you want to try it.</div><br/></div></div><div id="40048993" class="c"><input type="checkbox" id="c-40048993" checked=""/><div class="controls bullet"><span class="by">Maakuth</span><span>|</span><a href="#40049293">prev</a><span>|</span><a href="#40047469">next</a><span>|</span><label class="collapse" for="c-40048993">[-]</label><label class="expand" for="c-40048993">[2 more]</label></div><br/><div class="children"><div class="content">This is the perfect client for accessing Internet Archive content! Each IA item automatically has a torrent that has IA&#x27;s web seeds. Try Big Buck Bunny:<p>btfs <a href="https:&#x2F;&#x2F;archive.org&#x2F;download&#x2F;BigBuckBunny_124&#x2F;BigBuckBunny_124_archive.torrent" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;download&#x2F;BigBuckBunny_124&#x2F;BigBuckBunny_1...</a> mountpoint</div><br/><div id="40049714" class="c"><input type="checkbox" id="c-40049714" checked=""/><div class="controls bullet"><span class="by">rnhmjoj</span><span>|</span><a href="#40048993">parent</a><span>|</span><a href="#40047469">next</a><span>|</span><label class="collapse" for="c-40049714">[-]</label><label class="expand" for="c-40049714">[1 more]</label></div><br/><div class="children"><div class="content">Even better, try this:<p><pre><code>    btplay https:&#x2F;&#x2F;archive.org&#x2F;download&#x2F;BigBuckBunny_124&#x2F;BigBuckBunny_124_archive.torrent</code></pre></div><br/></div></div></div></div><div id="40047469" class="c"><input type="checkbox" id="c-40047469" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#40048993">prev</a><span>|</span><a href="#40048116">next</a><span>|</span><label class="collapse" for="c-40047469">[-]</label><label class="expand" for="c-40047469">[1 more]</label></div><br/><div class="children"><div class="content">Thoughts from 4 years ago:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23576063">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23576063</a></div><br/></div></div><div id="40048116" class="c"><input type="checkbox" id="c-40048116" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40047469">prev</a><span>|</span><a href="#40048731">next</a><span>|</span><label class="collapse" for="c-40048116">[-]</label><label class="expand" for="c-40048116">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>BTFS â mount any .torrent file or magnet link as directory</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23576063">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23576063</a> - June 2020 (121 comments)<p><i>BitTorrent file system</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10826154">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10826154</a> - Jan 2016 (33 comments)</div><br/></div></div><div id="40048731" class="c"><input type="checkbox" id="c-40048731" checked=""/><div class="controls bullet"><span class="by">ceritium</span><span>|</span><a href="#40048116">prev</a><span>|</span><a href="#40048138">next</a><span>|</span><label class="collapse" for="c-40048731">[-]</label><label class="expand" for="c-40048731">[1 more]</label></div><br/><div class="children"><div class="content">I did something similar some years ago, <a href="https:&#x2F;&#x2F;github.com&#x2F;ceritium&#x2F;fuse-torrent">https:&#x2F;&#x2F;github.com&#x2F;ceritium&#x2F;fuse-torrent</a><p>I had no idea what I was doing, most of the hard work IS done by the torrent-stream node package</div><br/></div></div><div id="40048138" class="c"><input type="checkbox" id="c-40048138" checked=""/><div class="controls bullet"><span class="by">Cieric</span><span>|</span><a href="#40048731">prev</a><span>|</span><a href="#40047984">next</a><span>|</span><label class="collapse" for="c-40048138">[-]</label><label class="expand" for="c-40048138">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve thought about using this for my media server in the past, but in the end I ran into to many issues trying to automate it. Then there&#x27;s all the normal issues, slow downloads can wreck havoc on some programs expecting the whole thing to be there and I couldn&#x27;t move files around without breaking connections. It was interesting to mess with, but in the end I just decided it would be a fun challenge to write my own in zig so I could have something &quot;easy&quot; to hack on in the future.</div><br/></div></div><div id="40047984" class="c"><input type="checkbox" id="c-40047984" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#40048138">prev</a><span>|</span><a href="#40048222">next</a><span>|</span><label class="collapse" for="c-40047984">[-]</label><label class="expand" for="c-40047984">[2 more]</label></div><br/><div class="children"><div class="content">I found it might be quite useful for huge LLMs since those are now hosted on BitTorrent. Of course it is not going to be as practical as IPFS since IPFS is content addressable and easier to do random access.</div><br/><div id="40048139" class="c"><input type="checkbox" id="c-40048139" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#40047984">parent</a><span>|</span><a href="#40048222">next</a><span>|</span><label class="collapse" for="c-40048139">[-]</label><label class="expand" for="c-40048139">[1 more]</label></div><br/><div class="children"><div class="content">Is there much use for a partially resident LLM though?<p>Then I don&#x27;t see much of an advantage over just vanilla bittorrent - if you realistically need a full local copy to even start working anyway.</div><br/></div></div></div></div><div id="40048222" class="c"><input type="checkbox" id="c-40048222" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#40047984">prev</a><span>|</span><a href="#40047481">next</a><span>|</span><label class="collapse" for="c-40048222">[-]</label><label class="expand" for="c-40048222">[5 more]</label></div><br/><div class="children"><div class="content">Pretty cool on the surface, but 2 things I can think of right now that mostly kills it for me (and maybe many others). 1) the things one usually use Bittorrent for tend to need the complete files to be all there to be useful, and internet speeds is a limiter in that regard. 2) seeder count tends to break down pretty quickly, as people delete or even just move the files elsewhere for whatever reason, so availability falls.</div><br/><div id="40048415" class="c"><input type="checkbox" id="c-40048415" checked=""/><div class="controls bullet"><span class="by">elevenz</span><span>|</span><a href="#40048222">parent</a><span>|</span><a href="#40047481">next</a><span>|</span><label class="collapse" for="c-40048415">[-]</label><label class="expand" for="c-40048415">[4 more]</label></div><br/><div class="children"><div class="content">A file index tool can be add to torrent clients, letting it scan all files in a user-selected folder and tag them with torrent info. Then how can it find the torrent info for a given file? Maybe we need a central server, maybe some hacker will invent a distributed reverse torrent search network, to list what playlists has a specific song. I don&#x27;t know if someone has already invented this. I think it can be the final answer to any distributed file system driven by user uploads.</div><br/><div id="40049724" class="c"><input type="checkbox" id="c-40049724" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#40048222">root</a><span>|</span><a href="#40048415">parent</a><span>|</span><a href="#40048851">next</a><span>|</span><label class="collapse" for="c-40049724">[-]</label><label class="expand" for="c-40049724">[1 more]</label></div><br/><div class="children"><div class="content">IPFS has resolved the indexing issue, with content addressing. Overall I&#x27;d say it has all the pros of bittorrent and fewer of the cons, from a technical perspective. However it&#x27;s more complex, which may be a reason why it isn&#x27;t more adopted.</div><br/></div></div><div id="40048851" class="c"><input type="checkbox" id="c-40048851" checked=""/><div class="controls bullet"><span class="by">WhiteOwlLion</span><span>|</span><a href="#40048222">root</a><span>|</span><a href="#40048415">parent</a><span>|</span><a href="#40049724">prev</a><span>|</span><a href="#40047481">next</a><span>|</span><label class="collapse" for="c-40048851">[-]</label><label class="expand" for="c-40048851">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t torrents block based so file boundaries are not observed without hacks?</div><br/><div id="40049722" class="c"><input type="checkbox" id="c-40049722" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#40048222">root</a><span>|</span><a href="#40048851">parent</a><span>|</span><a href="#40047481">next</a><span>|</span><label class="collapse" for="c-40049722">[-]</label><label class="expand" for="c-40049722">[1 more]</label></div><br/><div class="children"><div class="content">torrents are file-based but in v1 the edge of a file doesn&#x27;t map with the edge of a piece, so you can&#x27;t easily find file&#x27;s hashes.<p>In v2 this is solved and it is possible to easily know the hash of each file in the torrent, so you can search for it in other torrents</div><br/></div></div></div></div></div></div></div></div><div id="40047481" class="c"><input type="checkbox" id="c-40047481" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#40048222">prev</a><span>|</span><a href="#40047906">next</a><span>|</span><label class="collapse" for="c-40047481">[-]</label><label class="expand" for="c-40047481">[1 more]</label></div><br/><div class="children"><div class="content">the top comment &lt;<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23580334">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23580334</a>&gt; by saurik <i>(yes, that one)</i> on the previous 121 comment thread back in 2020 sums up my feelings about the situation: BTFS is a &quot;one CID at a time&quot; version of IPFS<p>I do think IPFS is awesome, but is going to take some major advances in at least 3 areas before it becomes something usable day-to-day:<p>1. not running a local node proxy (I hear that Brave has some built-in WebTorrent support, so maybe that&#x27;s the path, but since I don&#x27;t use Brave I can&#x27;t say whether they are &quot;WebTorrent in name only&quot; or what<p>2. related to that, the swarm&#x2F;peer resolution latency suffers in the same way that &quot;web3 crypto tomfoolery&quot; does, and that latency makes &quot;browsing&quot; feel like the old 14.4k modem days<p>3. IPFS is <i>absolutely fantastic</i> for infrequently changing but super popular content, e.g. wikipedia, game releases, MDN content, etc, but is a super PITA to replace &quot;tip&quot; or &quot;main&quot; (if one thinks of browsing a git repo) with the &quot;updated&quot; version since (to the best of my knowledge) the only way folks have to resolve that newest CID is IPNS and DNS is never, ever going to be a &quot;well, that&#x27;s a good mechanism and surely doesn&#x27;t contribute to one of the N things any outage always involves&quot;<p>I&#x27;m aware that I have spent an inordinate amount of words talking about a filesystem other than the one you submitted, but unlike BTFS, which I would never install, I think that those who click on this and are interested in the idea of BTFS may enjoy reading further into IPFS, but should bear in mind my opinion of its current shortcomings</div><br/></div></div><div id="40047906" class="c"><input type="checkbox" id="c-40047906" checked=""/><div class="controls bullet"><span class="by">xmichael909</span><span>|</span><a href="#40047481">prev</a><span>|</span><a href="#40047538">next</a><span>|</span><label class="collapse" for="c-40047906">[-]</label><label class="expand" for="c-40047906">[3 more]</label></div><br/><div class="children"><div class="content">No security at all?</div><br/><div id="40049730" class="c"><input type="checkbox" id="c-40049730" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#40047906">parent</a><span>|</span><a href="#40049077">next</a><span>|</span><label class="collapse" for="c-40049730">[-]</label><label class="expand" for="c-40049730">[1 more]</label></div><br/><div class="children"><div class="content">What security would be interesting here ?</div><br/></div></div><div id="40049077" class="c"><input type="checkbox" id="c-40049077" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40047906">parent</a><span>|</span><a href="#40049730">prev</a><span>|</span><a href="#40047538">next</a><span>|</span><label class="collapse" for="c-40049077">[-]</label><label class="expand" for="c-40049077">[1 more]</label></div><br/><div class="children"><div class="content"><i>Give her some funked-up muzak, she treats you nice</i><p><i>Feed her some hungry reggae, she&#x27;ll love you twice</i></div><br/></div></div></div></div><div id="40047538" class="c"><input type="checkbox" id="c-40047538" checked=""/><div class="controls bullet"><span class="by">SuperNinKenDo</span><span>|</span><a href="#40047906">prev</a><span>|</span><a href="#40047448">next</a><span>|</span><label class="collapse" for="c-40047538">[-]</label><label class="expand" for="c-40047538">[1 more]</label></div><br/><div class="children"><div class="content">Cool concept. I assume that it seeds if and while the files are present on your device? Tried to read the manpage but unformatted manpage markdown on a phone was too difficult to read.</div><br/></div></div><div id="40047448" class="c"><input type="checkbox" id="c-40047448" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#40047538">prev</a><span>|</span><a href="#40049690">next</a><span>|</span><label class="collapse" for="c-40047448">[-]</label><label class="expand" for="c-40047448">[13 more]</label></div><br/><div class="children"><div class="content">so is this like a Dropbox alternative using the bittorrent protocol?</div><br/><div id="40047507" class="c"><input type="checkbox" id="c-40047507" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#40047448">parent</a><span>|</span><a href="#40049690">next</a><span>|</span><label class="collapse" for="c-40047507">[-]</label><label class="expand" for="c-40047507">[12 more]</label></div><br/><div class="children"><div class="content">No,this is being able to interact with a .torrent file as if it&#x27;s a directory.<p>The only usecase I see for this is as an alternative to a more traditional bittorrent client.</div><br/><div id="40047645" class="c"><input type="checkbox" id="c-40047645" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047507">parent</a><span>|</span><a href="#40049690">next</a><span>|</span><label class="collapse" for="c-40047645">[-]</label><label class="expand" for="c-40047645">[11 more]</label></div><br/><div class="children"><div class="content">got it. but now i kind of want a torrent-based dropbox. i have five workstations. would be great to be able to utilize them as my own miniature distributed file system without a corporate server.</div><br/><div id="40047675" class="c"><input type="checkbox" id="c-40047675" checked=""/><div class="controls bullet"><span class="by">ggop</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40047862">next</a><span>|</span><label class="collapse" for="c-40047675">[-]</label><label class="expand" for="c-40047675">[2 more]</label></div><br/><div class="children"><div class="content">You could try Syncthing
<a href="https:&#x2F;&#x2F;docs.syncthing.net&#x2F;intro&#x2F;getting-started.html" rel="nofollow">https:&#x2F;&#x2F;docs.syncthing.net&#x2F;intro&#x2F;getting-started.html</a></div><br/><div id="40048066" class="c"><input type="checkbox" id="c-40048066" checked=""/><div class="controls bullet"><span class="by">jtriangle</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047675">parent</a><span>|</span><a href="#40047862">next</a><span>|</span><label class="collapse" for="c-40048066">[-]</label><label class="expand" for="c-40048066">[1 more]</label></div><br/><div class="children"><div class="content">Syncthing experience is greatly improved if you also host your own discovery server, and if you can port forward.<p>Pretty minor to do, but, it&#x27;s a big speed increase.</div><br/></div></div></div></div><div id="40047862" class="c"><input type="checkbox" id="c-40047862" checked=""/><div class="controls bullet"><span class="by">zed716</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40047675">prev</a><span>|</span><a href="#40047751">next</a><span>|</span><label class="collapse" for="c-40047862">[-]</label><label class="expand" for="c-40047862">[1 more]</label></div><br/><div class="children"><div class="content">There used to be something that worked exactly in this manner, called AeroFS -- There was a website portion that worked just like Dropbox did, and then a client you could install on your systems, and it would distribute items in a torrent-like manner between clients. It had a lot of neat features. It&#x27;s a shame that it didn&#x27;t end up really going anywhere (in a very crowded field at the time), because it worked great and they had an on-prem solution that worked really well.</div><br/></div></div><div id="40047751" class="c"><input type="checkbox" id="c-40047751" checked=""/><div class="controls bullet"><span class="by">vineyardmike</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40047862">prev</a><span>|</span><a href="#40047785">next</a><span>|</span><label class="collapse" for="c-40047751">[-]</label><label class="expand" for="c-40047751">[2 more]</label></div><br/><div class="children"><div class="content">There have been a bunch of projects that tried to do some variant this, and I&#x27;d love for it to exist, but I&#x27;d almost posit it&#x27;s an impossible problem. Projects either find a way to handle the content-addressing, but then fail on coordinating nodes, or can coordinate but can&#x27;t choose placement efficiently, or are just vaporware. I think the hard part is most personal computers are too unreliable to trust, and centralization, even for a homelab experimental user, is just too easy.<p>A few projects that tackled some version of this...<p>Nextcloud, Owncloud, and generally just NAS can be &quot;dropbox but self hosted&quot; but its centralized.<p>IPFS, Perkeep, Iroh, hypercore (npm), focused on content-addressed information, making cataloging and sharing easy, but fail to really handle coordination of which node the data goes on.<p>Syncthing, Garage, and of course BitTorrent, and a few others can coordinate but they all duplicate everything everywhere.<p>&quot;Bazil.org&quot;, and (dead link) &quot;infinit.sh&quot; both sought to coordinate distribution and somehow catalog the data, but they both seem to have died without achieving their goals. I used infinit.sh when it was alive ~2016 but it was too slow to use for anything.<p>I&#x27;d love for something like this to exist, but I think its an impossible mission.</div><br/><div id="40047765" class="c"><input type="checkbox" id="c-40047765" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047751">parent</a><span>|</span><a href="#40047785">next</a><span>|</span><label class="collapse" for="c-40047765">[-]</label><label class="expand" for="c-40047765">[1 more]</label></div><br/><div class="children"><div class="content">...wow, kind of fascinating. wish there was a post-mortem on failed attempts at this. I would not expect this, of all problems, to be unsolvable in 2024.</div><br/></div></div></div></div><div id="40047785" class="c"><input type="checkbox" id="c-40047785" checked=""/><div class="controls bullet"><span class="by">kaetemi</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40047751">prev</a><span>|</span><a href="#40048013">next</a><span>|</span><label class="collapse" for="c-40047785">[-]</label><label class="expand" for="c-40047785">[1 more]</label></div><br/><div class="children"><div class="content">Resilio Sync (previously BitTorrent sync) is what you&#x27;re looking for.</div><br/></div></div><div id="40048013" class="c"><input type="checkbox" id="c-40048013" checked=""/><div class="controls bullet"><span class="by">r14c</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40047785">prev</a><span>|</span><a href="#40047820">next</a><span>|</span><label class="collapse" for="c-40048013">[-]</label><label class="expand" for="c-40048013">[1 more]</label></div><br/><div class="children"><div class="content">tahoe-lafs might do what you need!</div><br/></div></div><div id="40047820" class="c"><input type="checkbox" id="c-40047820" checked=""/><div class="controls bullet"><span class="by">baobun</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40048013">prev</a><span>|</span><a href="#40047674">next</a><span>|</span><label class="collapse" for="c-40047820">[-]</label><label class="expand" for="c-40047820">[1 more]</label></div><br/><div class="children"><div class="content">There are families of distributed filesystems. Most famous would be Ceph and GlusterFS and there are a many newer ones - maybe one of them would fit your use-case?</div><br/></div></div><div id="40047674" class="c"><input type="checkbox" id="c-40047674" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40047448">root</a><span>|</span><a href="#40047645">parent</a><span>|</span><a href="#40047820">prev</a><span>|</span><a href="#40048484">next</a><span>|</span><label class="collapse" for="c-40047674">[-]</label><label class="expand" for="c-40047674">[1 more]</label></div><br/><div class="children"><div class="content">IPFS?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>