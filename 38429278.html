<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701162059392" as="style"/><link rel="stylesheet" href="styles.css?v=1701162059392"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arangodb.com/2021/02/cpp-memory-model-migrating-from-x86-to-arm/">C++ Memory Model: Migrating from x86 to ARM</a> <span class="domain">(<a href="https://arangodb.com">arangodb.com</a>)</span></div><div class="subtext"><span>signa11</span> | <span>2 comments</span></div><br/><div><div id="38443562" class="c"><input type="checkbox" id="c-38443562" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><label class="collapse" for="c-38443562">[-]</label><label class="expand" for="c-38443562">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using &quot;sfence&quot; memory barrier to enforce visibility in my programs on amd64&#x2F;x86_64.<p>It&#x27;s good to know that my programs might need to be adjusted.<p>Chris Wellons [1] has an interesting post about using an explicit __ATOMIC_RELEASE and then __ATOMIC_ACQUIRE to tell thread sanitizer that there is definitely a happens-before relationship between threads.<p>[1]: <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2022&#x2F;10&#x2F;03&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2022&#x2F;10&#x2F;03&#x2F;</a><p>I have an idea: I would really like to layer an abstraction ontop of the memory model to formulate a protocol for interprocess&#x2F;interthread communication. In other words, the cache coherency protocol IS the protocol for message passing. No locks!<p>My understanding is that memory_order_seq_cst or _ATOMIC_SEQ_CST in gcc C means all atomic operations in the same thread happens sequentially from the perspective of other threads.<p>This whitepaper (&quot;How to miscompile programs with “benign” data races&quot;) discusses more about compiler optimisations breaking data races.<p>[2]: <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;event&#x2F;hotpar11&#x2F;tech&#x2F;final_files&#x2F;Boehm.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;event&#x2F;hotpar11&#x2F;tech&#x2F;final_file...</a></div><br/></div></div></div></div></div></div></div></body></html>