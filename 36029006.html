<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684918865747" as="style"/><link rel="stylesheet" href="styles.css?v=1684918865747"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://writings.stephenwolfram.com/2010/11/programming-with-natural-language-is-actually-going-to-work/">Programming with Natural Language Is Going to Work (2010)</a> <span class="domain">(<a href="https://writings.stephenwolfram.com">writings.stephenwolfram.com</a>)</span></div><div class="subtext"><span>mrleinad</span> | <span>89 comments</span></div><br/><div><div id="36053384" class="c"><input type="checkbox" id="c-36053384" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36052582">next</a><span>|</span><label class="collapse" for="c-36053384">[-]</label><label class="expand" for="c-36053384">[33 more]</label></div><br/><div class="children"><div class="content">Remember the phrase &quot;developers spend 10% of the time writing code and 90% of the time debugging?&quot;<p>Even if it isn&#x27;t 90%, most developers <i>like</i> writing code more than debugging, so most would prefer to automate the latter.<p>AI translating natural language into code probably isn&#x27;t as important as AI generating bug-free code and&#x2F;or debugging its code. Even GPT-4 struggles with this: sometimes you point out a bug and it works, but sometimes it just can&#x27;t find the issue and starts hallucinating even more as it gets confused.<p>Everyone&#x27;s trying to train GPT models to write code, but maybe we should be training them how to use a debugger. Though its a lot harder to map text generation to debugging...<p>Also, it&#x27;s a bit ironic how one way to prevent bugs is using stronger type systems and formal methods. But, AI is particularly bad at formal methods. But maybe with a system like MCTS combined with much faster generation...</div><br/><div id="36055566" class="c"><input type="checkbox" id="c-36055566" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36054938">next</a><span>|</span><label class="collapse" for="c-36055566">[-]</label><label class="expand" for="c-36055566">[1 more]</label></div><br/><div class="children"><div class="content">I have worked on one 30 year old system that was written by people that knew what they were doing<p>it was then maintained by at least 20 different people that had no idea what they were doing<p>very little of the altered logic makes any sense and 95% of the time consists of trying to reverse engineer what they were trying to do<p>then fix it up without breaking other parts of the codebase as many of the logic bugs interact with each other and end up cancelling out<p>with the garbage generated by LLMs... I suspect all development is going to turn into this</div><br/></div></div><div id="36054938" class="c"><input type="checkbox" id="c-36054938" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36055566">prev</a><span>|</span><a href="#36055251">next</a><span>|</span><label class="collapse" for="c-36054938">[-]</label><label class="expand" for="c-36054938">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Everyone&#x27;s trying to train GPT models to write code, but maybe we should be training them how to use a debugger. Though its a lot harder to map text generation to debugging...<p>We can actually try this now. Literally tell the LLM what you want to do and work with it. See how far you can take it. You will of course be asking the LLM for debug line inputs and you will be providing it with outputs as you run the debugger yourself.</div><br/><div id="36055074" class="c"><input type="checkbox" id="c-36055074" checked=""/><div class="controls bullet"><span class="by">antihipocrat</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36054938">parent</a><span>|</span><a href="#36055251">next</a><span>|</span><label class="collapse" for="c-36055074">[-]</label><label class="expand" for="c-36055074">[3 more]</label></div><br/><div class="children"><div class="content">Or just learn to write it ourselves? If it takes the same amount of time to work with the LLM as coding it from scratch then I&#x27;d prefer to improve my coding ability while I do the work.</div><br/><div id="36055121" class="c"><input type="checkbox" id="c-36055121" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055074">parent</a><span>|</span><a href="#36055251">next</a><span>|</span><label class="collapse" for="c-36055121">[-]</label><label class="expand" for="c-36055121">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just saying the tech is already here. The core engine can do it.<p>Before you go on and write such a system it&#x27;s better to test if the LLM can do debugging to an efficacy level that we require. I don&#x27;t think anyone has tried this yet and we do know LLMs have certain issues.<p>But make no mistake, the possibility that an LLM knows how to debug programs is actually quite high. If it can do this: <a href="https:&#x2F;&#x2F;www.engraved.blog&#x2F;building-a-virtual-machine-inside&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.engraved.blog&#x2F;building-a-virtual-machine-inside&#x2F;</a> it can likely debug a program, but I can&#x27;t say definitively because I&#x27;m too lazy to try.</div><br/><div id="36055334" class="c"><input type="checkbox" id="c-36055334" checked=""/><div class="controls bullet"><span class="by">antihipocrat</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055121">parent</a><span>|</span><a href="#36055251">next</a><span>|</span><label class="collapse" for="c-36055334">[-]</label><label class="expand" for="c-36055334">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing that link, from that example I can see how LLMs could be used to speed up the learning process.<p>I do wonder though whether the methods that the LLM provides are reflective of best practice or whether they are simply what happens to be most written in SO or blog posts.</div><br/></div></div></div></div></div></div></div></div><div id="36055251" class="c"><input type="checkbox" id="c-36055251" checked=""/><div class="controls bullet"><span class="by">mattlutze</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36054938">prev</a><span>|</span><a href="#36055097">next</a><span>|</span><label class="collapse" for="c-36055251">[-]</label><label class="expand" for="c-36055251">[4 more]</label></div><br/><div class="children"><div class="content">Most software devs would prefer a debugger, but most non-software devs would probably prefer a virtual developer.<p>If a technical product manager was able to generate the code needed for a feature using some combination of LLMs and CoPilots—even for proof of concepts, for example—the business would need to hire fewer developers and saves significant operating costs.<p>Extending it to your everyday person. Aunt Jane bought a new washing machine and wants to add it into her smart house. Either she&#x27;s gotta call the niece to hook it all up, write the integration to Home Assistant, write automations for her iOS devices, etc, or, she asks her favorite LLM &#x2F; Co-Pilot for help and it step-by-step walks her through it directly, with code, with individual troubleshooting.<p>There&#x27;s business in both use cases, but the total addressable market is quite a bit bigger for one of them.</div><br/><div id="36055277" class="c"><input type="checkbox" id="c-36055277" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055251">parent</a><span>|</span><a href="#36055337">next</a><span>|</span><label class="collapse" for="c-36055277">[-]</label><label class="expand" for="c-36055277">[2 more]</label></div><br/><div class="children"><div class="content">How about the washing machine just plugs itself seamlessly into her smart house, without Aunt Jane having to do anything than a quick identity check on her phone? Probably needs to be an Apple washing machine, though.</div><br/><div id="36055409" class="c"><input type="checkbox" id="c-36055409" checked=""/><div class="controls bullet"><span class="by">brokenkebaby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055277">parent</a><span>|</span><a href="#36055337">next</a><span>|</span><label class="collapse" for="c-36055409">[-]</label><label class="expand" for="c-36055409">[1 more]</label></div><br/><div class="children"><div class="content">...with expensive quickly deteriorating cable</div><br/></div></div></div></div><div id="36055337" class="c"><input type="checkbox" id="c-36055337" checked=""/><div class="controls bullet"><span class="by">discreteevent</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055251">parent</a><span>|</span><a href="#36055277">prev</a><span>|</span><a href="#36055097">next</a><span>|</span><label class="collapse" for="c-36055337">[-]</label><label class="expand" for="c-36055337">[1 more]</label></div><br/><div class="children"><div class="content">&gt;it step-by-step walks her through it directly, with code<p>This is exactly where it completely breaks down. The AI might as well show her some hieroglyphics.</div><br/></div></div></div></div><div id="36055097" class="c"><input type="checkbox" id="c-36055097" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36055251">prev</a><span>|</span><a href="#36054444">next</a><span>|</span><label class="collapse" for="c-36055097">[-]</label><label class="expand" for="c-36055097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, it&#x27;s a bit ironic how one way to prevent bugs is using stronger type systems and formal methods. But, AI is particularly bad at formal methods.<p>It kinda works tho. In my anecdote Copilot works much better with C# than Python simply because I can write the signature of a function and that it generates the content.<p>(I know Python has type annotations too, but Copilot just isn&#x27;t as smart as with C#. Perhaps because there isn&#x27;t enough training data in typed Python?)</div><br/></div></div><div id="36054444" class="c"><input type="checkbox" id="c-36054444" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36055097">prev</a><span>|</span><a href="#36055194">next</a><span>|</span><label class="collapse" for="c-36054444">[-]</label><label class="expand" for="c-36054444">[15 more]</label></div><br/><div class="children"><div class="content">Training an AI to write unit tests (and refactor code to be more testable) would be a real game changer.</div><br/><div id="36055031" class="c"><input type="checkbox" id="c-36055031" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36054444">parent</a><span>|</span><a href="#36054981">next</a><span>|</span><label class="collapse" for="c-36055031">[-]</label><label class="expand" for="c-36055031">[12 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you get it. The game has already changed. And nobody trained the AI to write unit tests or refactor code. It could do it as emergent behavior.<p>It happened so fast that so many people are in denial and many people aren&#x27;t even asking the obvious questions. Simply ASK chatGPT to refactor your code to be more unit testable and IT Can do it.<p>Of course it clearly has your typical LLM problems but it is roughly 50% there. The game has changed. If AI gets to 100%, not only will the game be changed, but humans will no longer be part of the game.<p>See what I asked chatGPT:<p><pre><code>   ME:
   def (x: int):
      for i in range(x):
         print(i)

   Can you refactor the code so it can be more unit testable?


   CHATGPT:
   Certainly! To make the code more unit testable, we can refactor it into a function that returns a list of integers instead of directly printing them. Here&#x27;s the refactored code:

   python

   def generate_number_list(x: int) -&gt; List[int]:
       number_list = []
       for i in range(x):
           number_list.append(i)
       return number_list

   In this refactored code, we&#x27;ve created a function called generate_number_list that takes an integer x as input. Instead of printing each number, we use a number_list variable to store the generated numbers by appending them in the loop. Finally, we return the number_list.

   By returning the list instead of printing the numbers directly, we make the code more testable because we can now write unit tests that assert the correctness of the generated list.
</code></pre>
If boggles my mind that I see threads of people saying &quot;what if we train LLMs to do this or to do that?&quot; or whatever. Guys, just ask the LLM to do what you want in plain English. It can do it.</div><br/><div id="36055086" class="c"><input type="checkbox" id="c-36055086" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055031">parent</a><span>|</span><a href="#36055545">next</a><span>|</span><label class="collapse" for="c-36055086">[-]</label><label class="expand" for="c-36055086">[9 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t the game.<p>The game is designing software to requirements. It&#x27;s writing literature for a new era. It&#x27;s creating X for A audience with N vauge unspecified needs -- where X is a complex product made of many parts, involving many people, with shifting and changing problems&#x2F;solutions&#x2F;requirements.<p>The game was never writing the stack overflow answer -- that was already written.</div><br/><div id="36055142" class="c"><input type="checkbox" id="c-36055142" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055086">parent</a><span>|</span><a href="#36055545">next</a><span>|</span><label class="collapse" for="c-36055142">[-]</label><label class="expand" for="c-36055142">[8 more]</label></div><br/><div class="children"><div class="content">&gt;The game was never writing the stack overflow answer -- that was already written.<p>The problem is this was never a stackoverflow question and there was never an answer for it.<p>Try finding it. The LLM is already playing the game because it came up with that answer which is Fully Correct, Out of Thin Air.<p>Look, clearly the LLM can&#x27;t play the game as well as a trained adept human, but it&#x27;s definitely playing the game.<p>&gt;The game is designing software to requirements. It&#x27;s writing literature for a new era. It&#x27;s creating X for A audience with N vauge unspecified needs -- where X is a complex product made of many parts, involving many people, with shifting and changing problems&#x2F;solutions&#x2F;requirements.<p>It can do all of this. It can talk like you and parrot exactly what your saying and also go into more detail and re-frame your words more eloquently.<p>What you&#x27;re not getting is that all the things you mentioned the LLM can do in actuality to varying degrees to the point where it is in the &quot;game.&quot; and at times it does better than us. Likely, you haven&#x27;t even tried asking it yet.</div><br/><div id="36055242" class="c"><input type="checkbox" id="c-36055242" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055142">parent</a><span>|</span><a href="#36055265">next</a><span>|</span><label class="collapse" for="c-36055242">[-]</label><label class="expand" for="c-36055242">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Fully Correct, Out of Thin Air<p>I think if you&#x27;re an expert in an area, this effect is easier to see through. You know where the github repo is, where the library example is, which ebooks there area -- etc. and you&#x27;re mostly at-ease not using them and just writing the solution yourself.<p>These systems are not &quot;fully correct&quot; and not &quot;out of thin area&quot;. They are trained on everything ever digitised, including the entire internet. They, in effect, find similar historical cases to your query and merge them. In many cases, for specific enough queries, the text is verbatim from an original source.<p>This is less revolutionary than the spreadsheet; it&#x27;s less than google search. It&#x27;s a speed boost to what was always the most wrote element to what we do. Yes, that often took us the longest -- and so some might be afraid that&#x27;s what labour is -- but it isnt.<p>We never &quot;added value&quot; to products via what may be automated. Value is <i>always</i> a matter of the desire of the buyer of the products of our labour (vs. the supply) -- and making those products <i>for</i> those buyers was always what they wanted.<p>This will be clear to everyone pretty quickly, as with all tech, it&#x27;s &quot;magic&quot; on the first encounter -- until the limitations are exposed.<p>I actually work in an area where what took 3mo last year, I can now do in maybe 3 days due to ChatGPT. But when it comes to providing my customers with that content, the value was always in <i>how</i> I provided it and what it did for them.<p>I think this makes my skills more valuable, not less. Since the quality of products will be even more stratified by experts who can quickly assemble what the customer needs from non-experts who have to fight through AI dialogue to get something generic.</div><br/><div id="36055374" class="c"><input type="checkbox" id="c-36055374" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055242">parent</a><span>|</span><a href="#36055325">next</a><span>|</span><label class="collapse" for="c-36055374">[-]</label><label class="expand" for="c-36055374">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I think if you&#x27;re an expert in an area,<p>Experts in the area, including Hinton, the father of modern AI, self admit they don&#x27;t fully understand what&#x27;s going on but they think that LLMs know what they are talking about.<p>&gt;These systems are not &quot;fully correct&quot; and not &quot;out of thin area&quot;. They are trained on everything ever digitised, including the entire internet. They, in effect, find similar historical cases to your query and merge them. In many cases, for specific enough queries, the text is verbatim from an original source.<p>I never said the systems are fully correct. I said that for my specific example the answer is fully correct and out of thin air. No such question and answer pair exists on the internet. Find it and prove me wrong.<p>&gt;This will be clear to everyone pretty quickly, as with all tech, it&#x27;s &quot;magic&quot; on the first encounter -- until the limitations are exposed.<p>Except many experts are saying the exact opposite of what you&#x27;re saying. I&#x27;m just parroting the experts..<p>&gt;I actually work in an area where what took 3mo last year, I can now do in maybe 3 days due to ChatGPT. But when it comes to providing my customers with that content, the value was always in how I provided it and what it did for them.<p>So if they knew you were just copying and pasting their queries to chatgpt would they still care about the &quot;how&quot;? I doubt it.</div><br/></div></div><div id="36055325" class="c"><input type="checkbox" id="c-36055325" checked=""/><div class="controls bullet"><span class="by">mchaver</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055242">parent</a><span>|</span><a href="#36055374">prev</a><span>|</span><a href="#36055265">next</a><span>|</span><label class="collapse" for="c-36055325">[-]</label><label class="expand" for="c-36055325">[2 more]</label></div><br/><div class="children"><div class="content">I agree. LLMs are very impressive, but it isn&#x27;t helpful to think of them of magic. LLMs are a great tool to explore and remix the body of human knowledge on the internet (limited to what it has been trained on).<p>The user needs to keep in mind that it can give plenty of false information. To make good use of it, the user needs to be able to verify if the returned information is useful, makes sense, compare with first hand sources, etc. In the hands of expert that is really powerful. In the hands of a layman (on the subject in question), they can generate a lot of crap and misunderstand what it is saying. It is similar to the idea that Democracy can be a great tool, but it needs an educated and participatory populous or it may generate a lot of headaches.</div><br/><div id="36055414" class="c"><input type="checkbox" id="c-36055414" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055325">parent</a><span>|</span><a href="#36055265">next</a><span>|</span><label class="collapse" for="c-36055414">[-]</label><label class="expand" for="c-36055414">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I agree. LLMs are very impressive, but it isn&#x27;t helpful to think of them of magic. LLMs are a great tool to explore and remix the body of human knowledge on the internet (limited to what it has been trained on).<p>Of course you shouldn&#x27;t think of it as magic. But, the experts self admit they don&#x27;t fully understand how LLMs can produce such output. It&#x27;s definitely emergent behavior. We&#x27;ve built something we don&#x27;t understand, and although it&#x27;s not magic, it&#x27;s one of the closest things to it that can exist. Think about it. What is the closest thing in reality to magic? Literally, building something we can&#x27;t understand is it.<p>It&#x27;s one thing to think of something as magic, it&#x27;s another thing to try to simplify a highly complex concept into a box. When elon musk got his rockets to space why were people so floored by decades old technology that he simply made cheaper?<p>But when someone makes AI that can literally do almost anything you ask it to everyone just suddenly says it&#x27;s a simple stochastic parrot that can&#x27;t do much?<p>I think it&#x27;s obvious. It&#x27;s because a rocket can&#x27;t replace your job or your identity. If part of your skillset and identity is &quot;master programmer&quot; and suddenly there&#x27;s a machine that can do better than you, the easiest thing to stop that machine is to first deny reality.</div><br/></div></div></div></div></div></div><div id="36055265" class="c"><input type="checkbox" id="c-36055265" checked=""/><div class="controls bullet"><span class="by">mchaver</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055142">parent</a><span>|</span><a href="#36055242">prev</a><span>|</span><a href="#36055282">next</a><span>|</span><label class="collapse" for="c-36055265">[-]</label><label class="expand" for="c-36055265">[2 more]</label></div><br/><div class="children"><div class="content">I think this is one of the killer applications of LLMs, a friendly Stack Overflow where you can ask any programming question you want with out fear of being reprimanded. Of course, this capability in LLM is probably due to the terseness of Stack Overflow and the large database of code in Github.<p>However, in its current state users still have to know how to program in order to make good use of it. It will still give you lots of errors, but being able to get something close to your goal can save you a lot of time. Someone who does not know how to program will not be able to use these to put together a complex, useful and reliable system. It might change in the future, but these things are hard to predict.</div><br/><div id="36055472" class="c"><input type="checkbox" id="c-36055472" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055265">parent</a><span>|</span><a href="#36055282">next</a><span>|</span><label class="collapse" for="c-36055472">[-]</label><label class="expand" for="c-36055472">[1 more]</label></div><br/><div class="children"><div class="content">&gt; fear of being reprimanded.<p>Don&#x27;t worry about this. You can get over the fear. I&#x27;m in the top 10% of stackoverflow users in terms of points and it&#x27;s all because my stupidest questions from decades back gathered thousands of points from other stupid idiots like me. Who cares. Literally the line graph keeps climbing with no effort from me all from my dumbest questions. Just ask and don&#x27;t worry about the criticism, you&#x27;ll get a bit, but not too much.<p>&gt;However, in its current state users still have to know how to program in order to make good use of it. It will still give you lots of errors, but being able to get something close to your goal can save you a lot of time. Someone who does not know how to program will not be able to use these to put together a complex, useful and reliable system. It might change in the future, but these things are hard to predict.<p>Of course. I think the thing I was trying to point out is the breadth of what chatgpt can do. So if you ask it to do a really in depth and detailed task it&#x27;s likely to do it with flaws. That&#x27;s not the point I was trying to emphasize, not the fact that it can&#x27;t do any task with great depth but the fact that it can do ANY task. It has huge breadth.<p>So to bring it line with the direction of this thread. People were thinking about making special LLMs that refactor code to be unit testable. I mean we don&#x27;t have to make special LLMs to do that because you can already ask chatgpt to do it already. That&#x27;s the point.</div><br/></div></div></div></div></div></div></div></div><div id="36055545" class="c"><input type="checkbox" id="c-36055545" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055031">parent</a><span>|</span><a href="#36055086">prev</a><span>|</span><a href="#36055273">next</a><span>|</span><label class="collapse" for="c-36055545">[-]</label><label class="expand" for="c-36055545">[1 more]</label></div><br/><div class="children"><div class="content">if it actually understood what it was doing it would tell you that that logic doesn&#x27;t need a test as the python has the range(x) functionality built-in<p>instead it generates a load of redundant boilerplate<p>if I saw a developer check that in I&#x27;d think they were incompetent</div><br/></div></div><div id="36055273" class="c"><input type="checkbox" id="c-36055273" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36055031">parent</a><span>|</span><a href="#36055545">prev</a><span>|</span><a href="#36054981">next</a><span>|</span><label class="collapse" for="c-36055273">[-]</label><label class="expand" for="c-36055273">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it does great on little toy examples.<p>What I would like to do is feed in my entire 50k line program and get something out.</div><br/></div></div></div></div><div id="36054981" class="c"><input type="checkbox" id="c-36054981" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36054444">parent</a><span>|</span><a href="#36055031">prev</a><span>|</span><a href="#36055070">next</a><span>|</span><label class="collapse" for="c-36054981">[-]</label><label class="expand" for="c-36054981">[1 more]</label></div><br/><div class="children"><div class="content">Copilot does a decent job with &quot;dumb&quot; unit tests, e.g. &quot;when the condition X is Y then Z&quot;.<p>But it obviously doesn&#x27;t have knowledge of your domain, and I don&#x27;t think any LLM could do a perfect job without that.</div><br/></div></div><div id="36055070" class="c"><input type="checkbox" id="c-36055070" checked=""/><div class="controls bullet"><span class="by">protortyp</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36054444">parent</a><span>|</span><a href="#36054981">prev</a><span>|</span><a href="#36055194">next</a><span>|</span><label class="collapse" for="c-36055070">[-]</label><label class="expand" for="c-36055070">[1 more]</label></div><br/><div class="children"><div class="content">I already use gpt4 for this. Works quite well if you show it a couple of reference unit tests.</div><br/></div></div></div></div><div id="36055194" class="c"><input type="checkbox" id="c-36055194" checked=""/><div class="controls bullet"><span class="by">ly3xqhl8g9</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36054444">prev</a><span>|</span><a href="#36053570">next</a><span>|</span><label class="collapse" for="c-36055194">[-]</label><label class="expand" for="c-36055194">[1 more]</label></div><br/><div class="children"><div class="content">Train them how to hallucinate the debugger and the world. Forget about running the debugger only for your program, simulate the entire stack, networking and databases included, for a true timeless debugger.</div><br/></div></div><div id="36053570" class="c"><input type="checkbox" id="c-36053570" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#36053384">parent</a><span>|</span><a href="#36055194">prev</a><span>|</span><a href="#36052582">next</a><span>|</span><label class="collapse" for="c-36053570">[-]</label><label class="expand" for="c-36053570">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m imagining an AI based on a deductive system rather than sequential text generation. This is roughly how &quot;strong type systems&quot; work, and so it might be simpler to map this model to formal methods.<p>By the way, if you spend 90% of time debugging your code, I think that&#x27;s really sad. Either the programming language sucks, or the codebase sucks, or both. I probably spend 10-20% max of my time on debugging.</div><br/><div id="36053753" class="c"><input type="checkbox" id="c-36053753" checked=""/><div class="controls bullet"><span class="by">hnfong</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36053570">parent</a><span>|</span><a href="#36052582">next</a><span>|</span><label class="collapse" for="c-36053753">[-]</label><label class="expand" for="c-36053753">[5 more]</label></div><br/><div class="children"><div class="content">The &quot;strong type systems&quot; work by having you design the types correctly in the first place. If designed correctly they work wonders, and 90+% of the time if the code compiles it&#x27;s probably correct. That&#x27;s a big &quot;if&quot; though, and most of your time writing &quot;strong type systems&quot; is coming up with the correct type structure.<p>The one thing worse than debugging code is debugging &quot;types&quot;. Those 30-page C++ compiler errors are definitely worse than whatever I had to do with (for example) Python.</div><br/><div id="36053968" class="c"><input type="checkbox" id="c-36053968" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36053753">parent</a><span>|</span><a href="#36054853">next</a><span>|</span><label class="collapse" for="c-36053968">[-]</label><label class="expand" for="c-36053968">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Those 30-page C++ compiler errors are definitely worse than whatever I had to do with (for example) Python.<p>That&#x27;s definitely in the &quot;programming language sucks&quot; category. Good languages make it easy to debug problems with your types.</div><br/></div></div><div id="36054853" class="c"><input type="checkbox" id="c-36054853" checked=""/><div class="controls bullet"><span class="by">mikebenfield</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36053753">parent</a><span>|</span><a href="#36053968">prev</a><span>|</span><a href="#36055127">next</a><span>|</span><label class="collapse" for="c-36054853">[-]</label><label class="expand" for="c-36054853">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Those 30-page C++ compiler errors are definitely worse than whatever I had to do with (for example) Python.<p>C++ is sort of the canonical example of a language with a terrible type system, so it&#x27;s not really the right place to look for this comparison.</div><br/></div></div><div id="36055127" class="c"><input type="checkbox" id="c-36055127" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36053753">parent</a><span>|</span><a href="#36054853">prev</a><span>|</span><a href="#36054129">next</a><span>|</span><label class="collapse" for="c-36055127">[-]</label><label class="expand" for="c-36055127">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Those 30-page C++ compiler errors are definitely worse than whatever I had to do with (for example) Python.<p>Everyone complains how slowly Rust compiles. But at least its error messages are much better.</div><br/></div></div><div id="36054129" class="c"><input type="checkbox" id="c-36054129" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#36053384">root</a><span>|</span><a href="#36053753">parent</a><span>|</span><a href="#36055127">prev</a><span>|</span><a href="#36052582">next</a><span>|</span><label class="collapse" for="c-36054129">[-]</label><label class="expand" for="c-36054129">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;strong type systems&quot; work by having you design the types correctly in the first place.<p>I was responding to a comment that was suggesting letting an AI to do that.<p>&gt; The one thing worse than debugging code is debugging &quot;types&quot;.<p>It depends on a language. In languages with first-class types, we have the same tools to debug types. Classical C++ templates are more akin to a macro system than a type system.</div><br/></div></div></div></div></div></div></div></div><div id="36052582" class="c"><input type="checkbox" id="c-36052582" checked=""/><div class="controls bullet"><span class="by">lcuff</span><span>|</span><a href="#36053384">prev</a><span>|</span><a href="#36055497">next</a><span>|</span><label class="collapse" for="c-36052582">[-]</label><label class="expand" for="c-36052582">[12 more]</label></div><br/><div class="children"><div class="content">I suspect as things evolve with the Large Language Models, there will be integration with existing computer languages and frameworks.  That the ability to say &quot;Create a web site using language X with framework Y&quot; will become a reality.   This ability to get Hello World done in 5 minutes instead of 1&#x2F;2 a day to walk through a intro book&#x2F;tutorial, well, that&#x27;s a win.<p>Then, down the road, each AI might have a preferred&#x2F;default language, technology and framework. Quite possibly newly created.  This has a parallel to intermediate representations (the earliest of which I&#x27;m aware of is p-code in UCSD Pascal).  But it is also analogous to compiling C to assembler, and then machine code. Similarly with Java.  Wolfram is correct when he talks about needing it to be a representation that the creator can inspect and verify.  Not necessarily the least bit easy with a complex project. It will be an engineering journey, but it does spark in me the hope that English (or anyone&#x27;s native language) becomes the high level language of choice for guiding machines in tasks.  Mathematica?  Humph.  Stephen Wolfram is very pleased with things he&#x27;s thought of or perhaps synthesized, but I&#x27;m gonna say, I think Mathematica is not the generic solution we will want.</div><br/><div id="36052829" class="c"><input type="checkbox" id="c-36052829" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#36052582">parent</a><span>|</span><a href="#36055102">next</a><span>|</span><label class="collapse" for="c-36052829">[-]</label><label class="expand" for="c-36052829">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I suspect as things evolve with the Large Language Models, there will be integration with existing computer languages and frameworks. That the ability to say &quot;Create a web site using language X with framework Y&quot; will become a reality.<p>So, I think a key challenge is that modern programming languages do 2 things simultaneously.<p>1. They provide direct instruction to computers.<p>2. They document precise human intent.<p>Even if the need for part 1 goes away, part 2 will always be with us. I would expect that if natural language programming becomes a thing, that a dialect forms - akin to legalese - that embodies best practices for precisely documenting human intent.</div><br/><div id="36052845" class="c"><input type="checkbox" id="c-36052845" checked=""/><div class="controls bullet"><span class="by">galleywest200</span><span>|</span><a href="#36052582">root</a><span>|</span><a href="#36052829">parent</a><span>|</span><a href="#36055102">next</a><span>|</span><label class="collapse" for="c-36052845">[-]</label><label class="expand" for="c-36052845">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I would expect that if natural language programming becomes a thing, that a dialect forms - akin to legalese - that embodies best practices for precisely documenting human intent.<p>Sort of like how the SQL syntax seems designed for business admin folks to use, but us programmers ended up using it.</div><br/><div id="36053202" class="c"><input type="checkbox" id="c-36053202" checked=""/><div class="controls bullet"><span class="by">ofey404</span><span>|</span><a href="#36052582">root</a><span>|</span><a href="#36052845">parent</a><span>|</span><a href="#36053142">next</a><span>|</span><label class="collapse" for="c-36053202">[-]</label><label class="expand" for="c-36053202">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sort of like how the SQL syntax seems designed for business admin folks to use, but us programmers ended up using it.<p>So it seems that a declarative programming language would be a suitable target for LLM to generate.<p>Maybe someday there would be a popular, shared IR across models, like SQL does to relational database.</div><br/></div></div><div id="36053142" class="c"><input type="checkbox" id="c-36053142" checked=""/><div class="controls bullet"><span class="by">ok_computer</span><span>|</span><a href="#36052582">root</a><span>|</span><a href="#36052845">parent</a><span>|</span><a href="#36053202">prev</a><span>|</span><a href="#36055102">next</a><span>|</span><label class="collapse" for="c-36053142">[-]</label><label class="expand" for="c-36053142">[1 more]</label></div><br/><div class="children"><div class="content">I was going to say the same thing, we’ll all be YELLING OUT SQL to our mic terminals and syntactically backtracking from the expressiveness and imprecision of our dynamic typed languages of choice.</div><br/></div></div></div></div></div></div><div id="36055102" class="c"><input type="checkbox" id="c-36055102" checked=""/><div class="controls bullet"><span class="by">byby</span><span>|</span><a href="#36052582">parent</a><span>|</span><a href="#36052829">prev</a><span>|</span><a href="#36052888">next</a><span>|</span><label class="collapse" for="c-36055102">[-]</label><label class="expand" for="c-36055102">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Create a web site using language X with framework Y<p>Not sure if you played with chatGPT, but you can ALREADY ask it to do this and it will give you something that works 50% of the time.</div><br/></div></div><div id="36052888" class="c"><input type="checkbox" id="c-36052888" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#36052582">parent</a><span>|</span><a href="#36055102">prev</a><span>|</span><a href="#36053340">next</a><span>|</span><label class="collapse" for="c-36052888">[-]</label><label class="expand" for="c-36052888">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This ability to get Hello World done in 5 minutes instead of 1&#x2F;2 a day to walk through a intro book&#x2F;tutorial, well, that&#x27;s a win.</i><p>So a bit like `create-react-app` or `dotnet new` or such, but now powered by AI?*</div><br/><div id="36053470" class="c"><input type="checkbox" id="c-36053470" checked=""/><div class="controls bullet"><span class="by">lcuff</span><span>|</span><a href="#36052582">root</a><span>|</span><a href="#36052888">parent</a><span>|</span><a href="#36053340">next</a><span>|</span><label class="collapse" for="c-36053470">[-]</label><label class="expand" for="c-36053470">[1 more]</label></div><br/><div class="children"><div class="content">Well, I haven&#x27;t used either of those, so I can&#x27;t comment on a comparison ... but the point is less &#x27;powered by an ai&#x27; and more the fact that I&#x27;m using English, not the jargon of create-react-app or dotnet new or the rails version or the django version ... Right now, my experience programming with an AI is that I&#x27;m much better off asking for subroutines to do this and that, not ask for a complete architecture.  Mostly for debugging reasons: When it doesn&#x27;t work, I want the debugging to be manageable.  Getting the AI to debug its own code has not been a productive path for me, but hopefully soon.</div><br/></div></div></div></div><div id="36053340" class="c"><input type="checkbox" id="c-36053340" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#36052582">parent</a><span>|</span><a href="#36052888">prev</a><span>|</span><a href="#36052774">next</a><span>|</span><label class="collapse" for="c-36053340">[-]</label><label class="expand" for="c-36053340">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This ability to get Hello World done in 5 minutes...<p>This has existed since at least 1992 (Visual C++) and probably before that (Borland Pascal?).</div><br/><div id="36053493" class="c"><input type="checkbox" id="c-36053493" checked=""/><div class="controls bullet"><span class="by">lcuff</span><span>|</span><a href="#36052582">root</a><span>|</span><a href="#36053340">parent</a><span>|</span><a href="#36052774">next</a><span>|</span><label class="collapse" for="c-36053493">[-]</label><label class="expand" for="c-36053493">[2 more]</label></div><br/><div class="children"><div class="content">Well, I&#x27;m thinking more of a web site Hello World than a C++ Hello World.  The original point of Hello World (per Kernighan and Ritchie) was to ensure that all the tools were installed (the compiler itself wasn&#x27;t a given) and in your path and configured correctly. So yeah, I was say even in 1988 (when I started programming in C) there&#x27;s a way in which Hello.c was 5 minutes. But when I started with Rails (years later), it was more like 1&#x2F;2 a day, and the Hello World notion had expanded in scope by quite a bit. I didn&#x27;t spell out the _kind_ of Hello World I had in mind. My bad.</div><br/><div id="36054475" class="c"><input type="checkbox" id="c-36054475" checked=""/><div class="controls bullet"><span class="by">riceart</span><span>|</span><a href="#36052582">root</a><span>|</span><a href="#36053493">parent</a><span>|</span><a href="#36052774">next</a><span>|</span><label class="collapse" for="c-36054475">[-]</label><label class="expand" for="c-36054475">[1 more]</label></div><br/><div class="children"><div class="content">Web hello world in rails is literally a single command and seconds.</div><br/></div></div></div></div></div></div><div id="36052774" class="c"><input type="checkbox" id="c-36052774" checked=""/><div class="controls bullet"><span class="by">6510</span><span>|</span><a href="#36052582">parent</a><span>|</span><a href="#36053340">prev</a><span>|</span><a href="#36055497">next</a><span>|</span><label class="collapse" for="c-36052774">[-]</label><label class="expand" for="c-36052774">[1 more]</label></div><br/><div class="children"><div class="content">Front end js is like the nest we&#x27;ve been building for it - not knowing why.</div><br/></div></div></div></div><div id="36055497" class="c"><input type="checkbox" id="c-36055497" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#36052582">prev</a><span>|</span><a href="#36053368">next</a><span>|</span><label class="collapse" for="c-36055497">[-]</label><label class="expand" for="c-36055497">[1 more]</label></div><br/><div class="children"><div class="content">It seems like this article is an advertising for Wolfram Alpha&#x27;s then-new feature. It brings few elements to support the headline thesis, aside from showing these features.</div><br/></div></div><div id="36053368" class="c"><input type="checkbox" id="c-36053368" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#36055497">prev</a><span>|</span><a href="#36052098">next</a><span>|</span><label class="collapse" for="c-36053368">[-]</label><label class="expand" for="c-36053368">[11 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been doing this for 200+ years. All the programming languages we use, and mathematical notation, are based in some way upon natural language concepts (yes even FP languages). So really we&#x27;re talking about a continuum. And also worth noting that human languages evolve over time. So both programming languages will evolve to be more natural, and natural language will evolve to be more machine-parsable.</div><br/><div id="36053395" class="c"><input type="checkbox" id="c-36053395" checked=""/><div class="controls bullet"><span class="by">gwoolhurme</span><span>|</span><a href="#36053368">parent</a><span>|</span><a href="#36053569">next</a><span>|</span><label class="collapse" for="c-36053395">[-]</label><label class="expand" for="c-36053395">[7 more]</label></div><br/><div class="children"><div class="content">Yeah. The first time I saw Haskell written out, it felt like a blending of formal math and programming. I was really excited at how it looks like it could have come from my discrete math book. I don&#x27;t think programming in english is a good idea, but like you said, we will probably get something that looks more like formal languages, because that&#x27;s what we&#x27;ve always done.</div><br/><div id="36053685" class="c"><input type="checkbox" id="c-36053685" checked=""/><div class="controls bullet"><span class="by">grt_thr</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36053395">parent</a><span>|</span><a href="#36053569">next</a><span>|</span><label class="collapse" for="c-36053685">[-]</label><label class="expand" for="c-36053685">[6 more]</label></div><br/><div class="children"><div class="content">Mathematics as shown in textbooks is not rigorous. I don&#x27;t understand why so many people fetishize something they saw at university.<p>Formalised mathematics are incomprehensible to humans and orders of magnitude longer then anything you can see in textbook or mathematical papers outside automated theorem proving.</div><br/><div id="36053874" class="c"><input type="checkbox" id="c-36053874" checked=""/><div class="controls bullet"><span class="by">hnfong</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36053685">parent</a><span>|</span><a href="#36053957">next</a><span>|</span><label class="collapse" for="c-36053874">[-]</label><label class="expand" for="c-36053874">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of a tangential rant in the book &quot;The Poincare Conjecture&quot;:<p>&quot;... the postulates are unclear. Does postulate 2 mean that we can extend any line segment forever? Does it mean that we can cut up any segment? And if it means the first, who is to say that the resulting line is unique? And how seriously should we take the definitions? Are they just meant to provide guidance about a word that is essentially undefined (today&#x27;s, and probably Euclid&#x27;s, in-terpretation) or are they supposed to completely specify the object named? In the latter case, just what does the phrase &quot;a breadthless length&quot; mean?<p>Mathematicians and scholars know that there are gaps in Euclid, and there has been a great deal of discussion over the ages about alternate axioms, or possible additional ones. That has not stopped generations of worshipful school-masters, besotted with the majestic order, the accessibility and the patent usefulness of the Elements from rushing in and trumpeting it as the finest in human thought. However, to a thoughtful student, the Elements can seem less rational than capricious. The insistence that the Elements is flawless, and the apex of rigorous thought, turns some students away from mathematics. One wonders how much fear of mathematics stems from the disjuncture between the assertion that Euclid is perfect and some students&#x27; intuitive, but difficult to articulate, sense that some things in it are not quite right. Unless you are unusually rebel-lious, it is easy blame yourself and conclude that mathematics is beyond you.<p>It is worth bearing in mind that mathematical results, for all they are represented as eternal and outside specific human cultures, are in fact transmitted and understood within definite social and cultural contexts. Some argue, for example, that the Greeks invented proof in order to make sense of the statements of mathematical results of Babylon and Egypt without access to the context in which such results were used and discovered. In order to make use of the results, the Greeks needed to sort out different, seemingly...&quot;</div><br/></div></div><div id="36053957" class="c"><input type="checkbox" id="c-36053957" checked=""/><div class="controls bullet"><span class="by">gwoolhurme</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36053685">parent</a><span>|</span><a href="#36053874">prev</a><span>|</span><a href="#36053569">next</a><span>|</span><label class="collapse" for="c-36053957">[-]</label><label class="expand" for="c-36053957">[4 more]</label></div><br/><div class="children"><div class="content">We might have different definitions my good sir. Granted I don&#x27;t have a PhD in math and my math stopped at a masters. To me formalization is theorems and proofs, which are 100% comprehensible to humans. For reference: <a href="http:&#x2F;&#x2F;www.vdash.org&#x2F;formal&#x2F;#math" rel="nofollow">http:&#x2F;&#x2F;www.vdash.org&#x2F;formal&#x2F;#math</a><p>Everything in that link looks like programming, especially when you consider something like Haskell. Even formalism as a philosophy tries to add logic to natural language it self. So I am not sure where I am fetishizing what I saw at university. Care to explain without the snark?</div><br/><div id="36054140" class="c"><input type="checkbox" id="c-36054140" checked=""/><div class="controls bullet"><span class="by">grt_thr</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36053957">parent</a><span>|</span><a href="#36053569">next</a><span>|</span><label class="collapse" for="c-36054140">[-]</label><label class="expand" for="c-36054140">[3 more]</label></div><br/><div class="children"><div class="content">That is a proof of the same way that<p><pre><code>    print(&quot;Hello World&quot;)
</code></pre>
is an executable.</div><br/><div id="36054176" class="c"><input type="checkbox" id="c-36054176" checked=""/><div class="controls bullet"><span class="by">gwoolhurme</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36054140">parent</a><span>|</span><a href="#36054174">next</a><span>|</span><label class="collapse" for="c-36054176">[-]</label><label class="expand" for="c-36054176">[1 more]</label></div><br/><div class="children"><div class="content">Ah I did say they were proofs... that is my fault, what I mean to say is that formalization is the way they are written, is very much a language. Either way. Not sure where the venom was coming from</div><br/></div></div><div id="36054174" class="c"><input type="checkbox" id="c-36054174" checked=""/><div class="controls bullet"><span class="by">gwoolhurme</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36054140">parent</a><span>|</span><a href="#36054176">prev</a><span>|</span><a href="#36053569">next</a><span>|</span><label class="collapse" for="c-36054174">[-]</label><label class="expand" for="c-36054174">[1 more]</label></div><br/><div class="children"><div class="content">I never said they were proofs right? I am still confused. I was talking about foramalizing and how at least to me I see programming in it. Even something extremely complex like &quot;The Strong Perfect Graph Theorem&quot; is still readable and reads like english+programming. That&#x27;s why I said haskell looks like it comes out of a discrete mathbook. I am not sure what your point is or where my fetishization is coming from.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36053569" class="c"><input type="checkbox" id="c-36053569" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36053368">parent</a><span>|</span><a href="#36053395">prev</a><span>|</span><a href="#36052098">next</a><span>|</span><label class="collapse" for="c-36053569">[-]</label><label class="expand" for="c-36053569">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So both programming languages will evolve to be more natural, and natural language will evolve to be more machine-parsable.<p>Hard disagree. Is Rust similar to natural language? Has English become more similar to &lt;pick the easiest programming language&gt;?</div><br/><div id="36053631" class="c"><input type="checkbox" id="c-36053631" checked=""/><div class="controls bullet"><span class="by">gwoolhurme</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36053569">parent</a><span>|</span><a href="#36053597">next</a><span>|</span><label class="collapse" for="c-36053631">[-]</label><label class="expand" for="c-36053631">[1 more]</label></div><br/><div class="children"><div class="content">Just to play with the logic a bit. I could see natural language coming up with formal templating to get something closer to a programming language. Not like how we speak will change, but more like how a haiku works is formalized. Similarly to how every CS1 class in university has people who do the &quot;write the steps in making a sandwich&quot; exercise. That exercise is actually easier in a programming language, because of the nature of what a programming language is, its instructions in steps at the end of the day. So perhaps something is formalized that way? Also most modern languages have been slowly adding in things that are easier to read from a natural language perspective VS classical C syntax style. Rust is very C-like but still has plenty of FP like functions built in too.</div><br/></div></div><div id="36053597" class="c"><input type="checkbox" id="c-36053597" checked=""/><div class="controls bullet"><span class="by">EamonnMR</span><span>|</span><a href="#36053368">root</a><span>|</span><a href="#36053569">parent</a><span>|</span><a href="#36053631">prev</a><span>|</span><a href="#36052098">next</a><span>|</span><label class="collapse" for="c-36053597">[-]</label><label class="expand" for="c-36053597">[1 more]</label></div><br/><div class="children"><div class="content">The way you&#x27;re using brackets sure resembles Backus-Naur form.</div><br/></div></div></div></div></div></div><div id="36052098" class="c"><input type="checkbox" id="c-36052098" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36053368">prev</a><span>|</span><a href="#36054429">next</a><span>|</span><label class="collapse" for="c-36052098">[-]</label><label class="expand" for="c-36052098">[28 more]</label></div><br/><div class="children"><div class="content">Sure, if the natural language we&#x27;re talking about is formalized to the point of basically being math.  Let&#x27;s not confuse that with &quot;everyone will be able to program&quot;, though.</div><br/><div id="36052498" class="c"><input type="checkbox" id="c-36052498" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#36052098">parent</a><span>|</span><a href="#36052182">next</a><span>|</span><label class="collapse" for="c-36052498">[-]</label><label class="expand" for="c-36052498">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll be the same way everybody can program with Excel right now. Things will work fine, until they don&#x27;t anymore, at which point a professional will be brought in to help fix &quot;the bug&quot;. Obviously, that bug will the obvious result of the whole thing being a horrible mess and will be unfixable without a proper rewrite.<p>_Maybe_ the AI will be able to help with the rewrite, generating test cases and translating business logic, which would be nice.</div><br/><div id="36053402" class="c"><input type="checkbox" id="c-36053402" checked=""/><div class="controls bullet"><span class="by">cableshaft</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052498">parent</a><span>|</span><a href="#36052978">next</a><span>|</span><label class="collapse" for="c-36053402">[-]</label><label class="expand" for="c-36053402">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d much rather program with the help of ChatGPT 4, as it is right now, over programming with Excel (I&#x27;ve done both). And at least on a smaller scale, the code generated by ChatGPT hasn&#x27;t been a mess at all.<p>Sometimes it&#x27;s incorrect or insufficient and it can&#x27;t handle the more complex solution I&#x27;m asking of it, but the code isn&#x27;t messy and doesn&#x27;t require me to rewrite it from scratch, just fix what&#x27;s incorrect.</div><br/></div></div><div id="36052978" class="c"><input type="checkbox" id="c-36052978" checked=""/><div class="controls bullet"><span class="by">qumpis</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052498">parent</a><span>|</span><a href="#36053402">prev</a><span>|</span><a href="#36052182">next</a><span>|</span><label class="collapse" for="c-36052978">[-]</label><label class="expand" for="c-36052978">[2 more]</label></div><br/><div class="children"><div class="content">I think many people give up too quickly (as could perceived by those professionals who had to put sweat when learning how to put things back when they  break). But a capable language model might serve as a debugger: &quot;you&#x27;re stuck? About to call a professional? No worries, explain to me what you see and let me ask you questions in order to find a fix together&quot;</div><br/><div id="36053182" class="c"><input type="checkbox" id="c-36053182" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052978">parent</a><span>|</span><a href="#36052182">next</a><span>|</span><label class="collapse" for="c-36053182">[-]</label><label class="expand" for="c-36053182">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;ll evolve into the AI Assistant being an always-on&#x2F;always-available app&#x2F;service&#x2F;client (ala Siri&#x2F;Alexa)  coupled with a much more powerful online service. Advantage is that once the client is installed, it has access to practically everything the user is doing (which is what the tech companies dream of) and can actually ingest the inputs without the user having to summarize&#x2F;translate into a text box (problem with Excel? AI assistant can read the excel sheet that has the issue so you can just ask questions).<p>I also think that the main two reasons behind Alexa&#x2F;Siri not seeing very high adoption rates are misinterpretation of the voice commands + quality of results. With LLMs, at least the first issue should improve dramatically and if the popularity of ChatGPT is anything to go by, the second issue should also see improvements.</div><br/></div></div></div></div></div></div><div id="36052182" class="c"><input type="checkbox" id="c-36052182" checked=""/><div class="controls bullet"><span class="by">6gvONxR4sf7o</span><span>|</span><a href="#36052098">parent</a><span>|</span><a href="#36052498">prev</a><span>|</span><a href="#36052472">next</a><span>|</span><label class="collapse" for="c-36052182">[-]</label><label class="expand" for="c-36052182">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love if the ambiguities could be a dialogue of question&#x2F;answer, rather than being fully specified ahead of time like we generally have programming today. It seems much more efficient.</div><br/><div id="36052355" class="c"><input type="checkbox" id="c-36052355" checked=""/><div class="controls bullet"><span class="by">grt_thr</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052182">parent</a><span>|</span><a href="#36052202">next</a><span>|</span><label class="collapse" for="c-36052355">[-]</label><label class="expand" for="c-36052355">[9 more]</label></div><br/><div class="children"><div class="content">The ambiguity is exponential. I wish that the people hyping on llms read the older literature and sentence parsing.<p>The only reason why people are so impressed is that chatgpt sometimes gives better results than Google. Which just ought to tell you hiw bad google has gotten.</div><br/><div id="36052870" class="c"><input type="checkbox" id="c-36052870" checked=""/><div class="controls bullet"><span class="by">wolfgang42</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052355">parent</a><span>|</span><a href="#36053620">next</a><span>|</span><label class="collapse" for="c-36052870">[-]</label><label class="expand" for="c-36052870">[4 more]</label></div><br/><div class="children"><div class="content">Well, programmers provide a natural language interface and somehow we usually manage the ambiguity and complexity OK.<p>In my experience, a lot of support requests for bespoke&#x2F;in-house software go like this:<p>&gt; User: Why is my wibble being quarked? This shouldn’t be happening!<p>&gt; Dev: Wibble ID, please?<p>&gt; User: ID 234567. This is terrible!<p>&gt; Dev: <i>[rummages in git blame]</i> Well, this wibble is frobnicated, and three years ago <i>[links to Slack thread]</i> you said that all frobnicated wibbles should be automatically quarked.<p>&gt; User: Yes, but that was before we automated the Acme account. We <i>never</i> frobnicate <i>their</i> wibbles!<p>&gt; Dev: ...so, is there a way for me to tell if a client wants their wibbles unfrobnicated, or should I hard-code an exception for Acme?<p>(And then, six months later: “Why are none of Acme’s wibbles being frobnicated automatically?”)<p>If you could introduce an AI assistant that could answer these questions instantly (instead of starting with a support ticket), it’d cut the feedback loop from hours or days down to seconds, and the users (who are generally pretty smart in their field, even if my frustration is showing above) would have a much better resource for understanding the black box they’ve been given and why it works the way it does.</div><br/><div id="36054145" class="c"><input type="checkbox" id="c-36054145" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052870">parent</a><span>|</span><a href="#36054001">next</a><span>|</span><label class="collapse" for="c-36054145">[-]</label><label class="expand" for="c-36054145">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you could introduce an AI assistant that could answer these questions instantly<p>If you have some change documentation so good that you are able to answer that kind of question for things that a previous developer changed, you may have a chance of making the computer answer it.<p>Personally, I have never seen the first part done.</div><br/><div id="36054303" class="c"><input type="checkbox" id="c-36054303" checked=""/><div class="controls bullet"><span class="by">wolfgang42</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36054145">parent</a><span>|</span><a href="#36054001">next</a><span>|</span><label class="collapse" for="c-36054303">[-]</label><label class="expand" for="c-36054303">[1 more]</label></div><br/><div class="children"><div class="content">Yes, obviously the computer can’t find answers that have been lost to the mists of time; pointing to a specific discussion is a best-case scenario, and relies on a good commit history.<p>But even just providing a brief explanation of the current code would be a great help (even if it gets confused and gives bad answers occasionally; so do I sometimes!); and even when the history is vague you can usually pull useful information like “this was last changed eight years ago, here’s a ticket number” or “it’s worked like this since the feature was added, I have no idea what they were thinking at the time” or “the change that caused this to start happening claims to be a refactor, but seems to have accidentally inverted a condition in the process”.<p>And in a magical world where the AI is handling this entire conversation automatically, it would naturally write a good commit message for itself, quoting the discussion with the relevant user, so it has something to point to when the topic comes up again. (And it’d be in all the Slack channels, so when someone mentions in #sales-na-east that Acme has asked about quarking services, it can drop into the conversation and point out that the Wibble Manager might need changing <i>before</i> that turns into an urgent change request because we’ve accidentally sent them a batch of unquarked wibbles. Well, one can dream, anyway.)</div><br/></div></div></div></div><div id="36054001" class="c"><input type="checkbox" id="c-36054001" checked=""/><div class="controls bullet"><span class="by">wolfgang42</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052870">parent</a><span>|</span><a href="#36054145">prev</a><span>|</span><a href="#36053620">next</a><span>|</span><label class="collapse" for="c-36054001">[-]</label><label class="expand" for="c-36054001">[1 more]</label></div><br/><div class="children"><div class="content">Oops, only now do I realize that should have been “we never <i>quark</i> their wibbles” and “a client wants their wibbles unquarked.” (Hopefully doesn’t make a difference to comprehension since they’re nonsense words anyway, but there you go.)</div><br/></div></div></div></div><div id="36053620" class="c"><input type="checkbox" id="c-36053620" checked=""/><div class="controls bullet"><span class="by">6gvONxR4sf7o</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052355">parent</a><span>|</span><a href="#36052870">prev</a><span>|</span><a href="#36053022">next</a><span>|</span><label class="collapse" for="c-36053620">[-]</label><label class="expand" for="c-36053620">[1 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s exactly the point. The game of 20 questions is exponential as well. To uniquely identify a thing, the more specific you go, the level of precision needed to be unambiguous blows up. However, as a dialogue, you don&#x27;t have to fully spec out every branch of the tree ahead of time. They ask a yes or no question and the ambiguity <i>decreases</i> exponentially for every question asked.<p>By having a dialogue, you can resolve only the ambiguities pertinent to the specific question at hand.</div><br/></div></div><div id="36053022" class="c"><input type="checkbox" id="c-36053022" checked=""/><div class="controls bullet"><span class="by">qumpis</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052355">parent</a><span>|</span><a href="#36053620">prev</a><span>|</span><a href="#36053506">next</a><span>|</span><label class="collapse" for="c-36053022">[-]</label><label class="expand" for="c-36053022">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no need to detail how individual bricks of a house will be laid out when discussing the overall plan of it. Current LLMs, from my experience, don&#x27;t branch out too well when facing ambiguity, but rather pick the most likely answer consistent with the history.  But it&#x27;s imaginable that these concerns will be addressed once systems start maximizing the returns over whole conversations and not just individual interactions.</div><br/><div id="36053405" class="c"><input type="checkbox" id="c-36053405" checked=""/><div class="controls bullet"><span class="by">grt_thr</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36053022">parent</a><span>|</span><a href="#36053506">next</a><span>|</span><label class="collapse" for="c-36053405">[-]</label><label class="expand" for="c-36053405">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But it&#x27;s imaginable that these concerns<p>It&#x27;s also imaginable that we can build an engine that runs on entropy. Doesn&#x27;t mean it&#x27;s possible.</div><br/></div></div></div></div><div id="36053506" class="c"><input type="checkbox" id="c-36053506" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052355">parent</a><span>|</span><a href="#36053022">prev</a><span>|</span><a href="#36052202">next</a><span>|</span><label class="collapse" for="c-36053506">[-]</label><label class="expand" for="c-36053506">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.  I actually mis-parsed the headline myself, before noting the date.  I was thinking &quot;is going to work&quot; meant it would be happening in more and more workplaces.</div><br/></div></div></div></div><div id="36052202" class="c"><input type="checkbox" id="c-36052202" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052182">parent</a><span>|</span><a href="#36052355">prev</a><span>|</span><a href="#36052472">next</a><span>|</span><label class="collapse" for="c-36052202">[-]</label><label class="expand" for="c-36052202">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what programming with ChatGPT is like.</div><br/><div id="36052213" class="c"><input type="checkbox" id="c-36052213" checked=""/><div class="controls bullet"><span class="by">6gvONxR4sf7o</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052202">parent</a><span>|</span><a href="#36052314">next</a><span>|</span><label class="collapse" for="c-36052213">[-]</label><label class="expand" for="c-36052213">[1 more]</label></div><br/><div class="children"><div class="content">Yep! And I&#x27;d bet that&#x27;s a huge part of why it took off. An equally capable model with a &quot;write a better prompt and try again&quot; UX wouldn&#x27;t be nearly as useful.</div><br/></div></div><div id="36052314" class="c"><input type="checkbox" id="c-36052314" checked=""/><div class="controls bullet"><span class="by">anothernewdude</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052202">parent</a><span>|</span><a href="#36052213">prev</a><span>|</span><a href="#36052472">next</a><span>|</span><label class="collapse" for="c-36052314">[-]</label><label class="expand" for="c-36052314">[2 more]</label></div><br/><div class="children"><div class="content">A massive pain in the ass?</div><br/><div id="36053837" class="c"><input type="checkbox" id="c-36053837" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052314">parent</a><span>|</span><a href="#36052472">next</a><span>|</span><label class="collapse" for="c-36053837">[-]</label><label class="expand" for="c-36053837">[1 more]</label></div><br/><div class="children"><div class="content">Have you not spent much time working with ChatGPT? Or maybe you haven&#x27;t upgraded to plus so you get GPT4? It&#x27;s so fucking good. It&#x27;s a bit like pair programming. Even though it can&#x27;t always give you the result you want, it does so an appreciable percentage of the time and it&#x27;s a fabulous way to think through problems, especially as a complement to the &quot;google -&gt; stackoverflow -&gt; copy -&gt; paste&quot; style programming when you&#x27;re trying things out or unsure of how to do something.</div><br/></div></div></div></div></div></div></div></div><div id="36052472" class="c"><input type="checkbox" id="c-36052472" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#36052098">parent</a><span>|</span><a href="#36052182">prev</a><span>|</span><a href="#36052783">next</a><span>|</span><label class="collapse" for="c-36052472">[-]</label><label class="expand" for="c-36052472">[1 more]</label></div><br/><div class="children"><div class="content">I guess this will open up programming to anyone who can handle the math required to describe the behavior of a program. Unfortunately it is not even clear to me that this population is anywhere near as large as the existing population of programmers.</div><br/></div></div><div id="36052783" class="c"><input type="checkbox" id="c-36052783" checked=""/><div class="controls bullet"><span class="by">geysersam</span><span>|</span><a href="#36052098">parent</a><span>|</span><a href="#36052472">prev</a><span>|</span><a href="#36052200">next</a><span>|</span><label class="collapse" for="c-36052783">[-]</label><label class="expand" for="c-36052783">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why you need a language &quot;formalized to the point of math&quot; to instruct a computer to follow simple instructions (Write a crud API for this and this, it should have these endpoints etc.)<p>Of course there will be ambiguity, but you could say anything higher level than assembly is also ambiguous, but that&#x27;s not usually a problem.<p>I think it&#x27;s reasonable to expect that more people will be able to program if this becomes reality. Just as going from assembly to c allowed more people to program.</div><br/><div id="36053430" class="c"><input type="checkbox" id="c-36053430" checked=""/><div class="controls bullet"><span class="by">cableshaft</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052783">parent</a><span>|</span><a href="#36052200">next</a><span>|</span><label class="collapse" for="c-36053430">[-]</label><label class="expand" for="c-36053430">[1 more]</label></div><br/><div class="children"><div class="content">Eh, I was using it to help generate animated backgrounds with various custom geometry and animations tonight for a game of mine, and it performed admirably but it was struggling a bit.<p>I wouldn&#x27;t mind if it had a bit more formalization to the point of math to it for those bits. Was still good enough that I got some usable options from it, though.</div><br/></div></div></div></div><div id="36052200" class="c"><input type="checkbox" id="c-36052200" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#36052098">parent</a><span>|</span><a href="#36052783">prev</a><span>|</span><a href="#36054429">next</a><span>|</span><label class="collapse" for="c-36052200">[-]</label><label class="expand" for="c-36052200">[6 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t ChatGPT (or some now not that far fetched futuristic version that&#x27;s superior) a 5GL? You ask it for a program in English, and it codes it for you. You&#x27;ve just coded in natural language.</div><br/><div id="36052259" class="c"><input type="checkbox" id="c-36052259" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052200">parent</a><span>|</span><a href="#36052217">next</a><span>|</span><label class="collapse" for="c-36052259">[-]</label><label class="expand" for="c-36052259">[2 more]</label></div><br/><div class="children"><div class="content">You still have to make sure the code runs correctly and incorporate it into the rest of the code base. You also need to have some idea of what sort of code you&#x27;re asking for, particularly if it has to fit with existing code.</div><br/><div id="36052589" class="c"><input type="checkbox" id="c-36052589" checked=""/><div class="controls bullet"><span class="by">captnObvious</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052259">parent</a><span>|</span><a href="#36052217">next</a><span>|</span><label class="collapse" for="c-36052589">[-]</label><label class="expand" for="c-36052589">[1 more]</label></div><br/><div class="children"><div class="content">Check out chatgpt code interpreter. One step down…</div><br/></div></div></div></div><div id="36052217" class="c"><input type="checkbox" id="c-36052217" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052200">parent</a><span>|</span><a href="#36052259">prev</a><span>|</span><a href="#36054429">next</a><span>|</span><label class="collapse" for="c-36052217">[-]</label><label class="expand" for="c-36052217">[3 more]</label></div><br/><div class="children"><div class="content">I would love to see somebody writing a compiler that way.</div><br/><div id="36053224" class="c"><input type="checkbox" id="c-36053224" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052217">parent</a><span>|</span><a href="#36052241">next</a><span>|</span><label class="collapse" for="c-36053224">[-]</label><label class="expand" for="c-36053224">[1 more]</label></div><br/><div class="children"><div class="content">The original version of my site aidev.codes was a bit like that. The concept was to keep refining the spec and each time it would regenerate starting with whatever section had been modified. There was even a way to clone an &quot;app spec&quot; like with Codepens.<p>People generally didn&#x27;t seem very interested. Also the bigger problem was that the gpt-3.5 models really wouldn&#x27;t return the same thing consistently so a minor change could throw other things off.<p>Also a conversation feels like a much more intuitive way of doing it. So I switched to that.</div><br/></div></div><div id="36052241" class="c"><input type="checkbox" id="c-36052241" checked=""/><div class="controls bullet"><span class="by">n8cpdx</span><span>|</span><a href="#36052098">root</a><span>|</span><a href="#36052217">parent</a><span>|</span><a href="#36053224">prev</a><span>|</span><a href="#36054429">next</a><span>|</span><label class="collapse" for="c-36052241">[-]</label><label class="expand" for="c-36052241">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;medium.com&#x2F;@byanofsky&#x2F;chatgpt-helped-me-build-a-compiler-7aebcd2a2c20" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@byanofsky&#x2F;chatgpt-helped-me-build-a-comp...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>