<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704531656404" as="style"/><link rel="stylesheet" href="styles.css?v=1704531656404"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jvns.ca/blog/2024/01/05/do-we-think-of-git-commits-as-diffs--snapshots--or-histories/">Do we think of Git commits as diffs, snapshots, and/or histories?</a> <span class="domain">(<a href="https://jvns.ca">jvns.ca</a>)</span></div><div class="subtext"><span>soheilpro</span> | <span>91 comments</span></div><br/><div><div id="38888928" class="c"><input type="checkbox" id="c-38888928" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#38889100">next</a><span>|</span><label class="collapse" for="c-38888928">[-]</label><label class="expand" for="c-38888928">[19 more]</label></div><br/><div class="children"><div class="content">One issue with the &quot;diff&quot; model is that in GIT (and most all VCs these days) there is no &quot;one true answer&quot; to the question &quot;how did this old file change to become this new one&quot;.<p>Instead, what is stored is &quot;what is the smallest&#x2F;fastest&#x2F;simplest way to create new file from old file&quot;.<p>(depends on tradeoff)<p>Which is not the same as what you may have actually done to change old file into new one.<p>One result is that the textual representation you see in &quot;diff&quot; is just one interpretation of how the file changed - since it is reconstructing it from first principles.<p>I mention this because the author mention the  following positive of the diff mental model:
&quot;most of the time I’m concerned with the change I’m making – if I’m just changing 1 line of code, obviously I’m mostly thinking about just that 1 line of code and not the entire current state of the codebase<p>when you click on a Git commit on GitHub or use git show, you see the diff, so it’s just what I’m used to seeing&quot;<p>Of course, you see &quot;a diff&quot;, not &quot;the diff&quot;, because there is no &quot;the diff&quot;.  and when you change 1 line of code, the diff may or may not show it as having changed one line of code.<p>It is likely to in most cases because that usually meets the definition of longest common subsequence that common diff algorithms optimize for.
But not always.<p>Which leads to interest results when you were thinking about a change one way, but the diff doesn&#x27;t show what you actually did to the code in your editor :)</div><br/><div id="38888965" class="c"><input type="checkbox" id="c-38888965" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38888928">parent</a><span>|</span><a href="#38889270">next</a><span>|</span><label class="collapse" for="c-38888965">[-]</label><label class="expand" for="c-38888965">[4 more]</label></div><br/><div class="children"><div class="content">Git stores states of the repo across time. The diff is something created for the user. Internally, Git might or might store it in an optimized way, but not necessarily.</div><br/><div id="38889280" class="c"><input type="checkbox" id="c-38889280" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38888965">parent</a><span>|</span><a href="#38889270">next</a><span>|</span><label class="collapse" for="c-38889280">[-]</label><label class="expand" for="c-38889280">[3 more]</label></div><br/><div class="children"><div class="content">Ok so I think I at least understand now that “git diff” isn’t just showing me some stored information in the repo’s metadata.<p>But still, I can’t reason about how so many changes to a repo can be recorded in a way that’s so efficient that it’s almost imperceptible in time cost. And I’ve yet to see a satisfactory answer to this question. I need concrete examples.</div><br/><div id="38889482" class="c"><input type="checkbox" id="c-38889482" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889280">parent</a><span>|</span><a href="#38889405">next</a><span>|</span><label class="collapse" for="c-38889482">[-]</label><label class="expand" for="c-38889482">[1 more]</label></div><br/><div class="children"><div class="content">Git is basically an object storage. Most objects in Git are blobs identified by their hash code. For example, a commit points to a directory. A directory points to all files and directories it contains.<p>With this foundation, Git is already quite efficient in common scenarios since most commits create only a few new objects: the commit, the new versions of the files, and all directory nodes all the way to the top.<p>Git could store all of these in the filesystem. Often, they are stored in indexed and compressed pack files though. But the underlying principle remains the same.</div><br/></div></div><div id="38889405" class="c"><input type="checkbox" id="c-38889405" checked=""/><div class="controls bullet"><span class="by">federiconafria</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889280">parent</a><span>|</span><a href="#38889482">prev</a><span>|</span><a href="#38889270">next</a><span>|</span><label class="collapse" for="c-38889405">[-]</label><label class="expand" for="c-38889405">[1 more]</label></div><br/><div class="children"><div class="content">Git does not store changes it stores a tree with the whole state of the repo for every commit. This tree has references to the files, when a file is changed a new copy is always added and the new commit will reference the new tree with the reference to the new file.<p>When you ask git for a diff it compares the trees and when there is a difference it compares the files the trees reference and it shows you a diff.<p>Git does not store diffs, it stores file trees.</div><br/></div></div></div></div></div></div><div id="38889270" class="c"><input type="checkbox" id="c-38889270" checked=""/><div class="controls bullet"><span class="by">hunter2_</span><span>|</span><a href="#38888928">parent</a><span>|</span><a href="#38888965">prev</a><span>|</span><a href="#38888979">next</a><span>|</span><label class="collapse" for="c-38889270">[-]</label><label class="expand" for="c-38889270">[2 more]</label></div><br/><div class="children"><div class="content">&gt; when you change 1 line of code, the diff may or may not show it as having changed one line of code.<p>Can you offer an example where an editor is used to change one line of code, and a resulting diff leads the user to believe that the number of changed lines is not one?<p>I don&#x27;t think people interpret an adjacent opposing pair (one line removed, immediately followed by one line added) as <i>not show[ing] it as having changed one line of code.</i></div><br/><div id="38889763" class="c"><input type="checkbox" id="c-38889763" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889270">parent</a><span>|</span><a href="#38888979">next</a><span>|</span><label class="collapse" for="c-38889763">[-]</label><label class="expand" for="c-38889763">[1 more]</label></div><br/><div class="children"><div class="content">A diff like this is perfectly valid:<p><pre><code>  -foo
  -bar
  -baz
  +foo
  +bar
</code></pre>
Although I don&#x27;t know any tool which would actually <i>generate</i> such a diff.</div><br/></div></div></div></div><div id="38888979" class="c"><input type="checkbox" id="c-38888979" checked=""/><div class="controls bullet"><span class="by">gnulinux</span><span>|</span><a href="#38888928">parent</a><span>|</span><a href="#38889270">prev</a><span>|</span><a href="#38889022">next</a><span>|</span><label class="collapse" for="c-38888979">[-]</label><label class="expand" for="c-38888979">[4 more]</label></div><br/><div class="children"><div class="content">This is an excellent comment and one should also note that the claim is wrong. If one line is changed &quot;a diff&quot; will likely have two lines: one removed, one added. If you change a sentence &quot;I am studying tonight&quot; to &quot;I am not studying tonight&quot; git diff will show one line deleted when I actually didn&#x27;t delete anything, conceptually.</div><br/><div id="38889033" class="c"><input type="checkbox" id="c-38889033" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38888979">parent</a><span>|</span><a href="#38889026">next</a><span>|</span><label class="collapse" for="c-38889033">[-]</label><label class="expand" for="c-38889033">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is an excellent comment and one should also note that the claim is wrong.<p>I’ll pretend that this isn’t pedantry. I can understand why you’d say this, but I think you just haven’t explored the way that git diff works, including the configuration options it takes.<p><pre><code>  $ git diff &#x27;HEAD^&#x27;
  diff --git a&#x2F;file b&#x2F;file
  index efb8e76..ca03496 100644
  --- a&#x2F;file
  +++ b&#x2F;file
  @@ -1,3 +1,3 @@
   This is context.
  -I am studying tonight.
  +I am not studying tonight.
   This is also context.
</code></pre>
Try it with --word-diff…<p><pre><code>  $ git diff &#x27;HEAD^&#x27; --word-diff
  diff --git a&#x2F;file b&#x2F;file
  index efb8e76..ca03496 100644
  --- a&#x2F;file
  +++ b&#x2F;file
  @@ -1,3 +1,3 @@
  This is context.
  I am {+not+} studying tonight.
  This is also context.</code></pre></div><br/></div></div><div id="38889026" class="c"><input type="checkbox" id="c-38889026" checked=""/><div class="controls bullet"><span class="by">eadler</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38888979">parent</a><span>|</span><a href="#38889033">prev</a><span>|</span><a href="#38889022">next</a><span>|</span><label class="collapse" for="c-38889026">[-]</label><label class="expand" for="c-38889026">[2 more]</label></div><br/><div class="children"><div class="content">`git diff --word-diff` is wonderful for this<p><pre><code>  diff --git 1&#x2F;old 2&#x2F;new
  index 7164d6e..61a276c 100644
  --- 1&#x2F;old
  +++ 2&#x2F;new
  @@ -1 +1 @@
  I am {+not+} studying tonight</code></pre></div><br/><div id="38889197" class="c"><input type="checkbox" id="c-38889197" checked=""/><div class="controls bullet"><span class="by">yardstick</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889026">parent</a><span>|</span><a href="#38889022">next</a><span>|</span><label class="collapse" for="c-38889197">[-]</label><label class="expand" for="c-38889197">[1 more]</label></div><br/><div class="children"><div class="content">Wow, why isn’t this the default?!</div><br/></div></div></div></div></div></div><div id="38889695" class="c"><input type="checkbox" id="c-38889695" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#38888928">parent</a><span>|</span><a href="#38889022">prev</a><span>|</span><a href="#38889021">next</a><span>|</span><label class="collapse" for="c-38889695">[-]</label><label class="expand" for="c-38889695">[1 more]</label></div><br/><div class="children"><div class="content">&gt; GIT<p>Just out of curiosity: What do you think GIT stands for?</div><br/></div></div><div id="38889021" class="c"><input type="checkbox" id="c-38889021" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#38888928">parent</a><span>|</span><a href="#38889695">prev</a><span>|</span><a href="#38889100">next</a><span>|</span><label class="collapse" for="c-38889021">[-]</label><label class="expand" for="c-38889021">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Instead, what is stored is &quot;what is the smallest&#x2F;fastest&#x2F;simplest way to create new file from old file&quot;.<p>I think this may be misleading to people reading your comment. Git is a snapshot based version control system (Maybe you know this). Each commit contains a complete exact snapshot of the entire repository. On the other hand it does contain optimizations to reduce the size of these snapshots in the form of git packs, and in that sense your comment is technically true, but this is really just an implementation detail.</div><br/><div id="38889099" class="c"><input type="checkbox" id="c-38889099" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889021">parent</a><span>|</span><a href="#38889100">next</a><span>|</span><label class="collapse" for="c-38889099">[-]</label><label class="expand" for="c-38889099">[5 more]</label></div><br/><div class="children"><div class="content">Even the fact that it&#x27;s snapshots (but possibly compressed) is an implementation detail.  I actually really like the generalized &quot;smallest&#x2F;fastest&#x2F;simplest way to create new file from old file&quot; explanation.  &quot;Fastest&quot; was a primary goal of git.  Same with Mercurial.  Other distributed revision control tools that were designed around the same time (bzr, darcs) didn&#x27;t optimize for speed and you could tell.</div><br/><div id="38889338" class="c"><input type="checkbox" id="c-38889338" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889099">parent</a><span>|</span><a href="#38889137">next</a><span>|</span><label class="collapse" for="c-38889338">[-]</label><label class="expand" for="c-38889338">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I actually really like the generalized &quot;smallest&#x2F;fastest&#x2F;simplest way to create new file from old file&quot; explanation.<p>You might like that explanation because it fits a mental model you may have acquired previously, but at the user interface level, Git stores snapshots. It&#x27;s not an implementation detail, it&#x27;s what the entire command line is based on.</div><br/></div></div><div id="38889137" class="c"><input type="checkbox" id="c-38889137" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889099">parent</a><span>|</span><a href="#38889338">prev</a><span>|</span><a href="#38889610">next</a><span>|</span><label class="collapse" for="c-38889137">[-]</label><label class="expand" for="c-38889137">[2 more]</label></div><br/><div class="children"><div class="content">I disagree, snapshots is the fundamental model. Otherwise, shallow clones would not be possible.</div><br/><div id="38889675" class="c"><input type="checkbox" id="c-38889675" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889137">parent</a><span>|</span><a href="#38889610">next</a><span>|</span><label class="collapse" for="c-38889675">[-]</label><label class="expand" for="c-38889675">[1 more]</label></div><br/><div class="children"><div class="content">Of course they would be possible, just harder and less efficient to implement.<p>The snapshot representation can be transformed into a chain of diffs representation and the other way round without losing anything except performance.</div><br/></div></div></div></div><div id="38889610" class="c"><input type="checkbox" id="c-38889610" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38888928">root</a><span>|</span><a href="#38889099">parent</a><span>|</span><a href="#38889137">prev</a><span>|</span><a href="#38889100">next</a><span>|</span><label class="collapse" for="c-38889610">[-]</label><label class="expand" for="c-38889610">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s _a_ way that an algorithm found out of the infinitely many edit scripts representing the same change; the underlying nitpick in this thread is that an algorithm found it and maybe it&#x27;s not a great choice (we&#x27;ve likely all seen diff algorithms making some odd choices in the presence of closing braces, for example). But there&#x27;s not particularly any adjectives to be expected about it.</div><br/></div></div></div></div></div></div></div></div><div id="38889100" class="c"><input type="checkbox" id="c-38889100" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38888928">prev</a><span>|</span><a href="#38889628">next</a><span>|</span><label class="collapse" for="c-38889100">[-]</label><label class="expand" for="c-38889100">[5 more]</label></div><br/><div class="children"><div class="content">The exact way in which git handles commits is very muddied - it&#x27;s snapshots on the surface, a bit of diffs when packed and a lot of operations on commits are actually 3-way merges (including merges, rebases, cherrypicks and reverts). Keeping track of all these matter (esp the operations that use diffs), but it can also get overwhelming for a tool.<p>In my opinion, it&#x27;s probably good enough to understand the model git is trying to emulate. Commits are stored more or less like snapshot copies of the working tree directory with commit information attached. The fact that there is de-duplication and packing behind the scenes is more a matter of trying to increase storage efficiency than of any practical difference from the directory snapshot model. Meanwhile, the more complex git operations (merges, rebases, reverts, etc) use actual diff algorithms and 3-way merges (way more often than you&#x27;d imagine) to propagate changes between these snapshots. This is especially apparent in the case of rebases, where the snapshot model falls completely on its side (modifying a commit will cause the same change in all subsequent commits).<p>This actually makes sense if you consider the development workflow of linux kernel before git. Versions were directories or on CVS and a lot of development was based on quilt, diffutils and patchutils. Git covers all these use cases, though it may not be immediately apparent.<p>Added later: It&#x27;s also interesting to look at Mercurial&#x27;s model. Like Git, Mercurial uses both snapshot and diffs for storage. But unlike the Git way of layering these two, Mercurial interleaves them - as diffs with full snapshots occasionally. This is more like the video codec concept of keyframes (I think that&#x27;s what inspired it). This means that Mercurial, unlike Git, doesn&#x27;t need repacking. And while Git exposes its internal model in its full glory, Mercurial manages to more or less abstract it away.</div><br/><div id="38889216" class="c"><input type="checkbox" id="c-38889216" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38889100">parent</a><span>|</span><a href="#38889628">next</a><span>|</span><label class="collapse" for="c-38889216">[-]</label><label class="expand" for="c-38889216">[4 more]</label></div><br/><div class="children"><div class="content">Well-said, although I disagree that it&#x27;s &quot;muddled&quot;.<p>The data model is that commits are snapshots, and diffs between snapshots are computed as needed. The whole system is designed around this.<p>Packing is an implementation detail.<p>The fact that internally it can store snapshots as diffs is more or less unrelated to the user-facing diffs. IMO it&#x27;s confusing to even mention it in an educational context, except in response to the question of &quot;how does Git prevent repo size from exploding?&quot;.</div><br/><div id="38889569" class="c"><input type="checkbox" id="c-38889569" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#38889100">root</a><span>|</span><a href="#38889216">parent</a><span>|</span><a href="#38889334">next</a><span>|</span><label class="collapse" for="c-38889569">[-]</label><label class="expand" for="c-38889569">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Packing is an implementation detail.<p>It&#x27;s so much of an implementation detail that even if the pack has a diff&#x2F;delta between the two objects to diff, that WON&#x27;T be used to produce the output from git diff.</div><br/></div></div><div id="38889334" class="c"><input type="checkbox" id="c-38889334" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38889100">root</a><span>|</span><a href="#38889216">parent</a><span>|</span><a href="#38889569">prev</a><span>|</span><a href="#38889628">next</a><span>|</span><label class="collapse" for="c-38889334">[-]</label><label class="expand" for="c-38889334">[2 more]</label></div><br/><div class="children"><div class="content">&gt; although I disagree that it&#x27;s &quot;muddled&quot;<p>I understand. I meant muddied (not muddled) in the sense that it can be confusing for beginners. For some reason, many long-time git users also don&#x27;t seem to progress beyond the initial image they have. (That includes me too - I struggled with rebases for a long time). That description wasn&#x27;t a criticism of the git model. Git model is clear if you take some time to study it.<p>&gt; Packing is an implementation detail.<p>&gt; The fact that internally it can store snapshots as diffs is more or less unrelated to the user-facing diffs.<p>My point exactly! To summarize, a git user needs to remember only two things:<p>1. Git commits are modeled as snapshots of work tree.<p>2. Many operations are (user-facing) diff-based.<p>Every other detail is a finer implementation detail that&#x27;s good to know but not essential to get started.</div><br/><div id="38889365" class="c"><input type="checkbox" id="c-38889365" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38889100">root</a><span>|</span><a href="#38889334">parent</a><span>|</span><a href="#38889628">next</a><span>|</span><label class="collapse" for="c-38889365">[-]</label><label class="expand" for="c-38889365">[1 more]</label></div><br/><div class="children"><div class="content">The thing that&#x27;s muddied for beginners are bad YouTube tutorials (which the internet is full of), not Git or the actual documentation. People should really read the Git documentation, it&#x27;s very well-written and explains the correct mental model.<p>Also, people really shouldn&#x27;t teach implementation details to beginners. Or intermediates. Perhaps anyone who casually mentions that Git stores diffs to anyone not currently opening the source code for Git itself should be disqualified from ever giving explanations for technical stuff ever again.</div><br/></div></div></div></div></div></div></div></div><div id="38889628" class="c"><input type="checkbox" id="c-38889628" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#38889100">prev</a><span>|</span><a href="#38888847">next</a><span>|</span><label class="collapse" for="c-38889628">[-]</label><label class="expand" for="c-38889628">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the merged commit can actually be literally anything<p>That cannot be stressed enough. Years ago a searched for a weird bug and could not find it. Of course I did not look at merge conflicts because &quot;they don&#x27;t really introduce anything new&quot;. But it turned out that a merge commit had introduced an arbitrary line, not related to its parents.<p>Also the opposite is true: You can make a conflict free merge of two correct parents and the result is broken code. It does not seem to happen very often in real life, but it&#x27;s a risk one should be aware of.<p>I wonder how many merge commits there are in the Linux source tree that introduce something new by conflict resolution or break something existing without conflict resolution involved.<p>At work we are a small enough organization that we don&#x27;t really merge, all our merges are fast-forward. But that means you move the risks above to rebasing.</div><br/></div></div><div id="38888847" class="c"><input type="checkbox" id="c-38888847" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38889628">prev</a><span>|</span><a href="#38889777">next</a><span>|</span><label class="collapse" for="c-38888847">[-]</label><label class="expand" for="c-38888847">[25 more]</label></div><br/><div class="children"><div class="content">&gt; is “how Git implements it” really the right way to explain it?<p>Of course not, and nowhere outside of software engineering will you find such widespread confusion between concepts and their implementation.<p>Do we think of pressing the gas pedal in a car as &quot;accelerate&quot;, or as &quot;regulate the intake manifold&quot;?<p>Commits are one of the most high-level concepts in Git. If an explanation for them resorts to implementation details, it&#x27;s a bad explanation.</div><br/><div id="38889743" class="c"><input type="checkbox" id="c-38889743" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38888949">next</a><span>|</span><label class="collapse" for="c-38889743">[-]</label><label class="expand" for="c-38889743">[1 more]</label></div><br/><div class="children"><div class="content">&gt; is “how Git implements it” really the right way to explain it?<p>&gt;&gt; Of course not,<p>As long as the user is a software developer I would disagree. If the developer cannot understand the implementation concept style of explanation, I don&#x27;t want to use or review their code either. I am saying implementation concepts as object storage, branches being pointers to objects etc. Of course implementation details and optimizations like packfiles don&#x27;t matter.<p>Every user-friendly explanation will have its limits once we get merges, rebases etc. For software developers it is important that their mental models don&#x27;t hit such limits.<p>If the user is not a software developer you have a point.</div><br/></div></div><div id="38888949" class="c"><input type="checkbox" id="c-38888949" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38889743">prev</a><span>|</span><a href="#38889089">next</a><span>|</span><label class="collapse" for="c-38888949">[-]</label><label class="expand" for="c-38888949">[11 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny you mention that, because Design of Everyday Things has a whole part about how people abstracting away the implementation leads to people having extremely wrong ideas about how things work.<p>I think abstraction is good in theory, but at the end of the day the implementation is what is happening. The classic thing of people relying on undocumented behavior, etc etc.<p>What good is a conceptual representation that doesn&#x27;t actually align with what happens? It&#x27;s not like the gas pedal being pressed down is actually what makes a car accelerate, after all! Whenever you&#x27;re dealing with something _not_ working as expected, those who know the implementation are going to be in a much more comfortable position in general IMO.</div><br/><div id="38889700" class="c"><input type="checkbox" id="c-38889700" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888949">parent</a><span>|</span><a href="#38889476">next</a><span>|</span><label class="collapse" for="c-38889700">[-]</label><label class="expand" for="c-38889700">[1 more]</label></div><br/><div class="children"><div class="content">Is it actually a problem that people have the wrong ideas about how things work?<p>Sure, if they <i>need</i> to actually know how something works (because, say, they want to dig in and modify the system itself), then of course they need to understand what happens below the abstraction.<p>But if my goal is &quot;drive a car&quot;, then it may not be helpful to know anything about that pedal beyond &quot;car starts moving when I press the accelerator pedal&quot;.  Because the nice thing is that I don&#x27;t need to know about fuel injection or whatever happens when I press the accelerator on an ICE car.  And the <i>really</i> nice thing is that if I switch from an ICE car to an EV, the basic usage is the same, and it doesn&#x27;t matter that something completely, entirely different happens when I press that same pedal on those two different cars.<p>(Ok, well, now we have one-pedal mode on some EVs, but... otherwise...)</div><br/></div></div><div id="38889476" class="c"><input type="checkbox" id="c-38889476" checked=""/><div class="controls bullet"><span class="by">fauigerzigerk</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888949">parent</a><span>|</span><a href="#38889700">prev</a><span>|</span><a href="#38889102">next</a><span>|</span><label class="collapse" for="c-38889476">[-]</label><label class="expand" for="c-38889476">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt;I think abstraction is good in theory, but at the end of the day the implementation is what is happening.</i><p>Abstraction is absolutely necessary in practice. It&#x27;s the language we use to tell a system what we want it to achieve. It&#x27;s the only way for us to know what the system can do without starting a science project. It&#x27;s the only way for the implementer to know what to implement. And it&#x27;s the only way to check whether a system actually does what it&#x27;s supposed to do.<p>Of course, knowing how a system actually works is always better than not knowing it. Every abstraction is leaky as so many side-channel attacks clearly demonstrate. But that doesn&#x27;t mean the abstraction is some theoretical pie in the sky that we can live without.</div><br/></div></div><div id="38889102" class="c"><input type="checkbox" id="c-38889102" checked=""/><div class="controls bullet"><span class="by">Exoristos</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888949">parent</a><span>|</span><a href="#38889476">prev</a><span>|</span><a href="#38889030">next</a><span>|</span><label class="collapse" for="c-38889102">[-]</label><label class="expand" for="c-38889102">[1 more]</label></div><br/><div class="children"><div class="content">I have to say this is the first time I&#x27;ve heard accelerating by gas pedal described as undocumented behavior.<p>&gt; It&#x27;s not like the gas pedal being pressed down is actually what makes a car accelerate<p>In proximity to the driver it certainly is the cause.</div><br/></div></div><div id="38889030" class="c"><input type="checkbox" id="c-38889030" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888949">parent</a><span>|</span><a href="#38889102">prev</a><span>|</span><a href="#38889043">next</a><span>|</span><label class="collapse" for="c-38889030">[-]</label><label class="expand" for="c-38889030">[3 more]</label></div><br/><div class="children"><div class="content">Not understanding how things work can result in very suboptimal decisions, and throttle control is a good example.<p>Even in a good old ICE car the throttle is not as straightforward as “more ‘gas’ equals more acceleration” (depending on many factors, such as road surface conditions, it can also make you go slower or stop completely).<p>An airplane would take it to a whole new level. What throttle does is dependent on fuel mixture, air density at your altitude, the configuration of controls—in fact, it’s probably much easier to enumerate the limited scenarios in which throttle <i>actually</i> makes you go faster as opposed to straight up crash.<p>There can be made an argument that smart systems could&#x2F;should, with their layers of abstraction, maintain an illusion of ‘gas’ = acceleration, and that human should not have to know anything else; but would you trust your life to such an arrangement?<p>There can be an argument that stakes are high in case of air travel, and low in case of VCS; but that falls apart if you consider source code managed in a VCS can indeed power a life-critical system, and if not knowing well enough how the VCS works can lead to development overhead and eventually bugs in that system, then human cost is real.</div><br/><div id="38889071" class="c"><input type="checkbox" id="c-38889071" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889030">parent</a><span>|</span><a href="#38889043">next</a><span>|</span><label class="collapse" for="c-38889071">[-]</label><label class="expand" for="c-38889071">[2 more]</label></div><br/><div class="children"><div class="content"><i>The purpose of the VCS is to abstract away how its concepts are implemented.</i> It should be possible to replace the standard Git implementation with any other that provides the same external interface without the user being affected, or even noticing it.<p>If that isn&#x27;t possible, the problem lies with Git, not with users &quot;not understanding&quot; it.</div><br/><div id="38889114" class="c"><input type="checkbox" id="c-38889114" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889071">parent</a><span>|</span><a href="#38889043">next</a><span>|</span><label class="collapse" for="c-38889114">[-]</label><label class="expand" for="c-38889114">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s going a bit far.  Git is heavily optimized for speed.  If the implementation changed the UI could possibly stay the same but users would notice.<p>Now, aside from that I think I generally agree with what you are saying.  Git&#x27;s UI, especially the way things are named, does feel very much tied to the implementation in ways that are a problem.</div><br/></div></div></div></div></div></div><div id="38889043" class="c"><input type="checkbox" id="c-38889043" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888949">parent</a><span>|</span><a href="#38889030">prev</a><span>|</span><a href="#38889089">next</a><span>|</span><label class="collapse" for="c-38889043">[-]</label><label class="expand" for="c-38889043">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s funny you mention that, because Design of Everyday Things has a whole part about how people abstracting away the implementation leads to people having extremely wrong ideas about how things work.<p>Which, funnily enough, isn&#x27;t a problem at all, unless the abstraction is leaky, or the purpose of the thing itself is poorly explained.<p>The abstraction <i>is</i> &quot;the way things work&quot;. If not, something is fundamentally wrong with the design.</div><br/><div id="38889061" class="c"><input type="checkbox" id="c-38889061" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889043">parent</a><span>|</span><a href="#38889089">next</a><span>|</span><label class="collapse" for="c-38889061">[-]</label><label class="expand" for="c-38889061">[3 more]</label></div><br/><div class="children"><div class="content">Every abstraction is leaky.</div><br/><div id="38889723" class="c"><input type="checkbox" id="c-38889723" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889061">parent</a><span>|</span><a href="#38889086">next</a><span>|</span><label class="collapse" for="c-38889723">[-]</label><label class="expand" for="c-38889723">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but the amount of leakiness varies a lot.  And in practice, most of the time we just don&#x27;t need to care.<p>Of course the canonical, annoying examples of the leaky abstractions involve software stacks, where we end up writing a bunch of code, and find that things work great until weird edge cases happen, and then we get upset and have to dig through the abstractions to figure out what&#x27;s going on.<p>But the leaks in a lot of real-world abstractions just don&#x27;t matter.  Like the accelerator pedal in a car.  That one does leak a bit in some places: for example, pressing the pedal isn&#x27;t linear.  On a (usually ICE) car with a geared transmission, pressing the pedal hard when in gear one gives you different results than when you press it hard when in gear six.  But then you switch to an EV and the response is different.  Or even switch to a different ICE car with a different transmission, and the response is different.  But ultimately that doesn&#x27;t really matter; the person driving gets used to it in very short order.  The leaks in that abstraction just don&#x27;t matter all that much.</div><br/></div></div><div id="38889086" class="c"><input type="checkbox" id="c-38889086" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889061">parent</a><span>|</span><a href="#38889723">prev</a><span>|</span><a href="#38889089">next</a><span>|</span><label class="collapse" for="c-38889086">[-]</label><label class="expand" for="c-38889086">[1 more]</label></div><br/><div class="children"><div class="content">Not true in practice. Billions of websites work just fine when viewed on wildly different platform stacks, without developers or users ever having to care about differences in CPU architecture or kernel design.</div><br/></div></div></div></div></div></div></div></div><div id="38889089" class="c"><input type="checkbox" id="c-38889089" checked=""/><div class="controls bullet"><span class="by">kaelinl</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38888949">prev</a><span>|</span><a href="#38889398">next</a><span>|</span><label class="collapse" for="c-38889089">[-]</label><label class="expand" for="c-38889089">[1 more]</label></div><br/><div class="children"><div class="content">People who must diagnose, modify, optimize, or establish procedures for operating the car think of it in the context of the system. Meanwhile, people who strictly want to move forward think of it as the accelerator.<p>Likewise for engineering tools. If you&#x27;d like to use a simple abstraction as your mental model, you&#x27;ll be able to operate the tool in the basic sense without issue. But as engineers, when something goes wrong with our tools we often don&#x27;t immediately bring it into a mechanic. We need our tools to do very specific things, and we must understand what they did each time we perform an operation. We establish workflows that build on top of the tools and depend on the tool matching our precise expectations of its behavior. In essence, we are the mechanic for our own car.<p>And of course, our needs are much more diverse than &quot;make car go forward&quot;. So inevitably, we run into trouble more often. What user-facing function of a car is as precise, powerful or intricate as a textual merge or reconciling two diverged work histories? There are many ways those operations can be done, and questions the user must answer about their desired result.</div><br/></div></div><div id="38889398" class="c"><input type="checkbox" id="c-38889398" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38889089">prev</a><span>|</span><a href="#38889044">next</a><span>|</span><label class="collapse" for="c-38889398">[-]</label><label class="expand" for="c-38889398">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Do we think of pressing the gas pedal in a car as &quot;accelerate&quot;, or as &quot;regulate the intake manifold&quot;?<p>I&#x27;m just curious -- which of the two do you think is the correct mental model to safely drive a car? If you think its the former, my guess is you&#x27;ve never driven where there are mountains and&#x2F;or never driven manual.</div><br/><div id="38889744" class="c"><input type="checkbox" id="c-38889744" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889398">parent</a><span>|</span><a href="#38889742">next</a><span>|</span><label class="collapse" for="c-38889744">[-]</label><label class="expand" for="c-38889744">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve driven in mountains (I&#x27;m actually in the mountains, with snow on the ground, even, right now) and for 15 years drove manual (I sometimes miss it, but mostly do not, in the same way that I run Debian now and can&#x27;t be bothered to run a distro like Gentoo anymore), but I literally never thought of pressing the gas pedal as &quot;regulate the intake manifold&quot;.  I honestly don&#x27;t even know what an intake manifold is, though I&#x27;m sure if I cared enough, Wikipedia would tell me.<p>Certainly my understanding of it is a bit more nuanced than simply &quot;accelerate&quot;, but ultimately.... &quot;press pedal harder, car moves faster&quot; is... fine?  Sure, you have to consider road conditions and (if driving manual) your current gear, speed, RPMs, etc., but... I dunno, I still think &quot;press pedal harder, car moves faster&quot; is a useful mental model to have, to some non-zero level of approximation.<p>Put another way: if I were to think of all the details of what the accelerator of a car actually does under the hood every time I pressed it, and consider the implications of it and allow that to inform how I press the accelerator, I would have precious little time to actually drive the car... like, the things that actually matter, like steering and staying on the road and avoiding other cars and people and whatnot.  When I press the accelerator, I think about the effect it&#x27;s going to have on the car.  And I have a good idea of what effect it&#x27;s going to have based on my experience driving that car (or any car, really).  Not based on any knowledge -- knowledge that I lack! -- of what pressing the accelerator actually does.</div><br/></div></div><div id="38889742" class="c"><input type="checkbox" id="c-38889742" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889398">parent</a><span>|</span><a href="#38889744">prev</a><span>|</span><a href="#38889044">next</a><span>|</span><label class="collapse" for="c-38889742">[-]</label><label class="expand" for="c-38889742">[1 more]</label></div><br/><div class="children"><div class="content">The correct way to safely drive a car is intuition – not a &quot;mental model&quot; of anything.<p>That&#x27;s why experienced drivers drive so much more safely than novice ones. It&#x27;s certainly not because in the meantime, they somehow learned how the throttle works internally.<p>The same basic lesson applies to software. The best design is the one that lends itself most to human intuition. Because when saving a photo from an image editor, users sure as hell aren&#x27;t thinking &quot;now an inode is created with this and that metadata&quot;.</div><br/></div></div></div></div><div id="38889044" class="c"><input type="checkbox" id="c-38889044" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38889398">prev</a><span>|</span><a href="#38888925">next</a><span>|</span><label class="collapse" for="c-38889044">[-]</label><label class="expand" for="c-38889044">[3 more]</label></div><br/><div class="children"><div class="content">In German (and curiosly also in Chinese) &quot;adding&quot; or &quot;giving gas&quot; is the common idiom for accellerating. Also sometimes in general for putting in more effort.<p>Git actually presents a very simple view to the user: repository states across time. These states can be compared to each other.</div><br/><div id="38889238" class="c"><input type="checkbox" id="c-38889238" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889044">parent</a><span>|</span><a href="#38888925">next</a><span>|</span><label class="collapse" for="c-38889238">[-]</label><label class="expand" for="c-38889238">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Git actually presents a very simple view to the user: repository states across time.<p>That doesn&#x27;t explain commands like rebase or cherry-pick or even patch. The diff algorithm that generates diffs based on history is very much integral to git, even if it is configurable. There are plenty of git commands that assume you can meaningfully transform a commit into a diff from its parent(s). So commits are sometimes snapshots sometimes diffs, depending on the tool you&#x27;re using to interact with them.</div><br/><div id="38889401" class="c"><input type="checkbox" id="c-38889401" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889238">parent</a><span>|</span><a href="#38888925">next</a><span>|</span><label class="collapse" for="c-38889401">[-]</label><label class="expand" for="c-38889401">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true. However, that&#x27;s implicit in the way these commands are defined. It <i>has</i> to be that way to make working with Git efficient, which is optimized for common use cases. For example, to cherry-pick a single commit.</div><br/></div></div></div></div></div></div><div id="38888925" class="c"><input type="checkbox" id="c-38888925" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38889044">prev</a><span>|</span><a href="#38888905">next</a><span>|</span><label class="collapse" for="c-38888925">[-]</label><label class="expand" for="c-38888925">[2 more]</label></div><br/><div class="children"><div class="content">Or even worse -- regulating the manifold pressute. A resting gas pedal means the engine is suctioning a vacuum in the manifold, whereas a fully depressed pedal means the manifold is restored to atmospheric pressure!</div><br/><div id="38889010" class="c"><input type="checkbox" id="c-38889010" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888925">parent</a><span>|</span><a href="#38888905">next</a><span>|</span><label class="collapse" for="c-38889010">[-]</label><label class="expand" for="c-38889010">[1 more]</label></div><br/><div class="children"><div class="content">&gt; restored to atmospheric pressure!<p><i>Cries in sad turbo noises</i></div><br/></div></div></div></div><div id="38888905" class="c"><input type="checkbox" id="c-38888905" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38888847">parent</a><span>|</span><a href="#38888925">prev</a><span>|</span><a href="#38889777">next</a><span>|</span><label class="collapse" for="c-38888905">[-]</label><label class="expand" for="c-38888905">[3 more]</label></div><br/><div class="children"><div class="content">I think if it as &quot;regulate the intake manifold&quot; or revving the engine because I feel it makes more sense. I don&#x27;t really understand the relationship between how much you push the pedal and how much acceleration it produces. I&#x27;ve given up on trying to understand that, so I don&#x27;t think of it as acceleration.</div><br/><div id="38889205" class="c"><input type="checkbox" id="c-38889205" checked=""/><div class="controls bullet"><span class="by">ikari_pl</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38888905">parent</a><span>|</span><a href="#38889777">next</a><span>|</span><label class="collapse" for="c-38889205">[-]</label><label class="expand" for="c-38889205">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that you intuitively do. When driving, you know when to press it lightly, and when more, as well as what the expected result will be.<p>That would mean, I think, that the implementation details are irrelevant, because it&#x27;s abstracted well enough to serve its purpose - and it&#x27;s so easy that usually the FIRST driving lesson takes you into actual traffic (at least in Poland).</div><br/><div id="38889307" class="c"><input type="checkbox" id="c-38889307" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38888847">root</a><span>|</span><a href="#38889205">parent</a><span>|</span><a href="#38889777">next</a><span>|</span><label class="collapse" for="c-38889307">[-]</label><label class="expand" for="c-38889307">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. I see it as a control system. I have a target acceleration and I have to change the input to the system to hone in on my target acceleration. I don&#x27;t intuitively know how to accelerate at 10 mph &#x2F; s. But by watching a guage I could be the control system that tries to do so.</div><br/></div></div></div></div></div></div></div></div><div id="38889777" class="c"><input type="checkbox" id="c-38889777" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#38888847">prev</a><span>|</span><a href="#38888689">next</a><span>|</span><label class="collapse" for="c-38889777">[-]</label><label class="expand" for="c-38889777">[1 more]</label></div><br/><div class="children"><div class="content"><i>diff considered harmful</i><p>For me, the incongruity between the way git was supposed to work, based on the idea that it stored deltas, and actual observed behavior was maddening.<p>More than once I completely ripped out a git repo just so I could get around the stupid merge conflicts I would end up with on a single user project.<p>We should always teach that git stores snapshots, and shows diffs as a convenient fiction for the user.</div><br/></div></div><div id="38888689" class="c"><input type="checkbox" id="c-38888689" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#38889777">prev</a><span>|</span><a href="#38888843">next</a><span>|</span><label class="collapse" for="c-38888689">[-]</label><label class="expand" for="c-38888689">[4 more]</label></div><br/><div class="children"><div class="content">Yes.<p>It depends what you&#x27;re doing. Most of the basic commands, they&#x27;re snapshots. When you get into things like rebase especially, you have to think in terms of diffs.<p>I&#x27;m not sure what &quot;histories&quot; are, as a distinct thing from snapshots, kind of seems like the same thing.</div><br/><div id="38888706" class="c"><input type="checkbox" id="c-38888706" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#38888689">parent</a><span>|</span><a href="#38888724">next</a><span>|</span><label class="collapse" for="c-38888706">[-]</label><label class="expand" for="c-38888706">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you, just want to explain what a history is.<p>A &quot;history&quot; is what other version control systems call a &quot;branch.&quot; It&#x27;s the commit and all of its ancestors.<p>Some people think of things this way because the commit ID does depend on its ancestors by depending on its parent (which depends on its parent, which depends on its parent...).<p>This is why, if you rebase a commit, and the content ends up exactly the same (maybe someone already made the equivalent change in both branches), the commit ID still changes: the parent has changed, so the hash changes, so the ID changes.<p>I hope that makes sense.</div><br/></div></div><div id="38888724" class="c"><input type="checkbox" id="c-38888724" checked=""/><div class="controls bullet"><span class="by">Evidlo</span><span>|</span><a href="#38888689">parent</a><span>|</span><a href="#38888706">prev</a><span>|</span><a href="#38888843">next</a><span>|</span><label class="collapse" for="c-38888724">[-]</label><label class="expand" for="c-38888724">[2 more]</label></div><br/><div class="children"><div class="content">Snapshots and diffs aren&#x27;t enough.  They don&#x27;t describe the DAG structure.</div><br/><div id="38888773" class="c"><input type="checkbox" id="c-38888773" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#38888689">root</a><span>|</span><a href="#38888724">parent</a><span>|</span><a href="#38888843">next</a><span>|</span><label class="collapse" for="c-38888773">[-]</label><label class="expand" for="c-38888773">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not a lot more to Git&#x27;s DAG in a commit besides &quot;Snapshot&quot;, &quot;Comment&quot;, and &quot;Pointer to previous commits&quot;. Even signatures are just a bit of porcelain to the data structure.</div><br/></div></div></div></div></div></div><div id="38888843" class="c"><input type="checkbox" id="c-38888843" checked=""/><div class="controls bullet"><span class="by">nickm12</span><span>|</span><a href="#38888689">prev</a><span>|</span><a href="#38888831">next</a><span>|</span><label class="collapse" for="c-38888843">[-]</label><label class="expand" for="c-38888843">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the context, I definitely think of commits as all three of diff, snapshot, or history.<p>When I&#x27;m coding, I think of myself as &quot;authoring a change&quot; and the commit I post for code review, and later rebase, is the change I&#x27;m pushing. (but simultaneously the commit I&#x27;m developing against is a snapshot!).<p>Once code is pushed, I flip over to &quot;history&quot;. At that point, I&#x27;m using the commit as an identifier for a release, which generally contains multiple changes. The primary questions at that point are &quot;what&#x27;s in this release?&quot; and &quot;How does it differ from the previous release?&quot; and mentally I see that as a set of changes rather than a single diff, even though production doesn&#x27;t care how many commits are in the difference.<p>The unscientific poll excluded &quot;all three&quot;.  I guess I have to go with &quot;diff&quot; as &quot;most true&quot; but it simply makes no sense when using a commit id to identify what to check out or release.</div><br/></div></div><div id="38888831" class="c"><input type="checkbox" id="c-38888831" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38888843">prev</a><span>|</span><a href="#38889202">next</a><span>|</span><label class="collapse" for="c-38888831">[-]</label><label class="expand" for="c-38888831">[5 more]</label></div><br/><div class="children"><div class="content">&quot;history vs snapshot&quot; is a kind of weird distinction that could use some pulling apart.<p>A commit is a snapshot, but that snapshot includes a reference to prior history. It &quot;isn&#x27;t&quot; the history per se, but includes a way to get it. When we `git log` it&#x27;s clearly thinking in terms of a sequence of commits, not a single commit with multiple snapshots.<p>A commit is not a full history; a lot of stuff is only in the reflog, and the reflog isn&#x27;t permanent. Losing the branch name is a big deal but there are no good solutions and mercurial&#x27;s attempt is definitely worse (flashbacks of `svn rename`, which I&#x27;m not sure I ever used personally but heard enough horror stories about that I basically refused to actually use any VCS until git saved the world)<p>A commit (or more often, a series of commits) can be <i>used</i> as a diff by virtue of looking at the history pointer. But there are enough footguns that thinking in terms of diffs alone is clearly harmful.</div><br/><div id="38889697" class="c"><input type="checkbox" id="c-38889697" checked=""/><div class="controls bullet"><span class="by">ahepp</span><span>|</span><a href="#38888831">parent</a><span>|</span><a href="#38889023">next</a><span>|</span><label class="collapse" for="c-38889697">[-]</label><label class="expand" for="c-38889697">[1 more]</label></div><br/><div class="children"><div class="content">What are some of these footguns?</div><br/></div></div><div id="38889023" class="c"><input type="checkbox" id="c-38889023" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888831">parent</a><span>|</span><a href="#38889697">prev</a><span>|</span><a href="#38889202">next</a><span>|</span><label class="collapse" for="c-38889023">[-]</label><label class="expand" for="c-38889023">[3 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t like losing branch names then I&#x27;m genuinely curious what you think is wrong with Mercurial&#x27;s solution?</div><br/><div id="38889109" class="c"><input type="checkbox" id="c-38889109" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38888831">root</a><span>|</span><a href="#38889023">parent</a><span>|</span><a href="#38889202">next</a><span>|</span><label class="collapse" for="c-38889109">[-]</label><label class="expand" for="c-38889109">[2 more]</label></div><br/><div class="children"><div class="content">Mercurial branches get in the way. Branches should be <i>recorded</i> in commits, not <i>contain</i> or constrain commits.<p>`git` records one side&#x27;s branch name for merge commits, which is great ... except it doesn&#x27;t record the other, or record anything for fast-forward or rebase. And what it does record isn&#x27;t directly machine-readable.</div><br/><div id="38889143" class="c"><input type="checkbox" id="c-38889143" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888831">root</a><span>|</span><a href="#38889109">parent</a><span>|</span><a href="#38889202">next</a><span>|</span><label class="collapse" for="c-38889143">[-]</label><label class="expand" for="c-38889143">[1 more]</label></div><br/><div class="children"><div class="content">Hmm.  Are we both talking about Mercurial branches and not maybe bookmarks or something different?  It&#x27;s been a while since I&#x27;ve used mercurial but from what I remember the branch name is recorded as part of the commit?<p>I&#x27;m not sure I understand what you mean by containing or constraining or being in the way, either, sorry.<p>If you are rebasing you are modifying history generally to purposefully remove a branch in the DAG.  I&#x27;m not sure you&#x27;d want to keep a branch name in that case?</div><br/></div></div></div></div></div></div></div></div><div id="38889202" class="c"><input type="checkbox" id="c-38889202" checked=""/><div class="controls bullet"><span class="by">OscarCunningham</span><span>|</span><a href="#38888831">prev</a><span>|</span><a href="#38888784">next</a><span>|</span><label class="collapse" for="c-38889202">[-]</label><label class="expand" for="c-38889202">[5 more]</label></div><br/><div class="children"><div class="content">If we don&#x27;t care about implementation details then isn&#x27;t it mathematically equivalent to say that a commit is a diff or a snapshot?<p>Each commit knows its parent. So from the diff you can calculate the snapshot, and from the snapshot you can calculate the diff.</div><br/><div id="38889220" class="c"><input type="checkbox" id="c-38889220" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#38889202">parent</a><span>|</span><a href="#38889224">next</a><span>|</span><label class="collapse" for="c-38889220">[-]</label><label class="expand" for="c-38889220">[2 more]</label></div><br/><div class="children"><div class="content">As it turns out, we care about details like “does diffing two branches show output inside of a week”. Diff-based systems were very slow at constructing a diff between divergent branches.</div><br/><div id="38889737" class="c"><input type="checkbox" id="c-38889737" checked=""/><div class="controls bullet"><span class="by">OscarCunningham</span><span>|</span><a href="#38889202">root</a><span>|</span><a href="#38889220">parent</a><span>|</span><a href="#38889224">next</a><span>|</span><label class="collapse" for="c-38889737">[-]</label><label class="expand" for="c-38889737">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but in terms of understanding what to expect git to output, the two points of view should be equally valid.</div><br/></div></div></div></div><div id="38889224" class="c"><input type="checkbox" id="c-38889224" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38889202">parent</a><span>|</span><a href="#38889220">prev</a><span>|</span><a href="#38888784">next</a><span>|</span><label class="collapse" for="c-38889224">[-]</label><label class="expand" for="c-38889224">[2 more]</label></div><br/><div class="children"><div class="content">In a merge commit with 4 parents, what diff does the commit represent?</div><br/><div id="38889732" class="c"><input type="checkbox" id="c-38889732" checked=""/><div class="controls bullet"><span class="by">OscarCunningham</span><span>|</span><a href="#38889202">root</a><span>|</span><a href="#38889224">parent</a><span>|</span><a href="#38888784">next</a><span>|</span><label class="collapse" for="c-38889732">[-]</label><label class="expand" for="c-38889732">[1 more]</label></div><br/><div class="children"><div class="content">The diff from the first parent. This isn&#x27;t breaking any symmetry between the parents, since git already treats the first parent as special.</div><br/></div></div></div></div></div></div><div id="38888784" class="c"><input type="checkbox" id="c-38888784" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#38889202">prev</a><span>|</span><a href="#38888694">next</a><span>|</span><label class="collapse" for="c-38888784">[-]</label><label class="expand" for="c-38888784">[2 more]</label></div><br/><div class="children"><div class="content">Well, git makes a distinction between a delta and a diff, and it uses both.<p>A delta is a lot like a diff, and loosely speaking, you could say it&#x27;s one kind of diff. And deltas are used (in packfiles) for storing git objects, so in that sense, a commit <i>is</i> (sometimes) stored as a delta.<p>But each commit takes a snapshot of the entire tree, so in that sense it is a complete snapshot.<p>However, even without delta object storage, if a file does not change between one commit and another, then its blob object will be reused because its hash will match, so in that sense, a commit stores (loosely speaking, again) a kind of diff.<p>Also, a commit object refers to a tree object but also zero or more parent commit objects, and via these parent object(s), you can reach past commits, so a commit does also, in a sense, store (loosely speaking) a history of every past commit. (Well, not <i>every</i>, but every one reachable from this branch.)<p>So, none of the options is 100% wrong, depending on your interpretation and how you define terms.</div><br/><div id="38889264" class="c"><input type="checkbox" id="c-38889264" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#38888784">parent</a><span>|</span><a href="#38888694">next</a><span>|</span><label class="collapse" for="c-38889264">[-]</label><label class="expand" for="c-38889264">[1 more]</label></div><br/><div class="children"><div class="content">Commits are also used as diffs by several git commands - rebase, cherry-pick, patch, probably others. These commands take a commit and a target branch, but they use the commit as a diff from its parent, not as a snapshot. So it&#x27;s fair to say that git&#x27;s own API treats commits as diffs in some situations.</div><br/></div></div></div></div><div id="38888694" class="c"><input type="checkbox" id="c-38888694" checked=""/><div class="controls bullet"><span class="by">dado3212</span><span>|</span><a href="#38888784">prev</a><span>|</span><a href="#38889266">next</a><span>|</span><label class="collapse" for="c-38888694">[-]</label><label class="expand" for="c-38888694">[1 more]</label></div><br/><div class="children"><div class="content">That’s interesting! I think of them as diffs, though I know they’re snapshots. More familiar with Mercurial though, which may influence my thinking.</div><br/></div></div><div id="38889266" class="c"><input type="checkbox" id="c-38889266" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#38888694">prev</a><span>|</span><a href="#38888870">next</a><span>|</span><label class="collapse" for="c-38889266">[-]</label><label class="expand" for="c-38889266">[1 more]</label></div><br/><div class="children"><div class="content">This feels like a false dichotomy. Is a shadow the absence of light or is it a black blob? Well: both! In a purely physical sense it&#x27;s the absence of light but in your vision it&#x27;s a black blob, and these are both true and useful.<p>Given that she wrote a whole post about it the author obviously knows that both are useful, but I&#x27;d expect most people to use both frames of reference and switch as necessary rather than picking just one.</div><br/></div></div><div id="38888870" class="c"><input type="checkbox" id="c-38888870" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38889266">prev</a><span>|</span><a href="#38888909">next</a><span>|</span><label class="collapse" for="c-38888870">[-]</label><label class="expand" for="c-38888870">[2 more]</label></div><br/><div class="children"><div class="content">Wow, I just realized that I&#x27;ve been playing around with git and mercurial for nearly 17 years!  And people are still confused about git!  That&#x27;s amazing.  I still love that it&#x27;s distributed, fast, and it handles branches and merges better than anything before it.  I do wish the UI was better.</div><br/><div id="38889379" class="c"><input type="checkbox" id="c-38889379" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38888870">parent</a><span>|</span><a href="#38888909">next</a><span>|</span><label class="collapse" for="c-38889379">[-]</label><label class="expand" for="c-38889379">[1 more]</label></div><br/><div class="children"><div class="content">How often do you use Mercurial, compared to Git?<p>&gt; I do wish the UI was better.<p>The times I use Mercurial, it feels like it manages to abstract away the gory details while still achieving almost everything git does. Mercurial even has queues built-in, whereas Git needs something like stgit or topgit to achieve the same. Would you say that Mercurial meets your expectations?</div><br/></div></div></div></div><div id="38888909" class="c"><input type="checkbox" id="c-38888909" checked=""/><div class="controls bullet"><span class="by">devsda</span><span>|</span><a href="#38888870">prev</a><span>|</span><a href="#38888969">next</a><span>|</span><label class="collapse" for="c-38888909">[-]</label><label class="expand" for="c-38888909">[1 more]</label></div><br/><div class="children"><div class="content">Interesting but for me reading the article left more questions than it answered.<p>If you are curious about the internals, the referenced blogpost[1] has a detailed explanation of object file reperesentation(s) and I cannot recommend it enough.<p>[1] <a href="https:&#x2F;&#x2F;codewords.recurse.com&#x2F;issues&#x2F;three&#x2F;unpacking-git-packfiles" rel="nofollow">https:&#x2F;&#x2F;codewords.recurse.com&#x2F;issues&#x2F;three&#x2F;unpacking-git-pac...</a></div><br/></div></div><div id="38888969" class="c"><input type="checkbox" id="c-38888969" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38888909">prev</a><span>|</span><a href="#38888858">next</a><span>|</span><label class="collapse" for="c-38888969">[-]</label><label class="expand" for="c-38888969">[11 more]</label></div><br/><div class="children"><div class="content">Reading through this and then thinking about rebases in particular.... I think whoever comes up with a good mechanical explanation of rebasing deserves a prize. I just imagine it as &quot;it figures out diffs and then tries to apply them over at another place&quot; but this runs up against reality way too often.</div><br/><div id="38889042" class="c"><input type="checkbox" id="c-38889042" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888969">parent</a><span>|</span><a href="#38889171">next</a><span>|</span><label class="collapse" for="c-38889042">[-]</label><label class="expand" for="c-38889042">[2 more]</label></div><br/><div class="children"><div class="content">Does this explanation help?<p><a href="http:&#x2F;&#x2F;bryan-murdock.blogspot.com&#x2F;2022&#x2F;12&#x2F;git-rebase-explained.html" rel="nofollow">http:&#x2F;&#x2F;bryan-murdock.blogspot.com&#x2F;2022&#x2F;12&#x2F;git-rebase-explain...</a><p>Rebase is really a merge (actually one merge per commit you are rebasing).  At least it should be.  With mercurial it really seems to be.  With git I&#x27;m not so sure because it feels like it&#x27;s always worse at resolving conflicts than mercurial.  I haven&#x27;t tested it thoroughly or looked at the implementations</div><br/><div id="38889192" class="c"><input type="checkbox" id="c-38889192" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38888969">root</a><span>|</span><a href="#38889042">parent</a><span>|</span><a href="#38889171">next</a><span>|</span><label class="collapse" for="c-38889192">[-]</label><label class="expand" for="c-38889192">[1 more]</label></div><br/><div class="children"><div class="content">Interesting that this article omits any mention of &quot;cherry-pick&quot;.</div><br/></div></div></div></div><div id="38889171" class="c"><input type="checkbox" id="c-38889171" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38888969">parent</a><span>|</span><a href="#38889042">prev</a><span>|</span><a href="#38889184">next</a><span>|</span><label class="collapse" for="c-38889171">[-]</label><label class="expand" for="c-38889171">[1 more]</label></div><br/><div class="children"><div class="content">I recommend striving to understand what `git cherry-pick` does, since that&#x27;s equivalent to rebasing a single commit without doing anything else. That parts is where you get rebase conflicts from. Everything else `git rebase` does is a combination of `git amend` and `git squash`.</div><br/></div></div><div id="38889184" class="c"><input type="checkbox" id="c-38889184" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38888969">parent</a><span>|</span><a href="#38889171">prev</a><span>|</span><a href="#38888982">next</a><span>|</span><label class="collapse" for="c-38889184">[-]</label><label class="expand" for="c-38889184">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s some Python pseudocode of the mental model that works well enough most of the time?<p><pre><code>  def rebase(base, curr=HEAD):
      common_ancestor = git_merge_base(base, curr)
      git_checkout(common_ancestor)
      for commit in commit_range(common_ancestor, curr):
          git_cherry_pick(commit)
</code></pre>
Does that help?</div><br/></div></div><div id="38888982" class="c"><input type="checkbox" id="c-38888982" checked=""/><div class="controls bullet"><span class="by">mr_mitm</span><span>|</span><a href="#38888969">parent</a><span>|</span><a href="#38889184">prev</a><span>|</span><a href="#38889040">next</a><span>|</span><label class="collapse" for="c-38888982">[-]</label><label class="expand" for="c-38888982">[1 more]</label></div><br/><div class="children"><div class="content">I imagine it as separating a branch from the rest of the tree and attaching it to a new base commit (&quot;rebase&quot;). Naturally you need to apply all diffs (interpreting commits as diffs here) from the original branch to the new base commit. So you re-based it.</div><br/></div></div><div id="38889040" class="c"><input type="checkbox" id="c-38889040" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38888969">parent</a><span>|</span><a href="#38888982">prev</a><span>|</span><a href="#38888858">next</a><span>|</span><label class="collapse" for="c-38889040">[-]</label><label class="expand" for="c-38889040">[5 more]</label></div><br/><div class="children"><div class="content">How does this &quot;run up against reality&quot;, it is the reality, full stop, not even eliding tricky details. Whatever made you say that is the part of you that&#x27;s confused here.</div><br/><div id="38889064" class="c"><input type="checkbox" id="c-38889064" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888969">root</a><span>|</span><a href="#38889040">parent</a><span>|</span><a href="#38888858">next</a><span>|</span><label class="collapse" for="c-38889064">[-]</label><label class="expand" for="c-38889064">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the reality.  It is a 3-way merge of each commit you are rebasing, not just applying diffs.  Except sometimes when I&#x27;m resolving conflicts git mergetool doesn&#x27;t seem to supply 3 files to kdiff3 (just two) which really really bothers me.  Never saw that with Mercurial</div><br/><div id="38889128" class="c"><input type="checkbox" id="c-38889128" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38888969">root</a><span>|</span><a href="#38889064">parent</a><span>|</span><a href="#38888858">next</a><span>|</span><label class="collapse" for="c-38889128">[-]</label><label class="expand" for="c-38889128">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the reality, it&#x27;s just applying diffs. The OP&#x27;s blog actually has an earlier post about how applying diffs uses a 3-way merge; before ort and its more versatile API which can handle just applying diffs, rebase literally used apply machinery.</div><br/><div id="38889209" class="c"><input type="checkbox" id="c-38889209" checked=""/><div class="controls bullet"><span class="by">krupan</span><span>|</span><a href="#38888969">root</a><span>|</span><a href="#38889128">parent</a><span>|</span><a href="#38888858">next</a><span>|</span><label class="collapse" for="c-38889209">[-]</label><label class="expand" for="c-38889209">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, when I think of applying diffs I think of using the patch command that literally takes a set of files and a diff and applies the diff to the files.  patch doesn&#x27;t know any history and doesn&#x27;t do 3-way merges.  In my mind a 3-way merge is different than just &quot;applying diffs&quot;<p>I&#x27;ll look for her post about rebase, it sounds interesting, thanks!</div><br/><div id="38889656" class="c"><input type="checkbox" id="c-38889656" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38888969">root</a><span>|</span><a href="#38889209">parent</a><span>|</span><a href="#38888858">next</a><span>|</span><label class="collapse" for="c-38889656">[-]</label><label class="expand" for="c-38889656">[1 more]</label></div><br/><div class="children"><div class="content">diff(old, new) is sort of a degenerate case of diff3(left, base, right) where left = base; if your patch came _from_ git in some capacity it can identify base and doesn&#x27;t need to fall back</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38888858" class="c"><input type="checkbox" id="c-38888858" checked=""/><div class="controls bullet"><span class="by">nioj</span><span>|</span><a href="#38888969">prev</a><span>|</span><a href="#38889636">next</a><span>|</span><label class="collapse" for="c-38888858">[-]</label><label class="expand" for="c-38888858">[2 more]</label></div><br/><div class="children"><div class="content">Less commented ongoing discussion (currently 1 comment) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38884498">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38884498</a></div><br/><div id="38888889" class="c"><input type="checkbox" id="c-38888889" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#38888858">parent</a><span>|</span><a href="#38889636">next</a><span>|</span><label class="collapse" for="c-38888889">[-]</label><label class="expand" for="c-38888889">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why that didn&#x27;t get deduped</div><br/></div></div></div></div><div id="38889636" class="c"><input type="checkbox" id="c-38889636" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38888858">prev</a><span>|</span><a href="#38889088">next</a><span>|</span><label class="collapse" for="c-38889636">[-]</label><label class="expand" for="c-38889636">[1 more]</label></div><br/><div class="children"><div class="content">I honestly don&#x27;t see where the confusion is.<p>A git commit is a change from one state of the repository to another.  A change is a diff, because... that&#x27;s what a diff -- <i>difference</i> -- is, by definition.  So a commit is a diff.  (However, the reverse is not true: a diff is not a commit!  A diff <i>can</i> be a commit, but a diff can also be a representation of a series of commits, or something else entirely.)<p>A git tree is a snapshot.  A snapshot is, by definition, a view of the world at a point in time.  A commit doesn&#x27;t show you the world: it only shows you what&#x27;s changed between the previous world and the next world.  The state of the tree -- a checkout that comprises all the files in a project, at a particular time, is a snapshot.  I guess I can see how a commit might be confused for this: you can check out a tree at a particular commit, and that would be a snapshot.  But the commit is not the tree!  The commit is not the snapshot!  You could also look at it this way: you are not checking out a commit; you are checking out a tree that happens to be identified by the ref that points to a commit.  (Technically that&#x27;s not even the case, or rather it is, but only coincidentally: while we can check out trees by giving git a commit ref, in reality the tree itself has a different object name.)<p>To relate the two paragraphs above, a commit is the description of the change between two different trees (aka snapshots).<p>A commit also cannot be a history.  Again, by definition: a commit shows one single change, and one single change is not a history.  It is a <i>part</i> of the full history, to be sure: a history is a <i>series</i> of commits.  I guess a single commit is a history in a weird, limited, useless sense, in the sense that it is a &quot;history&quot; of a single change.  But I don&#x27;t really think of history as moment in time; history is a progression between times.  You could say something like &quot;the series of commits between these two tags shows the history of changes between release X and release Y&quot;.  You could also say that &quot;all of the commits on the main branch show the entire history of the project&quot;.<p>&gt; <i>is “how Git implements it” really the right way to explain it?</i><p>No, I don&#x27;t think so.  Implementation details (in the general sense, not specific to git) often don&#x27;t represent the mental model that&#x27;s most useful for understanding a system.  Git is a little interesting in that it actually is a lot easier to understand how to <i>use</i> git and be productive using git if you understand a bit about its implementation.  But that doesn&#x27;t mean your mental model of a version control system should depend on implementation details.</div><br/></div></div><div id="38889088" class="c"><input type="checkbox" id="c-38889088" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38889636">prev</a><span>|</span><a href="#38888772">next</a><span>|</span><label class="collapse" for="c-38889088">[-]</label><label class="expand" for="c-38889088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It gets a little weird with merge commits, but maybe you just say it’s stored as a diff from the first parent of the merge.<p>Depending on the specific operation it can act like a diff from any of the parents (though the first is special) or all of them; it&#x27;s (typically, and the way operations treat it) the result of a three-way merge using the parents and the most recent common ancestor found via graph walking, eliding some complexity.<p>To the author, refer back to your earlier post about three-way merging in this section, perhaps?</div><br/></div></div><div id="38888772" class="c"><input type="checkbox" id="c-38888772" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#38889088">prev</a><span>|</span><a href="#38888849">next</a><span>|</span><label class="collapse" for="c-38888772">[-]</label><label class="expand" for="c-38888772">[1 more]</label></div><br/><div class="children"><div class="content">commit == snapshot + reference to parent commit</div><br/></div></div><div id="38888849" class="c"><input type="checkbox" id="c-38888849" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#38888772">prev</a><span>|</span><label class="collapse" for="c-38888849">[-]</label><label class="expand" for="c-38888849">[1 more]</label></div><br/><div class="children"><div class="content">snapshots in time where all the bits should work... many small tested changes with people coordinating to keep out of each-others way.<p>Or... a dumpster fire as that one guy we all know breaks the build with a backlog of commits on a Friday... 1 hour before the end of the week.<p>We all meet &quot;that one guy&quot; eventually.  =)</div><br/></div></div></div></div></div></div></div></body></html>