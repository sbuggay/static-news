<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737622878780" as="style"/><link rel="stylesheet" href="styles.css?v=1737622878780"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.edgedb.com/blog/c-stdlib-isn-t-threadsafe-and-even-safe-rust-didn-t-save-us">C stdlib isn&#x27;t threadsafe and even safe Rust didn&#x27;t save us</a> <span class="domain">(<a href="https://www.edgedb.com">www.edgedb.com</a>)</span></div><div class="subtext"><span>msully4321</span> | <span>186 comments</span></div><br/><div><div id="42801932" class="c"><input type="checkbox" id="c-42801932" checked=""/><div class="controls bullet"><span class="by">vrtx0</span><span>|</span><a href="#42796925">next</a><span>|</span><label class="collapse" for="c-42801932">[-]</label><label class="expand" for="c-42801932">[2 more]</label></div><br/><div class="children"><div class="content">Let me try to help:<p>1. If a process crashes and dumps, be sure to look at the system log of the cause (e.g. SIGSEGV, OOM, invalid instruction, etc.)<p>2. Be certain you’re looking at the right core dumps — I believe UID 1000 just means posix UserID (which is unrelated to a PID), though I don’t use containers.<p>3. Stay focused on the right level of abstraction — memory model details are great to know, but irrelevant here.<p>4. Variables do not correlate 1:1 with registers, except in C calling conventions. The assumption about x20 and a local variable is incorrect, unfortunately.<p>5. getenv() and setenv() do not work as implied in the post. When a process starts via execve(), the OS&#x2F;libc constructs a new snapshot of the environment, and cannot be modified by an ancestral process. It’s a snapshot in time, unless updated by the process itself. When a process fork()s, the child gets a new <i>copy</i> of the parent’s environment — updates do not propagate.<p>getenv() is thread safe and reentrant. You don’t use an environment to pass shared data — setenv() is generally used when constructing the environment for a child process before a fork(). See man environment.<p>6. FWIW, ‘char** env’ is a null-terminated array of pointers, so dumping memory from *env (or env[0]) is only valid until you hit the first NULL. The size of the array is not stored in the array.<p>I hope this helps! And apologies if this is redundant — I read so many comments; mostly variations of “the problem with getenv is x”, but gave up before reading all of the (currently) 168 comments.</div><br/><div id="42802139" class="c"><input type="checkbox" id="c-42802139" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42801932">parent</a><span>|</span><a href="#42796925">next</a><span>|</span><label class="collapse" for="c-42802139">[-]</label><label class="expand" for="c-42802139">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m kind of confused by this response. It doesn&#x27;t seem to match the actual article? For example, they consulted the code to find what x20 had in it, rather than blindly guessing. Doing that is perfectly fine and even desirable when analyzing crashes. There is no forking mentioned. People call setenv all the time when trying to modify their own environment (hence the crashes!). Nobody said anything about the size of env.</div><br/></div></div></div></div><div id="42796925" class="c"><input type="checkbox" id="c-42796925" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42801932">prev</a><span>|</span><a href="#42796919">next</a><span>|</span><label class="collapse" for="c-42796925">[-]</label><label class="expand" for="c-42796925">[43 more]</label></div><br/><div class="children"><div class="content">The major takeaway from this is that Rust will be making environment setters unsafe in the next edition. With luck, this will filter down into crates that trigger these crashes (<a href="https:&#x2F;&#x2F;github.com&#x2F;alexcrichton&#x2F;openssl-probe&#x2F;issues&#x2F;30">https:&#x2F;&#x2F;github.com&#x2F;alexcrichton&#x2F;openssl-probe&#x2F;issues&#x2F;30</a> filed upstream in the meantime).</div><br/><div id="42797763" class="c"><input type="checkbox" id="c-42797763" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#42796925">parent</a><span>|</span><a href="#42797263">next</a><span>|</span><label class="collapse" for="c-42797763">[-]</label><label class="expand" for="c-42797763">[35 more]</label></div><br/><div class="children"><div class="content">But that won&#x27;t actually fix the underlying problem, namely that getenv and setenv (or unsetenv, probably) cannot safely be called from different threads.<p>It seems like the only reliable way to fix this is to change these functions so that they exclusively acquire a mutex.</div><br/><div id="42798014" class="c"><input type="checkbox" id="c-42798014" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797763">parent</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798014">[-]</label><label class="expand" for="c-42798014">[17 more]</label></div><br/><div class="children"><div class="content">I have a different perspective: the underlying problem is calling setenv().  As far as I&#x27;m concerned, the environment is a read-only input parameter set on process creation like argv.  It&#x27;s not a mechanism for exchanging information within a process, as used here with SSL_CERT_FILE.<p>And remember that the exec* family of calls has a version with an envp argument, which is what should be used if a child process is to be started with a different environment — build a completely new structure, don&#x27;t touch the existing one.  Same for posix_spawn.<p>And, lastly, compatibility with ancient systems strikes again:  the environment is also accessible through this:<p><pre><code>   extern char **environ;
</code></pre>
Which is, of course, best described as <i>bullshit</i>.</div><br/><div id="42798082" class="c"><input type="checkbox" id="c-42798082" checked=""/><div class="controls bullet"><span class="by">diroussel</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798014">parent</a><span>|</span><a href="#42800909">next</a><span>|</span><label class="collapse" for="c-42798082">[-]</label><label class="expand" for="c-42798082">[4 more]</label></div><br/><div class="children"><div class="content">Indeed, environment variables should be used to configure child processes, not to configure the current process, for non-shell programs, IMHO.<p>Note that Java, and the JVM, doesn&#x27;t allow changing environment variables.  It was the right choice, even if painful at times.</div><br/><div id="42798944" class="c"><input type="checkbox" id="c-42798944" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798082">parent</a><span>|</span><a href="#42798757">next</a><span>|</span><label class="collapse" for="c-42798944">[-]</label><label class="expand" for="c-42798944">[2 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a narrow window, at least in some programming languages, when environment variables can be set at the start of a process. But since it&#x27;s global shared state, it needs to be write (0,1) and read many. No libraries should set them. No frameworks should set them, only application authors and it should be dead obvious to the entire team what the last responsible moment is to write an environment variable.<p>I am fairly certain that somewhere inside the polyhedron that satisfies those constraints, is a large subset that could be statically analyzed and proven sound. But I&#x27;m less certain if Rust could express it cleanly.</div><br/><div id="42801212" class="c"><input type="checkbox" id="c-42801212" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798944">parent</a><span>|</span><a href="#42798757">next</a><span>|</span><label class="collapse" for="c-42801212">[-]</label><label class="expand" for="c-42801212">[1 more]</label></div><br/><div class="children"><div class="content">Which programming languages?<p>When using C++ I wanted programs to have a function that was called before main() and set up things that got sealed afterwards, like parsing command-line-arguments, the environment variables, loading runtime libraries, and maybe look at the local directory, but I&#x27;m not sure if it&#x27;ll be a useful and meaningful distinction unless you restructure way too many things.<p>I remember that on the Fuchsia kernel programs needed to drop capabilities at some point, but the shift needed might be a hard sell given things already &quot;work fine&quot;.</div><br/></div></div></div></div><div id="42798757" class="c"><input type="checkbox" id="c-42798757" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798082">parent</a><span>|</span><a href="#42798944">prev</a><span>|</span><a href="#42800909">next</a><span>|</span><label class="collapse" for="c-42798757">[-]</label><label class="expand" for="c-42798757">[1 more]</label></div><br/><div class="children"><div class="content">Sure is painful (mostly when writing tests where the environment variables aren&#x27;t abstracted in some way).<p>But I think it was actually possible to hack around up until Java 17.</div><br/></div></div></div></div><div id="42800909" class="c"><input type="checkbox" id="c-42800909" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798014">parent</a><span>|</span><a href="#42798082">prev</a><span>|</span><a href="#42799855">next</a><span>|</span><label class="collapse" for="c-42800909">[-]</label><label class="expand" for="c-42800909">[4 more]</label></div><br/><div class="children"><div class="content">&gt; As far as I&#x27;m concerned, the environment is a read-only input parameter set on process creation like argv.<p>This holds for a lot of programs, but what if you&#x27;re writing a shell?</div><br/><div id="42801078" class="c"><input type="checkbox" id="c-42801078" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42800909">parent</a><span>|</span><a href="#42801117">next</a><span>|</span><label class="collapse" for="c-42801078">[-]</label><label class="expand" for="c-42801078">[1 more]</label></div><br/><div class="children"><div class="content">Even then, you could maintain a separate copy of the environment that you control and freely mutate. Basically, during startup, you create a copy of the env you received. Any setenv primitive you expose to users will modify this copy (that you can sync properly yourself). When you want to launch a process, you explicitly provide the internal copy of the env to that process, you don&#x27;t rely on libc providing its own copy.<p>Of course, this means you won&#x27;t see any changes to env vars from libraries you may use that call setenv(), but you also shouldn&#x27;t need, or want, that in a shell.<p>I still think having a proper synchronous thread safe setenv()&#x2F;getenv() in libc is the better choice.</div><br/></div></div><div id="42801117" class="c"><input type="checkbox" id="c-42801117" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42800909">parent</a><span>|</span><a href="#42801078">prev</a><span>|</span><a href="#42801518">next</a><span>|</span><label class="collapse" for="c-42801117">[-]</label><label class="expand" for="c-42801117">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re writing a shell, you can spend the 15 minutes to write a custom mutable data structure for your envvars; no need to significantly worsen the entire ecosystem to reduce the size of shells by a couple dozen lines (or, rather, move those lines into libc..)</div><br/></div></div><div id="42801518" class="c"><input type="checkbox" id="c-42801518" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42800909">parent</a><span>|</span><a href="#42801117">prev</a><span>|</span><a href="#42799855">next</a><span>|</span><label class="collapse" for="c-42801518">[-]</label><label class="expand" for="c-42801518">[1 more]</label></div><br/><div class="children"><div class="content">I’ve written a lot of subprocess runners and environmental variables passed to a sub-process is just data at that point and you store it in your own variable like you would store someone’s name or someone’s age.</div><br/></div></div></div></div><div id="42799855" class="c"><input type="checkbox" id="c-42799855" checked=""/><div class="controls bullet"><span class="by">lamontcg</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798014">parent</a><span>|</span><a href="#42800909">prev</a><span>|</span><a href="#42798101">next</a><span>|</span><label class="collapse" for="c-42799855">[-]</label><label class="expand" for="c-42799855">[1 more]</label></div><br/><div class="children"><div class="content">Environment variables are a gigantic, decades-old hack that nobody should be using...  but instead everyone has rejected file-based configuration management and everyone is abusing environment variables to inject config into &quot;immutable&quot; docker containers...</div><br/></div></div><div id="42798101" class="c"><input type="checkbox" id="c-42798101" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798014">parent</a><span>|</span><a href="#42799855">prev</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798101">[-]</label><label class="expand" for="c-42798101">[7 more]</label></div><br/><div class="children"><div class="content">&gt; As far as I&#x27;m concerned, the environment is a read-only input parameter set on process creation like argv.<p>Mutating argv is actually quite popular, or at least it used to be.</div><br/><div id="42798933" class="c"><input type="checkbox" id="c-42798933" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798101">parent</a><span>|</span><a href="#42798179">next</a><span>|</span><label class="collapse" for="c-42798933">[-]</label><label class="expand" for="c-42798933">[1 more]</label></div><br/><div class="children"><div class="content">Mutating argv is fine for how it is usually done. That is, to permute the arguments in a getopt() call so that all nonoptions are at the end.<p>It is fine because it is usually done during the initialization phase, before starting any other thread. setenv() can be used here too, though I prefer to avoid doing that in any case. I also prefer not to touch argv, but since that&#x27;s how GNU getopt() works, I just go with it.<p>Once the program is running and has started its threads, I consider setenv() is a big no no. The Rust documentation agrees with me: &quot;In multi-threaded programs on other operating systems, the only safe option is to not use set_var or remove_var at all.&quot;. Note: here, &quot;other operating systems&quot; means &quot;not Windows&quot;.</div><br/></div></div><div id="42798179" class="c"><input type="checkbox" id="c-42798179" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798101">parent</a><span>|</span><a href="#42798933">prev</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798179">[-]</label><label class="expand" for="c-42798179">[5 more]</label></div><br/><div class="children"><div class="content">Yes, and if there were &quot;setargv()&quot; or &quot;getargv()&quot; functions, they&#x27;d have the same issues ;) … but argv is a function parameter to main()¹, and <i>only</i> that.<p>¹ or technically whatever your ELF entry point is, _start in crt0 or your poison of choice.</div><br/><div id="42798215" class="c"><input type="checkbox" id="c-42798215" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798179">parent</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798215">[-]</label><label class="expand" for="c-42798215">[4 more]</label></div><br/><div class="children"><div class="content">&gt; but argv is a function parameter to main()¹, and only that.<p>&gt; ¹ or technically whatever your ELF entry point is, _start in crt0 or your poison of choice.<p>Once you include the footnote, at least on linux&#x2F;macos (not sure about Windows), you could take the same perspective with regards to envp and the auxiliary array. It&#x27;s libc that decided to store a pointer to these before calling your `main`, not the abi. At the time of the ELF entry point these are all effectively stack local variables.</div><br/><div id="42798266" class="c"><input type="checkbox" id="c-42798266" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798215">parent</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798266">[-]</label><label class="expand" for="c-42798266">[3 more]</label></div><br/><div class="children"><div class="content">I mean, yes, we&#x27;re in &quot;violent agreement&quot; there.  It&#x27;s nice that libc squirrels away a copy and gives you a `getenv()` function with a string lookup, but… setenv… that was just a horrible idea.  It&#x27;s not really wrong to view it as a tool that allows you to muck around with main()&#x27;s local variables.  Which to me sounds like one should take a shower after using it ;D<p>(Ed.: the man page should say &quot;you are required to take a shower after writing code that uses setenv(), both to get off the dirt, but also to give you time to think about what you are doing&quot; :D)</div><br/><div id="42798386" class="c"><input type="checkbox" id="c-42798386" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798266">parent</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798386">[-]</label><label class="expand" for="c-42798386">[2 more]</label></div><br/><div class="children"><div class="content">Oops, didn&#x27;t mean to come across as disagreeing at all, more of a &quot;yes, and &lt;once you include the footnote&gt;&quot;.</div><br/><div id="42798487" class="c"><input type="checkbox" id="c-42798487" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798386">parent</a><span>|</span><a href="#42801724">next</a><span>|</span><label class="collapse" for="c-42798487">[-]</label><label class="expand" for="c-42798487">[1 more]</label></div><br/><div class="children"><div class="content">Ah, after rereading I think I accidentally read that in, sorry</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42801724" class="c"><input type="checkbox" id="c-42801724" checked=""/><div class="controls bullet"><span class="by">Ferret7446</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797763">parent</a><span>|</span><a href="#42798014">prev</a><span>|</span><a href="#42798463">next</a><span>|</span><label class="collapse" for="c-42801724">[-]</label><label class="expand" for="c-42801724">[1 more]</label></div><br/><div class="children"><div class="content">Is that a problem?  I feel like calling getenv and setenv from different threads is a design antipattern anyway.  Any environment setting and loading should happen in the one and only main thread right after process init.</div><br/></div></div><div id="42798463" class="c"><input type="checkbox" id="c-42798463" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797763">parent</a><span>|</span><a href="#42801724">prev</a><span>|</span><a href="#42801145">next</a><span>|</span><label class="collapse" for="c-42798463">[-]</label><label class="expand" for="c-42798463">[5 more]</label></div><br/><div class="children"><div class="content">No amount of locking can make the getenv API thread-safe, because it returns a pointer which gets invalidated by setenv, but lacks a way to release ownership over it and unblock setenv safely (or to free a returned copy).<p>So setenv&#x27;s existence makes getenv inherently unsafe unless you can ensure the <i>entire application</i> is at a safe point to use them.</div><br/><div id="42801032" class="c"><input type="checkbox" id="c-42801032" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798463">parent</a><span>|</span><a href="#42798706">next</a><span>|</span><label class="collapse" for="c-42801032">[-]</label><label class="expand" for="c-42801032">[3 more]</label></div><br/><div class="children"><div class="content">This is actually not that hard to fix.<p>Getenv() could keep several copies of the value around: one internal copy protected by a mutex, that it never returns, and one copy per thread that it stores in thread local storage. When you call getenv(), it locks the mutex, checks if the current thread&#x27;s value exists, populates it from the internal copy if not, and returns it. It will also install a new setenv-specific signal handler on this thread and store info about this thread having a copy.<p>Setenv() will then take the same mutex as getenv(), check if the internal copy is different from the new value; if it is, it will modify the internal copy, modify the local thread&#x27;s copy if that has one, and then signal each other thread in the process that has a copy in TLS. The setenv signal handler will modify the local copy that thread holds.<p>It&#x27;s gonna be slow for a large multi-threaded program, but since setenv() used to corrupt memory for such programs, they probably don&#x27;t care. And for single-threaded programs, or even for programs that don&#x27;t access getenv()&#x2F;setenv() on multiple threads, there should be no extra overhead other than the mutex and the bookkeeping.<p>The only issues that would remain are programs which send the pointer they get from getenv() to other threads without ensuring locking access, and programs which rely on modifying the pointer from getenv() directly as a way to set an env var, and expect this to be visible across threads. Those are just hopelessly broken and can&#x27;t use the same API - but aren&#x27;t more broken then they are today.<p>Of course, in addition to this complex work to make the old API (mostly) thread safe, it should also offer a new API that simply returns a copy every time, doesn&#x27;t promise to show modifications to your copy when setenv() gets called (you need to call getenv() again), and puts the onus on you to free that copy explicitly.</div><br/><div id="42801580" class="c"><input type="checkbox" id="c-42801580" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42801032">parent</a><span>|</span><a href="#42798706">next</a><span>|</span><label class="collapse" for="c-42801580">[-]</label><label class="expand" for="c-42801580">[2 more]</label></div><br/><div class="children"><div class="content">If you only consider `getenv`&#x2F;`setenv` there are indeed many solutions, but it&#x27;s not that simple. You also need to consider `putenv` (not <i>that</i> nasty, you just need to treat it like initial environment, which means you can&#x27;t use a single range check) and accessing the `environ` variable directly (nasty).<p>Your particular solution doesn&#x27;t work because people expect `getenv` to be async-signal-safe, which means you shouldn&#x27;t be allocating memory.<p>Hmm ... doing an incref-like operation during `getenv` for a previously `setenv`ed variable that hasn&#x27;t yet been accessed in this thread would be fine ... clear those refs during calls we know indicate knowledge refreshes ...</div><br/><div id="42801658" class="c"><input type="checkbox" id="c-42801658" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42801580">parent</a><span>|</span><a href="#42798706">next</a><span>|</span><label class="collapse" for="c-42801658">[-]</label><label class="expand" for="c-42801658">[1 more]</label></div><br/><div class="children"><div class="content">&gt;`putenv` (not <i>that</i> nasty,<p>It&#x27;s equally <i>nasty</i>. POSIX requires that the argument to `putenv()&#x27; not be copied, so it&#x27;s not very different from assigning to `environ&#x27; directly.</div><br/></div></div></div></div></div></div><div id="42798706" class="c"><input type="checkbox" id="c-42798706" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798463">parent</a><span>|</span><a href="#42801032">prev</a><span>|</span><a href="#42801145">next</a><span>|</span><label class="collapse" for="c-42798706">[-]</label><label class="expand" for="c-42798706">[1 more]</label></div><br/><div class="children"><div class="content">C could provide functions to lock&#x2F;unlock a mutex and require that any attempt to access the environment has to be done holding the mutex. This would still leave the correctness in the hands of the user, but at least it would provide a standard API to secure the environment in a multi threaded application that library and application developers could adopt.</div><br/></div></div></div></div><div id="42801145" class="c"><input type="checkbox" id="c-42801145" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797763">parent</a><span>|</span><a href="#42798463">prev</a><span>|</span><a href="#42798000">next</a><span>|</span><label class="collapse" for="c-42801145">[-]</label><label class="expand" for="c-42801145">[1 more]</label></div><br/><div class="children"><div class="content">But it would force Rust programs to add their own synchronization mechanism around them. As long as no two threads can call getenv&#x2F;setenv at the same time then it’s fine.</div><br/></div></div><div id="42798000" class="c"><input type="checkbox" id="c-42798000" checked=""/><div class="controls bullet"><span class="by">pshc</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797763">parent</a><span>|</span><a href="#42801145">prev</a><span>|</span><a href="#42798004">next</a><span>|</span><label class="collapse" for="c-42798000">[-]</label><label class="expand" for="c-42798000">[5 more]</label></div><br/><div class="children"><div class="content">The underlying problem is that setenv is mutable global state and should never have existed</div><br/><div id="42798079" class="c"><input type="checkbox" id="c-42798079" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798000">parent</a><span>|</span><a href="#42798393">next</a><span>|</span><label class="collapse" for="c-42798079">[-]</label><label class="expand" for="c-42798079">[3 more]</label></div><br/><div class="children"><div class="content">The process&#x27;s current directory is mutable global state as well, and yet chdir(2) is thread-safe.</div><br/><div id="42798641" class="c"><input type="checkbox" id="c-42798641" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798079">parent</a><span>|</span><a href="#42798393">next</a><span>|</span><label class="collapse" for="c-42798641">[-]</label><label class="expand" for="c-42798641">[2 more]</label></div><br/><div class="children"><div class="content">chdir is thread-safe, but interacting with the current directory in any context other than parsing command-line arguments is still nearly always a mistake. Everything past a program&#x27;s entry point should be working exclusively in absolute paths.</div><br/><div id="42799321" class="c"><input type="checkbox" id="c-42799321" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798641">parent</a><span>|</span><a href="#42798393">next</a><span>|</span><label class="collapse" for="c-42799321">[-]</label><label class="expand" for="c-42799321">[1 more]</label></div><br/><div class="children"><div class="content">Yeah if you chdir() in a multithreaded program, all cwd-relative file accesses in other threads are fucked.<p>As well as absolute paths, it’s ok to work with descriptor-relative paths using openat() and friends.</div><br/></div></div></div></div></div></div><div id="42798393" class="c"><input type="checkbox" id="c-42798393" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798000">parent</a><span>|</span><a href="#42798079">prev</a><span>|</span><a href="#42798004">next</a><span>|</span><label class="collapse" for="c-42798393">[-]</label><label class="expand" for="c-42798393">[1 more]</label></div><br/><div class="children"><div class="content">Welcome to the C standard library, the application of mutable global state to literally everything in it has to be the most consistent and predictable feature of the language standard.</div><br/></div></div></div></div><div id="42798004" class="c"><input type="checkbox" id="c-42798004" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797763">parent</a><span>|</span><a href="#42798000">prev</a><span>|</span><a href="#42797263">next</a><span>|</span><label class="collapse" for="c-42798004">[-]</label><label class="expand" for="c-42798004">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same problem with global vars, but at a machine scope. The real solution here would be for the OS to have a better interface to read and write env vars, more like a file where you have to get rw permission (whether that&#x27;s implemented as a mutex or what).</div><br/><div id="42798033" class="c"><input type="checkbox" id="c-42798033" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798004">parent</a><span>|</span><a href="#42797263">next</a><span>|</span><label class="collapse" for="c-42798033">[-]</label><label class="expand" for="c-42798033">[4 more]</label></div><br/><div class="children"><div class="content">This is neither an OS nor a machine scope problem.  The environment is provided by the OS <i>at startup</i>.  What the process does with it from there on is its own concern.</div><br/><div id="42798078" class="c"><input type="checkbox" id="c-42798078" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798033">parent</a><span>|</span><a href="#42797263">next</a><span>|</span><label class="collapse" for="c-42798078">[-]</label><label class="expand" for="c-42798078">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The environment is provided by the OS at startup.<p>That&#x27;s part of the design of the OS. How the OS implements this is primitive, and so it leaves it up to every language to handle. The blog mentions the issue is with getenv, setenv, and realloc, all system calls. To me, that sounds like bad OS design is causing issues downstream with languages, leaving it up to individual programmers to deal with the fallout.</div><br/><div id="42798153" class="c"><input type="checkbox" id="c-42798153" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798078">parent</a><span>|</span><a href="#42798134">next</a><span>|</span><label class="collapse" for="c-42798153">[-]</label><label class="expand" for="c-42798153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; getenv, setenv, and realloc, all system calls<p>None of these 3 functions is a system call.  open(), mmap(), sbrk(), poll(), etc. are system calls.  What you&#x27;re referring to is C library API, which as Go has shown (both to its benefit and its detriment) is optional on almost all operating systems (a major exception being OpenBSD.)<p>If you really want to lose some sanity I would recommend reading the man page for getauxval(), and then look up how that works on the machine level when the process is started.  Especially on some of the older architectures.  (No liability accepted for any grey hair induced by this.)<p>ed.: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;631631&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;631631&#x2F;</a></div><br/></div></div><div id="42798134" class="c"><input type="checkbox" id="c-42798134" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42798078">parent</a><span>|</span><a href="#42798153">prev</a><span>|</span><a href="#42797263">next</a><span>|</span><label class="collapse" for="c-42798134">[-]</label><label class="expand" for="c-42798134">[1 more]</label></div><br/><div class="children"><div class="content">Neither getenv, setenv nor realloc are system calls, they all are functions from C stdandard library, some parts of which for historical reasons are required to be almost impossible to use safely&#x2F;reliably.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42797263" class="c"><input type="checkbox" id="c-42797263" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42796925">parent</a><span>|</span><a href="#42797763">prev</a><span>|</span><a href="#42796919">next</a><span>|</span><label class="collapse" for="c-42797263">[-]</label><label class="expand" for="c-42797263">[7 more]</label></div><br/><div class="children"><div class="content">People get trained to ignore the ____UNSAFE_payattention__nevermindthatthisappears50timesinthisfile___ blocks and prefixes<p>This also shows up in web frameworks where Vue has the v-html directive and react has dangerouslySetInnerHTML. Vue definitely has it better.</div><br/><div id="42797411" class="c"><input type="checkbox" id="c-42797411" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797263">parent</a><span>|</span><a href="#42796919">next</a><span>|</span><label class="collapse" for="c-42797411">[-]</label><label class="expand" for="c-42797411">[6 more]</label></div><br/><div class="children"><div class="content">In the React world, the only times I&#x27;ve seen dangerouslySetInnerHTML consistently used is for outputting string literal CSS content (and this one is increasingly rare as build tools need less handholding), string literal JSON content (for JSON+LD), and string literal premade scripts (i.e. pixel tags from the marketing content). That&#x27;s not to say there&#x27;s no danger surface there, but it&#x27;s not broadly used as a tool outside of code that&#x27;s either really bad or really exhaustively hand-tuned.</div><br/><div id="42798231" class="c"><input type="checkbox" id="c-42798231" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797411">parent</a><span>|</span><a href="#42797626">next</a><span>|</span><label class="collapse" for="c-42798231">[-]</label><label class="expand" for="c-42798231">[1 more]</label></div><br/><div class="children"><div class="content">Code syntax highlighting libraries for react use dangerouslySetInnerHTML.</div><br/></div></div><div id="42797626" class="c"><input type="checkbox" id="c-42797626" checked=""/><div class="controls bullet"><span class="by">javier2</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797411">parent</a><span>|</span><a href="#42798231">prev</a><span>|</span><a href="#42797492">next</a><span>|</span><label class="collapse" for="c-42797626">[-]</label><label class="expand" for="c-42797626">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only really seen dangerouslySetInnerHTML used while transitioning from certain kinds of server side rendering to React. There is still lots of really old internal tools in ancient html out there.</div><br/></div></div><div id="42797492" class="c"><input type="checkbox" id="c-42797492" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797411">parent</a><span>|</span><a href="#42797626">prev</a><span>|</span><a href="#42796919">next</a><span>|</span><label class="collapse" for="c-42797492">[-]</label><label class="expand" for="c-42797492">[3 more]</label></div><br/><div class="children"><div class="content">React doesn&#x27;t have a tag and attribute sanitizer built in, so having non-js-programmers edit JSX isn&#x27;t especially safe anyways, as an <i>img</i> or <i>a href</i> could exfiltrate data. If it were they could just block out an innerHTML attribute. A js programmer can get around it by setting up a ref and then using the reference to set innerHTML without the word <i>dangerously</i> appearing.</div><br/><div id="42797621" class="c"><input type="checkbox" id="c-42797621" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797492">parent</a><span>|</span><a href="#42796919">next</a><span>|</span><label class="collapse" for="c-42797621">[-]</label><label class="expand" for="c-42797621">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A js programmer can get around it by setting up a ref and then using the reference to set innerHTML without the word dangerously appearing.<p>If DOM nodes during the next render differ from what react-dom expects (i.e. the DOM nodes from the previous render), then react-dom may throw a DOMException. Mutating innerHTML via a ref may violate React&#x27;s invariants, and the library correctly throws an error when programmers, browser extensions, etc. mutate the DOM such that a node&#x27;s parent unexpectedly changes.<p>There are workarounds[1] to mutate DOM nodes managed by React and avoid DOMExceptions, but I haven&#x27;t worked on a codebase where anything like this was necessary.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;issues&#x2F;11538#issuecomment-390386520">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;issues&#x2F;11538#issuecomment-...</a></div><br/><div id="42797750" class="c"><input type="checkbox" id="c-42797750" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42796925">root</a><span>|</span><a href="#42797621">parent</a><span>|</span><a href="#42796919">next</a><span>|</span><label class="collapse" for="c-42797750">[-]</label><label class="expand" for="c-42797750">[1 more]</label></div><br/><div class="children"><div class="content">The reference is used to operate on the subtree when wrapping libraries like CodeMirror <a href="https:&#x2F;&#x2F;github.com&#x2F;uiwjs&#x2F;react-codemirror&#x2F;blob&#x2F;master&#x2F;core&#x2F;src&#x2F;index.tsx#L146">https:&#x2F;&#x2F;github.com&#x2F;uiwjs&#x2F;react-codemirror&#x2F;blob&#x2F;master&#x2F;core&#x2F;s...</a> React leaves it alone if the children doesn&#x27;t change.<p>innerHTML is useful when there is a trusted HTML source, which is becoming more popular with stuff like HTMX and FastHTML.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42796919" class="c"><input type="checkbox" id="c-42796919" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#42796925">prev</a><span>|</span><a href="#42797132">next</a><span>|</span><label class="collapse" for="c-42796919">[-]</label><label class="expand" for="c-42796919">[18 more]</label></div><br/><div class="children"><div class="content">In the Rust std, `set_var` and `remove_var` will correctly require using an `unsafe {}` block in the next edition (2024). The documentation does now mention the safety issue but obviously it was a mistake to make these functions safe originally (albeit a mistake even higher level languages have made).<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;env&#x2F;fn.set_var.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;env&#x2F;fn.set_var.html</a><p>There is a patch for glibc which makes `getenv` safe in more cases where the environment is modified but C still allows direct access to the environ so it can&#x27;t be completely safe in the face of modification <a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;commit&#x2F;7a61e7f557a97ab597d6fca5e2d1f13f65685c61">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;commit&#x2F;7a61e7f557a97ab597d6f...</a></div><br/><div id="42796982" class="c"><input type="checkbox" id="c-42796982" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42796919">parent</a><span>|</span><a href="#42797132">next</a><span>|</span><label class="collapse" for="c-42796982">[-]</label><label class="expand" for="c-42796982">[17 more]</label></div><br/><div class="children"><div class="content">Why requiring unsafe when the std implementation could take care of the synchronisation?</div><br/><div id="42797050" class="c"><input type="checkbox" id="c-42797050" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42796982">parent</a><span>|</span><a href="#42797032">next</a><span>|</span><label class="collapse" for="c-42797050">[-]</label><label class="expand" for="c-42797050">[7 more]</label></div><br/><div class="children"><div class="content">Because the std implementation can not force synchronisation on the libc, so any call into a C library which uses getenv will break... which is exactly what happened in TFA: `openssl-probe` called env::set_var on the Rust side, and the Python interpreter called getenv(3) directly.</div><br/><div id="42798265" class="c"><input type="checkbox" id="c-42798265" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797050">parent</a><span>|</span><a href="#42797895">next</a><span>|</span><label class="collapse" for="c-42798265">[-]</label><label class="expand" for="c-42798265">[2 more]</label></div><br/><div class="children"><div class="content">But the standard implementation could copy the environment at startup, and only uses its copy.<p>And the library&#x27;s use of setenv is clearly a bug as setenv is documented to be not threadsafe in the C standard library. So that would take care of that problem.</div><br/><div id="42799039" class="c"><input type="checkbox" id="c-42799039" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42798265">parent</a><span>|</span><a href="#42797895">next</a><span>|</span><label class="collapse" for="c-42799039">[-]</label><label class="expand" for="c-42799039">[1 more]</label></div><br/><div class="children"><div class="content">If you clone the environment at startup, then you get a situation where code in the same binary can see different values depending if it uses libc or Rust&#x27;s std. It&#x27;s also no longer the same environment as in the process metadata.<p>Using a copy by default may have worked if it was designed as such before Rust 1.0, but Rust took the decision to expose the real environment and changing this now would be more disruptive than marking mutations as unsafe.</div><br/></div></div></div></div><div id="42797895" class="c"><input type="checkbox" id="c-42797895" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797050">parent</a><span>|</span><a href="#42798265">prev</a><span>|</span><a href="#42797032">next</a><span>|</span><label class="collapse" for="c-42797895">[-]</label><label class="expand" for="c-42797895">[4 more]</label></div><br/><div class="children"><div class="content">Is it possible to skip libc completely or would this introduce too many portability concerns?</div><br/><div id="42798092" class="c"><input type="checkbox" id="c-42798092" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797895">parent</a><span>|</span><a href="#42798012">next</a><span>|</span><label class="collapse" for="c-42798092">[-]</label><label class="expand" for="c-42798092">[1 more]</label></div><br/><div class="children"><div class="content">In general, no, because of FFI. In special circumstances, yes, but this isn&#x27;t really important because the libc implementation is trivial (on all platforms that matter, envp is a char** to strings formatted as KEY=VALUE, set_env(key, value) is equivalent to allocating a new KEY=VALUE string and finding the index of a key if it exists or appending to the array).<p>Under the hood the pointer is initialized by the loader, in a special place in executable memory. Most of the time, the loader gets the initial environment variable list by looking at argv* (try reading past the end of the null separator, you&#x27;ll find the initial environment variables).<p>It would be possible for a language to hack it such that on load they initialize their own env var set without using libc and be able to safely set&#x2F;get those env vars without going through libc, and to inherit them when spawning child processes by reading the special location instead of the standard location initialized by your platforms&#x27; loader&#x2F;updated by libc. But how useful is a language with FFI that&#x27;s fundamentally broken since callees can&#x27;t set environment variables? (probably very useful, since software that relies on this is questionably designed in the first place)<p>If you wanted to make a bullet proof solution, you would specify the location of an envp mutex in the loaders&#x27; format and make it libc&#x27;s (or any language runtime) problem to acquire that mutex.<p>* there are platforms where this isn&#x27;t true</div><br/></div></div><div id="42798012" class="c"><input type="checkbox" id="c-42798012" checked=""/><div class="controls bullet"><span class="by">jcotton42</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797895">parent</a><span>|</span><a href="#42798092">prev</a><span>|</span><a href="#42797032">next</a><span>|</span><label class="collapse" for="c-42798012">[-]</label><label class="expand" for="c-42798012">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just libc, it&#x27;s any C or C++ library that calls getenv or setenv.</div><br/><div id="42798275" class="c"><input type="checkbox" id="c-42798275" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42798012">parent</a><span>|</span><a href="#42797032">next</a><span>|</span><label class="collapse" for="c-42798275">[-]</label><label class="expand" for="c-42798275">[1 more]</label></div><br/><div class="children"><div class="content">Specifically, any C or C++ library that calls setenv (despite documentation that says that setenv is not threadsafe).</div><br/></div></div></div></div></div></div></div></div><div id="42797032" class="c"><input type="checkbox" id="c-42797032" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42796982">parent</a><span>|</span><a href="#42797050">prev</a><span>|</span><a href="#42797025">next</a><span>|</span><label class="collapse" for="c-42797032">[-]</label><label class="expand" for="c-42797032">[4 more]</label></div><br/><div class="children"><div class="content">It can only synchronize if everything using is Rust&#x27;s functions. But that&#x27;s not a given. People can use C libraries (especially libc) which won&#x27;t be aware of Rust&#x27;s locks. Or they could even use a high level runtime with its own locking but then they&#x27;ll be distinct from Rust&#x27;s locks.<p>The only way to coordinate locking would be to do so in libc itself.</div><br/><div id="42797344" class="c"><input type="checkbox" id="c-42797344" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797032">parent</a><span>|</span><a href="#42797025">next</a><span>|</span><label class="collapse" for="c-42797344">[-]</label><label class="expand" for="c-42797344">[3 more]</label></div><br/><div class="children"><div class="content">libc does do locking, but it&#x27;s insufficient. The semantics of getenv&#x2F;setenv&#x2F;putenv just aren&#x27;t safe for multi-threaded mutation, period, because the addresses are exposed. It&#x27;s not really even a C language issue; were you to design a thread-safe env API, for C or Rust, it would look much different, likely relying on string copying even on reads rather than passing strings by reference (reference counted immutable strings would work, too, but is probably too heavy handed), and definitely not exposing the environ array.<p>The closest libc can get to MT safety is to <i>never</i> deallocate an environment string or an environ array. Solaris does this--if you continually add new variables with setenv it just leaks environ array memory, or if you continually overwrite a key it just leaks the old value. (IIRC, glibc is halfway there.) But even then it still requires the application to abstain from doing crazy stuff, like modifying the strings you get back from getenv. NetBSD tried adding safer interfaces, like getenv_r, but it&#x27;s ultimately insufficient to meaningfully address the problem.<p>The right answer for safe, portable programs is to not mutate the environment once you go multi-threaded, or even better just treat process environment as immutable once you enter your main loop or otherwise finish with initial process setup. glibc could (and maybe should) fully adopt the Solaris solution (currently, IIRC, glibc leaks env strings but not environ arrays), but if applications are using the environment variable table as a global, shared, <i>mutable</i> key-value store, then leaking memory probably isn&#x27;t what they want, either. Either way, the best solution is to stop treating it as mutable.</div><br/><div id="42797410" class="c"><input type="checkbox" id="c-42797410" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797344">parent</a><span>|</span><a href="#42797025">next</a><span>|</span><label class="collapse" for="c-42797410">[-]</label><label class="expand" for="c-42797410">[2 more]</label></div><br/><div class="children"><div class="content">A safe API would look a lot like Windows&#x27; GetEnvironmentVariable and SetEnvironmentVariable<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winbase&#x2F;nf-winbase-getenvironmentvariable" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winbase&#x2F;...</a><p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winbase&#x2F;nf-winbase-setenvironmentvariable" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winbase&#x2F;...</a></div><br/><div id="42797559" class="c"><input type="checkbox" id="c-42797559" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797410">parent</a><span>|</span><a href="#42797025">next</a><span>|</span><label class="collapse" for="c-42797559">[-]</label><label class="expand" for="c-42797559">[1 more]</label></div><br/><div class="children"><div class="content">Yep. GetEnvironmentStrings and FreeEnvironmentStrings are probably even more noteworthy as they seem to substitute for an exposed environ array, though they push more effort to the application.</div><br/></div></div></div></div></div></div></div></div><div id="42797025" class="c"><input type="checkbox" id="c-42797025" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42796982">parent</a><span>|</span><a href="#42797032">prev</a><span>|</span><a href="#42797012">next</a><span>|</span><label class="collapse" for="c-42797025">[-]</label><label class="expand" for="c-42797025">[1 more]</label></div><br/><div class="children"><div class="content">It can&#x27;t ensure synchronization because any code using libc could bypass the sync wrapper. In particular, Rust lets you link C libs which wouldn&#x27;t use the Rust stdlib.</div><br/></div></div><div id="42797012" class="c"><input type="checkbox" id="c-42797012" checked=""/><div class="controls bullet"><span class="by">msully4321</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42796982">parent</a><span>|</span><a href="#42797025">prev</a><span>|</span><a href="#42797383">next</a><span>|</span><label class="collapse" for="c-42797012">[-]</label><label class="expand" for="c-42797012">[1 more]</label></div><br/><div class="children"><div class="content">Because it can still race with C code using the standard library. getenv calls are common in C libraries; the call to getenv in this post was inside of strerror.</div><br/></div></div><div id="42797383" class="c"><input type="checkbox" id="c-42797383" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42796982">parent</a><span>|</span><a href="#42797012">prev</a><span>|</span><a href="#42797132">next</a><span>|</span><label class="collapse" for="c-42797383">[-]</label><label class="expand" for="c-42797383">[3 more]</label></div><br/><div class="children"><div class="content">you&#x27;ve gotten a lot of answers which say the same thing, but which I don&#x27;t think answer your question:<p>synchronization methods impose various complexity and performance penalties, and single threaded applications which don&#x27;t need that would pay those penalties and get no benefit.<p>Unix was designed around a lightweight ethos that allowed simple combining of functions by the user on the command line. See &quot;worse is better&quot;, but tl;dr that way of doing things proved better, and that&#x27;s why you find yourself confronting what it doesn&#x27;t do.</div><br/><div id="42798095" class="c"><input type="checkbox" id="c-42798095" checked=""/><div class="controls bullet"><span class="by">davidt84</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797383">parent</a><span>|</span><a href="#42798009">next</a><span>|</span><label class="collapse" for="c-42798095">[-]</label><label class="expand" for="c-42798095">[1 more]</label></div><br/><div class="children"><div class="content">The real problem is that getenv() and setenv() were created before threads were really a thing.</div><br/></div></div><div id="42798009" class="c"><input type="checkbox" id="c-42798009" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42796919">root</a><span>|</span><a href="#42797383">parent</a><span>|</span><a href="#42798095">prev</a><span>|</span><a href="#42797132">next</a><span>|</span><label class="collapse" for="c-42798009">[-]</label><label class="expand" for="c-42798009">[1 more]</label></div><br/><div class="children"><div class="content">Well it was better in the short term but is worse in the long term. In particular, the error handling situation is generally atrocious, which is fine for interactive&#x2F;sysadmin use but much worse for serious production use.</div><br/></div></div></div></div></div></div></div></div><div id="42797132" class="c"><input type="checkbox" id="c-42797132" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42796919">prev</a><span>|</span><a href="#42797230">next</a><span>|</span><label class="collapse" for="c-42797132">[-]</label><label class="expand" for="c-42797132">[8 more]</label></div><br/><div class="children"><div class="content">Even if C stdlib maintainers are resistant against making setenv multi-thread safe, at a minimum there should be a new alternative thread-safe API defined, whether within POSIX or defining a defacto standard and forcing POSIX to adopt it over time. If instead of explaining why nothing could be done was spent fixing this problem, a new thread-safe API could have replaced the old setenv which could have been deprecated and removed from many software projects.<p>I&#x27;m also not convinced by Musl&#x27;s maintainer that it can&#x27;t be fixed within Musl considering glibc is making changes to make this a non-issue.</div><br/><div id="42798162" class="c"><input type="checkbox" id="c-42798162" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#42797132">parent</a><span>|</span><a href="#42797748">next</a><span>|</span><label class="collapse" for="c-42798162">[-]</label><label class="expand" for="c-42798162">[3 more]</label></div><br/><div class="children"><div class="content">The biggest problem is not the absence of a thread safe API, it&#x27;s the existence of this:<p><pre><code>    extern char **environ;
</code></pre>
As long as environ is publicly accessible, there&#x27;s no guarantee that setenv and getenv will be used at all, since they&#x27;re not necessary.<p>If you&#x27;re willing to get rid of environ, it&#x27;s pretty trivial to make setenv and getenv thread safe. If not, then it&#x27;s impossible, although one could still argue that making setenv and getenv thread safe is at least an improvement, even if it&#x27;s not a complete solution (aka don&#x27;t let the perfect be the enemy of the good).</div><br/><div id="42798826" class="c"><input type="checkbox" id="c-42798826" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42797132">root</a><span>|</span><a href="#42798162">parent</a><span>|</span><a href="#42797748">next</a><span>|</span><label class="collapse" for="c-42798826">[-]</label><label class="expand" for="c-42798826">[2 more]</label></div><br/><div class="children"><div class="content">&gt; aka don&#x27;t let the perfect be the enemy of the good<p>Exactly my point. Over time *environ would disappear, at least from the major software projects that everyone uses (assuming it&#x27;s even in use in them in the first place).</div><br/><div id="42801650" class="c"><input type="checkbox" id="c-42801650" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42797132">root</a><span>|</span><a href="#42798826">parent</a><span>|</span><a href="#42797748">next</a><span>|</span><label class="collapse" for="c-42801650">[-]</label><label class="expand" for="c-42801650">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I don&#x27;t think I&#x27;ve ever seen a single use of it. However I just checked on grep.app and at least a few big softwares use it - git, nginx, Postgresql, neovim, etc, which suggests that setenv&#x2F;getenv is not sufficient.</div><br/></div></div></div></div></div></div><div id="42797748" class="c"><input type="checkbox" id="c-42797748" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42797132">parent</a><span>|</span><a href="#42798162">prev</a><span>|</span><a href="#42798436">next</a><span>|</span><label class="collapse" for="c-42797748">[-]</label><label class="expand" for="c-42797748">[1 more]</label></div><br/><div class="children"><div class="content">Guess that would also require some locking for all the exec() functions that don&#x27;t take the environment as a parameter or that search PATH for the executable.</div><br/></div></div><div id="42798436" class="c"><input type="checkbox" id="c-42798436" checked=""/><div class="controls bullet"><span class="by">davidt84</span><span>|</span><a href="#42797132">parent</a><span>|</span><a href="#42797748">prev</a><span>|</span><a href="#42797230">next</a><span>|</span><label class="collapse" for="c-42798436">[-]</label><label class="expand" for="c-42798436">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced by you that you know more than the experts who have determined there is no backwards-compatible way to fix this.</div><br/><div id="42798815" class="c"><input type="checkbox" id="c-42798815" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42797132">root</a><span>|</span><a href="#42798436">parent</a><span>|</span><a href="#42797230">next</a><span>|</span><label class="collapse" for="c-42798815">[-]</label><label class="expand" for="c-42798815">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll take existence proofs [1] over personal insults but YMMV. You also may want to be careful assuming the expertise of people on this forum. Some people here are quite technical.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;commit&#x2F;7a61e7f557a97ab597d6fca5e2d1f13f65685c61">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;commit&#x2F;7a61e7f557a97ab597d6f...</a></div><br/><div id="42798839" class="c"><input type="checkbox" id="c-42798839" checked=""/><div class="controls bullet"><span class="by">davidt84</span><span>|</span><a href="#42797132">root</a><span>|</span><a href="#42798815">parent</a><span>|</span><a href="#42797230">next</a><span>|</span><label class="collapse" for="c-42798839">[-]</label><label class="expand" for="c-42798839">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t thread safe, it&#x27;s safER.<p>I am also quite technical, thanks.</div><br/></div></div></div></div></div></div></div></div><div id="42797230" class="c"><input type="checkbox" id="c-42797230" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#42797132">prev</a><span>|</span><a href="#42797004">next</a><span>|</span><label class="collapse" for="c-42797230">[-]</label><label class="expand" for="c-42797230">[5 more]</label></div><br/><div class="children"><div class="content">Its like a rite of passage to be hit by an environment related bug on linux, which is mysteriously less a problem on other unix&#x27;s. Which is sorta funny given how pragmatic Linus and the kernel are about fixing POSIX bugs by making them not happen, while glibc is still lagging here decades after people tried to at least make the problem better. Sure there is all the crap around TZ&#x2F;etc, but simply providing getenv_r() and synchronizing it with setenv() and warning during compile&#x2F;link on getenv() would have killed much of the problem. Nevermind, actually doing a COW style system where the env pointer(s) are read only. Instead the problem is pushed to the individual application, which is a huge mistake, because application writers are rarely aware of what their dependencies are doing. Which is the situation I found myself in many many years ago. The closed source library vendor, at the time, told us to stop using that toy unix clone (linux).</div><br/><div id="42797790" class="c"><input type="checkbox" id="c-42797790" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42797230">parent</a><span>|</span><a href="#42797004">next</a><span>|</span><label class="collapse" for="c-42797790">[-]</label><label class="expand" for="c-42797790">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>environment related bug on linux, which is mysteriously less a problem on other unix&#x27;s.</i><p>How do you figure?  The problem isn&#x27;t the implementation, it&#x27;s the API.  setenv(), unsetenv(), putenv(), and especially environ, are inherently unsafe in a multithreaded program.  Even getenv_r() can&#x27;t really save you, since another thread may be calling setenv() while the (old) value of an env var is being copied into the provided buffer.  Sure, a getenv_r() fixes the case where you get something back from getenv(), and then another thread calls setenv() and makes that memory invalid, but there&#x27;s no way to protect the other calls breaking the API.<p>There are ways to mitigate some of the issues, like having libc hold a mutex when inside getenv()&#x2F;setenv()&#x2F;putenv()&#x2F;unsetenv(), but there&#x27;s still no way for libc to guarantee that something returned by getenv() remains valid long enough for the calling code to use it (which, right, can be fixed by getenv_r(), which could also be protected by that mutex).  But there&#x27;s no good way to make direct access to environ safe.  I suppose you could make environ a thread-local, but then different threads&#x27; views of the environment could become out of sync, permanently (and you could get different results between calling getenv_r() and examining environ directly).<p>Back-compat here is just really hard to do.  Even adding a mutex to protect those functions could change the semantics enough to break existing programs.  (Arguably they&#x27;re already broken in that case, but still...)</div><br/><div id="42798307" class="c"><input type="checkbox" id="c-42798307" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42797230">root</a><span>|</span><a href="#42797790">parent</a><span>|</span><a href="#42798042">next</a><span>|</span><label class="collapse" for="c-42798307">[-]</label><label class="expand" for="c-42798307">[2 more]</label></div><br/><div class="children"><div class="content">Why does adding a mutex break the API? I guess it breaks `char**environ`. But the API wouldn&#x27;t be broken.</div><br/><div id="42798691" class="c"><input type="checkbox" id="c-42798691" checked=""/><div class="controls bullet"><span class="by">benmmurphy</span><span>|</span><a href="#42797230">root</a><span>|</span><a href="#42798307">parent</a><span>|</span><a href="#42798042">next</a><span>|</span><label class="collapse" for="c-42798691">[-]</label><label class="expand" for="c-42798691">[1 more]</label></div><br/><div class="children"><div class="content">I think you would have to change the API to return a copy of the string as the get_env result which the caller is responsible for free-ing or the env implementation would have to ensure returned values from get_env are stable and never change which is effectively a memory leak.</div><br/></div></div></div></div><div id="42798042" class="c"><input type="checkbox" id="c-42798042" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42797230">root</a><span>|</span><a href="#42797790">parent</a><span>|</span><a href="#42798307">prev</a><span>|</span><a href="#42797004">next</a><span>|</span><label class="collapse" for="c-42798042">[-]</label><label class="expand" for="c-42798042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Even getenv_r() can&#x27;t really save you, since another thread may be calling setenv() while the (old) value of an env var is being copied into the provided buffer.<p>Won&#x27;t that depends on the libc implementation. For example, maybe setenv writes to another buffer, then swaps pointers atomically; wouldn&#x27;t that work?</div><br/></div></div></div></div></div></div><div id="42797004" class="c"><input type="checkbox" id="c-42797004" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42797230">prev</a><span>|</span><a href="#42797893">next</a><span>|</span><label class="collapse" for="c-42797004">[-]</label><label class="expand" for="c-42797004">[7 more]</label></div><br/><div class="children"><div class="content">Previously on setenv being a terrible thing: <a href="https:&#x2F;&#x2F;www.evanjones.ca&#x2F;setenv-is-not-thread-safe.html" rel="nofollow">https:&#x2F;&#x2F;www.evanjones.ca&#x2F;setenv-is-not-thread-safe.html</a> (discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38342642">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38342642</a> first comment is even about it causing issues in Rust)</div><br/><div id="42797328" class="c"><input type="checkbox" id="c-42797328" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42797004">parent</a><span>|</span><a href="#42797893">next</a><span>|</span><label class="collapse" for="c-42797328">[-]</label><label class="expand" for="c-42797328">[6 more]</label></div><br/><div class="children"><div class="content">Yes. That&#x27;s known.<p>Most of the rest of the problem here seems to be the development environment. They&#x27;re testing on a remote machine in an Amazon data center and using Docker. This rig fails to report that a process has crashed. Then they don&#x27;t have enough debug symbol info inside their container to get a backtrace. If they&#x27;d gotten a clean backtrace reported on the first failure, this would have been obvious.<p>Why is anyone using &quot;setenv&quot; anyway?</div><br/><div id="42797385" class="c"><input type="checkbox" id="c-42797385" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42797004">root</a><span>|</span><a href="#42797328">parent</a><span>|</span><a href="#42797536">next</a><span>|</span><label class="collapse" for="c-42797385">[-]</label><label class="expand" for="c-42797385">[1 more]</label></div><br/><div class="children"><div class="content">Yup, it&#x27;s mostly just the story and tools we used to get ourselves out of a mess that was made harder by some decisions made earlier -- the tests were running in a container with stripped symbols (we&#x27;re going to ship symbols after this, no reason to over-optimize), our custom test runner failed to report process death (an oversight).<p>There&#x27;s no reason setenv should have been called here. The `openssl-probe` library could simply return the paths to the system cert files and callers could plug those directly into the OpenSSL config.<p>Oversights all around and hopefully this continues to improve.</div><br/></div></div><div id="42797536" class="c"><input type="checkbox" id="c-42797536" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42797004">root</a><span>|</span><a href="#42797328">parent</a><span>|</span><a href="#42797385">prev</a><span>|</span><a href="#42797893">next</a><span>|</span><label class="collapse" for="c-42797536">[-]</label><label class="expand" for="c-42797536">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Why is anyone using &quot;setenv&quot; anyway?<p>Because it’s there and it looks like a good idea until it takes one of your fingers.</div><br/><div id="42798080" class="c"><input type="checkbox" id="c-42798080" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42797004">root</a><span>|</span><a href="#42797536">parent</a><span>|</span><a href="#42797893">next</a><span>|</span><label class="collapse" for="c-42798080">[-]</label><label class="expand" for="c-42798080">[3 more]</label></div><br/><div class="children"><div class="content">It really does not look like a good idea to setenv() . The very notion is quite  terrifying. Messing with a bunch of globals, that other code knows about as well? Nuh-uh.<p>The thing is, the OP people weren&#x27;t doing that at all, it was some irresponsible library maintainers. If your code does that, you have to include something like the &quot;surgeon general&#x27;s warning&quot; everywhere: &quot;CAREFUL: USING THIS LIBRARY MAY CAUSE TERMINAL CRASHES&quot;.</div><br/><div id="42800868" class="c"><input type="checkbox" id="c-42800868" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42797004">root</a><span>|</span><a href="#42798080">parent</a><span>|</span><a href="#42800080">next</a><span>|</span><label class="collapse" for="c-42800868">[-]</label><label class="expand" for="c-42800868">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>History: V7 research UNIX had &quot;getenv()&quot;, but not &quot;setenv()&quot;.[1]
BSD Unix 4.x had  &quot;getenv()&quot; and &quot;setenv()&quot;[2] Google&#x27;s &quot;AI Overview&quot; says &quot;The setenv() and unsetenv() functions were included in Version 7 of AT&amp;T UNIX.&quot;, but that does not seem to be correct.<p>This misfeature seems to be what was once called a &quot;Berkeleyism&quot;, a Berkeley mod to UNIX.<p>&quot;setenv()&quot; predates UNIX&#x2F;Linux getting threads.<p>[1] <a href="http:&#x2F;&#x2F;web.cuzuco.com&#x2F;~cuzuco&#x2F;v7&#x2F;v7vol1.pdf" rel="nofollow">http:&#x2F;&#x2F;web.cuzuco.com&#x2F;~cuzuco&#x2F;v7&#x2F;v7vol1.pdf</a><p>[2] <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;44bsdprogrammers0000ucbe&#x2F;page&#x2F;n383&#x2F;mode&#x2F;2up?view=theater" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;44bsdprogrammers0000ucbe&#x2F;page&#x2F;n3...</a></div><br/></div></div><div id="42800080" class="c"><input type="checkbox" id="c-42800080" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#42797004">root</a><span>|</span><a href="#42798080">parent</a><span>|</span><a href="#42800868">prev</a><span>|</span><a href="#42797893">next</a><span>|</span><label class="collapse" for="c-42800080">[-]</label><label class="expand" for="c-42800080">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s OpenSSL. It&#x27;s basically a sea urchin turned into code in terms of safe handling.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42797893" class="c"><input type="checkbox" id="c-42797893" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42797004">prev</a><span>|</span><a href="#42798397">next</a><span>|</span><label class="collapse" for="c-42797893">[-]</label><label class="expand" for="c-42797893">[4 more]</label></div><br/><div class="children"><div class="content">This reminded me of that whole &quot;12-factor app&quot; movement, which several of my former coworkers had really bought into.  One of the &quot;factors&quot; is that apps should be configured by environment variables.<p>I always thought this was kinda foolish: your configuration method is a flat-namespace basked of stringly-typed values.  The perils of getenv()&#x2F;setenv()&#x2F;environ are also, I think, a great argument against using env vars for configuration.<p>Sure, there aren&#x27;t always great, well-supported options out there.  I prefer using a configuration file (you can have templated config and a system that fills in different values for e.g. dev&#x2F;stage&#x2F;prod), and I&#x27;ll usually use YAML, despite its faults and gotchas.  There are probably better configuration file formats, but IMO YAML is still significantly better than using env vars.</div><br/><div id="42801142" class="c"><input type="checkbox" id="c-42801142" checked=""/><div class="controls bullet"><span class="by">johnny22</span><span>|</span><a href="#42797893">parent</a><span>|</span><a href="#42798522">next</a><span>|</span><label class="collapse" for="c-42801142">[-]</label><label class="expand" for="c-42801142">[1 more]</label></div><br/><div class="children"><div class="content">This is unrelated really. If you read your enviornment variables into config and never touched them again, then you&#x27;re totally safe.<p>I personally use 12 factor app style, but once it&#x27;s entered the app I validate the env variables and data and then store them. It&#x27;s totally fine after that.</div><br/></div></div><div id="42798522" class="c"><input type="checkbox" id="c-42798522" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42797893">parent</a><span>|</span><a href="#42801142">prev</a><span>|</span><a href="#42799597">next</a><span>|</span><label class="collapse" for="c-42798522">[-]</label><label class="expand" for="c-42798522">[1 more]</label></div><br/><div class="children"><div class="content">getenv() is perfectly fine, it&#x27;s setenv() that is the problem.  Which in theory this wouldn&#x27;t be using since the env would be set up prior to starting that mystical app.<p>But yes, a flat namespace, with string values, shared as a free-for-all with who knows what libraries and modules you&#x27;re loading… that&#x27;s not a good idea even if it didn&#x27;t have safety issues in setenv().</div><br/></div></div><div id="42799597" class="c"><input type="checkbox" id="c-42799597" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42797893">parent</a><span>|</span><a href="#42798522">prev</a><span>|</span><a href="#42798397">next</a><span>|</span><label class="collapse" for="c-42799597">[-]</label><label class="expand" for="c-42799597">[1 more]</label></div><br/><div class="children"><div class="content">I have similar reservations about env vars.  I dislike how they can be read from anywhere--it interrupts the ability to reason about a function&#x27;s behavior from its signature and makes impure plenty of functions that could otherwise have been pure.<p>If there were a language feature that let me mark apps such that during any process env vars are not writable and are readable only once (together, in a batch, not once per var), I&#x27;d use it everywhere.</div><br/></div></div></div></div><div id="42798397" class="c"><input type="checkbox" id="c-42798397" checked=""/><div class="controls bullet"><span class="by">rikthevik</span><span>|</span><a href="#42797893">prev</a><span>|</span><a href="#42797078">next</a><span>|</span><label class="collapse" for="c-42798397">[-]</label><label class="expand" for="c-42798397">[1 more]</label></div><br/><div class="children"><div class="content">Great article about digging into a non-obvious bug. This one had it all! Intermittent bug, architecture-specific, hidden in a dependency, rust, the python GIL, gettext. Fantastic stuff.<p>These kinds of detailed troubleshooting reports are the closest thing you can get to having to do it yourself. Thanks to the authors. It&#x27;s easy to say &quot;don&#x27;t use X duh&quot; until a dependency relies on it, and how were you supposed to know?</div><br/></div></div><div id="42797078" class="c"><input type="checkbox" id="c-42797078" checked=""/><div class="controls bullet"><span class="by">shikon7</span><span>|</span><a href="#42798397">prev</a><span>|</span><a href="#42798318">next</a><span>|</span><label class="collapse" for="c-42797078">[-]</label><label class="expand" for="c-42797078">[23 more]</label></div><br/><div class="children"><div class="content">I wonder why it is so hard for Rust to implement its own safe stdlib independent of C.</div><br/><div id="42797162" class="c"><input type="checkbox" id="c-42797162" checked=""/><div class="controls bullet"><span class="by">dgrunwald</span><span>|</span><a href="#42797078">parent</a><span>|</span><a href="#42797128">next</a><span>|</span><label class="collapse" for="c-42797162">[-]</label><label class="expand" for="c-42797162">[1 more]</label></div><br/><div class="children"><div class="content">How exactly would that help in this situation?<p>If both Rust and C have independent standard libraries loaded into the same process, each would have an independent set of environment variables. So setting a variable from Rust wouldn&#x27;t make it visible to the C code, which would break the article&#x27;s usecase of configuring OpenSSL.<p>The only real solution is to have the operating system provide a thread-safe way of managing environment variables. Windows does so; but in Linux that&#x27;s the job of libc, which refuses to provide thread-safety.</div><br/></div></div><div id="42797128" class="c"><input type="checkbox" id="c-42797128" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42797078">parent</a><span>|</span><a href="#42797162">prev</a><span>|</span><a href="#42797493">next</a><span>|</span><label class="collapse" for="c-42797128">[-]</label><label class="expand" for="c-42797128">[1 more]</label></div><br/><div class="children"><div class="content">The crash in the article happened when Python called C&#x27;s getenv. Rust could very well throw away libc, but then it would also be throwing away its great C interop story. Rust can&#x27;t force Python to use its own stdlib instead of libc.</div><br/></div></div><div id="42797493" class="c"><input type="checkbox" id="c-42797493" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42797078">parent</a><span>|</span><a href="#42797128">prev</a><span>|</span><a href="#42797456">next</a><span>|</span><label class="collapse" for="c-42797493">[-]</label><label class="expand" for="c-42797493">[6 more]</label></div><br/><div class="children"><div class="content">They did, it&#x27;s called core. But it assumes no operating system at all, and environment variables require an operating system.</div><br/><div id="42797694" class="c"><input type="checkbox" id="c-42797694" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797493">parent</a><span>|</span><a href="#42797456">next</a><span>|</span><label class="collapse" for="c-42797694">[-]</label><label class="expand" for="c-42797694">[5 more]</label></div><br/><div class="children"><div class="content">&gt; and environment variables require an operating system<p>Is that true? It&#x27;s just a process global string -&gt; string map, that can be pre-loaded with values before the process starts, with a copy of the current state being passed to any sub-process. This could be trivially implemented with batch processing&#x2F;supervisory programs.</div><br/><div id="42797869" class="c"><input type="checkbox" id="c-42797869" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797694">parent</a><span>|</span><a href="#42797805">next</a><span>|</span><label class="collapse" for="c-42797869">[-]</label><label class="expand" for="c-42797869">[2 more]</label></div><br/><div class="children"><div class="content">Sure, there&#x27;s a broader concept here, which doesn&#x27;t require any operating system. But any alternate string-&gt;string map you define won&#x27;t answer to C code calling getenv, won&#x27;t be passed to child processes created with fork, won&#x27;t be visible through &#x2F;proc&#x2F;$PID&#x2F;environ, etc.</div><br/><div id="42800034" class="c"><input type="checkbox" id="c-42800034" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797869">parent</a><span>|</span><a href="#42797805">next</a><span>|</span><label class="collapse" for="c-42800034">[-]</label><label class="expand" for="c-42800034">[1 more]</label></div><br/><div class="children"><div class="content">This is the context:<p>&gt; They did, it&#x27;s called core. But it assumes no operating system at all, and environment variables require an operating system.<p>I think there&#x27;s some confusion here. The C standard library is an abstraction layer that exists to implement standard behavior on hardware. It&#x27;s <i>entirely</i> unrelated to the existence of an OS. Things like &quot;&#x2F;proc&#x2F;$PID&#x2F;environ&quot; have nothing to do with C.<p>There are many standard libraries, for embedded, that implement these things, like getenv, on <i>bare metal</i> [1].<p>Standard C libraries exist to <i>implement functionality</i>. It <i>does not</i> define <i>how</i> to implement the functionality. That&#x27;s the whole point of C: it&#x27;s an abstraction that has very little requirements.<p>The implementation of environment variables don&#x27;t require an OS. If they made this &quot;core&quot;, they could trivially implement the concept.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Newlib" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Newlib</a>
[2] getenv: <a href="https:&#x2F;&#x2F;sourceware.org&#x2F;newlib&#x2F;libc.html" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;newlib&#x2F;libc.html</a></div><br/></div></div></div></div><div id="42797805" class="c"><input type="checkbox" id="c-42797805" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797694">parent</a><span>|</span><a href="#42797869">prev</a><span>|</span><a href="#42798024">next</a><span>|</span><label class="collapse" for="c-42797805">[-]</label><label class="expand" for="c-42797805">[1 more]</label></div><br/><div class="children"><div class="content">Well, it&#x27;s used by the OS when exec-ing a new process, but at least the Linux syscall for that takes the environment as an explicit parameter. So it could be managed in whatever way by the runtime until execve() is called.</div><br/></div></div><div id="42798024" class="c"><input type="checkbox" id="c-42798024" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797694">parent</a><span>|</span><a href="#42797805">prev</a><span>|</span><a href="#42797456">next</a><span>|</span><label class="collapse" for="c-42798024">[-]</label><label class="expand" for="c-42798024">[1 more]</label></div><br/><div class="children"><div class="content">Environment variables are not just technical, they&#x27;re social. You need to get everyone on board with your scheme.</div><br/></div></div></div></div></div></div><div id="42797456" class="c"><input type="checkbox" id="c-42797456" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42797078">parent</a><span>|</span><a href="#42797493">prev</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42797456">[-]</label><label class="expand" for="c-42797456">[7 more]</label></div><br/><div class="children"><div class="content">Linux is an unusual platform in that it allows you to call into it via assembly. Most other platforms require you to go through libc to do so. It&#x27;s not really in Rust&#x27;s hands.</div><br/><div id="42797940" class="c"><input type="checkbox" id="c-42797940" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797456">parent</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42797940">[-]</label><label class="expand" for="c-42797940">[6 more]</label></div><br/><div class="children"><div class="content">This is not unusual at all. Windows allowed it for years before Linux came along. It was also true of some other *nix systems - IIRC, Ultrix (DEC) allowed this, and so did Dynix (Sequent).<p>*BSD allows it too, or used as of 2022.<p>What is unusual about Linux is that it guarantees a syscall ABI, meaning that if you follow it, you can make a system call &quot;portably&quot; across &quot;any&quot; version of Linux.</div><br/><div id="42798068" class="c"><input type="checkbox" id="c-42798068" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797940">parent</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42798068">[-]</label><label class="expand" for="c-42798068">[5 more]</label></div><br/><div class="children"><div class="content">Sure, I’m speaking about platforms that are relevant today, not historical ones. Windows, MacOS, {Free,Open,Net}BSD, Solaris, illumos, none of these do.</div><br/><div id="42798544" class="c"><input type="checkbox" id="c-42798544" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42798068">parent</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42798544">[-]</label><label class="expand" for="c-42798544">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite easy to find out the actual situation on this since Go decided to do it their way.  Last I checked, OpenBSD is the only OS where they go through libc, but I haven&#x27;t really kept up.</div><br/><div id="42798634" class="c"><input type="checkbox" id="c-42798634" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42798544">parent</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42798634">[-]</label><label class="expand" for="c-42798634">[3 more]</label></div><br/><div class="children"><div class="content">In my understanding, Go initially disregarded various platforms&#x27; rules here, and have ended up walking it back. I could be wrong though.<p>It&#x27;s hard to find good details here, but here&#x27;s a mailing list thread from 2019 mentioning libc usage: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;uX8eUeyuuAY&#x2F;m&#x2F;CfhlczbrAwAJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;uX8eUeyuuAY&#x2F;m&#x2F;Cfhl...</a><p>&gt; On Solaris (and Windows), and more recently in macOS as well we link with libc (or equivalent).<p>&gt; Go used to do raw system calls on macOS, and binaries were occasionally broken by kernel updates. Now Go uses libc on macOS.</div><br/><div id="42798669" class="c"><input type="checkbox" id="c-42798669" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42798634">parent</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42798669">[-]</label><label class="expand" for="c-42798669">[2 more]</label></div><br/><div class="children"><div class="content">Yep, in 2022 it finally started using libc on *BSD too.<p>But ... there&#x27;s a difference between being able to do direct syscalls via asm, and them being portable across kernel versions, which is what this subthread was about.<p>Granted, most people want version portability, but still on a technical level, it&#x27;s not the same thing.</div><br/><div id="42798689" class="c"><input type="checkbox" id="c-42798689" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42798669">parent</a><span>|</span><a href="#42797095">next</a><span>|</span><label class="collapse" for="c-42798689">[-]</label><label class="expand" for="c-42798689">[1 more]</label></div><br/><div class="children"><div class="content">No, my comment was about what APIs a platform considers to be their stable, external API. That you can technically call them anyway (except for ones like OpenBSD that actively check and prevent you) doesn&#x27;t mean you&#x27;re not doing something unsupported.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42797095" class="c"><input type="checkbox" id="c-42797095" checked=""/><div class="controls bullet"><span class="by">zanderwohl</span><span>|</span><a href="#42797078">parent</a><span>|</span><a href="#42797456">prev</a><span>|</span><a href="#42798318">next</a><span>|</span><label class="collapse" for="c-42797095">[-]</label><label class="expand" for="c-42797095">[7 more]</label></div><br/><div class="children"><div class="content">It would be a tremendous amount of work, and would take years. Meanwhile, the problems are avoidable. It&#x27;s not exactly the &quot;rust way&quot; to just remember and avoid problems, but everything in language design is compromises.</div><br/><div id="42797477" class="c"><input type="checkbox" id="c-42797477" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797095">parent</a><span>|</span><a href="#42798318">next</a><span>|</span><label class="collapse" for="c-42797477">[-]</label><label class="expand" for="c-42797477">[6 more]</label></div><br/><div class="children"><div class="content">&quot;Impossibru!!&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;sunfishcode&#x2F;eyra">https:&#x2F;&#x2F;github.com&#x2F;sunfishcode&#x2F;eyra</a><p>Oh look:<p>&gt; Why use Eyra? It fixes Rust&#x27;s set_var unsoundness issue. The environment-variable implementation leaks memory internally (it is optional, but enabled by default), so setenv etc. are thread-safe.</div><br/><div id="42801339" class="c"><input type="checkbox" id="c-42801339" checked=""/><div class="controls bullet"><span class="by">zanderwohl</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797477">parent</a><span>|</span><a href="#42797507">next</a><span>|</span><label class="collapse" for="c-42801339">[-]</label><label class="expand" for="c-42801339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why not use Eyra?<p>Well, that&#x27;s a lot of caveats. As I said, it would take years to complete. And it looks like it&#x27;s well on its way but not near complete.</div><br/></div></div><div id="42797507" class="c"><input type="checkbox" id="c-42797507" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797477">parent</a><span>|</span><a href="#42801339">prev</a><span>|</span><a href="#42798027">next</a><span>|</span><label class="collapse" for="c-42797507">[-]</label><label class="expand" for="c-42797507">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s quite a trade-off</div><br/><div id="42798345" class="c"><input type="checkbox" id="c-42798345" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797507">parent</a><span>|</span><a href="#42798311">next</a><span>|</span><label class="collapse" for="c-42798345">[-]</label><label class="expand" for="c-42798345">[1 more]</label></div><br/><div class="children"><div class="content">I think glibc made the same trade-off. It makes sense for most types of programs, but there&#x27;s certainly a lot of classes of programs that wouldn&#x27;t take it.</div><br/></div></div><div id="42798311" class="c"><input type="checkbox" id="c-42798311" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797507">parent</a><span>|</span><a href="#42798345">prev</a><span>|</span><a href="#42798027">next</a><span>|</span><label class="collapse" for="c-42798311">[-]</label><label class="expand" for="c-42798311">[1 more]</label></div><br/><div class="children"><div class="content">What is? Leaking memory? It&#x27;s going to be a few kB at absolute most. Not an issue unless you are doing something very weird.</div><br/></div></div></div></div><div id="42798027" class="c"><input type="checkbox" id="c-42798027" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42797078">root</a><span>|</span><a href="#42797477">parent</a><span>|</span><a href="#42797507">prev</a><span>|</span><a href="#42798318">next</a><span>|</span><label class="collapse" for="c-42798027">[-]</label><label class="expand" for="c-42798027">[1 more]</label></div><br/><div class="children"><div class="content">That only works on Linux though right?</div><br/></div></div></div></div></div></div></div></div><div id="42798318" class="c"><input type="checkbox" id="c-42798318" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42797078">prev</a><span>|</span><a href="#42797137">next</a><span>|</span><label class="collapse" for="c-42798318">[-]</label><label class="expand" for="c-42798318">[2 more]</label></div><br/><div class="children"><div class="content">What is the rationale for libc not making setenv&#x2F;getenv thread safe? It does seem rather odd given how environment variables are explicitly defined as shared between threads in the same process!<p>It doesn&#x27;t seem it would take much to do it efficiently, even retaining the poor getenv() pointer-returning API (which could point to a thread local buffer). The coordination between getenv and setenv could be very lightweight - spinlock vs mutex.</div><br/><div id="42801911" class="c"><input type="checkbox" id="c-42801911" checked=""/><div class="controls bullet"><span class="by">4gotunameagain</span><span>|</span><a href="#42798318">parent</a><span>|</span><a href="#42797137">next</a><span>|</span><label class="collapse" for="c-42801911">[-]</label><label class="expand" for="c-42801911">[1 more]</label></div><br/><div class="children"><div class="content">I think the argument was that the standard states that setenv is not thread safe, although from what I see it says that it does <i>not have to be</i> thread safe:<p><pre><code>  The setenv( ) function need not be thread-safe. A function that is not required to be thread-safe is not required to be reentrant.
</code></pre>
<a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;open&#x2F;n4217.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;open&#x2F;n4217.pdf</a>.<p>Page.. 1860 :&#x27;)</div><br/></div></div></div></div><div id="42797137" class="c"><input type="checkbox" id="c-42797137" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#42798318">prev</a><span>|</span><a href="#42797896">next</a><span>|</span><label class="collapse" for="c-42797137">[-]</label><label class="expand" for="c-42797137">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t we have a better pattern for this?<p><pre><code>    if (__environ == NULL || name[0] == &#x27;\0&#x27;)
      return NULL;</code></pre></div><br/></div></div><div id="42797896" class="c"><input type="checkbox" id="c-42797896" checked=""/><div class="controls bullet"><span class="by">cuno</span><span>|</span><a href="#42797137">prev</a><span>|</span><a href="#42797390">next</a><span>|</span><label class="collapse" for="c-42797896">[-]</label><label class="expand" for="c-42797896">[1 more]</label></div><br/><div class="children"><div class="content">We ended up overriding and replacing with our own thread-safe version years ago when we also hit this.</div><br/></div></div><div id="42796873" class="c"><input type="checkbox" id="c-42796873" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#42797390">prev</a><span>|</span><a href="#42797761">next</a><span>|</span><label class="collapse" for="c-42796873">[-]</label><label class="expand" for="c-42796873">[31 more]</label></div><br/><div class="children"><div class="content">Yet another person is burned by calling setenv() in a multi-threaded context.  There really needs to be a big warning banner on the manpage for setenv() that warns about this because it seems like a far more common problem than you would expect.</div><br/><div id="42796948" class="c"><input type="checkbox" id="c-42796948" checked=""/><div class="controls bullet"><span class="by">umpalumpaaa</span><span>|</span><a href="#42796873">parent</a><span>|</span><a href="#42796940">next</a><span>|</span><label class="collapse" for="c-42796948">[-]</label><label class="expand" for="c-42796948">[28 more]</label></div><br/><div class="children"><div class="content">The man page says:<p>&gt;        POSIX.1 does not require setenv() or unsetenv() to be reentrant.<p>A non-reentrant function cannot be thread safe.<p>In general (for POSIX, libc and many other libraries: if the docs do not explicitly say &quot;this function is thread safe&quot; they are not).</div><br/><div id="42796999" class="c"><input type="checkbox" id="c-42796999" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42796948">parent</a><span>|</span><a href="#42797172">next</a><span>|</span><label class="collapse" for="c-42796999">[-]</label><label class="expand" for="c-42796999">[19 more]</label></div><br/><div class="children"><div class="content">It&#x27;s time to move beyond this attitude and make things safe by default. For example, Solaris has a safer version of setenv().<p>&quot;It is ridiculous that this has been a known problem for so long. It has wasted thousands of hours of people&#x27;s time, either debugging the problems, or debating what to do about it. We know how to fix the problem.&quot; <a href="https:&#x2F;&#x2F;www.evanjones.ca&#x2F;setenv-is-not-thread-safe.html" rel="nofollow">https:&#x2F;&#x2F;www.evanjones.ca&#x2F;setenv-is-not-thread-safe.html</a></div><br/><div id="42797975" class="c"><input type="checkbox" id="c-42797975" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42796999">parent</a><span>|</span><a href="#42797261">next</a><span>|</span><label class="collapse" for="c-42797975">[-]</label><label class="expand" for="c-42797975">[4 more]</label></div><br/><div class="children"><div class="content">One of the major differences between X Window and the win32 GUI APIs is that the windows one builds in thread safety, and it cannot be removed. This means that you pay the price of mutexes and the like (what the windows world likes to call &quot;critical sections&quot;), even if you have a single threaded GUI. X Window, on the other hand, decided to do nothing about threads at all, leaving it up to the application.<p>30 years after these decisions were made, most sensible people do single threaded GUIs anyway (that is, all calls to the windowing API come from a single thread, and all redraws occur synchronously with respect to that thread; this does not block the use of threads functioning as workers on behalf of the GUI, but they are not allowed to make windowing API calls themselves).<p>Consequently, the overhead present in the win32 API is basically just dead-weight, there to make sure that &quot;things are safe by default&quot;.<p>There&#x27;s a design lesson here for everyone, though precisely what it is will likely still be argued about.</div><br/><div id="42801761" class="c"><input type="checkbox" id="c-42801761" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797975">parent</a><span>|</span><a href="#42798299">next</a><span>|</span><label class="collapse" for="c-42801761">[-]</label><label class="expand" for="c-42801761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consequently, the overhead present in the win32 API is basically just dead-weight, there to make sure that &quot;things are safe by default&quot;.<p>How much overhead is it though? IIRC uncontended mutexes are practically free, especially when they&#x27;re only being used from a single thread.<p>Our industry is way too eager to make things unsafe for the sake of marginal performance differences that are irrelevant for most use cases, IMO.</div><br/></div></div><div id="42798299" class="c"><input type="checkbox" id="c-42798299" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797975">parent</a><span>|</span><a href="#42801761">prev</a><span>|</span><a href="#42797261">next</a><span>|</span><label class="collapse" for="c-42798299">[-]</label><label class="expand" for="c-42798299">[2 more]</label></div><br/><div class="children"><div class="content">Yet 30 years later people <i>are</i> calling setenv()&#x2F;getenv() from different threads even though &quot;it is known&quot; that it crashes. For whatever reason the lesson from GUIs doesn&#x27;t apply here.</div><br/><div id="42798576" class="c"><input type="checkbox" id="c-42798576" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42798299">parent</a><span>|</span><a href="#42797261">next</a><span>|</span><label class="collapse" for="c-42798576">[-]</label><label class="expand" for="c-42798576">[1 more]</label></div><br/><div class="children"><div class="content">Judging from a lot of the comments in this thread, the idea that there could even be parts of the *POSIX API* that are not thread-safe seems like an idea that hasn&#x27;t even occured to a lot of (younger?) programmers ...</div><br/></div></div></div></div></div></div><div id="42797261" class="c"><input type="checkbox" id="c-42797261" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42796999">parent</a><span>|</span><a href="#42797975">prev</a><span>|</span><a href="#42797087">next</a><span>|</span><label class="collapse" for="c-42797261">[-]</label><label class="expand" for="c-42797261">[10 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t.<p>You could wrap setenv in a mutex, but that&#x27;s not good enough.  It can still be called from different processes, which means you&#x27;d need to do a more expensive and complex syncing system to make it safe.<p>That ballons out to other env related methods needing to honor the synchronization primitive in order for there to be a semblance of safety.<p>However, you still end up in a scenario where you can call<p><pre><code>    setenv
    getenv
</code></pre>
and that would be incorrect because between the set and the get, even with mutexes properly in place and coordinated amongst different applications, you have a race condition where your set can be overwritten by another application&#x27;s set before your get can run.  Now, instead of actually making these functions safe you&#x27;ve buried the fact that external processes (or your own threads) can mess with env state.<p>The solution is to stop using env as some sort of global variable and instead treat it as a constant when the application starts.  Using setenv should be mostly discouraged because of these issues.</div><br/><div id="42797429" class="c"><input type="checkbox" id="c-42797429" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797261">parent</a><span>|</span><a href="#42797483">next</a><span>|</span><label class="collapse" for="c-42797429">[-]</label><label class="expand" for="c-42797429">[2 more]</label></div><br/><div class="children"><div class="content">How does an external process mess with env state? As far as I know, you pass the environment when doing the execvpe() and then you cannot touch it from outside of the process anymore.</div><br/><div id="42797620" class="c"><input type="checkbox" id="c-42797620" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797429">parent</a><span>|</span><a href="#42797483">next</a><span>|</span><label class="collapse" for="c-42797620">[-]</label><label class="expand" for="c-42797620">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct. Parent comment is inaccurate. The problem is that a different library in the same process can use getenv without locking (or without locking the same lock as your code)</div><br/></div></div></div></div><div id="42797483" class="c"><input type="checkbox" id="c-42797483" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797261">parent</a><span>|</span><a href="#42797429">prev</a><span>|</span><a href="#42798306">next</a><span>|</span><label class="collapse" for="c-42797483">[-]</label><label class="expand" for="c-42797483">[6 more]</label></div><br/><div class="children"><div class="content">Of course you can. Mutexes are system objects, so it&#x27;s not a huge problem to sync across processes, if you really have to (is it really expected that one process can set env vars inside another process?).<p>Making global state, especially state that has no reason to be modified or even read very often like the env, thread safe is a trivial issue, well studied and understood. Could an intern do it? Probably not. Could literally any maintainer of a standard C library? Easily.<p>This is much more of a culture problem preventing such obvious flaws from being recognized as such.<p>Side-note: your set-then-get example is a theoretical problem in search of a use case. Why would you ever want to concurrently set an env var and expect to be guaranteed to read that same value? And even if this is a real thing that applications really use, exposing a new function to sync anything on the env mutex is, again, trivial. So, if you really needed that, you could do<p><pre><code>  lockenv
  setenv
  getenv
  unlockenv
</code></pre>
And problem solved.</div><br/><div id="42797824" class="c"><input type="checkbox" id="c-42797824" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797483">parent</a><span>|</span><a href="#42798045">next</a><span>|</span><label class="collapse" for="c-42797824">[-]</label><label class="expand" for="c-42797824">[2 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t solve anything.  You could be using a library (perhaps a closed-source one) that doesn&#x27;t use these hypothetical lockenv()&#x2F;unlockenv() functions.<p>This needs to be fixed inside libc, but there&#x27;s no way to do so completely without breaking backward-compatibility.</div><br/><div id="42800855" class="c"><input type="checkbox" id="c-42800855" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797824">parent</a><span>|</span><a href="#42798045">next</a><span>|</span><label class="collapse" for="c-42800855">[-]</label><label class="expand" for="c-42800855">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I was talking about fixes inside libc. The poster above was claiming it can&#x27;t be done inside libc. And the lockvenv&#x2F;unlockvenv functions I was mentioning were meant to exist besides the internal locking inside setenv&#x2F;getenv. They would only be used if you needed transactional access (a combination of setting&#x2F;getting multiple env vars atomically).</div><br/></div></div></div></div><div id="42798045" class="c"><input type="checkbox" id="c-42798045" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797483">parent</a><span>|</span><a href="#42797824">prev</a><span>|</span><a href="#42798306">next</a><span>|</span><label class="collapse" for="c-42798045">[-]</label><label class="expand" for="c-42798045">[3 more]</label></div><br/><div class="children"><div class="content">That is a technical solution. What is your solution to the much more serious social problem of adding this check to every codebase in existence? What points of leverage do you have?</div><br/><div id="42800869" class="c"><input type="checkbox" id="c-42800869" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42798045">parent</a><span>|</span><a href="#42798306">next</a><span>|</span><label class="collapse" for="c-42800869">[-]</label><label class="expand" for="c-42800869">[2 more]</label></div><br/><div class="children"><div class="content">The point was about adding a mutex inside libc in getenv and setenv. That way, every codebase in existence automatically gets this safety. The poster I was replying to claimed that this wouldn&#x27;t help, because it would still not offer thread safety when doing multiple operations.<p>I pointed out that, <i>in addition</i> to libc setenv&#x2F;getenv using a mutex internally, they could also expose new functions to allow transactional access for anyone that really needs it - though I suspect that is a vanishingly small minority.</div><br/><div id="42801622" class="c"><input type="checkbox" id="c-42801622" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42800869">parent</a><span>|</span><a href="#42798306">next</a><span>|</span><label class="collapse" for="c-42801622">[-]</label><label class="expand" for="c-42801622">[1 more]</label></div><br/><div class="children"><div class="content">Ah I see — in that case you might be interested in the lockless illumos impl <a href="https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libc&#x2F;port&#x2F;gen&#x2F;getenv.c">https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;...</a></div><br/></div></div></div></div></div></div></div></div><div id="42798306" class="c"><input type="checkbox" id="c-42798306" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797261">parent</a><span>|</span><a href="#42797483">prev</a><span>|</span><a href="#42797087">next</a><span>|</span><label class="collapse" for="c-42798306">[-]</label><label class="expand" for="c-42798306">[1 more]</label></div><br/><div class="children"><div class="content">You didn&#x27;t read the link, did you?</div><br/></div></div></div></div><div id="42797087" class="c"><input type="checkbox" id="c-42797087" checked=""/><div class="controls bullet"><span class="by">umpalumpaaa</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42796999">parent</a><span>|</span><a href="#42797261">prev</a><span>|</span><a href="#42797172">next</a><span>|</span><label class="collapse" for="c-42797087">[-]</label><label class="expand" for="c-42797087">[4 more]</label></div><br/><div class="children"><div class="content">I am not sure making things safe by default is a good idea. This always comes with a cost. Thats also the reason why basic data types (array, dictionaries, etc) are generally not thread safe… because its usually not needed or handled on a much higher level.<p>Its a different story for languages&#x2F;environments that are supposed to be safe by default and where you have language features that ensure safety (actors, optionals etc) but not for something like libc which has a standard it has to conform to and like 100 years of history.</div><br/><div id="42797226" class="c"><input type="checkbox" id="c-42797226" checked=""/><div class="controls bullet"><span class="by">dgrunwald</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797087">parent</a><span>|</span><a href="#42797545">next</a><span>|</span><label class="collapse" for="c-42797226">[-]</label><label class="expand" for="c-42797226">[2 more]</label></div><br/><div class="children"><div class="content">The problem with `setenv` is that people expect one process to have one set of environment variables, which is shared across multiple languages running in that process. This implies every language must let its environment variables be managed by a central language-independent library -- and on POSIX systems, that&#x27;s libc.
So if libc refuses to provide thread-safety, that impacts not just C, but all possible languages (except for those that cannot call into C-libraries; as those don&#x27;t need to bother synchronizing the environment with libc).</div><br/><div id="42797995" class="c"><input type="checkbox" id="c-42797995" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797226">parent</a><span>|</span><a href="#42797545">next</a><span>|</span><label class="collapse" for="c-42797995">[-]</label><label class="expand" for="c-42797995">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just that &quot;libc refuses to provide thread-safety&quot; ... the POSIX standard specifies that these functions are non-reentrant.</div><br/></div></div></div></div><div id="42797545" class="c"><input type="checkbox" id="c-42797545" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797087">parent</a><span>|</span><a href="#42797226">prev</a><span>|</span><a href="#42797172">next</a><span>|</span><label class="collapse" for="c-42797545">[-]</label><label class="expand" for="c-42797545">[1 more]</label></div><br/><div class="children"><div class="content">In some cases this is true. In the case of setting and getting env vars, it is not. There is no comceivable reason for making a process that spends any significant portion of its runtime calling setenv() or getenv(). Even if those calls were a thousand times slower than today, it would still be a non-issue.</div><br/></div></div></div></div></div></div><div id="42797172" class="c"><input type="checkbox" id="c-42797172" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42796948">parent</a><span>|</span><a href="#42796999">prev</a><span>|</span><a href="#42797057">next</a><span>|</span><label class="collapse" for="c-42797172">[-]</label><label class="expand" for="c-42797172">[7 more]</label></div><br/><div class="children"><div class="content">&gt; A non-reentrant function cannot be thread safe.<p>Actually, a non-reentrant function can be thread-safe. A common example of such a function in libc being malloc().</div><br/><div id="42797396" class="c"><input type="checkbox" id="c-42797396" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797172">parent</a><span>|</span><a href="#42797414">next</a><span>|</span><label class="collapse" for="c-42797396">[-]</label><label class="expand" for="c-42797396">[5 more]</label></div><br/><div class="children"><div class="content">By definition, a &quot;reentrant function&quot; is a function that may be invoked even when it has not returned yet from a previous invocation.<p>So a non-reentrant function is a function that may not be invoked again between a previous invocation and returning from that invocation.<p>When a function may be invoked from different threads, then it is certain that sometimes it will be invoked by a thread before returning from a previous invocation from a different thread.<p>Therefore any function that may be invoked from different threads <i>must</i> be reentrant. Otherwise the behavior of the program is unpredictable. Reentrant functions may be required even in single-thread programs, when they may be invoked recursively, or they may be invoked by signal handlers.<p>An implementation of &quot;malloc&quot; may be reentrant or it may be non-reentrant.<p>Old &quot;malloc&quot; implementations were usually non-reentrant because they used global variables for managing the heap. Such &quot;malloc&quot; functions could not be used in multi-threaded programs.<p>Modern &quot;malloc&quot; implementations are reentrant, either by using only thread-local storage or by using shared global variables to which some method for concurrent access is implemented, e.g. with mutual exclusion.</div><br/><div id="42801979" class="c"><input type="checkbox" id="c-42801979" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797396">parent</a><span>|</span><a href="#42797481">next</a><span>|</span><label class="collapse" for="c-42801979">[-]</label><label class="expand" for="c-42801979">[1 more]</label></div><br/><div class="children"><div class="content">No, this is confused. Reentrancy (&quot;reentrant-safe&quot;, or the somewhat related POSIX definition of async-signal-safe which I&#x27;ll use here) and thread safety are not the same thing.<p>An async-signal-safe function is thread-safe, but a thread-safe function may or may not be async-signal-safe.<p>For instance, if a function uses mutual exclusion (say, posix_mutex_lock() and friends) to ensure thread-safety it won&#x27;t be async-signal-safe, because if the function is invoked via a signal handler it may deadlock. Which is why many common libc functions like malloc and stdio are not required to be async-signal-safe.</div><br/></div></div><div id="42797481" class="c"><input type="checkbox" id="c-42797481" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797396">parent</a><span>|</span><a href="#42801979">prev</a><span>|</span><a href="#42797414">next</a><span>|</span><label class="collapse" for="c-42797481">[-]</label><label class="expand" for="c-42797481">[3 more]</label></div><br/><div class="children"><div class="content">Who has a signal safe malloc?</div><br/><div id="42798459" class="c"><input type="checkbox" id="c-42798459" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797481">parent</a><span>|</span><a href="#42797414">next</a><span>|</span><label class="collapse" for="c-42798459">[-]</label><label class="expand" for="c-42798459">[2 more]</label></div><br/><div class="children"><div class="content">POSIX does not require malloc to be signal safe.<p>Therefore I do not think that anyone has bothered to implement a signal-safe malloc, as this is likely to be complicated.<p>Allocating memory in a signal handler makes no sense in a well designed program, so not being allowed to use malloc and related functions is not a problem.</div><br/><div id="42800388" class="c"><input type="checkbox" id="c-42800388" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42798459">parent</a><span>|</span><a href="#42797414">next</a><span>|</span><label class="collapse" for="c-42800388">[-]</label><label class="expand" for="c-42800388">[1 more]</label></div><br/><div class="children"><div class="content">So it sounds like malloc would be an example of a function which is thread safe but not reentrant.</div><br/></div></div></div></div></div></div></div></div><div id="42797414" class="c"><input type="checkbox" id="c-42797414" checked=""/><div class="controls bullet"><span class="by">sumtechguy</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42797172">parent</a><span>|</span><a href="#42797396">prev</a><span>|</span><a href="#42797057">next</a><span>|</span><label class="collapse" for="c-42797414">[-]</label><label class="expand" for="c-42797414">[1 more]</label></div><br/><div class="children"><div class="content">I could be wrong but isnt that because each thread has its own heap?</div><br/></div></div></div></div></div></div><div id="42796940" class="c"><input type="checkbox" id="c-42796940" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#42796873">parent</a><span>|</span><a href="#42796948">prev</a><span>|</span><a href="#42797761">next</a><span>|</span><label class="collapse" for="c-42796940">[-]</label><label class="expand" for="c-42796940">[2 more]</label></div><br/><div class="children"><div class="content">Funny enough, the Rust wrapper `std::env::set_var` does have a big warning <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;env&#x2F;fn.set_var.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;env&#x2F;fn.set_var.html</a></div><br/><div id="42799776" class="c"><input type="checkbox" id="c-42799776" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#42796873">root</a><span>|</span><a href="#42796940">parent</a><span>|</span><a href="#42797761">next</a><span>|</span><label class="collapse" for="c-42799776">[-]</label><label class="expand" for="c-42799776">[1 more]</label></div><br/><div class="children"><div class="content">Looks like that Safety section was added in 1.76.0. It&#x27;ll be an even bigger warning in the future since it&#x27;s now going to be unsafe in Rust 2024</div><br/></div></div></div></div></div></div><div id="42797761" class="c"><input type="checkbox" id="c-42797761" checked=""/><div class="controls bullet"><span class="by">hauntsaninja</span><span>|</span><a href="#42796873">prev</a><span>|</span><a href="#42796883">next</a><span>|</span><label class="collapse" for="c-42797761">[-]</label><label class="expand" for="c-42797761">[2 more]</label></div><br/><div class="children"><div class="content">We had so many of these issues that we ended up LD_PRELOAD-ing patch getenv &#x2F; setenv &#x2F; putenv</div><br/><div id="42797851" class="c"><input type="checkbox" id="c-42797851" checked=""/><div class="controls bullet"><span class="by">msully4321</span><span>|</span><a href="#42797761">parent</a><span>|</span><a href="#42796883">next</a><span>|</span><label class="collapse" for="c-42797851">[-]</label><label class="expand" for="c-42797851">[1 more]</label></div><br/><div class="children"><div class="content">With a fixed implementation that leaks environments (like the one that just landed in glibc)?</div><br/></div></div></div></div><div id="42796883" class="c"><input type="checkbox" id="c-42796883" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42797761">prev</a><span>|</span><a href="#42797860">next</a><span>|</span><label class="collapse" for="c-42796883">[-]</label><label class="expand" for="c-42796883">[27 more]</label></div><br/><div class="children"><div class="content">Mutable global state is evil. Friends don’t let friends use mutable global state.<p>I hate envvars. It’s “the Linux way”. I avoid them like the plague. A++ strong recommend.<p>libc is terrible. The world needs to move on.</div><br/><div id="42796934" class="c"><input type="checkbox" id="c-42796934" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#42796883">parent</a><span>|</span><a href="#42796978">next</a><span>|</span><label class="collapse" for="c-42796934">[-]</label><label class="expand" for="c-42796934">[9 more]</label></div><br/><div class="children"><div class="content">Env vars are good if you treat them as read-only within the process</div><br/><div id="42796965" class="c"><input type="checkbox" id="c-42796965" checked=""/><div class="controls bullet"><span class="by">msully4321</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796934">parent</a><span>|</span><a href="#42798775">next</a><span>|</span><label class="collapse" for="c-42796965">[-]</label><label class="expand" for="c-42796965">[7 more]</label></div><br/><div class="children"><div class="content">Yeah, setenv should probably just not exist, and environment variables should be only set when spawning new processes.</div><br/><div id="42797438" class="c"><input type="checkbox" id="c-42797438" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796965">parent</a><span>|</span><a href="#42798775">next</a><span>|</span><label class="collapse" for="c-42797438">[-]</label><label class="expand" for="c-42797438">[6 more]</label></div><br/><div class="children"><div class="content">The problem is that applications sometimes need to set environment variables which will be read by libraries in the same process. This is safe to do during startup, but at no later times.<p>Ideally all libraries which use environment variables should have APIs allowing you to override the env variables without calling setenv(), but that isn&#x27;t always the case.</div><br/><div id="42797701" class="c"><input type="checkbox" id="c-42797701" checked=""/><div class="controls bullet"><span class="by">docandrew</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797438">parent</a><span>|</span><a href="#42797852">next</a><span>|</span><label class="collapse" for="c-42797701">[-]</label><label class="expand" for="c-42797701">[1 more]</label></div><br/><div class="children"><div class="content">I’d argue that libraries shouldn’t read environment variables at all. They’re passed on the initial program stack and look just like stack vars, so the issue here is essentially the same as taking the address of a stack variable and misusing it.<p>Just like a library wouldn’t try to use argv directly, it shouldn’t use envp either (even if done via getenv&#x2F;setenv)</div><br/></div></div><div id="42797852" class="c"><input type="checkbox" id="c-42797852" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797438">parent</a><span>|</span><a href="#42797701">prev</a><span>|</span><a href="#42797486">next</a><span>|</span><label class="collapse" for="c-42797852">[-]</label><label class="expand" for="c-42797852">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The problem is that applications sometimes need to set environment variables which will be read by libraries in the same process. This is safe to do during startup, but at no later times.</i><p>No, the problem is that libraries try to do this at all.  Libraries should just have those APIs you mention, and not touch env vars, period.  If you, the library user, <i>really</i> want to use env vars for those settings, you can getenv() them yourself and pass them to the library&#x27;s APIs.<p>Obviously we can&#x27;t change history; there are libraries that do this anyway.  But we should encourage library authors to (in the future) pretend that env vars don&#x27;t exist.</div><br/><div id="42798758" class="c"><input type="checkbox" id="c-42798758" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797852">parent</a><span>|</span><a href="#42798017">next</a><span>|</span><label class="collapse" for="c-42798758">[-]</label><label class="expand" for="c-42798758">[1 more]</label></div><br/><div class="children"><div class="content">The place where it makes sense for a library to read environment variables is where the program is not written to use that <i>specific</i> library. For example, I can link a program whose author has never heard of TCMalloc against TCMalloc rather than the system malloc, and then configure TCMalloc via environment variables. This does not require modifying a single line of code, while manually forwarding configuration onto the allocator would. Another common example is configuring sanitizers. Not having to do anything other than pass another command-line switch to the compiler is one of the things that makes them really painless to use.<p>I do think you&#x27;d be hard-pressed to find a situation where a program calling setenv() to configure a library <i>actually</i> makes sense. It&#x27;s a pretty strong sign that someone made a bad decision. People will, however, make mistakes in API design.</div><br/></div></div><div id="42798017" class="c"><input type="checkbox" id="c-42798017" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797852">parent</a><span>|</span><a href="#42798758">prev</a><span>|</span><a href="#42797486">next</a><span>|</span><label class="collapse" for="c-42798017">[-]</label><label class="expand" for="c-42798017">[1 more]</label></div><br/><div class="children"><div class="content">If env vars don&#x27;t exist, that makes it much harder (and more likely impossible) for users to modify library&#x2F;application behavior at run time.<p>I agree with you that it would be much better if, when libA needs to set behavio Foo in libB, it called libB:setBehavior (Foo) rather than setenv (&quot;LibBehavior&quot;, &quot;Foo&quot;)<p>But let&#x27;s not throw the baby out with the bathwater.</div><br/></div></div></div></div><div id="42797486" class="c"><input type="checkbox" id="c-42797486" checked=""/><div class="controls bullet"><span class="by">msully4321</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797438">parent</a><span>|</span><a href="#42797852">prev</a><span>|</span><a href="#42798775">next</a><span>|</span><label class="collapse" for="c-42797486">[-]</label><label class="expand" for="c-42797486">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the cows have certainly gotten out already.</div><br/></div></div></div></div></div></div><div id="42798775" class="c"><input type="checkbox" id="c-42798775" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796934">parent</a><span>|</span><a href="#42796965">prev</a><span>|</span><a href="#42796978">next</a><span>|</span><label class="collapse" for="c-42798775">[-]</label><label class="expand" for="c-42798775">[1 more]</label></div><br/><div class="children"><div class="content">I’ll take a config file over an envvar 100% of the time.</div><br/></div></div></div></div><div id="42796978" class="c"><input type="checkbox" id="c-42796978" checked=""/><div class="controls bullet"><span class="by">maep</span><span>|</span><a href="#42796883">parent</a><span>|</span><a href="#42796934">prev</a><span>|</span><a href="#42797074">next</a><span>|</span><label class="collapse" for="c-42796978">[-]</label><label class="expand" for="c-42796978">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Mutable global state is evil. Friends don’t let friends use mutable global state.<p>Throw away your CPU and RAM then.</div><br/><div id="42799234" class="c"><input type="checkbox" id="c-42799234" checked=""/><div class="controls bullet"><span class="by">incrudible</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796978">parent</a><span>|</span><a href="#42797014">next</a><span>|</span><label class="collapse" for="c-42799234">[-]</label><label class="expand" for="c-42799234">[1 more]</label></div><br/><div class="children"><div class="content">Your CPU has an MMU in order to (among other things) let the OS prevent mutable global state.</div><br/></div></div><div id="42797014" class="c"><input type="checkbox" id="c-42797014" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796978">parent</a><span>|</span><a href="#42799234">prev</a><span>|</span><a href="#42798490">next</a><span>|</span><label class="collapse" for="c-42797014">[-]</label><label class="expand" for="c-42797014">[4 more]</label></div><br/><div class="children"><div class="content">And disks. And the cloud. Or basically, you know, computers.</div><br/><div id="42797189" class="c"><input type="checkbox" id="c-42797189" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797014">parent</a><span>|</span><a href="#42797148">next</a><span>|</span><label class="collapse" for="c-42797189">[-]</label><label class="expand" for="c-42797189">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t threaten me with a good time.</div><br/></div></div><div id="42797148" class="c"><input type="checkbox" id="c-42797148" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797014">parent</a><span>|</span><a href="#42797189">prev</a><span>|</span><a href="#42799254">next</a><span>|</span><label class="collapse" for="c-42797148">[-]</label><label class="expand" for="c-42797148">[1 more]</label></div><br/><div class="children"><div class="content">The universe, you mean.</div><br/></div></div><div id="42799254" class="c"><input type="checkbox" id="c-42799254" checked=""/><div class="controls bullet"><span class="by">incrudible</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797014">parent</a><span>|</span><a href="#42797148">prev</a><span>|</span><a href="#42798490">next</a><span>|</span><label class="collapse" for="c-42799254">[-]</label><label class="expand" for="c-42799254">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, the cloud where we all happily share compute resources without any restrictions to avoid stomping on each others toes.</div><br/></div></div></div></div><div id="42798490" class="c"><input type="checkbox" id="c-42798490" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796978">parent</a><span>|</span><a href="#42797014">prev</a><span>|</span><a href="#42797074">next</a><span>|</span><label class="collapse" for="c-42798490">[-]</label><label class="expand" for="c-42798490">[1 more]</label></div><br/><div class="children"><div class="content">I can not possibly roll my eyes hard enough.<p>Go ahead and write lots of mutable global statics. But when your program crashes randomly and you need my help to debug and it is, once again, a global mutable then you have to perform a walk of shame.</div><br/></div></div></div></div><div id="42797074" class="c"><input type="checkbox" id="c-42797074" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#42796883">parent</a><span>|</span><a href="#42796978">prev</a><span>|</span><a href="#42796955">next</a><span>|</span><label class="collapse" for="c-42797074">[-]</label><label class="expand" for="c-42797074">[4 more]</label></div><br/><div class="children"><div class="content">what do you suggest as alternative?<p>the problem is not linux, not mutable global state or resources and not libc.<p>the problem is not getting time at work to do things properly. like spotting this in GDB before the issue hit, because your boss gave you time to tirelessly debug and reverse your code and anything it touches....<p>there is too much money in halfbaked code. sad but true.</div><br/><div id="42797716" class="c"><input type="checkbox" id="c-42797716" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797074">parent</a><span>|</span><a href="#42796955">next</a><span>|</span><label class="collapse" for="c-42797716">[-]</label><label class="expand" for="c-42797716">[3 more]</label></div><br/><div class="children"><div class="content">It definitely is the current libc. That one&#x27;s proven by systems which do not have the same problem. Then the next layer problem is trying to pretend we can get everyone to pay attention and avoid bugs in code instead of forcing interfaces and implementations where those bugs are not possible.</div><br/><div id="42801937" class="c"><input type="checkbox" id="c-42801937" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797716">parent</a><span>|</span><a href="#42796955">next</a><span>|</span><label class="collapse" for="c-42801937">[-]</label><label class="expand" for="c-42801937">[2 more]</label></div><br/><div class="children"><div class="content">just because someone makes a window doesn&#x27;t mean you gotta jump out of it. there are good and bad uses for things, and the bad ones should be avoided lest one hurt themselves?</div><br/><div id="42801997" class="c"><input type="checkbox" id="c-42801997" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42801937">parent</a><span>|</span><a href="#42796955">next</a><span>|</span><label class="collapse" for="c-42801997">[-]</label><label class="expand" for="c-42801997">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Death_of_Garry_Hoy" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Death_of_Garry_Hoy</a> people will assume more safety than necessary. You don&#x27;t have to jump, but someone will try. We can accept that fact or watch people fail over and over on the same issue. It&#x27;s better to help everyone avoid the problem in the first place.<p>For some reason lots of programmers will behave like the comment section on an accident video. &quot;I would notice that earlier&quot;, &quot;I&#x27;d avoid that&quot;, &quot;I can react faster&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="42796955" class="c"><input type="checkbox" id="c-42796955" checked=""/><div class="controls bullet"><span class="by">glouwbug</span><span>|</span><a href="#42796883">parent</a><span>|</span><a href="#42797074">prev</a><span>|</span><a href="#42797228">next</a><span>|</span><label class="collapse" for="c-42796955">[-]</label><label class="expand" for="c-42796955">[3 more]</label></div><br/><div class="children"><div class="content">libc moved the world into the Information Age</div><br/><div id="42797177" class="c"><input type="checkbox" id="c-42797177" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42796955">parent</a><span>|</span><a href="#42797228">next</a><span>|</span><label class="collapse" for="c-42797177">[-]</label><label class="expand" for="c-42797177">[2 more]</label></div><br/><div class="children"><div class="content">In the same way that <i>Yersinia pestis</i> moved the world into the Renaissance?</div><br/><div id="42797238" class="c"><input type="checkbox" id="c-42797238" checked=""/><div class="controls bullet"><span class="by">glouwbug</span><span>|</span><a href="#42796883">root</a><span>|</span><a href="#42797177">parent</a><span>|</span><a href="#42797228">next</a><span>|</span><label class="collapse" for="c-42797238">[-]</label><label class="expand" for="c-42797238">[1 more]</label></div><br/><div class="children"><div class="content">Yes, neither were memory or thread safe</div><br/></div></div></div></div></div></div><div id="42796936" class="c"><input type="checkbox" id="c-42796936" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#42796883">parent</a><span>|</span><a href="#42797228">prev</a><span>|</span><a href="#42797047">next</a><span>|</span><label class="collapse" for="c-42796936">[-]</label><label class="expand" for="c-42796936">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s your preferred alternative?</div><br/></div></div><div id="42797047" class="c"><input type="checkbox" id="c-42797047" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#42796883">parent</a><span>|</span><a href="#42796936">prev</a><span>|</span><a href="#42797860">next</a><span>|</span><label class="collapse" for="c-42797047">[-]</label><label class="expand" for="c-42797047">[1 more]</label></div><br/><div class="children"><div class="content">Don’t use a mouse or a monitor then.</div><br/></div></div></div></div><div id="42797860" class="c"><input type="checkbox" id="c-42797860" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#42796883">prev</a><span>|</span><a href="#42797609">next</a><span>|</span><label class="collapse" for="c-42797860">[-]</label><label class="expand" for="c-42797860">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you just didn&#x27;t know it&#x27;s not threadsafe. This is common knowledge in the C and C++ world.</div><br/></div></div><div id="42797959" class="c"><input type="checkbox" id="c-42797959" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42797609">prev</a><span>|</span><a href="#42797114">next</a><span>|</span><label class="collapse" for="c-42797959">[-]</label><label class="expand" for="c-42797959">[2 more]</label></div><br/><div class="children"><div class="content">A function which sets global process state is not thread safe? Why, I&#x27;m shocked; shocked and chagrined.<p>But really, I don&#x27;t understand why a sensitive security-related library would implicitly use an unsafe function like setenv().</div><br/><div id="42798223" class="c"><input type="checkbox" id="c-42798223" checked=""/><div class="controls bullet"><span class="by">bangaladore</span><span>|</span><a href="#42797959">parent</a><span>|</span><a href="#42797114">next</a><span>|</span><label class="collapse" for="c-42798223">[-]</label><label class="expand" for="c-42798223">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A function which sets global process state is not thread safe? Why, I&#x27;m shocked; shocked and chagrined.<p>This is a oversimplification. Windows has essentially the exact same API and it works just fine in multithreaded contexts.<p>The issue here is unix allows the underlying pointer to be accessed, bypassing any possible thread-safe APIs.</div><br/></div></div></div></div><div id="42797114" class="c"><input type="checkbox" id="c-42797114" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#42797959">prev</a><span>|</span><a href="#42797400">next</a><span>|</span><label class="collapse" for="c-42797114">[-]</label><label class="expand" for="c-42797114">[2 more]</label></div><br/><div class="children"><div class="content">The whole point of Rust is memory safety, not thread safety...</div><br/><div id="42797170" class="c"><input type="checkbox" id="c-42797170" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42797114">parent</a><span>|</span><a href="#42797400">next</a><span>|</span><label class="collapse" for="c-42797170">[-]</label><label class="expand" for="c-42797170">[1 more]</label></div><br/><div class="children"><div class="content">Rust literally bakes data race safety into the language. While it does not resolve general race conditions, thread safety issues which cause memory unsafety (which an UAF or dangling pointer would be) are very much within its remit.</div><br/></div></div></div></div><div id="42797400" class="c"><input type="checkbox" id="c-42797400" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#42797114">prev</a><span>|</span><label class="collapse" for="c-42797400">[-]</label><label class="expand" for="c-42797400">[3 more]</label></div><br/><div class="children"><div class="content">It is weird that I got this right before Rust did.<p>Because I use structured concurrency, I can make it so every thread has its own environment <i>stack</i>. To add to a new environment, I duplicate it, add the new variable, and push the new enviroment on the stack.<p>Then I can use code blocks to delimit where that stack should be popped. [1]<p>This is all perfectly safe, no `unsafe` required, and can even extend to other things like the current working directory. [2]<p>IMO, Rust got this wrong 10 years ago when Leakpocalypse broke. [3]<p>[1]: <a href="https:&#x2F;&#x2F;git.yzena.com&#x2F;Yzena&#x2F;Yc&#x2F;src&#x2F;branch&#x2F;master&#x2F;tests&#x2F;yao&#x2F;env.yao" rel="nofollow">https:&#x2F;&#x2F;git.yzena.com&#x2F;Yzena&#x2F;Yc&#x2F;src&#x2F;branch&#x2F;master&#x2F;tests&#x2F;yao&#x2F;e...</a><p>[2]: <a href="https:&#x2F;&#x2F;gavinhoward.com&#x2F;2024&#x2F;09&#x2F;rewriting-rust-a-response&#x2F;#global-context" rel="nofollow">https:&#x2F;&#x2F;gavinhoward.com&#x2F;2024&#x2F;09&#x2F;rewriting-rust-a-response&#x2F;#g...</a><p>[3]: <a href="https:&#x2F;&#x2F;gavinhoward.com&#x2F;2024&#x2F;05&#x2F;what-rust-got-wrong-on-formal-verification&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gavinhoward.com&#x2F;2024&#x2F;05&#x2F;what-rust-got-wrong-on-forma...</a></div><br/><div id="42797434" class="c"><input type="checkbox" id="c-42797434" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42797400">parent</a><span>|</span><label class="collapse" for="c-42797434">[-]</label><label class="expand" for="c-42797434">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t _really_ a Rust problem. Rust is a victim of POSIX.<p>If you have 1) C FFI interop in Yao, there&#x27;s still a chance you might have two C libraries cause a crash without your code even being involved.</div><br/><div id="42798916" class="c"><input type="checkbox" id="c-42798916" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#42797400">root</a><span>|</span><a href="#42797434">parent</a><span>|</span><label class="collapse" for="c-42798916">[-]</label><label class="expand" for="c-42798916">[1 more]</label></div><br/><div class="children"><div class="content">Except if there is dymanic linking, I can use that to inject my own setenv and getenv, just like people inject jemalloc or other malloc alternatives.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>