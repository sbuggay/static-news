<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694163660314" as="style"/><link rel="stylesheet" href="styles.css?v=1694163660314"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model (2010)</a> <span class="domain">(<a href="https://nvie.com">nvie.com</a>)</span></div><div class="subtext"><span>saaspirant</span> | <span>52 comments</span></div><br/><div><div id="37428726" class="c"><input type="checkbox" id="c-37428726" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37430788">next</a><span>|</span><label class="collapse" for="c-37428726">[-]</label><label class="expand" for="c-37428726">[23 more]</label></div><br/><div class="children"><div class="content">This was terrible at the time and it remains terrible now. <i>Extremely</i> few teams need this level of complexity and some parts of it – like the redundant long-lived develop branch – are pointless safety blankets. It seems to have only caught on because a lot of people felt adrift when it comes to Git and this was written far too authoritatively for what it is. I’ve seen so many small teams tie themselves up wasting time working for Git Flow that I think this might actually be the worst thing to ever happen to version control. I’m glad the author has mostly walked it back, but unfortunately the damage has been done.<p>If you are putting a team together and haven’t picked a Git workflow and are unsure what to do, start with something simple like trunk-based development and add complexity if and when you encounter problems that justify it.<p><a href="https:&#x2F;&#x2F;trunkbaseddevelopment.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;trunkbaseddevelopment.com</a><p>Previous discussions:<p>Please stop recommending Gitflow: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22485489">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22485489</a><p>GitFlow considered harmful: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9744059">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9744059</a><p>The problem with Git Flow: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23622071">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23622071</a></div><br/><div id="37429707" class="c"><input type="checkbox" id="c-37429707" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37430478">next</a><span>|</span><label class="collapse" for="c-37429707">[-]</label><label class="expand" for="c-37429707">[2 more]</label></div><br/><div class="children"><div class="content">Strong agreement with everything you&#x27;ve said here. I can&#x27;t say enough good things about trunk-based development. I started managing a team with 15+ developers. They had used long-lived branches, with a develop, a staging, and a release branch. Not using TBD, &quot;releases&quot; were a huge ceremony and extremely inertial. Velocity went way, way up when we adopted TBD. It took some time for people to become comfortable with the new approach, not because it&#x27;s complex, but precisely because they had grown so used to unnecessary complexity and had to unlearn many things.</div><br/><div id="37430991" class="c"><input type="checkbox" id="c-37430991" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37429707">parent</a><span>|</span><a href="#37430478">next</a><span>|</span><label class="collapse" for="c-37430991">[-]</label><label class="expand" for="c-37430991">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Strong agreement with everything you&#x27;ve said here. I can&#x27;t say enough good things about trunk-based development.<p>I don&#x27;t agree. Git flow is just trunk development applied to release-centric, non-web projects,  after you learned very basic lessons on how to put together a production-ready release. There is absolutely no good reason to advocate in favour of ignorance and force you to reinvent the wheel on a process that exists for decades.<p>Failing to understand these needs only set you up to learn hard lessons the hard way at a time you least want to learn them: when Product is pushing you to release the damn thing and asking you why you are incapable of just posting a bugfix over a previous release.</div><br/></div></div></div></div><div id="37430478" class="c"><input type="checkbox" id="c-37430478" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37429707">prev</a><span>|</span><a href="#37428852">next</a><span>|</span><label class="collapse" for="c-37430478">[-]</label><label class="expand" for="c-37430478">[5 more]</label></div><br/><div class="children"><div class="content">Personally, I simply don&#x27;t want to see any merge-commits, ever. Merges are hard to follow and may include conflict resolutions which are hard to show (if they show up at all).<p>Sure, &quot;merging&quot; is an amazing feature. But I am not working on projects with an organizational complexity like the Linux kernel. Short-lived &amp; rebased branches so that code gets integrated into main fast. Conflict resolution is never postponed nor shared. Versioning&#x2F;release&#x2F;deploy&#x2F;rollback is dealt with mostly outside of git, or with tags-on-main at most.</div><br/><div id="37430881" class="c"><input type="checkbox" id="c-37430881" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37430478">parent</a><span>|</span><a href="#37431057">next</a><span>|</span><label class="collapse" for="c-37430881">[-]</label><label class="expand" for="c-37430881">[3 more]</label></div><br/><div class="children"><div class="content">Merge commits also break regression finding, since if you checkout a commit that was part of a merge, you land  in a tree state reflecting what tree at this commit looked like before the merge, which is a state the master branch has never been in. It often breaks things which work both before and after the merge commit. So you can never find with certainty the regression point at commit level, other than locally linearising this merge into a series of cherry picks. It’s just awful.</div><br/><div id="37431028" class="c"><input type="checkbox" id="c-37431028" checked=""/><div class="controls bullet"><span class="by">dbt00</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37430881">parent</a><span>|</span><a href="#37431057">next</a><span>|</span><label class="collapse" for="c-37431028">[-]</label><label class="expand" for="c-37431028">[2 more]</label></div><br/><div class="children"><div class="content">--first-parent, and both with git bisect and many other things, is your friend here.</div><br/><div id="37431045" class="c"><input type="checkbox" id="c-37431045" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37431028">parent</a><span>|</span><a href="#37431057">next</a><span>|</span><label class="collapse" for="c-37431045">[-]</label><label class="expand" for="c-37431045">[1 more]</label></div><br/><div class="children"><div class="content">That doesn’t fix the issue I described. It leads to a situation where you can say that a merge introduced a regression, but you don’t know which of the merged commits did, because it skips over them all. So it’s not commit-level.</div><br/></div></div></div></div></div></div><div id="37431057" class="c"><input type="checkbox" id="c-37431057" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37430478">parent</a><span>|</span><a href="#37430881">prev</a><span>|</span><a href="#37428852">next</a><span>|</span><label class="collapse" for="c-37431057">[-]</label><label class="expand" for="c-37431057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Versioning&#x2F;release&#x2F;deploy&#x2F;rollback is dealt with mostly outside of git, or with tags-on-main at most.<p>This is simply outright wrong. Releases are not a tagged versions of a development branch. There is stuff that belongs in releases but should not be present ever in develop branches at all, and vice-versa.<p>Once you need specific changes going into a release, you need branches.<p>Also, you should not block development work on the development branch just because you need to push a release.<p>Also, if you find a bug in a release candidate, you fix that bug alone. You do not add other changes just because someone committed them to the development branch.<p>Cutting a release means picking up an unstable version and work your way up to make it stable. This means freezing the introduction of additional random features, and commit bugfixes only. Tagging does not allow that.</div><br/></div></div></div></div><div id="37428852" class="c"><input type="checkbox" id="c-37428852" checked=""/><div class="controls bullet"><span class="by">hsn915</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37430478">prev</a><span>|</span><a href="#37428908">next</a><span>|</span><label class="collapse" for="c-37428852">[-]</label><label class="expand" for="c-37428852">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems to have only caught on because a lot of people felt adrift when it comes to Git and this was written far too authoritatively for what it is.<p>My hypothesis is the design of the page and the images played a big role in convincing people this is &quot;legit&quot;.</div><br/></div></div><div id="37428908" class="c"><input type="checkbox" id="c-37428908" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37428852">prev</a><span>|</span><a href="#37429242">next</a><span>|</span><label class="collapse" for="c-37428908">[-]</label><label class="expand" for="c-37428908">[5 more]</label></div><br/><div class="children"><div class="content">It seemed much beloved by teams who’d used SVN or other source controls that had incremental version numbers, switched to Git, and strongly wanted to implement their old workflow in Git.<p>I worked at a shop that tried really hard to pretend that it was possible to strictly order commits (“What if dev A writes commit 1234, then dev B writes commit 5678 and pushes it, then dev A pushes 1234. Which came first?” “The earlier one!” “What does ‘earlier’ mean here?” “Why can’t you just do it!”) and they thought Git Flow was the greatest thing ever.<p>Put another way, it was popular among the same people who write every language as though it were their favorite. Have Python but they only have Java experience? All their Python looks like Java! Well, they thought Git Flow was spiffy, too.</div><br/><div id="37429078" class="c"><input type="checkbox" id="c-37429078" checked=""/><div class="controls bullet"><span class="by">capn_duck</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37428908">parent</a><span>|</span><a href="#37431207">next</a><span>|</span><label class="collapse" for="c-37429078">[-]</label><label class="expand" for="c-37429078">[2 more]</label></div><br/><div class="children"><div class="content">This is the second comment I&#x27;ve seen in this thread comparing &quot;Gitflow&quot; to what was typical in SVN. Having been there when SVN was in vogue, I can assure you that our process looked nothing like Gitflow. SVN encourages what we now refer to as &quot;trunk based development&quot;. The default branch was even called &quot;trunk&quot;.</div><br/><div id="37429334" class="c"><input type="checkbox" id="c-37429334" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37429078">parent</a><span>|</span><a href="#37431207">next</a><span>|</span><label class="collapse" for="c-37429334">[-]</label><label class="expand" for="c-37429334">[1 more]</label></div><br/><div class="children"><div class="content">I was used to SVN too, and you’re right about the trunk bit. I’m mainly talking about SVN’s nicely linear revision numbers and how it was unambiguous that r23 came after r22. That’s the part that GitFlow adherents wanted to simulate.</div><br/></div></div></div></div><div id="37431207" class="c"><input type="checkbox" id="c-37431207" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37428908">parent</a><span>|</span><a href="#37429078">prev</a><span>|</span><a href="#37430161">next</a><span>|</span><label class="collapse" for="c-37431207">[-]</label><label class="expand" for="c-37431207">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it was possible to strictly order commits<p>This holds no relevance at all. Nothing in gitflow calls for strictly ordered commits. Just because there is a branch represented with semver that does not mean that the revision control system is involved in versioning.</div><br/></div></div><div id="37430161" class="c"><input type="checkbox" id="c-37430161" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37428908">parent</a><span>|</span><a href="#37431207">prev</a><span>|</span><a href="#37429242">next</a><span>|</span><label class="collapse" for="c-37430161">[-]</label><label class="expand" for="c-37430161">[1 more]</label></div><br/><div class="children"><div class="content">I used SVN extensively since the early 2000&#x27;s, and while I still don&#x27;t like git (at least for projects that also involve non-coders), I liked git-flow even less (and as the sibling poster said, SVN encouraged a much simpler trunk-based development model).<p>My impression was that git-flow was pitched by people who didn&#x27;t have much experience with other version control systems and were also new to git.</div><br/></div></div></div></div><div id="37429242" class="c"><input type="checkbox" id="c-37429242" checked=""/><div class="controls bullet"><span class="by">atomicnature</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37428908">prev</a><span>|</span><a href="#37430871">next</a><span>|</span><label class="collapse" for="c-37429242">[-]</label><label class="expand" for="c-37429242">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. In my teams, I&#x27;ve always implemented a simple model, which hasn&#x27;t failed me. Main branch triggers deployment, and name rest of the branches &lt;author&gt;&#x2F;&lt;feature&gt;. Just works.<p>In some cases, an extra caveat to the above was triggering deployment&#x2F;build in Main, only when the tag&#x2F;version number gets incremented.</div><br/></div></div><div id="37430871" class="c"><input type="checkbox" id="c-37430871" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37429242">prev</a><span>|</span><a href="#37429040">next</a><span>|</span><label class="collapse" for="c-37430871">[-]</label><label class="expand" for="c-37430871">[2 more]</label></div><br/><div class="children"><div class="content">Agreed, but your linked article on trunk-based development does include this strange idea:<p>&gt; the core requirement of Continuous Integration that all team members commit to trunk at least once every 24 hours</div><br/><div id="37430910" class="c"><input type="checkbox" id="c-37430910" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37430871">parent</a><span>|</span><a href="#37429040">next</a><span>|</span><label class="collapse" for="c-37430910">[-]</label><label class="expand" for="c-37430910">[1 more]</label></div><br/><div class="children"><div class="content">That’s been the case since day one; it’s not something trunk-based development invented.<p>Remember, continuous integration is literally that – people integrate their changes continuously. It’s not just “we run Jenkins”.<p><a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;continuousIntegration.html#EveryoneCommitsToTheMainlineEveryDay" rel="nofollow noreferrer">https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;continuousIntegration.html...</a></div><br/></div></div></div></div><div id="37429040" class="c"><input type="checkbox" id="c-37429040" checked=""/><div class="controls bullet"><span class="by">albert_e</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37430871">prev</a><span>|</span><a href="#37430333">next</a><span>|</span><label class="collapse" for="c-37429040">[-]</label><label class="expand" for="c-37429040">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this insight. This is useful advice for those who are re&#x2F;discovering some of these practices for newer projects and would benefit from adopting a more saner approach.<p>I see a reference to GitHub Flow which seems to make sense: <a href="https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;get-started&#x2F;quickstart&#x2F;github-flow" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;get-started&#x2F;quickstart&#x2F;github-flo...</a></div><br/></div></div><div id="37430333" class="c"><input type="checkbox" id="c-37430333" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37429040">prev</a><span>|</span><a href="#37428735">next</a><span>|</span><label class="collapse" for="c-37430333">[-]</label><label class="expand" for="c-37430333">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Seeing this again with the added “successful” attribute made me think: “successful at what?”<p>At influencing developers? Yes. At helping developers? I want to say no.<p>I don’t want to blame the author for this catching on, but I don’t think it was helpful that it did.</div><br/></div></div><div id="37428735" class="c"><input type="checkbox" id="c-37428735" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37430333">prev</a><span>|</span><a href="#37430742">next</a><span>|</span><label class="collapse" for="c-37428735">[-]</label><label class="expand" for="c-37428735">[1 more]</label></div><br/><div class="children"><div class="content">Thank you.<p>This blog post is responsible for more toil than anything else I can think of.<p>&gt; It seems to have only caught on because a lot of people felt adrift when it comes to Git and this was written far too authoritatively for what it is.<p>I think &quot;Git Flow&quot; was successful for the same reason that Javascript &quot;Standard&quot; linter was: misleading branding that lends credibility.</div><br/></div></div><div id="37430742" class="c"><input type="checkbox" id="c-37430742" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37428735">prev</a><span>|</span><a href="#37429759">next</a><span>|</span><label class="collapse" for="c-37430742">[-]</label><label class="expand" for="c-37430742">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This was terrible at the time and it remains terrible now.<p>I strongly disagree. This branching model didn&#x27;t came out of the blue. This branching model is a direct mapping between regular run-of-the-mill release processes for applications intended to be delivered and installed by the general public, and how Git implements branches.<p>Let&#x27;s actually look at the git flow workflow branching model and see what it does. There are:<p>* a develop branch. Where commits&#x2F;pull requests are continuously integrated as part of the everyday development work. Is this complex? No.<p>* feature branches. Where developers present their changes as part of pull requests prior to merging them onto the development branch. Is this complex? No. Software development platforms such as github and gitlab even support creating them automatically as part of the normal ticket creation workflow, and even support triggering dedicated pipeline workflows.<p>* Release branches. These are used to pick a specific state of the development branch to prepare it to be releasable to the public, and prevent it from receiving additional features. This involves things like bumping up version numbers, update changelogs and docs, flip up feature flags, and more importantly trigger pipeline workflows to generate production-ready installers. These installers are then subjected to build verification tests, manual tests, deployment tests, and Product managers use them to evaluate what users will receive. Is this complex? No.<p>* bugfix branches. What happens if a bug is found in a release candidate? You push a fix, of course. You push it directly into the release branch and afterwards create another release candidate version to be subjected to BVTs and manual tests. You also need to fix the bug in the development branch. Is this complex? No.<p>* The prod branch. Once your release candidates are finalized, you cut a release. This can mean tweaking version numbers and docs again, but the goal is to persist the exact version that was released to the public. Also, if an important bug is found in production, such as a crash, you&#x27;re going to have to prepare a patch release shipping only a fix for it. This branch is used to fork a new release candidate, tweak stuff like version numbers, changelogs, docs, get the fix in, run regression tests, have Product Managers double-check that the bug is fixed, and release a new version. Is this complex? No.<p>I followed this exact branching model for all non-web projects I worked on for a timespan that goes over a decade.<p>Here&#x27;s the fun part: I followed it before I even knew this page existed. Why? Because this is what you eventually end up converging to if you are a professional doing professional work with a professional team to deliver a production ready version of a product built by professionals.<p>Why is that? Because real world requirements emerge. You learn the hard way that you cannot pause continuous integration when preparing a release, and thus you need release candidate branches to not block other developers. You learn the hard way that you need to do additional work over a release candidate in order to get it ready for production. You learn the hard way that after you release a version of your app then eventually you will need to scramble to release another version to ship a critical bugfix. You learn the hard way that you need to work in multiple releases in parallel. You learn the hard way that sometimes a release is scrapped because the Product Manager changes their mind and instead of shipping a hotfix we ship additional features. Etc etc etc.<p>Now, there are things in this branching model that might not be ideal. For example, merging release branches back into a single prod&#x2F;master&#x2F;mainline branch is convenient as a way to ensure the stable release is front and center in a git repo, but it doesn&#x27;t work if you need to have multiple releases for multiple versions. In the last few years the teams I worked on ended up not merging release branches anywhere, and just kept them dangling out of the development branch. This helps manage the complexity of a major release bump where you need to continue maintaining both the new and old release versions, and possibly even ship minor&#x2F;patch versions of the old release.</div><br/></div></div><div id="37429759" class="c"><input type="checkbox" id="c-37429759" checked=""/><div class="controls bullet"><span class="by">gonzo41</span><span>|</span><a href="#37428726">parent</a><span>|</span><a href="#37430742">prev</a><span>|</span><a href="#37430788">next</a><span>|</span><label class="collapse" for="c-37429759">[-]</label><label class="expand" for="c-37429759">[2 more]</label></div><br/><div class="children"><div class="content">The article suggests *GitHub Flow* not Git-Flow. Which from reading does just seem like trunk based development.<p>After a while, I think we all just end up there from exhaustion.</div><br/><div id="37430265" class="c"><input type="checkbox" id="c-37430265" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#37428726">root</a><span>|</span><a href="#37429759">parent</a><span>|</span><a href="#37430788">next</a><span>|</span><label class="collapse" for="c-37430265">[-]</label><label class="expand" for="c-37430265">[1 more]</label></div><br/><div class="children"><div class="content">The article is the original git-flow article. It suggests GitHub Flow for projects with continuous deployment and no version numbers in a 2020 addendum, but otherwise, it&#x27;s the overengineered git-flow.</div><br/></div></div></div></div></div></div><div id="37430788" class="c"><input type="checkbox" id="c-37430788" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#37428726">prev</a><span>|</span><a href="#37431081">next</a><span>|</span><label class="collapse" for="c-37430788">[-]</label><label class="expand" for="c-37430788">[1 more]</label></div><br/><div class="children"><div class="content">There is no one-size fits all branching model for git. But they are extremely important. Some people swear by gitflow and others don&#x27;t. 
I wish there was a <i>set</i> of tried ones though, with some simple questions to help decide. I can think of two questions:<p>First ask whether you need to be supporting multiple versions in production or not. A simple web service with single tenant model would do OK with just one maintained version. There is always a &quot;current&quot; latest production release and whether that branch it&#x27;s built from is called &quot;production&quot; or &quot;master&quot; doesn&#x27;t really matter. You have a stable main, and then unstable branches are develop and feature.
But if you must support multiple production versions longer term, as for any software that is installed by clients (Desktop, self hosted web backends, ...) then of course having a single &quot;production&quot; branch no longer flies. You need to have long lived release branches, that might even diverge and never merge back to any long term development branch. These could be called &quot;release&#x2F;v1.0&quot; or similar. And obviously if you have designated release branches then there is no point having an unstable develop branch - you can just make main your unstable develop branch.<p>Second after deciding between maintaining 1 or N active versions in production is deciding whether you can do continuous deployment. If you can deploy to production multiple times per day, that might affect your branching model. If on the other hand you have fixed waterfall-like deadlines because e.g. you only have a chance to get regulatory review for the new version (if you make security critical software e.g. medical, automotive) twice per year then that might have an effect on your branching model, you&#x27;d then use your release&#x2F;v1.0 branches before the release as a long term stabilization before the release.</div><br/></div></div><div id="37431081" class="c"><input type="checkbox" id="c-37431081" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#37430788">prev</a><span>|</span><a href="#37429576">next</a><span>|</span><label class="collapse" for="c-37431081">[-]</label><label class="expand" for="c-37431081">[1 more]</label></div><br/><div class="children"><div class="content">I think one major shortcoming of git-flow is that semantically commits belong to a specific branch, but it conflicts with git&#x27;s branching model, which are just moving labels.<p>Git flow ironically probably works better on mercurial branches, where changesets (commits) belong to specific branches permanently.<p>Also I think it&#x27;s hard to implement complicated git branching strategies when most developers like to navigate the history by visualizing the graph of commits by GUI tools or just by git log. It doesn&#x27;t help that git log doesn&#x27;t implement a powerful query language over commits, but most developers are not aware of the simpler but powerful queries either that are available.</div><br/></div></div><div id="37429576" class="c"><input type="checkbox" id="c-37429576" checked=""/><div class="controls bullet"><span class="by">Yodel0914</span><span>|</span><a href="#37431081">prev</a><span>|</span><a href="#37429030">next</a><span>|</span><label class="collapse" for="c-37429576">[-]</label><label class="expand" for="c-37429576">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the hate for this at all. I wonder if it&#x27;s because I&#x27;ve mostly mostly in corporate environments, with dedicated test&#x2F;QA teams.<p>One of the big advantages of either fixed dev&#x2F;test&#x2F;prod branches or dev&#x2F;versionN branches is that the testers get a stable codebase to test against, which can have bugfixes applied without bringing everything else from dev along for the ride. It&#x27;s virtually impossible to regression test a release if it has constant changes being made to it.</div><br/><div id="37431011" class="c"><input type="checkbox" id="c-37431011" checked=""/><div class="controls bullet"><span class="by">sanitycheck</span><span>|</span><a href="#37429576">parent</a><span>|</span><a href="#37430289">next</a><span>|</span><label class="collapse" for="c-37431011">[-]</label><label class="expand" for="c-37431011">[1 more]</label></div><br/><div class="children"><div class="content">I used to use something like git flow, but the long-lived dev branch proved to be a real problem for QA because it changes constantly which led to tester confusion and wasted time.<p>What I do now is keep master always release-ready and work is done in feature branches. The feature branches each automatially get their own (numerous) builds for testing, and internal QA is done against those. QA can be held up for weeks or months, so doing it this way keeps unfinished code out of releases and allows the business to change their priorities to shelve stuff that&#x27;s suddenly not as urgent as it was last week - and also to suddenly do new surprise submissions&#x2F;releases the day after randomly promising them in a phone call.<p>If two feature branches have overlapping changes and it&#x27;s taking people months to approve them then the merges are annoying, but usually sorted out in the lifetime of a single cup of tea.<p>Release builds are done off tags, usually on master. Hotfixes to old releases (when there&#x27;s no QA resource available to test a big update) can be done in a low-impact way by branching (&quot;zombie&#x2F;customer-platform-x.y.z&quot;) off the tag for that release, cherry-picking onto it and adding a release tag.<p>Customers get demo&#x2F;QA builds, also done off tags so when they get around to reporting an issue weeks later we know what code they&#x27;ve been looking at.<p>(For context, the software is a client-side white label thing with different builds targeting multiple platforms - so there&#x27;s a customer&#x2F;platform matrix meaning many different releases, and almost every release has to be a manual submission each involving different 3rd-party QA which takes 2-6 weeks (best case, with no issues found). Config + content is dynamic, no two customers use the same subset of functionality. Keeping everything current is impossible.)</div><br/></div></div><div id="37430289" class="c"><input type="checkbox" id="c-37430289" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#37429576">parent</a><span>|</span><a href="#37431011">prev</a><span>|</span><a href="#37430321">next</a><span>|</span><label class="collapse" for="c-37430289">[-]</label><label class="expand" for="c-37430289">[3 more]</label></div><br/><div class="children"><div class="content">Regression should be covered mostly by automated tests. We have a huge suite of e2e tests covering everything from frontend, through microservices, dbs, kafkas, mobile apps, pipelines.<p>Over 8 years we added so much features that we would need to triple the QA teams every year, this simply doesn&#x27;t scale well.<p>We have dedicated QA people in full stack teams, they test features that are going to get merged and help with writing the automated tests. Trunk based development.<p>We used to do it like you say. Non-stop issues with releases dragging, series of hotfixes, teams being torn between new features and firefighting something that should have been released already. Our velocity, quality and predictibility is soooo much better now.</div><br/><div id="37430786" class="c"><input type="checkbox" id="c-37430786" checked=""/><div class="controls bullet"><span class="by">onion2k</span><span>|</span><a href="#37429576">root</a><span>|</span><a href="#37430289">parent</a><span>|</span><a href="#37430999">next</a><span>|</span><label class="collapse" for="c-37430786">[-]</label><label class="expand" for="c-37430786">[1 more]</label></div><br/><div class="children"><div class="content"><i>We have a huge suite of e2e tests covering everything from frontend, through microservices, dbs, kafkas, mobile apps, pipelines.</i><p>It&#x27;s easy to advocate for a process that isn&#x27;t git flow (eg TBD) if you have that. The problem is how to get from an environment <i>without</i> extensive tests to an environment with those tests safely without constantly having to fight fires everywhere. Saying something like &quot;your git process is bad&quot; or &quot;feature branches are a waste of time&quot; requires context. If you&#x27;re in a situation where you <i>need</i> the &#x27;safety blanket&#x27; of branches because everything is effectively untested then you have to fix that problem first.<p>TBD works well if you have a robust, trustworthy environment. If you don&#x27;t then it&#x27;d make things <i>even worse</i>.</div><br/></div></div><div id="37430999" class="c"><input type="checkbox" id="c-37430999" checked=""/><div class="controls bullet"><span class="by">Yodel0914</span><span>|</span><a href="#37429576">root</a><span>|</span><a href="#37430289">parent</a><span>|</span><a href="#37430786">prev</a><span>|</span><a href="#37430321">next</a><span>|</span><label class="collapse" for="c-37430999">[-]</label><label class="expand" for="c-37430999">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s quite interesting. We also have a huge suite of API integration tests, plus a lot of UI automation which does most of our regression. But we also have clients who are high profile enough that it&#x27;s simply not feasible to push changes out without a human sanity-checking them first.<p>We also have a fairly complex, interconnected domain and the system reflects that. I love the idea of having manual QA on feature branches being enough, but I&#x27;m not sure it&#x27;s feasible for us.</div><br/></div></div></div></div><div id="37430321" class="c"><input type="checkbox" id="c-37430321" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#37429576">parent</a><span>|</span><a href="#37430289">prev</a><span>|</span><a href="#37429712">next</a><span>|</span><label class="collapse" for="c-37430321">[-]</label><label class="expand" for="c-37430321">[1 more]</label></div><br/><div class="children"><div class="content">Separate release branches do make a lot of sense and allow making only bugfixes to already released versions. The develop&#x2F;master separation suggested by git-flow has no benefits and only makes a bigger mess. Trunk-based development also involves release branches, but is much easier: <a href="https:&#x2F;&#x2F;trunkbaseddevelopment.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;trunkbaseddevelopment.com&#x2F;</a></div><br/></div></div><div id="37429712" class="c"><input type="checkbox" id="c-37429712" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#37429576">parent</a><span>|</span><a href="#37430321">prev</a><span>|</span><a href="#37429030">next</a><span>|</span><label class="collapse" for="c-37429712">[-]</label><label class="expand" for="c-37429712">[1 more]</label></div><br/><div class="children"><div class="content">Actually it was a poor qa&#x2F;test relationship that destroyed git flow for me.  Because the presence of release branches made the PO confident they could release any fixes or &quot;emergency features&quot; they wanted, they kept the QA team on the release branches while the dev team kept cranking through the backlog until it came time to validate like a year&#x27;s worth of work and QA+PO threw up their hands and said it was too much to validate.<p>So now I don&#x27;t merge a feature unless I know it&#x27;s allowed to be released.  If it&#x27;s not releasable, it&#x27;s not merging.</div><br/></div></div></div></div><div id="37429030" class="c"><input type="checkbox" id="c-37429030" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#37429576">prev</a><span>|</span><a href="#37429095">next</a><span>|</span><label class="collapse" for="c-37429030">[-]</label><label class="expand" for="c-37429030">[1 more]</label></div><br/><div class="children"><div class="content">After multiple attempts to use Git Flow at multiple different companies, I&#x27;m certain that it is untenable. No matter how competent your team is, Git Flow demands a level of consistency with such a complex process that empirically, your team will always end up making mistakes, trashing the commit tree, and calling the team lead in to move the commits around to where they were supposed to go.<p>We&#x27;ve had much more luck with trunk-based development, as other commenters have mentioned.</div><br/></div></div><div id="37429095" class="c"><input type="checkbox" id="c-37429095" checked=""/><div class="controls bullet"><span class="by">smashed</span><span>|</span><a href="#37429030">prev</a><span>|</span><a href="#37428990">next</a><span>|</span><label class="collapse" for="c-37429095">[-]</label><label class="expand" for="c-37429095">[2 more]</label></div><br/><div class="children"><div class="content">I know there&#x27;s been a lot of gripes against git-flow but I think one of the reasons it had such an impact is that project maintainers&#x2F;leaders are looking for some sort of &quot;workflow&quot; or process around git.<p>As a project grows, you want some process around how to name branches, when to use tags, how to handle merges, from which branch to base your work on, etc.<p>Git flow gave all the answers in an authoritative way. You could just say to junior team members&#x2F;contributors that the project uses git-flow and send them the link to the doc.<p>I applied git-flow to my projects but simplified the process, eventually abandoning almost all its principles. It did give me a starting point to think about what we really needed, what is important and how to communicate it with a team.<p>One particular process I am quite fond of is to use the develop branch as a free for all integration&#x2F;testing branch with automated deployment to a test (dev) environment with absolutely no guarantee of working whatsoever to any stake holder.  This allows devs to demo their work, collaborate and spot conflicts early, without being slowed down by fear of breaking something or waiting for a code review.<p>Unlike git-flow, that develop branch is a dead end. It does not get merged to master or any other branch ever and gets force-push (reset) when things go wrong.<p>Feature branches eventually get proper code review, their history can be cleaned up and eventually merged (or dropped) via a proper pull request.</div><br/><div id="37430072" class="c"><input type="checkbox" id="c-37430072" checked=""/><div class="controls bullet"><span class="by">jasongi</span><span>|</span><a href="#37429095">parent</a><span>|</span><a href="#37428990">next</a><span>|</span><label class="collapse" for="c-37430072">[-]</label><label class="expand" for="c-37430072">[1 more]</label></div><br/><div class="children"><div class="content">The concept of a “develop” branch here isn’t really a requirement to have a branch deploy. Most CI I’ve used let you pick any tag&#x2F;commit&#x2F;branch to run on - so nothing stopping you just deploying your feature branch without having a special branch for it.<p>The trunk (i.e main&#x2F;master) is the only branch you should really be collaborating on, otherwise you’re going to end up with painful, long-live branches with that are messy to integrate.</div><br/></div></div></div></div><div id="37428990" class="c"><input type="checkbox" id="c-37428990" checked=""/><div class="controls bullet"><span class="by">TheGRS</span><span>|</span><a href="#37429095">prev</a><span>|</span><a href="#37429197">next</a><span>|</span><label class="collapse" for="c-37428990">[-]</label><label class="expand" for="c-37428990">[3 more]</label></div><br/><div class="children"><div class="content">Highly recommend going with trunk-based deployment these days. I think git flow just made sense to people from older VCS&#x27;s and didn&#x27;t know they could just not have a prod branch. With a medium or larger team that wants to release early and often, git flow will actually slow you all down, I don&#x27;t recommend it.</div><br/><div id="37429047" class="c"><input type="checkbox" id="c-37429047" checked=""/><div class="controls bullet"><span class="by">capn_duck</span><span>|</span><a href="#37428990">parent</a><span>|</span><a href="#37429197">next</a><span>|</span><label class="collapse" for="c-37429047">[-]</label><label class="expand" for="c-37429047">[2 more]</label></div><br/><div class="children"><div class="content">My experience was that older VCS&#x27;s (SVN in my case) leaned in heavily to the trunk based paradigm. I don&#x27;t know what you&#x27;re talking about with prod branches. The default branch in SVN was called - trunk.</div><br/><div id="37429188" class="c"><input type="checkbox" id="c-37429188" checked=""/><div class="controls bullet"><span class="by">fineIllregister</span><span>|</span><a href="#37428990">root</a><span>|</span><a href="#37429047">parent</a><span>|</span><a href="#37429197">next</a><span>|</span><label class="collapse" for="c-37429188">[-]</label><label class="expand" for="c-37429188">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s what they&#x27;re saying. People think that when they switch to git they have to use prod and other, newer workflows. But you can keep doing the same thing you did in SVN, using trunk primarily in git, with easier merges.</div><br/></div></div></div></div></div></div><div id="37429197" class="c"><input type="checkbox" id="c-37429197" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#37428990">prev</a><span>|</span><a href="#37430750">next</a><span>|</span><label class="collapse" for="c-37429197">[-]</label><label class="expand" for="c-37429197">[1 more]</label></div><br/><div class="children"><div class="content">We came pretty close to using this at one point. Thankfully I was able to propose a similar sounding but very different approach called &quot;GitHub flow&quot; (aka normal development). Quite a bullet dodge imo.</div><br/></div></div><div id="37430750" class="c"><input type="checkbox" id="c-37430750" checked=""/><div class="controls bullet"><span class="by">lostfocus</span><span>|</span><a href="#37429197">prev</a><span>|</span><a href="#37430513">next</a><span>|</span><label class="collapse" for="c-37430750">[-]</label><label class="expand" for="c-37430750">[1 more]</label></div><br/><div class="children"><div class="content">I honestly don&#x27;t understand the hate that Git Flow gets these days. We&#x27;ve been using it in our little client-services agency (projects of 2 to 8 developers with infrequent deployments) for the last couple of years and never had any problem with it. It&#x27;s easy to explain and automate and mostly just works without getting in the way.</div><br/></div></div><div id="37430513" class="c"><input type="checkbox" id="c-37430513" checked=""/><div class="controls bullet"><span class="by">Phelinofist</span><span>|</span><a href="#37430750">prev</a><span>|</span><a href="#37429239">next</a><span>|</span><label class="collapse" for="c-37430513">[-]</label><label class="expand" for="c-37430513">[1 more]</label></div><br/><div class="children"><div class="content">In our branching model we have a develop branch for $current and version specific branches for LTS (2-4). Both get fed via PRs. Pretty okay complexity-wise.<p>Our issue is more with the JIRA issue logistics to get everything into the correct branches. We can&#x27;t use multiple fix versions per issue, so we clone the issue for all branches that it is needed for. That is cumbersome and also error prone since sometimes creating clones gets forgotten. Also the tickets can diverge if people are careless and comment one of the clone issues instead of the main one.</div><br/></div></div><div id="37429239" class="c"><input type="checkbox" id="c-37429239" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37430513">prev</a><span>|</span><a href="#37428729">next</a><span>|</span><label class="collapse" for="c-37429239">[-]</label><label class="expand" for="c-37429239">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>A note of reflection after 10 years of “A successful Git branching model”</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22496724">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22496724</a> - March 2020 (100 comments)<p><i>A successful Git branching model (2010)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15376841">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15376841</a> - Oct 2017 (120 comments)<p><i>What is wrong with “A successful Git branching model”?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11190310">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11190310</a> - Feb 2016 (120 comments)<p><i>What is wrong with “A successful Git branching model”?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11059485">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11059485</a> - Feb 2016 (4 comments)<p><i>A simple git branching model</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6456193">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6456193</a> - Sept 2013 (157 comments)<p><i>A successful Git branching model (2010)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6437983">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6437983</a> - Sept 2013 (15 comments)<p><i>A successful Git branching model</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5928979">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5928979</a> - June 2013 (3 comments)<p><i>A successful Git branching model</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1966820">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1966820</a> - Dec 2010 (11 comments)<p><i>Tutorial: How to use Git in a team development environment</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1826279">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1826279</a> - Oct 2010 (26 comments)<p><i>A successful Git branching model</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1063198">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1063198</a> - Jan 2010 (44 comments)</div><br/></div></div><div id="37428729" class="c"><input type="checkbox" id="c-37428729" checked=""/><div class="controls bullet"><span class="by">capn_duck</span><span>|</span><a href="#37429239">prev</a><span>|</span><a href="#37428751">next</a><span>|</span><label class="collapse" for="c-37428729">[-]</label><label class="expand" for="c-37428729">[1 more]</label></div><br/><div class="children"><div class="content">This one blog post resulted in so much pain for so many. I&#x27;m glad it has been addended, but the damage was done.<p>For the record, I don&#x27;t think it&#x27;s the authors fault.</div><br/></div></div><div id="37428751" class="c"><input type="checkbox" id="c-37428751" checked=""/><div class="controls bullet"><span class="by">logN_2</span><span>|</span><a href="#37428729">prev</a><span>|</span><a href="#37431100">next</a><span>|</span><label class="collapse" for="c-37428751">[-]</label><label class="expand" for="c-37428751">[1 more]</label></div><br/><div class="children"><div class="content">Many jr devs cite this model to me. Every new hire after on boarding looking to make an impact cites this. And I’m getting tired of explaining why this model is not always a good idea.<p>And we’re building apps that have multiple versions in the wild.</div><br/></div></div><div id="37431100" class="c"><input type="checkbox" id="c-37431100" checked=""/><div class="controls bullet"><span class="by">bbsimonbb</span><span>|</span><a href="#37428751">prev</a><span>|</span><a href="#37430440">next</a><span>|</span><label class="collapse" for="c-37431100">[-]</label><label class="expand" for="c-37431100">[1 more]</label></div><br/><div class="children"><div class="content">Tis a little disconcerting to see master called master. I thought we&#x27;d all changed that?</div><br/></div></div><div id="37430440" class="c"><input type="checkbox" id="c-37430440" checked=""/><div class="controls bullet"><span class="by">davewood</span><span>|</span><a href="#37431100">prev</a><span>|</span><a href="#37429207">next</a><span>|</span><label class="collapse" for="c-37430440">[-]</label><label class="expand" for="c-37430440">[1 more]</label></div><br/><div class="children"><div class="content">I am using git flow for a project that is around since 2012, I&#x27;m pretty much the single developer on said project. gitflow it keeps everything very orderly and I had no issues. Whenever I make a release I have to look up the workflow but that only takes a minute.<p>Due to the criticism that I came across over the past few years it&#x27;s unlikely I would use it for a new project though.</div><br/></div></div><div id="37429207" class="c"><input type="checkbox" id="c-37429207" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#37430440">prev</a><span>|</span><a href="#37428932">next</a><span>|</span><label class="collapse" for="c-37429207">[-]</label><label class="expand" for="c-37429207">[3 more]</label></div><br/><div class="children"><div class="content">Upvoted for the retraction.<p>Personal opinions on best practices:<p>- If you have multiple components to an application, whether frontend&#x2F;backend or microservices, put them all in the same repository by default. It is so easy to split them apart again after your team grows to the point where it matters, but before that point you will need to carefully coordinate merging PRs to multiple repos, and sometimes rolling them back, and it is so easy with a small application monorepo. You can just store git’s “tree hashes” in s3 and check if they changed when deciding whether to build and deploy, it&#x27;s not hard.<p>- If you&#x27;re versioning, a version.txt file at the root of the versioned content is your friend. Have a {subproject_name}-v1.6 branch, you tag commits on that branch v1.6.3-rc1, rc2, ... automatically with CI&#x2F;CD, until you tag one RC as a release when you release it.<p>- Everyone merges into main, you cherrypick from main out to those other branches. This keeps the graph clean. When you cut v1.6 you decide whether your next project on main is v2.0 or v1.7.<p>- Feature toggles are your friend, see Rod Hilton’s Three-Flow[1]. Just clean them up when you release!<p>- with about a day&#x27;s involvement in CI&#x2F;CD, the `main` branch can have a `k8s&#x2F;` folder with subfolders for each of your deployment environments. You want to deploy something to prod, just update a version number in `k8s&#x2F;prod` and merge to `main`. This is even a little simpler than Three-Flow and you can very precisely answer when something was shipped.<p>- folders `rfc&#x2F;` and `docs&#x2F;` and `issues&#x2F;` at the root level would be amazing but I can&#x27;t get any company to actually do them. One stop shopping! Why not? Once `main` is authoritatively central, it becomes a great place for these things, just the same as you use it for `k8s&#x2F;prod` and `k8s&#x2F;dev`.<p>- The underlying point of all of this is to make sure that everybody merges their code every day. If that would break something, put the breakage behind a feature toggle. If it&#x27;s a config file that doesn&#x27;t have feature toggles, run the C preprocessor on it or invest in Dhall or some other hack. Do whatever you can so that there is one big conversation happening, and everybody is collaborating. The worst is when you have these huge merge conflicts, the second worst is when you have been doing a lot of work and someone else sweeps it all away before you merge, &quot;oh I didn&#x27;t see you working on that so I solved it in this inferior hacky way.&quot;<p>1. <a href="https:&#x2F;&#x2F;www.rodhilton.com&#x2F;2017&#x2F;04&#x2F;09&#x2F;a-different-branching-strategy&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rodhilton.com&#x2F;2017&#x2F;04&#x2F;09&#x2F;a-different-branching-s...</a></div><br/><div id="37430241" class="c"><input type="checkbox" id="c-37430241" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#37429207">parent</a><span>|</span><a href="#37428932">next</a><span>|</span><label class="collapse" for="c-37430241">[-]</label><label class="expand" for="c-37430241">[2 more]</label></div><br/><div class="children"><div class="content">This is almost as bad as the original article...<p>Just deploy any change to main... don&#x27;t worry about version numbers unless it matters, even then, just version your spec, not your application. If it does matter, deploy all changes to your QA environment. Once you&#x27;re happy (at the end of a sprint or whatever), tag a commit and release that to production. Need a hotfix? Branch off of your tag, do the thing, and tag that commit and merge it to main.<p>There&#x27;s no reason for &quot;version&quot; files. you can pull your previous version image and compare the SHA hashes for your new version. If they&#x27;re different, then deploy the new one (heh, maybe you got some security patches from the base image). Otherwise, no reason to deploy -- or if you have zero-downtime deployments, just deploy it anyway and don&#x27;t worry about comparing hashes or whether or not something changed.</div><br/><div id="37430864" class="c"><input type="checkbox" id="c-37430864" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#37429207">root</a><span>|</span><a href="#37430241">parent</a><span>|</span><a href="#37428932">next</a><span>|</span><label class="collapse" for="c-37430864">[-]</label><label class="expand" for="c-37430864">[1 more]</label></div><br/><div class="children"><div class="content">Any release I have made whether it&#x27;s to a package manager or an app store or a windows app etc has had to have not just versions for the product but also some times exact versions for individual files (e.g. Traditional Windows installer apps where screwing up the versioning on even one file is a huge mistake that might prevent the next deployment from working toe to downgrade rules.)<p>I have spent a lot more time in my life on thinking about &quot;versioning schemes&quot; than I have &quot;branching schemes&quot; due to this. E.g. windows files and apps don&#x27;t have SemVer, just a 4 component version, so you really need to think long and hard about the kind of thing whether 1.0-dev should be 1.0.10 or 1.0.1 in order to sort properly over your 1.0-final and so on.<p>A world where you can just &quot;deploy an image&quot; and know it just replaces your previous one and in general one where you can deploy yourself, to machines you control sounds nice compared to making packages which should work at 10k different users and follow the whims of various stores, package managers and installer systems.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>