<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692694862317" as="style"/><link rel="stylesheet" href="styles.css?v=1692694862317"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nixos.wiki/wiki/Impermanence">Impermanence</a> <span class="domain">(<a href="https://nixos.wiki">nixos.wiki</a>)</span></div><div class="subtext"><span>anotherhue</span> | <span>22 comments</span></div><br/><div><div id="37220194" class="c"><input type="checkbox" id="c-37220194" checked=""/><div class="controls bullet"><span class="by">blfr</span><span>|</span><a href="#37218773">next</a><span>|</span><label class="collapse" for="c-37220194">[-]</label><label class="expand" for="c-37220194">[1 more]</label></div><br/><div class="children"><div class="content">Back in the HDD days, I had a ~&#x2F;ramdisk directory that was, as the name implies, a ramdisk, so it would get wiped away on every reboot. I would keep files I was working on there, making sure I file them away properly before rebooting.<p>Also, I would sync my firefox profile there so it didn&#x27;t spin up the disk. Amazingly, Arch still has a maintained solution for doing just that!<p><a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Firefox&#x2F;Profile_on_RAM" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Firefox&#x2F;Profile_on_RAM</a></div><br/></div></div><div id="37218773" class="c"><input type="checkbox" id="c-37218773" checked=""/><div class="controls bullet"><span class="by">jbott</span><span>|</span><a href="#37220194">prev</a><span>|</span><a href="#37220028">next</a><span>|</span><label class="collapse" for="c-37218773">[-]</label><label class="expand" for="c-37218773">[11 more]</label></div><br/><div class="children"><div class="content">This is linked in the footer of this page, but Graham Christensen has an excellent blog post “Erase your darlings” [1] that explains why you might want to do this. There is a script floating around on github [2] that does the install automatically, but I needs to be modified slightly to work on newer nixos versions. I have a forked version [3] that I used this morning, but my decisions might not make sense for everyone, but it’s provided as-is for now :)<p>1. <a href="https:&#x2F;&#x2F;grahamc.com&#x2F;blog&#x2F;erase-your-darlings&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;grahamc.com&#x2F;blog&#x2F;erase-your-darlings&#x2F;</a><p>2. <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;mx00s&#x2F;ea2462a3fe6fdaa65692fe7ee824de3e" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;mx00s&#x2F;ea2462a3fe6fdaa65692fe7ee824de...</a><p>3. <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;jbott&#x2F;531b9d555dae7f197f25326ef251f164&#x2F;ae1478e90e7efc8c98f2eb070d02ef3d738a633d" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;jbott&#x2F;531b9d555dae7f197f25326ef251f1...</a></div><br/><div id="37219140" class="c"><input type="checkbox" id="c-37219140" checked=""/><div class="controls bullet"><span class="by">SkyMarshal</span><span>|</span><a href="#37218773">parent</a><span>|</span><a href="#37218917">next</a><span>|</span><label class="collapse" for="c-37219140">[-]</label><label class="expand" for="c-37219140">[4 more]</label></div><br/><div class="children"><div class="content">There’s an even better setup than Erase your Darlings.  Instead of putting &#x2F; on a zfs pool and erasing and rewriting it every reboot, just put tmpfs on &#x2F; instead.<p>With &#x2F; all in memory it automatically gets wiped and recreated every reboot, without needing to actively erase a disk, and thus with much less drive wear (depending on how frequently you reboot).  It’s also faster on some things when loading from RAM instead of the disk.  And it’s overall a cleaner, simpler setup.<p><a href="https:&#x2F;&#x2F;elis.nu&#x2F;blog&#x2F;2020&#x2F;05&#x2F;nixos-tmpfs-as-root&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elis.nu&#x2F;blog&#x2F;2020&#x2F;05&#x2F;nixos-tmpfs-as-root&#x2F;</a><p>You can also put tmpfs on home as well, using Impermanence and Home Manager to persist things like ~&#x2F;.config and whatever other files or folders need to persist between reboots:<p><a href="https:&#x2F;&#x2F;elis.nu&#x2F;blog&#x2F;2020&#x2F;06&#x2F;nixos-tmpfs-as-home&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elis.nu&#x2F;blog&#x2F;2020&#x2F;06&#x2F;nixos-tmpfs-as-home&#x2F;</a><p>tmpfs on &#x2F; is enabled by NixOS’s unique design, in which it keeps the entire system in &#x2F;nix&#x2F;store and then softlinks all the paths into their appropriate place in &#x2F;.  With tmpfs on &#x2F;, NixOS automatically recreates those softlinks in tmpfs on reboot.  Very little setup effort is required to make this work.</div><br/><div id="37219226" class="c"><input type="checkbox" id="c-37219226" checked=""/><div class="controls bullet"><span class="by">jbott</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37219140">parent</a><span>|</span><a href="#37218917">next</a><span>|</span><label class="collapse" for="c-37219226">[-]</label><label class="expand" for="c-37219226">[3 more]</label></div><br/><div class="children"><div class="content">I don’t think the point about disk wear is true. ZFS is a block-based CoW filesystem already, so the “erase” is actually something more like “make a new metadata entry that points to an earlier state snapshot”. Plus, I’d expect normal disk usage (ie. chrome disk cache) probably far outweighs any disk wear you’d get from the (relatively) small size of files you get written into &#x2F;.<p>Unless you’re working on a server with a ton of ram, I also think using tmpfs is more likely to shoot yourself in the foot with excess memory pressure. I don’t know of a way for the kernel to free memory if you write a huge file to the tmpfs partition by mistake, unless you use swap, and then you have the problems that come with that.<p>Tmpfs might be faster though!</div><br/><div id="37219343" class="c"><input type="checkbox" id="c-37219343" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37219226">parent</a><span>|</span><a href="#37218917">next</a><span>|</span><label class="collapse" for="c-37219343">[-]</label><label class="expand" for="c-37219343">[2 more]</label></div><br/><div class="children"><div class="content">&gt; tmpfs is more likely to shoot yourself in the foot with excess memory pressure<p>It defaults to 50% of physical RAM, but you can set the size option to whatever you want: <a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;filesystems&#x2F;tmpfs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;filesystems&#x2F;tmpfs.htm...</a><p>(So yes, something to consider, but totally possible to mitigate)</div><br/><div id="37219545" class="c"><input type="checkbox" id="c-37219545" checked=""/><div class="controls bullet"><span class="by">jbott</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37219343">parent</a><span>|</span><a href="#37218917">next</a><span>|</span><label class="collapse" for="c-37219545">[-]</label><label class="expand" for="c-37219545">[1 more]</label></div><br/><div class="children"><div class="content">TIL!</div><br/></div></div></div></div></div></div></div></div><div id="37218917" class="c"><input type="checkbox" id="c-37218917" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37218773">parent</a><span>|</span><a href="#37219140">prev</a><span>|</span><a href="#37220028">next</a><span>|</span><label class="collapse" for="c-37218917">[-]</label><label class="expand" for="c-37218917">[6 more]</label></div><br/><div class="children"><div class="content">Sounds interesting in theory, but modern development setups are often full with tools, dependencies, IDE indices, intermediate build results, etc. pp. that all may take a very long time to download and build from scratch. Sure, you could try to keep track of all such things and persist them but it&#x27;s going to be a lot of effort trying to figure out where all your tools are dumping their state.</div><br/><div id="37219137" class="c"><input type="checkbox" id="c-37219137" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37218917">parent</a><span>|</span><a href="#37219081">next</a><span>|</span><label class="collapse" for="c-37219137">[-]</label><label class="expand" for="c-37219137">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think of impermanence as a tool for development setups, but rather a tool to improve production security. When a server gets compromised, it&#x27;s common for an attacker to leverage their initial access to set up backdoor access for themselves, e.g. an additional privileged user or privileged service which phones home, so that they&#x27;re no longer reliant on the original vulnerability to gain access again. This is important to ensure that they can launch a more damaging attack at a more opportune time (e.g. at the beginning of a long weekend). Now consider a stateful server which you need to host (e.g. Kubernetes control plane &#x2F; etcd) where you ordinarily cannot practice immutable infrastructure due to the stateful nature of the server. Modules like impermanence allow you to guard against this kind of compromise by simply wiping out everything but the actual state as a result of rebooting. Any privileged users or malicious processes (which, of course, are not part of the system configuration used at boot) get wiped out at every reboot. It&#x27;s not a silver bullet - an attacker could simply releverage the original vulnerability and set up access again - but doing the reboots frequently would force the vulnerability  to be re-exploited each time, making it a pattern of access more likely to be detected in a SIEM.</div><br/></div></div><div id="37219081" class="c"><input type="checkbox" id="c-37219081" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37218917">parent</a><span>|</span><a href="#37219137">prev</a><span>|</span><a href="#37218953">next</a><span>|</span><label class="collapse" for="c-37219081">[-]</label><label class="expand" for="c-37219081">[1 more]</label></div><br/><div class="children"><div class="content">&gt; often full with tools, dependencies, IDE indices, intermediate build results<p>Tools and dependencies go in nix. Indexes and temporary build stuff is just cache, which you can still have (I&#x27;d lean towards regenerating per reboot, but YMMV).<p>&gt; but it&#x27;s going to be a lot of effort trying to figure out where all your tools are dumping their state.<p>Fair. Kind of an indictment of the current state of the ecosystem, but yes.</div><br/></div></div><div id="37218953" class="c"><input type="checkbox" id="c-37218953" checked=""/><div class="controls bullet"><span class="by">n42</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37218917">parent</a><span>|</span><a href="#37219081">prev</a><span>|</span><a href="#37220028">next</a><span>|</span><label class="collapse" for="c-37218953">[-]</label><label class="expand" for="c-37218953">[3 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not so difficult, really. most of this is in your home folder, which is just a separate persistent mount.<p>you can also use impermanence with home-manager if you want<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nix-community&#x2F;impermanence#home-manager">https:&#x2F;&#x2F;github.com&#x2F;nix-community&#x2F;impermanence#home-manager</a></div><br/><div id="37219037" class="c"><input type="checkbox" id="c-37219037" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37218953">parent</a><span>|</span><a href="#37220028">next</a><span>|</span><label class="collapse" for="c-37219037">[-]</label><label class="expand" for="c-37219037">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but then you&#x27;re throwing away the purported benefits (setup is always reproducible) for your entire home folder.<p>It seems like there are two contradictory goals here, each with their own benefits. Impermanence gives you reproducibility, but permanence gives you performance.<p>Maybe the right tradeoff <i>is</i> to just persist the entire home folder and nothing else (or few other things... I&#x27;m not sure I&#x27;d want to always download some programs that are quite huge), but the tradeoff is essentially still there.</div><br/><div id="37219159" class="c"><input type="checkbox" id="c-37219159" checked=""/><div class="controls bullet"><span class="by">n42</span><span>|</span><a href="#37218773">root</a><span>|</span><a href="#37219037">parent</a><span>|</span><a href="#37220028">next</a><span>|</span><label class="collapse" for="c-37219159">[-]</label><label class="expand" for="c-37219159">[1 more]</label></div><br/><div class="children"><div class="content">you&#x27;re talking about three different things: NixOS, Home Manager, and Impermanence. or put another way: reproducible root filesystem, reproducible home folder, automatically reproducing things on boot.<p>if you want a reproducible root filesystem, use NixOS. if you want to reproduce your root filesystem on boot, use NixOS with impermanence.<p>if you want a reproducible home folder, use home manager. if you want to reproduce your home folder on boot, use home manager with impermanence.<p>I only use impermanence on servers. I don&#x27;t think there&#x27;s any point using it on a desktop, or with Home Manager, other than street cred. it just complicates things. I don&#x27;t really even recommend Home Manager for first time NixOS users for the same reason.<p>edit: and I want to address this comment:<p>&gt; I&#x27;m not sure I&#x27;d want to always download some programs that are quite huge<p>this isn&#x27;t how it works; the binaries, as well as the entire initial state of the filesystem, are cached in the Nix cache, a read-only filesystem. you&#x27;re not downloading everything on every boot.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37220028" class="c"><input type="checkbox" id="c-37220028" checked=""/><div class="controls bullet"><span class="by">0x69420</span><span>|</span><a href="#37218773">prev</a><span>|</span><a href="#37219566">next</a><span>|</span><label class="collapse" for="c-37220028">[-]</label><label class="expand" for="c-37220028">[1 more]</label></div><br/><div class="children"><div class="content">one of the nicest things about nixos is illustrated here, where a concrete few tens of lines of code implement a feature that some consider to define an entire genre of distro<p>as a teenager i ran gentoo &amp; passively marvelled in the back of my head that this self-described “meta-distribution” was flexible enough to serve as the basis of chromeos or whatever<p>it&#x27;s no coincidence that “gentoo but Good Actually” was one of the descriptions i heard that convinced me to give nixos a spin, paralleled further by the fact that i unironically ran gentoo prefix on macos in lieu of homebrew&#x2F;macports for a while, and would later go on to run nix-darwin<p>this particular instance of flexibility, though, feeds back nicely into one of the bullet points on the nixos elevator pitch (one little config directory is all you need to care about outside &#x2F;var or &#x2F;home). in a sense, running this setup is putting your money where your mouth is as far as that claim is concerned. and hey whoa would you look at that, it works. neat!</div><br/></div></div><div id="37219566" class="c"><input type="checkbox" id="c-37219566" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37220028">prev</a><span>|</span><a href="#37219355">next</a><span>|</span><label class="collapse" for="c-37219566">[-]</label><label class="expand" for="c-37219566">[1 more]</label></div><br/><div class="children"><div class="content">Even better than having &#x2F; mounted as tmpfs, is having &#x2F; mounted as read-only. So no misconfigured application can write and depend on files on tmpfs (which is stored in RAM), and breaking after reboot.<p>On my Fedora Silverblue, only &#x2F;etc and &#x2F;var are mounted read-write. &#x2F;home is a symlink to &#x2F;var&#x2F;home, &#x2F;root is a symlink to &#x2F;var&#x2F;root.</div><br/></div></div><div id="37219355" class="c"><input type="checkbox" id="c-37219355" checked=""/><div class="controls bullet"><span class="by">acka</span><span>|</span><a href="#37219566">prev</a><span>|</span><a href="#37218788">next</a><span>|</span><label class="collapse" for="c-37219355">[-]</label><label class="expand" for="c-37219355">[4 more]</label></div><br/><div class="children"><div class="content">Regarding the example hardwareconfiguration.nix file: why would anyone want to mount a filesystem on a user&#x27;s home directory as world writable?
Maybe it shows my age, I know that most people don&#x27;t run multi-user systems anymore (I do though).
Even so, I would still be quite worried about some runaway process, perhaps running as user nobody for a reason, messing with my stuff.</div><br/><div id="37219637" class="c"><input type="checkbox" id="c-37219637" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#37219355">parent</a><span>|</span><a href="#37219376">next</a><span>|</span><label class="collapse" for="c-37219637">[-]</label><label class="expand" for="c-37219637">[2 more]</label></div><br/><div class="children"><div class="content">I installed NixOS for the first time a couple of weeks ago. My biggest annoyance has been that most documentation and wiki contributions seem to assume that you&#x27;re running as a single-user system where it&#x27;s OK to sudo as root every time you want to change some user settings.<p>For example, I have still not been able to run Sway as a window manager because I can&#x27;t find how to set it up properly using Home Manager (doing the equivalent with an .xsession and i3 was no problem). The wiki article about it (<a href="https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Sway" rel="nofollow noreferrer">https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Sway</a>) has a lot of configuration at the system level configuration.nix, but most of that is missing from the ostensibly equivalent Home Manager config.<p>It seems like a design error that the Home Manager configuration options do not map 1:1 to the NixOS configuration options for users, and I&#x27;m guessing that error is caused by a lack of interest in properly configured multi-user systems.</div><br/><div id="37220175" class="c"><input type="checkbox" id="c-37220175" checked=""/><div class="controls bullet"><span class="by">e3bc54b2</span><span>|</span><a href="#37219355">root</a><span>|</span><a href="#37219637">parent</a><span>|</span><a href="#37219376">next</a><span>|</span><label class="collapse" for="c-37220175">[-]</label><label class="expand" for="c-37220175">[1 more]</label></div><br/><div class="children"><div class="content">For better or worse, home-manager is developed outside nixpkgs, where rest of NixOS lies.<p>While I cannot speak to the reasons behind the schism, home-manager is better thought of as independent project that builds off of abstractions in nixpkgs, without taking into account what NixOS does.</div><br/></div></div></div></div><div id="37219376" class="c"><input type="checkbox" id="c-37219376" checked=""/><div class="controls bullet"><span class="by">n42</span><span>|</span><a href="#37219355">parent</a><span>|</span><a href="#37219637">prev</a><span>|</span><a href="#37218788">next</a><span>|</span><label class="collapse" for="c-37219376">[-]</label><label class="expand" for="c-37219376">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is common or acceptable; I think it is just a bad user contribution</div><br/></div></div></div></div><div id="37218788" class="c"><input type="checkbox" id="c-37218788" checked=""/><div class="controls bullet"><span class="by">sigmonsays</span><span>|</span><a href="#37219355">prev</a><span>|</span><a href="#37219806">next</a><span>|</span><label class="collapse" for="c-37218788">[-]</label><label class="expand" for="c-37218788">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s really interesting the things that become possible with a system like nix in use. I don&#x27;t think i&#x27;d ever use this but having a configuration persisted make for a interesting platform when reboot restores it to the original state.</div><br/></div></div><div id="37219806" class="c"><input type="checkbox" id="c-37219806" checked=""/><div class="controls bullet"><span class="by">fsflover</span><span>|</span><a href="#37218788">prev</a><span>|</span><a href="#37218896">next</a><span>|</span><label class="collapse" for="c-37219806">[-]</label><label class="expand" for="c-37219806">[1 more]</label></div><br/><div class="children"><div class="content">This is the default behavior on Qubes OS: you run all software in VMs and VMs reset their &#x2F;root partitions upon reboot, <a href="https:&#x2F;&#x2F;www.qubes-os.org&#x2F;doc&#x2F;templates" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.qubes-os.org&#x2F;doc&#x2F;templates</a>.</div><br/></div></div><div id="37218896" class="c"><input type="checkbox" id="c-37218896" checked=""/><div class="controls bullet"><span class="by">analognoise</span><span>|</span><a href="#37219806">prev</a><span>|</span><label class="collapse" for="c-37218896">[-]</label><label class="expand" for="c-37218896">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been getting really into Nix and NixOs recently, and I love when stuff gets put here about it.</div><br/></div></div></div></div></div></div></div></body></html>