<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710406854150" as="style"/><link rel="stylesheet" href="styles.css?v=1710406854150"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">The Myers diff algorithm: part 1</a> <span class="domain">(<a href="https://blog.jcoglan.com">blog.jcoglan.com</a>)</span></div><div class="subtext"><span>jiripospisil</span> | <span>20 comments</span></div><br/><div><div id="39699399" class="c"><input type="checkbox" id="c-39699399" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39700300">next</a><span>|</span><label class="collapse" for="c-39699399">[-]</label><label class="expand" for="c-39699399">[3 more]</label></div><br/><div class="children"><div class="content">Good to see this interesting and very fundamental topic getting attention, and looking forward to the next post, where hopefully the algorithm&#x27;s cleverness will be explored.<p>&gt;It does this by being greedy, that is trying to consume as many lines that are the same before making a change (therefore avoiding the “wrong end” problem), and also by preferring deletions over insertions when given a choice, so that deletions appear first.<p>Not really. The algorithm guarantees to find an alignment&#x2F;diff&#x2F;edit script of minimal length, but whether it prefers the &quot;leftmost&quot; such alignment (&quot;wrong-end&quot; here and in many similar cases in source code) or the &quot;rightmost&quot; (&quot;right-end&quot; here) is not a crucial aspect of how it works. The preference can be switched by reversing both inputs before diffing and then reversing the output afterwards -- but that&#x27;s also the case for any other algorithm that solves this problem optimally.<p>Myers&#x27;s algorithm is greedy in another sense, however: It greedily hunts first for a solution in which no edits are necessary, then solutions in which 1 edit (insertion or deletion) is necessary, then 2, etc., terminating as soon as it finds a solution. Clearly this leads to an optimal (smallest-possible) diff. It also means that it takes time proportional to the <i>amount of difference</i> between the two inputs, which is the clever part: This is what makes it much faster than other approaches in the common case where the two inputs are highly similar.</div><br/><div id="39701649" class="c"><input type="checkbox" id="c-39701649" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#39699399">parent</a><span>|</span><a href="#39700541">next</a><span>|</span><label class="collapse" for="c-39701649">[-]</label><label class="expand" for="c-39701649">[1 more]</label></div><br/><div class="children"><div class="content">But there&#x27;s also the not-so-common (yet still somewhat frequent) case where the inputs are highly different. Myers diff alone would take quadratic time, which in practice is often unacceptable.<p>Real-world implementations often have a limit on the amount of difference (e.g. max(256, sqrt(input size))), and if that&#x27;s exceeded, they switch to heuristics (so the resulting diff is no longer guaranteed to be minimal). This reduces the worst-case runtime from O(N*2) to O(N*1.5).</div><br/></div></div><div id="39700541" class="c"><input type="checkbox" id="c-39700541" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#39699399">parent</a><span>|</span><a href="#39701649">prev</a><span>|</span><a href="#39700300">next</a><span>|</span><label class="collapse" for="c-39700541">[-]</label><label class="expand" for="c-39700541">[1 more]</label></div><br/><div class="children"><div class="content">It was posted in 2017. You can get to part 2 from the link at the bottom.</div><br/></div></div></div></div><div id="39700300" class="c"><input type="checkbox" id="c-39700300" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#39699399">prev</a><span>|</span><a href="#39699013">next</a><span>|</span><label class="collapse" for="c-39700300">[-]</label><label class="expand" for="c-39700300">[2 more]</label></div><br/><div class="children"><div class="content">I used to use diff as an interview question. Implementing a simple algorithm that produces reasonable (not necessarily minimal) diffs is fairly straightforward. If you&#x27;re on track for an ok-to-good score in implementing diff, it leaves just the right amount of time to have a rich discussion about optimizing and other approaches.<p>I feel like this makes the interview a balanced test for programming capability, problem solving and communication. I tested it quite a bit on folks I knew and it had some of the lowest rates of false positives. The &quot;candidates&quot; enjoyed it and felt they solved something much more interesting to them, leaving a memory they carry through their software engineering lives. The ones I tested it on have actually mentioned it in future conversations.<p>Interviews today are too focused on maximum time spent coding. Instead verifying ability to code is quick and we focus more on improving it and use conversation to test more high order bits.</div><br/><div id="39701405" class="c"><input type="checkbox" id="c-39701405" checked=""/><div class="controls bullet"><span class="by">pcl</span><span>|</span><a href="#39700300">parent</a><span>|</span><a href="#39699013">next</a><span>|</span><label class="collapse" for="c-39701405">[-]</label><label class="expand" for="c-39701405">[1 more]</label></div><br/><div class="children"><div class="content">I really like these sorts of interview questions. Something with a spectrum of solutions, interesting algorithms, and room for discussion and exploration.<p>I also like asking interviwees questions that are intentionally missing some amount of detail. Nothing that makes the problem a dead end, but enough vagueness to give people a chance to ask clarifying questions and &#x2F; or make assumptions of their own.</div><br/></div></div></div></div><div id="39699013" class="c"><input type="checkbox" id="c-39699013" checked=""/><div class="controls bullet"><span class="by">teabee89</span><span>|</span><a href="#39700300">prev</a><span>|</span><a href="#39699017">next</a><span>|</span><label class="collapse" for="c-39699013">[-]</label><label class="expand" for="c-39699013">[4 more]</label></div><br/><div class="children"><div class="content">A while ago I discovered the lesser known Tichy diff algorithm that seems to preserve more context and is better suited for big code refactors: <a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;220439403_The_String-to-String_Correction_Problem_With_Block_Moves" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;220439403_The_Strin...</a> via <a href="https:&#x2F;&#x2F;bryanpendleton.blogspot.com&#x2F;2010&#x2F;04&#x2F;more-study-of-diff-walter-tichys-papers.html" rel="nofollow">https:&#x2F;&#x2F;bryanpendleton.blogspot.com&#x2F;2010&#x2F;04&#x2F;more-study-of-di...</a></div><br/><div id="39700164" class="c"><input type="checkbox" id="c-39700164" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#39699013">parent</a><span>|</span><a href="#39699017">next</a><span>|</span><label class="collapse" for="c-39700164">[-]</label><label class="expand" for="c-39700164">[3 more]</label></div><br/><div class="children"><div class="content">Any current implementations?</div><br/><div id="39700610" class="c"><input type="checkbox" id="c-39700610" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39699013">root</a><span>|</span><a href="#39700164">parent</a><span>|</span><a href="#39699017">next</a><span>|</span><label class="collapse" for="c-39700610">[-]</label><label class="expand" for="c-39700610">[2 more]</label></div><br/><div class="children"><div class="content">“Tichy diff” pulls up a helluva lot of C. difficile links on DDG. Sheesh.</div><br/><div id="39701293" class="c"><input type="checkbox" id="c-39701293" checked=""/><div class="controls bullet"><span class="by">kwhitefoot</span><span>|</span><a href="#39699013">root</a><span>|</span><a href="#39700610">parent</a><span>|</span><a href="#39699017">next</a><span>|</span><label class="collapse" for="c-39701293">[-]</label><label class="expand" for="c-39701293">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C. difficile<p>Difficult C? :-)</div><br/></div></div></div></div></div></div></div></div><div id="39699017" class="c"><input type="checkbox" id="c-39699017" checked=""/><div class="controls bullet"><span class="by">Gehinnn</span><span>|</span><a href="#39699013">prev</a><span>|</span><a href="#39700521">next</a><span>|</span><label class="collapse" for="c-39699017">[-]</label><label class="expand" for="c-39699017">[3 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s how we implemented the Myers diff algorithm in VS Code:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;live&#x2F;yWy-0TNVsLg" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;live&#x2F;yWy-0TNVsLg</a><p>On top of the core algorithm, we have many heuristics to show much nicer differs in many cases.</div><br/><div id="39700126" class="c"><input type="checkbox" id="c-39700126" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39699017">parent</a><span>|</span><a href="#39700521">next</a><span>|</span><label class="collapse" for="c-39700126">[-]</label><label class="expand" for="c-39700126">[2 more]</label></div><br/><div class="children"><div class="content">&gt; we have many heuristics to show much nicer diffs in many cases<p>Anything related to the “patience” or “histogram” variations as used e.g. in Git?</div><br/><div id="39700956" class="c"><input type="checkbox" id="c-39700956" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#39699017">root</a><span>|</span><a href="#39700126">parent</a><span>|</span><a href="#39700521">next</a><span>|</span><label class="collapse" for="c-39700956">[-]</label><label class="expand" for="c-39700956">[1 more]</label></div><br/><div class="children"><div class="content">Also interested in this.</div><br/></div></div></div></div></div></div><div id="39700521" class="c"><input type="checkbox" id="c-39700521" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39699017">prev</a><span>|</span><a href="#39699079">next</a><span>|</span><label class="collapse" for="c-39700521">[-]</label><label class="expand" for="c-39700521">[2 more]</label></div><br/><div class="children"><div class="content">Line-based diff algorithms are fine, but what the world really needs is more study into tree-based diffs.<p>This does <i>not</i> require per-language implementations of `diff`, only per-language implementations of text-to-some-well-known-tree.</div><br/><div id="39700962" class="c"><input type="checkbox" id="c-39700962" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#39700521">parent</a><span>|</span><a href="#39699079">next</a><span>|</span><label class="collapse" for="c-39700962">[-]</label><label class="expand" for="c-39700962">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Semantic diff is very useful. Tangentially, I&#x27;m surprised that the terraform diff cannot be displayed in a more user-friendly manner.</div><br/></div></div></div></div><div id="39699079" class="c"><input type="checkbox" id="c-39699079" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#39700521">prev</a><span>|</span><a href="#39699422">next</a><span>|</span><label class="collapse" for="c-39699079">[-]</label><label class="expand" for="c-39699079">[4 more]</label></div><br/><div class="children"><div class="content">Myers also created the BLAST algorithm which was widely used in biology (still is, but it was used more in the past)</div><br/><div id="39699245" class="c"><input type="checkbox" id="c-39699245" checked=""/><div class="controls bullet"><span class="by">slyrus</span><span>|</span><a href="#39699079">parent</a><span>|</span><a href="#39699422">next</a><span>|</span><label class="collapse" for="c-39699245">[-]</label><label class="expand" for="c-39699245">[3 more]</label></div><br/><div class="children"><div class="content">And Gene wrote the assembly tools that did shotgun assembly of the human genome for Celera when most folks (except Jim Kent who wrote the _other_ assembler (used by the public sequencing effort (NIH,Broad,UCSC, etc…)) said it couldn’t be done. IMO, he and Jim Kent deserve a Nobel prize for these efforts.</div><br/><div id="39700109" class="c"><input type="checkbox" id="c-39700109" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#39699079">root</a><span>|</span><a href="#39699245">parent</a><span>|</span><a href="#39699855">next</a><span>|</span><label class="collapse" for="c-39700109">[-]</label><label class="expand" for="c-39700109">[1 more]</label></div><br/><div class="children"><div class="content">True.  Celera had a large TruCluster, machines with 8 (16?) processors, 64GB and inter-node cluster networking for a truly shared filesystem.  Shotgun at the time required very large memory many-CPU high throughput IO machines (although 64GB isn&#x27;t really a large memory machine now) while Kent&#x27;s approach worked fine on clusters but IIRC was tuned for the specific type of scaffold sequencing done by the public project.<p>From the original celera paper, an endnote describing what was pretty impressive hardware for the time:<p>Celera’s computing environment is based on Compaq Computer Corporation’s Alpha system technology running the Tru64 Unix operating system. Celera uses these Alphas as Data Servers and as nodes in a Virtual Compute Farm, all of which are
connected to a fully switched network operating at Fast Ethernet speed (for the VCF) and gigabit Ethernet speed (for data servers). Load balancing and
scheduling software manages the submission and execution of jobs, based on central processing unit (CPU) speed, memory requirements, and priority.
The Virtual Compute Farm is composed of 440 Alpha CPUs, which includes model EV6 running at a clock speed of 400 MHz and EV67 running at 667 MHz. Available memory on these systems ranges from 2 GB to 8 GB. The VCF is used to manage trace file processing, and annotation. Genome assembly was performed on a GS 160 running 16 EV67s (667MHz) and 64 GB of memory, and 10 ES40s running 4 EV6s (500 MHz) and 32 GB of memory. A total of 100 terabytes of physical disk storage was included in a Storage Area Network that was available to systems across the environment. To ensure high availability, file and database servers were configured as 4-node Alpha TruClusters, so that services would fail over in the event of hardware or software failure. Data availability was further enhanced by
using hardware- and software-based disk mirroring (RAID-0), disk striping (RAID-1), and disk striping with parity (RAID-5).</div><br/></div></div><div id="39699855" class="c"><input type="checkbox" id="c-39699855" checked=""/><div class="controls bullet"><span class="by">inciampati</span><span>|</span><a href="#39699079">root</a><span>|</span><a href="#39699245">parent</a><span>|</span><a href="#39700109">prev</a><span>|</span><a href="#39699422">next</a><span>|</span><label class="collapse" for="c-39699855">[-]</label><label class="expand" for="c-39699855">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s more, this isn&#x27;t history. Code from the Celera assembler lives on in a lineage of assembly methods (Canu, HiCanu, Verkko) which have ultimately _completely automated the process of complete genome assembly_ 
<a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1038&#x2F;s41587-023-01662-6" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1038&#x2F;s41587-023-01662-6</a>. The fact that this assembly approach remained relevant until practical resolution of the assembly problem is a testament to its solid theoretical foundation (the string graph) which relates read length, error rate, and information theoretic limits of genome assembly <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1093&#x2F;bioinformatics&#x2F;bti1114" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1093&#x2F;bioinformatics&#x2F;bti1114</a>.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>