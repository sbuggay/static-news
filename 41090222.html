<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722157261556" as="style"/><link rel="stylesheet" href="styles.css?v=1722157261556"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://posixcafe.org/blogs/2024/07/27/0/">Plan 9 is a uniquely complete operating system</a> <span class="domain">(<a href="https://posixcafe.org">posixcafe.org</a>)</span></div><div class="subtext"><span>moody__</span> | <span>44 comments</span></div><br/><div><div id="41091241" class="c"><input type="checkbox" id="c-41091241" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#41091889">next</a><span>|</span><label class="collapse" for="c-41091241">[-]</label><label class="expand" for="c-41091241">[2 more]</label></div><br/><div class="children"><div class="content">For the uninitiated, Plan 9 lives on as the filesystem network interface that allows Windows and Windows Subsystem for Linux cross-platform access to your C drive. Via &quot;<a href="https:&#x2F;&#x2F;nelsonslog.wordpress.com&#x2F;2019&#x2F;06&#x2F;01&#x2F;wsl-access-to-linux-files-via-plan-9&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nelsonslog.wordpress.com&#x2F;2019&#x2F;06&#x2F;01&#x2F;wsl-access-to-li...</a>&quot;:<p><pre><code>    Plan 9’s filesystem is a very simple network filesystem protocol to share files between systems. They are specifically using 9P2000.L.
    They considered using Samba and SMB instead but can’t rely on Samba being installed and usable in the Linux guest OS and didn’t want to ship it because Samba is GPL licensed.
    They picked Plan 9 because it’s much simpler to implement. Also Microsoft already had Plan 9 server code for some other Linux container project they’d done.
    The \\wsl$\ path is handled in the Windows system by the MUP, an existing hook for network-like filesystems. They added a new one for Plan 9.
    The $ is in the name so that it can’t be confused with a computer whose hostname is wsl.
    The Plan 9 server in Linux communicates with the Windows Plan 9 client via a Unix socket. (Windows supports Unix sockets; who knew?)
    Windows can access your Linux files even if no Linux is instance is running. There’s a new Windows service called LXSManagerUser that mediates user identity and permissions.</code></pre></div><br/><div id="41091432" class="c"><input type="checkbox" id="c-41091432" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41091241">parent</a><span>|</span><a href="#41091889">next</a><span>|</span><label class="collapse" for="c-41091432">[-]</label><label class="expand" for="c-41091432">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (Windows supports Unix sockets; who knew?)<p>Only since Windows 10 build 17063 (December 2017 pre-release) [0] [1], which was released as Windows 10 April 2018 Update. So for the first 25+ years of Windows&#x27; existence, it didn&#x27;t.<p>And although it does implement the basic functionality, it is missing features found on mainstream Unix-like platforms, e.g. file descriptor passing (SCM_RIGHTS)<p>[0] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;commandline&#x2F;af_unix-comes-to-windows&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;commandline&#x2F;af_unix-comes-to-...</a><p>[1] <a href="https:&#x2F;&#x2F;betawiki.net&#x2F;wiki&#x2F;Windows_10_build_17063" rel="nofollow">https:&#x2F;&#x2F;betawiki.net&#x2F;wiki&#x2F;Windows_10_build_17063</a></div><br/></div></div></div></div><div id="41091889" class="c"><input type="checkbox" id="c-41091889" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#41091241">prev</a><span>|</span><a href="#41090719">next</a><span>|</span><label class="collapse" for="c-41091889">[-]</label><label class="expand" for="c-41091889">[1 more]</label></div><br/><div class="children"><div class="content">Plan9 is one of those things I go back to every Summer and that is somewhere between completely mind-blowing (check out the GIF at <a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2020&#x2F;09&#x2F;02&#x2F;1900" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2020&#x2F;09&#x2F;02&#x2F;1900</a> to see how fast it boots in real-time on a single-core Pi) and almost completely unfit for purpose because it just doesn’t integrate well (or easily enough) with modern systems (I also considered using it for a writing “appliance” - <a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2023&#x2F;09&#x2F;22&#x2F;1230" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2023&#x2F;09&#x2F;22&#x2F;1230</a> - but syncing data off it was a blocker, and three-button mouse chording GUIs are just not a thing I want to deal with).<p>One of the “stupid” ideas I have in my back-burner is to rewrite rio so that it works like Mac OS 7 (the platinum look with window shading), which in my mind was always a very sane and efficient way to manage windows — but time is not on my side…<p>I have one of my usual lists of resources for it on <a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;os&#x2F;plan9" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;os&#x2F;plan9</a> - comment here if it’s missing anything you particularly like.</div><br/></div></div><div id="41090719" class="c"><input type="checkbox" id="c-41090719" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41091889">prev</a><span>|</span><a href="#41091566">next</a><span>|</span><label class="collapse" for="c-41090719">[-]</label><label class="expand" for="c-41090719">[23 more]</label></div><br/><div class="children"><div class="content">&gt; The Plan 9 implementations tend to not be as feature rich as the proper upstream variants.<p>This is IMO the biggest drawback. Why wouldn&#x27;t any user want the software to be feature rich? In fact, looking at Plan 9, I often feel that the provided software is just a MVP.</div><br/><div id="41091001" class="c"><input type="checkbox" id="c-41091001" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#41090719">parent</a><span>|</span><a href="#41090780">next</a><span>|</span><label class="collapse" for="c-41091001">[-]</label><label class="expand" for="c-41091001">[10 more]</label></div><br/><div class="children"><div class="content">Counterpoint: Plan 9 is supposed to be the ultimate realization of the Unix philosophy.  One important aspect of the Unix philosophy is composable software.  Instead of large, feature-rich programs where functionality is often siloed off from other programs, users have a toolbox of small, composable programs that “do only one thing and do it well” and that they could connect together using pipes and other inter-process communication primitives.<p>Composable software is something I’m highly interested in.  There were efforts in the 1990s to make desktop software more composable, such as COM from Windows and OpenDoc from Apple, but the desktop world is still dominated by large applications such as those that constitute Microsoft Office and the Adobe Creative Suite.  It would have been a wonderful opportunity for the Linux desktop world to embrace components, but, alas, the community embraced OpenOffice, GIMP, and other large applications.</div><br/><div id="41091539" class="c"><input type="checkbox" id="c-41091539" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091001">parent</a><span>|</span><a href="#41091286">next</a><span>|</span><label class="collapse" for="c-41091539">[-]</label><label class="expand" for="c-41091539">[2 more]</label></div><br/><div class="children"><div class="content">That would be Inferno, not Plan 9.<p>COM is everywhere on Windows, specially since Vista, as the WinDev regained the control they thought Longhorn was going to take away from them.<p>One of Powershell strengths is the easy access to COM, just like .NET,  frameworks.<p>Linux could do the same with D-Bus, but alas so is the distributions wars, and hate on anything like proprietary OSes, that it only has a minor role on systemd, GNOME and KDE.</div><br/><div id="41091893" class="c"><input type="checkbox" id="c-41091893" checked=""/><div class="controls bullet"><span class="by">bboygravity</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091539">parent</a><span>|</span><a href="#41091286">next</a><span>|</span><label class="collapse" for="c-41091893">[-]</label><label class="expand" for="c-41091893">[1 more]</label></div><br/><div class="children"><div class="content">Intuitively this sounds like asking for dependency and API hell?<p>Imagine writing a huge complex program that is dependent of communication between smaller existing programs. Either you use the default programs that where shipped with all the different versions of OS&#x27;es with different distro&#x27;s (never going to work, too many different versions of programs and their communication interfaces) or you ship certain fixed versions of all of the small programs that form your bigger program.<p>In case of the latter: why not just use libraries? It&#x27;s basically the same thing with an easier API?<p>Maybe I&#x27;m missing something...</div><br/></div></div></div></div><div id="41091286" class="c"><input type="checkbox" id="c-41091286" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091001">parent</a><span>|</span><a href="#41091539">prev</a><span>|</span><a href="#41091205">next</a><span>|</span><label class="collapse" for="c-41091286">[-]</label><label class="expand" for="c-41091286">[1 more]</label></div><br/><div class="children"><div class="content">The irony is that Acorn&#x27;s RISC OS arguably came the closest to this ideal with any pragmatism. The way that file choosers worked effectively allowed one to pipe a saved file from one application to another and then do it again through the same workflow in the next application and so on.</div><br/></div></div><div id="41091205" class="c"><input type="checkbox" id="c-41091205" checked=""/><div class="controls bullet"><span class="by">flomo</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091001">parent</a><span>|</span><a href="#41091286">prev</a><span>|</span><a href="#41090780">next</a><span>|</span><label class="collapse" for="c-41091205">[-]</label><label class="expand" for="c-41091205">[6 more]</label></div><br/><div class="children"><div class="content">Agreed. And one could argue that Unix wasn&#x27;t really popular because of the &quot;philosophy&quot;, but because it would get out of the way and let you run big monolithic applications like OracleDB or CAD software or even Emacs and etc. So no popular application using &quot;Plan 9 philosophy&quot; ever emerged.</div><br/><div id="41091862" class="c"><input type="checkbox" id="c-41091862" checked=""/><div class="controls bullet"><span class="by">hakfoo</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091205">parent</a><span>|</span><a href="#41091492">next</a><span>|</span><label class="collapse" for="c-41091862">[-]</label><label class="expand" for="c-41091862">[4 more]</label></div><br/><div class="children"><div class="content">I suspect the appeal of the Unix Philosophy is strongest at the earliest phases of the system&#x27;s evolution.<p>Once you&#x27;ve written some very basic boostrap tools, the &quot;second generation&quot; of stuff that adds convenience and flexibility are a lot simpler.<p>A trivial example:  20 seconds after you wrote &quot;directory listing&quot;, someone will say &quot;I want a directory listing, but sorted by date, and it would be awesome if it didn&#x27;t immediately scroll past the end of my screen.&quot;<p>With Unix Philosophy tools, you might already have have a &quot;sort&quot; and &quot;paginate&quot; command, so it&#x27;s just piping stuff together.  They can do it themselves, or it will take 20 seconds to explain.<p>Without it, you&#x27;re going to have to add additional options to &quot;directory listing&quot; (or parallel commands) to handle the sorting and pagination features.  The tools get bigger and buggier for the same functionality.<p>Early Unix machines weren&#x27;t much bigger than mid-80s PCs-- 512K of memory or less-- but offered a very rich command line experience compared with DOS machines of similar sizes.<p>Programs like database or CAD packages probably go monolithic because they&#x27;re more &quot;state dependent&quot; than your usual command-line tools.  &quot;sort&quot; and &quot;more&quot; can take their inputs from stdin and feed them out to stdout, and when they&#x27;re done, forget everything with no damage.<p>That wouldn&#x27;t work well for other packages.  You could probably make a database or CAD system that worked as composable units, like `echo db.sql | db-query &quot;select username from accounts where credit &lt; 0&quot; | xargs delete-account` or `echo image.dxf | add-circle -x 200 -y 400 -r 60 &gt; image.dxf`  But you&#x27;d spend a lot of time reloading and reparsing the same files.  A persistent monolith that keeps the data file open and in whatever internal representation is most efficient is going to perform better.<p>Some use cases also have limited composability, because the user can only plan a few moves ahead.  Tools that encourage interactive&#x2F;experimental usage, like drafting software, might involve the user stopping every step or two to make sure they&#x27;re staying on plan, and queuing up a series of commands could wreak havoc.  Some of these packages ended up simulating composable tools through internal macro&#x2F;scripting languages which still avoided the penalty of having to rely on the OS to orchestrate every single action.</div><br/><div id="41091909" class="c"><input type="checkbox" id="c-41091909" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091862">parent</a><span>|</span><a href="#41091921">next</a><span>|</span><label class="collapse" for="c-41091909">[-]</label><label class="expand" for="c-41091909">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With Unix Philosophy tools, you might already have have a &quot;sort&quot; and &quot;paginate&quot; command, so it&#x27;s just piping stuff together. They can do it themselves, or it will take 20 seconds to explain.<p>Sorting the output of textual tools like ls requires parsing which can be non-trivial.  It&#x27;s easier to do it by using a modern structural shell such as nushell.</div><br/></div></div><div id="41091921" class="c"><input type="checkbox" id="c-41091921" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091862">parent</a><span>|</span><a href="#41091909">prev</a><span>|</span><a href="#41091492">next</a><span>|</span><label class="collapse" for="c-41091921">[-]</label><label class="expand" for="c-41091921">[2 more]</label></div><br/><div class="children"><div class="content">Imagine extending Plan 9 semantics with something like REST style protocols, but via the (virtual) filesystem layer rather than HTTP requests.<p>(Offhand, I&#x27;ve never touched Plan 9 but...) Hypothetically &#x2F;proc&#x2F;SOMEPID&#x2F;db&#x2F;DATABASE&#x2F;SCHEMA&#x2F;TABLE&#x2F;various views which provide expressions in some order.  Or &#x2F;proc&#x2F;SOMEPID&#x2F;containerofthings&#x2F; and the directory listing is serviced by the application, as an enumeration of keys (filenames) to values (datasets).  For a database the API would behave similarly to how ORMs operate since filesystems are inherently similar to objects.</div><br/><div id="41091931" class="c"><input type="checkbox" id="c-41091931" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091921">parent</a><span>|</span><a href="#41091492">next</a><span>|</span><label class="collapse" for="c-41091931">[-]</label><label class="expand" for="c-41091931">[1 more]</label></div><br/><div class="children"><div class="content">Why be dependent on the &#x2F;proc&#x2F;SOMEPID&#x2F; path?  Just write your process as a plan9 file server, and expose it in some arbitrary part of the filesystem.</div><br/></div></div></div></div></div></div><div id="41091492" class="c"><input type="checkbox" id="c-41091492" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091205">parent</a><span>|</span><a href="#41091862">prev</a><span>|</span><a href="#41090780">next</a><span>|</span><label class="collapse" for="c-41091492">[-]</label><label class="expand" for="c-41091492">[1 more]</label></div><br/><div class="children"><div class="content">I agree, but I believe the fact there are no popular applications that fully embrace the Unix&#x2F;Plan 9 philosophy is the point of the philosophy.  Generic tools that can be composed versus end-to-end applications.  Both have their advantages and disadvantages, though component-based software doesn’t preclude the development of end-to-end applications using these components.  In my opinion I believe the reason end-to-end applications are dominant is because it’s easier for companies to sell and market <i>products</i> over <i>tools</i>.  Part of the reason OpenDoc failed was because companies that made a living selling end-to-end applications (like Adobe) didn’t want to adopt component-based software where the product (application) isn’t the main focus.  Imagine if users could construct their own Photoshop out of discrete elements.</div><br/></div></div></div></div></div></div><div id="41090780" class="c"><input type="checkbox" id="c-41090780" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#41090719">parent</a><span>|</span><a href="#41091001">prev</a><span>|</span><a href="#41091801">next</a><span>|</span><label class="collapse" for="c-41090780">[-]</label><label class="expand" for="c-41090780">[9 more]</label></div><br/><div class="children"><div class="content">For the same reason people prefer languages like Python over Perl. Simplicity improves usability and understandability.<p>It&#x27;s pleasant to use a minimalist, viable product.<p>9front is not the only OS I use, but it is one of my daily drivers.</div><br/><div id="41090787" class="c"><input type="checkbox" id="c-41090787" checked=""/><div class="controls bullet"><span class="by">lagniappe</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41090780">parent</a><span>|</span><a href="#41091216">next</a><span>|</span><label class="collapse" for="c-41090787">[-]</label><label class="expand" for="c-41090787">[1 more]</label></div><br/><div class="children"><div class="content">Hey Ori :) I particularly enjoyed your video talk &quot;not dead just resting&quot; - thanks for everything you do<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6m3GuoaxRNM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6m3GuoaxRNM</a></div><br/></div></div><div id="41091216" class="c"><input type="checkbox" id="c-41091216" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41090780">parent</a><span>|</span><a href="#41090787">prev</a><span>|</span><a href="#41090974">next</a><span>|</span><label class="collapse" for="c-41091216">[-]</label><label class="expand" for="c-41091216">[2 more]</label></div><br/><div class="children"><div class="content">Python started out decades ago as a language for beginners or non-professional programmers, but is the current language simple or minimalistic?</div><br/><div id="41091601" class="c"><input type="checkbox" id="c-41091601" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091216">parent</a><span>|</span><a href="#41090974">next</a><span>|</span><label class="collapse" for="c-41091601">[-]</label><label class="expand" for="c-41091601">[1 more]</label></div><br/><div class="children"><div class="content">Not at all, it has C++ complexity level, if one wants to master it at all levels.<p>Additionally, since even minor versions introduce breaking changes, getting something from e.g. Python 1.6 to run on 3.12 is an exercise in trial and error, or unexpected surprises at some moment at runtime.</div><br/></div></div></div></div><div id="41090974" class="c"><input type="checkbox" id="c-41090974" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41090780">parent</a><span>|</span><a href="#41091216">prev</a><span>|</span><a href="#41091059">next</a><span>|</span><label class="collapse" for="c-41090974">[-]</label><label class="expand" for="c-41090974">[4 more]</label></div><br/><div class="children"><div class="content">Python isn&#x27;t simple.</div><br/><div id="41091112" class="c"><input type="checkbox" id="c-41091112" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41090974">parent</a><span>|</span><a href="#41091398">next</a><span>|</span><label class="collapse" for="c-41091112">[-]</label><label class="expand" for="c-41091112">[2 more]</label></div><br/><div class="children"><div class="content">Perl is less simple. Though, I suppose lua would be a better comparison.</div><br/><div id="41091175" class="c"><input type="checkbox" id="c-41091175" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41091112">parent</a><span>|</span><a href="#41091398">next</a><span>|</span><label class="collapse" for="c-41091175">[-]</label><label class="expand" for="c-41091175">[1 more]</label></div><br/><div class="children"><div class="content">I fail to see your point. To me, these three are all very close to each other in &quot;simplicity&quot; and any ordering seems arguable. If anything, isn&#x27;t Perl simpler than Python and if not, why?<p>Perhaps vast differences in ergonomics and language-culture-fit but that&#x27;s orthogonal&#x2F;unrelated?</div><br/></div></div></div></div><div id="41091398" class="c"><input type="checkbox" id="c-41091398" checked=""/><div class="controls bullet"><span class="by">nutrie</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41090974">parent</a><span>|</span><a href="#41091112">prev</a><span>|</span><a href="#41091059">next</a><span>|</span><label class="collapse" for="c-41091398">[-]</label><label class="expand" for="c-41091398">[1 more]</label></div><br/><div class="children"><div class="content">He didn&#x27;t say Python was simple. He mentioned simplicity, those are different things.</div><br/></div></div></div></div><div id="41091059" class="c"><input type="checkbox" id="c-41091059" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#41090719">root</a><span>|</span><a href="#41090780">parent</a><span>|</span><a href="#41090974">prev</a><span>|</span><a href="#41091801">next</a><span>|</span><label class="collapse" for="c-41091059">[-]</label><label class="expand" for="c-41091059">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s `venv` Just Works (and is standard), while whatever it was that I dug up to get the same effect in Perl mostly didn&#x27;t. I somewhat prefer Perl for things where this isn&#x27;t an issue.<p>I should probably make time look again in case I missed something or it&#x27;s improved in the last decade.</div><br/></div></div></div></div><div id="41091433" class="c"><input type="checkbox" id="c-41091433" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41090719">parent</a><span>|</span><a href="#41091801">prev</a><span>|</span><a href="#41091796">next</a><span>|</span><label class="collapse" for="c-41091433">[-]</label><label class="expand" for="c-41091433">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why wouldn&#x27;t any user want the software to be feature rich?<p>Users want feature rich systems. Individual programs are best feature-complete, but focused on a single task and capable of cooperating with others when something out of scope is desired.<p>From my personal viewpoint: It&#x27;s not easy to hack on large monoliths, even for senior software engineers. But if every logical piece of the monolith tries to be as small as it meaningfully could, the barriers are drastically lower.</div><br/></div></div><div id="41091796" class="c"><input type="checkbox" id="c-41091796" checked=""/><div class="controls bullet"><span class="by">akritid</span><span>|</span><a href="#41090719">parent</a><span>|</span><a href="#41091433">prev</a><span>|</span><a href="#41091566">next</a><span>|</span><label class="collapse" for="c-41091796">[-]</label><label class="expand" for="c-41091796">[1 more]</label></div><br/><div class="children"><div class="content">It is a personal choice of course, but some people enjoy the feeling of fully learning a piece of software, which is impossible with most.</div><br/></div></div></div></div><div id="41091566" class="c"><input type="checkbox" id="c-41091566" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41090719">prev</a><span>|</span><a href="#41090501">next</a><span>|</span><label class="collapse" for="c-41091566">[-]</label><label class="expand" for="c-41091566">[1 more]</label></div><br/><div class="children"><div class="content">The author is putting &quot;upstream&quot; on some weird pedestal. The whole point of foss is that any upstreams have very limited privileges compared to downstreams.<p>&gt; Put in another way, if someone wanted the ability to touch every line of code (in the upstream sense), they would have to be a member of some non trivial amount of communities.<p>On a typical distro you can just download sources and start hacking, you don&#x27;t need to be member of any community.<p>While something like Debian might not be monorepo in the strictest sense, on a conceptual level it is very close. They still have all the sources under their control and are not dependent on anything outside. They are at full liberty to accept or reject any patches regardless of where they come from, from &quot;upstream&quot; or &quot;downstream&quot;.<p>This idea that distros are actually independent full-featured operating systems is an idea that I think is getting forgotten way too often. Distros are (or rather can be) much more than mere repackaging of upstream software.</div><br/></div></div><div id="41090501" class="c"><input type="checkbox" id="c-41090501" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41091566">prev</a><span>|</span><a href="#41091092">next</a><span>|</span><label class="collapse" for="c-41090501">[-]</label><label class="expand" for="c-41090501">[1 more]</label></div><br/><div class="children"><div class="content">cache cause hugged:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240728004832&#x2F;https:&#x2F;&#x2F;posixcafe.org&#x2F;blogs&#x2F;2024&#x2F;07&#x2F;27&#x2F;0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240728004832&#x2F;https:&#x2F;&#x2F;posixcafe...</a></div><br/></div></div><div id="41091092" class="c"><input type="checkbox" id="c-41091092" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#41090501">prev</a><span>|</span><a href="#41091490">next</a><span>|</span><label class="collapse" for="c-41091092">[-]</label><label class="expand" for="c-41091092">[1 more]</label></div><br/><div class="children"><div class="content">So is there something (social or technical) that makes it tricky to independently provide apps for plan 9, or is it just that the only people who care already have commit access?</div><br/></div></div><div id="41091490" class="c"><input type="checkbox" id="c-41091490" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41091092">prev</a><span>|</span><a href="#41090482">next</a><span>|</span><label class="collapse" for="c-41091490">[-]</label><label class="expand" for="c-41091490">[1 more]</label></div><br/><div class="children"><div class="content">Superceded by Inferno as follow up project, where Limbo took the role of the abandoned Alef language for Plan 9.<p>I always have the impression the discussion stops on a gas station the middle of the road, instead of on the destination.</div><br/></div></div><div id="41090482" class="c"><input type="checkbox" id="c-41090482" checked=""/><div class="controls bullet"><span class="by">GianFabien</span><span>|</span><a href="#41091490">prev</a><span>|</span><a href="#41090843">next</a><span>|</span><label class="collapse" for="c-41090482">[-]</label><label class="expand" for="c-41090482">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve played with Plan9 several times, but never used it seriously.  The aesthetics that puts me off. Would have been great if they had taken guidance from BeOS &#x2F; Haiku-OS for the look and feel. Heck, even Windows 95 would have been an improvement.</div><br/><div id="41090542" class="c"><input type="checkbox" id="c-41090542" checked=""/><div class="controls bullet"><span class="by">coreload</span><span>|</span><a href="#41090482">parent</a><span>|</span><a href="#41090546">next</a><span>|</span><label class="collapse" for="c-41090542">[-]</label><label class="expand" for="c-41090542">[1 more]</label></div><br/><div class="children"><div class="content">That would have been difficult since Plan 9 predates each of those other systems. Also Plan 9 took place in Bell Labs as a research project, was based on their own UI research, and was not intended to be a commercially familiar UI. There are interesting ideas in the write ups about the UI that could be applied in nearly any UI today.</div><br/></div></div><div id="41090546" class="c"><input type="checkbox" id="c-41090546" checked=""/><div class="controls bullet"><span class="by">Gualdrapo</span><span>|</span><a href="#41090482">parent</a><span>|</span><a href="#41090542">prev</a><span>|</span><a href="#41090972">next</a><span>|</span><label class="collapse" for="c-41090546">[-]</label><label class="expand" for="c-41090546">[5 more]</label></div><br/><div class="children"><div class="content">Not an expert in OS development whatsoever but I do know that it&#x27;s not intended for common usage, so how its UI looks is not something devs would take much care of.<p>Though I do know that it puts some strong emphasis on mouse usage, something that for someone that grew to use the keyboard a lot like me (ironically, as a graphic designer) seems to be really awkward, to say the less. Its strengths seem to be its overlaying concepts and that it intended to be &quot;the next gen Unix&quot; - alas it won&#x27;t take over for a myriad of reasons, and some would argue Unix-es have already borrowed some of its concepts for themselves.</div><br/><div id="41090883" class="c"><input type="checkbox" id="c-41090883" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41090546">parent</a><span>|</span><a href="#41090972">next</a><span>|</span><label class="collapse" for="c-41090883">[-]</label><label class="expand" for="c-41090883">[4 more]</label></div><br/><div class="children"><div class="content">Forgive my naïvety, but couldn’t X and CDE be ported over?</div><br/><div id="41091113" class="c"><input type="checkbox" id="c-41091113" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41090883">parent</a><span>|</span><a href="#41090943">next</a><span>|</span><label class="collapse" for="c-41091113">[-]</label><label class="expand" for="c-41091113">[1 more]</label></div><br/><div class="children"><div class="content">You could, but if you want Unix, you already know where to find it.</div><br/></div></div><div id="41090943" class="c"><input type="checkbox" id="c-41090943" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41090883">parent</a><span>|</span><a href="#41091113">prev</a><span>|</span><a href="#41090952">next</a><span>|</span><label class="collapse" for="c-41090943">[-]</label><label class="expand" for="c-41090943">[1 more]</label></div><br/><div class="children"><div class="content">I thought there <i>was</i> an X server for Plan 9 (edit: yes; <a href="https:&#x2F;&#x2F;plan9.io&#x2F;wiki&#x2F;plan9&#x2F;x11_installation&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;plan9.io&#x2F;wiki&#x2F;plan9&#x2F;x11_installation&#x2F;index.html</a> ), but it kinda defeats the point unless you use something like <a href="https:&#x2F;&#x2F;github.com&#x2F;gerstner-hub&#x2F;xwmfs">https:&#x2F;&#x2F;github.com&#x2F;gerstner-hub&#x2F;xwmfs</a> on it. CDE... something like CDE probably, but actual CDE would be <i>painful</i> and really defeat the point unless you ported its IPC to a Plan 9 native version.</div><br/></div></div><div id="41090952" class="c"><input type="checkbox" id="c-41090952" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41090883">parent</a><span>|</span><a href="#41090943">prev</a><span>|</span><a href="#41090972">next</a><span>|</span><label class="collapse" for="c-41090952">[-]</label><label class="expand" for="c-41090952">[1 more]</label></div><br/><div class="children"><div class="content">Not trivially. There&#x27;s a lot in how Plan 9 is put together that makes this a monumental effort.<p>(That said, there may have been an X server brought in at some point, but don&#x27;t quote me on that. That&#x27;s the least of anyone&#x27;s problems in undertaking a CDE port though.)</div><br/></div></div></div></div></div></div><div id="41090972" class="c"><input type="checkbox" id="c-41090972" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#41090482">parent</a><span>|</span><a href="#41090546">prev</a><span>|</span><a href="#41090843">next</a><span>|</span><label class="collapse" for="c-41090972">[-]</label><label class="expand" for="c-41090972">[4 more]</label></div><br/><div class="children"><div class="content">Plan 9 was heavily influenced by the Xerox PARC Mesa&#x2F;Cedar interface, which influenced Wirth’s Project Oberon.  I forget whether Project Oberon directly influenced Plan 9, but I’ve heard people argue that Rob Pike, one of the leaders of the Plan 9 project at Bell Labs, was heavily influenced by Wirth when it came to programming language design, even if the syntax was closer to C instead of Wirth languages like Pascal, Modula-2, and Oberon.  With that said, there are major similarities between the interfaces of Cedar&#x2F;Mesa, Project Oberon, and Plan 9.<p>A few years ago I thought about what it would take to implement a more conventional desktop GUI on top of Plan 9, but I’ve oscillated back and forth between wanting Plan 9 with a Mac-like desktop versus wanting a modern Lisp&#x2F;Smalltalk machine (with object-oriented underpinnings instead of Plan 9’s “everything is a file” interfaces) with a Mac-like desktop.</div><br/><div id="41091611" class="c"><input type="checkbox" id="c-41091611" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41090972">parent</a><span>|</span><a href="#41090843">next</a><span>|</span><label class="collapse" for="c-41091611">[-]</label><label class="expand" for="c-41091611">[3 more]</label></div><br/><div class="children"><div class="content">You see Oberon&#x27;s influence on how ACME editor works, and later the OS dynamism enjoyed by Inferno and Limbo, that everyone usually forgets about.</div><br/><div id="41091734" class="c"><input type="checkbox" id="c-41091734" checked=""/><div class="controls bullet"><span class="by">akritid</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41091611">parent</a><span>|</span><a href="#41090843">next</a><span>|</span><label class="collapse" for="c-41091734">[-]</label><label class="expand" for="c-41091734">[2 more]</label></div><br/><div class="children"><div class="content">Inferno is not a successor.  For example you can have Golang for Plan 9 but doesn’t make much sense on Inferno. You would even run Inferno on Plan 9 on some scenarios. I suspect most people who know about Plan 9 also know about Inferno, but it’s just a different thing, does not supersede it in general.</div><br/><div id="41091797" class="c"><input type="checkbox" id="c-41091797" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41090482">root</a><span>|</span><a href="#41091734">parent</a><span>|</span><a href="#41090843">next</a><span>|</span><label class="collapse" for="c-41091797">[-]</label><label class="expand" for="c-41091797">[1 more]</label></div><br/><div class="children"><div class="content">Plan 9 =&gt; Inferno<p>Alef =&gt; Limbo =&gt; Go.<p>Being able to target Plan 9 with Go doesn&#x27;t make sense, that isn&#x27;t how historical evolution works.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41090843" class="c"><input type="checkbox" id="c-41090843" checked=""/><div class="controls bullet"><span class="by">lagniappe</span><span>|</span><a href="#41090482">prev</a><span>|</span><a href="#41090798">next</a><span>|</span><label class="collapse" for="c-41090843">[-]</label><label class="expand" for="c-41090843">[1 more]</label></div><br/><div class="children"><div class="content">The year of the 9 desktop cometh!</div><br/></div></div><div id="41090798" class="c"><input type="checkbox" id="c-41090798" checked=""/><div class="controls bullet"><span class="by">pxmpxm</span><span>|</span><a href="#41090843">prev</a><span>|</span><label class="collapse" for="c-41090798">[-]</label><label class="expand" for="c-41090798">[1 more]</label></div><br/><div class="children"><div class="content">Plan9 is the ycN equivalent of <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;739&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;739&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>