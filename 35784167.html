<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683040924099" as="style"/><link rel="stylesheet" href="styles.css?v=1683040924099"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://htdp.org/2023-3-6/Book/part_preface.html">How to Design Programs 2nd Edition</a> <span class="domain">(<a href="https://htdp.org">htdp.org</a>)</span></div><div class="subtext"><span>noob_eng</span> | <span>93 comments</span></div><br/><div><div id="35784616" class="c"><input type="checkbox" id="c-35784616" checked=""/><div class="controls bullet"><span class="by">adamors</span><span>|</span><a href="#35788238">next</a><span>|</span><label class="collapse" for="c-35784616">[-]</label><label class="expand" for="c-35784616">[5 more]</label></div><br/><div class="children"><div class="content">Posted just 3 weeks ago by the same user no less  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35478871" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35478871</a></div><br/><div id="35787967" class="c"><input type="checkbox" id="c-35787967" checked=""/><div class="controls bullet"><span class="by">jmnicolas</span><span>|</span><a href="#35784616">parent</a><span>|</span><a href="#35787130">next</a><span>|</span><label class="collapse" for="c-35787967">[-]</label><label class="expand" for="c-35787967">[1 more]</label></div><br/><div class="children"><div class="content">Not in vain since I just saw it today.</div><br/></div></div><div id="35787130" class="c"><input type="checkbox" id="c-35787130" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#35784616">parent</a><span>|</span><a href="#35787967">prev</a><span>|</span><a href="#35784863">next</a><span>|</span><label class="collapse" for="c-35787130">[-]</label><label class="expand" for="c-35787130">[1 more]</label></div><br/><div class="children"><div class="content">i found out about it today</div><br/></div></div></div></div><div id="35788238" class="c"><input type="checkbox" id="c-35788238" checked=""/><div class="controls bullet"><span class="by">photochemsyn</span><span>|</span><a href="#35784616">prev</a><span>|</span><a href="#35787698">next</a><span>|</span><label class="collapse" for="c-35788238">[-]</label><label class="expand" for="c-35788238">[4 more]</label></div><br/><div class="children"><div class="content">I think this approach to the issue of &#x27;what language to start with&#x27; has a serious flaw for basic programming instruction:<p>&gt; &quot;Our solution is to start with our own tailor-made teaching language, dubbed “Beginning Student Language” or BSL.&quot;<p>The only time the use of a toy language makes sense is if you&#x27;re learning how to create a programming language in the context of understanding compilers, e.g.<p><a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;tutorial&#x2F;MyFirstLanguageFrontend&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;tutorial&#x2F;MyFirstLanguageFrontend&#x2F;index...</a><p>Otherwise it&#x27;s doing the students a disservice as they&#x27;ll never use the language again and will have to relearn a whole new syntax later on.  It&#x27;s also far better to learn in a widely used language because there will be a wide variety of resources that can help you solve simple problems (and this is even more true in the era of ChatGPT).<p>The argument that a simplified language makes it easier for students to grasp high-level concepts doesn&#x27;t work either: instead just use a restricted well-defined subset of a language like C, C++, Java, Python, Javascript - and explain to the students the rationale for doing so.</div><br/><div id="35788834" class="c"><input type="checkbox" id="c-35788834" checked=""/><div class="controls bullet"><span class="by">soegaard</span><span>|</span><a href="#35788238">parent</a><span>|</span><a href="#35788308">next</a><span>|</span><label class="collapse" for="c-35788834">[-]</label><label class="expand" for="c-35788834">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not one &quot;toy&quot; language. 
It&#x27;s a series of languages that becomes gradually larger.
It has the exact same syntax and semantics as the &quot;real&quot; Racket.<p>If a language is small, the compiler can give very precise beginner friendly error messages. I&#x27;ll call someone who has programmed one or two weeks for a beginner.<p>As an example, in the beginner language all function calls begins with a name, so `((foo) 42)` gives an error message, that says function calls must start with a name. Note that beginners often use too many parentheses.<p>Later on when first order functions are introduced, the call `(foo)` might return a function, so `((foo) 42)` is okay.
The beginner friendly &quot;function call must start with a name&quot; message is now no longer true.<p>There are four language levels used in the book - and they follow the progression in the book.</div><br/></div></div><div id="35788308" class="c"><input type="checkbox" id="c-35788308" checked=""/><div class="controls bullet"><span class="by">Athas</span><span>|</span><a href="#35788238">parent</a><span>|</span><a href="#35788834">prev</a><span>|</span><a href="#35787698">next</a><span>|</span><label class="collapse" for="c-35788308">[-]</label><label class="expand" for="c-35788308">[2 more]</label></div><br/><div class="children"><div class="content">I thought BSL was a subset of Scheme, so it avoids most of those problems you mention. Or do I misremember?</div><br/><div id="35788624" class="c"><input type="checkbox" id="c-35788624" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#35788238">root</a><span>|</span><a href="#35788308">parent</a><span>|</span><a href="#35787698">next</a><span>|</span><label class="collapse" for="c-35788624">[-]</label><label class="expand" for="c-35788624">[1 more]</label></div><br/><div class="children"><div class="content">They should have just used standard R7RS small. Creating a variant only serves more confusion.</div><br/></div></div></div></div></div></div><div id="35787698" class="c"><input type="checkbox" id="c-35787698" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#35788238">prev</a><span>|</span><a href="#35784670">next</a><span>|</span><label class="collapse" for="c-35787698">[-]</label><label class="expand" for="c-35787698">[3 more]</label></div><br/><div class="children"><div class="content">The copyright says 2014, the foreword says they spent 15 years on the 2nd edition since 1995-2000.<p>It also says it was released the 6th of March 2023<p>So is it new or not?</div><br/><div id="35788464" class="c"><input type="checkbox" id="c-35788464" checked=""/><div class="controls bullet"><span class="by">tjr</span><span>|</span><a href="#35787698">parent</a><span>|</span><a href="#35784670">next</a><span>|</span><label class="collapse" for="c-35788464">[-]</label><label class="expand" for="c-35788464">[2 more]</label></div><br/><div class="children"><div class="content">I remember the 2nd edition coming out in printed form years ago.<p>Perhaps there was some update in March of 2023, or perhaps this particular set of HTML files was published in March, but overall, the book has been out for a while.</div><br/><div id="35788511" class="c"><input type="checkbox" id="c-35788511" checked=""/><div class="controls bullet"><span class="by">marai2</span><span>|</span><a href="#35787698">root</a><span>|</span><a href="#35788464">parent</a><span>|</span><a href="#35784670">next</a><span>|</span><label class="collapse" for="c-35788511">[-]</label><label class="expand" for="c-35788511">[1 more]</label></div><br/><div class="children"><div class="content">There is a version number at the top: &quot;v8.8.0.8&quot;.
I believe they keep making updates to the book probably to fix typos&#x2F;errata.
The original link I had bookmarked <a href="https:&#x2F;&#x2F;htdp.org&#x2F;2018-01-06&#x2F;Book&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;htdp.org&#x2F;2018-01-06&#x2F;Book&#x2F;index.html</a>
and this one look mostly the same - content wise.<p>But it would be nice if there was a CHANGES file or description about what does change between these versions.</div><br/></div></div></div></div></div></div><div id="35784670" class="c"><input type="checkbox" id="c-35784670" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#35787698">prev</a><span>|</span><a href="#35786229">next</a><span>|</span><label class="collapse" for="c-35784670">[-]</label><label class="expand" for="c-35784670">[3 more]</label></div><br/><div class="children"><div class="content">Why one should read this book? If you have read this book, what were your big takeaways from this?</div><br/><div id="35788652" class="c"><input type="checkbox" id="c-35788652" checked=""/><div class="controls bullet"><span class="by">marai2</span><span>|</span><a href="#35784670">parent</a><span>|</span><a href="#35784905">next</a><span>|</span><label class="collapse" for="c-35788652">[-]</label><label class="expand" for="c-35788652">[1 more]</label></div><br/><div class="children"><div class="content">I read this book when I was learning functional programming. Since I started learning fp with Haskell, I couldn&#x27;t figure out in the beginning how you create any meaningful programs with it. All I had were small toy programming problems from the Haskell book I was reading. This book hand-held me through learning fp and the two things that, for me, helped connect the dots were the Space Invaders type game that you build in one of the chapters of HTDP2 and Scott Wlaschin&#x27;s Domain Modeling Made Functional by Scott Wlaschin. The Space Invaders game showed me how you can create a bigger program that actually is of moderate complexity by composing little functions together!<p>However the book is an introductory book, so there is a lot of basic stuff if you already know programming.</div><br/></div></div><div id="35784905" class="c"><input type="checkbox" id="c-35784905" checked=""/><div class="controls bullet"><span class="by">soegaard</span><span>|</span><a href="#35784670">parent</a><span>|</span><a href="#35788652">prev</a><span>|</span><a href="#35786229">next</a><span>|</span><label class="collapse" for="c-35784905">[-]</label><label class="expand" for="c-35784905">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s all about systematic program design.<p>The authors has the following to say in the Preface.<p>PREFACE<p>Many professions require some form of programming. Accountants program spreadsheets; musicians program synthesizers; authors program word processors; and web designers program style sheets. When we wrote these words for the first edition of the book (1995–2000), readers may have considered them futuristic; by now, programming has become a required skill and numerous outlets—books, on-line courses, K-12 curricula—cater to this need, always with the goal of enhancing people’s job prospects.<p>The typical course on programming teaches a “tinker until it works” approach. When it works, students exclaim “It works!” and move on. Sadly, this phrase is also the shortest lie in computing, and it has cost many people many hours of their lives. In contrast, this book focuses on habits of good programming, addressing both professional and vocational programmers.<p>By “good programming,” we mean an approach to the creation of software that relies on systematic thought, planning, and understanding from the very beginning, at every stage, and for every step. To emphasize the point, we speak of systematic program design and systematically designed programs. Critically, the latter articulates the rationale of the desired functionality. Good programming also satisfies an aesthetic sense of accomplishment; the elegance of a good program is comparable to time-tested poems or the black-and-white photographs of a bygone era. In short, programming differs from good programming like crayon sketches in a diner from oil paintings in a museum.<p>No, this book won’t turn anyone into a master painter. But, we would not have spent fifteen years writing this edition if we didn’t believe that
everyone can design programs and everyone can experience the satisfaction that comes with creative design.<p>Indeed, we go even further and argue that program design—but not programming—deserves the same role in a liberal-arts education as mathematics and language skills.<p>A student of design who never touches a program again will still pick up universally useful problem-solving skills, experience a deeply creative activity, and learn to appreciate a new form of aesthetic. The rest of this preface explains in detail what we mean with “systematic design,” who benefits in what manner, and how we go about teaching it all.<p>For more details on &quot;System Program Design&quot; means in practise, see the last section of the preface. <a href="https:&#x2F;&#x2F;htdp.org&#x2F;2018-01-06&#x2F;Book&#x2F;part_preface.html" rel="nofollow">https:&#x2F;&#x2F;htdp.org&#x2F;2018-01-06&#x2F;Book&#x2F;part_preface.html</a></div><br/></div></div></div></div><div id="35786229" class="c"><input type="checkbox" id="c-35786229" checked=""/><div class="controls bullet"><span class="by">JustSomeNobody</span><span>|</span><a href="#35784670">prev</a><span>|</span><a href="#35786264">next</a><span>|</span><label class="collapse" for="c-35786229">[-]</label><label class="expand" for="c-35786229">[1 more]</label></div><br/><div class="children"><div class="content">I love the look of scribble docs.  I don&#x27;t really use Racket though.  Are there alternatives that anyone knows about that have this look?</div><br/></div></div><div id="35784582" class="c"><input type="checkbox" id="c-35784582" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#35785905">prev</a><span>|</span><a href="#35785748">next</a><span>|</span><label class="collapse" for="c-35784582">[-]</label><label class="expand" for="c-35784582">[65 more]</label></div><br/><div class="children"><div class="content">I would not follow any of this book anymore.<p>Abstractions lead to coupling and complexity.<p>So many outdated principles I can’t enumerate them all.</div><br/><div id="35786525" class="c"><input type="checkbox" id="c-35786525" checked=""/><div class="controls bullet"><span class="by">mumblemumble</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35784773">next</a><span>|</span><label class="collapse" for="c-35786525">[-]</label><label class="expand" for="c-35786525">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Abstractions lead to coupling and complexity.<p>If you&#x27;re in the habit of programming in anything other than machine language, I think you&#x27;ll have to agree that the real story is more nuanced than that.<p>I haven&#x27;t actually read this book so I&#x27;m not prepared to defend it. But I would happily run my mouth and say that the truth is more that abstractions are a double-edged sword. They can be very effective in skilled hands, but they are dangerous in the hands of the untrained. Unfortunately, what makes a good abstraction (IMO it&#x27;s algebras or GTFO) is not something in which most of us receive sufficient training.</div><br/><div id="35787281" class="c"><input type="checkbox" id="c-35787281" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35786525">parent</a><span>|</span><a href="#35784773">next</a><span>|</span><label class="collapse" for="c-35787281">[-]</label><label class="expand" for="c-35787281">[1 more]</label></div><br/><div class="children"><div class="content">If an &quot;abstraction&quot; leads to coupling, then it&#x27;s not an abstraction.</div><br/></div></div></div></div><div id="35784773" class="c"><input type="checkbox" id="c-35784773" checked=""/><div class="controls bullet"><span class="by">stinos</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35786525">prev</a><span>|</span><a href="#35784636">next</a><span>|</span><label class="collapse" for="c-35784773">[-]</label><label class="expand" for="c-35784773">[16 more]</label></div><br/><div class="children"><div class="content"><i>Abstractions lead to coupling and complexity.</i><p>The <i>wrong</i> abstractions <i>can</i> lead to coupling and complexity. The right ones on the other hand are all about reducing coupling and complexity.</div><br/><div id="35786771" class="c"><input type="checkbox" id="c-35786771" checked=""/><div class="controls bullet"><span class="by">simplotek</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784773">parent</a><span>|</span><a href="#35785084">next</a><span>|</span><label class="collapse" for="c-35786771">[-]</label><label class="expand" for="c-35786771">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The wrong abstractions can lead to coupling and complexity.<p>This comes to the old quote:<p>* <i>&quot;Make everything as simple as possible, but not simpler.”</i> Albert Einstein.<p>Abstractions undoubtedly add complexity that quickly becomes unmanageable. By now everyone is already aware of the horror that&#x27;s the enterprise version of Hello World, and YAGNI&#x2F;gold plating are renowned antipatterns. Many codebases have already succumbed to the perils of premature generalization, where the good old rule of 3 of refactoring serves as a shield against it.<p>But still some developers succumb to the siren song of abstracting away things.</div><br/><div id="35787388" class="c"><input type="checkbox" id="c-35787388" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35786771">parent</a><span>|</span><a href="#35788700">next</a><span>|</span><label class="collapse" for="c-35787388">[-]</label><label class="expand" for="c-35787388">[2 more]</label></div><br/><div class="children"><div class="content">Okay, let&#x27;s take an excerpt from one of those enterprise &quot;hello world&quot;s:<p><pre><code>    IHelloWorldString helloWorldString = helloWorld.getHelloWorld();
    IPrintStrategy printStrategy = helloWorld.getPrintStrategy();
    IStatusCode code = helloWorld.print(printStrategy, helloWorldString);
</code></pre>
Extracting two subobjects from an object to feed them back to the same very object <i>is not an abstraction</i>, it&#x27;s merely adding a bunch of public methods (and interfaces) to the object. That may or may not help in abstracting things: and usually, the more handles and bells and whistles are available to pull and play with, the <i>less</i> abstracted the code actually is.</div><br/><div id="35788803" class="c"><input type="checkbox" id="c-35788803" checked=""/><div class="controls bullet"><span class="by">simplotek</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35787388">parent</a><span>|</span><a href="#35788700">next</a><span>|</span><label class="collapse" for="c-35788803">[-]</label><label class="expand" for="c-35788803">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s merely adding a bunch of public methods (and interfaces)<p>What do the interfaces represent?</div><br/></div></div></div></div><div id="35788700" class="c"><input type="checkbox" id="c-35788700" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35786771">parent</a><span>|</span><a href="#35787388">prev</a><span>|</span><a href="#35785084">next</a><span>|</span><label class="collapse" for="c-35788700">[-]</label><label class="expand" for="c-35788700">[2 more]</label></div><br/><div class="children"><div class="content">How is gold plating the same as YAGNI? They&#x27;re opposites, no?</div><br/><div id="35788788" class="c"><input type="checkbox" id="c-35788788" checked=""/><div class="controls bullet"><span class="by">simplotek</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35788700">parent</a><span>|</span><a href="#35785084">next</a><span>|</span><label class="collapse" for="c-35788788">[-]</label><label class="expand" for="c-35788788">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How is gold plating the same as YAGNI? They&#x27;re opposites, no?<p>No, gold plating and YAGNI are two faces of the same abstraction coin.</div><br/></div></div></div></div></div></div><div id="35785084" class="c"><input type="checkbox" id="c-35785084" checked=""/><div class="controls bullet"><span class="by">jasfi</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784773">parent</a><span>|</span><a href="#35786771">prev</a><span>|</span><a href="#35784816">next</a><span>|</span><label class="collapse" for="c-35785084">[-]</label><label class="expand" for="c-35785084">[3 more]</label></div><br/><div class="children"><div class="content">I agree, besides, there&#x27;s really no getting away from abstractions to manage complexity.</div><br/><div id="35786669" class="c"><input type="checkbox" id="c-35786669" checked=""/><div class="controls bullet"><span class="by">lo_zamoyski</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785084">parent</a><span>|</span><a href="#35785846">next</a><span>|</span><label class="collapse" for="c-35786669">[-]</label><label class="expand" for="c-35786669">[1 more]</label></div><br/><div class="children"><div class="content">A stronger claim: <i>everything</i> in programming is an abstraction.<p>Somewhat tangential, but I sense tacitly related... I sometimes sense that many people who program adhere to a kind of computational atomism, that there is some kind of underlying &quot;real&quot; and that everything else is &quot;just&quot; some kind of arrangement of elements of the real. But that&#x27;s just an implementation detail. Yes, when we implement a language that compiles to instructions or bits on a specific machine, we are indeed working to simulate that language. But computation and formal languages don&#x27;t really have anything to do with physical computers. Their connection is entirely incidental. It is a matter of practicality, like the choice of using a hammer versus a rock to drive spikes of metal through wood. A computer language <i>is</i> the &quot;base&quot; language. From the formal perspective, there is no &quot;low-level&quot; or &quot;high-level&quot; language, just different languages that compilers can translate between. What is &quot;low-level&quot; (typically the target language) is merely low-level by convention, usually because we are targeting a given machine instruction set of some physical machine.<p>But even here, the notion of an &quot;instruction&quot; or a &quot;bit&quot; are abstractions. There are no &quot;bits&quot; in the world as ontological entities. Computation and data are abstract, full stop. All physical implementations are simply instruments for simulating that abstract model. There is no difference, in principle, between using checker pieces, differences in voltage, magnetic polarity, or thumbs up&#x2F;thumbs down to represent bits.<p>The language should, ideally, be suited to the domain of discourse.</div><br/></div></div><div id="35785846" class="c"><input type="checkbox" id="c-35785846" checked=""/><div class="controls bullet"><span class="by">tephra</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785084">parent</a><span>|</span><a href="#35786669">prev</a><span>|</span><a href="#35784816">next</a><span>|</span><label class="collapse" for="c-35785846">[-]</label><label class="expand" for="c-35785846">[1 more]</label></div><br/><div class="children"><div class="content">Arguably managing complexity is one of the main things you do when doing programming</div><br/></div></div></div></div><div id="35784816" class="c"><input type="checkbox" id="c-35784816" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784773">parent</a><span>|</span><a href="#35785084">prev</a><span>|</span><a href="#35785276">next</a><span>|</span><label class="collapse" for="c-35784816">[-]</label><label class="expand" for="c-35784816">[4 more]</label></div><br/><div class="children"><div class="content">We have a history of abstraction-based code that’s turned applications into frozen balls of mud.<p>We have so many tools to help write good code that the short-term savings of shared libraries is superseded by having distinct codebases that can be modified without those dependency concerns. Same is true for finding bugs in many places and easily setting those up for maintenance releases.</div><br/><div id="35785208" class="c"><input type="checkbox" id="c-35785208" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784816">parent</a><span>|</span><a href="#35788111">next</a><span>|</span><label class="collapse" for="c-35785208">[-]</label><label class="expand" for="c-35785208">[2 more]</label></div><br/><div class="children"><div class="content">There is no going around complexity. We are absolutely standing on the shoulders of huge giants; even if you think you don’t have any dependency, behind the scenes you use many decades-old libraries dealing with the complexity of floating point arithmetics and such.<p>Also, Brooks paper is still true, the only real, significant productivity boost is reusing existing code. Even if you rewrite everything from scratch, you will still have to carry the exact same amount of essential complexity. Managing complexity is pretty much the most important part of CS.</div><br/><div id="35788164" class="c"><input type="checkbox" id="c-35788164" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785208">parent</a><span>|</span><a href="#35788111">next</a><span>|</span><label class="collapse" for="c-35788164">[-]</label><label class="expand" for="c-35788164">[1 more]</label></div><br/><div class="children"><div class="content">open any network communications protocol RFC
or any CPU design architecture
or operating systems memory tables
or operating systems filesystems with journaling
or hardware I&#x2F;O<p>it is crazy that society hasn&#x27;t collapsed yet</div><br/></div></div></div></div><div id="35788111" class="c"><input type="checkbox" id="c-35788111" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784816">parent</a><span>|</span><a href="#35785208">prev</a><span>|</span><a href="#35785276">next</a><span>|</span><label class="collapse" for="c-35788111">[-]</label><label class="expand" for="c-35788111">[1 more]</label></div><br/><div class="children"><div class="content">Some engineer from Netflix once said something along the lines: &quot;Microservices, not too many, mostly alongside team boundaries&quot;. Meaning most microservices should be wholly owned by a team and a team should ideally own only one microservice (but exceptions are allowed under special circumstances)<p>Like microservices, I feel code abstractions should be thought in a similar way, mostly a thing we use in our team, not company wide<p>In my own team I have to fight very hard to keep dependencies to external code down, the amount of entangling people are willing to put their code through is just crazy. An argument I often put is: &quot;Why should we use lib X from team Y from my company if they don&#x27;t even feel it is good enough to open source?&quot;. Any external code that my team imports into our project should be good enough it could be open sourced (given IP-rights allowing)</div><br/></div></div></div></div><div id="35785276" class="c"><input type="checkbox" id="c-35785276" checked=""/><div class="controls bullet"><span class="by">GiorgioG</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784773">parent</a><span>|</span><a href="#35784816">prev</a><span>|</span><a href="#35784636">next</a><span>|</span><label class="collapse" for="c-35785276">[-]</label><label class="expand" for="c-35785276">[3 more]</label></div><br/><div class="children"><div class="content">Over time all abstractions become “wrong” as requirements change.</div><br/><div id="35786557" class="c"><input type="checkbox" id="c-35786557" checked=""/><div class="controls bullet"><span class="by">mumblemumble</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785276">parent</a><span>|</span><a href="#35785299">next</a><span>|</span><label class="collapse" for="c-35786557">[-]</label><label class="expand" for="c-35786557">[1 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t be baking business logic into your abstractions like that.<p>Or, perhaps this is a better way of putting it: if there&#x27;s business logic mixed into it, it&#x27;s not an abstraction, it&#x27;s a concretion.</div><br/></div></div><div id="35785299" class="c"><input type="checkbox" id="c-35785299" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785276">parent</a><span>|</span><a href="#35786557">prev</a><span>|</span><a href="#35784636">next</a><span>|</span><label class="collapse" for="c-35785299">[-]</label><label class="expand" for="c-35785299">[1 more]</label></div><br/><div class="children"><div class="content">This is why refactoring is a thing.<p>Perhaps someone should write a book for managers that explains these two things.</div><br/></div></div></div></div></div></div><div id="35784636" class="c"><input type="checkbox" id="c-35784636" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35784773">prev</a><span>|</span><a href="#35788127">next</a><span>|</span><label class="collapse" for="c-35784636">[-]</label><label class="expand" for="c-35784636">[28 more]</label></div><br/><div class="children"><div class="content">&gt; Abstractions lead to coupling and complexity.<p>So you write everything in assembly and rewrite it completely for every new target system? Seems a bit tedious to me &#x2F;s<p>Just kidding abstraction serves it&#x27;s function and the right amount of abstraction makes things better, more transferable, easier to maintain etc. I think for example about hardware abstraction layers (HAL) in embedded programming. But abstraction in programming is <i>never</i> a value in itself and its use needs to be weighed carefully.<p>I think it is best to teach people to stick to the data and to think about transformations between said data. If they don&#x27;t know abstraction (aka beginner&#x27;s spaghetti code) it is worth telling them about it.</div><br/><div id="35784804" class="c"><input type="checkbox" id="c-35784804" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784636">parent</a><span>|</span><a href="#35785335">next</a><span>|</span><label class="collapse" for="c-35784804">[-]</label><label class="expand" for="c-35784804">[25 more]</label></div><br/><div class="children"><div class="content">I think ORMs fit that bill. For some reason they were (are?) incredibly popular, but I don&#x27;t think they stood the test of time. In the case of SQL, it&#x27;s already an abstraction. No need for elaborate wizardry to hide the fact you&#x27;re about to JOIN a table or two. Just write the damn join.<p>Every. Single. Project. I see using ORMs resulted in a baseline 20+ queries being fired under the hood for every screen. They are not bad in and of themselves, I think that they attract or are amenable to a certain type of development mindset that ends in bad results.<p>I have a very hard time thinking of any kind of object oriented abstraction that turned out to be a very good idea.</div><br/><div id="35787321" class="c"><input type="checkbox" id="c-35787321" checked=""/><div class="controls bullet"><span class="by">simplotek</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35784869">next</a><span>|</span><label class="collapse" for="c-35787321">[-]</label><label class="expand" for="c-35787321">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think ORMs fit that bill. For some reason they were (are?) incredibly popular, but I don&#x27;t think they stood the test of time.<p>I don&#x27;t think there is any truth at all to this personal belief. In some domains it&#x27;s unthinkable to use anything other than the standard ORM. In C# you&#x27;d need to be nuts to roll SQL by hand instead of using Entity Framework, and Django speaks for itself.<p>The only drawback of ORMs is that their promise is that developers don&#x27;t need to learn the intricacies of SQL and SQL-related design patterns, but in practice developers need to learn the intricacies of SQL, the ORM framework, and the SQL generated by the ORM. Naive developers might believe they are better off reinventing the wheel with ad-hoc SQL stuff, but that&#x27;s another problem.</div><br/><div id="35788247" class="c"><input type="checkbox" id="c-35788247" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35787321">parent</a><span>|</span><a href="#35784869">next</a><span>|</span><label class="collapse" for="c-35788247">[-]</label><label class="expand" for="c-35788247">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think you are right to add the “depending on your environment” caveat. I have no experience in the Windows domain.</div><br/></div></div></div></div><div id="35784869" class="c"><input type="checkbox" id="c-35784869" checked=""/><div class="controls bullet"><span class="by">regularfry</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35787321">prev</a><span>|</span><a href="#35785199">next</a><span>|</span><label class="collapse" for="c-35784869">[-]</label><label class="expand" for="c-35784869">[2 more]</label></div><br/><div class="children"><div class="content">OO abstractions are very effective in UI toolkits, but because a smaller proportion of folk are working on desktop apps any more, people tend not to get exposed to that use case.<p>I also think it depends on the type of ORM.  Active Record?  <i>Really</i> problematic except for simple use cases but because they make those simple cases easy they get popular on that basis.  Data Mapper?  Actually fine and very useful, but harder to write well and a bit harder to use.</div><br/><div id="35785867" class="c"><input type="checkbox" id="c-35785867" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784869">parent</a><span>|</span><a href="#35785199">next</a><span>|</span><label class="collapse" for="c-35785867">[-]</label><label class="expand" for="c-35785867">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s actually a good point. UI widgets map nicely to objects, at least usually.</div><br/></div></div></div></div><div id="35785199" class="c"><input type="checkbox" id="c-35785199" checked=""/><div class="controls bullet"><span class="by">bzzzt</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35784869">prev</a><span>|</span><a href="#35785240">next</a><span>|</span><label class="collapse" for="c-35785199">[-]</label><label class="expand" for="c-35785199">[9 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t imagine programmers using reasonably well tested and documented ORMs and still firing a minimum of 20 queries would be capable of writing a nice and equally bug-free SQL interface in place of that ORM...</div><br/><div id="35785570" class="c"><input type="checkbox" id="c-35785570" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785199">parent</a><span>|</span><a href="#35785403">next</a><span>|</span><label class="collapse" for="c-35785570">[-]</label><label class="expand" for="c-35785570">[7 more]</label></div><br/><div class="children"><div class="content">I think the use of ORMs by people who understand databases is fine. I think when ORMs turn into, “you don’t need to know SQL!” Is when things go off the rails.<p>Everyone (management) wants a way to get productivity without loads of experience and tools that promise that tend to be misleading.</div><br/><div id="35785723" class="c"><input type="checkbox" id="c-35785723" checked=""/><div class="controls bullet"><span class="by">segfaltnh</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785570">parent</a><span>|</span><a href="#35785403">next</a><span>|</span><label class="collapse" for="c-35785723">[-]</label><label class="expand" for="c-35785723">[6 more]</label></div><br/><div class="children"><div class="content">Are there really software jobs where managers are the ones making decisions like whether or not to use ORMs? Some of these comments make me feel like I&#x27;ve had a truly blessed career.</div><br/><div id="35785991" class="c"><input type="checkbox" id="c-35785991" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785723">parent</a><span>|</span><a href="#35786001">next</a><span>|</span><label class="collapse" for="c-35785991">[-]</label><label class="expand" for="c-35785991">[4 more]</label></div><br/><div class="children"><div class="content">You better believe you have had a truly blessed career.<p>In most places the moment you say &quot;this will take 67 minutes and not the 65 minutes you thought it would&quot;, all sorts of idiots that know nothing about programming will come and dispute your every technical decision.<p>Exaggeration of course, but not far from the truth. Worst of all are the CTOs that already sing only the CEO&#x27;s tune, come and review your entire project in exhaustive detail, conclude that you did 99% of everything correctly and well and exactly how they would do it, then proceed to fire you over the missing 1%.<p>Again, kind of an exaggeration, but again, not far from the truth either.<p>In most places people are treated like interchangeable cogs. Better hold tight to your warm positions, it&#x27;s not a given you&#x27;ll find a better one if you figure that you must leave.<p>I dream of a workplace where after I prove my worth -- 1-2 months -- I&#x27;ll just be left alone to produce and correct code and protect the company&#x27;s interests without being second-guessed, even though I am one of the most productive devs there. I dream of that. I might cry if one day I realize that I&#x27;ve actually landed such a job.<p>And I am a senior. 21 years in the profession. Food for thought for you.<p>It&#x27;s all about who you know and drink coffee with, apparently. Your abilities as a professional barely matter, it seems.</div><br/><div id="35786167" class="c"><input type="checkbox" id="c-35786167" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785991">parent</a><span>|</span><a href="#35786001">next</a><span>|</span><label class="collapse" for="c-35786167">[-]</label><label class="expand" for="c-35786167">[3 more]</label></div><br/><div class="children"><div class="content">I’ve only worked in a few large companies where nobody even cared about code quality unless you brought down a production system with a bad change or something.<p>You’re seriously saying you’ve had 21 years of constantly being second guessed? What kinds of places are you working at?</div><br/><div id="35786230" class="c"><input type="checkbox" id="c-35786230" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35786167">parent</a><span>|</span><a href="#35786353">next</a><span>|</span><label class="collapse" for="c-35786230">[-]</label><label class="expand" for="c-35786230">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been a contractor in the last 7 years and I&#x27;ve come to dearly regret it.<p>Never has my work been so second-guessed and ripped apart. I suppose my price was too high for them, not sure.<p>I&#x27;m still reflecting and have no good conclusions to offer.<p>(But part of the time I was in bad health and my work quality suffered. So that explains one percentage of the cases at least.)</div><br/></div></div><div id="35786353" class="c"><input type="checkbox" id="c-35786353" checked=""/><div class="controls bullet"><span class="by">MyneOutside</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35786167">parent</a><span>|</span><a href="#35786230">prev</a><span>|</span><a href="#35786001">next</a><span>|</span><label class="collapse" for="c-35786353">[-]</label><label class="expand" for="c-35786353">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing this 15 years and I&#x27;ve been dealing with second guessing or managers acting like we don&#x27;t know what we are doing the whole time. The problem being the managers are MBAs who know little or next to nothing about software development. They don&#x27;t like being told differently from whatever narrative they come up with and primarily solely focus on cost.<p>The company I work for considers themself a MSP. The parent company is a sales company selling non software products.<p>In any case, yeah it happens.</div><br/></div></div></div></div></div></div><div id="35786001" class="c"><input type="checkbox" id="c-35786001" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785723">parent</a><span>|</span><a href="#35785991">prev</a><span>|</span><a href="#35785403">next</a><span>|</span><label class="collapse" for="c-35786001">[-]</label><label class="expand" for="c-35786001">[1 more]</label></div><br/><div class="children"><div class="content">It’s usually indirect, “only use libraries from these approved internal systems”, “new projects use these templates”… etc. Eventually to go against this set of standards make you appear to be a squeaky wheel while everyone else seems to be working just fine.</div><br/></div></div></div></div></div></div><div id="35785403" class="c"><input type="checkbox" id="c-35785403" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785199">parent</a><span>|</span><a href="#35785570">prev</a><span>|</span><a href="#35785240">next</a><span>|</span><label class="collapse" for="c-35785403">[-]</label><label class="expand" for="c-35785403">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you are wrong and that&#x27;s the actual cause of the problems, not the tools. But that&#x27;s for another day..</div><br/></div></div></div></div><div id="35785240" class="c"><input type="checkbox" id="c-35785240" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35785199">prev</a><span>|</span><a href="#35785340">next</a><span>|</span><label class="collapse" for="c-35785240">[-]</label><label class="expand" for="c-35785240">[1 more]</label></div><br/><div class="children"><div class="content">ORMs are okay, people just don’t know when to use them. They were always meant for OLTP, not OLAP workloads.<p>How else would you update this record, plus 10 other record pointing to it? That’s the point of ORMs, “writing” the boilerplate SQL for you, and also the other direction, mapping records to objects.<p>It’s not the tools problem that people refuse to learn new things and misuse it.</div><br/></div></div><div id="35785340" class="c"><input type="checkbox" id="c-35785340" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35785240">prev</a><span>|</span><a href="#35784945">next</a><span>|</span><label class="collapse" for="c-35785340">[-]</label><label class="expand" for="c-35785340">[1 more]</label></div><br/><div class="children"><div class="content">The whole concept of a database as a separate system is an abstraction. An extremely successful one.</div><br/></div></div><div id="35784945" class="c"><input type="checkbox" id="c-35784945" checked=""/><div class="controls bullet"><span class="by">futureduck</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35785340">prev</a><span>|</span><a href="#35784852">next</a><span>|</span><label class="collapse" for="c-35784945">[-]</label><label class="expand" for="c-35784945">[1 more]</label></div><br/><div class="children"><div class="content">I second that OO abstractions shine in UI systems. Most complex UI applications  use some form of ECS these days.</div><br/></div></div><div id="35784852" class="c"><input type="checkbox" id="c-35784852" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35784945">prev</a><span>|</span><a href="#35784833">next</a><span>|</span><label class="collapse" for="c-35784852">[-]</label><label class="expand" for="c-35784852">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve yet to encounter a single project which does not use ORM. Everyone uses it. So they definitely stood test of time. And popularity of ORMs says more about issues with bare SQL approach. IMO SQL is just bad. Developers want JSON, not CSV. Developers want to specify conditions with lambdas, not with strings.</div><br/><div id="35785008" class="c"><input type="checkbox" id="c-35785008" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784852">parent</a><span>|</span><a href="#35784833">next</a><span>|</span><label class="collapse" for="c-35785008">[-]</label><label class="expand" for="c-35785008">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t the &quot;everyone uses it&quot; argument works here. Sure, it has a lot of momentum, but I&#x27;m just not seeing the proposed productivity enhancements. I actually just spent a significant chunk of time to de-ORM a system to get some performance and, more importantly, clarity back.<p>IMO it&#x27;s way, way easier to look at some queries instead of some leaky abstraction (on <i>top</i> of the already leaky abstraction that is SQL).<p>Again, I really don&#x27;t think popularity is a sane metric anymore. (React, &quot;Astro&quot;, Angular, web-dev in general)<p>Edit: I&#x27;m very much in a bubble. A lot depends on your tooling and environment. For example I can appreciate it being different in an MS environment with stuff like linq. I&#x27;m not in that environment.</div><br/></div></div></div></div><div id="35784833" class="c"><input type="checkbox" id="c-35784833" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784804">parent</a><span>|</span><a href="#35784852">prev</a><span>|</span><a href="#35785335">next</a><span>|</span><label class="collapse" for="c-35784833">[-]</label><label class="expand" for="c-35784833">[6 more]</label></div><br/><div class="children"><div class="content">Relational databases are an operational anti-pattern. ORMs have proven that.</div><br/><div id="35785750" class="c"><input type="checkbox" id="c-35785750" checked=""/><div class="controls bullet"><span class="by">segfaltnh</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784833">parent</a><span>|</span><a href="#35784966">next</a><span>|</span><label class="collapse" for="c-35785750">[-]</label><label class="expand" for="c-35785750">[1 more]</label></div><br/><div class="children"><div class="content">I have the opposite feeling on RDBMS, based on my limited experience. I think you need a good reason to deviate from it, which is often very large scale. I&#x27;d say 99% of applications written are no where near this scale.</div><br/></div></div><div id="35784966" class="c"><input type="checkbox" id="c-35784966" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784833">parent</a><span>|</span><a href="#35785750">prev</a><span>|</span><a href="#35785335">next</a><span>|</span><label class="collapse" for="c-35784966">[-]</label><label class="expand" for="c-35784966">[4 more]</label></div><br/><div class="children"><div class="content">Relational databases have shown, and will continue to show more longevity than object orientation.<p>Facts and the relationships between facts is a deeper foundational principle than the concept mashup of modularity, hidden [mutable] state, dynamic dispatch and interface subtyping that object orientation is formed from. Databases are more long-lived than applications, so applications tend towards adapting to the form of the data rather than the other way around.</div><br/><div id="35788274" class="c"><input type="checkbox" id="c-35788274" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784966">parent</a><span>|</span><a href="#35785283">next</a><span>|</span><label class="collapse" for="c-35788274">[-]</label><label class="expand" for="c-35788274">[1 more]</label></div><br/><div class="children"><div class="content">relational databases are backed by relational algebra, an actual formal math definition. You can prove theorems like the output of Query X is equal to the output of Query Y, but Query Y is likely to run faster so that is what we will run<p>You can&#x27;t outdate math (you can outdate math notation though, finding better ways to express the same information). To be fair SQL is not 100% relational algebra compatible, but it is close enough</div><br/></div></div><div id="35785283" class="c"><input type="checkbox" id="c-35785283" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784966">parent</a><span>|</span><a href="#35788274">prev</a><span>|</span><a href="#35785945">next</a><span>|</span><label class="collapse" for="c-35785283">[-]</label><label class="expand" for="c-35785283">[1 more]</label></div><br/><div class="children"><div class="content">The concept of mashup of modularity, hidden mutable state and dynamic dispatch, etc also stood its time, and so do relational databases.<p>There is a mismatch between the two models, but it can make sense to think of the entities at hand as objects at times, and relational data at other times. That’s why ORMs are a thing, and also why most popular programming language nowadays are multi-paradigm, so they can also support a more data-oriented approach.</div><br/></div></div></div></div></div></div></div></div><div id="35785335" class="c"><input type="checkbox" id="c-35785335" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784636">parent</a><span>|</span><a href="#35784804">prev</a><span>|</span><a href="#35784811">next</a><span>|</span><label class="collapse" for="c-35785335">[-]</label><label class="expand" for="c-35785335">[1 more]</label></div><br/><div class="children"><div class="content">Actually it would have to be numeric codes, as Assembly is also an abstraction. :)</div><br/></div></div><div id="35784811" class="c"><input type="checkbox" id="c-35784811" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784636">parent</a><span>|</span><a href="#35785335">prev</a><span>|</span><a href="#35788127">next</a><span>|</span><label class="collapse" for="c-35784811">[-]</label><label class="expand" for="c-35784811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But abstraction in programming is never a value in itself and its use needs to be weighed carefully.<p>I think this generalises well to anything in (or outside) programming. Slavish adherence to any principle without consideration for the underlying merits of the situation is likely to become a negative.</div><br/></div></div></div></div><div id="35788127" class="c"><input type="checkbox" id="c-35788127" checked=""/><div class="controls bullet"><span class="by">qumpis</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35784636">prev</a><span>|</span><a href="#35785993">next</a><span>|</span><label class="collapse" for="c-35788127">[-]</label><label class="expand" for="c-35788127">[1 more]</label></div><br/><div class="children"><div class="content">This might not be a perspective of a programmer, but the code I&#x27;ve reviewed and tried to understand from academics is always easier to manage when it&#x27;s not abstracted  too deeply. Especially when reading the code is the main reason for trying to understand the underlying idea.<p>Unless you have an extensive (visual?) representation of how the code flows, abstracted code for beginners might be a hindrance towards understanding what&#x27;s happening at the lowest level while still maintaining the contours of the whole thing.<p>Of course when everyone&#x27;s on the same page and has similar understanding, this is no longer a concern.</div><br/></div></div><div id="35785993" class="c"><input type="checkbox" id="c-35785993" checked=""/><div class="controls bullet"><span class="by">ericjmorey</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35788127">prev</a><span>|</span><a href="#35786511">next</a><span>|</span><label class="collapse" for="c-35785993">[-]</label><label class="expand" for="c-35785993">[1 more]</label></div><br/><div class="children"><div class="content">Could you share a few examples of what you consider outdated principles?</div><br/></div></div><div id="35786511" class="c"><input type="checkbox" id="c-35786511" checked=""/><div class="controls bullet"><span class="by">favadi</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35785993">prev</a><span>|</span><a href="#35785112">next</a><span>|</span><label class="collapse" for="c-35786511">[-]</label><label class="expand" for="c-35786511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Abstractions lead to coupling and complexity.<p>Without abstractions, we would still programming using punched cards.</div><br/></div></div><div id="35785112" class="c"><input type="checkbox" id="c-35785112" checked=""/><div class="controls bullet"><span class="by">oslac</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35786511">prev</a><span>|</span><a href="#35784634">next</a><span>|</span><label class="collapse" for="c-35785112">[-]</label><label class="expand" for="c-35785112">[2 more]</label></div><br/><div class="children"><div class="content">Having read through the old version I cannot recommend that one either.</div><br/><div id="35785982" class="c"><input type="checkbox" id="c-35785982" checked=""/><div class="controls bullet"><span class="by">ericjmorey</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785112">parent</a><span>|</span><a href="#35784634">next</a><span>|</span><label class="collapse" for="c-35785982">[-]</label><label class="expand" for="c-35785982">[1 more]</label></div><br/><div class="children"><div class="content">Would you care to elaborate?</div><br/></div></div></div></div><div id="35784634" class="c"><input type="checkbox" id="c-35784634" checked=""/><div class="controls bullet"><span class="by">geokon</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35785112">prev</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35784634">[-]</label><label class="expand" for="c-35784634">[8 more]</label></div><br/><div class="children"><div class="content">I also found the outside-in way they solve problems (using stubs for inner calls) very bizarre. I could be wrong.. But I don&#x27;t think anyone codes like that</div><br/><div id="35786276" class="c"><input type="checkbox" id="c-35786276" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784634">parent</a><span>|</span><a href="#35784807">next</a><span>|</span><label class="collapse" for="c-35786276">[-]</label><label class="expand" for="c-35786276">[1 more]</label></div><br/><div class="children"><div class="content">I code like that. I got burned one too many times spending hours&#x2F;days on an inner call that turned out to be unnecessary. When you solve outside-in, you are sure you&#x27;re solving the right problem in the right way without overcommitting to intermediate steps.</div><br/></div></div><div id="35784807" class="c"><input type="checkbox" id="c-35784807" checked=""/><div class="controls bullet"><span class="by">regularfry</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784634">parent</a><span>|</span><a href="#35786276">prev</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35784807">[-]</label><label class="expand" for="c-35784807">[6 more]</label></div><br/><div class="children"><div class="content">&quot;Using stubs for inner calls&quot; is literally a top-level description of London-style TDD.</div><br/><div id="35785045" class="c"><input type="checkbox" id="c-35785045" checked=""/><div class="controls bullet"><span class="by">kmac_</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784807">parent</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35785045">[-]</label><label class="expand" for="c-35785045">[5 more]</label></div><br/><div class="children"><div class="content">Only Detroid school! Mocks should be banned (unless they mock external system). London-style tests cargo culting is one of the reasons why OOP got bad name.</div><br/><div id="35785242" class="c"><input type="checkbox" id="c-35785242" checked=""/><div class="controls bullet"><span class="by">regularfry</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785045">parent</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35785242">[-]</label><label class="expand" for="c-35785242">[4 more]</label></div><br/><div class="children"><div class="content">Leaving mocks in place once you&#x27;re done should be banned, I agree with that.  I think they&#x27;re fine as an exploratory tool to figure out what an interface should look like.</div><br/><div id="35785555" class="c"><input type="checkbox" id="c-35785555" checked=""/><div class="controls bullet"><span class="by">kmac_</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785242">parent</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35785555">[-]</label><label class="expand" for="c-35785555">[3 more]</label></div><br/><div class="children"><div class="content">Mocks means that there&#x27;s a side effect neccessary (and that&#x27;s quite rare) so the use is justified in such a case. If a stub is needed, then mostly it&#x27;s gone when the code is refactored to a more functional style.<p>Unfortunately, most OOP developers bury side effects at the bottom of the stack, instead of passing an object that describes the side effect to happen (which it&#x27;s executed at the shallow and simple application layer).<p>Said result object can be tested as any other function result and no mocking is required.</div><br/><div id="35785781" class="c"><input type="checkbox" id="c-35785781" checked=""/><div class="controls bullet"><span class="by">segfaltnh</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785555">parent</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35785781">[-]</label><label class="expand" for="c-35785781">[2 more]</label></div><br/><div class="children"><div class="content">I love this sort of approach for one-shot externalities but what about when your entire program is a conversation with external components? My current project coordinates software repositories and services within AWS and I find myself using a lot of mocks in testing.<p>I can return a tree of lambdas but then I have to resolve them against something and that&#x27;s just replacing mocks with lambdas, really. Not sure it&#x27;s any better in practice.</div><br/><div id="35786057" class="c"><input type="checkbox" id="c-35786057" checked=""/><div class="controls bullet"><span class="by">kmac_</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35785781">parent</a><span>|</span><a href="#35784622">next</a><span>|</span><label class="collapse" for="c-35786057">[-]</label><label class="expand" for="c-35786057">[1 more]</label></div><br/><div class="children"><div class="content">Great question! I worked with two approaches:
1. Sagas - a centralised place to handle bussines flows
2. Event system<p>Start with 1. and eventually (pun intended) move to 2.
Both ways allow parallelized interactions with external systems, deferred decisions, etc. whatever the bussines will require.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="35784622" class="c"><input type="checkbox" id="c-35784622" checked=""/><div class="controls bullet"><span class="by">Hypergraphe</span><span>|</span><a href="#35784582">parent</a><span>|</span><a href="#35784634">prev</a><span>|</span><a href="#35785748">next</a><span>|</span><label class="collapse" for="c-35784622">[-]</label><label class="expand" for="c-35784622">[5 more]</label></div><br/><div class="children"><div class="content">In fact, that could be useful to ellaborate a bit.</div><br/><div id="35784650" class="c"><input type="checkbox" id="c-35784650" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784622">parent</a><span>|</span><a href="#35785748">next</a><span>|</span><label class="collapse" for="c-35784650">[-]</label><label class="expand" for="c-35784650">[4 more]</label></div><br/><div class="children"><div class="content">Primarily this book completely ignores communication with subject matter experts and the business. This is fundamentally more important than any language, process, or platform.</div><br/><div id="35784815" class="c"><input type="checkbox" id="c-35784815" checked=""/><div class="controls bullet"><span class="by">Ligma123</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784650">parent</a><span>|</span><a href="#35786234">next</a><span>|</span><label class="collapse" for="c-35784815">[-]</label><label class="expand" for="c-35784815">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Primarily this book completely ignores communication with subject matter experts and the business.<p>Probably because this isn&#x27;t an advanced book on Software Engineering, but an introductory book to programming.</div><br/></div></div><div id="35786234" class="c"><input type="checkbox" id="c-35786234" checked=""/><div class="controls bullet"><span class="by">sussmannbaka</span><span>|</span><a href="#35784582">root</a><span>|</span><a href="#35784650">parent</a><span>|</span><a href="#35784815">prev</a><span>|</span><a href="#35784714">next</a><span>|</span><label class="collapse" for="c-35786234">[-]</label><label class="expand" for="c-35786234">[1 more]</label></div><br/><div class="children"><div class="content">This is wrong, it’s a core part of the design process as described in the book.</div><br/></div></div></div></div></div></div></div></div><div id="35785748" class="c"><input type="checkbox" id="c-35785748" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#35784582">prev</a><span>|</span><label class="collapse" for="c-35785748">[-]</label><label class="expand" for="c-35785748">[9 more]</label></div><br/><div class="children"><div class="content">Programming is simple. The fact is that there exists a document like this proves that human is flaw to explain simple things.</div><br/><div id="35787225" class="c"><input type="checkbox" id="c-35787225" checked=""/><div class="controls bullet"><span class="by">hibbelig</span><span>|</span><a href="#35785748">parent</a><span>|</span><a href="#35787116">next</a><span>|</span><label class="collapse" for="c-35787225">[-]</label><label class="expand" for="c-35787225">[1 more]</label></div><br/><div class="children"><div class="content">Programming is simple in the same way playing the piano is: You just press a key and out comes a note.  Yet somehow, depending on who presses those keys, out comes beautiful music or horrible noise.<p>Sure, anyone can write and understand &quot;ADD A TO B GIVING C&quot;, just like anyone can press a key on the piano.  But the resulting program is a different matter entirely.</div><br/></div></div><div id="35787116" class="c"><input type="checkbox" id="c-35787116" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35785748">parent</a><span>|</span><a href="#35787225">prev</a><span>|</span><a href="#35786144">next</a><span>|</span><label class="collapse" for="c-35787116">[-]</label><label class="expand" for="c-35787116">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a meaningless claim.<p>There are two different axes by which programming can be arbitrarily complicated, one being more of a &quot;vertical&quot; one, where the state space is not too wide, but complex to get right - think of a quicksort at a lower difficulty, and some parallel algorithm on the other end.<p>The other dimension would be more &quot;horizontal&quot;, like here is the service which would not be all that complex in itself, but it has different requirements based on country, with different access control, the whole state machine of a given entry also can change between legislatures and might be updated at any time, etc. This is complex similarly to how a biological cell is -- it has a bunch of legacy&#x2F;redundancy getting added to it over time. For another example, dates&#x2F;time libraries -- it is not complex computationally in itself, but due to all the edge cases it is absolutely not a trivial program to write.<p>Not really sure whether these categories have names to them, but I think these are fundamentally different (but a program may be complex from both axes).</div><br/></div></div><div id="35786144" class="c"><input type="checkbox" id="c-35786144" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#35785748">parent</a><span>|</span><a href="#35787116">prev</a><span>|</span><a href="#35786603">next</a><span>|</span><label class="collapse" for="c-35786144">[-]</label><label class="expand" for="c-35786144">[2 more]</label></div><br/><div class="children"><div class="content">Writing a sentence is simple, yet there are many skills to learn to do it well.</div><br/><div id="35786152" class="c"><input type="checkbox" id="c-35786152" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#35785748">root</a><span>|</span><a href="#35786144">parent</a><span>|</span><a href="#35786603">next</a><span>|</span><label class="collapse" for="c-35786152">[-]</label><label class="expand" for="c-35786152">[1 more]</label></div><br/><div class="children"><div class="content">Correct. But it didn&#x27;t disaproove the original statement.</div><br/></div></div></div></div><div id="35786603" class="c"><input type="checkbox" id="c-35786603" checked=""/><div class="controls bullet"><span class="by">brbrodude</span><span>|</span><a href="#35785748">parent</a><span>|</span><a href="#35786144">prev</a><span>|</span><a href="#35786196">next</a><span>|</span><label class="collapse" for="c-35786603">[-]</label><label class="expand" for="c-35786603">[1 more]</label></div><br/><div class="children"><div class="content">`In fact, if treated properly, most programming things are hard, even things that might seem simple. That is because you have complex pieces that you have to put together and to make them work. And the hardest part is when one has to write the complex pieces from scratch. Things only seem easy because you have people with 5, 10, 20 years of experience doing things that are easy to them because they did them many times before, because they made all the possible mistakes or thought about them and made sure they don’t fall in those traps.`
<a href="https:&#x2F;&#x2F;dorinlazar.ro&#x2F;2021-02-programming-is-hard&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dorinlazar.ro&#x2F;2021-02-programming-is-hard&#x2F;</a></div><br/></div></div><div id="35786196" class="c"><input type="checkbox" id="c-35786196" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#35785748">parent</a><span>|</span><a href="#35786603">prev</a><span>|</span><label class="collapse" for="c-35786196">[-]</label><label class="expand" for="c-35786196">[3 more]</label></div><br/><div class="children"><div class="content">Can you provide an example of something you consider to be complicated? I’d like to know how to calibrate your comment.</div><br/><div id="35786277" class="c"><input type="checkbox" id="c-35786277" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#35785748">root</a><span>|</span><a href="#35786196">parent</a><span>|</span><label class="collapse" for="c-35786277">[-]</label><label class="expand" for="c-35786277">[2 more]</label></div><br/><div class="children"><div class="content">Try to read: Category theory for programmers. Wait, absolutely nonsense ;)</div><br/><div id="35786347" class="c"><input type="checkbox" id="c-35786347" checked=""/><div class="controls bullet"><span class="by">soegaard</span><span>|</span><a href="#35785748">root</a><span>|</span><a href="#35786277">parent</a><span>|</span><label class="collapse" for="c-35786347">[-]</label><label class="expand" for="c-35786347">[1 more]</label></div><br/><div class="children"><div class="content">Abstract nonsense!<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Abstract_nonsense" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Abstract_nonsense</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>