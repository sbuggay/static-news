<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733216467547" as="style"/><link rel="stylesheet" href="styles.css?v=1733216467547"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lore.kernel.org/all/cc40943e-dec1-4890-a1d9-579350ce296f@pbonzini.local/">Rust in QEMU Roadmap</a>Â <span class="domain">(<a href="https://lore.kernel.org">lore.kernel.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>14 comments</span></div><br/><div><div id="42254353" class="c"><input type="checkbox" id="c-42254353" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#42303721">next</a><span>|</span><label class="collapse" for="c-42254353">[-]</label><label class="expand" for="c-42254353">[7 more]</label></div><br/><div class="children"><div class="content">Thanks for posting this to HN! Author here, happy to answer any questions.<p>(By the way, I did not originally start the project, though I&#x27;ve worked quite a bit on the safe abstractions that are mentioned in the roadmap).</div><br/><div id="42303956" class="c"><input type="checkbox" id="c-42303956" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#42254353">parent</a><span>|</span><a href="#42303318">next</a><span>|</span><label class="collapse" for="c-42303956">[-]</label><label class="expand" for="c-42303956">[2 more]</label></div><br/><div class="children"><div class="content">What does your wishlist for Rust look like? (Besides &quot;simpler C&#x2F;Rust interoperability&quot;, of course.) Has QEMU run into things that Rust-for-Linux hasn&#x27;t, that feel missing from the Rust language?</div><br/><div id="42304008" class="c"><input type="checkbox" id="c-42304008" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#42254353">root</a><span>|</span><a href="#42303956">parent</a><span>|</span><a href="#42303318">next</a><span>|</span><label class="collapse" for="c-42304008">[-]</label><label class="expand" for="c-42304008">[1 more]</label></div><br/><div class="children"><div class="content">Right now the only language-level thing I would like is const operator overloading. Even supporting MSRV as old as 1.63 was not a big deal, the worst thing was dependencies using let...else which we will vendor and patch.<p>Pin is what it is, but it is mostly okay since I haven&#x27;t needed projection so far. Initialization using Linux&#x27;s &quot;impl PinInit&lt;Self&gt;&quot; approach seems to be working very well in my early experiments, I contributed changes to use the crate without unstable features.<p>In the FFI area: Bindgen support for toml configuration (<a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-bindgen&#x2F;pull&#x2F;2917">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-bindgen&#x2F;pull&#x2F;2917</a> but it could also be response files on the command line), and easier passing of closures from Rust to C (though I found a very nice way to do it for ZSTs that implement Fn, which is by far the common case).<p>The &quot;data structure interoperability&quot; part of the roadmap is something I should present to someone in the Rust community for impressions. Some kind of standardization of core FFI traits would be nice.<p>Outside the Rust core proper, Meson support needs to mature a bit for ease of use, but it is getting there. Linux obviously doesn&#x27;t need that.<p>BTW, saw your comment in the dead thread, you&#x27;re too nice. I have been curious about Rust for some time and with Linux maturing, and Linaro doing the first contribution of build system integration + sample device code, it was time to give it a try.</div><br/></div></div></div></div><div id="42303318" class="c"><input type="checkbox" id="c-42303318" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#42254353">parent</a><span>|</span><a href="#42303956">prev</a><span>|</span><a href="#42303721">next</a><span>|</span><label class="collapse" for="c-42303318">[-]</label><label class="expand" for="c-42303318">[4 more]</label></div><br/><div class="children"><div class="content">Bullish or bearish on rust in the kernel?</div><br/><div id="42303332" class="c"><input type="checkbox" id="c-42303332" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#42254353">root</a><span>|</span><a href="#42303318">parent</a><span>|</span><a href="#42303721">next</a><span>|</span><label class="collapse" for="c-42303332">[-]</label><label class="expand" for="c-42303332">[3 more]</label></div><br/><div class="children"><div class="content">Hello! Small world. :)<p>For drivers, it&#x27;s already happening, especially for graphics but not limited to that. 6.13 has some very important changes. A lot of Linux is drivers so that&#x27;s already a reason to be bullish.<p>Answering for QEMU instead: it depends on the community being willing to share the burden of writing the FFI code. Despite Rust being low level, there is still a substantial amount of work to do. Replies to the roadmap pointed out tracepoints as an area where I know nothing and therefore I would like someone else to do the work (I am working mostly on the object and threading models, which is also where a lot of the impedance mismatch between Rust and C lies).</div><br/><div id="42303847" class="c"><input type="checkbox" id="c-42303847" checked=""/><div class="controls bullet"><span class="by">aapoalas</span><span>|</span><a href="#42254353">root</a><span>|</span><a href="#42303332">parent</a><span>|</span><a href="#42303721">next</a><span>|</span><label class="collapse" for="c-42303847">[-]</label><label class="expand" for="c-42303847">[2 more]</label></div><br/><div class="children"><div class="content">Hello. I assume tracepoints mean kprobes&#x2F;uprobes or something along those lines? I&#x27;ve just this weekend worked on implementing&#x2F;adapting a crate for DTrace USDTs aka DTrace probes to also work on Linux and generate SystemTap SDTs (aka USDTs aka dtrace probes).<p>This is probably a little different from tracepoints in the kernel space but I&#x27;m somewhat interested in going deeper and into the kernel side of things. Let me know if you have any pointers as to where I might be of concrete assistance to you!</div><br/><div id="42303900" class="c"><input type="checkbox" id="c-42303900" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#42254353">root</a><span>|</span><a href="#42303847">parent</a><span>|</span><a href="#42303721">next</a><span>|</span><label class="collapse" for="c-42303900">[-]</label><label class="expand" for="c-42303900">[1 more]</label></div><br/><div class="children"><div class="content">QEMU has several tracepoint providers, the main ones are (a slightly fancy version of) printf and USDT. There is a Python program that generates the C code for the chosen backend(s), so the thing to do would be to adjust the script to produce either an FFI bridge or the equivalent Rust code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>