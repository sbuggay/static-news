<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734944451746" as="style"/><link rel="stylesheet" href="styles.css?v=1734944451746"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: Who&#x27;s building on Python NoGIL?</a> </div><div class="subtext"><span>grandimam</span> | <span>40 comments</span></div><br/><div><div id="42483992" class="c"><input type="checkbox" id="c-42483992" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42476748">next</a><span>|</span><label class="collapse" for="c-42483992">[-]</label><label class="expand" for="c-42483992">[3 more]</label></div><br/><div class="children"><div class="content">This is going to be bananas for libpython-clj[1].  One of the biggest limiting factors right now is that you can&#x27;t mix Java&#x2F;Clojure concurrency with Python concurrency, you need to have a really clear separation of concurrency models.  But with this, you will be able to freely mix Clojure and Python concurrency.  Just from a compositional standpoint, Clojure atoms and core.async with Python functions will be fantastic. More practically, this will unlock a lot of performance gains with PyTorch and Tensorflow which historically we&#x27;ve had to lock to single threaded mode. Yay!<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;clj-python&#x2F;libpython-clj">https:&#x2F;&#x2F;github.com&#x2F;clj-python&#x2F;libpython-clj</a></div><br/><div id="42488728" class="c"><input type="checkbox" id="c-42488728" checked=""/><div class="controls bullet"><span class="by">jwindle47</span><span>|</span><a href="#42483992">parent</a><span>|</span><a href="#42484955">prev</a><span>|</span><a href="#42476748">next</a><span>|</span><label class="collapse" for="c-42488728">[-]</label><label class="expand" for="c-42488728">[1 more]</label></div><br/><div class="children"><div class="content">I’m here for it :) love the Clojure approach to symbiosis. Parens consume all the things!</div><br/></div></div></div></div><div id="42476748" class="c"><input type="checkbox" id="c-42476748" checked=""/><div class="controls bullet"><span class="by">bionhoward</span><span>|</span><a href="#42483992">prev</a><span>|</span><a href="#42485101">next</a><span>|</span><label class="collapse" for="c-42476748">[-]</label><label class="expand" for="c-42476748">[13 more]</label></div><br/><div class="children"><div class="content">PyO3 0.23.0 was a big release I’ve been tinkering with extensively. Support for “free-threaded Python” is a headline feature, and I imagine NoGIL Python will be extremely nice for Rust interoperability, so there is definitely interest in that crate. Also could be huge for queueing data for GPUs, api servers, and bulk data fetching.<p>For whatever reason (maybe post 2to3 PTSD), Python community seems not extremely eager to jump on latest versions of Python and it often takes a long time for popular libraries to support the latest and greatest, so I’d recommend patience and baby steps<p><a href="https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3&#x2F;releases&#x2F;tag&#x2F;v0.23.0">https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3&#x2F;releases&#x2F;tag&#x2F;v0.23.0</a></div><br/><div id="42483323" class="c"><input type="checkbox" id="c-42483323" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42476748">parent</a><span>|</span><a href="#42485101">next</a><span>|</span><label class="collapse" for="c-42483323">[-]</label><label class="expand" for="c-42483323">[12 more]</label></div><br/><div class="children"><div class="content">&gt; For whatever reason (maybe post 2to3 PTSD), Python community seems not extremely eager to jump on latest versions of Python<p>Well, you&#x27;d think after the 2 to 3 debacle, python might take backwards compatibility more seriously, but they don&#x27;t.<p>Follow semver, and stop breaking things on 3.x. If it&#x27;s deprecated in 3.x, don&#x27;t remove it until 4.</div><br/><div id="42484011" class="c"><input type="checkbox" id="c-42484011" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42483323">parent</a><span>|</span><a href="#42483562">next</a><span>|</span><label class="collapse" for="c-42484011">[-]</label><label class="expand" for="c-42484011">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s even a plan for a v4. The fallout from 2 to 3 was that bad. So to keep improvements going takes deprecating something several versions before removing, and research is done to find how popular that particular thing is to determine its candidacy for removal. Thus it&#x27;s best practice to pin all dependencies, and read the release notes before doing a version update.</div><br/><div id="42484128" class="c"><input type="checkbox" id="c-42484128" checked=""/><div class="controls bullet"><span class="by">Numerlor</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42484011">parent</a><span>|</span><a href="#42483562">next</a><span>|</span><label class="collapse" for="c-42484128">[-]</label><label class="expand" for="c-42484128">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;d be better if the name was understood as python 3 instead of just python to avoid mixing in semver</div><br/></div></div></div></div><div id="42483562" class="c"><input type="checkbox" id="c-42483562" checked=""/><div class="controls bullet"><span class="by">throwaway127482</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42483323">parent</a><span>|</span><a href="#42484011">prev</a><span>|</span><a href="#42492454">next</a><span>|</span><label class="collapse" for="c-42483562">[-]</label><label class="expand" for="c-42483562">[8 more]</label></div><br/><div class="children"><div class="content">What have they broken on 3.x? Genuine question as I haven&#x27;t followed python&#x27;s development super closely</div><br/><div id="42484041" class="c"><input type="checkbox" id="c-42484041" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42483562">parent</a><span>|</span><a href="#42487701">next</a><span>|</span><label class="collapse" for="c-42484041">[-]</label><label class="expand" for="c-42484041">[4 more]</label></div><br/><div class="children"><div class="content">Some seldom used standard modules have been deprecated and later removed. Like recently I revisited a project I initially made using v3.6, but it broke on v3.13 due to an indirect dependency no longer present in the stdlib. It was a simple fix though as a quick search identified the issue and pointed to the removed module in a package on PyPI.</div><br/><div id="42484918" class="c"><input type="checkbox" id="c-42484918" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42484041">parent</a><span>|</span><a href="#42484803">next</a><span>|</span><label class="collapse" for="c-42484918">[-]</label><label class="expand" for="c-42484918">[2 more]</label></div><br/><div class="children"><div class="content">Python 3.6 is from 2016 and 3.13 is from 2024. Similar things happen on most platforms on this timescale, eg on the Java side[1], you&#x27;d be going from Java 8 to Java 23.<p>Clojure is pretty good even on that timescale though.<p>[1] See eg <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;50445603" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;50445603</a> up until 2021</div><br/><div id="42487946" class="c"><input type="checkbox" id="c-42487946" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42484918">parent</a><span>|</span><a href="#42484803">next</a><span>|</span><label class="collapse" for="c-42487946">[-]</label><label class="expand" for="c-42487946">[1 more]</label></div><br/><div class="children"><div class="content">Yep it&#x27;s totally understandable, and OK by me as these changes are documented in the release docs and the fix a pip install away.</div><br/></div></div></div></div><div id="42484803" class="c"><input type="checkbox" id="c-42484803" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42484041">parent</a><span>|</span><a href="#42484918">prev</a><span>|</span><a href="#42487701">next</a><span>|</span><label class="collapse" for="c-42484803">[-]</label><label class="expand" for="c-42484803">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s nothing crazy, but it makes upgrades a lot more unpredictable. It&#x27;s harder to communicate to management why the 3.x update took a day and the 3.y upgrade took a whole quarter.<p>It&#x27;s harder to upgrade services in a central way with any amount of leverage, and generally requires more coordination overhead, and moving more carefully.<p>Compare with, say, golang, where it&#x27;s pretty much a non-issue. My experience with Ruby was a lot better too, until Ruby 3, but hey, that was a major version bump!</div><br/></div></div></div></div><div id="42487701" class="c"><input type="checkbox" id="c-42487701" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42483562">parent</a><span>|</span><a href="#42484041">prev</a><span>|</span><a href="#42492454">next</a><span>|</span><label class="collapse" for="c-42487701">[-]</label><label class="expand" for="c-42487701">[3 more]</label></div><br/><div class="children"><div class="content">Removal of setuptools in 3.12 broke a ton of legacy builds. Basically created a wall of forced package upgrades for a huge amount of packages in PypI where end users have to bump a bunch of stuff if they want to migrate from &lt; 3.12 to 3.12+</div><br/><div id="42489101" class="c"><input type="checkbox" id="c-42489101" checked=""/><div class="controls bullet"><span class="by">Flimm</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42487701">parent</a><span>|</span><a href="#42492454">next</a><span>|</span><label class="collapse" for="c-42489101">[-]</label><label class="expand" for="c-42489101">[2 more]</label></div><br/><div class="children"><div class="content">setuptools was never part of Python&#x27;s standard library. I think you&#x27;re thinking of distutils which was removed from Python in the 3.12 release. You can easily access distutils again by installing a package from PyPI.</div><br/><div id="42491812" class="c"><input type="checkbox" id="c-42491812" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42489101">parent</a><span>|</span><a href="#42492454">next</a><span>|</span><label class="collapse" for="c-42491812">[-]</label><label class="expand" for="c-42491812">[1 more]</label></div><br/><div class="children"><div class="content">You are right, it was distutils. Good call out. Not sure why I thought of setuptools.</div><br/></div></div></div></div></div></div></div></div><div id="42492454" class="c"><input type="checkbox" id="c-42492454" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#42476748">root</a><span>|</span><a href="#42483323">parent</a><span>|</span><a href="#42483562">prev</a><span>|</span><a href="#42485101">next</a><span>|</span><label class="collapse" for="c-42492454">[-]</label><label class="expand" for="c-42492454">[1 more]</label></div><br/><div class="children"><div class="content">My thoughts exactly. Python was supposed to be this ultra-portable thing. But... I am finding myself having to write patches to get my software to work on different Python versions.<p>People who have Python 3 installed can be on many different versions. The thing is, depending on the version, quite often bug fixes included in later versions aren&#x27;t in older versions. So if you want to make your code work -- got to get the patches in manually, monkey patch broken code, and do it that way. Then there&#x27;s the seemingly random deprecation of standard library modules &#x2F; other breaking changes.<p>I take python version support seriously because if people install your packages you&#x27;ll be outsourcing all of the above crap to the user. They might not even know how to &#x27;upgrade&#x27; python. Or end up on the wrong version. If your package doesn&#x27;t work when they install it they&#x27;ll just move on to something else. Python is a total shit show for packaging.</div><br/></div></div></div></div></div></div><div id="42485101" class="c"><input type="checkbox" id="c-42485101" checked=""/><div class="controls bullet"><span class="by">carlsborg</span><span>|</span><a href="#42476748">prev</a><span>|</span><a href="#42469008">next</a><span>|</span><label class="collapse" for="c-42485101">[-]</label><label class="expand" for="c-42485101">[2 more]</label></div><br/><div class="children"><div class="content">Its merged into CPython 3.13 but labeled as experimental.<p>Single threaded cpu bound workloads suffer in benchmarks (vs i&#x2F;o workloads) till they put back the specializing adaptive interpreter (PEP 659) in 3.14. Docs say a 40% hit now, target is 10% at next release.<p>C extensions will have to be re-built and ported to support free threaded mode.<p>Some interesting and impactful bits of open source work for those with a c++ multithreading background.</div><br/><div id="42492675" class="c"><input type="checkbox" id="c-42492675" checked=""/><div class="controls bullet"><span class="by">santiagobasulto</span><span>|</span><a href="#42485101">parent</a><span>|</span><a href="#42469008">next</a><span>|</span><label class="collapse" for="c-42492675">[-]</label><label class="expand" for="c-42492675">[1 more]</label></div><br/><div class="children"><div class="content">May I ask which benchmarks you saw? I was looking for some reliable one and couldn’t find them.</div><br/></div></div></div></div><div id="42469008" class="c"><input type="checkbox" id="c-42469008" checked=""/><div class="controls bullet"><span class="by">shlomo_z</span><span>|</span><a href="#42485101">prev</a><span>|</span><a href="#42469010">next</a><span>|</span><label class="collapse" for="c-42469008">[-]</label><label class="expand" for="c-42469008">[7 more]</label></div><br/><div class="children"><div class="content">I have the same question! I love Python and asynchronous stuff, and I do not know too much about threading.<p>Is threading potentially better for IO bound tasks than async?</div><br/><div id="42469133" class="c"><input type="checkbox" id="c-42469133" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42469008">parent</a><span>|</span><a href="#42488041">next</a><span>|</span><label class="collapse" for="c-42469133">[-]</label><label class="expand" for="c-42469133">[3 more]</label></div><br/><div class="children"><div class="content">Potentially, but probably not. The benefit of a parallel-enabled interpreter would be two CPU cores executing bytecode instructions at the same time in the same interpreter. So, you could have one python thread working on one set of data, and another python thread working on another set of data, and the two threads would not interfere with each other much or at all. Today, with the global interpreter lock, only one of those threads can be executing bytecode at a time.</div><br/><div id="42473027" class="c"><input type="checkbox" id="c-42473027" checked=""/><div class="controls bullet"><span class="by">shlomo_z</span><span>|</span><a href="#42469008">root</a><span>|</span><a href="#42469133">parent</a><span>|</span><a href="#42488041">next</a><span>|</span><label class="collapse" for="c-42473027">[-]</label><label class="expand" for="c-42473027">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Today, with the global interpreter lock, only one of those threads can be executing bytecode at a time.<p>Yes, but Python now has a version without GIL, which prompted this post in the first place. So my question is: Now, if I use a version of Python 3.13 without GIL, can a threaded Flask app do better than an AIOHTTP server.</div><br/><div id="42482742" class="c"><input type="checkbox" id="c-42482742" checked=""/><div class="controls bullet"><span class="by">elashri</span><span>|</span><a href="#42469008">root</a><span>|</span><a href="#42473027">parent</a><span>|</span><a href="#42488041">next</a><span>|</span><label class="collapse" for="c-42482742">[-]</label><label class="expand" for="c-42482742">[1 more]</label></div><br/><div class="children"><div class="content">I think it will depend on which task we are talking about. For For CPU-bound tasks (i.e heavy computation, data processing), The No-GIL Flask with threading would likely perform better than AIOHTTP since it can truly parallelize computation across cores.Now for I&#x2F;O-bound tasks (database queries, API calls or file operations) then AIOHTTP would still likely be more efficient due to its lower overhead and memory.<p>So for your original question<p>&gt; Is threading potentially better for IO bound tasks than async?<p>async will be better in general, potentially due to Async co-routines using far less memory than threads and being better under high concurrency. But that&#x27;s all will depend on the details of implementation of the server.</div><br/></div></div></div></div></div></div><div id="42492483" class="c"><input type="checkbox" id="c-42492483" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#42469008">parent</a><span>|</span><a href="#42488041">prev</a><span>|</span><a href="#42469010">next</a><span>|</span><label class="collapse" for="c-42492483">[-]</label><label class="expand" for="c-42492483">[2 more]</label></div><br/><div class="children"><div class="content">Quite honestly I&#x27;d tell you not to mix threads with asyncio. As you note: IO bound tasks aren&#x27;t CPU hogs and there&#x27;s little benefit to mixing it with threads. It will lead to unnecessary bugs, complexity, and problems with event loop management.<p>Asyncio can run tens of thousands of tasks if its used properly. If you think something will block it you should check out &quot;process pool executors.&quot; Note that its very tricky to share resources like sockets between processes so its kind of another reason to avoid stuff like this.<p>I think Python 3.14 will have interpreter pools for even more concurrency options.</div><br/><div id="42492947" class="c"><input type="checkbox" id="c-42492947" checked=""/><div class="controls bullet"><span class="by">solidasparagus</span><span>|</span><a href="#42469008">root</a><span>|</span><a href="#42492483">parent</a><span>|</span><a href="#42469010">next</a><span>|</span><label class="collapse" for="c-42492947">[-]</label><label class="expand" for="c-42492947">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  there&#x27;s little benefit to mixing it with threads<p>&gt;  If you think something will block it you should check out &quot;process pool executors.&quot; Note that its very tricky to share resources like sockets between processes so its kind of another reason to avoid stuff like this.<p>Isn&#x27;t that the benefit of no-gil? The ability to run CPU-intensive operations without incurring the overhead and friction of multiprocessing? Now you can do multicore processing while also having shared memory</div><br/></div></div></div></div></div></div><div id="42469010" class="c"><input type="checkbox" id="c-42469010" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42469008">prev</a><span>|</span><a href="#42482748">next</a><span>|</span><label class="collapse" for="c-42469010">[-]</label><label class="expand" for="c-42469010">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always used threads despite the GIL.  I haven&#x27;t tried NoGIL and am waiting to find out how many bugs it surfaces.  I do get the impression that multi-threaded Python code is full of hazards that the GIL covers up.  There will have to be locks inserted all over the place.  CPython should have simply been retired as part of the 2 to 3 transition.  It was great in its day, on 1-core machines with the constraints of that era.  I have a feeling of tragedy that this didn&#x27;t happen and now it can never be repaired.  I probably wouldn&#x27;t use Python for web projects these days.  I haven&#x27;t done anything in Elixir yet but it looks like about the best option.  (I&#x27;ve used Erlang so I think I have a decent idea of what I&#x27;d be getting into with Elixir).</div><br/><div id="42469048" class="c"><input type="checkbox" id="c-42469048" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#42469010">parent</a><span>|</span><a href="#42479264">next</a><span>|</span><label class="collapse" for="c-42469048">[-]</label><label class="expand" for="c-42469048">[7 more]</label></div><br/><div class="children"><div class="content">In a strange way, Python being so bad at interpreting bytecodes and limited by GIL, plus being good at interfacing with C cheaply (unlike Go and Java,) induced a programming style that is extremely suited for data-parallel computing which is the way to efficiently scale compute in today&#x27;s SIMD&#x2F;GPU world. If you wanted to be efficient, you had to prepare your data ahead of time and hand it off. Any intermediate interaction with that data would ruin your performance. That&#x27;s mostly how efficient Python libraries and ecosystem are built.<p>Weakness may have turned into a strength.</div><br/><div id="42482595" class="c"><input type="checkbox" id="c-42482595" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42469048">parent</a><span>|</span><a href="#42469966">next</a><span>|</span><label class="collapse" for="c-42482595">[-]</label><label class="expand" for="c-42482595">[2 more]</label></div><br/><div class="children"><div class="content">Why would NoGIL change that, though? It&#x27;s not like large data-parallel operations can suddenly be done efficiently in Python if you remove the GIL. The problem with GIL afaik is mostly latency problems in interactive applications.</div><br/><div id="42484195" class="c"><input type="checkbox" id="c-42484195" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42482595">parent</a><span>|</span><a href="#42469966">next</a><span>|</span><label class="collapse" for="c-42484195">[-]</label><label class="expand" for="c-42484195">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I didn&#x27;t mean to imply something will change. I am simply concurring with the parent while observing that limitation turned into a strength by established a certain ecosystem early on that fits the modern architectural developments well. I don&#x27;t think that is going to change now, but had nogil been the original, it could have led to a different style of libraries being designed.</div><br/></div></div></div></div><div id="42469966" class="c"><input type="checkbox" id="c-42469966" checked=""/><div class="controls bullet"><span class="by">grandimam</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42469048">parent</a><span>|</span><a href="#42482595">prev</a><span>|</span><a href="#42479264">next</a><span>|</span><label class="collapse" for="c-42469966">[-]</label><label class="expand" for="c-42469966">[4 more]</label></div><br/><div class="children"><div class="content">Can you elaborate more on the  data-parallel computing part?</div><br/><div id="42473888" class="c"><input type="checkbox" id="c-42473888" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42469966">parent</a><span>|</span><a href="#42470471">next</a><span>|</span><label class="collapse" for="c-42473888">[-]</label><label class="expand" for="c-42473888">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much the entire Data Science&#x2F;Machine Learning landscape from numpy, etc. to tensorflow and alike are thin wrappers over C code and if you want performance, you better batch structure your operation beforehand and minimize back and forth from Python.</div><br/></div></div><div id="42470471" class="c"><input type="checkbox" id="c-42470471" checked=""/><div class="controls bullet"><span class="by">francocalvo</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42469966">parent</a><span>|</span><a href="#42473888">prev</a><span>|</span><a href="#42479264">next</a><span>|</span><label class="collapse" for="c-42470471">[-]</label><label class="expand" for="c-42470471">[2 more]</label></div><br/><div class="children"><div class="content">He&#x27;s probably talking about libraries like PySpark or PyFlink which are used a lot</div><br/><div id="42483428" class="c"><input type="checkbox" id="c-42483428" checked=""/><div class="controls bullet"><span class="by">whoiscroberts</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42470471">parent</a><span>|</span><a href="#42479264">next</a><span>|</span><label class="collapse" for="c-42483428">[-]</label><label class="expand" for="c-42483428">[1 more]</label></div><br/><div class="children"><div class="content">Pyflink seems promising, I love vanilla flink but as soon as you need to debug your pyflink job pyflink becomes a hurdle. That translation layer between Python and Java can be opaque.</div><br/></div></div></div></div></div></div></div></div><div id="42479264" class="c"><input type="checkbox" id="c-42479264" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42469010">parent</a><span>|</span><a href="#42469048">prev</a><span>|</span><a href="#42482748">next</a><span>|</span><label class="collapse" for="c-42479264">[-]</label><label class="expand" for="c-42479264">[2 more]</label></div><br/><div class="children"><div class="content">So what would the alternative history have been if CPython was retired after Python 3 came out in 2008, what would we be using now? IronPython or GraalPy?</div><br/><div id="42482589" class="c"><input type="checkbox" id="c-42482589" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#42469010">root</a><span>|</span><a href="#42479264">parent</a><span>|</span><a href="#42482748">next</a><span>|</span><label class="collapse" for="c-42482589">[-]</label><label class="expand" for="c-42482589">[1 more]</label></div><br/><div class="children"><div class="content">It would have suffered the same fate as Perl 6 and we&#x27;d all be on 2.1x.</div><br/></div></div></div></div></div></div><div id="42482748" class="c"><input type="checkbox" id="c-42482748" checked=""/><div class="controls bullet"><span class="by">0xDEADFED5</span><span>|</span><a href="#42469010">prev</a><span>|</span><a href="#42468820">next</a><span>|</span><label class="collapse" for="c-42482748">[-]</label><label class="expand" for="c-42482748">[1 more]</label></div><br/><div class="children"><div class="content">Waiting for CFFI or pywin32 free-threaded support since I don&#x27;t have time to work on CFFI myself</div><br/></div></div><div id="42468820" class="c"><input type="checkbox" id="c-42468820" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#42482748">prev</a><span>|</span><a href="#42492806">next</a><span>|</span><label class="collapse" for="c-42468820">[-]</label><label class="expand" for="c-42468820">[2 more]</label></div><br/><div class="children"><div class="content">Started working on a no-gil gRPC Python implementation but super low priority.<p>Has anyone started deploying nogil at scale in prod?</div><br/><div id="42469009" class="c"><input type="checkbox" id="c-42469009" checked=""/><div class="controls bullet"><span class="by">grandimam</span><span>|</span><a href="#42468820">parent</a><span>|</span><a href="#42492806">next</a><span>|</span><label class="collapse" for="c-42469009">[-]</label><label class="expand" for="c-42469009">[1 more]</label></div><br/><div class="children"><div class="content">No, I am not personally aware of anyone using it prod.</div><br/></div></div></div></div><div id="42492806" class="c"><input type="checkbox" id="c-42492806" checked=""/><div class="controls bullet"><span class="by">shiv_agarwal</span><span>|</span><a href="#42468820">prev</a><span>|</span><label class="collapse" for="c-42492806">[-]</label><label class="expand" for="c-42492806">[1 more]</label></div><br/><div class="children"><div class="content">Hi</div><br/></div></div></div></div></div></div></div></body></html>