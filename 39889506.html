<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711962074806" as="style"/><link rel="stylesheet" href="styles.css?v=1711962074806"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.micahcantor.com/blog/programming-beyond-paradigms/">Programming Beyond Paradigms</a> <span class="domain">(<a href="https://www.micahcantor.com">www.micahcantor.com</a>)</span></div><div class="subtext"><span>hydroxideOH-</span> | <span>29 comments</span></div><br/><div><div id="39891941" class="c"><input type="checkbox" id="c-39891941" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#39889763">next</a><span>|</span><label class="collapse" for="c-39891941">[-]</label><label class="expand" for="c-39891941">[1 more]</label></div><br/><div class="children"><div class="content">I think a lot if the paradigm frame comes from programming being still relatively new (although that&#x27;s becoming a less and less viable meme). We&#x27;re still very &quot;one true way&quot; in how we talk about software design.<p>Personally, I&#x27;d love to see us talking more in terms of problems&#x2F;solutions.<p>To give an example. State leads to complexity and bugs, and it can be minimized by preferring pure functions where possible. That&#x27;s a good principle that can be learnt from without embracing everything functional and rejecting everything that involves objects.</div><br/></div></div><div id="39889763" class="c"><input type="checkbox" id="c-39889763" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#39891941">prev</a><span>|</span><a href="#39892002">next</a><span>|</span><label class="collapse" for="c-39889763">[-]</label><label class="expand" for="c-39889763">[13 more]</label></div><br/><div class="children"><div class="content">&gt; The unifying aspect of new languages such as Rust, Nim, and Gleam is that they were designed from the beginning to be beyond paradigms.<p>I really don’t think this is correct at all. Rather, Rust&#x2F;Nim&#x2F;Gleam are first and foremost imperative languages. They may have some functional and Lispy features thrown in, but that doesn’t change the fact that programs in those languages involve writing statements to be executed one after another — the defining aspect of imperative languages.<p>If you really wanted to, I guess you could define this particular combination of ‘imperative+functional+macros’ as its own new paradigm. These languages are consistent enough with their design that that might actually make sense. But it’s certainly not ‘post-paradigm‘ in any meaningful way.</div><br/><div id="39890000" class="c"><input type="checkbox" id="c-39890000" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39889763">parent</a><span>|</span><a href="#39891510">next</a><span>|</span><label class="collapse" for="c-39890000">[-]</label><label class="expand" for="c-39890000">[3 more]</label></div><br/><div class="children"><div class="content">Agreeing and amplifying: I believe multi-paradigm is a useful term, but you can always find a prioritization in the paradigms. Your language is going to privilege either mutable or immutable data. It can support both, but one is going to be considered the default. Even if the language itself doesn&#x27;t, the standard library and the resulting influence it has on the 3rd party libraries will result in a preference. Your language will privilege one side or the other of the expression problem. Your language will privilege statements or functions. Your language will privilege static or dynamic types. Your language will prioritize compile time things or run time things. And so on for quite a few things. Even when someone finds an interesting way to split the difference in one of those categories, that does not <i>defy</i> this categorization, it <i>adds a new one</i>, a new way of prioritizing. But that new way still won&#x27;t be a completely even 50% split.<p>There are many multiparadigm languages. They are even the norm now. But being multiparadigm doesn&#x27;t mean they all support all paradigms equally. Programming X in Y is a problem for almost all combinations of X and Y for X != Y, because the language will always have a &quot;grain&quot; to it. Thus, it is still meaningful to argue about which paradigm <i>preference</i> is suitable to which tasks.<p>Even two of the most similar languages there are, at least in terms of language spec, Python and Ruby, demonstrate significant differences in the orientation of the library ecosystem in some of their philosophies.</div><br/><div id="39890286" class="c"><input type="checkbox" id="c-39890286" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39890000">parent</a><span>|</span><a href="#39890041">next</a><span>|</span><label class="collapse" for="c-39890286">[-]</label><label class="expand" for="c-39890286">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are many multiparadigm languages. They are even the norm now. But being multiparadigm doesn&#x27;t mean they all support all paradigms equally.<p>Mozart&#x2F;Oz and CTM are obligatory reading to understand the topic of supporting multiple paradigms: <a href="https:&#x2F;&#x2F;www.info.ucl.ac.be&#x2F;~pvr&#x2F;VanRoyChapter.pdf" rel="nofollow">https:&#x2F;&#x2F;www.info.ucl.ac.be&#x2F;~pvr&#x2F;VanRoyChapter.pdf</a><p>Oz is among the few languages where all paradigms are equal. A great HN discussion about the above link: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18381640">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18381640</a></div><br/></div></div><div id="39890041" class="c"><input type="checkbox" id="c-39890041" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39890000">parent</a><span>|</span><a href="#39890286">prev</a><span>|</span><a href="#39891510">next</a><span>|</span><label class="collapse" for="c-39890041">[-]</label><label class="expand" for="c-39890041">[1 more]</label></div><br/><div class="children"><div class="content">I agree with all of this. But I’ll point out that ‘the paradigms can be prioritised’ wasn’t intended to be my main point there. I wanted rather to refute the argument that Rust etc. aren’t ‘post-paradigm’ at all: on the contrary, they fit in quite well with existing paradigms.<p>&gt; Even two of the most similar languages there are, at least in terms of language spec, Python and Ruby, demonstrate significant differences in the orientation of the library ecosystem in some of their philosophies.<p>Hmm… I feel you can get a lot more similar than that. Python and Ruby are actually rather different to my mind. Rather, you could take OCaml vs SML, or Scheme vs Racket. The differences are still there, but it’s much more subtle.</div><br/></div></div></div></div><div id="39891510" class="c"><input type="checkbox" id="c-39891510" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#39889763">parent</a><span>|</span><a href="#39890000">prev</a><span>|</span><a href="#39890003">next</a><span>|</span><label class="collapse" for="c-39891510">[-]</label><label class="expand" for="c-39891510">[1 more]</label></div><br/><div class="children"><div class="content">I suspect it is possible to make the same argument for the contrary position.  Once we&#x27;re talking about &quot;some functional and Lispy features thrown in&quot;; we must start to question what a paradigm is.<p>If I write a program, fundamentally I have a blob in my head that I&#x27;m reifying into formal logic. It doesn&#x27;t make sense to talk about the blob as having a paradigm; but I&#x27;m not sure that it is useful to talk about the reification as having a &quot;paradigm&quot; either. The appropriate techniques to be used are on a functional-imperative spectrum based on how stateful the problem is.<p>This whole idea of programming paradigms I think is a mis-take of a more fundamental question of how to classify programming problems - we&#x27;re looking at the shadow in Plato&#x27;s cave and getting nonsense because we expect the problem to to take on aspects of the programming language. Which is not a strategy for achieving success. We should be classifying problems based on state, not programming languages based on paradigms.<p>Most of the experts have figured that out, they pick their programming language based on the problem space they want to deal in. But the paradigm paradigm doesn&#x27;t help in making those decisions, so it&#x27;s utility is low.</div><br/></div></div><div id="39890003" class="c"><input type="checkbox" id="c-39890003" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#39889763">parent</a><span>|</span><a href="#39891510">prev</a><span>|</span><a href="#39891569">next</a><span>|</span><label class="collapse" for="c-39890003">[-]</label><label class="expand" for="c-39890003">[3 more]</label></div><br/><div class="children"><div class="content">To add to my parent comment, I think there’s another point to be made here: ‘post-paradigm’ is, to some extent, a contradiction in terms. You can’t build a language without its basic structure implying <i>some</i> paradigm (or possibly more than one).<p>There’s a perspective I find useful here. I tend to think of different ‘programming paradigms’ as different approaches to solving problems. In imperative languages, you solve problems by modifying values in sequence until you get to the answer; in functional languages, you solve problems by building up a function which gives you back the answer; and so on.<p>The key thing here is, you <i>do</i> need to give yourself some way of solving problems. That translates directly to the paradigm which your programming language adopts. If you give yourself more than one way of solving problems, then the language becomes multi-paradigm. In rare cases, you might even end up inventing a totally novel problem-solving approach, and hence a new paradigm… but even that’s not ‘post-paradigm’, it’s just another paradigm.</div><br/><div id="39890799" class="c"><input type="checkbox" id="c-39890799" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39890003">parent</a><span>|</span><a href="#39891569">next</a><span>|</span><label class="collapse" for="c-39890799">[-]</label><label class="expand" for="c-39890799">[2 more]</label></div><br/><div class="children"><div class="content">Replying here to both.<p>I don’t disagree on any of your technical points. But I also think for practical purposes you’re missing the forest here. I agree with the sentiment of the article - I think the big trend in <i>general purpose</i> PLs is a blend of multiple classical paradigms. Perhaps we’re moving the goalpost and paradigms need to be rearranged - but that <i>is</i> intrinsically interesting - it’s literally the continents of knowledge drifting slowly into new configurations.<p>Single-paradigm languages like prolog, CSS or SQL keep their restrictions not because the lack of use-cases, but because the benefit of keeping the complex execution engines away from the end-user exceeds the minor wins in expressiveness.<p>I don’t think it’s a coincidence that the declarative languages are in this category. They are higher level, and opening up low-level customizations is really tricky: for instance, if you put imperative code inside your CSS, it needs complex “re-evaluation rules”, that results in a dilemma: either give full control to the programmer, which imposes specific execution engine designs and complex API surfaces – or re-evaluate too often, which risks killing memoization and perf (cache invalidation). It could be even worse if the code has side-effects or dep cycles.<p>On the contrary, imperative low level languages like Rust can <i>easily</i> come along and say things like: “this is not only a function, but a side-effect free function”. “This is not just a reference, but an immutable reference”. Then you can cleverly leverage those traits in your “execution engine” ie the compiler, to deliver low-level perf. There are even people who describe rust as a high-level language for these reasons, which is a bit provocative to me but in all honesty not completely outrageous.<p>An alternative take on the last 10-15 years:<p>- General purpose PLs typically have an imperative base, while integrating multiple classical paradigms:<p>- Only a few aspects of OOP are added to modern PLs, where inheritance has largely been superseded by simpler composition<p>- Features from FP have surged in popularity, being integrated and even retro-fitted into general purpose PLs, providing both perf- and DX improvements<p>- Structured meta-programming and&#x2F;or codegen has been a strong focus for compiled languages, acknowledging that it’s preferable to limit the complexity of the core language at the expense of separate pre-compile phases</div><br/><div id="39891990" class="c"><input type="checkbox" id="c-39891990" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39890799">parent</a><span>|</span><a href="#39891569">next</a><span>|</span><label class="collapse" for="c-39891990">[-]</label><label class="expand" for="c-39891990">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Prolog is a single paradigm language. It just has one dominant paradigm: Logic Programming. But in actual Prolog systems you&#x27;ll find procedural programming, constraint programming, object-oriented programming, meta programming (programming on the language level).</div><br/></div></div></div></div></div></div><div id="39891569" class="c"><input type="checkbox" id="c-39891569" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#39889763">parent</a><span>|</span><a href="#39890003">prev</a><span>|</span><a href="#39889924">next</a><span>|</span><label class="collapse" for="c-39891569">[-]</label><label class="expand" for="c-39891569">[2 more]</label></div><br/><div class="children"><div class="content">I think your comment may be arguing against you.<p>Gleam is one of the really really functional languages out there. There is no mutability, there are no statements, no loops. It has let bindings, function application, and conditionals through if&#x2F;case, and that’s it. It has just tricked you because it has a very nice and friendly syntax.<p>It also has no macros so I don’t know what you mean in that last paragraph.</div><br/><div id="39891713" class="c"><input type="checkbox" id="c-39891713" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39891569">parent</a><span>|</span><a href="#39889924">next</a><span>|</span><label class="collapse" for="c-39891713">[-]</label><label class="expand" for="c-39891713">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Functional&quot; has lost its meaning. Originally, functional programming was rather well-defined - now everything that has a `.map` is called functional. Gleam goes a longer way than, say, Python. But since it still has side-effects and lacks a system, it is very different from e.g. Haskell.</div><br/></div></div></div></div><div id="39889924" class="c"><input type="checkbox" id="c-39889924" checked=""/><div class="controls bullet"><span class="by">hydroxideOH-</span><span>|</span><a href="#39889763">parent</a><span>|</span><a href="#39891569">prev</a><span>|</span><a href="#39892002">next</a><span>|</span><label class="collapse" for="c-39889924">[-]</label><label class="expand" for="c-39889924">[3 more]</label></div><br/><div class="children"><div class="content">I disagree. In Rust, traits are used all over for dynamic dispatch, the defining feature of object-oriented programming. Moreover, all three languages support structural pattern matching (borrowed from functional programming) as a core control-structure.<p>Certainly all three languages can be used in a simple, imperative style. But that&#x27;s not the only paradigm that can be used unlike in C or early versions of Python. Many programs in these languages look significantly different than just statements and procedures.</div><br/><div id="39890750" class="c"><input type="checkbox" id="c-39890750" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39889924">parent</a><span>|</span><a href="#39889953">next</a><span>|</span><label class="collapse" for="c-39890750">[-]</label><label class="expand" for="c-39890750">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In Rust, traits are used all over for dynamic dispatch, the defining feature of object-oriented programming.<p>In my experience, Rust traits are used much more for static dispatch `fn foo&lt;T: Trait&gt;(T)` than dynamic dispatch `fn foo(Box&lt;dyn Trait&gt;)`. This, together with its ADTs and lack of inheritance, gives it a very different feel from most &quot;object oriented&quot; languages.<p>Also, what counts as a &quot;defining feature&quot; depends greatly on who&#x27;s defining it. Though dynamic dispatch is certainly up there on most lists.</div><br/></div></div><div id="39889953" class="c"><input type="checkbox" id="c-39889953" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#39889763">root</a><span>|</span><a href="#39889924">parent</a><span>|</span><a href="#39890750">prev</a><span>|</span><a href="#39892002">next</a><span>|</span><label class="collapse" for="c-39889953">[-]</label><label class="expand" for="c-39889953">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Many programs in these languages look significantly different than just statements and procedures.<p>Like I said, they’ve certainly adopted features from other paradigms… but the basic, underlying structure of programs in these languages is still statements, sequenced one after another. It’s not like Haskell or Scheme where nearly every operation is ultimately done through function calls. And it’s <i>certainly</i> not ‘post-paradigm’ as the article claims.<p>&gt; Moreover, all three languages support structural pattern matching (borrowed from functional programming) as a core control-structure.<p>As for this: people often associate functional programming with pattern-matching, but I’ve never really understood why. The only relationship is that it originated in the ML language family, which also happens to be functional. There’s many functional languages which lack pattern-matching (e.g. most Lisps), and there’s many non-functional languages which have it (Java, C#, Python).</div><br/></div></div></div></div></div></div><div id="39892002" class="c"><input type="checkbox" id="c-39892002" checked=""/><div class="controls bullet"><span class="by">frou_dh</span><span>|</span><a href="#39889763">prev</a><span>|</span><a href="#39891721">next</a><span>|</span><label class="collapse" for="c-39892002">[-]</label><label class="expand" for="c-39892002">[1 more]</label></div><br/><div class="children"><div class="content">As the big name languages become a never-ending accretion of multi-paradigm features, then it just feels like a sort of Grey Goo landscape. There&#x27;s a charm in things remaining true to themselves, even at the cost of maximum utility.</div><br/></div></div><div id="39891721" class="c"><input type="checkbox" id="c-39891721" checked=""/><div class="controls bullet"><span class="by">bashauma</span><span>|</span><a href="#39892002">prev</a><span>|</span><a href="#39890472">next</a><span>|</span><label class="collapse" for="c-39891721">[-]</label><label class="expand" for="c-39891721">[1 more]</label></div><br/><div class="children"><div class="content">I more or less agree with the author that &quot;programming paradigms are becoming practically the same as programming styles&quot;, but even so, some languages have core features that cannot be replicated by mainstream &quot;multi-paradigm&quot; languages, and then that I can call them as the Next Paradigm.<p>An example is dependent types. This is impossible in all the languages the author mentions in the article (yes, well, GHC Haskell comes close), but there is at least one &quot;21st century general-purpose language&quot; that uses it, called Idris.</div><br/></div></div><div id="39890472" class="c"><input type="checkbox" id="c-39890472" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39891721">prev</a><span>|</span><a href="#39891050">next</a><span>|</span><label class="collapse" for="c-39890472">[-]</label><label class="expand" for="c-39890472">[2 more]</label></div><br/><div class="children"><div class="content">The closest thing I&#x27;ve seen to truly multi-paradigm was a programming language now lost to time called Metamine, which I kept a clone of[1]. Here&#x27;s some previous discussion[2]<p>In Metamine<p><pre><code>   a := b   is a normal assignment
   c = d+1   means that c will ALWAYS be equal to d+1 
   z = 10-time    results in a countdown timer, z
</code></pre>
That magical equals is declarative programming... something that I&#x27;ve only seen mixed with imperative functioning that one time.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;mikewarot&#x2F;metamine">https:&#x2F;&#x2F;github.com&#x2F;mikewarot&#x2F;metamine</a><p>[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27555940">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27555940</a></div><br/><div id="39890575" class="c"><input type="checkbox" id="c-39890575" checked=""/><div class="controls bullet"><span class="by">lanna</span><span>|</span><a href="#39890472">parent</a><span>|</span><a href="#39891050">next</a><span>|</span><label class="collapse" for="c-39890575">[-]</label><label class="expand" for="c-39890575">[1 more]</label></div><br/><div class="children"><div class="content">Easy to achieve the same in any language that supports the uniform access principle, and it does not even look magical</div><br/></div></div></div></div><div id="39891050" class="c"><input type="checkbox" id="c-39891050" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#39890472">prev</a><span>|</span><a href="#39889853">next</a><span>|</span><label class="collapse" for="c-39891050">[-]</label><label class="expand" for="c-39891050">[1 more]</label></div><br/><div class="children"><div class="content">A better example is the <i>Oz programming language and the Mozart programming system</i> (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Oz_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Oz_(programming_language)</a>) explained in the book <i>Concepts, Techniques, and Models of Computer Programing by Peter Van Roy and Seif Haridi</i>.</div><br/></div></div><div id="39889853" class="c"><input type="checkbox" id="c-39889853" checked=""/><div class="controls bullet"><span class="by">ergonaught</span><span>|</span><a href="#39891050">prev</a><span>|</span><a href="#39889654">next</a><span>|</span><label class="collapse" for="c-39889853">[-]</label><label class="expand" for="c-39889853">[2 more]</label></div><br/><div class="children"><div class="content">Common Lisp is a modern programming language, apparently. Who knew.<p>Greenspun’s Tenth Rule always irritated me more than it amused me but here we are.</div><br/><div id="39890243" class="c"><input type="checkbox" id="c-39890243" checked=""/><div class="controls bullet"><span class="by">LettuceSand12</span><span>|</span><a href="#39889853">parent</a><span>|</span><a href="#39889654">next</a><span>|</span><label class="collapse" for="c-39890243">[-]</label><label class="expand" for="c-39890243">[1 more]</label></div><br/><div class="children"><div class="content">A lisp that didn’t spam parentheses would probably be more palatable.</div><br/></div></div></div></div><div id="39889654" class="c"><input type="checkbox" id="c-39889654" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#39889853">prev</a><span>|</span><a href="#39889882">next</a><span>|</span><label class="collapse" for="c-39889654">[-]</label><label class="expand" for="c-39889654">[1 more]</label></div><br/><div class="children"><div class="content">This has been true of Common Lisp almost since the beginning.  Supported functional, imperative and object oriented paradigms out of the box.  And macros allow supporting almost any other programming style in the language as well.  Probably any programming paradigm you can think of at some point was added to Common Lisp as a library through macros.</div><br/></div></div><div id="39889882" class="c"><input type="checkbox" id="c-39889882" checked=""/><div class="controls bullet"><span class="by">refactor_master</span><span>|</span><a href="#39889654">prev</a><span>|</span><a href="#39891402">next</a><span>|</span><label class="collapse" for="c-39889882">[-]</label><label class="expand" for="c-39889882">[1 more]</label></div><br/><div class="children"><div class="content">If anything, new languages have the potential to be more paradigmatic than past languages, because they’re starting over from a better place.<p>Just take a look at how Python is evolving, and the trail of essentially “dead” features and standards it’s leaving behind.</div><br/></div></div><div id="39890880" class="c"><input type="checkbox" id="c-39890880" checked=""/><div class="controls bullet"><span class="by">aryehof</span><span>|</span><a href="#39891402">prev</a><span>|</span><a href="#39891014">next</a><span>|</span><label class="collapse" for="c-39890880">[-]</label><label class="expand" for="c-39890880">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The most common understanding is that a paradigm is a set of features in a programming language that determine its control flow or type system<p>A better viewpoint is to question what sort of problems or way to model a system, is a particular paradigm best suited to?</div><br/></div></div><div id="39891531" class="c"><input type="checkbox" id="c-39891531" checked=""/><div class="controls bullet"><span class="by">tristramb</span><span>|</span><a href="#39891014">prev</a><span>|</span><a href="#39891649">next</a><span>|</span><label class="collapse" for="c-39891531">[-]</label><label class="expand" for="c-39891531">[1 more]</label></div><br/><div class="children"><div class="content">Written by AI?</div><br/></div></div><div id="39891649" class="c"><input type="checkbox" id="c-39891649" checked=""/><div class="controls bullet"><span class="by">lemper</span><span>|</span><a href="#39891531">prev</a><span>|</span><label class="collapse" for="c-39891649">[-]</label><label class="expand" for="c-39891649">[1 more]</label></div><br/><div class="children"><div class="content">bro, sorry. but your &quot;article&quot; has next to no meat. train your bot to write stuff better, bro.</div><br/></div></div></div></div></div></div></div></body></html>