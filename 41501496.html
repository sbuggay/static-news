<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726045273281" as="style"/><link rel="stylesheet" href="styles.css?v=1726045273281"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.cloudflare.com/pingora-saving-compute-1-percent-at-a-time/">A good day to trie-hard: saving compute 1% at a time</a> <span class="domain">(<a href="https://blog.cloudflare.com">blog.cloudflare.com</a>)</span></div><div class="subtext"><span>eaufavor</span> | <span>154 comments</span></div><br/><div><div id="41501684" class="c"><input type="checkbox" id="c-41501684" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41504082">next</a><span>|</span><label class="collapse" for="c-41501684">[-]</label><label class="expand" for="c-41501684">[63 more]</label></div><br/><div class="children"><div class="content">If you had asked me to make a wild guess as to how Cloudflare stores internal headers and then removes them, I would have come up with some options:<p>- An entire separate dictionary or other data structure.<p>- One single header containing all internal metadata.<p>- All headers have a prefix, and the internal ones start with I and the external ones start with E.<p>- All internal headers start with “CFInt”.<p>I would not have come up with a scheme in which headers in a particular list are internal. (What if someone else uses this name?  What if something forgets to sanitize?  What if different simultaneously running programs disagree in the list?  What if the Connection header names a Cloudflare-internal header?  What if the set-difference algorithm is annoyingly slow?)<p>The web is already full of obnoxiously ambiguous in-band signaling and header naming, and I find it bizarre that a company with Cloudflare’s scale uses such a tedious and error-prone mechanism internally.</div><br/><div id="41504063" class="c"><input type="checkbox" id="c-41504063" checked=""/><div class="controls bullet"><span class="by">e63f67dd-065b</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41501794">next</a><span>|</span><label class="collapse" for="c-41504063">[-]</label><label class="expand" for="c-41504063">[4 more]</label></div><br/><div class="children"><div class="content">Former employee here; the interesting (horrifying?) fact is that you can <i>set</i> some of these internal headers (I remember a notable bug with cf-cache-status) in workers (the serverless offering) and cause all kinds of bad things to happen :)</div><br/><div id="41506838" class="c"><input type="checkbox" id="c-41506838" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41504063">parent</a><span>|</span><a href="#41501794">next</a><span>|</span><label class="collapse" for="c-41506838">[-]</label><label class="expand" for="c-41506838">[3 more]</label></div><br/><div class="children"><div class="content">It seems to me it should be trivial to strip anything internal that comes out of a worker right?</div><br/><div id="41507028" class="c"><input type="checkbox" id="c-41507028" checked=""/><div class="controls bullet"><span class="by">ketzo</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41506838">parent</a><span>|</span><a href="#41501794">next</a><span>|</span><label class="collapse" for="c-41507028">[-]</label><label class="expand" for="c-41507028">[2 more]</label></div><br/><div class="children"><div class="content">Trivial unless someone <i>wants</i> to modify CF internal headers as part of their solution…<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/><div id="41507242" class="c"><input type="checkbox" id="c-41507242" checked=""/><div class="controls bullet"><span class="by">virtue3</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41507028">parent</a><span>|</span><a href="#41501794">next</a><span>|</span><label class="collapse" for="c-41507242">[-]</label><label class="expand" for="c-41507242">[1 more]</label></div><br/><div class="children"><div class="content">Haha thank you</div><br/></div></div></div></div></div></div></div></div><div id="41501794" class="c"><input type="checkbox" id="c-41501794" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41504063">prev</a><span>|</span><a href="#41505118">next</a><span>|</span><label class="collapse" for="c-41501794">[-]</label><label class="expand" for="c-41501794">[17 more]</label></div><br/><div class="children"><div class="content">Ive worked at several huge corporations in IT security, where we care about headers a lot, and they all use headers in a manner similar to CloudFlare.<p>Including using proxies at the edge to strip out internal headers bidirectionally- yes, inbound too.</div><br/><div id="41502014" class="c"><input type="checkbox" id="c-41502014" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501794">parent</a><span>|</span><a href="#41501951">next</a><span>|</span><label class="collapse" for="c-41502014">[-]</label><label class="expand" for="c-41502014">[3 more]</label></div><br/><div class="children"><div class="content">The first large scale piece of software I worked on was for telcos pre smart phone. We used internal headers to offload authentication and terminate SSL. We also had to pressure F5 to fix about half a dozen bugs in BIG-IP to do so. Bugs that should in no universe have existed in version 9 of a product.<p>I used to joke that F5 owed me and my coworker 3 months of salary for all the free QA we did for them.</div><br/><div id="41503075" class="c"><input type="checkbox" id="c-41503075" checked=""/><div class="controls bullet"><span class="by">tmsite</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502014">parent</a><span>|</span><a href="#41501951">next</a><span>|</span><label class="collapse" for="c-41503075">[-]</label><label class="expand" for="c-41503075">[2 more]</label></div><br/><div class="children"><div class="content">It helps if you realize that BIG-IP 9.0 was essentially a from-scratch rewrite of BIG-IP 4.5.  Among other major redesigns, the data plane was moved from BSD kernel space to Linux user space.  Internally, the joke was that it would be two times better when we were done (4.5 * 2 = 9.0).  It probably was, but not on day zero.</div><br/><div id="41503157" class="c"><input type="checkbox" id="c-41503157" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503075">parent</a><span>|</span><a href="#41501951">next</a><span>|</span><label class="collapse" for="c-41503157">[-]</label><label class="expand" for="c-41503157">[1 more]</label></div><br/><div class="children"><div class="content">On day sixty it couldn’t do SSL termination and cookie based traffic shaping didn’t work.<p>I was a little bummed it was “just” a Linux box but that’s pretty common today. I hadn’t discovered dd-wrt yet and wouldn’t for a few years.</div><br/></div></div></div></div></div></div><div id="41501951" class="c"><input type="checkbox" id="c-41501951" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501794">parent</a><span>|</span><a href="#41502014">prev</a><span>|</span><a href="#41505118">next</a><span>|</span><label class="collapse" for="c-41501951">[-]</label><label class="expand" for="c-41501951">[13 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t make it better, it makes it worse.</div><br/><div id="41502040" class="c"><input type="checkbox" id="c-41502040" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501951">parent</a><span>|</span><a href="#41505118">next</a><span>|</span><label class="collapse" for="c-41502040">[-]</label><label class="expand" for="c-41502040">[12 more]</label></div><br/><div class="children"><div class="content">Are you on a corporate network? Do you use a firewall at home?<p>You’re on enclaves <i>all the time</i>. This is just a different one. Separate networks per class of traffic used to be de rigeur before Cloud. Now it’s all munged together.</div><br/><div id="41502518" class="c"><input type="checkbox" id="c-41502518" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502040">parent</a><span>|</span><a href="#41504177">next</a><span>|</span><label class="collapse" for="c-41502518">[-]</label><label class="expand" for="c-41502518">[10 more]</label></div><br/><div class="children"><div class="content">I understand that security needs to be pragmatic, but because security does it, doesn&#x27;t make it right.<p>It isn&#x27;t about being in the enclave, it is having to keep track of what headers you set vs external. It is fragile and error prone and it will absolutely break someone else when there is a name collision.<p>All security exploits are a subset of bugs.</div><br/><div id="41502671" class="c"><input type="checkbox" id="c-41502671" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502518">parent</a><span>|</span><a href="#41504177">next</a><span>|</span><label class="collapse" for="c-41502671">[-]</label><label class="expand" for="c-41502671">[9 more]</label></div><br/><div class="children"><div class="content">And what would you have them do instead? SSL to every service? Reauthenticate on every single call? What’s your clever solution?<p>There’s probably a dozen things you can terminate at a boundary that would cost so much to run through the entire system that it would bankrupt a company.<p>And then there’s tracing, which also uses headers.</div><br/><div id="41508280" class="c"><input type="checkbox" id="c-41508280" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502671">parent</a><span>|</span><a href="#41503050">next</a><span>|</span><label class="collapse" for="c-41508280">[-]</label><label class="expand" for="c-41508280">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m dumb or missing something, but why not just do what Google does -- convert all inbound HTTP requests into Protobufs, separate out the internal stuffs from the external stuffs, run it through your myriad of internal services, and then on the way out you still have your nicely delineated protobufs which you can convert back into HTTP. Why are we mucking about with headers in the first place?</div><br/></div></div><div id="41503050" class="c"><input type="checkbox" id="c-41503050" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502671">parent</a><span>|</span><a href="#41508280">prev</a><span>|</span><a href="#41504177">next</a><span>|</span><label class="collapse" for="c-41503050">[-]</label><label class="expand" for="c-41503050">[7 more]</label></div><br/><div class="children"><div class="content">one of the listed options was to begin all the Cloudflare internal header names with &quot;CFInt&quot;</div><br/><div id="41503120" class="c"><input type="checkbox" id="c-41503120" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503050">parent</a><span>|</span><a href="#41504177">next</a><span>|</span><label class="collapse" for="c-41503120">[-]</label><label class="expand" for="c-41503120">[6 more]</label></div><br/><div class="children"><div class="content">That’s still header filtering. And it should be X-CF- by the way.</div><br/><div id="41503817" class="c"><input type="checkbox" id="c-41503817" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503120">parent</a><span>|</span><a href="#41503247">next</a><span>|</span><label class="collapse" for="c-41503817">[-]</label><label class="expand" for="c-41503817">[2 more]</label></div><br/><div class="children"><div class="content">It took me about 10 years to hear about it, but the IETF tried to deprecate the X- prefix back in 2012: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc6648" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc6648</a></div><br/><div id="41504144" class="c"><input type="checkbox" id="c-41504144" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503817">parent</a><span>|</span><a href="#41503247">next</a><span>|</span><label class="collapse" for="c-41504144">[-]</label><label class="expand" for="c-41504144">[1 more]</label></div><br/><div class="children"><div class="content">Good to know.<p>(Also sibling is right, I spaced on X-CF- being a header sent to CF customers’ servers. I don’t used cloudflare but cloudfront does the exact same thing)</div><br/></div></div></div></div><div id="41503247" class="c"><input type="checkbox" id="c-41503247" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503120">parent</a><span>|</span><a href="#41503817">prev</a><span>|</span><a href="#41504177">next</a><span>|</span><label class="collapse" for="c-41503247">[-]</label><label class="expand" for="c-41503247">[3 more]</label></div><br/><div class="children"><div class="content">X-CF- seems to be used by some other software. And Cloudflare has plenty of documented headers that don’t start with X.<p>The whole point is that a genuine user header should never conflict with a Cloudflare internal header, and a browser should never see an internal header.</div><br/><div id="41503315" class="c"><input type="checkbox" id="c-41503315" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503247">parent</a><span>|</span><a href="#41503506">next</a><span>|</span><label class="collapse" for="c-41503315">[-]</label><label class="expand" for="c-41503315">[1 more]</label></div><br/><div class="children"><div class="content">Please reread the entire thread. We are talking about someone who thinks the header solution is stupid. You are both splitting hairs. Stay on target.</div><br/></div></div><div id="41503506" class="c"><input type="checkbox" id="c-41503506" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503247">parent</a><span>|</span><a href="#41503315">prev</a><span>|</span><a href="#41504177">next</a><span>|</span><label class="collapse" for="c-41503506">[-]</label><label class="expand" for="c-41503506">[1 more]</label></div><br/><div class="children"><div class="content">Having re-read the thread, I totally agree. What you have listed is table stakes. I&#x27;d also say that internal headers would also be encrypted to a narrow protection domain.<p>If all internal headers were prefixed with X-CF-, you could strip them all via SIMD that had no knowledge of any specific header. Hell, you could probably do it on the NIC.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41504177" class="c"><input type="checkbox" id="c-41504177" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502040">parent</a><span>|</span><a href="#41502518">prev</a><span>|</span><a href="#41505118">next</a><span>|</span><label class="collapse" for="c-41504177">[-]</label><label class="expand" for="c-41504177">[1 more]</label></div><br/><div class="children"><div class="content">Configure all machines in a way that they can survive on some random untrusted public wifi. This should be the obvious default stance for laptops and phones.<p>But even for workstations wired to a trusted LAN it still makes sense because you never know which of the various tunnels might assign and expose some IPv6 address to the internet.<p>For servers you might be able to make an exception if you have a vigilant IT and the people with admin access aren&#x27;t actively trying to circumvent security, but even then that better not be your only layer of security.</div><br/></div></div></div></div></div></div></div></div><div id="41505118" class="c"><input type="checkbox" id="c-41505118" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41501794">prev</a><span>|</span><a href="#41501708">next</a><span>|</span><label class="collapse" for="c-41505118">[-]</label><label class="expand" for="c-41505118">[10 more]</label></div><br/><div class="children"><div class="content">I feel like I can point out lots of similar problems to the other solutions you suggest (heck, I thing some of those problems you list even <i>apply</i> to those other solutions).<p>The list approach has some downsides, but it also has a bunch of upsides. I feel like when people like to point out potential flaws of these approaches, they&#x27;re ignoring the history and difficulties that comes with Cloudflare&#x27;s scope. An enumerated list is the simplest and most flexible of the approaches, and it also doesn&#x27;t require any a priori agreement on the structure of a header key - this is probably important when you think about the sheer number of teams at Cloudflare, potential technology acquisitions, etc.</div><br/><div id="41506851" class="c"><input type="checkbox" id="c-41506851" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41505118">parent</a><span>|</span><a href="#41506248">next</a><span>|</span><label class="collapse" for="c-41506851">[-]</label><label class="expand" for="c-41506851">[7 more]</label></div><br/><div class="children"><div class="content">&gt; it also doesn&#x27;t require any a priori agreement on the structure of a header key - this is probably important when you think about the sheer number of teams at Cloudflare<p>That’s more of an indictment of how little effort is spent aligning things. It’s not that hard to tell every team that any headers have to start with ‘CFint’ and then enforce that.</div><br/><div id="41507245" class="c"><input type="checkbox" id="c-41507245" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41506851">parent</a><span>|</span><a href="#41507035">next</a><span>|</span><label class="collapse" for="c-41507245">[-]</label><label class="expand" for="c-41507245">[2 more]</label></div><br/><div class="children"><div class="content">* Headers that are originally private, but are later changed to public<p>* Headers that are intended to be public, but then are changed to private<p>* Headers that were created in the very early days of the company, which are so deeply integrated into everything that renaming them is basically impossible (or at least very hard and risky)<p>* Headers that are set by some appliance&#x2F;third party solution not controlled by CF, but which are technically internal and must be stripped.<p>* Newly acquired company has its own set of internal headers. Management is not amused when a huge, disrupting refactor is suggested by engineers.<p>And this is just a tip of the iceberg of possible problems when your scale is big enough.</div><br/><div id="41508336" class="c"><input type="checkbox" id="c-41508336" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41507245">parent</a><span>|</span><a href="#41507035">next</a><span>|</span><label class="collapse" for="c-41508336">[-]</label><label class="expand" for="c-41508336">[1 more]</label></div><br/><div class="children"><div class="content">So because everything is a Byzantine labyrinth due to scale we&#x27;re all going to agree to <i>remember</i> to add internal headers to strip to another service?<p>Maintaining the header to strip list is just another piece of technical debt to keep paying down.<p>Having a policy to strip everything under a prefix seems much less error prone.</div><br/></div></div></div></div><div id="41507035" class="c"><input type="checkbox" id="c-41507035" checked=""/><div class="controls bullet"><span class="by">ketzo</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41506851">parent</a><span>|</span><a href="#41507245">prev</a><span>|</span><a href="#41507603">next</a><span>|</span><label class="collapse" for="c-41507035">[-]</label><label class="expand" for="c-41507035">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s not that hard<p>How many years do you have to spend in software before you stop uttering those four cursed words?</div><br/><div id="41508452" class="c"><input type="checkbox" id="c-41508452" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41507035">parent</a><span>|</span><a href="#41507603">next</a><span>|</span><label class="collapse" for="c-41508452">[-]</label><label class="expand" for="c-41508452">[1 more]</label></div><br/><div class="children"><div class="content">It takes just as much experience to acknowledge that the cure is worse than the disease.</div><br/></div></div></div></div><div id="41507603" class="c"><input type="checkbox" id="c-41507603" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41506851">parent</a><span>|</span><a href="#41507035">prev</a><span>|</span><a href="#41506248">next</a><span>|</span><label class="collapse" for="c-41507603">[-]</label><label class="expand" for="c-41507603">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s not that hard to tell every team that any headers have to start with ‘CFint’ and then enforce that.<p>To be a little bit blunt, this just means you have never built software in a very large company that may have a lot of existing&#x2F;completely independent software, or have made technology acquisitions after the fact. That is, if you are starting from &quot;time 0&quot; of course it&#x27;s very easy to say &quot;internal headers need to start with CFInt&quot;, but that&#x27;s rarely the case.</div><br/><div id="41508463" class="c"><input type="checkbox" id="c-41508463" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41507603">parent</a><span>|</span><a href="#41506248">next</a><span>|</span><label class="collapse" for="c-41508463">[-]</label><label class="expand" for="c-41508463">[1 more]</label></div><br/><div class="children"><div class="content">I think if you work for such a very large company the only reason you are ok with it is because nobody at the top says ‘no more’.<p>If they do, it suddenly becomes very easy to get everything aligned, because there is likely a vast collection of bodies just collecting a paycheck that can be more productively assigned to manually renaming everything.</div><br/></div></div></div></div></div></div><div id="41506248" class="c"><input type="checkbox" id="c-41506248" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41505118">parent</a><span>|</span><a href="#41506851">prev</a><span>|</span><a href="#41501708">next</a><span>|</span><label class="collapse" for="c-41506248">[-]</label><label class="expand" for="c-41506248">[2 more]</label></div><br/><div class="children"><div class="content">Lists, extensible protobufs, etc are indeed great in their extensibility.  The issue I would see (if I worked at Cloudflare) isn’t to using a list — it’s that the list is the <i>same</i> list that’s used for externally visible HTTP headers.</div><br/><div id="41507611" class="c"><input type="checkbox" id="c-41507611" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41506248">parent</a><span>|</span><a href="#41501708">next</a><span>|</span><label class="collapse" for="c-41507611">[-]</label><label class="expand" for="c-41507611">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see that as a problem at all:<p>&quot;Hey any teams out there, before you can add internal headers, you need to register them with some service.&quot; Then the list is loaded from static storage at startup time and&#x2F;or refreshed on some periodic basis.</div><br/></div></div></div></div></div></div><div id="41501708" class="c"><input type="checkbox" id="c-41501708" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41505118">prev</a><span>|</span><a href="#41502249">next</a><span>|</span><label class="collapse" for="c-41501708">[-]</label><label class="expand" for="c-41501708">[17 more]</label></div><br/><div class="children"><div class="content">Yeah, me too, but systems grew over time and grew and grew and we were using HTTP headers for all sorts of stuff. This optimization makes the situation better, but the solution (which is underway) is to use a different mechanism for IPC and get rid of the use of HTTP headers completely.</div><br/><div id="41501749" class="c"><input type="checkbox" id="c-41501749" checked=""/><div class="controls bullet"><span class="by">throwaway77385</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501708">parent</a><span>|</span><a href="#41501891">next</a><span>|</span><label class="collapse" for="c-41501749">[-]</label><label class="expand" for="c-41501749">[1 more]</label></div><br/><div class="children"><div class="content">For anyone not in the loop, the above poster (JGC) is Cloudflare&#x27;s CTO himself :)</div><br/></div></div><div id="41501891" class="c"><input type="checkbox" id="c-41501891" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501708">parent</a><span>|</span><a href="#41501749">prev</a><span>|</span><a href="#41501744">next</a><span>|</span><label class="collapse" for="c-41501891">[-]</label><label class="expand" for="c-41501891">[8 more]</label></div><br/><div class="children"><div class="content">I’m certainly familiar with systems growing over time and outgrowing their original schema.<p>Is this the same phenomenon that resulted in Cloudflare Tunnels apparently being domain names?  Or why domains that are proxied by Cloudflare show up as “CNAME” in the DNS panel?  (The latter one seems extra strange — wasn’t the reverse proxy service the very first service that Cloudflare offered?  There must be some history here.)</div><br/><div id="41502080" class="c"><input type="checkbox" id="c-41502080" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501891">parent</a><span>|</span><a href="#41501744">next</a><span>|</span><label class="collapse" for="c-41502080">[-]</label><label class="expand" for="c-41502080">[7 more]</label></div><br/><div class="children"><div class="content">All new products are full of scaffolding that has to be removed when robustness becomes a higher priority than existence. Where we fail is not calling it that. Instead we just call some code “good” while our thicker skinned coworkers call the rest “fine”. It’s not fine. I don’t want to be working overtime the week of thanksgiving because you can’t think past the horizon.</div><br/><div id="41503556" class="c"><input type="checkbox" id="c-41503556" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502080">parent</a><span>|</span><a href="#41502421">next</a><span>|</span><label class="collapse" for="c-41503556">[-]</label><label class="expand" for="c-41503556">[5 more]</label></div><br/><div class="children"><div class="content">There is a very fine line between &quot;good enough&quot; and &quot;not good enough&quot; in any product beyond a certain complexity. Finding the pieces that cross that line can be hard and improving &quot;good enough&quot; parts is (sadly) mostly a waste of time in commercial settings.</div><br/><div id="41503688" class="c"><input type="checkbox" id="c-41503688" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503556">parent</a><span>|</span><a href="#41503904">next</a><span>|</span><label class="collapse" for="c-41503688">[-]</label><label class="expand" for="c-41503688">[3 more]</label></div><br/><div class="children"><div class="content">You have to backdate starting a project so it happens before things stop being good enough. And take into account bad estimates and the five other deadlines between then and now.<p>Often it’s better to clean as you go. If you have the time and the inclination, shore up one of the least good enough things.<p>It’s not unheard of to open up new feature sets via refactoring. Something that previously would have taken an “impossible” amount of time now becomes profitable, not just possible.</div><br/><div id="41507277" class="c"><input type="checkbox" id="c-41507277" checked=""/><div class="controls bullet"><span class="by">dmorgan81</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503688">parent</a><span>|</span><a href="#41503904">next</a><span>|</span><label class="collapse" for="c-41507277">[-]</label><label class="expand" for="c-41507277">[2 more]</label></div><br/><div class="children"><div class="content">I miss working at a place where that was encouraged. Now if I do that the testers complain that it’s not in scope for the ticket and to split the changes into another ticket with a separate test plan. The rot thus continues.</div><br/><div id="41507347" class="c"><input type="checkbox" id="c-41507347" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41507277">parent</a><span>|</span><a href="#41503904">next</a><span>|</span><label class="collapse" for="c-41507347">[-]</label><label class="expand" for="c-41507347">[1 more]</label></div><br/><div class="children"><div class="content">I think this is about when I discovered zone defense for performance optimization. QA doesn’t want to chase your code changes halfway across the codebase, and that’s fair. At some point it starts looking like you’re changing things just to change them, even if it ends up being a few percent better.<p>But if you limit yourself to one part of the interaction, they don’t get as mad. A dozen changes in the signup system piss them off less than five changes across the app.</div><br/></div></div></div></div></div></div><div id="41503904" class="c"><input type="checkbox" id="c-41503904" checked=""/><div class="controls bullet"><span class="by">didgetmaster</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503556">parent</a><span>|</span><a href="#41503688">prev</a><span>|</span><a href="#41502421">next</a><span>|</span><label class="collapse" for="c-41503904">[-]</label><label class="expand" for="c-41503904">[1 more]</label></div><br/><div class="children"><div class="content">This is why some bugs never get fixed (that is if you define a bug to include inefficient code and not just code that breaks something).</div><br/></div></div></div></div></div></div></div></div><div id="41501744" class="c"><input type="checkbox" id="c-41501744" checked=""/><div class="controls bullet"><span class="by">DamonHD</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501708">parent</a><span>|</span><a href="#41501891">prev</a><span>|</span><a href="#41503336">next</a><span>|</span><label class="collapse" for="c-41501744">[-]</label><label class="expand" for="c-41501744">[6 more]</label></div><br/><div class="children"><div class="content">And when that happy day dawns, slightly sadly, this nice optimisation will evaporate!</div><br/><div id="41502306" class="c"><input type="checkbox" id="c-41502306" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501744">parent</a><span>|</span><a href="#41503336">next</a><span>|</span><label class="collapse" for="c-41502306">[-]</label><label class="expand" for="c-41502306">[5 more]</label></div><br/><div class="children"><div class="content">Maybe the real treasure was the optimizations we made and discarded along the way.</div><br/><div id="41502636" class="c"><input type="checkbox" id="c-41502636" checked=""/><div class="controls bullet"><span class="by">DamonHD</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502306">parent</a><span>|</span><a href="#41504433">next</a><span>|</span><label class="collapse" for="c-41502636">[-]</label><label class="expand" for="c-41502636">[3 more]</label></div><br/><div class="children"><div class="content">Indeed.  I am very happy with some of the tricks that I developed (speeding up, and indeed allowing, Solaris C++ linking by prefiltering on MD5 hashes of canonicalised .o files -&gt; nm, anyone?) even though they were lost without trace (yep, Lehman Brothers, where are my Imakefiles now?)...</div><br/><div id="41503330" class="c"><input type="checkbox" id="c-41503330" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502636">parent</a><span>|</span><a href="#41504433">next</a><span>|</span><label class="collapse" for="c-41503330">[-]</label><label class="expand" for="c-41503330">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re probably as critical as ever at Barclays :)</div><br/><div id="41503579" class="c"><input type="checkbox" id="c-41503579" checked=""/><div class="controls bullet"><span class="by">DamonHD</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41503330">parent</a><span>|</span><a href="#41504433">next</a><span>|</span><label class="collapse" for="c-41503579">[-]</label><label class="expand" for="c-41503579">[1 more]</label></div><br/><div class="children"><div class="content">I really hope not, given that that very old Solaris compiler should have been laid to rest many many years ago.  Yes, some of my stuff had kinda made it into BarCap (even onto my desktop dev machine!) when I turned up there later, and even some at Nomura when I rocked up there again IIRC!</div><br/></div></div></div></div></div></div><div id="41504433" class="c"><input type="checkbox" id="c-41504433" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502306">parent</a><span>|</span><a href="#41502636">prev</a><span>|</span><a href="#41503336">next</a><span>|</span><label class="collapse" for="c-41504433">[-]</label><label class="expand" for="c-41504433">[1 more]</label></div><br/><div class="children"><div class="content">My likely overly cynical concern here is that this suggests trie-hard will soon end up abandoned, as you&#x27;re making it sound like it is a stop-gap solution for you.</div><br/></div></div></div></div></div></div><div id="41503336" class="c"><input type="checkbox" id="c-41503336" checked=""/><div class="controls bullet"><span class="by">alex_suzuki</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41501708">parent</a><span>|</span><a href="#41501744">prev</a><span>|</span><a href="#41502249">next</a><span>|</span><label class="collapse" for="c-41503336">[-]</label><label class="expand" for="c-41503336">[1 more]</label></div><br/><div class="children"><div class="content">You chiming in on this post makes me slightly bitter at having gone with CloudFront (I have everything on AWS so it seemed the obvious choice) instead of Cloudflare.</div><br/></div></div></div></div><div id="41502249" class="c"><input type="checkbox" id="c-41502249" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41501708">prev</a><span>|</span><a href="#41506630">next</a><span>|</span><label class="collapse" for="c-41502249">[-]</label><label class="expand" for="c-41502249">[6 more]</label></div><br/><div class="children"><div class="content">Other ideas:<p><pre><code>  - Ensure all headers added internally that are not for export at the front of the header list
  - Preseed the hashtable of all requests with internal headers you plan to remove.  
</code></pre>
In fact, if you preseed, you are basically combining these ideas but fixing how many internal headers are on each request.  At that point, you can use a linked hash table that preserves creation order and just remove the first N from the final list that you send back to clients.</div><br/><div id="41502437" class="c"><input type="checkbox" id="c-41502437" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502249">parent</a><span>|</span><a href="#41506630">next</a><span>|</span><label class="collapse" for="c-41502437">[-]</label><label class="expand" for="c-41502437">[5 more]</label></div><br/><div class="children"><div class="content">&gt; At that point, you can use a linked hash table that preserves creation order and just remove the first N from the final list that you send back to clients.<p>While Python provides data structures like this out of the box, designing a big system to require a special, nonstandard data structure to identify private metadata seems like a mistake to me.</div><br/><div id="41502693" class="c"><input type="checkbox" id="c-41502693" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502437">parent</a><span>|</span><a href="#41506630">next</a><span>|</span><label class="collapse" for="c-41502693">[-]</label><label class="expand" for="c-41502693">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I follow?  Does rust not have the equivalent of a LinkedHashMap from Java?  All I&#x27;m proposing is to start each map of headers off with a sentinel value for all of the headers you don&#x27;t intend to send back to the client.  Then, have a method that iterates over all values, for the places you need to send to internal servers, and another (probably the default?) that starts iteration after all of the internal items, which should just be a different pointer.  At this point, there is no need to inspect each header by name, as that was effectively done at compile time when you put the protected headers at the front of the list.<p>Is this somewhat special?  I mean, sure.  But it wasn&#x27;t long ago that a hash table was already in the special territory of data structures.<p>Edit: I should add that I&#x27;m not certain this idea would be better.  Just more ideas on what you could do.</div><br/><div id="41502826" class="c"><input type="checkbox" id="c-41502826" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502693">parent</a><span>|</span><a href="#41506630">next</a><span>|</span><label class="collapse" for="c-41502826">[-]</label><label class="expand" for="c-41502826">[3 more]</label></div><br/><div class="children"><div class="content">There’s a third party crate for this. C++’s STL also doesn’t have it by default.<p>The creation-order-preserving hash map is basically two data structures in one, it’s more complex and slower than a normal hash map, and IMO it’s rather bizarre and I have never really understood why anyone wants one.</div><br/><div id="41503038" class="c"><input type="checkbox" id="c-41503038" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502826">parent</a><span>|</span><a href="#41503020">next</a><span>|</span><label class="collapse" for="c-41503038">[-]</label><label class="expand" for="c-41503038">[1 more]</label></div><br/><div class="children"><div class="content">I would be surprised if it was dramatically slower, all told.  Though, fair that  I have not benchmarked in a long time, here.<p>My main &quot;idea&quot; here is to stop from having to check all of the headers on a &quot;per header&quot; basis.  Yes, you can make each check faster, as the TRIE does.  You can also remove the entire reason to check individual headers by starting a traversal after where the internal headers are.<p>You could also go with something like making sure the first header is &quot;InternalHeaderCount: N&quot; where you then keep the internal headers segregated form the others by a simple count.  (This assumes you have solid control over what is adding the headers internally, of course.)<p>(I also forgot to give kudos on the blog title.  Any Die Hard reference is a good reference. :D )</div><br/></div></div><div id="41503020" class="c"><input type="checkbox" id="c-41503020" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502826">parent</a><span>|</span><a href="#41503038">prev</a><span>|</span><a href="#41506630">next</a><span>|</span><label class="collapse" for="c-41503020">[-]</label><label class="expand" for="c-41503020">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s especially unfortunate that the intuitive name, `std::map`, is that ordered and generally least useful option of the standard library&#x27;s three hash map containers.<p>My last job did rely on ordered-ness of `QMap`, because the elements are listed in a Qt GUI and it could confuse users if those widgets randomly rearranged themselves. That&#x27;s the only use-case I&#x27;ve personally encountered for an ordered hash map.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41506630" class="c"><input type="checkbox" id="c-41506630" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41502249">prev</a><span>|</span><a href="#41505978">next</a><span>|</span><label class="collapse" for="c-41506630">[-]</label><label class="expand" for="c-41506630">[1 more]</label></div><br/><div class="children"><div class="content">X years ago the manager of the cache team raised the lack of data plane and control plane separation as an issue and we came up with various plans to fix things, but I guess nothing has happened since</div><br/></div></div><div id="41505978" class="c"><input type="checkbox" id="c-41505978" checked=""/><div class="controls bullet"><span class="by">danbruc</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41506630">prev</a><span>|</span><a href="#41503067">next</a><span>|</span><label class="collapse" for="c-41505978">[-]</label><label class="expand" for="c-41505978">[1 more]</label></div><br/><div class="children"><div class="content">This might of course introduce quite a bit of overhead, but the clean solution would arguably be to not mix requests to begin with, the external requests you are processing are the payload of the requests you are sending around internally. This would also allow you to cook up an optimized encapsulation protocol that might be more efficient to process than parsing and modifying HTTP. This admittedly comes from someone with essentially zero knowledge of what exactly Cloudflare is doing to the requests they receive.</div><br/></div></div><div id="41503067" class="c"><input type="checkbox" id="c-41503067" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41505978">prev</a><span>|</span><a href="#41501779">next</a><span>|</span><label class="collapse" for="c-41503067">[-]</label><label class="expand" for="c-41503067">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What if someone else uses this name?<p>Couldn&#x27;t you bypass this by pre-fixing the ones that aren&#x27;t yours? Or prefixing your internal ones with something unique enough?</div><br/></div></div><div id="41502111" class="c"><input type="checkbox" id="c-41502111" checked=""/><div class="controls bullet"><span class="by">620gelato</span><span>|</span><a href="#41501684">parent</a><span>|</span><a href="#41501779">prev</a><span>|</span><a href="#41504082">next</a><span>|</span><label class="collapse" for="c-41502111">[-]</label><label class="expand" for="c-41502111">[4 more]</label></div><br/><div class="children"><div class="content">Or perhaps even, insert yet another header with just the list of internal headers being added to the request, assuming this happens at a single place, otherwise a recipe for disaster.<p>I have a slightly different example of this, where a rpc framework used in my company disallows the service owner from modifying certain headers (say request identifier), and will instead create a duplicate header with a suffix. In that scenario at least, I can see this as a fairly reasonable tradeoff, as the goal is to control certain headers from being modified, not because they are platform internal but because there are certain assumptions associated with those headers that are followed company-wide.<p>I&#x27;ll go check what mechanism is used for this matching.</div><br/><div id="41504902" class="c"><input type="checkbox" id="c-41504902" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502111">parent</a><span>|</span><a href="#41503266">next</a><span>|</span><label class="collapse" for="c-41504902">[-]</label><label class="expand" for="c-41504902">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>yet another header with just the list of internal headers</i><p>Or the same but with a list of headers which AREN&#x27;T internal.<p>You&#x27;ll probably have a custom header-adding function that people should always use instead of the regular one. And this way, if someone forgets to use it, their header will get stripped.<p>You can think of a header escaping the internal network as something that needs to be authorized. This is a deny by default approach.</div><br/><div id="41505251" class="c"><input type="checkbox" id="c-41505251" checked=""/><div class="controls bullet"><span class="by">620gelato</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41504902">parent</a><span>|</span><a href="#41503266">next</a><span>|</span><label class="collapse" for="c-41505251">[-]</label><label class="expand" for="c-41505251">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes - perfect.</div><br/></div></div></div></div><div id="41503266" class="c"><input type="checkbox" id="c-41503266" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41501684">root</a><span>|</span><a href="#41502111">parent</a><span>|</span><a href="#41504902">prev</a><span>|</span><a href="#41504082">next</a><span>|</span><label class="collapse" for="c-41503266">[-]</label><label class="expand" for="c-41503266">[1 more]</label></div><br/><div class="children"><div class="content">This doesn’t work if the front end is older than an internal node and a header gets added, at least not without extra logic to patch everything up and handle conflicts.<p>The HTTP Connection header works like this, and one should generally assume that almost nothing implements it correctly.</div><br/></div></div></div></div></div></div><div id="41504082" class="c"><input type="checkbox" id="c-41504082" checked=""/><div class="controls bullet"><span class="by">pragma_x</span><span>|</span><a href="#41501684">prev</a><span>|</span><a href="#41502531">next</a><span>|</span><label class="collapse" for="c-41504082">[-]</label><label class="expand" for="c-41504082">[2 more]</label></div><br/><div class="children"><div class="content">It took me a moment to ponder the effectiveness of mapping utf8 characters into a bitmask.  At first, it seemed unwise.  Then I realized that 32 bits would get you `a-z` plus six special characters, and 64 bits would get you &#x27;A-Z&#x27; (uppercase) plus six more.  That&#x27;s plenty of room for HTTP headers, and for a blazing fast matching algorithm since it just masks and compares a couple integers.  Even figuring out which bit corresponds to which character is a simple lookup into a 256-word table.<p>One thing the author leaves out is this technique is technically a Bloom Filter.  I find these kinds of things fascinating since they came about in an era where computing was far more resource bound than today (1970 in this case).  But here we are, still finding real-world corners to use the same old optimizations.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bloom_filter" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bloom_filter</a></div><br/><div id="41505422" class="c"><input type="checkbox" id="c-41505422" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41504082">parent</a><span>|</span><a href="#41502531">next</a><span>|</span><label class="collapse" for="c-41505422">[-]</label><label class="expand" for="c-41505422">[1 more]</label></div><br/><div class="children"><div class="content">There are significant differences between trie-hard and a Bloom filter. Bloom filters are probabilistic, and use hashing.  They&#x27;re great for when rare false positives are acceptable in exchange for no false negatives, which isn&#x27;t uncommon, but isn&#x27;t what&#x27;s needed here: this is exact, and hashing is the step to beat.<p>Rather, this is a refinement&#x2F;variation on Liang&#x27;s algorithm, used in TeX for storing a hyphenation dictionary.  The thesis mentions Bloom&#x27;s algorithm, which it calls &quot;superimposed coding&quot;, and very much hearkens back to a time when memory was often the most precious commodity. I think you&#x27;ll like it. ^_^<p><a href="https:&#x2F;&#x2F;tug.org&#x2F;docs&#x2F;liang&#x2F;liang-thesis.pdf" rel="nofollow">https:&#x2F;&#x2F;tug.org&#x2F;docs&#x2F;liang&#x2F;liang-thesis.pdf</a></div><br/></div></div></div></div><div id="41502531" class="c"><input type="checkbox" id="c-41502531" checked=""/><div class="controls bullet"><span class="by">mightyham</span><span>|</span><a href="#41504082">prev</a><span>|</span><a href="#41501970">next</a><span>|</span><label class="collapse" for="c-41502531">[-]</label><label class="expand" for="c-41502531">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not very well versed in data structure optimization, but I was surprised they dismissed hash tables so quickly, especially when the table they are searching through is static. I find it somewhat hard to believe that a specially optimized hash table would not be faster than their trie implementation.</div><br/><div id="41502688" class="c"><input type="checkbox" id="c-41502688" checked=""/><div class="controls bullet"><span class="by">5kg</span><span>|</span><a href="#41502531">parent</a><span>|</span><a href="#41502613">next</a><span>|</span><label class="collapse" for="c-41502688">[-]</label><label class="expand" for="c-41502688">[2 more]</label></div><br/><div class="children"><div class="content">There is FxHashMap (<a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustc-hash">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustc-hash</a>) which is faster than std::collections::HashMap.<p>With ~100 static entries, o1hash (<a href="https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;smhasher&#x2F;blob&#x2F;master&#x2F;o1hash.h">https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;smhasher&#x2F;blob&#x2F;master&#x2F;o1hash.h</a>) should also work.</div><br/><div id="41503633" class="c"><input type="checkbox" id="c-41503633" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502688">parent</a><span>|</span><a href="#41502613">next</a><span>|</span><label class="collapse" for="c-41503633">[-]</label><label class="expand" for="c-41503633">[1 more]</label></div><br/><div class="children"><div class="content">Note FxHashMap is just the std HashMap with a different hashing algorithm.</div><br/></div></div></div></div><div id="41502613" class="c"><input type="checkbox" id="c-41502613" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#41502531">parent</a><span>|</span><a href="#41502688">prev</a><span>|</span><a href="#41505458">next</a><span>|</span><label class="collapse" for="c-41502613">[-]</label><label class="expand" for="c-41502613">[12 more]</label></div><br/><div class="children"><div class="content">They mentioned it is the overhead of the hashing that makes it slow compared to the trie.</div><br/><div id="41502696" class="c"><input type="checkbox" id="c-41502696" checked=""/><div class="controls bullet"><span class="by">mightyham</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502613">parent</a><span>|</span><a href="#41503358">next</a><span>|</span><label class="collapse" for="c-41502696">[-]</label><label class="expand" for="c-41502696">[5 more]</label></div><br/><div class="children"><div class="content">The point I&#x27;m making is that a specially optimized hashing function would probably blow away any trie traversal. When you know the data being hashed before hand it is possible to make custom hash functions that are as simple as a few bitwise operations on the first, middle and last character of the string (just an example).</div><br/><div id="41502933" class="c"><input type="checkbox" id="c-41502933" checked=""/><div class="controls bullet"><span class="by">dividuum</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502696">parent</a><span>|</span><a href="#41509198">next</a><span>|</span><label class="collapse" for="c-41502933">[-]</label><label class="expand" for="c-41502933">[1 more]</label></div><br/><div class="children"><div class="content">Right. Out of curiosity I looked into what code gperf generates and it seems it would end up O(1) for misses (it&#x27;s always three lookups into a generated table) and O(L) for hits, as a potential hit has to be confirmed by essentially a strcmp. Not sure how something like <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-phf&#x2F;rust-phf">https:&#x2F;&#x2F;github.com&#x2F;rust-phf&#x2F;rust-phf</a> would work, but probably similar?</div><br/></div></div><div id="41509198" class="c"><input type="checkbox" id="c-41509198" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502696">parent</a><span>|</span><a href="#41502933">prev</a><span>|</span><a href="#41506437">next</a><span>|</span><label class="collapse" for="c-41509198">[-]</label><label class="expand" for="c-41509198">[1 more]</label></div><br/><div class="children"><div class="content">if all your internal headers start with cf- and most non-internal headers don&#x27;t (but not all) and most headers are non-internal a trie might be hard to beat</div><br/></div></div><div id="41506437" class="c"><input type="checkbox" id="c-41506437" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502696">parent</a><span>|</span><a href="#41509198">prev</a><span>|</span><a href="#41503198">next</a><span>|</span><label class="collapse" for="c-41506437">[-]</label><label class="expand" for="c-41506437">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t know all the data that&#x27;s being hashed, though. They know everything that&#x27;s in the map, but not all the keys they&#x27;re trying to lookup.</div><br/></div></div><div id="41503198" class="c"><input type="checkbox" id="c-41503198" checked=""/><div class="controls bullet"><span class="by">treis</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502696">parent</a><span>|</span><a href="#41506437">prev</a><span>|</span><a href="#41503358">next</a><span>|</span><label class="collapse" for="c-41503198">[-]</label><label class="expand" for="c-41503198">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the sticky wicket collisions with external to CF defined headers?</div><br/></div></div></div></div><div id="41503358" class="c"><input type="checkbox" id="c-41503358" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502613">parent</a><span>|</span><a href="#41502696">prev</a><span>|</span><a href="#41502672">next</a><span>|</span><label class="collapse" for="c-41503358">[-]</label><label class="expand" for="c-41503358">[1 more]</label></div><br/><div class="children"><div class="content">If they just used the default, that&#x27;s SipHash which is optimized for security and DOS resistance, not performance. XXh3 is ~10x faster than that and there&#x27;s some newer ones that are even faster than Xxh3 like GxHash (like another ~1.5x-2x faster).<p>You would precompute the hash for the constant string list &amp; then compute the hash only for for the set of strings that begin with C&#x2F;c since &quot;cf-&quot; is a common prefix for those internal headers if I recall correctly, using RawTable to find entries by hash &amp; then comparing against the precomputed value to see if a collision matched before checking a string for equality.</div><br/></div></div><div id="41502672" class="c"><input type="checkbox" id="c-41502672" checked=""/><div class="controls bullet"><span class="by">hooli42</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502613">parent</a><span>|</span><a href="#41503358">prev</a><span>|</span><a href="#41505458">next</a><span>|</span><label class="collapse" for="c-41502672">[-]</label><label class="expand" for="c-41502672">[5 more]</label></div><br/><div class="children"><div class="content">Hash functions can be as simple as a single modulo.</div><br/><div id="41506633" class="c"><input type="checkbox" id="c-41506633" checked=""/><div class="controls bullet"><span class="by">torusle</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502672">parent</a><span>|</span><a href="#41503011">next</a><span>|</span><label class="collapse" for="c-41506633">[-]</label><label class="expand" for="c-41506633">[1 more]</label></div><br/><div class="children"><div class="content">Or as simple as using the hardware accelerated CRC32 that we have in our x86 CPUs.<p>Last time I checked, CRC32 worked surprisingly well as a hash.</div><br/></div></div><div id="41503011" class="c"><input type="checkbox" id="c-41503011" checked=""/><div class="controls bullet"><span class="by">ironman1478</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41502672">parent</a><span>|</span><a href="#41506633">prev</a><span>|</span><a href="#41505458">next</a><span>|</span><label class="collapse" for="c-41503011">[-]</label><label class="expand" for="c-41503011">[3 more]</label></div><br/><div class="children"><div class="content">As they said though, the hash function on a string type requires looking at every element in the string. Also, modulo is historically very slow. So, they still have to deal with O(n) operations, where n is the length of the input string. If they can improve the memory hopping problem associated with lists &#x2F; graph structures (which they claim to have done in their library), then a trie could would be much fast enough, which is what they observed. Combined with the fact that they claim that 90% of the time there is a miss when querying the trie, then you exit early a lot, whereas you always need to compute the whole hash on the input string when doing the hash map strategy.</div><br/><div id="41503308" class="c"><input type="checkbox" id="c-41503308" checked=""/><div class="controls bullet"><span class="by">mightyham</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41503011">parent</a><span>|</span><a href="#41503240">next</a><span>|</span><label class="collapse" for="c-41503308">[-]</label><label class="expand" for="c-41503308">[1 more]</label></div><br/><div class="children"><div class="content">The hash does not need to be computed on the whole string. I pointed this out in my other comment but just as a example: a hash function could be as simple as xoring the first 16 and last 16 bits of the string then indexing a 2^16 array. That means hashing is two pointer offsets and an xor (no modulo required). If there are 100 strings that need to be removed, then ~99% of rejections will be a very fast O(1).<p>And in the case of a match, a fast hash + memcmp will be way faster than a trie traversal. In fact, according to the trie-hard github readme, std::HashMap is already much faster than their trie implementation when searching for a match.</div><br/></div></div><div id="41503240" class="c"><input type="checkbox" id="c-41503240" checked=""/><div class="controls bullet"><span class="by">hervature</span><span>|</span><a href="#41502531">root</a><span>|</span><a href="#41503011">parent</a><span>|</span><a href="#41503308">prev</a><span>|</span><a href="#41505458">next</a><span>|</span><label class="collapse" for="c-41503240">[-]</label><label class="expand" for="c-41503240">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As they said though, the hash function on a string type requires looking at every element in the string.<p>Maybe for the default hash function. As another commenter pointed out, your data may make the following hash very effective: s[0] + s[len(s)&#x2F;&#x2F;2] + s[-1] which would be very fast. The point being is spending a day seeing if such a hash exists is worth it.</div><br/></div></div></div></div></div></div></div></div><div id="41505458" class="c"><input type="checkbox" id="c-41505458" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41502531">parent</a><span>|</span><a href="#41502613">prev</a><span>|</span><a href="#41501970">next</a><span>|</span><label class="collapse" for="c-41505458">[-]</label><label class="expand" for="c-41505458">[1 more]</label></div><br/><div class="children"><div class="content">A hash function can&#x27;t reject a string with a single test of the first byte. It just can&#x27;t.<p>For this application, that&#x27;s a leg up which a hash won&#x27;t be able to touch.  The rest of the art here is shaving down the constant factor of a trie far enough that the initial boost pays off in real-world performance.</div><br/></div></div></div></div><div id="41501970" class="c"><input type="checkbox" id="c-41501970" checked=""/><div class="controls bullet"><span class="by">miso2024</span><span>|</span><a href="#41502531">prev</a><span>|</span><a href="#41502118">next</a><span>|</span><label class="collapse" for="c-41501970">[-]</label><label class="expand" for="c-41501970">[6 more]</label></div><br/><div class="children"><div class="content">Finally a blog post with a trie.
Those trie leetcodes didn&#x27;t go in vain ;)</div><br/><div id="41503562" class="c"><input type="checkbox" id="c-41503562" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41501970">parent</a><span>|</span><a href="#41502823">next</a><span>|</span><label class="collapse" for="c-41503562">[-]</label><label class="expand" for="c-41503562">[1 more]</label></div><br/><div class="children"><div class="content">I’ve used them in real code! They are pretty intuitive for some use cases. The last time I used a trie was for address lookup. I even used a generator, haha. Double whammy leetcode in real life situation I guess.<p>It’s definitely not a common tool I reach for though.</div><br/></div></div><div id="41502823" class="c"><input type="checkbox" id="c-41502823" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41501970">parent</a><span>|</span><a href="#41503562">prev</a><span>|</span><a href="#41508396">next</a><span>|</span><label class="collapse" for="c-41502823">[-]</label><label class="expand" for="c-41502823">[2 more]</label></div><br/><div class="children"><div class="content">You will find them in any fast spelling or grammar verifier.</div><br/><div id="41505272" class="c"><input type="checkbox" id="c-41505272" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#41501970">root</a><span>|</span><a href="#41502823">parent</a><span>|</span><a href="#41508396">next</a><span>|</span><label class="collapse" for="c-41505272">[-]</label><label class="expand" for="c-41505272">[1 more]</label></div><br/><div class="children"><div class="content">Routing libraries as well. In Clojure, the reitit library uses a prefix tree implementation when the route table is large enough for linear search to be non-optimal.[1] The Go ecosystem also has httprouter, which uses prefix trees under the hood.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;metosin&#x2F;reitit&#x2F;blob&#x2F;master&#x2F;doc&#x2F;performance.md">https:&#x2F;&#x2F;github.com&#x2F;metosin&#x2F;reitit&#x2F;blob&#x2F;master&#x2F;doc&#x2F;performanc...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;julienschmidt&#x2F;httprouter#how-does-it-work">https:&#x2F;&#x2F;github.com&#x2F;julienschmidt&#x2F;httprouter#how-does-it-work</a></div><br/></div></div></div></div><div id="41508396" class="c"><input type="checkbox" id="c-41508396" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41501970">parent</a><span>|</span><a href="#41502823">prev</a><span>|</span><a href="#41504483">next</a><span>|</span><label class="collapse" for="c-41508396">[-]</label><label class="expand" for="c-41508396">[1 more]</label></div><br/><div class="children"><div class="content">i find myself reaching for a trie&#x2F;radix-tree from time to time in medium-complexity build tools or code analysis scripts, where I need to store some information about zillions of filepaths, and factoring out the common prefixes saves a ton of memory while being pretty intuitive</div><br/></div></div><div id="41504483" class="c"><input type="checkbox" id="c-41504483" checked=""/><div class="controls bullet"><span class="by">ayuhito</span><span>|</span><a href="#41501970">parent</a><span>|</span><a href="#41508396">prev</a><span>|</span><a href="#41502118">next</a><span>|</span><label class="collapse" for="c-41504483">[-]</label><label class="expand" for="c-41504483">[1 more]</label></div><br/><div class="children"><div class="content">I recently got a chance to find a practical use for a modified hybrid trie which was fun to implement! Lots of optimisations to go around.<p>It’s a nifty user-agent parser for Go: <a href="https:&#x2F;&#x2F;github.com&#x2F;medama-io&#x2F;go-useragent">https:&#x2F;&#x2F;github.com&#x2F;medama-io&#x2F;go-useragent</a><p>Typically this sort of problem relies on lots of regex parsing, so it was nice to take a more novel approach.</div><br/></div></div></div></div><div id="41502118" class="c"><input type="checkbox" id="c-41502118" checked=""/><div class="controls bullet"><span class="by">evmar</span><span>|</span><a href="#41501970">prev</a><span>|</span><a href="#41501788">next</a><span>|</span><label class="collapse" for="c-41502118">[-]</label><label class="expand" for="c-41502118">[1 more]</label></div><br/><div class="children"><div class="content">This post uses a fancy data structure to construct a to_remove set, then iterates through it to remove these from the underlying header map.<p>It appears the &quot;remove_header&quot; call is this one: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;pingora-http&#x2F;0.3.0&#x2F;src&#x2F;pingora_http&#x2F;lib.rs.html#576" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;pingora-http&#x2F;0.3.0&#x2F;src&#x2F;pingora_http&#x2F;lib.rs.h...</a>
which calls .remove() on two other data structures, both of which bottom out in this mountain of code: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;http&#x2F;latest&#x2F;src&#x2F;http&#x2F;header&#x2F;map.rs.html#1550" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;http&#x2F;latest&#x2F;src&#x2F;http&#x2F;header&#x2F;map.rs.html#1550</a></div><br/></div></div><div id="41501788" class="c"><input type="checkbox" id="c-41501788" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#41502118">prev</a><span>|</span><a href="#41508823">next</a><span>|</span><label class="collapse" for="c-41501788">[-]</label><label class="expand" for="c-41501788">[7 more]</label></div><br/><div class="children"><div class="content">Did you try a (tiny) bloom filter? Doing a quick convolution of the header key and a test against a bloom filter (SIMD? Using builtin CRC ops? 256-bit bloom filter size?) might avoid walking the trie altogether in most cases at the cost of a few cycles.</div><br/><div id="41502286" class="c"><input type="checkbox" id="c-41502286" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41501788">parent</a><span>|</span><a href="#41504184">next</a><span>|</span><label class="collapse" for="c-41502286">[-]</label><label class="expand" for="c-41502286">[3 more]</label></div><br/><div class="children"><div class="content">I do not know if the team did that but Bloom filters aren&#x27;t a panacea: <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;when-bloom-filters-dont-bloom&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;when-bloom-filters-dont-bloom&#x2F;</a></div><br/><div id="41505566" class="c"><input type="checkbox" id="c-41505566" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41501788">root</a><span>|</span><a href="#41502286">parent</a><span>|</span><a href="#41502524">next</a><span>|</span><label class="collapse" for="c-41505566">[-]</label><label class="expand" for="c-41505566">[1 more]</label></div><br/><div class="children"><div class="content">A bloom filter will have the same weaknesses of needing to do a hash. For static filters like this though where you have the set of strings to check against known up front, something like a binary fuse filter could work really well as it&#x27;s significantly faster than bloom filters when you don&#x27;t need online construction (you still need to do a hash of course but the evaluation against std::HashMap is flawed since it uses SipHash instead of modern constructions like xxh3 or gxhash).</div><br/></div></div><div id="41502524" class="c"><input type="checkbox" id="c-41502524" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#41501788">root</a><span>|</span><a href="#41502286">parent</a><span>|</span><a href="#41505566">prev</a><span>|</span><a href="#41504184">next</a><span>|</span><label class="collapse" for="c-41502524">[-]</label><label class="expand" for="c-41502524">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, for this problem you&#x27;d want a bloom filter that can entirely fit in vector registers during the computation, which should work well for a few hundred items.</div><br/></div></div></div></div><div id="41504184" class="c"><input type="checkbox" id="c-41504184" checked=""/><div class="controls bullet"><span class="by">pragma_x</span><span>|</span><a href="#41501788">parent</a><span>|</span><a href="#41502286">prev</a><span>|</span><a href="#41502280">next</a><span>|</span><label class="collapse" for="c-41504184">[-]</label><label class="expand" for="c-41504184">[1 more]</label></div><br/><div class="children"><div class="content">Considering that each node&#x27;s filter in their trie implementation is bloom-like already, the solution is awful close.  I agree that testing wider swaths of the string at once might be a dramatic accelerator.<p>A more naive approach might also be warranted. Some frequency analysis of hit&#x2F;miss for trie nodes might allow them to find specific character positions with a higher miss rate than the first one.  Testing such special positions first would speed things up. That assumes, of course, that the header data is fairly regular in nature.</div><br/></div></div><div id="41503345" class="c"><input type="checkbox" id="c-41503345" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#41501788">parent</a><span>|</span><a href="#41502280">prev</a><span>|</span><a href="#41508823">next</a><span>|</span><label class="collapse" for="c-41503345">[-]</label><label class="expand" for="c-41503345">[1 more]</label></div><br/><div class="children"><div class="content">I think that would require calculating the hash, which was ruled out as too slow.</div><br/></div></div></div></div><div id="41508823" class="c"><input type="checkbox" id="c-41508823" checked=""/><div class="controls bullet"><span class="by">Buckaroo9</span><span>|</span><a href="#41501788">prev</a><span>|</span><a href="#41502505">next</a><span>|</span><label class="collapse" for="c-41508823">[-]</label><label class="expand" for="c-41508823">[2 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t this line:
&gt; &quot;using regular expressions clocks in as taking about twice as long as the hashmap-based solution.&quot;
be written as the opposite? That the RE takes half as long&#x2F;is twice as fast?</div><br/><div id="41509140" class="c"><input type="checkbox" id="c-41509140" checked=""/><div class="controls bullet"><span class="by">nitnelave</span><span>|</span><a href="#41508823">parent</a><span>|</span><a href="#41502505">next</a><span>|</span><label class="collapse" for="c-41509140">[-]</label><label class="expand" for="c-41509140">[1 more]</label></div><br/><div class="children"><div class="content">I think the point is that naive regex are a very generic purpose tool, but it&#x27;s still in the same ballpark. Having a custom optimized state machine for this specific use case could bring another 5x improvement on top, leading to 2.5x faster, potentially.</div><br/></div></div></div></div><div id="41502505" class="c"><input type="checkbox" id="c-41502505" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41508823">prev</a><span>|</span><a href="#41503484">next</a><span>|</span><label class="collapse" for="c-41502505">[-]</label><label class="expand" for="c-41502505">[2 more]</label></div><br/><div class="children"><div class="content">Given that the set if items to match is static, I wonder if they tried a perfect hash table; that would reduce it to a few arithmetic operations followed by a single string compare.  It would be interesting to see how it compares to the trie.</div><br/><div id="41509257" class="c"><input type="checkbox" id="c-41509257" checked=""/><div class="controls bullet"><span class="by">sjf</span><span>|</span><a href="#41502505">parent</a><span>|</span><a href="#41503484">next</a><span>|</span><label class="collapse" for="c-41509257">[-]</label><label class="expand" for="c-41509257">[1 more]</label></div><br/><div class="children"><div class="content">That is what I immediately thought as well. The problem though is that a perfect hash is still going to be O(key length) for the hash function, which they are trying to avoid.<p>In theory, if they used a regex it would be using a state machine to do the matching, which should have similar performance to the trie- only O(k) in the worst case. But from what I understand regex libraries don&#x27;t actually build the state machine, they use backtracking so the performance is no longer O(k).<p>I&#x27;m surprised they couldn&#x27;t find a performant regex library that already existed that uses state machines. It should have similar performance to the trie. But in reality, the performance is affected more deeply by things like memory access patterns and the performance of specific arithmetic operations, so it&#x27;s impossible really to speculate.</div><br/></div></div></div></div><div id="41503484" class="c"><input type="checkbox" id="c-41503484" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#41502505">prev</a><span>|</span><a href="#41508573">next</a><span>|</span><label class="collapse" for="c-41503484">[-]</label><label class="expand" for="c-41503484">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested to know why the regex crate didn&#x27;t do better. I believe it should compile a search for multiple literal strings into an Aho-Corasick automaton, which is structured very much like a trie.</div><br/><div id="41503883" class="c"><input type="checkbox" id="c-41503883" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#41503484">parent</a><span>|</span><a href="#41508573">next</a><span>|</span><label class="collapse" for="c-41503883">[-]</label><label class="expand" for="c-41503883">[7 more]</label></div><br/><div class="children"><div class="content">regex crate author here. From a quick look at trie-hard, my guess is that trie-hard can do lookups on short strings much more quickly than the regex crate can do matches on short strings. The regex crate has a fair bit of overhead for selecting the right matching engine and applying other optimizations appropriate to general purpose matching.<p>But the aho-corasick crate, and especially the specific automatons, would be interesting to try. There&#x27;s much less overhead there. But, there are some differences:<p>* The contiguous NFA in aho-corasick has a lot more going on inside its &quot;next transition&quot; routine: <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;aho-corasick&#x2F;blob&#x2F;cd400ad792d6888cc8fa4c1f9e2493b519961b3c&#x2F;src&#x2F;nfa&#x2F;contiguous.rs#L186">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;aho-corasick&#x2F;blob&#x2F;cd400ad792d6...</a> --- This is primarily because an Aho-Corasick automaton isn&#x27;t just a trie. It also has failure transitions to support unanchored search. You can search without respecting failure transitions (and thus treat it as a trie), but the code is still there to deal with failure transitions. So that may have deleterious effects.<p>* The contiguous NFA also specializes its transition function depending on the size of the node. It would be interesting to see whether these techniques would be useful for trie-hard to play with. But there is definitely a benefit to keeping one simple and fast code path for all node types. (Less branching.)<p>* The aho-corasick crate does also expose a DFA directly: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;aho-corasick&#x2F;latest&#x2F;aho_corasick&#x2F;dfa&#x2F;struct.DFA.html" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;aho-corasick&#x2F;latest&#x2F;aho_corasick&#x2F;dfa&#x2F;struct....</a> --- In theory this should do less work per transition than trie-hard, and so it would be very interesting to measure its perf when compared to trie-hard. The main downside is that it&#x27;s a DFA and can use up a lot more memory and take longer to build. It seems like Cloudflare cares less about that in favor of optimizing read perf though, so it&#x27;s not clear why they didn&#x27;t go this route.<p>* The aho-corasick crate doesn&#x27;t let you store arbitrary values. You only get back a PatternID when a match occurs. So to get equivalent functionality as trie-hard, you&#x27;d need a separate map of PatternID-&gt;YourValue. Since that isn&#x27;t stored with the data in the trie, this alone might penalize you quite a bit with poorer CPU cache performance.<p>* trie-hard seems to provide some customization options for its representation. i.e., Let&#x27;s you use a `u8` to store its transitions versus a `u128` or `u256`. This might also help with cache usage for a small enough trie.</div><br/><div id="41505624" class="c"><input type="checkbox" id="c-41505624" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41503484">root</a><span>|</span><a href="#41503883">parent</a><span>|</span><a href="#41505684">next</a><span>|</span><label class="collapse" for="c-41505624">[-]</label><label class="expand" for="c-41505624">[3 more]</label></div><br/><div class="children"><div class="content">&gt; can use up a lot more memory and take longer to build<p>Does it support const construction so that you build it during compilation from a static set of strings?</div><br/><div id="41505686" class="c"><input type="checkbox" id="c-41505686" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#41503484">root</a><span>|</span><a href="#41505624">parent</a><span>|</span><a href="#41505684">next</a><span>|</span><label class="collapse" for="c-41505686">[-]</label><label class="expand" for="c-41505686">[2 more]</label></div><br/><div class="children"><div class="content">Nope. That doesn&#x27;t usually help in practice because it&#x27;s not hard to amortize construction with a std::sync::LazyLock.<p>(The `memchr` crate doesn&#x27;t even support const construction of a <i>single</i> substring searcher. I haven&#x27;t spent much time thinking about it because `const` is still pretty limited in what it supports, although progress is being made. For example, you can&#x27;t use trait methods in `const`. So while you can undoubtedly use `const` Rust to build <i>a</i> single substring searcher, whether `const` Rust can be used to build the one in `memchr` specifically isn&#x27;t clear to me. And if it could be done, it will undoubtedly come with development&#x2F;code-clarity costs and it&#x27;s not clear to me that those are worth paying. Because as I said, amortizing construction for a static set of strings is usually very simple to do.)<p>And in any case, &quot;takes a long time to build and uses a lot of memory&quot; isn&#x27;t avoided by doing it at compile time. Instead, you get bloated binaries and longer compile times. Which costs matter more? Dunno, especially when you amortize construction at runtime.</div><br/><div id="41505787" class="c"><input type="checkbox" id="c-41505787" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41503484">root</a><span>|</span><a href="#41505686">parent</a><span>|</span><a href="#41505684">next</a><span>|</span><label class="collapse" for="c-41505787">[-]</label><label class="expand" for="c-41505787">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I guess I was mainly just asking &quot;is const powerful enough yet for this to be a trivial addition&quot;.<p>&gt; Instead, you get bloated binaries and longer compile times<p>Longer compile times probably are solved by having the strings live in a standalone compilation unit which the compiler will end up caching and you can only dirty it by adding a new string. Needing to shuffle that extra data around might still cost extra compile time, but in a real world program I suspect that&#x27;s likely to not matter (both in terms of binary size &amp; that other things in the program will be more expensive to compile).<p>That being said I agree that doing a LazyLock is probably sufficient and given the amount of entries being compared against acquiring the lazy lock probably also gets amortized (it&#x27;s cheap but not free).</div><br/></div></div></div></div></div></div><div id="41505684" class="c"><input type="checkbox" id="c-41505684" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41503484">root</a><span>|</span><a href="#41503883">parent</a><span>|</span><a href="#41505624">prev</a><span>|</span><a href="#41508573">next</a><span>|</span><label class="collapse" for="c-41505684">[-]</label><label class="expand" for="c-41505684">[3 more]</label></div><br/><div class="children"><div class="content">This is a gratifying read (along with the article) because I&#x27;ve been working on closely related things, and had come to the tentative conclusion that taking Aho-Corasick, anchoring it (so no failure transitions), and laying it out in contiguous memory, basically results in Liang&#x27;s packed trie from TeX&#x27;s hyphenation algorithm.<p>trie-hard seems to be effectively that, but with some clever masking to get mileage out of having a limited byte vocabulary to deal with.<p>The DFA might pull ahead, but I wouldn&#x27;t just bet on that. Branch predictors don&#x27;t like lookup tables much, and the memory locality hit is small but real: more of a packed trie fits in a cache line than would a DFA.<p>You seem to have landed on similar conclusions here: beating a packed trie for this specific use case is going to be tough.<p>I also like that they hit on the same popcount-and-shift technique I&#x27;ve used in a data structure for UTF-8 character sets: <a href="https:&#x2F;&#x2F;github.com&#x2F;mnemnion&#x2F;runeset">https:&#x2F;&#x2F;github.com&#x2F;mnemnion&#x2F;runeset</a>. I admittedly haven&#x27;t benchmarked this much, correctness first and all, but seeing that Cloudflare has seen good numbers for something closely related reinforces the few tests I have run.<p>As a text-matching connoisseur, you may find the runeset interesting. It turns out to be hard to search for papers on &quot;UTF-8 character set&quot;, so if you&#x27;re aware of any prior art here I&#x27;d love a heads-up.  It&#x27;s fundamentally a generalization of using u64 bitmasks for sets of ASCII, which is as old as the hills at this point.</div><br/><div id="41505910" class="c"><input type="checkbox" id="c-41505910" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#41503484">root</a><span>|</span><a href="#41505684">parent</a><span>|</span><a href="#41508573">next</a><span>|</span><label class="collapse" for="c-41505910">[-]</label><label class="expand" for="c-41505910">[2 more]</label></div><br/><div class="children"><div class="content">RE DFA: possibly, but not completely obvious to me. The DFA in aho-corasick doesn&#x27;t typically have 256 different transitions per state. It uses &quot;byte classes&quot; to represent a typically smaller number of equivalence classes. Two bytes are in the same equivalence class if a match&#x2F;non-match cannot be distinguished between them.<p>To be clear, I&#x27;d bet trie-hard is still more space efficient. And using byte classes does require an extra look-up per transition.<p>But, worth measuring.<p>As your your RuneSet thing, I&#x27;d look at lightgrep and icgrep. I&#x27;m not 100% they have relevant work for you, but they might. In practice, I just combine sets of codepoints down into UTF-8 automata since that&#x27;s needed anyway for lazy DFA matching.</div><br/><div id="41507414" class="c"><input type="checkbox" id="c-41507414" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41503484">root</a><span>|</span><a href="#41505910">parent</a><span>|</span><a href="#41508573">next</a><span>|</span><label class="collapse" for="c-41507414">[-]</label><label class="expand" for="c-41507414">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>not completely obvious to me .. worth measuring.</i><p>I concur.<p>&gt; <i>lightgrep and icgrep</i><p>These are great tips for a &quot;related work&quot; section, but nothing like prior art as it turns out.  So yes, relevant and appreciated.<p>&gt; <i>UTF-8 automata .. lazy DFA matching</i><p>I wouldn&#x27;t expect RuneSet to be useful for any automata-based regex pattern matching approach, there&#x27;s not a good way to incorporate the context switch, among other considerations, and while it&#x27;s fast, I will be surprised (very pleased, but surprised) if it&#x27;s fast<i>er</i>.  It&#x27;s designed as a component of an LPeg style parsing machine, where it can be added inline and treated as an unusually large instruction.  I haven&#x27;t done more than time its test suite, which has shown that it&#x27;s fast enough for the intended use, and that optimization time is best put into other parts of the design for now.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41508573" class="c"><input type="checkbox" id="c-41508573" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#41503484">prev</a><span>|</span><a href="#41505866">next</a><span>|</span><label class="collapse" for="c-41508573">[-]</label><label class="expand" for="c-41508573">[1 more]</label></div><br/><div class="children"><div class="content">Alternatively at request ingress time you could take all original header names and save them, and at egress time you could use that list to drive which keys to emit?<p>Then you wouldn&#x27;t need to maintain a list of what is internal and you wouldn&#x27;t have to do any trie lookups.</div><br/></div></div><div id="41505866" class="c"><input type="checkbox" id="c-41505866" checked=""/><div class="controls bullet"><span class="by">y04nn</span><span>|</span><a href="#41508573">prev</a><span>|</span><a href="#41506907">next</a><span>|</span><label class="collapse" for="c-41505866">[-]</label><label class="expand" for="c-41505866">[2 more]</label></div><br/><div class="children"><div class="content">Why adding and then removing HTTP headers of a existing request for routing instead of adding a dedicated (custom) routing protocol above the HTTP stack? This would allow to just drop the added protocol on the outbound and be much more space efficient.</div><br/><div id="41507952" class="c"><input type="checkbox" id="c-41507952" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#41505866">parent</a><span>|</span><a href="#41506907">next</a><span>|</span><label class="collapse" for="c-41507952">[-]</label><label class="expand" for="c-41507952">[1 more]</label></div><br/><div class="children"><div class="content">The fabled tech talent shortage, probably.</div><br/></div></div></div></div><div id="41506907" class="c"><input type="checkbox" id="c-41506907" checked=""/><div class="controls bullet"><span class="by">unusualmonkey</span><span>|</span><a href="#41505866">prev</a><span>|</span><a href="#41501987">next</a><span>|</span><label class="collapse" for="c-41506907">[-]</label><label class="expand" for="c-41506907">[4 more]</label></div><br/><div class="children"><div class="content">My 2c:<p>1) Is this worthwhile? Looks like ~500 CPU cores were saved (are these real cores, or does this include hyperthread cores?). I don&#x27;t know cloudflare&#x27;s costs, but this seems like single digit servers and probably savings only in the $XX,XXX range. Not nothing, but do you expect a positive ROI on engineering?<p>2) If you do want to go to this detail, did you consider in putting the filter at the deserialization step, preventing the headers from being created in the first place?</div><br/><div id="41508910" class="c"><input type="checkbox" id="c-41508910" checked=""/><div class="controls bullet"><span class="by">_zoltan_</span><span>|</span><a href="#41506907">parent</a><span>|</span><a href="#41507449">next</a><span>|</span><label class="collapse" for="c-41508910">[-]</label><label class="expand" for="c-41508910">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand your point about the ROI. Let&#x27;s say it&#x27;s 40k a year for 5 years that&#x27;s 200k. That&#x27;s a multi year salary Hungary&#x2F;Poland (I have no idea of CF has offices there.)</div><br/></div></div><div id="41507449" class="c"><input type="checkbox" id="c-41507449" checked=""/><div class="controls bullet"><span class="by">aetherspawn</span><span>|</span><a href="#41506907">parent</a><span>|</span><a href="#41508910">prev</a><span>|</span><a href="#41507932">next</a><span>|</span><label class="collapse" for="c-41507449">[-]</label><label class="expand" for="c-41507449">[1 more]</label></div><br/><div class="children"><div class="content">It might only be $XX,XXX but it is forever.<p>Power savings forever.<p>Lower carbon emissions.<p>etc<p>Nice to see a company that cares about making things 1% faster rather than trying to analyse headers with AI to sell me sandals or something stupid like that.</div><br/></div></div><div id="41507932" class="c"><input type="checkbox" id="c-41507932" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41506907">parent</a><span>|</span><a href="#41507449">prev</a><span>|</span><a href="#41501987">next</a><span>|</span><label class="collapse" for="c-41507932">[-]</label><label class="expand" for="c-41507932">[1 more]</label></div><br/><div class="children"><div class="content">If an engineer spends a couple of days on it then the savings seem worthwhile?</div><br/></div></div></div></div><div id="41501987" class="c"><input type="checkbox" id="c-41501987" checked=""/><div class="controls bullet"><span class="by">cwilby</span><span>|</span><a href="#41506907">prev</a><span>|</span><a href="#41501892">next</a><span>|</span><label class="collapse" for="c-41501987">[-]</label><label class="expand" for="c-41501987">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Internally, we call the request’s destination server its “origin”<p>Origin: The point at which something comes into existence or from which it derives or is derived.<p>How can the request&#x27;s destination server be the origin, if it is the destination server?</div><br/><div id="41502072" class="c"><input type="checkbox" id="c-41502072" checked=""/><div class="controls bullet"><span class="by">fowl2</span><span>|</span><a href="#41501987">parent</a><span>|</span><a href="#41502049">next</a><span>|</span><label class="collapse" for="c-41502072">[-]</label><label class="expand" for="c-41502072">[2 more]</label></div><br/><div class="children"><div class="content">Depends on your perspective :)<p>&quot;Origin&quot; is a term from web browsers, from their point of view it refers to where a web page came from.<p>see <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;Security&#x2F;Same-origin_policy" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;Security&#x2F;Same-o...</a></div><br/><div id="41502108" class="c"><input type="checkbox" id="c-41502108" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41501987">root</a><span>|</span><a href="#41502072">parent</a><span>|</span><a href="#41502049">next</a><span>|</span><label class="collapse" for="c-41502108">[-]</label><label class="expand" for="c-41502108">[1 more]</label></div><br/><div class="children"><div class="content">This hilariously reminds me of the complaining about X server semantics back in the day.</div><br/></div></div></div></div><div id="41502049" class="c"><input type="checkbox" id="c-41502049" checked=""/><div class="controls bullet"><span class="by">tills13</span><span>|</span><a href="#41501987">parent</a><span>|</span><a href="#41502072">prev</a><span>|</span><a href="#41502027">next</a><span>|</span><label class="collapse" for="c-41502049">[-]</label><label class="expand" for="c-41502049">[2 more]</label></div><br/><div class="children"><div class="content">On the internet, the origin is the server sending the response to the user. I suppose you can look at it from the perspective of the owner of the server -- from their frame of reference, their journey _starts_ when they receive, process, and respond to the request.<p>Granted, computer scientists are infamously known for being terrible at naming things.</div><br/><div id="41502107" class="c"><input type="checkbox" id="c-41502107" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41501987">root</a><span>|</span><a href="#41502049">parent</a><span>|</span><a href="#41502027">next</a><span>|</span><label class="collapse" for="c-41502107">[-]</label><label class="expand" for="c-41502107">[1 more]</label></div><br/><div class="children"><div class="content">Had any fun with “Referer” headers lately?</div><br/></div></div></div></div><div id="41502027" class="c"><input type="checkbox" id="c-41502027" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41501987">parent</a><span>|</span><a href="#41502049">prev</a><span>|</span><a href="#41501892">next</a><span>|</span><label class="collapse" for="c-41502027">[-]</label><label class="expand" for="c-41502027">[2 more]</label></div><br/><div class="children"><div class="content">The origin is the origin of the content.</div><br/><div id="41502060" class="c"><input type="checkbox" id="c-41502060" checked=""/><div class="controls bullet"><span class="by">cwilby</span><span>|</span><a href="#41501987">root</a><span>|</span><a href="#41502027">parent</a><span>|</span><a href="#41501892">next</a><span>|</span><label class="collapse" for="c-41502060">[-]</label><label class="expand" for="c-41502060">[1 more]</label></div><br/><div class="children"><div class="content">Thus cross origin resource sharing.  Thanks!<p>At least it&#x27;s consistently inconsistent.</div><br/></div></div></div></div></div></div><div id="41501892" class="c"><input type="checkbox" id="c-41501892" checked=""/><div class="controls bullet"><span class="by">IncreasePosts</span><span>|</span><a href="#41501987">prev</a><span>|</span><a href="#41504150">next</a><span>|</span><label class="collapse" for="c-41501892">[-]</label><label class="expand" for="c-41501892">[4 more]</label></div><br/><div class="children"><div class="content">Off topic: how does 60M requests a second stack up with other big players like google, Facebook, TikTok?</div><br/><div id="41504315" class="c"><input type="checkbox" id="c-41504315" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#41501892">parent</a><span>|</span><a href="#41507411">next</a><span>|</span><label class="collapse" for="c-41504315">[-]</label><label class="expand" for="c-41504315">[2 more]</label></div><br/><div class="children"><div class="content">This 2013 research article from facebook indicates memcached handled “billions of requests per second” [1].<p>[1] <a href="https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;scaling-memcache-at-facebook&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;scaling-memcache-...</a></div><br/><div id="41505024" class="c"><input type="checkbox" id="c-41505024" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#41501892">root</a><span>|</span><a href="#41504315">parent</a><span>|</span><a href="#41507411">next</a><span>|</span><label class="collapse" for="c-41505024">[-]</label><label class="expand" for="c-41505024">[1 more]</label></div><br/><div class="children"><div class="content">I will note that http requests and internal requests are distinct.<p>The Zanzibar white paper from Google in 2019, for example lists top-line rpcs to Zanzibar at around 10m qps, but internal (in memory) cache hits at 200m qps and non cache internal fan-out at &gt;20m qps. Zanzibar of course isn&#x27;t http, but is a good public example of internal rpc fan-out.<p>Id expect cloutdflare similarly has some extremely high qps internal services.</div><br/></div></div></div></div><div id="41507411" class="c"><input type="checkbox" id="c-41507411" checked=""/><div class="controls bullet"><span class="by">why_only_15</span><span>|</span><a href="#41501892">parent</a><span>|</span><a href="#41504315">prev</a><span>|</span><a href="#41504150">next</a><span>|</span><label class="collapse" for="c-41507411">[-]</label><label class="expand" for="c-41507411">[1 more]</label></div><br/><div class="children"><div class="content">People typically quote google search as ~300k QPS</div><br/></div></div></div></div><div id="41504150" class="c"><input type="checkbox" id="c-41504150" checked=""/><div class="controls bullet"><span class="by">maciek12</span><span>|</span><a href="#41501892">prev</a><span>|</span><a href="#41505019">next</a><span>|</span><label class="collapse" for="c-41504150">[-]</label><label class="expand" for="c-41504150">[4 more]</label></div><br/><div class="children"><div class="content">Am i missing something or is the big O notation in this article wrong? For example in &quot;Sorted sets like BTreeSet use comparisons for searching, and that makes them logarithmic over key length O(log(L)), but they are also logarithmic in size too&quot; how  is the search done in logarithmic time? You could have a header that differs from an internal one only on the last character and then you have to read the whole thing. Also space-wise B-trees are linear, not O(nlogn). Additionally, at the end when talking about the trie, how do you achieve O(log(L)) for misses? Tries are not balanced, they do not halve the possible set on comparison (as I think the author states) and even if they did I don&#x27;t see how that achieves the logarithmic time.</div><br/><div id="41505724" class="c"><input type="checkbox" id="c-41505724" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41504150">parent</a><span>|</span><a href="#41505019">next</a><span>|</span><label class="collapse" for="c-41505724">[-]</label><label class="expand" for="c-41505724">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You could have a header that differs from an internal one only on the last character and then you have to read the whole thing<p>When people talk about BigO they usually talk about average Big-o and worst&#x2F;best case Big-o is explicitly called out if mentioned, so you can&#x27;t just think in terms of the worst possible case. Regardless I think they made several mistakes here as you note correctly.<p>BTreeSet is log(N) in number of nodes compared. But for strings that comparison is O(L) since you at least have to compare it to the string you find. So I believe it&#x27;s at best O(L log(N)) where L is the average string length and N is the number of nodes which is worse than the hash table which is just O(L). It&#x27;s tricky though if most strings don&#x27;t match your string. In that case I believe you end up degrading to an O(L) + O(log(N)).<p>Similarly, you are correct that they can&#x27;t be logarithmic in size and must be linear since you have to store the data. Tries can be sublinear depending on the input since it&#x27;s a form of compression as well.<p>Similarly you are right about trie complexity not being O(log(L)) for trie misses. I think what they&#x27;re observing is a massive speedup because mismatches error out on the first character usually. But it wouldn&#x27;t be logarithmic as there&#x27;s unlikely to be a logarithmic relation between headers that mismatch and the universe of matching words.</div><br/><div id="41505946" class="c"><input type="checkbox" id="c-41505946" checked=""/><div class="controls bullet"><span class="by">maciek12</span><span>|</span><a href="#41504150">root</a><span>|</span><a href="#41505724">parent</a><span>|</span><a href="#41505019">next</a><span>|</span><label class="collapse" for="c-41505946">[-]</label><label class="expand" for="c-41505946">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for replying, I really appreciate you taking the time to check my concerns! I was afraid I was going crazy haha.<p>The part about big O being usually about the average case was helpful, I&#x27;m still at uni where we mostly talk about worst case performance.</div><br/><div id="41506554" class="c"><input type="checkbox" id="c-41506554" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41504150">root</a><span>|</span><a href="#41505946">parent</a><span>|</span><a href="#41505019">next</a><span>|</span><label class="collapse" for="c-41506554">[-]</label><label class="expand" for="c-41506554">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll note I could very well be wrong - very back of the paper first principles derivation and could easily have made a mistake.<p>If you&#x27;re in a relevant course, might be a good opportunity to flag this to a professor or TA as a way to review. These kind of analyses can be tricky sometimes, especially if you need to prove it vs just do an answer by feel which is how engineers end up doing it (vs CS students that take the proofs much more seriously).<p>A way to sometimes double-check is to just simulate performance as input grows and see if it matches the expected log(N).</div><br/></div></div></div></div></div></div></div></div><div id="41505019" class="c"><input type="checkbox" id="c-41505019" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#41504150">prev</a><span>|</span><a href="#41503726">next</a><span>|</span><label class="collapse" for="c-41505019">[-]</label><label class="expand" for="c-41505019">[2 more]</label></div><br/><div class="children"><div class="content">Jumping on the bandwagon of other ideas... I wonder if it would be quicker to filter pit the internal headers when you write the request to the network (buffer)? ie something like `request_headers.filter(not_is_internal).for_each(...)`; that way you don&#x27;t have to remove anything from the data structure at all, but does require you to break down a layer of abstraction for performance benefits.</div><br/><div id="41505587" class="c"><input type="checkbox" id="c-41505587" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41505019">parent</a><span>|</span><a href="#41503726">next</a><span>|</span><label class="collapse" for="c-41505587">[-]</label><label class="expand" for="c-41505587">[1 more]</label></div><br/><div class="children"><div class="content">No, you&#x27;d just be smearing the work at best. The expensive part is determining set containment not updating the data structure. It doesn&#x27;t matter if you do it in a loop and update the data structure or do that check before writing.</div><br/></div></div></div></div><div id="41503726" class="c"><input type="checkbox" id="c-41503726" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#41505019">prev</a><span>|</span><a href="#41505464">next</a><span>|</span><label class="collapse" for="c-41503726">[-]</label><label class="expand" for="c-41503726">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know Rust. Can someone explain how this data structure stores whether a node is itself a valid word or whether it only leads to more nodes? For example the node &quot;do&quot; in their (“and”, “ant”, “dad”, “do”, &amp; “dot”) example. I guess it&#x27;s a discriminated union provided by Rust algebraic data types or something like that, but why not show the full bit pattern in memory?</div><br/><div id="41505148" class="c"><input type="checkbox" id="c-41505148" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41503726">parent</a><span>|</span><a href="#41504216">next</a><span>|</span><label class="collapse" for="c-41505148">[-]</label><label class="expand" for="c-41505148">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why not show the full bit pattern in memory?<p>Rust doesn&#x27;t guarantee a particular memory layout except for types explicitly requesting that you get a specific representation, so showing this would at least require a caveat that it&#x27;s not guaranteed to be accurate.<p>Furthermore, this specific data structure&#x27;s internals are generic, so to show the memory layout, it would have to be for a specific instantiation.<p>(They do also provide a structure that includes instantiations between u8 and u256, mentioning in a doc comment that the 256 size dominates overall size, and so if you want to slim it down, use the internals directly.)</div><br/></div></div><div id="41504216" class="c"><input type="checkbox" id="c-41504216" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41503726">parent</a><span>|</span><a href="#41505148">prev</a><span>|</span><a href="#41505464">next</a><span>|</span><label class="collapse" for="c-41504216">[-]</label><label class="expand" for="c-41504216">[1 more]</label></div><br/><div class="children"><div class="content">By looking at the source code [1] they have a discriminated union with 3 variants representing the possible combinations of representing a valid word and leading to more nodes (excluding the case where it is neither, which is impossible). So the node for the &#x27;o&#x27; in &quot;do&quot; should be a `SearchOrLeaf` storing &quot;do&quot;, its corresponding value (the `T`, in a set this would be empty) and the `SearchNode` containing the successors, which should only contain a &#x27;t&#x27; to &quot;dot&quot;.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;trie-hard&#x2F;blob&#x2F;3d8163ca2d9208c663d6dbac48105a96ac540306&#x2F;src&#x2F;lib.rs#L114">https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;trie-hard&#x2F;blob&#x2F;3d8163ca2d9208c...</a></div><br/></div></div></div></div><div id="41505464" class="c"><input type="checkbox" id="c-41505464" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41503726">prev</a><span>|</span><a href="#41506754">next</a><span>|</span><label class="collapse" for="c-41505464">[-]</label><label class="expand" for="c-41505464">[5 more]</label></div><br/><div class="children"><div class="content">I would have stopped at the first step, saving almost 1% of cpu time (0.993%). Creating a new fast trie data type for the other 0.287% seems inefficient. Surely there are other parts of the code that take more than 1% of the cpu time elsewhere to be looked at first?</div><br/><div id="41506629" class="c"><input type="checkbox" id="c-41506629" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41505464">parent</a><span>|</span><a href="#41506754">next</a><span>|</span><label class="collapse" for="c-41506629">[-]</label><label class="expand" for="c-41506629">[4 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; At the time of writing, the rate of requests leaving pingora-origin (globally) is 35 million requests per second. Any code that has to be run per-request is in the hottest of hot paths...function consumes more than 1.7% of pingora-origin’s total cpu time. To put that in perspective, the total cpu time consumed by pingora-origin is 40,000 compute-seconds per second. You can think of this as 40,000 saturated CPU cores fully dedicated to running pingora-origin. Of those 40,000, 1.7% (680) are only dedicated to evaluating clear_internal_headers. The function’s heavy usage and simplicity make it seem like a great place to start optimizing.<p>Given how many requests are going out, and just how hot the function is, every single gain matters. If my read of the article is correct, this is the hottest part of the hot path, so every gain here is super important.</div><br/><div id="41507967" class="c"><input type="checkbox" id="c-41507967" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41505464">root</a><span>|</span><a href="#41506629">parent</a><span>|</span><a href="#41506754">next</a><span>|</span><label class="collapse" for="c-41507967">[-]</label><label class="expand" for="c-41507967">[3 more]</label></div><br/><div class="children"><div class="content">680 cores is peanuts. That is less than 10 modern specced compute servers. Its not nothing but you are probably talking about $20-30k&#x2F;year in opex costs, which at the scale of cloudflare is probably a drop in the bucket.<p>Obviously it is an improvement but a lot of time there is lower hanging fruit, like the fact that the cloudflare control plane is&#x2F;was not globally distributed and could not tolerate data center outages.</div><br/><div id="41508429" class="c"><input type="checkbox" id="c-41508429" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41505464">root</a><span>|</span><a href="#41507967">parent</a><span>|</span><a href="#41506754">next</a><span>|</span><label class="collapse" for="c-41508429">[-]</label><label class="expand" for="c-41508429">[2 more]</label></div><br/><div class="children"><div class="content">Idk man, I’m not Cloudflare.<p>That said: probably different teams with different priorities.<p>I also disagree that “it’s _only_ $20-30k” as some kind of reason to not do this kind of work. Think of it another way: that’s now another 680 cores that can do _net more work_, that’s another 20-30k we don’t have to spend when traffic increases. “I landed a small PR that wiped $30k net off our costs” is a statement that would make a lot of people in a business pretty happy.</div><br/><div id="41508972" class="c"><input type="checkbox" id="c-41508972" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41505464">root</a><span>|</span><a href="#41508429">parent</a><span>|</span><a href="#41506754">next</a><span>|</span><label class="collapse" for="c-41508972">[-]</label><label class="expand" for="c-41508972">[1 more]</label></div><br/><div class="children"><div class="content">I work in a tech company which is a bit bigger than cloudflare and anything less than 6 figures&#x2F;yr opex reduction is a rounding error.
It is pretty regular to save the company 7 figures per year when opex is in the billions.<p>It is about the opportunity cost, nobody is going to disagree that small optimizations are a net positive but what else could you have done with your time? Maybe cloudflare is at the point of maturity where there are no easy wins and only 1% gains left but I kind of doubt it given their reliability track record. How many dollars do they lose for every hour they are down? Probably more than $20k.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41506754" class="c"><input type="checkbox" id="c-41506754" checked=""/><div class="controls bullet"><span class="by">gwittel</span><span>|</span><a href="#41505464">prev</a><span>|</span><a href="#41504270">next</a><span>|</span><label class="collapse" for="c-41506754">[-]</label><label class="expand" for="c-41506754">[1 more]</label></div><br/><div class="children"><div class="content">Neat optimization! Would it have been feasible to spend a bit of cpu&#x2F;memory and tag headers as internal upon the request construction?  That way filtering on output is trivial.</div><br/></div></div><div id="41504270" class="c"><input type="checkbox" id="c-41504270" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41506754">prev</a><span>|</span><a href="#41503701">next</a><span>|</span><label class="collapse" for="c-41504270">[-]</label><label class="expand" for="c-41504270">[4 more]</label></div><br/><div class="children"><div class="content">That late in the process, does it even need to support efficient lookup? Could it just be a Vec?</div><br/><div id="41505273" class="c"><input type="checkbox" id="c-41505273" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#41504270">parent</a><span>|</span><a href="#41503701">next</a><span>|</span><label class="collapse" for="c-41505273">[-]</label><label class="expand" for="c-41505273">[3 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t explicitly say that in the blog post but I assume that the engineering team behind this code does not run any workload performance experiments themselves but they only run the local (micro)benchmarks.<p>Because of this I think there&#x27;s no way for them to answer your question or to say &quot;hey, this could very well be a vector since we could not find any statistically significant impact between a vector, hash-map and trie in this code path for given workload&quot;.<p>This is a common fallacy I&#x27;ve seen in too many places. In other words, investing non-trivial engineering effort into optimizing a code-path that resembles .000001% of your workload is a waste of resources.<p>And due to the Amdahl&#x27;s law<p>&gt; Optimizing operations that are already measured in microseconds may seem a little silly, but these small improvements add up.<p>this is not how things usually work out in the end. Making small improvements in insignificant code-paths will still remain insignificant in the overall runtime performance.</div><br/><div id="41505740" class="c"><input type="checkbox" id="c-41505740" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41504270">root</a><span>|</span><a href="#41505273">parent</a><span>|</span><a href="#41503701">next</a><span>|</span><label class="collapse" for="c-41505740">[-]</label><label class="expand" for="c-41505740">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If we compare the sampled performance of the different versions of clear_internal_headers, we can see that the results from the performance sampling closely match what our benchmarks predicted<p>Look at the end where they validate that the performance wins show up in production in a similar way that the microbenchmarks predict.</div><br/><div id="41508858" class="c"><input type="checkbox" id="c-41508858" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#41504270">root</a><span>|</span><a href="#41505740">parent</a><span>|</span><a href="#41503701">next</a><span>|</span><label class="collapse" for="c-41508858">[-]</label><label class="expand" for="c-41508858">[1 more]</label></div><br/><div class="children"><div class="content">They only measure the CPU utilization of clear_internal_headers and they don&#x27;t show what was the impact of the change to the overall runtime performance. The latter is what I was referring to.</div><br/></div></div></div></div></div></div></div></div><div id="41503701" class="c"><input type="checkbox" id="c-41503701" checked=""/><div class="controls bullet"><span class="by">hencoappel</span><span>|</span><a href="#41504270">prev</a><span>|</span><a href="#41503138">next</a><span>|</span><label class="collapse" for="c-41503701">[-]</label><label class="expand" for="c-41503701">[1 more]</label></div><br/><div class="children"><div class="content">Given it&#x27;s such a hot part of their code, I&#x27;m genuinely surprised they didn&#x27;t go down the state machine route for as optimal a solution, or even further and made use of vector instructions. Maybe Rust can autovectorise the code though.</div><br/></div></div><div id="41503138" class="c"><input type="checkbox" id="c-41503138" checked=""/><div class="controls bullet"><span class="by">MehdiHK</span><span>|</span><a href="#41503701">prev</a><span>|</span><a href="#41504370">next</a><span>|</span><label class="collapse" for="c-41503138">[-]</label><label class="expand" for="c-41503138">[1 more]</label></div><br/><div class="children"><div class="content">Slightly off topic: I was a bit surprised nobody ported space-efficient marisa trie to Rust, or any other languages.<p>Anybody knows why?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;s-yata&#x2F;marisa-trie">https:&#x2F;&#x2F;github.com&#x2F;s-yata&#x2F;marisa-trie</a></div><br/></div></div><div id="41504370" class="c"><input type="checkbox" id="c-41504370" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#41503138">prev</a><span>|</span><a href="#41507499">next</a><span>|</span><label class="collapse" for="c-41504370">[-]</label><label class="expand" for="c-41504370">[2 more]</label></div><br/><div class="children"><div class="content">It’s a bit wild to me that one needs to add so many http headers internally that they need to get stripped off.<p>The “trie-hard” crate is a solution to the layers of cruft at CF</div><br/><div id="41506589" class="c"><input type="checkbox" id="c-41506589" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41504370">parent</a><span>|</span><a href="#41507499">next</a><span>|</span><label class="collapse" for="c-41506589">[-]</label><label class="expand" for="c-41506589">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it would matter if there&#x27;s only 1 header to be removed, it&#x27;s still a problem to be solved.</div><br/></div></div></div></div><div id="41507499" class="c"><input type="checkbox" id="c-41507499" checked=""/><div class="controls bullet"><span class="by">pianoben</span><span>|</span><a href="#41504370">prev</a><span>|</span><a href="#41502529">next</a><span>|</span><label class="collapse" for="c-41507499">[-]</label><label class="expand" for="c-41507499">[1 more]</label></div><br/><div class="children"><div class="content">This solution reminds me of an old blog post, where two members of the F# team at Microsoft battled back and forth on making the best solver for some word game.  Cloudflare&#x27;s solution here looks a lot like the second-to-last solution; the final post involved collapsing the tree nodes into a 2D array of u32s for maximum cache-hits.  It was a really neat solution!<p>...and amazingly, it&#x27;s still up from 2010: <a href="https:&#x2F;&#x2F;lorgonblog.wordpress.com&#x2F;2010&#x2F;02&#x2F;21&#x2F;dawg-gone&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lorgonblog.wordpress.com&#x2F;2010&#x2F;02&#x2F;21&#x2F;dawg-gone&#x2F;</a></div><br/></div></div><div id="41502529" class="c"><input type="checkbox" id="c-41502529" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#41507499">prev</a><span>|</span><a href="#41505434">next</a><span>|</span><label class="collapse" for="c-41502529">[-]</label><label class="expand" for="c-41502529">[2 more]</label></div><br/><div class="children"><div class="content">So this trie uses a custom u256 type that is a wrapper around an array of 4 u64s. Is rust smart enough to vecorize it into AVX instructions for the bit twiddling?<p>What about for the other integer sizes that the trie supports?</div><br/><div id="41506581" class="c"><input type="checkbox" id="c-41506581" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41502529">parent</a><span>|</span><a href="#41505434">next</a><span>|</span><label class="collapse" for="c-41506581">[-]</label><label class="expand" for="c-41506581">[1 more]</label></div><br/><div class="children"><div class="content">A lot of Rusts&#x27; optimisations are from LLVM, so if that&#x27;s smart enough to, then I assume it also benefits.</div><br/></div></div></div></div><div id="41505434" class="c"><input type="checkbox" id="c-41505434" checked=""/><div class="controls bullet"><span class="by">sixo</span><span>|</span><a href="#41502529">prev</a><span>|</span><a href="#41504857">next</a><span>|</span><label class="collapse" for="c-41505434">[-]</label><label class="expand" for="c-41505434">[1 more]</label></div><br/><div class="children"><div class="content">this post makes me think I could work at cloudflare, and also that I shouldn&#x27;t</div><br/></div></div><div id="41504857" class="c"><input type="checkbox" id="c-41504857" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41505434">prev</a><span>|</span><label class="collapse" for="c-41504857">[-]</label><label class="expand" for="c-41504857">[1 more]</label></div><br/><div class="children"><div class="content">If it takes 3.5 us to remove a substring within a packet-sized string you&#x27;re doing it wrong.</div><br/></div></div></div></div></div></div></div></body></html>