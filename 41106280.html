<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722416514608" as="style"/><link rel="stylesheet" href="styles.css?v=1722416514608"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cohost.org/prophet/post/7083950-functional-programmi">Functional languages should be so much better at mutation than they are</a> <span class="domain">(<a href="https://cohost.org">cohost.org</a>)</span></div><div class="subtext"><span>injuly</span> | <span>91 comments</span></div><br/><div><div id="41113725" class="c"><input type="checkbox" id="c-41113725" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41116165">next</a><span>|</span><label class="collapse" for="c-41113725">[-]</label><label class="expand" for="c-41113725">[15 more]</label></div><br/><div class="children"><div class="content">&gt; Rust&#x27;s shared XOR mutable references […] makes linearity nearly useless or inevitably creates a parallel, incomplete universe of functions that also work on linear values.<p>Yup. Rust can&#x27;t abstract over mutability. For owned values, it defaults to exclusive ownership, and needs explicit Rc&lt;T&gt; and clone() to share them. For references, in practice it requires making separate `foo()` and `foo_mut()` functions for each type of the loan.<p>Even though this sounds horribly clunky, it works okay in practice. Ability to temporarily borrow exclusively owned objects as either shared or exclusive-mutable adds enough flexibility.<p>Rust is known for being difficult, but I think a lot of that is due to lack of GC. Rust can&#x27;t make any reference live longer, and programmers have to manually get scopes of loans right, or manually use Rc&lt;RefCell&gt; to have a mini DIY GC. Perhaps a shared XOR mutable with a GC could be the best of both?</div><br/><div id="41115264" class="c"><input type="checkbox" id="c-41115264" checked=""/><div class="controls bullet"><span class="by">sans-seraph</span><span>|</span><a href="#41113725">parent</a><span>|</span><a href="#41115136">next</a><span>|</span><label class="collapse" for="c-41115264">[-]</label><label class="expand" for="c-41115264">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ability to temporarily borrow exclusively owned objects as either shared or exclusive-mutable adds enough flexibility.<p>Rust quietly has several other features in order to improve the quality-of-life of its ownership model. Two examples: if you have a mutable reference then Rust will coerce it to an immutable reference if one is required, and if you have a mutable reference then Rust will transparently re-borrow it when calling functions that accept mutable references in order to allow you to use the mutable reference more than once despite the fact that they do not implement Copy.</div><br/></div></div><div id="41115136" class="c"><input type="checkbox" id="c-41115136" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#41113725">parent</a><span>|</span><a href="#41115264">prev</a><span>|</span><a href="#41116267">next</a><span>|</span><label class="collapse" for="c-41115136">[-]</label><label class="expand" for="c-41115136">[12 more]</label></div><br/><div class="children"><div class="content">Aside: Could a Rust library provide an Rc&lt;T&gt; interface but use a more sophisticated GC algorithm underneath?</div><br/><div id="41115328" class="c"><input type="checkbox" id="c-41115328" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41115136">parent</a><span>|</span><a href="#41115419">next</a><span>|</span><label class="collapse" for="c-41115328">[-]</label><label class="expand" for="c-41115328">[1 more]</label></div><br/><div class="children"><div class="content">There are a couple of proof-of-concept libraries adding a `Gc&lt;T&gt; where T: Traceable`, so it is doable. 
You can&#x27;t change the existing Rc, because it&#x27;s a concrete type. Making it use a tracing GC internally would require a lot of compiler magic.<p>However, I don&#x27;t think a GC will catch on in Rust in its current form. Rust&#x27;s userbase likes it as a no-GC language. Plus a 3rd party library GC wrapper type can&#x27;t save you from having to learn ownership and lifetimes used by literally everything else. Once you invest time to learn the &quot;zero-cost&quot; references, a runtime Gc is less appealing, and won&#x27;t be as ergonomic than the built-in references.<p>Swift, OCaml, and Mojo are trying to add some subset of Rust-like ownership and borrowing, but in a simpler form.</div><br/></div></div><div id="41115419" class="c"><input type="checkbox" id="c-41115419" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41115136">parent</a><span>|</span><a href="#41115328">prev</a><span>|</span><a href="#41115186">next</a><span>|</span><label class="collapse" for="c-41115419">[-]</label><label class="expand" for="c-41115419">[9 more]</label></div><br/><div class="children"><div class="content">You can, but it turns out that, as one may intuitively expect, a GC is never needed unless implementing a VM for a GC-based language or an API that required GC like fd passing on unix domain sockets, and those generally want an ad-hoc GC instead tailored to whatever you are implementing.<p>Since it&#x27;s not needed and it&#x27;s massively worse than reference counting (assuming you only change reference counts when essential and use borrowing normally) due to the absurd behavior of scanning most of the heap at arbitrary times, there is no Rust GC crate in widespread use.</div><br/><div id="41116763" class="c"><input type="checkbox" id="c-41116763" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41115419">parent</a><span>|</span><a href="#41116389">next</a><span>|</span><label class="collapse" for="c-41116763">[-]</label><label class="expand" for="c-41116763">[5 more]</label></div><br/><div class="children"><div class="content">Almost all GCs used in practice today only scan the set of live objects, which in normal operation is much smaller than the entire heap. They also allow much more efficient allocation and de-allocation.<p>The problems with GC are threefold, and why you might not want it in a systems language:<p>1. GC requires more memory than strictly necessary to be efficient (usually about 1.5x - 2x the amount you absolutely need). You&#x27;re basically trading runtime efficiency for memory.<p>2. GC performance is harder to predict and reason about than certain other allocation strategies<p>3. GC languages tend to encourage excessive heap allocation for various reasons, ending up with much more junk than a typical Rust or C program that has a similar amount of entities<p>Note that item 2 is the one that&#x27;s least understood. The best part about GCs is that they make heap allocation trivial, and they make de-allocation a no-op. In contrast, both malloc() and free() are extremely complex and costly operations. The GC does impose a cost on every pointer write, similar to (but typically less than) the overhead of Arc&lt;T&gt; over a T*, but that has a very uniform and predictable cost. The problem of unpredictability only comes in the collection phase, and is mostly related to (a) when the collection happens, (b) how much data actually has to be scanned (how many live objects are present on the heap and stack), and (c) what type of collection needs to happen (is it enough to collect from this thread&#x27;s young generation, or do you need to collect all generations from all threads).<p>Note that many of these problems are in fact solvable, and there actually exist GCs with constant predictable collection times, suitable even for realtime applications (which malloc&#x2F;free don&#x27;t support). They are very sophisticated technology that no one is distributing for free though (e.g. you have to pay Azul for a realtime-compatible Java).</div><br/><div id="41116854" class="c"><input type="checkbox" id="c-41116854" checked=""/><div class="controls bullet"><span class="by">devbent</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41116763">parent</a><span>|</span><a href="#41117187">next</a><span>|</span><label class="collapse" for="c-41116854">[-]</label><label class="expand" for="c-41116854">[2 more]</label></div><br/><div class="children"><div class="content">People often forget that the runtime of free is not trivially calculatable!<p>I&#x27;ve worked on tiny embedded systems (.net micro framework) where for a given usage pattern the GC was perfectly predictable, as it should be.</div><br/><div id="41117137" class="c"><input type="checkbox" id="c-41117137" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41116854">parent</a><span>|</span><a href="#41117187">next</a><span>|</span><label class="collapse" for="c-41117137">[-]</label><label class="expand" for="c-41117137">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;Costly&#x27; doesn&#x27;t seem to require that O(k) be non-constant:<p><a href="http:&#x2F;&#x2F;www.gii.upv.es&#x2F;tlsf&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.gii.upv.es&#x2F;tlsf&#x2F;</a></div><br/></div></div></div></div><div id="41117187" class="c"><input type="checkbox" id="c-41117187" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41116763">parent</a><span>|</span><a href="#41116854">prev</a><span>|</span><a href="#41116389">next</a><span>|</span><label class="collapse" for="c-41117187">[-]</label><label class="expand" for="c-41117187">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re basically trading runtime efficiency for memory.<p>What do you mean? Aren&#x27;t GCs both less efficient at run time <i>and</i> use more memory?</div><br/><div id="41117320" class="c"><input type="checkbox" id="c-41117320" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41117187">parent</a><span>|</span><a href="#41116389">next</a><span>|</span><label class="collapse" for="c-41117320">[-]</label><label class="expand" for="c-41117320">[1 more]</label></div><br/><div class="children"><div class="content">They are massively faster (as in, has better throughput) than ref counting. See my previous comment for more details.</div><br/></div></div></div></div></div></div><div id="41116389" class="c"><input type="checkbox" id="c-41116389" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41115419">parent</a><span>|</span><a href="#41116763">prev</a><span>|</span><a href="#41117301">next</a><span>|</span><label class="collapse" for="c-41116389">[-]</label><label class="expand" for="c-41116389">[2 more]</label></div><br/><div class="children"><div class="content">For GC-based inner languages it&#x27;s mandatory to mention that inter-language cycles are nasty. Life is much easier in a world of explicit ownership!<p>I curate a list of what kinds of ownership people actually <i>want</i>: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;o11c&#x2F;dee52f11428b3d70914c4ed5652d43f7" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;o11c&#x2F;dee52f11428b3d70914c4ed5652d43f...</a><p>It&#x27;s been 6 years since I first posted it publicly, and neither I nor anyone giving suggestions has ever actually found a use for GC.</div><br/><div id="41116570" class="c"><input type="checkbox" id="c-41116570" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41116389">parent</a><span>|</span><a href="#41117301">next</a><span>|</span><label class="collapse" for="c-41116570">[-]</label><label class="expand" for="c-41116570">[1 more]</label></div><br/><div class="children"><div class="content">IME the utility of GC is not for structs but for closures. It’s very easy to cause cycles when freely using closures in non-GC languages.</div><br/></div></div></div></div><div id="41117301" class="c"><input type="checkbox" id="c-41117301" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41115419">parent</a><span>|</span><a href="#41116389">prev</a><span>|</span><a href="#41115186">next</a><span>|</span><label class="collapse" for="c-41117301">[-]</label><label class="expand" for="c-41117301">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since it&#x27;s not needed and it&#x27;s massively worse than reference counting<p>Lol, what? Maybe don’t go asserting stuff you clearly know little about. Reference counting is a fine tradeoff for manual memory-managed languages, but it is absolutely smoked out of the water by a tracing GC on most counts. It’s almost like JVM, V8, etc engineers know a thing about the topic and don’t have RC for a good reason.<p>Tracing GC doesn’t burden the mutator threads with additional work, almost everything can be done in parallel, resulting in vastly better throughput. Imagine dropping the last reference to a huge graph, one can actually observe it when exiting a c++ program, it might hang for a few seconds before returning control to you, as all the destructors are recursively called, serially, on the program thread, literally pointer by pointer jumping across the heap, the very thing you are so afraid of. And I didn’t even get to the atomic part, bumping a number up or down with synchronization between CPUs is literally the slowest operation you can do on a modern machine. Tracing GCs elegantly avoid all these problems at the price of some memory overhead. None of these GC algorithms (yes, RC is a GC) is a silver bullet, but let’s not joke ourselves.</div><br/></div></div></div></div><div id="41115186" class="c"><input type="checkbox" id="c-41115186" checked=""/><div class="controls bullet"><span class="by">creata</span><span>|</span><a href="#41113725">root</a><span>|</span><a href="#41115136">parent</a><span>|</span><a href="#41115419">prev</a><span>|</span><a href="#41116267">next</a><span>|</span><label class="collapse" for="c-41115186">[-]</label><label class="expand" for="c-41115186">[1 more]</label></div><br/><div class="children"><div class="content">You probably already know this, but the gc crate is an implementation of a somewhat more sophisticated GC, but it uses `derive`s to implement tracing, so it&#x27;s not <i>exactly</i> the Rc&lt;T&gt; interface.</div><br/></div></div></div></div><div id="41116267" class="c"><input type="checkbox" id="c-41116267" checked=""/><div class="controls bullet"><span class="by">nikhilsimha</span><span>|</span><a href="#41113725">parent</a><span>|</span><a href="#41115136">prev</a><span>|</span><a href="#41116165">next</a><span>|</span><label class="collapse" for="c-41116267">[-]</label><label class="expand" for="c-41116267">[1 more]</label></div><br/><div class="children"><div class="content">i personally like nim’s approach to memory management - implicitly refcounted, but exposes clean manual memory management when needed</div><br/></div></div></div></div><div id="41116165" class="c"><input type="checkbox" id="c-41116165" checked=""/><div class="controls bullet"><span class="by">Leftium</span><span>|</span><a href="#41113725">prev</a><span>|</span><a href="#41113434">next</a><span>|</span><label class="collapse" for="c-41116165">[-]</label><label class="expand" for="c-41116165">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ...functional programming is mostly about avoiding mutation at all costs<p>Slightly different perspective from Grokking Simplicity[1]: functional programming is not about avoiding mutation because &quot;mutation is bad.&quot; In fact, mutation is usually the desired result, but care must be taken because mutation depends on when and how many times it&#x27;s called.<p>So good FP isn&#x27;t about avoiding impure functions; instead it&#x27;s about giving <i>extra</i> care to them. After all, the purpose of all software is to cause some type of mutation&#x2F;effect (flip pixels on a screen, save bits to storage, send email, etc). Impure functions like these depend on the time they are called, so they are the most difficult to get right.<p>So Grokking Simplicity would probably say this:<p>1. Avoid pre-mature optimization. The overhead from FP is usually not significant, given the speed of today&#x27;s computers. Also performance gains unlocked by FP may counter any performance losses.<p>2. If optimization via mutation is required, push it as far outside and as late as possible, keeping the &quot;core&quot; functionally pure and immutable.<p>This is similar to Functional Core, Imperative Shell[2]; and perhaps similar to options 1 or 2 from the article.<p>[1]: <a href="https:&#x2F;&#x2F;www.manning.com&#x2F;books&#x2F;grokking-simplicity" rel="nofollow">https:&#x2F;&#x2F;www.manning.com&#x2F;books&#x2F;grokking-simplicity</a><p>[2]: <a href="https:&#x2F;&#x2F;hw.leftium.com&#x2F;#&#x2F;item&#x2F;18043058" rel="nofollow">https:&#x2F;&#x2F;hw.leftium.com&#x2F;#&#x2F;item&#x2F;18043058</a></div><br/></div></div><div id="41113434" class="c"><input type="checkbox" id="c-41113434" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41116165">prev</a><span>|</span><a href="#41113261">next</a><span>|</span><label class="collapse" for="c-41113434">[-]</label><label class="expand" for="c-41113434">[34 more]</label></div><br/><div class="children"><div class="content">The article utterly falls apart in its first paragraph where it itself acknowledges that the whole ML family including Ocaml has perfect support for mutation, rightfully assume most Ocaml programmers would choose to not use it most of the time but then assume incorrectly that it’s because the language makes it somehow uneasy. It’s not. It’s just that mutation is very rarely optimal. Even the exemple given fails:<p>&gt; For example, let&#x27;s say you&#x27;re iterating over some structure and collecting your results in a sequence. The most efficient data structure to use here would be a mutable dynamic array and in an imperative language that&#x27;s what pretty much everyone would use.<p>Well, no, this is straight confusion between what’s expressed by the program and what’s compiled. The idiomatic code in Ocaml will end up generating machine code which is as performant than using mutable array.<p>The fact that most programming languages don’t give enough semantic information for their compiler to do a good job doesn’t mean it necessary has to be so.  Functional programmers just trust that their compiler will properly optimize their code.<p>It gets fairly obvious when you realise that most Ocaml developers switch to using array when they want to benefit from unboxed floats.<p>The whole article is secretly about Haskell and fails to come to the obvious conclusion: Haskell choice of segregating mutations in special types and  use monads was an interesting and fruitful research topic but ultimately proved to be a terrible choice when it comes to language design (my opinion obviously not some absolute truth but I think the many fairly convoluted tricks haskellers pull to somehow reintroduce mutations support it). The solution is simple: stop using Haskell.</div><br/><div id="41116686" class="c"><input type="checkbox" id="c-41116686" checked=""/><div class="controls bullet"><span class="by">injuly</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41114124">next</a><span>|</span><label class="collapse" for="c-41116686">[-]</label><label class="expand" for="c-41116686">[1 more]</label></div><br/><div class="children"><div class="content">&gt; which is as performant than using mutable array.<p>I get what you&#x27;re trying to say, but that is provably false.
As great as the OCaml compiler is, it currently is not capable of the aggressive optimizations that GHC can do with lists.<p>More often than not, the compiler mostly won&#x27;t have enough static assertions to reliably generate machine code like that in a real world application (unless explicit mutation is used, of course).<p>&gt; Functional programmers just trust that their compiler will properly optimize their code.<p>Precisely.
This is why having safe local mutation as a language level feature can give more control to the programmer.
We no longer have to rely on the compiler to correctly guess whether a routine is better expressed as an array or a cons list.<p>&gt; The whole article is secretly about Haskell.<p>and ML, Koka, Clean, Mercury.
The article is about allowing local mutation without breaking referential transparency at the language level.<p>&quot;Stop using haskell&quot; is a very shallow conclusion, IMO.</div><br/></div></div><div id="41114124" class="c"><input type="checkbox" id="c-41114124" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41116686">prev</a><span>|</span><a href="#41114098">next</a><span>|</span><label class="collapse" for="c-41114124">[-]</label><label class="expand" for="c-41114124">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Well, no, this is straight confusion between what’s expressed by the program and what’s compiled. The idiomatic code in Ocaml will end up generating machine code which is as performant than using mutable array.<p>This cannot be true in general. There are machine code patterns for which arrays are faster than linked lists. The OCaml compiler, great as it is, won&#x27;t turn linked list source code into array machine code. Therefore, there is idiomatic code in OCaml that will not be as performant as arrays.<p>&gt; It gets fairly obvious when you realise that most Ocaml developers switch to using array when they want to benefit from unboxed floats.<p>This is one example why your statement above is not true.</div><br/><div id="41114236" class="c"><input type="checkbox" id="c-41114236" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114124">parent</a><span>|</span><a href="#41114245">next</a><span>|</span><label class="collapse" for="c-41114236">[-]</label><label class="expand" for="c-41114236">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is one example why your statement above is not true.<p>You are misreading my comment. I’m not intentionally contradicting myself in two paragraphs next to each other (I’m not always the brightest but still).<p>The point is that contrary to what the article states ML developers are not avoiding mutations because they are uneasy to use but because they trust their compiler when they know it will do good. Proof is that in other case they will use mutations when it makes sense to do so because the compiler does not do a good job.<p>The first paragraph refers to the specific case my comment quotes just before: data structure traversal and storage of elements in a set.</div><br/><div id="41115015" class="c"><input type="checkbox" id="c-41115015" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114236">parent</a><span>|</span><a href="#41114245">next</a><span>|</span><label class="collapse" for="c-41115015">[-]</label><label class="expand" for="c-41115015">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The point is that contrary to what the article states ML developers are not avoiding mutations because they are uneasy to use but because they trust their compiler when they know it will do good. Proof is that in other case they will use mutations when it makes sense to do so because the compiler does not do a good job.<p>It will do a <i>good</i> job, yes. Will it do the best possible job compared to some other algorithm or data structure? It can&#x27;t. Not in general.<p>And maybe not in the specific case either:<p>&gt; The first paragraph refers to the specific case my comment quotes just before: data structure traversal and storage of elements in a set.<p>So, this: <a href="https:&#x2F;&#x2F;ocaml.org&#x2F;play#code=bW9kdWxlIE15X2R5bmFycmF5ID0gc3RydWN0CgogIHR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBsZW5ndGg6IGludDsgbXV0YWJsZSB2YWx1ZXM6ICdhIGFycmF5IH0KCiAgbGV0IG1ha2UgaW5pdCA9CiAgICB7IGxlbmd0aCA9IDA7IHZhbHVlcyA9IEFycmF5Lm1ha2UgMTAgaW5pdCB9CgogIGxldCBhZGQgZCB4ID0KICAgIGlmIGQubGVuZ3RoID0gQXJyYXkubGVuZ3RoIGQudmFsdWVzIHRoZW4gYmVnaW4KICAgICAgZC52YWx1ZXMgPC0gQXJyYXkuKGFwcGVuZCBkLnZhbHVlcyAobWFrZSAobGVuZ3RoIGQudmFsdWVzKSB4KSkKICAgIGVuZDsKICAgIGQudmFsdWVzLihkLmxlbmd0aCkgPC0geDsKICAgIGQubGVuZ3RoIDwtIGQubGVuZ3RoICsgMQoKZW5kCgpsZXQgdGltZSBmbiA9CiAgbGV0IHN0YXJ0ID0gU3lzLnRpbWUgKCkgaW4KICBpZ25vcmUgKGZuICgpKTsKICBsZXQgZmluaXNoID0gU3lzLnRpbWUgKCkgaW4KICBmaW5pc2ggLS4gc3RhcnQKCmxldCBsaXN0X2JlbmNoIGlucHV0ID0KICBmb3IgaSA9IDEgdG8gMyBkbwogICAgbGV0IHQgPSB0aW1lIChmdW4gKCkgLT4gTGlzdC5tYXAgKGZ1biB4IC0%2BIHggKyAxKSBpbnB1dCkgaW4KICAgIEZvcm1hdC5wcmludGYgImxpc3Q6ICAgICAgICAlZiBzZWNcbiUhIiB0CiAgZG9uZQoKbGV0IGR5bmFycmF5X2JlbmNoIGlucHV0ID0KICBmb3IgaSA9IDEgdG8gMyBkbwogICAgbGV0IGQgPSBEeW5hcnJheS5jcmVhdGUgKCkgaW4KICAgIGxldCB0ID0gdGltZSAoZnVuICgpIC0%2BIExpc3QuaXRlciAoZnVuIHggLT4gRHluYXJyYXkuYWRkX2xhc3QgZCAoeCArIDEpKSBpbnB1dCkgaW4KICAgIEZvcm1hdC5wcmludGYgImR5bmFycmF5OiAgICAlZiBzZWNcbiUhIiB0CiAgZG9uZQoKbGV0IG15X2R5bmFycmF5X2JlbmNoIGlucHV0ID0KICBmb3IgaSA9IDEgdG8gMyBkbwogICAgbGV0IGQgPSBNeV9keW5hcnJheS5tYWtlICgtMSkgaW4KICAgIGxldCB0ID0gdGltZSAoZnVuICgpIC0%2BIExpc3QuaXRlciAoZnVuIHggLT4gTXlfZHluYXJyYXkuYWRkIGQgKHggKyAxKSkgaW5wdXQpIGluCiAgICBGb3JtYXQucHJpbnRmICJteSBkeW5hcnJheTogJWYgc2VjXG4lISIgdAogIGRvbmUKCmxldCBfID0KICBsZXQgaW5wdXQgPSBMaXN0LmluaXQgKGludF9vZl9zdHJpbmcgU3lzLmFyZ3YuKDIpKSBGdW4uaWQgaW4KICBtYXRjaCBTeXMuYXJndi4oMSkgd2l0aAogIHwgImxpc3QiIC0%2BIGxpc3RfYmVuY2ggaW5wdXQKICB8ICJkeW5hcnJheSIgLT4gZHluYXJyYXlfYmVuY2ggaW5wdXQKICB8ICJteV9keW5hcnJheSIgLT4gbXlfZHluYXJyYXlfYmVuY2ggaW5wdXQKICB8IF8gLT4gKCkK" rel="nofollow">https:&#x2F;&#x2F;ocaml.org&#x2F;play#code=bW9kdWxlIE15X2R5bmFycmF5ID0gc3Ry...</a><p><pre><code>    $ for len in 5_000_000 10_000_000 25_000_000; do echo &quot;-- ${len} elements --&quot;; .&#x2F;a.out list $len; .&#x2F;a.out dynarray $len; .&#x2F;a.out my_dynarray $len; echo; done
    -- 5_000_000 elements --
    list:        0.191551 sec
    list:        0.196947 sec
    list:        0.192806 sec
    dynarray:    0.301362 sec
    dynarray:    0.268592 sec
    dynarray:    0.266118 sec
    my dynarray: 0.163004 sec
    my dynarray: 0.142986 sec
    my dynarray: 0.143634 sec
    
    -- 10_000_000 elements --
    list:        0.377447 sec
    list:        0.367951 sec
    list:        0.312575 sec
    dynarray:    0.607158 sec
    dynarray:    0.582378 sec
    dynarray:    0.538621 sec
    my dynarray: 0.319705 sec
    my dynarray: 0.296607 sec
    my dynarray: 0.286634 sec
    
    -- 25_000_000 elements --
    list:        0.971244 sec
    list:        0.953493 sec
    list:        0.922049 sec
    dynarray:    1.515892 sec
    dynarray:    1.319543 sec
    dynarray:    1.328461 sec
    my dynarray: 1.119322 sec
    my dynarray: 0.971288 sec
    my dynarray: 0.973556 sec
    
    -- 50_000_000 elements --
    list:        1.852812 sec
    list:        1.848514 sec
    list:        1.505391 sec
    dynarray:    3.065143 sec
    dynarray:    2.941400 sec
    dynarray:    2.672760 sec
    my dynarray: 2.115499 sec
    my dynarray: 1.963535 sec
    my dynarray: 1.995470 sec
    
    -- 75_000_000 elements --
    list:        2.942536 sec
    list:        2.910063 sec
    list:        2.354291 sec
    dynarray:    4.567284 sec
    dynarray:    4.342670 sec
    dynarray:    3.979809 sec
    my dynarray: 2.528073 sec
    my dynarray: 2.225738 sec
    my dynarray: 2.226844 sec
</code></pre>
A simple dynamic array implementation (my_dynarray) beats a list over a wide range of lengths. But not at all lengths! OCaml&#x27;s built-in Dynarray is not competitive, but that&#x27;s because it wants to make certain strong guarantees.<p>To be clear, I agree with your <i>general</i> point that we can do just fine writing nice clean pure functional OCaml code for most of our code and can hand-optimize where needed. But your very specific claims rub me the wrong way.</div><br/><div id="41117068" class="c"><input type="checkbox" id="c-41117068" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41115015">parent</a><span>|</span><a href="#41114245">next</a><span>|</span><label class="collapse" for="c-41117068">[-]</label><label class="expand" for="c-41117068">[1 more]</label></div><br/><div class="children"><div class="content">Oops, this had a performance bug. Instead of:<p><pre><code>    if d.length = Array.length d.values then begin
      d.values &lt;- Array.(append d.values (make (length d.values) x))
    end;
</code></pre>
the array reallocation should actually be:<p><pre><code>    if d.length = Array.length d.values then begin
      let new_array = Array.make (Array.length d.values * 2) x in
      Array.blit d.values 0 new_array 0 (Array.length d.values);
      d.values &lt;- new_array
    end;
</code></pre>
otherwise we allocate about a third more memory than needed. It&#x27;s telling that even with this performance bug the dynamic array was broadly better than lists.<p>New results for the previously slowest cases:<p><pre><code>    -- 25_000_000 elements --
    list:        0.977002 sec
    list:        0.963903 sec
    list:        0.950473 sec
    dynarray:    1.476165 sec
    dynarray:    1.281724 sec
    dynarray:    1.343222 sec
    my dynarray: 0.872558 sec
    my dynarray: 0.755902 sec
    my dynarray: 0.753746 sec
    
    -- 50_000_000 elements --
    list:        1.914777 sec
    list:        1.886989 sec
    list:        1.542614 sec
    dynarray:    2.922376 sec
    dynarray:    2.783559 sec
    dynarray:    2.537473 sec
    my dynarray: 1.725873 sec
    my dynarray: 1.545252 sec
    my dynarray: 1.515591 sec
    
    -- 75_000_000 elements --
    list:        2.827154 sec
    list:        2.835789 sec
    list:        2.318733 sec
    dynarray:    4.354404 sec
    dynarray:    4.150271 sec
    dynarray:    3.781488 sec
    my dynarray: 1.887360 sec
    my dynarray: 1.929286 sec
    my dynarray: 1.814873 sec
</code></pre>
This turns an uneasy head-to-head into a clear win for dynamic arrays. Honestly, how could it be otherwise?</div><br/></div></div></div></div></div></div><div id="41114245" class="c"><input type="checkbox" id="c-41114245" checked=""/><div class="controls bullet"><span class="by">senorrib</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114124">parent</a><span>|</span><a href="#41114236">prev</a><span>|</span><a href="#41114586">next</a><span>|</span><label class="collapse" for="c-41114245">[-]</label><label class="expand" for="c-41114245">[2 more]</label></div><br/><div class="children"><div class="content">Well, it doesn&#x27;t make the substance wrong. This paragraph rightly summarizes it:<p>&quot;The fact that most programming languages don’t give enough semantic information for their compiler to do a good job doesn’t mean it necessary has to be so. Functional programmers just trust that their compiler will properly optimize their code.&quot;</div><br/><div id="41117077" class="c"><input type="checkbox" id="c-41117077" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114245">parent</a><span>|</span><a href="#41114586">next</a><span>|</span><label class="collapse" for="c-41117077">[-]</label><label class="expand" for="c-41117077">[1 more]</label></div><br/><div class="children"><div class="content">The substance of the statements I quoted was wrong. As I wrote elsewhere, I do agree with the broad statement that the combination of functional and imperative features in OCaml works just fine. But if the semantic information you give to the OCaml compiler is &quot;linked list&quot;, it will use a linked list rather than a data structure that might be better for the task at hand.</div><br/></div></div></div></div><div id="41114586" class="c"><input type="checkbox" id="c-41114586" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114124">parent</a><span>|</span><a href="#41114245">prev</a><span>|</span><a href="#41114098">next</a><span>|</span><label class="collapse" for="c-41114586">[-]</label><label class="expand" for="c-41114586">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The OCaml compiler, great as it is, won&#x27;t turn linked list source code into array machine code.<p>Why not? If the compiler can see that you have a short-lived local linked list and are using it in a way for which an array would be faster, why would it not do the same thing that an array would do?</div><br/><div id="41115043" class="c"><input type="checkbox" id="c-41115043" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114586">parent</a><span>|</span><a href="#41114098">next</a><span>|</span><label class="collapse" for="c-41115043">[-]</label><label class="expand" for="c-41115043">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why not?<p>Because it doesn&#x27;t. Doesn&#x27;t mean it couldn&#x27;t, if it tried hard enough. But it doesn&#x27;t, as a statement of current fact.</div><br/></div></div></div></div></div></div><div id="41114098" class="c"><input type="checkbox" id="c-41114098" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41114124">prev</a><span>|</span><a href="#41113798">next</a><span>|</span><label class="collapse" for="c-41114098">[-]</label><label class="expand" for="c-41114098">[9 more]</label></div><br/><div class="children"><div class="content">I mostly agree with your sentiment but this:<p>&gt; Well, no, this is straight confusion between what’s expressed by the program and what’s compiled. The idiomatic code in Ocaml will end up generating machine code which is as performant than using mutable array.<p>I disagree with. There are different ways to get close to the performance of `Array.map` with lists (best case scenario you don&#x27;t care about order and can use `List.rev_map`), but you will always have memory (and GC) overhead and so lists are strictly inferior to arrays for the presented use case.</div><br/><div id="41114144" class="c"><input type="checkbox" id="c-41114144" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114098">parent</a><span>|</span><a href="#41113798">next</a><span>|</span><label class="collapse" for="c-41114144">[-]</label><label class="expand" for="c-41114144">[8 more]</label></div><br/><div class="children"><div class="content">That’s not what the article is talking about. The proposed exemple is a traversal of a different data structure to collect results in an array. That’s a <i>fold</i> and will properly be tco-ed to something equivalent to adding to an array if you use list cons in the aggregation, might actually be better depending on how much resizing of the array you have to do while traversing.</div><br/><div id="41114871" class="c"><input type="checkbox" id="c-41114871" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114144">parent</a><span>|</span><a href="#41114480">next</a><span>|</span><label class="collapse" for="c-41114871">[-]</label><label class="expand" for="c-41114871">[4 more]</label></div><br/><div class="children"><div class="content">Works if you are building one list, but what if you are building multiple? What&#x27;s suggested on the OCaml site and what&#x27;s taught in most of academia is to use a recursive function with accumulator arguments that are reversed before returning to make the function tco:able. I doubt OCaml can optimize that pattern well, but idk.</div><br/><div id="41114941" class="c"><input type="checkbox" id="c-41114941" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114871">parent</a><span>|</span><a href="#41114480">next</a><span>|</span><label class="collapse" for="c-41114941">[-]</label><label class="expand" for="c-41114941">[3 more]</label></div><br/><div class="children"><div class="content">You can benefit from TCO while building multiple lists.<p><pre><code>  let rec f evens odds = function
    | [] -&gt; (evens, odds)
    | x :: xs  -&gt;
      if x mod 2 = 0 then f (x :: evens) odds xs
      else f evens (x :: odds) xs
</code></pre>
OCaml optimizes this fairly well and will compil it down to a single loop with two variables. If you reverse the lists there is going to be additional loops (and corresponding allocations).<p>However OCaml also provides the &quot;tail mod cons&quot; optimization that allows to get some of the benefits of TCO without needing to reverse the list (this is implemented as a program transformation that uses mutability under the hood), and that one will only work if you are building a single list.</div><br/><div id="41115205" class="c"><input type="checkbox" id="c-41115205" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114941">parent</a><span>|</span><a href="#41114480">next</a><span>|</span><label class="collapse" for="c-41115205">[-]</label><label class="expand" for="c-41115205">[2 more]</label></div><br/><div class="children"><div class="content">I think HN ate some characters because that code doesn&#x27;t look valid. But yeah, that&#x27;s how you do it. In my opinion it is not pretty (e.g., what if you have some mutable context?). I also don&#x27;t see how OCaml could turn the cons operations into dynamic array appends.</div><br/><div id="41116596" class="c"><input type="checkbox" id="c-41116596" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41115205">parent</a><span>|</span><a href="#41114480">next</a><span>|</span><label class="collapse" for="c-41116596">[-]</label><label class="expand" for="c-41116596">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think HN ate some characters because that code doesn&#x27;t look valid.<p>The OCaml compiler disagrees with you ;)<p>It also won&#x27;t ever turn a cons operation into a dynamic array append.</div><br/></div></div></div></div></div></div></div></div><div id="41114480" class="c"><input type="checkbox" id="c-41114480" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114144">parent</a><span>|</span><a href="#41114871">prev</a><span>|</span><a href="#41113798">next</a><span>|</span><label class="collapse" for="c-41114480">[-]</label><label class="expand" for="c-41114480">[3 more]</label></div><br/><div class="children"><div class="content">I think `Array.map` is a perfectly reasonable reading of &quot;you&#x27;re iterating over some structure and collecting your results in a sequence&quot;.<p>But sure, in the `fold` scenario where you don&#x27;t know the number of results in advance (you are more likely to know if you use imperative data structures, e.g. `Hashtbl.length` is constant-time whereas `Map.cardinal` is not), lists <i>might</i> be faster than growing arrays with copies. They are still going to use more memory, and they are unlikely to to be faster than a rope-like structure that grows with no copies.</div><br/><div id="41115104" class="c"><input type="checkbox" id="c-41115104" checked=""/><div class="controls bullet"><span class="by">senorrib</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114480">parent</a><span>|</span><a href="#41113798">next</a><span>|</span><label class="collapse" for="c-41115104">[-]</label><label class="expand" for="c-41115104">[2 more]</label></div><br/><div class="children"><div class="content">It isn’t. There’s no guarantee that .map will be processed in sequence. In fact, .map is usually a great candidate for parallelization.</div><br/><div id="41116577" class="c"><input type="checkbox" id="c-41116577" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41115104">parent</a><span>|</span><a href="#41113798">next</a><span>|</span><label class="collapse" for="c-41116577">[-]</label><label class="expand" for="c-41116577">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;sequence&quot; in the problem statement does not refer to the order of operations but to the data structure storing the results.<p>A parallel `Array.map` still computes a sequence, even though it may not compute in sequence.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41113798" class="c"><input type="checkbox" id="c-41113798" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41114098">prev</a><span>|</span><a href="#41114947">next</a><span>|</span><label class="collapse" for="c-41113798">[-]</label><label class="expand" for="c-41113798">[3 more]</label></div><br/><div class="children"><div class="content">I use f# daily at my company and am actually glad that many dotnet api integrations use array buffers (e.g. a byte array for streaming)<p>this forces me to optimize the f# code by thinking in terms of low-memory, mutable data structures when interfacing with external libraries.</div><br/><div id="41115240" class="c"><input type="checkbox" id="c-41115240" checked=""/><div class="controls bullet"><span class="by">phillipcarter</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41113798">parent</a><span>|</span><a href="#41114448">next</a><span>|</span><label class="collapse" for="c-41115240">[-]</label><label class="expand" for="c-41115240">[1 more]</label></div><br/><div class="children"><div class="content">Yep, and moreover, the combination of most library design and general culture around the language reinforces the dynamic of using mutability only when it&#x27;s needed or the most straightforward way to implement something, and contain that with immutable interfaces wherever possible.<p>I like to think we helped with this several years ago when making official guidance: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;style-guide&#x2F;conventions#immutability-and-mutation" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;style-guide&#x2F;...</a></div><br/></div></div><div id="41114448" class="c"><input type="checkbox" id="c-41114448" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41113798">parent</a><span>|</span><a href="#41115240">prev</a><span>|</span><a href="#41114947">next</a><span>|</span><label class="collapse" for="c-41114448">[-]</label><label class="expand" for="c-41114448">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, F# in general is pretty mutation friendly given how functional it is.</div><br/></div></div></div></div><div id="41114947" class="c"><input type="checkbox" id="c-41114947" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41113798">prev</a><span>|</span><a href="#41113703">next</a><span>|</span><label class="collapse" for="c-41114947">[-]</label><label class="expand" for="c-41114947">[3 more]</label></div><br/><div class="children"><div class="content">One thing that many people miss is that Haskell&#x27;s monadic style is a direct consequence of lazy evaluation. It all started because they thought lazyness was nice, and wanted to make a language that brought that front and center. But then they found out that they had to come up with a new way to do side-effects, because traditional side-effects don&#x27;t work when the order of evaluation is unpredictable.</div><br/><div id="41116978" class="c"><input type="checkbox" id="c-41116978" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41114947">parent</a><span>|</span><a href="#41113703">next</a><span>|</span><label class="collapse" for="c-41116978">[-]</label><label class="expand" for="c-41116978">[2 more]</label></div><br/><div class="children"><div class="content">I think this is historically wrong. Monads didn’t land until later in Haskell, no?</div><br/><div id="41117109" class="c"><input type="checkbox" id="c-41117109" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41116978">parent</a><span>|</span><a href="#41113703">next</a><span>|</span><label class="collapse" for="c-41117109">[-]</label><label class="expand" for="c-41117109">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think GP is contradicting that.</div><br/></div></div></div></div></div></div><div id="41113703" class="c"><input type="checkbox" id="c-41113703" checked=""/><div class="controls bullet"><span class="by">runeblaze</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41114947">prev</a><span>|</span><a href="#41114444">next</a><span>|</span><label class="collapse" for="c-41113703">[-]</label><label class="expand" for="c-41113703">[5 more]</label></div><br/><div class="children"><div class="content">I second the conclusion as (a brutal conclusion, but still) to stop using Haskell. Haskell allows imperative-like code but the ergonomics for day-to-day big-tech engineering is far from good. The state monad or lens are excellent tools to re-create a controlled imperative language in a vacuum, and is frankly impressive how much mutation we can conjure up from purity, but the error messages or the required understanding of PLT-ish things makes it non-scalable to &quot;real&quot; teams.</div><br/><div id="41115719" class="c"><input type="checkbox" id="c-41115719" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41113703">parent</a><span>|</span><a href="#41114444">next</a><span>|</span><label class="collapse" for="c-41115719">[-]</label><label class="expand" for="c-41115719">[4 more]</label></div><br/><div class="children"><div class="content">Haskell almost seems like it was intentionally designed to perform poorly on real computers, primarily because of space leaks and secondarily because the non-strict evaluation gets compiled into a lot of function pointer jumps, which branch predictors hate.<p>I think it&#x27;s funny that they make you write linked list code as a metaphor for generators, but it seems like it should be the other way round.<p>(Also, it has exceptions which are a bad language feature, and typed throws which are a worse one.)</div><br/><div id="41116351" class="c"><input type="checkbox" id="c-41116351" checked=""/><div class="controls bullet"><span class="by">initplus</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41115719">parent</a><span>|</span><a href="#41117117">next</a><span>|</span><label class="collapse" for="c-41116351">[-]</label><label class="expand" for="c-41116351">[1 more]</label></div><br/><div class="children"><div class="content">It seems that way because it kind of is. The early days of functional research were equally focused on designing alternative computer architectures that were more suited to functional paradigms.<p>Now that hardware angle has not been very successful on the whole, and we are left with languages that end up feeling a bit out of place on the hardware we have today.<p>Another thing to note is that there is a lot of untapped potential in fb compilers. It’s suffering from underinvestment.</div><br/></div></div><div id="41117117" class="c"><input type="checkbox" id="c-41117117" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41115719">parent</a><span>|</span><a href="#41116351">prev</a><span>|</span><a href="#41114444">next</a><span>|</span><label class="collapse" for="c-41117117">[-]</label><label class="expand" for="c-41117117">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (Also, it has exceptions which are a bad language feature, and typed throws which are a worse one.)<p>Can you elaborate?  You can&#x27;t stop people simulating exceptions with sum types, and if you have exceptions, why wouldn&#x27;t you want them to be typed?</div><br/><div id="41117369" class="c"><input type="checkbox" id="c-41117369" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41113434">root</a><span>|</span><a href="#41117117">parent</a><span>|</span><a href="#41114444">next</a><span>|</span><label class="collapse" for="c-41117369">[-]</label><label class="expand" for="c-41117369">[1 more]</label></div><br/><div class="children"><div class="content">Sum types aren&#x27;t a simulation of exceptions.</div><br/></div></div></div></div></div></div></div></div><div id="41115071" class="c"><input type="checkbox" id="c-41115071" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41114444">prev</a><span>|</span><a href="#41114981">next</a><span>|</span><label class="collapse" for="c-41115071">[-]</label><label class="expand" for="c-41115071">[1 more]</label></div><br/><div class="children"><div class="content">And not even always how the code is compiled. Canned runtime library routines can you destructive techniques to produce their outputs. The program doesn&#x27;t see an aggregate object until the function returns it. (If we set aside lazy structures for a moment, but those are actually another example of something that can be built destructively under the hood. As you probably more deeply into the object it is mutated to make more of it materialize.)</div><br/></div></div><div id="41114981" class="c"><input type="checkbox" id="c-41114981" checked=""/><div class="controls bullet"><span class="by">pcstl</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41115071">prev</a><span>|</span><a href="#41113670">next</a><span>|</span><label class="collapse" for="c-41114981">[-]</label><label class="expand" for="c-41114981">[1 more]</label></div><br/><div class="children"><div class="content">Can you provide evidence that code which is &quot;as performant as using mutation&quot; is generated? Mutation tends to be <i>very</i> hard to beat.</div><br/></div></div><div id="41113670" class="c"><input type="checkbox" id="c-41113670" checked=""/><div class="controls bullet"><span class="by">senorrib</span><span>|</span><a href="#41113434">parent</a><span>|</span><a href="#41114981">prev</a><span>|</span><a href="#41113261">next</a><span>|</span><label class="collapse" for="c-41113670">[-]</label><label class="expand" for="c-41113670">[1 more]</label></div><br/><div class="children"><div class="content">Came here to write exactly this. Thank you.</div><br/></div></div></div></div><div id="41113261" class="c"><input type="checkbox" id="c-41113261" checked=""/><div class="controls bullet"><span class="by">dave4420</span><span>|</span><a href="#41113434">prev</a><span>|</span><a href="#41113983">next</a><span>|</span><label class="collapse" for="c-41113261">[-]</label><label class="expand" for="c-41113261">[7 more]</label></div><br/><div class="children"><div class="content">A variant of option 4 is to keep track of references you know cannot possibly be shared, and update those by mutation. Compared to reference counting, it misses some opportunities for mutation, but avoids the false sharing.<p>I think Roc is doing this.</div><br/><div id="41114562" class="c"><input type="checkbox" id="c-41114562" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#41113261">parent</a><span>|</span><a href="#41114223">next</a><span>|</span><label class="collapse" for="c-41114562">[-]</label><label class="expand" for="c-41114562">[3 more]</label></div><br/><div class="children"><div class="content">To what extent is this already being done by other functional blanguages that have CoW mutability?
This seems like a legal compiler optimization to make in most cases no?</div><br/><div id="41115523" class="c"><input type="checkbox" id="c-41115523" checked=""/><div class="controls bullet"><span class="by">wittystick</span><span>|</span><a href="#41113261">root</a><span>|</span><a href="#41114562">parent</a><span>|</span><a href="#41114223">next</a><span>|</span><label class="collapse" for="c-41115523">[-]</label><label class="expand" for="c-41115523">[2 more]</label></div><br/><div class="children"><div class="content">Clean has been doing this for nearly as long as people have been using monads, but it never got the attention Haskell did, which I think is quite unfortunate. Rather than implictly keeping track of references, uniqueness types are marked explicitly to inform that their values cannot be aliased. They can also be used with monads to improve ergonomics a bit.<p>Granule has uniqueness types like Clean built onto a linear type system, which offers some additional advantages.</div><br/><div id="41115690" class="c"><input type="checkbox" id="c-41115690" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#41113261">root</a><span>|</span><a href="#41115523">parent</a><span>|</span><a href="#41114223">next</a><span>|</span><label class="collapse" for="c-41115690">[-]</label><label class="expand" for="c-41115690">[1 more]</label></div><br/><div class="children"><div class="content">Is Clean being used anywhere? Last time I looked at it was 1999 and, while cool, I haven&#x27;t ever heard of anyone using it.</div><br/></div></div></div></div></div></div><div id="41114223" class="c"><input type="checkbox" id="c-41114223" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41113261">parent</a><span>|</span><a href="#41114562">prev</a><span>|</span><a href="#41113390">next</a><span>|</span><label class="collapse" for="c-41114223">[-]</label><label class="expand" for="c-41114223">[1 more]</label></div><br/><div class="children"><div class="content">jq does this.  But at the jq language level it looks like mutation creates new values without mutating the old ones.</div><br/></div></div><div id="41113390" class="c"><input type="checkbox" id="c-41113390" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#41113261">parent</a><span>|</span><a href="#41114223">prev</a><span>|</span><a href="#41113983">next</a><span>|</span><label class="collapse" for="c-41113390">[-]</label><label class="expand" for="c-41113390">[2 more]</label></div><br/><div class="children"><div class="content">Came here to say this! Last I heard, the Roc folks were still curious to see whether this bet pays off for most&#x2F;all codebases.</div><br/><div id="41114123" class="c"><input type="checkbox" id="c-41114123" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41113261">root</a><span>|</span><a href="#41113390">parent</a><span>|</span><a href="#41113983">next</a><span>|</span><label class="collapse" for="c-41114123">[-]</label><label class="expand" for="c-41114123">[1 more]</label></div><br/><div class="children"><div class="content">For those following along <a href="https:&#x2F;&#x2F;github.com&#x2F;roc-lang&#x2F;roc">https:&#x2F;&#x2F;github.com&#x2F;roc-lang&#x2F;roc</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;multikitty&#x2F;New-Programming-Languages-Showcase&#x2F;blob&#x2F;main&#x2F;Roc%20Programming%20Language.md">https:&#x2F;&#x2F;github.com&#x2F;multikitty&#x2F;New-Programming-Languages-Show...</a><p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6qzWm_eoUXM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6qzWm_eoUXM</a></div><br/></div></div></div></div></div></div><div id="41113983" class="c"><input type="checkbox" id="c-41113983" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#41113261">prev</a><span>|</span><a href="#41114572">next</a><span>|</span><label class="collapse" for="c-41113983">[-]</label><label class="expand" for="c-41113983">[4 more]</label></div><br/><div class="children"><div class="content">I don’t know how Swift and Koka handle things, but I’ve written a lot of Tcl that uses the same CoW reference-counting trick. (Tcl is an under-appreciated FP language: everything is a string, and strings are immutable, so it has had efficient purely declarative data structures for decades).<p>The downside in Tcl is that if you refactor some code suddenly you can add a new reference and drop into accidentally quadratic territory because now everything is being copied. This leads to some cute&#x2F;ugly hacks that are only explainable in terms of interpreter implementation details, purely to reduce a refcount in the right spot.</div><br/><div id="41115280" class="c"><input type="checkbox" id="c-41115280" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41113983">parent</a><span>|</span><a href="#41114572">next</a><span>|</span><label class="collapse" for="c-41115280">[-]</label><label class="expand" for="c-41115280">[3 more]</label></div><br/><div class="children"><div class="content">In Swift you occasionally have to introduce a temporary local variable to avoid accidentally quadratic behavior, but I&#x27;ve never seen it require anything complicated or hard to explain.</div><br/><div id="41115616" class="c"><input type="checkbox" id="c-41115616" checked=""/><div class="controls bullet"><span class="by">burntcaramel</span><span>|</span><a href="#41113983">root</a><span>|</span><a href="#41115280">parent</a><span>|</span><a href="#41114572">next</a><span>|</span><label class="collapse" for="c-41115616">[-]</label><label class="expand" for="c-41115616">[2 more]</label></div><br/><div class="children"><div class="content">Curious about an example of this in Swift? Is it a variable holding a collection like an Array?</div><br/><div id="41116463" class="c"><input type="checkbox" id="c-41116463" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41113983">root</a><span>|</span><a href="#41115616">parent</a><span>|</span><a href="#41114572">next</a><span>|</span><label class="collapse" for="c-41116463">[-]</label><label class="expand" for="c-41116463">[1 more]</label></div><br/><div class="children"><div class="content">A really simple example:<p><pre><code>    class Foo {
        var foo = [Int]()
        var bar: [Int] {
            get {
                foo
            }
            set {
                foo = newValue
            }
        }
    }
    let obj = Foo()
</code></pre>
Calling `obj.foo.append(i)` in a loop takes linear time, while `obj.bar.append(1)` is quadratic time. `obj.foo.append()` does a borrow operation resulting in there never being more than one reference at a time, while `obj.bar.append()` does a get followed by a set, meaning that there&#x27;s always two references to the array and every append does a copy on write. `let bar = obj.bar; for i = 0..&lt;max { bar.append(i) }; obj.bar = bar` would do just a single CoW.<p>Usually of course your computed properties actually <i>do</i> something so this difference feels less surprising. Swift does offer the undocumented `_modify` property accessor to let computed operations do borrows, but making it an official feature is waiting for noncopyable types to be finalized.</div><br/></div></div></div></div></div></div></div></div><div id="41114572" class="c"><input type="checkbox" id="c-41114572" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41113983">prev</a><span>|</span><a href="#41114609">next</a><span>|</span><label class="collapse" for="c-41114572">[-]</label><label class="expand" for="c-41114572">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced about the dismissal of option 2.  I agree ST is clunky but not for the reasons given. It&#x27;s clunky because it&#x27;s impossible to mix with other effects.  What if I want ST <i>and</i> exceptions, for example, and I want the presence of both to be tracked in the type signature?  ST can&#x27;t do that.  But my effect system, Bluefin, can. In fact it can mix not only state references and exceptions, but arbitrary other effects such as streams and IO.<p>* <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin-0.0.2.0&#x2F;docs&#x2F;Bluefin-State.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin-0.0.2.0&#x2F;docs&#x2F;Blu...</a><p>* <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin-0.0.6.0&#x2F;docs&#x2F;Bluefin-Exception.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin-0.0.6.0&#x2F;docs&#x2F;Blu...</a></div><br/><div id="41114744" class="c"><input type="checkbox" id="c-41114744" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41114572">parent</a><span>|</span><a href="#41114698">next</a><span>|</span><label class="collapse" for="c-41114744">[-]</label><label class="expand" for="c-41114744">[2 more]</label></div><br/><div class="children"><div class="content">Nice, first I&#x27;m hearing of bluefin - I&#x27;ll be sure to check it out.<p>As an aside, I watched an Alexis King stream (which I can&#x27;t now find) in which she did a deep dive into effect systems and said something along the lines of: algebraic effect systems should not change their behaviour depending on nesting order e.g. Either&lt;State&lt;&gt;&gt; vs State&lt;Either&lt;&gt;&gt;.<p>Does bluefin have a particular philosophy about how to approach this?</div><br/><div id="41117174" class="c"><input type="checkbox" id="c-41117174" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114744">parent</a><span>|</span><a href="#41114698">next</a><span>|</span><label class="collapse" for="c-41117174">[-]</label><label class="expand" for="c-41117174">[1 more]</label></div><br/><div class="children"><div class="content">I agree with Alexis.  Bluefin approaches this by not actually having a nesting order.  The effects that can be performed as specified as function arguments, so they can be freely reordered without changing behaviour.  effectful, which was one of the inspirations for Bluefin, is similar but uses constraints instead of function arguments, which are even more free to reorder.<p>&gt; I&#x27;ll be sure to check it out<p>Great! If you have any questions or thoughts then feel free to file an issue on the repo (<a href="https:&#x2F;&#x2F;github.com&#x2F;tomjaguarpaw&#x2F;bluefin&#x2F;issues&#x2F;new">https:&#x2F;&#x2F;github.com&#x2F;tomjaguarpaw&#x2F;bluefin&#x2F;issues&#x2F;new</a>).</div><br/></div></div></div></div><div id="41114698" class="c"><input type="checkbox" id="c-41114698" checked=""/><div class="controls bullet"><span class="by">gloria_mundi</span><span>|</span><a href="#41114572">parent</a><span>|</span><a href="#41114744">prev</a><span>|</span><a href="#41114609">next</a><span>|</span><label class="collapse" for="c-41114698">[-]</label><label class="expand" for="c-41114698">[10 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t mixing of effects exactly what monad transformers are for? AFAICT you want an `ExceptT e ST` for some exception type `e`.<p><a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;mtl-2.3.1&#x2F;docs&#x2F;Control-Monad-Except.html#g:2" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;mtl-2.3.1&#x2F;docs&#x2F;Control-M...</a></div><br/><div id="41117129" class="c"><input type="checkbox" id="c-41117129" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114698">parent</a><span>|</span><a href="#41114854">next</a><span>|</span><label class="collapse" for="c-41117129">[-]</label><label class="expand" for="c-41117129">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I meant it&#x27;s impossible to mix ST with actual exceptions as implemented in the RTS, rather than with ExceptT which simulates exceptions in pure code (like StateT simulates mutable state in pure code).<p>You&#x27;re right, through a stroke of luck it&#x27;s possible to use `ExceptT e ST r` and either handle the exception part first, to get `ST r`, or handle the ST part first to get `Either e r`, so in that sense you can &quot;mix&quot; exceptions and ST. That doesn&#x27;t work for all transformers though.  If you have `Stream (Of a) ST r` then you <i>must</i> consume the stream first.  You can&#x27;t run the ST part an get a pure stream `Stream (Of a) Identity r`.  So in that sense ST can&#x27;t be mixed with other effects.  Bluefin <i>does</i> allow you to do that, though.</div><br/></div></div><div id="41114854" class="c"><input type="checkbox" id="c-41114854" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114698">parent</a><span>|</span><a href="#41117129">prev</a><span>|</span><a href="#41114609">next</a><span>|</span><label class="collapse" for="c-41114854">[-]</label><label class="expand" for="c-41114854">[8 more]</label></div><br/><div class="children"><div class="content">Yes, but transformers have a few drawbacks: the order of stacking alters behaviour, and you need to write n^2 instances for n transformers.<p>Compare ExceptT e (StateT m a) and StateT (ExceptT e m a): if you just want your computation to have state and exceptions the difference shouldn’t matter.</div><br/><div id="41115197" class="c"><input type="checkbox" id="c-41115197" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114854">parent</a><span>|</span><a href="#41115224">next</a><span>|</span><label class="collapse" for="c-41115197">[-]</label><label class="expand" for="c-41115197">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you just want your computation to have state and exceptions the difference shouldn’t matter<p>But... you don&#x27;t just want that.  You almost certainly care whether state changes are discarded when an exception is thrown.  I don&#x27;t claim that the types there are the most obvious or natural way to specify that, but there is a meaningful difference that <i>shouldn&#x27;t</i> be handwaved away.</div><br/></div></div><div id="41115224" class="c"><input type="checkbox" id="c-41115224" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114854">parent</a><span>|</span><a href="#41115197">prev</a><span>|</span><a href="#41114962">next</a><span>|</span><label class="collapse" for="c-41115224">[-]</label><label class="expand" for="c-41115224">[4 more]</label></div><br/><div class="children"><div class="content">I might have this wrong but I think if you want state and exceptions you probably want StateT (ExceptT e m a). The alternative would be to have state <i>or</i> exceptions, i.e. when you have an exception you no longer have state (which might be a legitimate type in some cases).</div><br/><div id="41115352" class="c"><input type="checkbox" id="c-41115352" checked=""/><div class="controls bullet"><span class="by">gloria_mundi</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41115224">parent</a><span>|</span><a href="#41114962">next</a><span>|</span><label class="collapse" for="c-41115352">[-]</label><label class="expand" for="c-41115352">[3 more]</label></div><br/><div class="children"><div class="content">Remember that transformers are &quot;inside-out&quot;, i.e. `StateT (ExceptT e m) a` is isomorphic to `m (Except e (State a))`. If we want to keep state if an exception occurs, you need a `m (State (Except e a))` which is `ExceptT e (StateT m) a`.</div><br/><div id="41115805" class="c"><input type="checkbox" id="c-41115805" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41115352">parent</a><span>|</span><a href="#41114962">next</a><span>|</span><label class="collapse" for="c-41115805">[-]</label><label class="expand" for="c-41115805">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I could never keep this straight</div><br/><div id="41116579" class="c"><input type="checkbox" id="c-41116579" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41115805">parent</a><span>|</span><a href="#41114962">next</a><span>|</span><label class="collapse" for="c-41116579">[-]</label><label class="expand" for="c-41116579">[1 more]</label></div><br/><div class="children"><div class="content">The way I remembered it, before I internalized it, was to think about applying the run functions one at a time.  runSomethingT will take a `SomethingT ... m ... a` and give you some kind of `m (... a)`.</div><br/></div></div></div></div></div></div></div></div><div id="41114962" class="c"><input type="checkbox" id="c-41114962" checked=""/><div class="controls bullet"><span class="by">throw156754228</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114854">parent</a><span>|</span><a href="#41115224">prev</a><span>|</span><a href="#41114609">next</a><span>|</span><label class="collapse" for="c-41114962">[-]</label><label class="expand" for="c-41114962">[2 more]</label></div><br/><div class="children"><div class="content">Also their other well known problem: you lose the program state if an exception is thrown in the monad above.</div><br/><div id="41117140" class="c"><input type="checkbox" id="c-41117140" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41114572">root</a><span>|</span><a href="#41114962">parent</a><span>|</span><a href="#41114609">next</a><span>|</span><label class="collapse" for="c-41117140">[-]</label><label class="expand" for="c-41117140">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s basically the same problem as `StateT s (ExceptT e m)` but for `StateT s m` where `m` throws exceptions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41114609" class="c"><input type="checkbox" id="c-41114609" checked=""/><div class="controls bullet"><span class="by">anfelor</span><span>|</span><a href="#41114572">prev</a><span>|</span><a href="#41113528">next</a><span>|</span><label class="collapse" for="c-41114609">[-]</label><label class="expand" for="c-41114609">[1 more]</label></div><br/><div class="children"><div class="content">Disclosure: I work on Koka&#x27;s FBIP optimization (Option 4).<p>&gt; The most efficient data structure to use here would be a mutable dynamic array and in an imperative language that&#x27;s what pretty much everyone would use. But if you asked an OCaml programmer, they would almost certainly use a linked list instead.<p>I agree with this sentiment. However, OCaml does have mutable arrays that are both efficient and convenient to use. Why would a programmer prefer a list over them? In my opinion, the main benefit of lists in this context is that they allow pattern matching and inductive reasoning. To make functional programming languages more suited for array programming, we would thus need something like View Patterns for arrays.<p>A related issue is that mutation can actually be slower than fresh allocations in OCaml. The reason for this is that the garbage collector is optimized for immutable datastructures and has both a very fast minor heap that makes allocations cheap and expensive tracking for references that do not go from younger to older elements. See: <a href="https:&#x2F;&#x2F;dev.realworldocaml.org&#x2F;garbage-collector.html#scrollNav-4-5" rel="nofollow">https:&#x2F;&#x2F;dev.realworldocaml.org&#x2F;garbage-collector.html#scroll...</a><p>&gt; Unfortunately, this makes it impossible to use any standard functions like map on linear values and either makes linearity nearly useless or inevitably creates a parallel, incomplete universe of functions that also work on linear values.<p>You can implement polymorphism over linearity: this is done in Frank Pfenning&#x27;s SNAX language and planned for the uniqueness types in a branch of OCaml.<p>&gt; This might sound a little dangerous since accidentally holding on to a reference could turn a linear time algorithm quadratic<p>No, the in-place reuse optimization does not affect the asymptotic time complexity. But it can indeed change the performance drastically if a value is no longer shared since copies are needed then.<p>&gt; A tracing garbage collector just doesn&#x27;t give you this sort of information.<p>It is possible to add One-bit Reference Counts to a garbage collector, see <a href="https:&#x2F;&#x2F;gitlab.haskell.org&#x2F;ghc&#x2F;ghc&#x2F;-&#x2F;issues&#x2F;23943" rel="nofollow">https:&#x2F;&#x2F;gitlab.haskell.org&#x2F;ghc&#x2F;ghc&#x2F;-&#x2F;issues&#x2F;23943</a><p>&gt; for now even these struggle to keep up with tracing garbage collectors even when factoring in automatic reuse analysis.<p>I investigated the linked benchmarks for a while. The gap between Koka and Haskell is smaller than described in that initial comment, but a tuned GHC is indeed a bit faster than Koka on that benchmark.</div><br/></div></div><div id="41113528" class="c"><input type="checkbox" id="c-41113528" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41114609">prev</a><span>|</span><a href="#41115845">next</a><span>|</span><label class="collapse" for="c-41113528">[-]</label><label class="expand" for="c-41113528">[3 more]</label></div><br/><div class="children"><div class="content">The author didn&#x27;t write a good objection to option 2. Both the ST monad (real mutations) and the variety of State monads (simulated mutations) work fine in practice. What&#x27;s even better is the STM monad, the software transactional memory monad that is not only about mutations but also solves synchronization between threads in a way that&#x27;s intuitive and easy to use. But let&#x27;s stick to the ST monad. Has the author looked at how hash maps and hash sets are implemented in Haskell? It&#x27;s arrays and mutation!<p>&gt; And if you only need mutation locally inside a function, using ST makes your code fundamentally more imperative in a way that really forces you to change your programming style.
This isn&#x27;t great either and doesn&#x27;t exactly help with readability, so the mental overhead is rarely worth it.<p>What?? You are explicitly opting into writing mutation code. Of course that&#x27;s going to change your programming code. It is <i>expected</i> to be different. Readability is increased because it clearly delineates a different coding style. And it&#x27;s not even that different from other monadic code, even when you compare to non-mutating monadic code.<p>Terrible article.</div><br/><div id="41116665" class="c"><input type="checkbox" id="c-41116665" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#41113528">parent</a><span>|</span><a href="#41113771">next</a><span>|</span><label class="collapse" for="c-41116665">[-]</label><label class="expand" for="c-41116665">[1 more]</label></div><br/><div class="children"><div class="content">Also optics like lenses, traversals and prisms make State-based mutation very syntactically convenient.</div><br/></div></div><div id="41113771" class="c"><input type="checkbox" id="c-41113771" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#41113528">parent</a><span>|</span><a href="#41116665">prev</a><span>|</span><a href="#41115845">next</a><span>|</span><label class="collapse" for="c-41113771">[-]</label><label class="expand" for="c-41113771">[1 more]</label></div><br/><div class="children"><div class="content">Author wants to avoid ST Monad to do mutation i think.</div><br/></div></div></div></div><div id="41115845" class="c"><input type="checkbox" id="c-41115845" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#41113528">prev</a><span>|</span><a href="#41114543">next</a><span>|</span><label class="collapse" for="c-41115845">[-]</label><label class="expand" for="c-41115845">[1 more]</label></div><br/><div class="children"><div class="content">Ben Lippmeier&#x27;s Disciplined Disciple Compiler (DDC), for his language later called Discus, was interesting.  It was&#x2F;is an experimental language that managed mutation through an effect typing system.  In the intro to his thesis he talks about it some.<p>Discus language: <a href="http:&#x2F;&#x2F;discus-lang.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;discus-lang.org&#x2F;</a><p>Thesis: <a href="https:&#x2F;&#x2F;benl.ouroborus.net&#x2F;papers&#x2F;2010-impure&#x2F;lippmeier-impure-world.pdf" rel="nofollow">https:&#x2F;&#x2F;benl.ouroborus.net&#x2F;papers&#x2F;2010-impure&#x2F;lippmeier-impu...</a><p>The thesis is the more interesting of those two links IMHO.  The intro is chapter 1 that starts at page 17 of the pdf.  It has one of the better critiques of Haskell that I&#x27;ve seen, and explains why uncontrolled mutation is not the answer.  Reference types ala ML aren&#x27;t the answer either, in his view.</div><br/></div></div><div id="41114543" class="c"><input type="checkbox" id="c-41114543" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#41115845">prev</a><span>|</span><a href="#41113978">next</a><span>|</span><label class="collapse" for="c-41114543">[-]</label><label class="expand" for="c-41114543">[2 more]</label></div><br/><div class="children"><div class="content">How come the CoW method requires runtime reference counting? A lot of the same benefit (but not all) should be available based on static analysis right?<p>Especially if the approach isn&#x27;t really Copy on Write, but Copy only when someone might want to use the old value. Default to trying to mutate in place, if you can prove that is safe.<p>For most locals, that should be rather doable, and it would be a pretty big gain. For function parameters it probably gets hairy though.</div><br/><div id="41116940" class="c"><input type="checkbox" id="c-41116940" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41114543">parent</a><span>|</span><a href="#41113978">next</a><span>|</span><label class="collapse" for="c-41116940">[-]</label><label class="expand" for="c-41116940">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How come the CoW method requires runtime reference counting?<p>Because it doesn’t do copy-on-read, you have to know whether there are references other than yours that can read the data. A single bit “at some time there were at least two references to it” doesn’t suffice, as it would mean you can’t detect when the last reference goes away, so it would leak memory (lots of it)<p>&gt; A lot of the same benefit (but not all) should be available based on static analysis right?<p>That’s an (very important) implementation detail that makes reference counting perform reasonably well. You don’t want increase-decrease cycles in tight loops, for example.</div><br/></div></div></div></div><div id="41113978" class="c"><input type="checkbox" id="c-41113978" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41114543">prev</a><span>|</span><a href="#41114156">next</a><span>|</span><label class="collapse" for="c-41113978">[-]</label><label class="expand" for="c-41113978">[1 more]</label></div><br/><div class="children"><div class="content">I learned programming in the 1980s based on examples from the 1970s and I would see (and write JNI wrappers for) FORTRAN codes in the 1990s that were built around algorithms that could work on data in place with minimal duplication of data structures such as sorts,  FFTs, even when it wasn&#x27;t obvious that they could do so.</div><br/></div></div><div id="41114156" class="c"><input type="checkbox" id="c-41114156" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41113978">prev</a><span>|</span><a href="#41114056">next</a><span>|</span><label class="collapse" for="c-41114156">[-]</label><label class="expand" for="c-41114156">[3 more]</label></div><br/><div class="children"><div class="content">I enjoyed this article. As someone who has written too much haskell and ocaml, and now writes mostly Rust, I am biased but I think this problem is mostly solved by rust. (The author mentions rust in option 3, but I think underappreaciates it.)<p>The author mentions linear types. This is a bit of a pet peeve of mine because, while very useful, linear types are not the concept that many people think they are and they are not implemented in rust (and neither are affine types). What rust implements is referred to as a &quot;uniqueness type&quot;.<p>The difference has to do with how they deal with what linear-types-people call &quot;exponentials&quot;. A linear type, as the article mentions, is the type of a value must be &quot;consumed&quot; exactly once (where consuming means passing it into a function, returning it, or sometimes destructuring it). Of course, in this mad world of ours we sometimes need to consume a value more than once, and indeed a language with only linear types would not be turing-complete. This escape hatch is called an &quot;exponential&quot;, I guess because exponential is kind of like the opposite of linear. A value with an exponential type can be used as often as you want. It is essentially most types in most programming languages.<p>IF a function expects a value with a linear type, can you pass an a value with an exponential type to it? The answer is that you can. Try this in linear haskell if you don&#x27;t believe me. A function taking a value with a linear type just says &quot;I consume this value exactly once, but you can pass me whatever you want&quot;. The restriction is that values with linear types can only be passed to functions that expect linear types. A value with a linear type must be consumed exactly once, so you certainly can&#x27;t pass it to a function that expects a value with an exponential type, because it might use that value twice. In other words, a linear type is a restriction on the callee.<p>Those familiar with rust will notice that this is not how rust works. If a function takes T, and you have &amp;T, you just cannot call that function. (Ignore Clone for now.) However, in the world of linear types, this would be allowed. This makes linear types not useful for the article&#x27;s purposes, although they are still very useful for other things.<p>What rust wants is a constraint not provided by linear types. Where linear types are a restriction on the callee, rust wants to be able to restrict the caller. It wants to be able to restrict the caller in such a way that it can know that there are no other references to a variable that&#x27;s been passed into a function. People call this a &quot;uniqueness type&quot; because you can say &quot;I want this type to be &#x27;unique&#x27;&quot; (where &#x27;unique&#x27; means not-aliased). Honestly this name doesn&#x27;t make a lot of sense, but it makes a little more sense when you think of it in terms of references. If a reference is unique, then it means that no other reference that points to the same object (which is the requirement rust imposes on mutable references). So while a linear type allows you to pass a non-linear variable to a function that expects a linear one, rust doesn&#x27;t allow you to pass a non-unique variable to a function that expects a unique one.<p>And adding this requirement to mutations resolves 90% of the issues that make mutability annoying. Mutability becomes challenging to understand when:<p>1. You have multiple references pointing to the same data in memory.
2. You change the data using one of these references.
3. As a result, the data appears to have changed when accessed through any of the other references.<p>This simply cannot happen when mutability requires values to not be aliased.</div><br/><div id="41114727" class="c"><input type="checkbox" id="c-41114727" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#41114156">parent</a><span>|</span><a href="#41114056">next</a><span>|</span><label class="collapse" for="c-41114727">[-]</label><label class="expand" for="c-41114727">[2 more]</label></div><br/><div class="children"><div class="content">&gt; IF a function expects a value with a linear type, can you pass an a value with an exponential type to it? The answer is that you can. Try this in linear haskell if you don&#x27;t believe me.<p>&gt; Those familiar with rust will notice that this is not how rust works. If a function takes T, and you have &amp;T, you just cannot call that function. (Ignore Clone for now.)<p>I think this is wrong. An exponential type in Rust is a type that implements `Copy`. The analogy in Rust is:<p><pre><code>    fn linear_fun&lt;T&gt;(x: T) {
        &#x2F;&#x2F; ...
    }

    fn main() {
        let foo = 5;
        linear_fun(foo);
        println!(foo);
    }
</code></pre>
And that compiles fine: `foo` is implicitly copied to maintain that `linear_fun` owns its parameter.<p>You can ignore `Clone`, but ignoring `Copy` destroys the premise, because without it Rust has no exponential types at all.<p>EDIT: I agree Rust solves the issue of mutability fairly well. Furthermore, I think practical linear types can be added to a Rust-like type system with Vale&#x27;s (<a href="https:&#x2F;&#x2F;vale.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vale.dev&#x2F;</a>) Higher RAII, where a &quot;linear type&quot; is an affine type that can&#x27;t be implicitly dropped outside of its declaring module.<p>I don&#x27;t know if this is what Vale does, but to enforce &quot;can&#x27;t be implicitly dropped outside of its declaring module&quot; in Rust I would add two changes:<p>- Whenever the compiler tries to insert implicit drop code for a linear type outside of its declaring module, it instead raises an error.<p>- Type parameters get an implicit `Affine` auto-trait, like `Sized`. If a type parameter is `?Affine`, the compiler will refuse to insert implicit drop code. Standard library generic parameters will be `?Affine` wherever possible, e.g. containers like `Vec` and `HashSet` will have `T: ?Affine`, but the methods that could implicitly destroy an element like `HashSet::insert` will have plain `T`.</div><br/><div id="41115950" class="c"><input type="checkbox" id="c-41115950" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41114156">root</a><span>|</span><a href="#41114727">parent</a><span>|</span><a href="#41114056">next</a><span>|</span><label class="collapse" for="c-41115950">[-]</label><label class="expand" for="c-41115950">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can ignore `Clone`, but ignoring `Copy` destroys the premise, because without it Rust has no exponential types at all.<p>it somewhat strains the analogy because rust is implemented in a very elegant way (where references can be used multiple times because they implement Copy), but the analogy to exponentials in rust would be references. Just imagine clone and copy aren’t a thing, and that references have a special case that allow them to be used multiple times while owned values can be used at most once. The thing to note is that if you have an owned value, you can pass a reference to it to as many functions as you want (so long as those functions expect references). But if you have a reference, you can’t pass it to a function that expects an owned value unless the type provides you a way to make a copy.<p>You can imagine starting with this and then building up to rust in a nice way. You first implement passing an owned value as a move. Then first add types that can be used multiple times because they are still valid after a move. (the Copy trait.) And then you make references Copy since they meet that criteria.</div><br/></div></div></div></div></div></div><div id="41114056" class="c"><input type="checkbox" id="c-41114056" checked=""/><div class="controls bullet"><span class="by">jonathanyc</span><span>|</span><a href="#41114156">prev</a><span>|</span><a href="#41114590">next</a><span>|</span><label class="collapse" for="c-41114056">[-]</label><label class="expand" for="c-41114056">[1 more]</label></div><br/><div class="children"><div class="content">I’m not even a big OCaml fan (you can use Algolia on my comment history…), but this article is just factually wrong.<p>&gt; For example, let&#x27;s say you&#x27;re iterating over some structure and collecting your results in a sequence. The most efficient data structure to use here would be a mutable dynamic array and in an imperative language that&#x27;s what pretty much everyone would use.<p>&gt; But if you asked an OCaml programmer, they would almost certainly use a linked list instead.<p>What? One of OCaml’s most notable features as a functional programming language is how it was designed to support mutation (see “the value restriction”, e.g. <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;22507448&#x2F;the-value-restriction" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;22507448&#x2F;the-value-restr...</a>) In my own OCaml programs I used mutation whenever appropriate (my only complaint would be that I wish there were a little more syntactic sugar around e.g. hash table access).<p>I wanted to like this post but it seems like low-effort clickbait.</div><br/></div></div><div id="41114590" class="c"><input type="checkbox" id="c-41114590" checked=""/><div class="controls bullet"><span class="by">narski</span><span>|</span><a href="#41114056">prev</a><span>|</span><label class="collapse" for="c-41114590">[-]</label><label class="expand" for="c-41114590">[4 more]</label></div><br/><div class="children"><div class="content">I recently ran into this issue when trying to memoize a simple numerical sequence in Hoon (yes, <i>that</i> Hoon. I know, I know...).<p>Let&#x27;s use the fibonacci sequence as an example. Let&#x27;s write it the classic, elegant way: f(n) = f(n-1) + f(n-2). Gorgeous. It&#x27;s the sum of the two previous. With the caveat that f(n=0|1) = n. In Python:<p><pre><code>  # fib for basic b&#x27;s
  def fib(n):
    ## Base case
    if n == 0 or n == 1:
      return n
    
    return fib(n-1) + fib(n-2)
</code></pre>
Right off the bat, performance is O(n)=n*2. Every call to f(n-1) will <i>also</i> need to compute f(n-2) anyways! It&#x27;s a mess. But since Python passes arrays and dictionaries as pointers (<i>cough</i>, sorry! I meant to say <i>references</i>) it&#x27;s super easy to memoize:<p><pre><code>  # optimize-pilled memoize-chad version
  def fib(n, saved={}):
    if n in saved:
      return saved[n]
    
    if n == 0 or n == 1:
      saved[n] = n
    else:
      saved[n] = fib(n-1) + fib(n-2)
    
    return saved[n]
</code></pre>
Okay, now our version is nearly as fast as the iterative approach.<p>This is the normal pattern in most languages, memoizing otherwise &quot;pure&quot; functions is easy because you can reference a shared object using references, right? Even with multithreading, we&#x27;re fine, since we have shared memory.<p>Okay, but in Hoon, there are no pointers! Well, there kinda are. The operating system lets you update the &quot;subject&quot; of your Urbit (the context in which your programs run), and you can do this via the filesystem (Clay) or daemons (Gall agents, which have their own state kind of).<p>But to do this within a simple function, not relying on fancy OS features? It&#x27;s totally possible, but a huge pain the Aslan.<p>First, here&#x27;s our bog-standard fib in Hoon:<p><pre><code>  |=  n=@ud
  ?:  (lte n 1)
    n
  %+  add
    $(n (dec n))
  $(n (sub n 2))
</code></pre>
Now, I memoize on the way down, by calculating just f(n-1) and memoizing those values, to acquire f(n-2):<p><pre><code>  :-  %say
  |=  [* [n=@ud ~] [cache=(map @ud @ud) ~]]
  :-  %noun
  ^-  [sum=@ud cache=(map @ud @ud)]
  =&#x2F;  has-n  (~(get by cache) n)
  ?~  has-n
    ?:  (lte n 1)
      [n (~(put by cache) n n)]
    =&#x2F;  minus-1  $(n (dec n))
    =&#x2F;  minus-2 
      =&#x2F;  search  (~(get by cache.minus-1) (sub n 2))
      ?~  search  0
      (need search)
    :-  (add sum.minus-1 minus-2)
    (~(put by cache.minus-1) n (add sum.minus-1 minus-2))
  [(need has-n) cache]
</code></pre>
and that works in the Dojo:<p><pre><code>  &gt; =fib-8 +fib 8
  &gt; sum.fib-8
  21
</code></pre>
but it sure is easier in Python! And I&#x27;m not picking on Hoon here, it&#x27;s just pure functional programming that makes you think this way - which as a hacker is fun, but in practice is kinda inconvenient.<p>I even wonder how much faster I actually made things. Let&#x27;s see:<p><pre><code>  &gt; =old now
  &gt; =res +fib 18
  &gt; sum.res
  2.584
  &gt; (sub now old)
  1.688.849.860.263.936
  :: now with the non-memoized code...
  &gt; =before now
  &gt; +fib 18
  2.584
  &gt; (sub now before)
  1.125.899.906.842.624
</code></pre>
Ha! My super improved memoized code is actually slower! That&#x27;s because computing the copies of the map costs more than just recurring a bunch. This math should change if I try to compute a bigger fib number...<p>Wait. Nevermind. My memoized version is faster. I tested it with the Unix time command. It&#x27;s just that Urbit Dojo has a wierd way of handling time that doesn&#x27;t match my intuition. Oh well, I guess I can learn how that works. But my point is, thinking is hard, and in Python or JS or C I only have to think in terms of values and pointers. And yes, that comes with subtle bugs where you think you have a value but you really have a pointer! But most of the time it&#x27;s pretty easy.<p>Btw sorry for rambling on with this trivial nonsense - I&#x27;m a devops guy so this is probably super boring and basic for all you master hn swe&#x27;s. But it&#x27;s just a tiny example of the constant frustrations I&#x27;ve had trying to do things that would be super simple if I could just grab a reference and modify something in memory, which for better or worse, is how every imperative language implicitly does things.</div><br/><div id="41115371" class="c"><input type="checkbox" id="c-41115371" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41114590">parent</a><span>|</span><a href="#41114756">next</a><span>|</span><label class="collapse" for="c-41115371">[-]</label><label class="expand" for="c-41115371">[2 more]</label></div><br/><div class="children"><div class="content">The standard way to expel stated mutable state us to push it into function parameters and returned values.<p>With Fibonacci numbers, you cab just compute two if them outright:<p><pre><code>  def fib_(n: int) -&gt; tuple[int, int]:
    if n == 0:
      return (1, 1)
    prev, this = fib_(n - 1)
    return (this, this + prev)

  def fib(n): return fib_(n)[0]
</code></pre>
Now there is no mutable state that survives between function calls, the performance is linear.<p>With true memoization though accessing a previously computed value.would be constant time.</div><br/><div id="41115825" class="c"><input type="checkbox" id="c-41115825" checked=""/><div class="controls bullet"><span class="by">narski</span><span>|</span><a href="#41114590">root</a><span>|</span><a href="#41115371">parent</a><span>|</span><a href="#41114756">next</a><span>|</span><label class="collapse" for="c-41115825">[-]</label><label class="expand" for="c-41115825">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The standard way to expel stated mutable state us to push it into function parameters and returned values.<p>This is precisely what I did in my Hoon solution :) However, I wasn&#x27;t aware that this approach is the standard way, and I&#x27;m glad to have learned that! Thanks</div><br/></div></div></div></div><div id="41114756" class="c"><input type="checkbox" id="c-41114756" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#41114590">parent</a><span>|</span><a href="#41115371">prev</a><span>|</span><label class="collapse" for="c-41114756">[-]</label><label class="expand" for="c-41114756">[1 more]</label></div><br/><div class="children"><div class="content">Note to self: never code Hoon</div><br/></div></div></div></div></div></div></div></div></div></body></html>