<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716022854490" as="style"/><link rel="stylesheet" href="styles.css?v=1716022854490"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dolphin-emu.org/blog/2017/07/30/ubershaders/">Ubershaders: A Ridiculous Solution to an Impossible Problem (2017)</a> <span class="domain">(<a href="https://dolphin-emu.org">dolphin-emu.org</a>)</span></div><div class="subtext"><span>Grognak</span> | <span>44 comments</span></div><br/><div><div id="40394442" class="c"><input type="checkbox" id="c-40394442" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40395652">next</a><span>|</span><label class="collapse" for="c-40394442">[-]</label><label class="expand" for="c-40394442">[17 more]</label></div><br/><div class="children"><div class="content">Has it really been 9 years since I started working on Ubershaders?<p>I&#x27;m a little surprised no better solution has come along. Vulkan didn&#x27;t even exist back then (and DirectX 12 had only just released) but instead of making things better, it digs it&#x27;s feet even deeper into the assumption that all shaders will be known ahead of time (resulting in long &quot;shader recompilation&quot; dialogs on startup on many games).<p>I&#x27;ve been tempted to build my own fast shader compiler into Dolphin for many common GPU architectures. Hell, it wouldn&#x27;t even be a proper compiler, more of a templated emitter as all shaders fit a pattern. Register allocation and scheduling could all be pre-calculated.<p>But that would be even more insane than ubershaders, as it would be one backend per gpu arch. And some drivers (like Nvidia) don&#x27;t provide a way to inject pre-compiled shader binaries.<p>On the positive side, ubershaders do solve the problem, and modern GPU drivers do a much better job at accepting ubershaders than they did 9 years ago. Though that&#x27;s primarily because (as far as I&#x27;m aware) examples of Dolphin&#x27;s ubershader have made their way into every single shader compiler test suite.</div><br/><div id="40395067" class="c"><input type="checkbox" id="c-40395067" checked=""/><div class="controls bullet"><span class="by">Miksel12</span><span>|</span><a href="#40394442">parent</a><span>|</span><a href="#40395632">next</a><span>|</span><label class="collapse" for="c-40395067">[-]</label><label class="expand" for="c-40395067">[4 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t you think intermediate representation like SPIR-V would suffice in mostly eliminating stutter? Yuzu used that and shader stutter seemed to be minimal and I can image that the shaders generated by Yuzu are much more complex than Dolphin.</div><br/><div id="40395200" class="c"><input type="checkbox" id="c-40395200" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395067">parent</a><span>|</span><a href="#40395632">next</a><span>|</span><label class="collapse" for="c-40395200">[-]</label><label class="expand" for="c-40395200">[3 more]</label></div><br/><div class="children"><div class="content">The only step that SPIR-V replaces is parsing the GLSL to an AST tree, and that&#x27;s only a small part of the total time to compile a shader. Usually the bottleneck is Register allocation or scheduling.<p>Back when Vulkan was developed, there were a bunch of OpenGL drivers out there which had random AST parsing bugs (Dolphin even has a bunch of workarounds for them); So a large chunk of the motivation for SPIR-V was avoiding the need for every driver to implement their own GLSL parser and the associated bugs.<p>The problem for Dolphin is not the complexity of the shader, but the quantity.<p>Shaders in modern games are usually written manually (or authored in a shader node editor by an artist), so it&#x27;s rare for a game to have more than a few thousand total. Better games might only have a few dozen for the entire game.<p>But because gamecube&#x2F;Wii games configure the TEV pixel pipeline though a dynamic API, some games use that API in a pattern where Dolphin can find itself generating hundreds of shaders per second. Some games even manage to generate new shaders continually as you play, because they append junk state to their pixel pixeline state which dolphin doesn&#x27;t detect as a duplicate.</div><br/><div id="40395380" class="c"><input type="checkbox" id="c-40395380" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395200">parent</a><span>|</span><a href="#40395632">next</a><span>|</span><label class="collapse" for="c-40395380">[-]</label><label class="expand" for="c-40395380">[2 more]</label></div><br/><div class="children"><div class="content">Shaving off the frontend costs is not going to be <i>nothing</i>. I don&#x27;t know if Dolphin is still using FXC&#x2F;D3DCompile or if they&#x27;ve switched to DXC, but FXC is infamously slow, even for very simple shaders. Dolphin&#x27;s shaders are medium-complexity IIRC, so I&#x27;d expect removing the frontend to be a decent win.<p>The driver PSO compilers aren&#x27;t <i>amazing</i> but they&#x27;re also not terrible. Most games do some form of hash-n-cache for PSO compilation and while stutters are still an issue, it&#x27;s not the worst in the world. With the frontend gone, I&#x27;d expect ~50 shaders per second to be roughly stutter-free.<p>Being smarter about specialization is probably a good idea -- having a blend between &quot;GPU interpreter&quot; and &quot;full specialized pipeline&quot; is where I think you should head. Several of the weirder TEV features could probably be moved to branching on dynamic buffer contents.<p>Not to mention using newer features like bindless to merge draw calls. I always wanted to do that but got too busy before I stopped working on Dolphin :)</div><br/><div id="40395824" class="c"><input type="checkbox" id="c-40395824" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395380">parent</a><span>|</span><a href="#40395632">next</a><span>|</span><label class="collapse" for="c-40395824">[-]</label><label class="expand" for="c-40395824">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; so I&#x27;d expect removing the frontend to be a decent win</i><p>I did some testing before working on ubershaders, and my modified build which cached the bytecode output of FXC&#x2F;D3DCompile (whatever dolphin was using at the time) didn&#x27;t reduce the stuttering by enough to be worth the effort of optimising the frontend.<p>My conclusion was that it&#x27;s simply wasn&#x27;t worth any effort to optimise for slightly smaller stutters, as they were still very perceivable to users. And Hybrid Ubershaders can hide any compile delays without any issue.<p>And this testing was with FXC&#x2F;D3DCompile which does a bunch of optimisations.  The fact that SPIR-V comes in (potentially) unoptimised means any vulkan compiler has to send it though all optimisation passes.   
Though I have been very tempted to do dead code removal before submitting the shaders, partly to make the shaders more readable to humans and partly to reduce the amount of code going though the various compiler passes.<p><i>&gt; Being smarter about specialization is probably a good idea -- having a blend between &quot;GPU interpreter&quot; and &quot;full specialized pipeline&quot; is where I think you should head.</i><p>Yeah, that was always next on the list. Start with just ubershaders and then incrementally specialise on a background thread for the correct balance of shaders.<p>Dolphin&#x27;s current specialised shaders are no-where near fully specialized. Need to go further by baking some of the constants and lookup textures into the shader.</div><br/></div></div></div></div></div></div></div></div><div id="40395632" class="c"><input type="checkbox" id="c-40395632" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#40394442">parent</a><span>|</span><a href="#40395067">prev</a><span>|</span><a href="#40395652">next</a><span>|</span><label class="collapse" for="c-40395632">[-]</label><label class="expand" for="c-40395632">[12 more]</label></div><br/><div class="children"><div class="content">I still don’t understand why you didn’t use the precompiled shaders packed with the games… you’re emulating the GameCube or Wii GPU, and it’s never going to change, and the games provide precompiled shaders.</div><br/><div id="40395856" class="c"><input type="checkbox" id="c-40395856" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395632">parent</a><span>|</span><a href="#40395714">next</a><span>|</span><label class="collapse" for="c-40395856">[-]</label><label class="expand" for="c-40395856">[3 more]</label></div><br/><div class="children"><div class="content">First, GameCube&#x2F;Wii API actually generates the &quot;shaders&quot; at runtime, so there is simply no way to know which vertex&#x2F;pixel pipeline states the game needs short of playing though the whole game, looking at every single bit of level geometry.<p>Many games actually dynamically generate new &quot;shaders&quot; on the fly, based on which lights are near an object, and in which order.<p>Second we can&#x27;t use those vertex&#x2F;pixel pipeline states directly on modern GPU, they need to be translated into modern shaders, and then compiled by the driver for your graphics card. It&#x27;s actually that compile step which causes the stuttering, dolphin&#x27;s translation is plenty fast enough.<p>The combination of these two facts means Dolphin can&#x27;t depend on any pre-computation at all.</div><br/><div id="40396161" class="c"><input type="checkbox" id="c-40396161" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395856">parent</a><span>|</span><a href="#40395714">next</a><span>|</span><label class="collapse" for="c-40396161">[-]</label><label class="expand" for="c-40396161">[2 more]</label></div><br/><div class="children"><div class="content">I don’t get it (this is not your fault, it’s mine) but I believe you.</div><br/><div id="40397238" class="c"><input type="checkbox" id="c-40397238" checked=""/><div class="controls bullet"><span class="by">rkachowski</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40396161">parent</a><span>|</span><a href="#40395714">next</a><span>|</span><label class="collapse" for="c-40397238">[-]</label><label class="expand" for="c-40397238">[1 more]</label></div><br/><div class="children"><div class="content">if I understand correctly<p>1. &quot;shader&quot; is just a metaphor, the actual code running on the gamecube gpu is a custom pipeline that has a dynamic structure and is updated aggressively throughout the lifetime of the app - there is no static &quot;shader&quot; program to run on the host GPU.<p>2. The architectures of the gamecube and modern GPUs are so distinct as to require an intricate translation layer in order to map gamecube rendering operations to first class shader operations on a modern GPU. This very process causes the stuttering that starts the issue.</div><br/></div></div></div></div></div></div><div id="40395714" class="c"><input type="checkbox" id="c-40395714" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395632">parent</a><span>|</span><a href="#40395856">prev</a><span>|</span><a href="#40395688">next</a><span>|</span><label class="collapse" for="c-40395714">[-]</label><label class="expand" for="c-40395714">[3 more]</label></div><br/><div class="children"><div class="content">Wait, I hought that&#x27;s what the ubershaders are. What you say is what I kept thinking for much of the article - &quot;just&quot; emulate the GPU, no compiler needed. And then they did.</div><br/><div id="40395757" class="c"><input type="checkbox" id="c-40395757" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395714">parent</a><span>|</span><a href="#40395688">next</a><span>|</span><label class="collapse" for="c-40395757">[-]</label><label class="expand" for="c-40395757">[2 more]</label></div><br/><div class="children"><div class="content">Maybe, lol, there were a lot of terms in that article that I didn’t understand well enough to claim I understood the article in toto.</div><br/><div id="40396860" class="c"><input type="checkbox" id="c-40396860" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395757">parent</a><span>|</span><a href="#40395688">next</a><span>|</span><label class="collapse" for="c-40396860">[-]</label><label class="expand" for="c-40396860">[1 more]</label></div><br/><div class="children"><div class="content">One thing to remember is these older consoles don&#x27;t have the same concept of a &quot;shader&quot; as we do today.<p>Go back far enough and you&#x27;ll find the industry trying to settle on quads or triangles for rendering (and we all knew who won)<p>The games were given basically an immediate mode API into the graphics card and they could do whatever they wanted, whenever they wanted, without warning.<p>The stutter happened when they were translating the API mentioned above into modern GPU shaders.<p>When it was on the CPU - They had to determine the effect, generate and compile the modern shaders, and upload that to the GPU, sometimes hundreds of times a second. Then the GPU would take over and display.<p>Uber shaders took that entire pipeline and moved it into the GPU.<p>This was low level emulation, just still hitting limits of modern CPUs.</div><br/></div></div></div></div></div></div><div id="40395688" class="c"><input type="checkbox" id="c-40395688" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395632">parent</a><span>|</span><a href="#40395714">prev</a><span>|</span><a href="#40395652">next</a><span>|</span><label class="collapse" for="c-40395688">[-]</label><label class="expand" for="c-40395688">[5 more]</label></div><br/><div class="children"><div class="content">They&#x27;re precompiled for the console GPU architecture, not the PC architecture, so they can&#x27;t be used directly and still need to be emulated - I think those precompiled shaders are the input to the ubershader.</div><br/><div id="40395731" class="c"><input type="checkbox" id="c-40395731" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395688">parent</a><span>|</span><a href="#40395652">next</a><span>|</span><label class="collapse" for="c-40395731">[-]</label><label class="expand" for="c-40395731">[4 more]</label></div><br/><div class="children"><div class="content">The GAMES THEMSELVES are precompiled for the PowerPC architecture, not the PC architecture, though.  That didn’t stop anyone from creating Dolphin.<p>GPUs (I’m told) have far fewer instructions to emulate than a CPU, so I’d think that low level emulation of the Flipper shaders would be no trouble.  Can’t translate or transpile them to PC GPUs though because those instruction sets are somewhat secret, I think.<p>I know nothing about this stuff but I am a developer so perhaps I know enough to ask the most stupid questions possible.<p>It’s gotta be a performance thing, why they didn’t emulate Flipper at a low enough level to use the precompiled shaders directly.</div><br/><div id="40396517" class="c"><input type="checkbox" id="c-40396517" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395731">parent</a><span>|</span><a href="#40396155">next</a><span>|</span><label class="collapse" for="c-40396517">[-]</label><label class="expand" for="c-40396517">[2 more]</label></div><br/><div class="children"><div class="content">&gt; because those instruction sets are somewhat secret, I think<p>The GPU ISAs are known (e.g. the PTX compiler for NVidia is open source and has a backend in LLVM). The main problem is that the GPU ISA changes with every GPU hardware generation and manufacturer, so if you want to support Nvidia 3xxx + 4xxx + AMD VLIW + AMD GCN + ... you have to use the common demoninator GLSL&#x2F;HLSL&#x2F;SPIR-V&#x2F;whatever.<p>&gt; why they didn’t emulate Flipper at a low enough level to use the precompiled shaders directly.<p>They did. Originally the GPU emulator was done in the CPU, and in 2017, the GPU emulator itself was moved into a shader (&quot;ubershader&quot;).<p>The console game itself does not include shaders in text format like many PC games do.</div><br/><div id="40397101" class="c"><input type="checkbox" id="c-40397101" checked=""/><div class="controls bullet"><span class="by">mandarax8</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40396517">parent</a><span>|</span><a href="#40396155">next</a><span>|</span><label class="collapse" for="c-40397101">[-]</label><label class="expand" for="c-40397101">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The GPU ISAs are known (e.g. the PTX compiler for NVidia is open source and has a backend in LLVM)<p>PTX is only and IR afaik, kinda like SPIRV. It also goes through another compiler in the driver so doesn&#x27;t really help here</div><br/></div></div></div></div><div id="40396155" class="c"><input type="checkbox" id="c-40396155" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40394442">root</a><span>|</span><a href="#40395731">parent</a><span>|</span><a href="#40396517">prev</a><span>|</span><a href="#40395652">next</a><span>|</span><label class="collapse" for="c-40396155">[-]</label><label class="expand" for="c-40396155">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that’s exactly the point though. This is the same question as why you can’t emulate a game by precompiling its code, and this doesn’t work because that information isn’t available until you try to run the game. That’s why Dolphin has an interpreter&#x2F;JIT.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40395652" class="c"><input type="checkbox" id="c-40395652" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#40394442">prev</a><span>|</span><a href="#40394068">next</a><span>|</span><label class="collapse" for="c-40395652">[-]</label><label class="expand" for="c-40395652">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting to see the parallels between this and an engine for a dynamic programming language. The one I&#x27;m most familiar with is JavaScript.<p>When you first need to run something, you run it on the interpreter (JS) &#x2F; ubershader (Dolphin). But once you know it&#x27;s going to be run repeatedly (rarely for JS, almost always for Dolphin), you kick off an async compilation to produce JIT code (JS) &#x2F; a specialized shader (Dolphin). You continue running in the expensive mode (interpreter &#x2F; ubershader) until the compilation is complete, then you switch over seamlessly.</div><br/></div></div><div id="40394068" class="c"><input type="checkbox" id="c-40394068" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40395652">prev</a><span>|</span><a href="#40397024">next</a><span>|</span><label class="collapse" for="c-40394068">[-]</label><label class="expand" for="c-40394068">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time:<p><i>Ubershaders: A Ridiculous Solution to an Impossible Problem</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14884992">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14884992</a> - July 2017 (88 comments)</div><br/></div></div><div id="40397024" class="c"><input type="checkbox" id="c-40397024" checked=""/><div class="controls bullet"><span class="by">doophus</span><span>|</span><a href="#40394068">prev</a><span>|</span><a href="#40394330">next</a><span>|</span><label class="collapse" for="c-40397024">[-]</label><label class="expand" for="c-40397024">[3 more]</label></div><br/><div class="children"><div class="content">What was the missing piece for &quot;shader sharing&quot;?<p>Would it be possible to build a web-hosted database of encountered shader configs against a game id, and have Dolphin fetch that list when a game launches and start doing async compilation?<p>When Dolphin encounters a new shader that wasn&#x27;t in the db, it phones home to request it to be added it to the list.<p>I feel an automated sharing solution would build up coverage pretty quickly, and finding a stutter would eventually be considered an achievement - &quot;no-one&#x27;s been here before!&quot;</div><br/><div id="40397119" class="c"><input type="checkbox" id="c-40397119" checked=""/><div class="controls bullet"><span class="by">mandarax8</span><span>|</span><a href="#40397024">parent</a><span>|</span><a href="#40394330">next</a><span>|</span><label class="collapse" for="c-40397119">[-]</label><label class="expand" for="c-40397119">[2 more]</label></div><br/><div class="children"><div class="content">Every shader depends on both the driver version and the model of your GPU itself. Which means a lot of shaders. I think Valve had a version of it though but not without issues (GBs of shaders to be downloaded)</div><br/><div id="40397296" class="c"><input type="checkbox" id="c-40397296" checked=""/><div class="controls bullet"><span class="by">91edec</span><span>|</span><a href="#40397024">root</a><span>|</span><a href="#40397119">parent</a><span>|</span><a href="#40394330">next</a><span>|</span><label class="collapse" for="c-40397296">[-]</label><label class="expand" for="c-40397296">[1 more]</label></div><br/><div class="children"><div class="content">The Steamdeck does this thats why it doesn&#x27;t suffer from stutters.<p>For normal PC&#x27;s, realistically Valve&#x2F;Steam are the only people who could solve or implement this for PC games as they have the tech and platform to distribute it all. Even with all that its a crazy task to try and solve due to all of the variations and new patches for games that require the shaders to be recompiled again.</div><br/></div></div></div></div></div></div><div id="40394330" class="c"><input type="checkbox" id="c-40394330" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#40397024">prev</a><span>|</span><a href="#40395468">next</a><span>|</span><label class="collapse" for="c-40394330">[-]</label><label class="expand" for="c-40394330">[7 more]</label></div><br/><div class="children"><div class="content">The pixel shading of the GameCube were slower than that of the OG Xbox. But, it was quite a bit more flexible. Specifically, the GameCube could load a couple textures, do a bit of math, then use that math to load some more texels. The Xbox could only load textures as the starting instructions before doing math and tried to make up for that with a few &quot;do very specific math and load textures in a single instruction&quot; ops.<p>But, still... Both GPUs were pretty well suited for this ubershader approach because they had a small, fixed limit on the number of instructions they could run. And, very strictly defined functionality for each instruction. They weren&#x27;t really &quot;shaders&quot; as much as highly flexible fixed function stages that you could reasonably wedge in a text shader compiler as a front end and only get a moderate to high amount of complaints about how strict and limited the rules were for the assembly. I recall that both shading units could reasonably be fully specified as C structs that you manually packed into the GPU registers instead of using a shader compiler at all.</div><br/><div id="40394584" class="c"><input type="checkbox" id="c-40394584" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40394330">parent</a><span>|</span><a href="#40394523">next</a><span>|</span><label class="collapse" for="c-40394584">[-]</label><label class="expand" for="c-40394584">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; The Xbox could only load textures as the starting instructions before doing math and tried to make up for that with a few &quot;do very specific math and load textures in a single instruction&quot; ops.</i><p>If you look closely, the TEV actually shares the same limitation, it&#x27;s just that the traditional representation interleaves the texture fetch and math instructions (Because the 3rd texture fetch &quot;instruction&quot; always feeds into the 3rd math &quot;instruction&quot;, for example). There are two independent execution units, separated by a fifo and no way to backfeed from the math back to texture fetch.<p>The two GPUs are roughly equivalent. The only reason the OG Xbox is consider to &quot;have pixel shaders&quot; is that they were exposed with a pixel shader API, while TEV was only ever exposed with a &quot;texture environment&quot; based API. They are both clearly register combiners, with no control flow, but they sit right in the middle as GPUs were transitioning from register combiners to &quot;proper&quot; pixel shaders. The team that designed GameCube&#x27;s GPU went on to develop the first DirectX 9 GPU.<p>I&#x27;m pretty sure the Xbox&#x27;s pixel pipeline is slightly more capable as TEV doesn&#x27;t have the Dot3 instruction (and it also has programmable vertex shaders). But developers all abandoned the xbox in 2005. TEV has a much better reputation for being flexible because TEV was used in the Wii all the way to ~2013. And graphics developers who were exposed to much better shaders on the Xbox, PS3 and PC got very good at back porting those modern techniques to the more limited Wii. More than one studio created un-offical shader compilers for the Wii, so they could share the same shaders across PS3&#x2F;Xbox&#x2F;Wii&#x2F;PC.<p><i>&gt; I recall that both shading units could reasonably be fully specified as C structs that you manually packed into the GPU registers instead of using a shader compiler at all.</i><p>Yeah, not that they ever exposed that API.<p>The GameCube had great support for recording display lists, so you could record a display list while you called the API commands to configure TEV and then call that display list later to quickly load the &quot;shader&quot;.   
Some games even saved those display lists to disc (or maybe generated them from scratch with external tools) as a form of offline shader compilation.</div><br/><div id="40395773" class="c"><input type="checkbox" id="c-40395773" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#40394330">root</a><span>|</span><a href="#40394584">parent</a><span>|</span><a href="#40395310">next</a><span>|</span><label class="collapse" for="c-40395773">[-]</label><label class="expand" for="c-40395773">[1 more]</label></div><br/><div class="children"><div class="content">You could definitely define pixel shaders on the Xbox using a combiner type struct. See the D3DPIXELSHADERDEF struct in the docs, from memory the equivalent of one of the NV register combiner extensions from OpenGL with additional access to a secret extra stage ordinarily reserved for some fixed function pipeeline stuff.</div><br/></div></div></div></div><div id="40394523" class="c"><input type="checkbox" id="c-40394523" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40394330">parent</a><span>|</span><a href="#40394584">prev</a><span>|</span><a href="#40395468">next</a><span>|</span><label class="collapse" for="c-40394523">[-]</label><label class="expand" for="c-40394523">[3 more]</label></div><br/><div class="children"><div class="content">ISTR the GC pipeline being fixed-function while the Xbox had a full-fat GPU (GeForce 3 variant) -- one of the reasons why the Xbox absolutely smoked the other sixth-gen consoles in terms of performance. Was I wrong?</div><br/><div id="40394621" class="c"><input type="checkbox" id="c-40394621" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40394330">root</a><span>|</span><a href="#40394523">parent</a><span>|</span><a href="#40394627">next</a><span>|</span><label class="collapse" for="c-40394621">[-]</label><label class="expand" for="c-40394621">[1 more]</label></div><br/><div class="children"><div class="content">Extremely common misconception (even among developers on those platforms)<p>In reality, the OG Xbox and GameCube GPUs are almost identical in pixel shading capabilities (Though the gamecube&#x27;s vertex shading pipeline is legitimately fixed function, but very flexible).<p>Despite their roughly equal capabilities, they were exposed with very different APIs. The xbox used the new-fangled &quot;Shader&quot; style API that Microsoft was introducing to the industry at the time, while TEV used a very extended version of the older &quot;Texture Environment&quot; style API that was introduced with DirectX 7 and OpenGL 1.3.<p>----------------<p><i>Edit: Actually, it might be better to explain from the other end:</i><p>In a true fixed function GPU like the Playstation 2 and Dreamcast (or OG Playstation... but not the N64, which is a two stage register combiner) the pixel pipeline is limited to just one basic equation. A single texture is sampled, and that sample is multiplied with a single color interpolated from the vertex colors (which were usually derived from lights). The flexibility is of the equation was limited to replacing each input with a fixed value, and then enabling a few optional post-processing stages like depth based fog, alpha cutout and&#x2F;or blending with a few fixed blend equations.<p>But the results from that single texel * vertex_color equation are limiting. A common technique to produce better results on such GPUs was &quot;multi-texturing&quot;. Graphics developers of the era would render the same triangles two or more times, but with different textures and vertex colours, blending the result into the frame buffer. This was commonly used to achieve the illusion of more detailed textures, or texture based light-maps. Or the reflections on cars in racing games.<p>But blending in the frame buffer is expensive as it wastes a lot of memory bandwidth. The PS2 is hyper-optimised for this approach, it has the VUs which can quickly generate multiple draws of the same geometry, and a fast, embedded dram with enough read&#x2F;write ports that it can do blending &quot;for free&quot;. But in the PC world, GPUs started adding features to combine these multiple draw call together and blend the result before writing to the frame buffer. The Voodoo 2 and Nvidia TnT (Twin Texel) from 1998 are examples of GPUs that supported this multi-pass texturing.<p>DirectX and OpenGL provided the &quot;texture environment&quot; APIs that automatically used these new single-pass multi-texturing features when available, or would fall back to multi-pass rendering on older GPUs.<p>But the actual hardware was often more flexible than what DirectX&#x2F;OpenGL exposed, though vendors supplied &quot;Register Combiner&quot; OpenGL extensions that exposed the full functionality (This is why John Carmack used OpenGL, so he could create optimised per-gpu render paths for each GPU). And these Register Combiners could be &quot;programmed&quot; to produce pixel equations that were way more advanced that what could be achieved with multi-pass rendering, as they could pass more than one value between stages. And they started supported 4 or 8 textures plus enough math stages to combine the textures.<p>Microsoft gave up trying to expose the full capabilities of these register combiners though the older Texture Environment APIs and introduced Pixel Shaders with DirectX 8, but they were just providing a new API for the features GPUs already had. The register combine stages were simply renamed to &quot;instructions&quot;.<p>The Xbox is a register combiner with 4 texture fetch stages and 8 combiner stages and Gamecube has 16 combiner stages and 8 texture fetches (well, it technically supports 16 texture fetches, but there are only 8 sets of UV coords)</div><br/></div></div><div id="40394627" class="c"><input type="checkbox" id="c-40394627" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#40394330">root</a><span>|</span><a href="#40394523">parent</a><span>|</span><a href="#40394621">prev</a><span>|</span><a href="#40395468">next</a><span>|</span><label class="collapse" for="c-40394627">[-]</label><label class="expand" for="c-40394627">[1 more]</label></div><br/><div class="children"><div class="content">The Xbox had fairly capable vertex shaders. But, phire&#x27;s comment does a better job of explaining the pixel capabilities both machines than I did.</div><br/></div></div></div></div></div></div><div id="40395468" class="c"><input type="checkbox" id="c-40395468" checked=""/><div class="controls bullet"><span class="by">conorpo</span><span>|</span><a href="#40394330">prev</a><span>|</span><a href="#40394296">next</a><span>|</span><label class="collapse" for="c-40395468">[-]</label><label class="expand" for="c-40395468">[13 more]</label></div><br/><div class="children"><div class="content">Does anyone know why this isn&#x27;t an issue for modern games on PC? I assume it&#x27;s because more uniforms are used, and the amount of shaders that actually need to be compiled at runtime is minimized, not to mention that the Graphics API is optimized to compile the shaders in the format they are provided. So is the issue with Dolphin that GameCube games would compile new shaders for lots of different configurations of effects &#x2F; stages? Would some sort of preprocessor that converts shader compilations to some mini-ubershader with uniforms that can handle a lot of the different effects be feasible? And then depending on how many completely different shaders there are you would have many different mini-ubershaders?</div><br/><div id="40396806" class="c"><input type="checkbox" id="c-40396806" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#40395468">parent</a><span>|</span><a href="#40395575">next</a><span>|</span><label class="collapse" for="c-40396806">[-]</label><label class="expand" for="c-40396806">[1 more]</label></div><br/><div class="children"><div class="content">The programmer of a modern PC game knows that they will be using shaders, and can arrange for them all to be compiled and sent to the GPU during a loading screen. That eliminates the lag, because there is no delay when choosing which shader to use for the next triangle. On the other hand it makes the loading screen take longer.<p>Meanwhile the programmer of a console game, not using shaders, could set GPU registers to any configuration they wanted just before rendering the next triangle. You have to actually play the game to find out what configurations it programs into the GPU, because those configurations are not neatly organized into a set of discrete shaders. Even then there is no guarantee that you found all possible configurations used by the game. The videos in the article provide a good example: the player fires a gun with luminous bullets, so on that frame the walls and floors need to be rendered with an extra light source. That requires reconfiguring the GPU to take that light source into account, then changing the configuration to render the weapon itself, then changing it again to render the HUD, and so on.<p>Now imagine that you go to a place on a different level where the walls are not shiny, and it doesn&#x27;t bother to render the walls with the extra light source. Or it renders them with extra vertex lighting but not extra specular lighting. Now combine that with every type of wall and floor in the game; they might all need a unique shader to be lit correctly by that one gun. To find all possible GPU configurations you need to fire that gun, and every other, near every single different type of wall and floor texture used in the game. And there are a dozen different guns.<p>And then you need to do it all again while wearing the night–vision goggles, because that causes everything to be rendered with a different configuration yet again.<p>Every one of those unique combinations needs to be made into a shader, and there’s just no way to be sure that you have actually collected all of them. Or you can write a single Ubershader that can, by using branches, loops, and other advanced tricks, emulate the entire capabilities of the emulated GPU. Then you can program the Ubershader by sending all of the emulated GPUs register values as uniforms.</div><br/></div></div><div id="40395575" class="c"><input type="checkbox" id="c-40395575" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#40395468">parent</a><span>|</span><a href="#40396806">prev</a><span>|</span><a href="#40395882">next</a><span>|</span><label class="collapse" for="c-40395575">[-]</label><label class="expand" for="c-40395575">[2 more]</label></div><br/><div class="children"><div class="content">It is an issue with some modern games (I recently played a title that had a &quot;Preparing Shaders...&quot; loading screen); the main difference is that those games know the full set of what they need to do and can precompile most of them up-front, while an emulator like Dolphin needs to handle whatever the game throws it on the fly.<p>Also, games might know what shaders it can skip and what it can&#x27;t, but Dolphin can&#x27;t skip shaders if they aren&#x27;t compiled, because it doesn&#x27;t know what the game will do with the render (e.g. Miis work by rendering their heads once into a texture, and then reusing that. If it skips the render because the shader isn&#x27;t ready, the Mii will just be missing forever).<p>Some emulators handle this by sharing &quot;shader caches&quot; between users so that they have a better idea of what the game will use; Dolphin opted for a different solution here.</div><br/><div id="40396210" class="c"><input type="checkbox" id="c-40396210" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40395575">parent</a><span>|</span><a href="#40395882">next</a><span>|</span><label class="collapse" for="c-40396210">[-]</label><label class="expand" for="c-40396210">[1 more]</label></div><br/><div class="children"><div class="content">It’s not a problem for the PS&#x2F;Xbox&#x2F;Switch. They have known hardware and it can all be recompiled.<p>But from what I’ve heard it’s often still an issue on PCs (I’m a Mac guy). I’ve seen videos of shader compilation stutters, even in games with a precompilation step that’s supposed to avoid that.<p>Digital Foundry has covered this many times. The link in a sibling comment to them on Eurogamer is a great place to start.</div><br/></div></div></div></div><div id="40395882" class="c"><input type="checkbox" id="c-40395882" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#40395468">parent</a><span>|</span><a href="#40395575">prev</a><span>|</span><a href="#40395769">next</a><span>|</span><label class="collapse" for="c-40395882">[-]</label><label class="expand" for="c-40395882">[1 more]</label></div><br/><div class="children"><div class="content">It is an issue for some modern big titles on PC. Trying to find some links that have somewhat general overview ...<p><a href="https:&#x2F;&#x2F;twistedvoxel.com&#x2F;unreal-engine-5-pc-stuttering-issues&#x2F;" rel="nofollow">https:&#x2F;&#x2F;twistedvoxel.com&#x2F;unreal-engine-5-pc-stuttering-issue...</a><p><a href="https:&#x2F;&#x2F;www.eurogamer.net&#x2F;digitalfoundry-2022-df-direct-weekly-talks-state-of-play-and-horizon-forbidden-west-post-patch-image-quality" rel="nofollow">https:&#x2F;&#x2F;www.eurogamer.net&#x2F;digitalfoundry-2022-df-direct-week...</a></div><br/></div></div><div id="40395769" class="c"><input type="checkbox" id="c-40395769" checked=""/><div class="controls bullet"><span class="by">ruined</span><span>|</span><a href="#40395468">parent</a><span>|</span><a href="#40395882">prev</a><span>|</span><a href="#40395498">next</a><span>|</span><label class="collapse" for="c-40395769">[-]</label><label class="expand" for="c-40395769">[4 more]</label></div><br/><div class="children"><div class="content">gcn games never anticipated shader compilation time because it didn&#x27;t exist.<p>shaders weren&#x27;t a thing when the gcn released. it may be arguable, but nobody even used the word at the time. shader compilation time <i>is</i> an issue for modern games on the PC, and because of this, developers anticipate and work around it.<p>on the gcn, specialized fixed-function pipelines were available, and could be composed by some limited configuration (literally, 24 instructions). you may think of this as a sort of proto-shader, but significantly, the fixed-function pipelines embody quite a lot of behavior <i>in specialized and limited hardware</i> that is now typically achieved <i>in software on more versatile hardware</i>.<p>so, to replicate that specialized hardware, modern graphics hardware (which exposes its greater capability as simple computational primitives) must compile a shader program and run it. but on gcn, the tiny configuration of static hardware loads near-instantly.</div><br/><div id="40396837" class="c"><input type="checkbox" id="c-40396837" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40395769">parent</a><span>|</span><a href="#40396886">next</a><span>|</span><label class="collapse" for="c-40396837">[-]</label><label class="expand" for="c-40396837">[1 more]</label></div><br/><div class="children"><div class="content">Shaders as concept exists since 1980&#x27;s,<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;TMS34010" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;TMS34010</a><p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;RenderMan_Shading_Language" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;RenderMan_Shading_Language</a><p>Just two examples, SIGGRAPH has plenty of paper on the subject.</div><br/></div></div><div id="40396886" class="c"><input type="checkbox" id="c-40396886" checked=""/><div class="controls bullet"><span class="by">OCASMv2</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40395769">parent</a><span>|</span><a href="#40396837">prev</a><span>|</span><a href="#40395498">next</a><span>|</span><label class="collapse" for="c-40396886">[-]</label><label class="expand" for="c-40396886">[2 more]</label></div><br/><div class="children"><div class="content">A 2002 postmortem on the tech of Rogue Leader, a Gamecube launch title, already using the term &quot;shaders&quot;:<p><a href="https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;programming&#x2F;shader-integration-merging-shading-technologies-on-the-nintendo-gamecube" rel="nofollow">https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;programming&#x2F;shader-integration...</a></div><br/><div id="40397134" class="c"><input type="checkbox" id="c-40397134" checked=""/><div class="controls bullet"><span class="by">shzhdbi09gv8ioi</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40396886">parent</a><span>|</span><a href="#40395498">next</a><span>|</span><label class="collapse" for="c-40397134">[-]</label><label class="expand" for="c-40397134">[1 more]</label></div><br/><div class="children"><div class="content">The first video card with a programmable pixel shader was the Nvidia GeForce 3 (NV20), released in 2001. [1]<p>1: <a href="https:&#x2F;&#x2F;www.techpowerup.com&#x2F;gpu-specs&#x2F;nvidia-nv20.g644" rel="nofollow">https:&#x2F;&#x2F;www.techpowerup.com&#x2F;gpu-specs&#x2F;nvidia-nv20.g644</a></div><br/></div></div></div></div></div></div><div id="40395498" class="c"><input type="checkbox" id="c-40395498" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#40395468">parent</a><span>|</span><a href="#40395769">prev</a><span>|</span><a href="#40394296">next</a><span>|</span><label class="collapse" for="c-40395498">[-]</label><label class="expand" for="c-40395498">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s because PC games know they need to deal with compilation, so they do it on the load screen or whatever. GC games can pre-compile them and just stuff it on the disk, so there&#x27;s no compilation cost.</div><br/><div id="40396851" class="c"><input type="checkbox" id="c-40396851" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40395498">parent</a><span>|</span><a href="#40394296">next</a><span>|</span><label class="collapse" for="c-40396851">[-]</label><label class="expand" for="c-40396851">[3 more]</label></div><br/><div class="children"><div class="content">GC shaders are loosely based on GLSL, and OpenGL compilation model, even though GX(2) isn&#x27;t OpenGL.</div><br/><div id="40396904" class="c"><input type="checkbox" id="c-40396904" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40396851">parent</a><span>|</span><a href="#40394296">next</a><span>|</span><label class="collapse" for="c-40396904">[-]</label><label class="expand" for="c-40396904">[2 more]</label></div><br/><div class="children"><div class="content">No, GameCube&#x27;s TEVs have nothing to do with GLSL. The reference to GX2 implies you&#x27;re confusing it with Wii U, inexplicably.</div><br/><div id="40397097" class="c"><input type="checkbox" id="c-40397097" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40395468">root</a><span>|</span><a href="#40396904">parent</a><span>|</span><a href="#40394296">next</a><span>|</span><label class="collapse" for="c-40397097">[-]</label><label class="expand" for="c-40397097">[1 more]</label></div><br/><div class="children"><div class="content">Yes I mixed them with Wii and Wii U,no need for &quot;inexplicably&quot; remark.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40394296" class="c"><input type="checkbox" id="c-40394296" checked=""/><div class="controls bullet"><span class="by">GaggiX</span><span>|</span><a href="#40395468">prev</a><span>|</span><label class="collapse" for="c-40394296">[-]</label><label class="expand" for="c-40394296">[1 more]</label></div><br/><div class="children"><div class="content">The shader compilation stutter reminds me of a video I recently saw where a developer solved the problem by running a large portion of his game during its first loading: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;oG-H-IfXUqI" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;oG-H-IfXUqI</a><p>The developer register himself playing the game and during the first loading of the game, the entire gameplay is replayed at high speed in the background on the machine.</div><br/></div></div></div></div></div></div></div></body></html>