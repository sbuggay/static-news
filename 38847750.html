<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704358854790" as="style"/><link rel="stylesheet" href="styles.css?v=1704358854790"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mjg59.dreamwidth.org/69070.html">Dealing with Weird ELF Libraries</a>Â <span class="domain">(<a href="https://mjg59.dreamwidth.org">mjg59.dreamwidth.org</a>)</span></div><div class="subtext"><span>ingve</span> | <span>14 comments</span></div><br/><div><div id="38862004" class="c"><input type="checkbox" id="c-38862004" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#38862450">next</a><span>|</span><label class="collapse" for="c-38862004">[-]</label><label class="expand" for="c-38862004">[7 more]</label></div><br/><div class="children"><div class="content">Oh hey, a favorite topic of mine!<p>The general rule is that program headers (containing <i>segments</i>) are for runtime, and section headers are for compile time. The ELF loader and RTLD do not even look at the section headers, which is abused often in various ways: most commonly, section headers are just stripped right off, but it&#x27;s entirely possible to devise a binary with valid-looking section headers that don&#x27;t match the program headers. Imagine: a malicious binary which points to the malicious code in the program header, but totally innocent code in the section header. Lots of tools - including reverse-engineering tools! - blindly trust the section headers for some reason.<p>The usual compile-time linker does look at section headers, and in particular will merge the various sections of the input .o files based on section name. Sections have more granularity than segments - for example, there is usually a .data section distinct from the .bss section, but often just a single RW segment that covers both (specifying a longer memory size than file size in order to zero-fill the BSS bits).<p>I believe the distinction between segments and sections largely arises because the runtime (ELF loader&#x2F;dynamic linker) have different needs from the compiler (static linker); however, I have not looked deeply enough into the history of the ELF format to know exactly why the distinction was made initially. I know many other formats do not make this distinction as clearly: Mach-O nests sections underneath segments hierarchically, whereas PE just has sections: much of the &quot;metadata&quot; that would normally live in ELF sections is instead in special &quot;directories&quot; pointed to by specific entries in the PE file header.</div><br/><div id="38863692" class="c"><input type="checkbox" id="c-38863692" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#38862004">parent</a><span>|</span><a href="#38863512">next</a><span>|</span><label class="collapse" for="c-38863692">[-]</label><label class="expand" for="c-38863692">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting. When I was hand-writing ELFs, it took me a while to grok sections vs. segments. If you ever run across a history of executable formats and the motivations for the particular decisions made with ELF, I&#x27;d love to read that.<p>The main thing that surprised me was how loose of a format ELF is compared to the much more rigid conventions imposed by modern mainstream compilers.</div><br/></div></div><div id="38863512" class="c"><input type="checkbox" id="c-38863512" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38862004">parent</a><span>|</span><a href="#38863692">prev</a><span>|</span><a href="#38862450">next</a><span>|</span><label class="collapse" for="c-38863512">[-]</label><label class="expand" for="c-38863512">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s turned into one of my favorite topics too.<p>It&#x27;s weird how all the tools out there are all about the ELF sections. Apparently the sections are where all the fun stuff gets stored and the program headers are just some kernel wizardry nobody really cares about.<p>The section&#x2F;segment dichotomy exists so that kernels need not load needless stuff onto memory. In practice it means things like ELF symbol tables are not available for introspection by the program. If pointers to those symbols are required, the easiest way is to get the ELF interpreter to give them to the program. If it&#x27;s a static executable then there&#x27;s no interpreter and things get annoying fast. Most solutions I&#x27;ve seen involve reading the program&#x27;s own executable into memory and parsing the ELF structures, essentially duplicating the work of the kernel&#x27;s ELF loader. Alternatively, one may engage in this incredibly fun activity called linker scripting.<p>I chose to hack together an ELF patching tool in order to get Linux to automatically load arbitrary ELF file segments onto memory. Along the way I requested some linker features and actually got them!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;lone-lang&#x2F;lone&#x2F;blob&#x2F;master&#x2F;source&#x2F;tools&#x2F;lone-embed.c">https:&#x2F;&#x2F;github.com&#x2F;lone-lang&#x2F;lone&#x2F;blob&#x2F;master&#x2F;source&#x2F;tools&#x2F;l...</a><p>With these tools I made it possible for my language&#x27;s interpreter to load programs embedded inside itself.<p><a href="https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;self-contained-lone-lisp-applications" rel="nofollow">https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;self-contained-lone-...</a><p>I really want to see this feature get adopted by the mainstream languages. Apparently no one else ever thought of it.</div><br/><div id="38863928" class="c"><input type="checkbox" id="c-38863928" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#38862004">root</a><span>|</span><a href="#38863512">parent</a><span>|</span><a href="#38862450">next</a><span>|</span><label class="collapse" for="c-38863928">[-]</label><label class="expand" for="c-38863928">[4 more]</label></div><br/><div class="children"><div class="content">Python one-file-packagers such as PyInstaller typically use the technique of shoving the entire Python standard library into the executable as a zip file; Python can natively import scripts straight out of .zip files (zipimport) so you just point `sys.path` at the executable and voila, self-contained Python in a single binary. (Note that this doesn&#x27;t immediately solve the problem of using native code dynamic libraries, which usually have to get unpacked anyway or use hacky custom loaders).<p>One year, for DEF CON CTF, we had to write all of our exploits as single ELF binaries targeting a minimal OS (DARPA CGC) with only seven system calls (exit, read, write, select, malloc, free, getrandom). Since writing exploits in C sucks, I packaged Python for the OS instead, creating a &quot;virtual filesystem&quot; for including Python code (including standard library) as a static chunk of data and implementing open&#x2F;read&#x2F;write on top of the VFS. This was really quite successful for us, as we were able to write very high-level Python code for a full, functioning Python interpreter in our exploits.</div><br/><div id="38864269" class="c"><input type="checkbox" id="c-38864269" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38862004">root</a><span>|</span><a href="#38863928">parent</a><span>|</span><a href="#38862450">next</a><span>|</span><label class="collapse" for="c-38864269">[-]</label><label class="expand" for="c-38864269">[3 more]</label></div><br/><div class="children"><div class="content">Nice. But the beauty of GP&#x27;s approach is that you don&#x27;t need to issue another open syscall to open argv[0] in order to access (read or mmap) your code but instead just piggy back on what the kernel just did for your entry point anyway.<p>Except for the beauty of the approach, I&#x27;m not sure what the practical advantages are. Are there cases where a process wouldn&#x27;t have permissions to access its own executable or argv[0] value is unreliable? Can you exec on a file descriptor of a deleted file?<p>EDIT: or would &#x2F;proc&#x2F;self&#x2F;exe always point to something the process could open?</div><br/><div id="38864393" class="c"><input type="checkbox" id="c-38864393" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#38862004">root</a><span>|</span><a href="#38864269">parent</a><span>|</span><a href="#38862450">next</a><span>|</span><label class="collapse" for="c-38864393">[-]</label><label class="expand" for="c-38864393">[2 more]</label></div><br/><div class="children"><div class="content">I believe the process always holds the binary open as a &quot;txt&quot; file descriptor (check lsof), so opening `&#x2F;proc&#x2F;self&#x2F;exe` always works.<p>You can even execve a &quot;memfd&quot;, an in-memory &quot;file&quot; which is not in the filesystem (distinct from a ramdisk file, which is a file sitting on an in-memory filesystem). &#x2F;proc&#x2F;self&#x2F;exe still works even in that case, even when the original memfd is closed.<p>Note that argv[0] can never be relied on 100%. The vast majority of programs will set it correctly (especially since many programs will malfunction if provided bogus argv[0]), but a caller has full control over argv[0] and can set it to anything, including a NULL pointer (by simply passing an empty argv array).</div><br/><div id="38864649" class="c"><input type="checkbox" id="c-38864649" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38862004">root</a><span>|</span><a href="#38864393">parent</a><span>|</span><a href="#38862450">next</a><span>|</span><label class="collapse" for="c-38864649">[-]</label><label class="expand" for="c-38864649">[1 more]</label></div><br/><div class="children"><div class="content">There is the possibility &#x2F;proc is not mounted, right?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38862450" class="c"><input type="checkbox" id="c-38862450" checked=""/><div class="controls bullet"><span class="by">jstrieb</span><span>|</span><a href="#38862004">prev</a><span>|</span><a href="#38862487">next</a><span>|</span><label class="collapse" for="c-38862450">[-]</label><label class="expand" for="c-38862450">[4 more]</label></div><br/><div class="children"><div class="content">If you want to pull back the curtain, I highly recommend hand-writing your own small ELF binary. In particular, on Linux, the C ELF structures are available via:<p><pre><code>    #include &lt;elf.h&gt;
</code></pre>
Writing C code to generate an ELF makes it apparent that an ELF is just a couple of structs and some assembled code dumped to a file. (I&#x27;ve used Keystone with decent success for assembly.) It&#x27;s actually pretty easy to build something that works if you follow along with the man page:<p><pre><code>    man 5 elf
</code></pre>
For debugging handmade ELF files, it&#x27;s handy to explicitly run the system loader under strace:<p><pre><code>    strace &#x2F;lib&#x2F;ld-linux.so.3 .&#x2F;homemade_elf
</code></pre>
You can find the path to the interpreter that will be used via something like:<p><pre><code>    readelf -a &quot;$(which ls)&quot; | grep -i interpreter
</code></pre>
For example, debugging with strace will make it apparent if any memory mappings are failing. The loader also sometimes has its own error messages that are more descriptive than a normal segfault.</div><br/><div id="38863658" class="c"><input type="checkbox" id="c-38863658" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#38862450">parent</a><span>|</span><a href="#38862487">next</a><span>|</span><label class="collapse" for="c-38863658">[-]</label><label class="expand" for="c-38863658">[3 more]</label></div><br/><div class="children"><div class="content">Also, don&#x27;t forget LD_DEBUG for debugging your handmade ELFs:<p><pre><code>    man 8 ld.so
</code></pre>
Your advice is completely on point. I spent some time a while back hand-writing ELF files in GNU Assembler. Statically linked executables are, indeed, quite straightforward. That said, there are definitely some mysteries, like the difference between p_vaddr and p_paddr in the program headers. Also, the difference between segments and sections is never really explained in the main references.<p>Dynamically linked ELF executables are somewhat of a different beast, though. You need some decent familiarity with assembly and the broad strokes of program loading to make heads or tails of the details around relocation symbols.<p>When I was playing around with these things, I never succeeded at hand-writing x86-64 dynamically linked ELF to do anything other than immediately segfault somewhere during loading. Maybe I should give it another try.<p>Not to far back, I spent some time  decompiling (small) static ELF binaries by hand. That really hammered in the x86-64 ISA and its subtleties. I also have Levine&#x27;s &quot;Linkers and Loaders&quot; sitting on my shelf, which I hope to get around to reading sooner than later.</div><br/><div id="38863791" class="c"><input type="checkbox" id="c-38863791" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38862450">root</a><span>|</span><a href="#38863658">parent</a><span>|</span><a href="#38862487">next</a><span>|</span><label class="collapse" for="c-38863791">[-]</label><label class="expand" for="c-38863791">[2 more]</label></div><br/><div class="children"><div class="content">&gt; immediately segfault somewhere during loading<p>Utterly terrifying. They somehow segfault before executing a single instruction in the program&#x27;s entry point. Even the likes of gdb are rendered powerless before the might of this uber segfault. I was reduced to posting readelf dumps on stackoverflow. Mercifully people immediately spotted the problem (unsorted PT_LOAD segments).</div><br/><div id="38864069" class="c"><input type="checkbox" id="c-38864069" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#38862450">root</a><span>|</span><a href="#38863791">parent</a><span>|</span><a href="#38862487">next</a><span>|</span><label class="collapse" for="c-38864069">[-]</label><label class="expand" for="c-38864069">[1 more]</label></div><br/><div class="children"><div class="content">This was one of my favorite StackOverflow debugging experiences: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;12575044&#x2F;1204143" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;12575044&#x2F;1204143</a>. A user posted that their code, `int main() { return 0; }`, was crashing with SIGFPE. I traced it to the fact that they had compiled the code with a fairly new GCC, but ran it on a machine with a very old libc - their old libc didn&#x27;t understand `DT_GNU_HASH` and was trying to look symbols up in an empty `DT_HASH` (computing the bucket indices mod 0 - hence SIGFPE).<p>It&#x27;s possible to debug these! If it&#x27;s a segfault (as opposed to the kernel just refusing to load your file), it&#x27;s usually because ld.so (the dynamic linker) has crashed, and you can debug ld.so explicitly (gdb ld-linux.so.2 ; run .&#x2F;yourprog). With symbols it&#x27;s usually feasible to identify the code in the dynamic linker that has crashed.</div><br/></div></div></div></div></div></div></div></div><div id="38862487" class="c"><input type="checkbox" id="c-38862487" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38862450">prev</a><span>|</span><label class="collapse" for="c-38862487">[-]</label><label class="expand" for="c-38862487">[2 more]</label></div><br/><div class="children"><div class="content">Coming from DOS&#x2F;Windows world, I think the main reason ELF is as weird and complex as it is, is because it tries to be both a dynamic and static object format at the same time, and dynamic linking on Unix-likes is also supposed to be an approximation of static linking, but at runtime. In contrast, PE exports are just a mapping from addresses (more precisely, RVAs) to names, and imports are simply an array of slots that point to the name but get overwritten by the actual address by the loader.</div><br/><div id="38864671" class="c"><input type="checkbox" id="c-38864671" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#38862487">parent</a><span>|</span><label class="collapse" for="c-38864671">[-]</label><label class="expand" for="c-38864671">[1 more]</label></div><br/><div class="children"><div class="content">ELF might be weirder, but as an end user I much prefer it compared to having to deal with implibs and declspecs and all that nonsense on Windows.</div><br/></div></div></div></div></div></div></div></div></div></body></html>