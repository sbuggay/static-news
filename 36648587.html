<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688893260983" as="style"/><link rel="stylesheet" href="styles.css?v=1688893260983"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lemire.me/blog/2023/07/07/packing-a-string-of-digits-into-an-integer-quickly/">Packing a string of digits into an integer quickly</a> <span class="domain">(<a href="https://lemire.me">lemire.me</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>14 comments</span></div><br/><div><div id="36650117" class="c"><input type="checkbox" id="c-36650117" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#36649559">next</a><span>|</span><label class="collapse" for="c-36650117">[-]</label><label class="expand" for="c-36650117">[2 more]</label></div><br/><div class="children"><div class="content">It was a fairly common thing to do very similar operations on Apple ][ computers.<p>6502 had a BCD (binary coded decimal) mode; basically when in BCD mode arithmetic operators carried at 0x9 rather than 0xF, and operations worked nibble-wise rather than byte-wise.  So it was common to represent 2 digits in one bye regardless of hex vs decimal.<p>I actually have been thinking about this lately because of the other half of the problem, ie ASCII &lt;—&gt; native types.  On the Apple 2 one really cool speed trick was to store strings directly on the screen.  The Apple 2 text screen was memory mapped (0x400 - 0x7FF IIRC).  To write strings to the screen in assembly, you wrote the ASCII character codes to the right memory locations.  But if you were trying to eke out every single cycle you could, and your strings were fixed length, you didn’t need to store them somewhere and copy them to the screen; you could use the screen as the store for your strings.<p>I once made a stupid program that counted to  one million this way; it ran fast enough to watch it finish.</div><br/><div id="36651380" class="c"><input type="checkbox" id="c-36651380" checked=""/><div class="controls bullet"><span class="by">wahahah</span><span>|</span><a href="#36650117">parent</a><span>|</span><a href="#36649559">next</a><span>|</span><label class="collapse" for="c-36651380">[-]</label><label class="expand" for="c-36651380">[1 more]</label></div><br/><div class="children"><div class="content">Huh, that decimal representation is a pretty attractive idea, I wonder why I haven&#x27;t heard of it before or seen it in use at all.<p>100&#x2F;256 seems very tolerable efficiency-wise.</div><br/></div></div></div></div><div id="36649559" class="c"><input type="checkbox" id="c-36649559" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#36650117">prev</a><span>|</span><a href="#36652191">next</a><span>|</span><label class="collapse" for="c-36649559">[-]</label><label class="expand" for="c-36649559">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand how this can work: there are 15 (or 7 :-) other characters with the same bottom four bits as each digit.  How does it distinguish between, say, &#x27;4&#x27; and &#x27;t&#x27;?  Space and &#x27;0&#x27; have the same lower four bits: \0!</div><br/><div id="36649838" class="c"><input type="checkbox" id="c-36649838" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36649559">parent</a><span>|</span><a href="#36649598">next</a><span>|</span><label class="collapse" for="c-36649838">[-]</label><label class="expand" for="c-36649838">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t distinguish, the non-digit character index is hardcoded into the bitmask (note the missing f in the second hex literal):<p><pre><code>  part1 = _pext_u64(part1, 0x0f0f0f0f0f0f0f0f);
  part2 = _pext_u64(part2, 0x0f000f0f0f0f0f0f);
</code></pre>
You are right that if you were to use a space in an unexpected position, the code wouldn&#x27;t work.</div><br/></div></div><div id="36649598" class="c"><input type="checkbox" id="c-36649598" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#36649559">parent</a><span>|</span><a href="#36649838">prev</a><span>|</span><a href="#36652191">next</a><span>|</span><label class="collapse" for="c-36649598">[-]</label><label class="expand" for="c-36649598">[5 more]</label></div><br/><div class="children"><div class="content">I think the author is only concerned with decimal digits (0-9).</div><br/><div id="36649695" class="c"><input type="checkbox" id="c-36649695" checked=""/><div class="controls bullet"><span class="by">patrec</span><span>|</span><a href="#36649559">root</a><span>|</span><a href="#36649598">parent</a><span>|</span><a href="#36652191">next</a><span>|</span><label class="collapse" for="c-36649695">[-]</label><label class="expand" for="c-36649695">[4 more]</label></div><br/><div class="children"><div class="content">No, he says that the strings can contain spaces and other characters but that he wants them ordered (only) by the decimal digits in them. I don&#x27;t see how this can work either.</div><br/><div id="36649822" class="c"><input type="checkbox" id="c-36649822" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#36649559">root</a><span>|</span><a href="#36649695">parent</a><span>|</span><a href="#36649868">next</a><span>|</span><label class="collapse" for="c-36649822">[-]</label><label class="expand" for="c-36649822">[1 more]</label></div><br/><div class="children"><div class="content">The bitmasks in the code are adjusted so that it works with that specific pattern of numbers to other letters. Masks only pick bits from digits when the are in those specific positions.<p>So this solution only works when the digit character places are fixed and known.<p>It would be possible to generate mask based on the first nibbles so that it would ignore non-digits. Maybe even with some fairly optimized vector instructions. Not sure would it be faster than some naive solution.</div><br/></div></div><div id="36649868" class="c"><input type="checkbox" id="c-36649868" checked=""/><div class="controls bullet"><span class="by">xcvb</span><span>|</span><a href="#36649559">root</a><span>|</span><a href="#36649695">parent</a><span>|</span><a href="#36649822">prev</a><span>|</span><a href="#36652191">next</a><span>|</span><label class="collapse" for="c-36649868">[-]</label><label class="expand" for="c-36649868">[2 more]</label></div><br/><div class="children"><div class="content">Looking at the code, it seems like it expects a string of the form &quot;dddddddd?dddddd&quot; where the &#x27;?&#x27; is any ascii character, and the code assumes the rest of the characters are ascii digits.<p>Specifically the line: `part2 = _pext_u64(part2, 0x0f000f0f0f0f0f0f);` seems to mask out that character.</div><br/><div id="36650058" class="c"><input type="checkbox" id="c-36650058" checked=""/><div class="controls bullet"><span class="by">patrec</span><span>|</span><a href="#36649559">root</a><span>|</span><a href="#36649868">parent</a><span>|</span><a href="#36652191">next</a><span>|</span><label class="collapse" for="c-36650058">[-]</label><label class="expand" for="c-36650058">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, I hadn&#x27;t noticed the 000 (rather than 0f0) in there! Thanks!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36652191" class="c"><input type="checkbox" id="c-36652191" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#36649559">prev</a><span>|</span><a href="#36650370">next</a><span>|</span><label class="collapse" for="c-36652191">[-]</label><label class="expand" for="c-36652191">[1 more]</label></div><br/><div class="children"><div class="content">Anyone know an efficient way of zipping&#x2F;interleaving two bitmasks on Intel? Assume both bitmasks are in their own mask registers, and the top halves and bottom halves can be zipped into separate output registers. My current solution uses the pdep instruction.</div><br/></div></div><div id="36650370" class="c"><input type="checkbox" id="c-36650370" checked=""/><div class="controls bullet"><span class="by">dcsommer</span><span>|</span><a href="#36652191">prev</a><span>|</span><a href="#36649646">next</a><span>|</span><label class="collapse" for="c-36650370">[-]</label><label class="expand" for="c-36650370">[1 more]</label></div><br/><div class="children"><div class="content">The BEAM VM (Erlang&#x2F;Elixir) recently optimized a related procedure as well  <a href="https:&#x2F;&#x2F;github.com&#x2F;erlang&#x2F;otp&#x2F;pull&#x2F;7426">https:&#x2F;&#x2F;github.com&#x2F;erlang&#x2F;otp&#x2F;pull&#x2F;7426</a></div><br/></div></div><div id="36649646" class="c"><input type="checkbox" id="c-36649646" checked=""/><div class="controls bullet"><span class="by">hammock</span><span>|</span><a href="#36650370">prev</a><span>|</span><label class="collapse" for="c-36649646">[-]</label><label class="expand" for="c-36649646">[2 more]</label></div><br/><div class="children"><div class="content">Can’t you just search through and remove all the non-digit characters? (Excel user here)</div><br/><div id="36650316" class="c"><input type="checkbox" id="c-36650316" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#36649646">parent</a><span>|</span><label class="collapse" for="c-36650316">[-]</label><label class="expand" for="c-36650316">[1 more]</label></div><br/><div class="children"><div class="content">You can. But the point of this exercise seems to be  cpu efficiency.</div><br/></div></div></div></div></div></div></div></div></div></body></html>