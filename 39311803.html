<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707469260071" as="style"/><link rel="stylesheet" href="styles.css?v=1707469260071"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://glitchbyte.io/posts/rust-wont-save-us/">Rust wont save us, but its ideas will</a> <span class="domain">(<a href="https://glitchbyte.io">glitchbyte.io</a>)</span></div><div class="subtext"><span>signa11</span> | <span>46 comments</span></div><br/><div><div id="39312689" class="c"><input type="checkbox" id="c-39312689" checked=""/><div class="controls bullet"><span class="by">dash2</span><span>|</span><a href="#39312745">next</a><span>|</span><label class="collapse" for="c-39312689">[-]</label><label class="expand" for="c-39312689">[4 more]</label></div><br/><div class="children"><div class="content">This article indeed did not make sense. The key point it doesn&#x27;t get is that the majority of issues described in the original were not deeply embedded in the language. They weren&#x27;t use-after-free etc. They were simply <i>the programmer doing something bad</i>, where something bad is highly domain-specific.<p>There will never be language-level protection against e.g. trusting a URL which you shouldn&#x27;t trust, or making a function public when it should be private, because languages have to be general enough to trust <i>some</i> URLs and make <i>some</i> functions public. Languages cannot take away the responsibility of the programmer not to do stupid stuff.</div><br/><div id="39312801" class="c"><input type="checkbox" id="c-39312801" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39312689">parent</a><span>|</span><a href="#39312771">next</a><span>|</span><label class="collapse" for="c-39312801">[-]</label><label class="expand" for="c-39312801">[1 more]</label></div><br/><div class="children"><div class="content">Languages can actually help here! They aren&#x27;t a panacea, of course, but you can do all sorts of things like encode things into the type system (&quot;this is a safe string, you cannot put user tainted input into it without escaping it&quot;) or be amenable to static analysis (&quot;this variable is not declared&quot;) or even manual code review (&quot;I can understand the entire semantics of this block of code because it is impossible to override the behavior of the operations here&quot;).</div><br/></div></div><div id="39312771" class="c"><input type="checkbox" id="c-39312771" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#39312689">parent</a><span>|</span><a href="#39312801">prev</a><span>|</span><a href="#39312759">next</a><span>|</span><label class="collapse" for="c-39312771">[-]</label><label class="expand" for="c-39312771">[1 more]</label></div><br/><div class="children"><div class="content">Agree you can&#x27;t kill all the badness, but e.g. web security has gotten better in many respects primarily (I have no proof of this claim but I was a pentester for a long time) because of improvements in libraries and frameworks.<p>I don&#x27;t think Rust offers anything special in this regard however.<p>Rather I think it is better understanding of the security nuances of particular problem domains that lead to api<p>Devs today are not particularly better at preventing xss or sqli but the default tools they reach for have APIs that make it harder to do the wrong thing.</div><br/></div></div></div></div><div id="39312745" class="c"><input type="checkbox" id="c-39312745" checked=""/><div class="controls bullet"><span class="by">steinuil</span><span>|</span><a href="#39312689">prev</a><span>|</span><a href="#39312388">next</a><span>|</span><label class="collapse" for="c-39312745">[-]</label><label class="expand" for="c-39312745">[1 more]</label></div><br/><div class="children"><div class="content">This post is not very good, sorry.<p>Let&#x27;s start with the first example about IEF: first of all, I think that the security advisory was mostly referring to <i>web</i> APIs that allow users without the necessary permissions to perform actions they shouldn&#x27;t be able to. If you can already call Java APIs you already have access to the machine so it matters little what visibility the method was declared with. And as somebody else mentioned, the default visibility for Java methods is package-private.<p>Second example about the URL interception: first of all, you could have `match`ed on the result of `strip_prefix` instead of checking `starts_with` and then `unwrap`ping the result of the former. Second, why not use a URI parsing library? And third: that is <i>not</i> what checking the source of the URL means in this context! I&#x27;m assuming there&#x27;s a way to tell what is the URL currently shown on the webview, and that you should check <i>that</i> before doing an RPC.<p>The Rust code example shown in the post is functionally identical to the Java version. Also, `&amp;str` doesn&#x27;t mean the string size is known at compile time, the bounds checks are all performed at runtime.<p>Third example about path traversal: again, that&#x27;s functionally the same code as the Java version. What is missing in both is a check that the path is relative to a well-known list of paths and doesn&#x27;t contain any `..` which could possibly lead to, well, a path traversal vulnerability!<p>I appreciate the effort that went into the post and I agree that Rust is still better than many other languages out there (because of its API design in many important areas), but man, this ain&#x27;t it.</div><br/></div></div><div id="39312388" class="c"><input type="checkbox" id="c-39312388" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39312745">prev</a><span>|</span><a href="#39312597">next</a><span>|</span><label class="collapse" for="c-39312388">[-]</label><label class="expand" for="c-39312388">[5 more]</label></div><br/><div class="children"><div class="content">The example with IEF doesn’t make sense. Whether you declare a function private or public doesn’t impact its usability as a gadget. And as I understand it reading up on IEF, the problem with removeDatabase is when it’s exposed as a remotely callable API without any auth check which is a very different problem. Am I misunderstanding what the author is saying?<p>I think the main problem with the article referenced in the submission is that percentages of vulnerabilities change based on the problem domain. The main threat for web facing services isn’t memory safety but that’s because most web facing services already use memory safe languages like JS, Java&#x2F;JVM, Python, Ruby, or Go. It’s weird to pick Rust for its memory safety for web services. The reason to pick Rust is because you get C&#x2F;C++ like performance without the memory safety issues. If you don’t need the perf, all the other languages are better choices because you’ll probably move quicker.<p>It’s interesting that 20% are still memory vulnerabilities. Assuming this is all the same class of attacks on web services, that means 20% of applications do care about perf and have exploitable memory safety issues. Or the methodology is shoddy and they’re comparing different classes of software. Regardless, the premise of the first article is flawed and rife with statistical analysis problems that paint a misleading picture while the response isn’t infusing me with a lot of confidence on the merits and comes off as unnecessarily fanboish trying to stretch for a reason of “but no rust still makes sense”. 70% of vulnerabilities in Chrome are memory safety. This holds for similar classes of software written in c&#x2F;C++ (eg Windows). There’s a reason all major c&#x2F;c++ codebases have started getting grass roots and organizational support to transition away as quickly as possible.</div><br/><div id="39312603" class="c"><input type="checkbox" id="c-39312603" checked=""/><div class="controls bullet"><span class="by">hkolk</span><span>|</span><a href="#39312388">parent</a><span>|</span><a href="#39312466">next</a><span>|</span><label class="collapse" for="c-39312603">[-]</label><label class="expand" for="c-39312603">[1 more]</label></div><br/><div class="children"><div class="content">The second example given (extracting information from a web view) is also weird. The rust code has the exact same flaw as the java code, which is that they do not validate the source. I think the author didn&#x27;t really understand the underlying problem here. Bounds checking was not the issue with the java (android) code</div><br/></div></div><div id="39312466" class="c"><input type="checkbox" id="c-39312466" checked=""/><div class="controls bullet"><span class="by">phicoh</span><span>|</span><a href="#39312388">parent</a><span>|</span><a href="#39312603">prev</a><span>|</span><a href="#39312597">next</a><span>|</span><label class="collapse" for="c-39312466">[-]</label><label class="expand" for="c-39312466">[3 more]</label></div><br/><div class="children"><div class="content">Rust has other advantages as well. For example, a common error when something goes wrong in Python is that a &#x27;None&#x27; value ends up somewhere where it shouldn&#x27;t be. Typically this None has traveled quite a while before some code tried to use it.<p>The richer and stricter type system of Rust makes such errors a lot less likely. And if an error escapes, there usually is a way better indication of the origin of the error than just &#x27;None&#x27;.</div><br/><div id="39312563" class="c"><input type="checkbox" id="c-39312563" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39312388">root</a><span>|</span><a href="#39312466">parent</a><span>|</span><a href="#39312488">next</a><span>|</span><label class="collapse" for="c-39312563">[-]</label><label class="expand" for="c-39312563">[1 more]</label></div><br/><div class="children"><div class="content">Ergonomic advantages &#x2F; reduced defect rates != vulnerability issues. The former aren’t a problem for languages like JS which has all sorts of weird sharp edges. But vulnerabilities are treated as a separate risk factor because the issues can spill to unexpected areas which makes risk harder to quantify and reason about. A vulnerability in some small tool that barely anyone uses can be used to exfil your entire customer database or do a ransomeare attack and cost you hundreds of millions of dollars in short term damage + investigations by regulatory bodies and law enforcement. A buggy piece of software at worst causes some bad PR or a failed product which is way way smaller and localized of an issue</div><br/></div></div><div id="39312488" class="c"><input type="checkbox" id="c-39312488" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39312388">root</a><span>|</span><a href="#39312466">parent</a><span>|</span><a href="#39312563">prev</a><span>|</span><a href="#39312597">next</a><span>|</span><label class="collapse" for="c-39312488">[-]</label><label class="expand" for="c-39312488">[1 more]</label></div><br/><div class="children"><div class="content">Most of those Rust features over Python, that are commonly referred to, are available in any programming language of ML linage.<p>Caml Light, SML, OCaml, Haskell, F#, Scala, and whatever else is out there.<p>Most of them also come with a REPL, and have multiple toolchains, no need for always be waiting for the compiler.</div><br/></div></div></div></div></div></div><div id="39312597" class="c"><input type="checkbox" id="c-39312597" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39312388">prev</a><span>|</span><a href="#39312511">next</a><span>|</span><label class="collapse" for="c-39312597">[-]</label><label class="expand" for="c-39312597">[1 more]</label></div><br/><div class="children"><div class="content">I actually enjoyed reading this and found this somewhat insightful. A critique of modern languages is that while they are more rigorous, there is still the issue of module visibility which is kind of weak and limited.<p>For example, Java has packages and a notion of package private. But that was always a bit of a weak form of modularization. So you end up with a lot of public functions just so some code in a different package can reach it. And while packages are hierarchical, visibility ignores that notion. Java of course has proper modules now. But they are a weak derivative of things like OSGI that while widely used at some point never really went mainstream. Module visibility in OSGI included explicitly defining exposed and required interfaces. If not exposed explicitly, the class loader would prevent you from calling it. Even if it was defined as public.<p>That kind of mechanisms are still missing in most languages. You kind of get some of this by using micro-services. But routing your function calls over a network is kind of stupid from a performance point of view. It doesn&#x27;t scale. I&#x27;ve seen some graphql based systems that are a bit challenged on this front. There are other examples of trying to solve this problem outside of the compiler at run&#x2F;deploy time. A lot of sandboxing used for docker, wasm, etc. is basically about that. But that is kind of mitigating the lack of solutions at the source code level.<p>OSGI was clunky but it definitely had some interesting ideas. Very sad that that never caught on.</div><br/></div></div><div id="39312511" class="c"><input type="checkbox" id="c-39312511" checked=""/><div class="controls bullet"><span class="by">anonnon</span><span>|</span><a href="#39312597">prev</a><span>|</span><a href="#39312307">next</a><span>|</span><label class="collapse" for="c-39312511">[-]</label><label class="expand" for="c-39312511">[10 more]</label></div><br/><div class="children"><div class="content">&gt; We should expect all our languages to be safer.<p>My prediction is modern C++, and even (looking at C23) modern C, will be evolved, albeit gradually, to offer <i>enough</i> of Rust&#x27;s safety so that on a cost-benefit analysis of either updating an existing C or C++ codebase to its modern, safer dialect or rewriting it in Rust, it will be a no-brainer to stick with C or C++. Rust will ultimately become a marginal language, like (sorry) Zig:<p><a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;CPP-Linux-Kernel-2024-Discuss" rel="nofollow">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;CPP-Linux-Kernel-2024-Discuss</a></div><br/><div id="39312595" class="c"><input type="checkbox" id="c-39312595" checked=""/><div class="controls bullet"><span class="by">drakmaniso</span><span>|</span><a href="#39312511">parent</a><span>|</span><a href="#39312550">next</a><span>|</span><label class="collapse" for="c-39312595">[-]</label><label class="expand" for="c-39312595">[1 more]</label></div><br/><div class="children"><div class="content">That would only work if the new versions were willing to break backward compatibility. The safety (and correctness) of a language is not about what it can do, but what it cannot.</div><br/></div></div><div id="39312550" class="c"><input type="checkbox" id="c-39312550" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39312511">parent</a><span>|</span><a href="#39312595">prev</a><span>|</span><a href="#39312693">next</a><span>|</span><label class="collapse" for="c-39312550">[-]</label><label class="expand" for="c-39312550">[3 more]</label></div><br/><div class="children"><div class="content">C++ is already a much safer C, yet plenty insist in using it like C, full of Cisms.<p>When copy paste compatibility to C is available, only regulated industry practices like MISRA force devs to adopt them.</div><br/><div id="39312666" class="c"><input type="checkbox" id="c-39312666" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#39312511">root</a><span>|</span><a href="#39312550">parent</a><span>|</span><a href="#39312693">next</a><span>|</span><label class="collapse" for="c-39312666">[-]</label><label class="expand" for="c-39312666">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about that. The average C++ software is probably safer purely because you can delegate most memory management to standard library.<p>But I&#x27;ve found C to be much easier to reason about. You can inline all the functions and macros and all that&#x27;s left is a bunch of pointer assignments and arithmetic. C++ has a much more complicated lifetime model which is surprisingly easy to violate. Combined with templates, it becomes really difficult to dig in.<p>Due to this, C is much more practical to use with formal verification tools like Frama-C and various model checkers.<p>If Rust had a restricted subset which had a footprint compared to C and allows formal verification (including functional requirements) I would switch right now.</div><br/><div id="39312854" class="c"><input type="checkbox" id="c-39312854" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#39312511">root</a><span>|</span><a href="#39312666">parent</a><span>|</span><a href="#39312693">next</a><span>|</span><label class="collapse" for="c-39312854">[-]</label><label class="expand" for="c-39312854">[1 more]</label></div><br/><div class="children"><div class="content">So, like Zig then?</div><br/></div></div></div></div></div></div><div id="39312693" class="c"><input type="checkbox" id="c-39312693" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#39312511">parent</a><span>|</span><a href="#39312550">prev</a><span>|</span><a href="#39312307">next</a><span>|</span><label class="collapse" for="c-39312693">[-]</label><label class="expand" for="c-39312693">[5 more]</label></div><br/><div class="children"><div class="content">Also Morello prototype architecture &#x2F; CHERI could well just end up enforcing this all at the hardware level and make language-level safety a largely moot point.</div><br/><div id="39312823" class="c"><input type="checkbox" id="c-39312823" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39312511">root</a><span>|</span><a href="#39312693">parent</a><span>|</span><a href="#39312773">next</a><span>|</span><label class="collapse" for="c-39312823">[-]</label><label class="expand" for="c-39312823">[1 more]</label></div><br/><div class="children"><div class="content">Morello provides some safety mechanisms, but it doesn&#x27;t solve all problems. It only covers certain types of memory corruption issues, for example.</div><br/></div></div><div id="39312773" class="c"><input type="checkbox" id="c-39312773" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#39312511">root</a><span>|</span><a href="#39312693">parent</a><span>|</span><a href="#39312823">prev</a><span>|</span><a href="#39312307">next</a><span>|</span><label class="collapse" for="c-39312773">[-]</label><label class="expand" for="c-39312773">[3 more]</label></div><br/><div class="children"><div class="content">Well, if you like crashy programs as opposed to insecure ones, sure!<p>CHERI would stop memory issues being exploited, but it won&#x27;t make your program work correctly when those same errors are encountered.</div><br/><div id="39312816" class="c"><input type="checkbox" id="c-39312816" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39312511">root</a><span>|</span><a href="#39312773">parent</a><span>|</span><a href="#39312307">next</a><span>|</span><label class="collapse" for="c-39312816">[-]</label><label class="expand" for="c-39312816">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there is a language that can guarantee correct operation when you write bugs in it ;)</div><br/><div id="39312853" class="c"><input type="checkbox" id="c-39312853" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#39312511">root</a><span>|</span><a href="#39312816">parent</a><span>|</span><a href="#39312307">next</a><span>|</span><label class="collapse" for="c-39312853">[-]</label><label class="expand" for="c-39312853">[1 more]</label></div><br/><div class="children"><div class="content">True, but you can use languages that avoid whole classes of bug!<p>I guess my only point is that CHERI may protect you from the worst abuse of those bugs, but it still doesn&#x27;t mean you shouldn&#x27;t use something that doesn&#x27;t suffer from them in the first place!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39312307" class="c"><input type="checkbox" id="c-39312307" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39312511">prev</a><span>|</span><a href="#39312352">next</a><span>|</span><label class="collapse" for="c-39312307">[-]</label><label class="expand" for="c-39312307">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Defense in depth&quot; worked fine against amateur attacks. Well-funded attackers who can work on breaking each stage and have a library of attacks to combine are a much worse threat. More attacks like that are appearing. 
Stuxnet is the strongest example.</div><br/><div id="39312829" class="c"><input type="checkbox" id="c-39312829" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#39312307">parent</a><span>|</span><a href="#39312835">next</a><span>|</span><label class="collapse" for="c-39312829">[-]</label><label class="expand" for="c-39312829">[1 more]</label></div><br/><div class="children"><div class="content">Defence in depth is a sound principle.  It helps to raise the cost of successful attack, and to avoid single points of failure in your security architecture.  It mitigates malicious attacks, human error and component failure.<p>You are right that nation states can throw more resources at an attack. All you can do is make attacks as difficult and expensive as possible for an attacker to pull off without detection (commensurate with the value of the assets being protected).</div><br/></div></div><div id="39312835" class="c"><input type="checkbox" id="c-39312835" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39312307">parent</a><span>|</span><a href="#39312829">prev</a><span>|</span><a href="#39312742">next</a><span>|</span><label class="collapse" for="c-39312835">[-]</label><label class="expand" for="c-39312835">[1 more]</label></div><br/><div class="children"><div class="content">&gt; More attacks like that are appearing.<p>I don&#x27;t think so. Generally as software becomes more secure the hacks you hear about will become more sophisticated to match, but this does not mean that they are more prevalent.</div><br/></div></div><div id="39312742" class="c"><input type="checkbox" id="c-39312742" checked=""/><div class="controls bullet"><span class="by">rollcat</span><span>|</span><a href="#39312307">parent</a><span>|</span><a href="#39312835">prev</a><span>|</span><a href="#39312712">next</a><span>|</span><label class="collapse" for="c-39312742">[-]</label><label class="expand" for="c-39312742">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very pessimistic take. I think defense in depth works exactly as advertised: you need progressively disproportionate resources to mount successful attacks, to the point where you need state-level actors&#x2F;funding.<p>E.g. modern cryptography works, the proof being that the UK wants to change the law to effectively ban it.<p>We&#x27;ve commoditized e2ee. The next step is to commoditize secure software, so that the baseline effort for <i>any</i> attack is too high for less determined &#x2F; funded actors. You will still occasionally have to face a stuxnet, but we shouldn&#x27;t need to face another epidemic of cryptolockers.</div><br/></div></div><div id="39312712" class="c"><input type="checkbox" id="c-39312712" checked=""/><div class="controls bullet"><span class="by">HenriTEL</span><span>|</span><a href="#39312307">parent</a><span>|</span><a href="#39312742">prev</a><span>|</span><a href="#39312352">next</a><span>|</span><label class="collapse" for="c-39312712">[-]</label><label class="expand" for="c-39312712">[1 more]</label></div><br/><div class="children"><div class="content">From my understanding it&#x27;s the contrary. The success of Stuxnet relied on the fact that siemens recommended to not change the default passwords as it could affect the operations of critical infrastructure, which is not exactly what I would call defense in depth. Modern defense in depth would require the use of 2FA for manual access (in addition to strong passwords).</div><br/></div></div></div></div><div id="39312352" class="c"><input type="checkbox" id="c-39312352" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#39312307">prev</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312352">[-]</label><label class="expand" for="c-39312352">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;m only learning Rust, but the borrow checker and ownership and lifetimes could be duplicated in C with a little extra syntax, couldn&#x27;t they?</div><br/><div id="39312456" class="c"><input type="checkbox" id="c-39312456" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#39312352">parent</a><span>|</span><a href="#39312504">next</a><span>|</span><label class="collapse" for="c-39312456">[-]</label><label class="expand" for="c-39312456">[2 more]</label></div><br/><div class="children"><div class="content">It <i>could</i>, but we&#x27;re just now getting `bool`, `true`, and `false` as keywords in C23.  The children of everyone posting here will be dead &amp; buried before WG14 adds lifetimes to C&#x27;s type system.</div><br/><div id="39312586" class="c"><input type="checkbox" id="c-39312586" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312456">parent</a><span>|</span><a href="#39312504">next</a><span>|</span><label class="collapse" for="c-39312586">[-]</label><label class="expand" for="c-39312586">[1 more]</label></div><br/><div class="children"><div class="content">But at least, our grandchildren&#x27;s graves won&#x27;t be unsafely accessed.</div><br/></div></div></div></div><div id="39312504" class="c"><input type="checkbox" id="c-39312504" checked=""/><div class="controls bullet"><span class="by">MaulingMonkey</span><span>|</span><a href="#39312352">parent</a><span>|</span><a href="#39312456">prev</a><span>|</span><a href="#39312847">next</a><span>|</span><label class="collapse" for="c-39312504">[-]</label><label class="expand" for="c-39312504">[1 more]</label></div><br/><div class="children"><div class="content">People can and have added extra annotations to C and C++ code for such things.
Static analyzers can catch some use-after-free and iterator invalidation bugs at compile time.
Problem is:<p>• They&#x27;re opt-in instead of opt-out (meaning none of your system libraries or 3rd party dependencies have bothered using them.)<p>• What&#x27;s been implemented in practice frequently fails to find bugs in relatively simple toy examples (I often confuse myself wondering why I&#x27;ve failed to turn some new bit of static analysis on, when in fact I have, and it&#x27;s simply failed to catch even my demonstration bug.)<p>• The <i>effective</i> tools, on the other hand, tend to have &quot;false&quot; positives as well.<p>The conclusion I&#x27;ve come to is that to fully solve these problems in C or C++, you&#x27;d effectively transform it into a new language.  And at that point, you might as well stop pretending that&#x27;s not <i>exactly</i> what you&#x27;re doing, and actually <i>create</i> said new language.<p>---<p>That said, when stuck using C or C++, static analysis and the compiler-specific half measures that are available <i>are</i> worth using, IMO.<p>• <a href="https:&#x2F;&#x2F;awesomekling.github.io&#x2F;Catching-use-after-move-bugs-with-Clang-consumed-annotations&#x2F;" rel="nofollow">https:&#x2F;&#x2F;awesomekling.github.io&#x2F;Catching-use-after-move-bugs-...</a><p>• <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThreadSafetyAnalysis.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThreadSafetyAnalysis.html</a><p>• <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;AttributeReference.html#lifetimebound" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;AttributeReference.html#lifetime...</a><p>• <a href="https:&#x2F;&#x2F;github.com&#x2F;MaulingMonkey&#x2F;notes&#x2F;blob&#x2F;master&#x2F;programming&#x2F;cpp-inspired-by-rust.md">https:&#x2F;&#x2F;github.com&#x2F;MaulingMonkey&#x2F;notes&#x2F;blob&#x2F;master&#x2F;programmi...</a><p>• `printf` type checking annotations exist, but don&#x27;t necessairly work on MSVC.  Often sanest to make your legacy logging macros call `printf` in a dead branch to leverage any hardcoded type checking of `printf`<p>Basically everything is a warning that you might consider cranking up to an error, of course.</div><br/></div></div><div id="39312847" class="c"><input type="checkbox" id="c-39312847" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39312352">parent</a><span>|</span><a href="#39312504">prev</a><span>|</span><a href="#39312360">next</a><span>|</span><label class="collapse" for="c-39312847">[-]</label><label class="expand" for="c-39312847">[1 more]</label></div><br/><div class="children"><div class="content">No. This would require a significant change to the semantics of C.</div><br/></div></div><div id="39312360" class="c"><input type="checkbox" id="c-39312360" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#39312352">parent</a><span>|</span><a href="#39312847">prev</a><span>|</span><a href="#39312531">next</a><span>|</span><label class="collapse" for="c-39312360">[-]</label><label class="expand" for="c-39312360">[3 more]</label></div><br/><div class="children"><div class="content">By patching C like this, wouldn&#x27;t you end up with Rust or something very similar before you know it?</div><br/><div id="39312429" class="c"><input type="checkbox" id="c-39312429" checked=""/><div class="controls bullet"><span class="by">xvedejas</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312360">parent</a><span>|</span><a href="#39312531">next</a><span>|</span><label class="collapse" for="c-39312429">[-]</label><label class="expand" for="c-39312429">[2 more]</label></div><br/><div class="children"><div class="content">safe Rust isn&#x27;t just the borrow checker, it&#x27;s also:<p><pre><code>  - no uninitialized memory
  - clone vs copy semantics as part of the type system
  - Send, Sync, &quot;fearless concurrency&quot;
  - no unchecked indexing
  - type safety (you can&#x27;t just cast things like in C)
</code></pre>
I do think these are clear complements to a borrow checker, since it&#x27;s all in the interest of preventing undefined behavior. Yet, there are even more nice modern features of Rust that C lacks:<p><pre><code>  - hygienic macros
  - namespaces
  - pattern matching
  - modern build&#x2F;package system</code></pre></div><br/><div id="39312582" class="c"><input type="checkbox" id="c-39312582" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312429">parent</a><span>|</span><a href="#39312531">next</a><span>|</span><label class="collapse" for="c-39312582">[-]</label><label class="expand" for="c-39312582">[1 more]</label></div><br/><div class="children"><div class="content">Good point.</div><br/></div></div></div></div></div></div><div id="39312531" class="c"><input type="checkbox" id="c-39312531" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#39312352">parent</a><span>|</span><a href="#39312360">prev</a><span>|</span><a href="#39312421">next</a><span>|</span><label class="collapse" for="c-39312531">[-]</label><label class="expand" for="c-39312531">[1 more]</label></div><br/><div class="children"><div class="content">They could, but for compatibility reasons it would be opt-in. The strength of Rust is that you can&#x27;t opt out of the borrow-checker (even with unsafe).</div><br/></div></div><div id="39312421" class="c"><input type="checkbox" id="c-39312421" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39312352">parent</a><span>|</span><a href="#39312531">prev</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312421">[-]</label><label class="expand" for="c-39312421">[7 more]</label></div><br/><div class="children"><div class="content">No, there’s lots of technical reasons why. Not least of which is that c&#x2F;c++ has be try very loose aliasing rules as well as the lack of a concept of move&#x2F;drop (language nerds can chime in with all the other reasons). Even c++ would struggle even though committed members are aware c++ is dying and are trying to bridge the gap somehow.<p>If you changed the language to support a Rust-like borrow checker, you’d lose back compat which defeats the purpose of stick with C semantics in the first place. There’s the related problem that the borrow checker isn’t automatic. There are places it does good inference, but any structure that has ownership needs to have that owner ship explicitly defined (and often in functions too). That is hard to do when you have to deal with a lot of legacy code that doesn’t have it - while that part can be solved through annotations, things inexpressible in the Rust borrow checker are perfectly legal C so you’d somehow also have to change that code. Additionally the Rust borrow checker can still fail spectacularly on very reasonable code. That’s being addressed in Polonius if that project ever lands, but even then it’s just a step function improvement to solve specific what should be valid code - it doesn’t fix all issues with the borrow checker.<p>C++ is exploring gradual safeness to provide for optionally strengthening the safety but it’s unclear that approach actually makes sense other than as a balwark to c++ dieing completely (ie the switching cost would be weighed against the cost of fortifying the safety of the code and relying on a poor estimate of the risks involved since there’s too many unknowns)<p>TLDR: structural, cultural, and back compat issues will prevent anything like the borrow checker.</div><br/><div id="39312440" class="c"><input type="checkbox" id="c-39312440" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312421">parent</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312440">[-]</label><label class="expand" for="c-39312440">[6 more]</label></div><br/><div class="children"><div class="content">Why do you think C++ is dying?<p>Maybe in your industry, but not in general.</div><br/><div id="39312497" class="c"><input type="checkbox" id="c-39312497" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312440">parent</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312497">[-]</label><label class="expand" for="c-39312497">[5 more]</label></div><br/><div class="children"><div class="content">Every major tech organization has indicated their shifting focus of their flagship products to shift the codebases from c&#x2F;c++ to rust. Microsoft (Windows, Azure maybe office, not sure), Google (Chrome and probably a bunch of internal projects), Apple (various kernel pieces to harden and fix the ability to jailbreak). Linux has dipped its toe in the water with drivers but honestly I expect that to shift away from C and then eventually C will go into a “no new subsystem in C” policy followed by a “rewrite critical subsystems in pure rust).<p>Dying doesn’t mean that there’s not going to be developers. It just means that it’s no longer growing and the ability to hire developers that have significant c&#x2F;c++ experience will get harder and harder. It’s still very early days and c&#x2F;c++ has a lot more legacy code still running than COBOL ever did and COBOL is still alive and kicking in a sense. I would still classify cobol as a largely dead language even though technically people still know it and the code is running.<p>As for industry, could be. I imagine you think finance but I have a hard time seeing them stick to c&#x2F;c++ if the rest of tech proper has switched. For new projects, maintenance will be cheaper because of things like cargo crates and other ecosystem niceties that c&#x2F;c++ will never have. And rust performance is on par with c&#x2F;C++. So what would be the case for starting any new project in c&#x2F;C++?<p>I’m not predicting a timeline. I’m just describing a clear trend. It could easily take 50+ years. Depends on investments by corporations + grass roots + how effective the c++ committee is at stopping the bleeding + whether the rust community does an own goal like trying to standardize the language through ISO which is a huge contributor for why c++ and c will be unable to adjust. But right now rust has a clear velocity and acceleration advantage and has achieved “escape” velocity for when a language will likely take over for another.</div><br/><div id="39312570" class="c"><input type="checkbox" id="c-39312570" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312497">parent</a><span>|</span><a href="#39312517">next</a><span>|</span><label class="collapse" for="c-39312570">[-]</label><label class="expand" for="c-39312570">[1 more]</label></div><br/><div class="children"><div class="content">Game industry is solidly C++ and that’s not changing anytime soon.<p>It’s not just inertia. Games have very specific latency and timing requirements that required tightly integrated language and compiler features developed for this very purpose. The financial industry too has similar needs and solutions. Rust isn’t a fit for those use cases. Not without a mountain of work that no one is doing, nor would be likely to be accepted as it conflicts with the design goals of Rust.</div><br/></div></div><div id="39312517" class="c"><input type="checkbox" id="c-39312517" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312497">parent</a><span>|</span><a href="#39312570">prev</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312517">[-]</label><label class="expand" for="c-39312517">[3 more]</label></div><br/><div class="children"><div class="content">In Microsoft&#x27;s case, it is still baby steps outside Azure.<p>When XBox, Office and Windows business units really do approach Rust support the same way as they embrace C++ over anything else, then Rust is really in the house.<p>Yes I am aware of Rust&#x2F;WinRT and the GDI regions kernel module rewrite.<p>Rust&#x2F;WinRT is done by the same guys that botched C++&#x2F;WinRT, no big hopes with that one.</div><br/><div id="39312542" class="c"><input type="checkbox" id="c-39312542" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312517">parent</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312542">[-]</label><label class="expand" for="c-39312542">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2023&#x2F;04&#x2F;27&#x2F;microsoft_windows_rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2023&#x2F;04&#x2F;27&#x2F;microsoft_windows_rus...</a><p><a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;01&#x2F;31&#x2F;microsoft_seeks_rust_developers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;01&#x2F;31&#x2F;microsoft_seeks_rust_...</a><p>Reasonable people can disagree but I wouldn’t call that a baby step. Core windows libraries, the NT kernel all being rewritten in Rust. Not sure why 365 stuff is being rewritten from c# to rust but maybe there’s some kind of perf issues that Rust will help them with.<p>But your bar is also too high. This stuff happens slowly and then all at once. The slow bit is making the infra changes and figuring out how to start the porting process so that other people can start to contribute in a way that’s a positive addition.</div><br/><div id="39312555" class="c"><input type="checkbox" id="c-39312555" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39312352">root</a><span>|</span><a href="#39312542">parent</a><span>|</span><a href="#39312500">next</a><span>|</span><label class="collapse" for="c-39312555">[-]</label><label class="expand" for="c-39312555">[1 more]</label></div><br/><div class="children"><div class="content">The only kernel stuff I already mentioned, there isn&#x27;t anything else.<p>On Office side, is yet again Azure infrastructure, which I also referred.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39312500" class="c"><input type="checkbox" id="c-39312500" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#39312352">prev</a><span>|</span><a href="#39312262">next</a><span>|</span><label class="collapse" for="c-39312500">[-]</label><label class="expand" for="c-39312500">[2 more]</label></div><br/><div class="children"><div class="content">I think the author cheats a little bit, because in the first example on &quot;IEF&quot; he compares a function declaration containing an explicit visibility modifier &quot;public&quot; to the default Rust version (private).<p>But in reality, omitting Java visibility keyword puts the function into the &quot;default&quot; visibility rules, which is package-private. So, public in the same package, but private when seen from other packages. So the impact is severily limited, depending on the architecture of the application (it&#x27;s de facto public for applications contained in 1 package).<p>Still, Rust version is more restrictive, so the point holds, but I think it should be fixed somehow.</div><br/><div id="39312692" class="c"><input type="checkbox" id="c-39312692" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#39312500">parent</a><span>|</span><a href="#39312262">next</a><span>|</span><label class="collapse" for="c-39312692">[-]</label><label class="expand" for="c-39312692">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I had the same reaction, it was a very bad strawman: the author had explicitly set the function to be public in the Java example, and then not done so in the Rust example, and then argued that Rust is safer. But that&#x27;s absurd: you deliberately made dropDatabase public in Java, which you could just as easily do in Rust by making it pub. The author just opted not to do that in order to argue that Rust is safer.<p>Your argument is fair that the &quot;default&quot; state in Rust is more restrictive, but the difference honestly is tiny. In practice, basically all Java code I&#x27;ve seen always explicitly states whether every function is private, public or protected, that&#x27;s just how you write Java. Should it be compiler-enforced that you always do so? Maybe, but we&#x27;re really splitting hairs here.</div><br/></div></div></div></div></div></div></div></div></div></body></html>