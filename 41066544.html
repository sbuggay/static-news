<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721984466086" as="style"/><link rel="stylesheet" href="styles.css?v=1721984466086"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mihaiolteanu.me/defense-of-lisp-macros">Defense of Lisp macros: The automotive field as a case in point</a>Â <span class="domain">(<a href="https://mihaiolteanu.me">mihaiolteanu.me</a>)</span></div><div class="subtext"><span>molteanu</span> | <span>161 comments</span></div><br/><div><div id="41068095" class="c"><input type="checkbox" id="c-41068095" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#41070225">next</a><span>|</span><label class="collapse" for="c-41068095">[-]</label><label class="expand" for="c-41068095">[55 more]</label></div><br/><div class="children"><div class="content">I was a bit baffled the first time I was introduced to Simulink Coder. I get the value proposition: simulate your model so that you have confidence it&#x27;s doing the right thing, and then essentially just run that model as code instead of implementing it yourself and possibly introducing mistakes. What I didn&#x27;t understand, as a software guy, not an engineering guy, was why on earth you&#x27;d want a <i>graphical</i> programming language to do that. Surely it would be easier to just write your model in a traditional text-based language. Hell, the same company even makes their own language (MATLAB) that would be perfect for the task.<p>I did a little digging, and it turns out I had it backwards. It&#x27;s not that Simulink invented a new graphical programming language to do this stuff. Control systems engineers have been studying and documenting systems using Simulink-style block diagrams since at least the 1960s. Simulink just took something that used to be a paper and chalkboard modeling tool and made it executable on a computer.</div><br/><div id="41068805" class="c"><input type="checkbox" id="c-41068805" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41075726">next</a><span>|</span><label class="collapse" for="c-41068805">[-]</label><label class="expand" for="c-41068805">[15 more]</label></div><br/><div class="children"><div class="content">Bingo.  Additionally, control theory block diagrams are pretty rigorous, with algebraic rules for manipulating them you&#x27;ll find in a controls textbook.  You can pretty much enter a block diagram from Apollo documentation into Simulink and &quot;run&quot; it, in much the same way you could run a spice simulation on a schematic from that era.</div><br/><div id="41072054" class="c"><input type="checkbox" id="c-41072054" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068805">parent</a><span>|</span><a href="#41075726">next</a><span>|</span><label class="collapse" for="c-41072054">[-]</label><label class="expand" for="c-41072054">[14 more]</label></div><br/><div class="children"><div class="content">Yeah, there&#x27;s a really interesting phenomenon that I&#x27;ve observed that goes with that. If what you&#x27;re describing was the main way people used it, I&#x27;d be very satisfied with that and have actually been chewing on ways to potentially bring those kinds of concepts into the more &quot;mainstream&quot; programming world (I&#x27;m not going to go way off on that tangent right now)<p>What I&#x27;ve seen many times though in my career that awkwardly spans EE and CS is that people forget that you can still... write equations instead of doing everything in Simulink. As an example I was looking at a simplified model of an aircraft a couple months ago.<p>One of the things it needed to compute was the density of air at a given altitude. This is a somewhat complicated equation that is a function of altitude, temperature (which can be modelled as a function of altitude), and some other stuff. These are, despite being a bit complicated, straightforward equations. The person who had made this model didn&#x27;t write the equations, though, they instead made a Simulink sub-model for it with a bunch of addition, multiplication, and division blocks in a ratsnest.<p>I think the Simulink approach should be used when it brings clarity to the problem, and should be abandoned when it obscures the problem. In this case it took a ton of mental energy to reassemble all of the blocks back into a simple closed-form equation and then further re-arranging to verify that it matched the textbook equation.</div><br/><div id="41072286" class="c"><input type="checkbox" id="c-41072286" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072054">parent</a><span>|</span><a href="#41072525">next</a><span>|</span><label class="collapse" for="c-41072286">[-]</label><label class="expand" for="c-41072286">[7 more]</label></div><br/><div class="children"><div class="content">I had an intern do something similar with an electromechanical machine.  I&#x27;d all but written the equations out for him but he found drawing it out in Simulink in the most fundamental, primitive blocks to help him understand what was going on . I don&#x27;t get it either.<p>A related phenomenon seems to be people who don&#x27;t want to &quot;wire up&quot; schematics but  attach named nets to every component and then draw boxes around them.</div><br/><div id="41072421" class="c"><input type="checkbox" id="c-41072421" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072286">parent</a><span>|</span><a href="#41073706">next</a><span>|</span><label class="collapse" for="c-41072421">[-]</label><label class="expand" for="c-41072421">[5 more]</label></div><br/><div class="children"><div class="content">&gt; people who don&#x27;t want to &quot;wire up&quot; schematics but attach named nets to every component and then draw boxes around them<p>Lol there are a few things that I am highly intolerant of and this is one of them. The only place where I&#x27;m generally ok with that approach is at the input connectors, the microcontroller, and the output connectors. Same philosophy as I said before though: &quot;if it brings clarity draw it as a wired up schematic; if it turns into a ratsnest use net labels to jump somewhere else&quot;. Having every component in a separate box with net labels will generally obscure what&#x27;s going on and just turns it into an easter egg hunt.</div><br/><div id="41072613" class="c"><input type="checkbox" id="c-41072613" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072421">parent</a><span>|</span><a href="#41074180">next</a><span>|</span><label class="collapse" for="c-41072613">[-]</label><label class="expand" for="c-41072613">[1 more]</label></div><br/><div class="children"><div class="content">Also, part of the style seems to be to contort any actual schematic to fit in the box.  I like to ask &quot;if you wouldn&#x27;t put it on its own page so you could draw it clearly, why did you draw a box around it?&quot;.</div><br/></div></div><div id="41074180" class="c"><input type="checkbox" id="c-41074180" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072421">parent</a><span>|</span><a href="#41072613">prev</a><span>|</span><a href="#41073706">next</a><span>|</span><label class="collapse" for="c-41074180">[-]</label><label class="expand" for="c-41074180">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really get this point of view. Take an I2C bus, for example. Isn&#x27;t it easier to read the schematic if all the components on the bus have two pins connected to wires labeled &#x27;SDA&#x27; and &#x27;SCL&#x27;?</div><br/><div id="41076573" class="c"><input type="checkbox" id="c-41076573" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41074180">parent</a><span>|</span><a href="#41074550">next</a><span>|</span><label class="collapse" for="c-41076573">[-]</label><label class="expand" for="c-41076573">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes, and it depends what you&#x27;re trying to convey.<p>Take a system with multiple I2C devices - with each device on a different sheet, it becomes difficult to tell that you might have bus contention issues.</div><br/></div></div><div id="41074550" class="c"><input type="checkbox" id="c-41074550" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41074180">parent</a><span>|</span><a href="#41076573">prev</a><span>|</span><a href="#41073706">next</a><span>|</span><label class="collapse" for="c-41074550">[-]</label><label class="expand" for="c-41074550">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, thereâs a balance here. There are common nets like SDA, SCL, GND, VCC that make sense to have as global nets. And then thereâs actual circuits where it makes more sense (for understandability) to not do it like that.<p>Hereâs an example that I think takes it too far: <a href="https:&#x2F;&#x2F;cdn.sparkfun.com&#x2F;datasheets&#x2F;Dev&#x2F;LilyPad&#x2F;LilyPad-MP3-v15a.pdf" rel="nofollow">https:&#x2F;&#x2F;cdn.sparkfun.com&#x2F;datasheets&#x2F;Dev&#x2F;LilyPad&#x2F;LilyPad-MP3-...</a><p>- The audio jack (line level) could have just sat to the right of the codec and been directly connected to it to make it clear that itâs just a direct output<p>- the speaker amplifier could be directly connected to the audio jack as well. I spent a lot of time looking around to figure out where it actually connects to; I figured it would have its input connected to the MP3 codec and didnât realize that it would be connected through the micro switches inside the headphone jack (which makes sense now that I see it)<p>- the SD card slot could either be connected directly to the codec or could have better names on the nets. When I see MOSI, MISO, and SCK I assume that theyâre connected to the main MCU. Even more confusing, thereâs an SD-CS that is connected to the MCU but not the rest of the SPI pins<p>Overall Iâd probably give this one a B. Itâs by no means the most egregious Iâve seen but it also obscures the signal flow pretty badly.<p>Other things I would probably consider doing:<p>- better clustering of pins on the MCU by function. The switch inputs and LED outputs that connect to the rotary encoder are all over the place. Most tools allow you to move the pins on microcontrollers around at will<p>- the FTDI block could move onto the first page. The DTR pin could use a bit of explanation that itâs tied to the reset circuit. Not their fault in this one but the naming inconsistency between 
FTDI-RXI and TRIG4&#x2F;TXO is confusing until you figure out that the pin is meant to be either a GPIO or a UART pin. The name doesnât make it clear that it goes to the FTDI chip because itâs inconsistent with the rest of the FTDI-xxx names but thatâs because most ECAD programs handle net names poorly anyway<p>Edit: one more thing that really bugs me about this schematic: the Vbatt net leaving J1. Itâs labelled but not with any kind of flag or loose&#x2F;unterminated line that would indicate that itâs connected to the net leaving U2. And further with that, the fact that VIN on U2 comes <i>only</i> from the FTDI connector on the second page (I thinkâ¦)</div><br/></div></div></div></div></div></div><div id="41073706" class="c"><input type="checkbox" id="c-41073706" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072286">parent</a><span>|</span><a href="#41072421">prev</a><span>|</span><a href="#41072525">next</a><span>|</span><label class="collapse" for="c-41073706">[-]</label><label class="expand" for="c-41073706">[1 more]</label></div><br/><div class="children"><div class="content">I think using the drawing it out process to understand initially is ... not how my brain would do it, but seems like a perfectly valid approach.<p>But once you -do- understand it&#x27;s time to stick that in a reference file out of the way and write it again properly for actual use.</div><br/></div></div></div></div><div id="41072525" class="c"><input type="checkbox" id="c-41072525" checked=""/><div class="controls bullet"><span class="by">singleshot_</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072054">parent</a><span>|</span><a href="#41072286">prev</a><span>|</span><a href="#41072437">next</a><span>|</span><label class="collapse" for="c-41072525">[-]</label><label class="expand" for="c-41072525">[1 more]</label></div><br/><div class="children"><div class="content">One cool thing about, for instance, density altitude calculations or runway length calculations, is that you can break the parts of the algorithm down graphically do pilots can trace through datapoints to get an answer without even having a calculator. See many pilot operating handbooks for examples.</div><br/></div></div><div id="41072437" class="c"><input type="checkbox" id="c-41072437" checked=""/><div class="controls bullet"><span class="by">mighmi</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072054">parent</a><span>|</span><a href="#41072525">prev</a><span>|</span><a href="#41075726">next</a><span>|</span><label class="collapse" for="c-41072437">[-]</label><label class="expand" for="c-41072437">[5 more]</label></div><br/><div class="children"><div class="content">Where can I read about your project or hear your tangent?</div><br/><div id="41072875" class="c"><input type="checkbox" id="c-41072875" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072437">parent</a><span>|</span><a href="#41075726">next</a><span>|</span><label class="collapse" for="c-41072875">[-]</label><label class="expand" for="c-41072875">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m hoping at a minimum get my thoughts written out while I&#x27;m flying this weekend!<p>The quick gist is that Jupyter is frustrating for me because it&#x27;s so easy to end up in a situation where you inadvertently end up with a cell higher up in your document that is using a value computed in a cell further down. It&#x27;s all just one global namespace.<p>In the Julia world with Pluto they get around this by restricting what can go into cells a little bit (e.g. you have to do some gymnastics if you&#x27;re going to try to assign more than one variable in a single cell); by doing it this way they can do much better dependency analysis and determine a valid ordering of your cells. It&#x27;s just fine to move a bunch of calculation code to the end&#x2F;appendix of your document and use the values higher up.<p>The idea I&#x27;ve been chewing on comes somewhat from using Obsidian and their whole infinite canvas idea. It seems like using ideas from Pluto around dependency analysis and being able to also determine whether the contents of a given cell are pure or not (i.e. whether they do IO or other syscalls, or will provide outputs that are solely a function of their inputs) should be able to make it easier to do something... notebook-like that benefits from cached computations while also having arbitrary computation graphs and kind of an infinite canvas of data analysis. Thinking like a circuit simulator, it should be possible to connect a &quot;scope&quot; onto the lines between cells to easily make plots on the fly to visualize what&#x27;s happening.<p>Anyway, that&#x27;s the quick brain dump. It&#x27;s not well-formed at all yet. And honestly I would be delighted if someone reads this and steals the idea and builds it themselves so that I can just an off-the-shelf tool that doesn&#x27;t frustrate me as much as Jupyter does :)</div><br/><div id="41073265" class="c"><input type="checkbox" id="c-41073265" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072875">parent</a><span>|</span><a href="#41075726">next</a><span>|</span><label class="collapse" for="c-41073265">[-]</label><label class="expand" for="c-41073265">[3 more]</label></div><br/><div class="children"><div class="content">it sounds like the ideal solution would be something functional (so you have a computation graph), pure (so you can cache results) and lazy (so order of expressions doesn&#x27;t matter.) why not Haskell? or even a pure&#x2F;lazy subset&#x2F;variant of Julia, if you want to ditch the baggage of Haskell&#x27;s type bondage?<p>you could ditch explicit cells entirely, and implement your &quot;scope&quot; by selecting a (sub)expression and spying on the inputs&#x2F;outputs.</div><br/><div id="41073401" class="c"><input type="checkbox" id="c-41073401" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41073265">parent</a><span>|</span><a href="#41075378">next</a><span>|</span><label class="collapse" for="c-41073401">[-]</label><label class="expand" for="c-41073401">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve thought about that and have written some fun Haskell code in the past but... the other goal is to actually have users :D. I&#x27;ve also considered Lisp, Scheme, and friends to have really easily parseable ASTs.<p>I jest a bit, but there&#x27;s a very rich ecosystem of really useful data analysis libraries with Python that do somewhat exist in other ecosystems (R, Julia, etc) but aren&#x27;t nearly as... I would use the word polish, but a lot of the Python libraries have sharp edges as well. Well trodden might be a better word. My experience with doing heavy data analysis with Python and Julia is that both of them are often going to require some Googling to understand a weird pattern to accomplish something effectively but there&#x27;s a much higher probability that you&#x27;re going to find the answer quickly with Python.<p>I also don&#x27;t really want to reinvent the universe on the first go.<p>It has occurred to me that it might be possible to do this in a style similar to org-mode though where it actually doesn&#x27;t care what the underlying language is and you could just weave a bunch of languages together. Rust code interfacing with some hardware, C++ doing the Kalman filter, Python (via geopandas) doing geospatial computation, and R (via ggplot2) rendering the output. There&#x27;s a data marshalling issue there of course, which I&#x27;ve also not spent too many cycles thinking about yet :)<p>Edit: I did copy and paste your comment into my notebook for chewing on while I&#x27;m travelling this weekend. Thanks for riffing with me!</div><br/></div></div><div id="41075378" class="c"><input type="checkbox" id="c-41075378" checked=""/><div class="controls bullet"><span class="by">smw</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41073265">parent</a><span>|</span><a href="#41073401">prev</a><span>|</span><a href="#41075726">next</a><span>|</span><label class="collapse" for="c-41075378">[-]</label><label class="expand" for="c-41075378">[1 more]</label></div><br/><div class="children"><div class="content">Elixir livebook does this</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41075726" class="c"><input type="checkbox" id="c-41075726" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41068805">prev</a><span>|</span><a href="#41068200">next</a><span>|</span><label class="collapse" for="c-41075726">[-]</label><label class="expand" for="c-41075726">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Control systems engineers have been studying and documenting systems using Simulink-style block diagrams since at least the 1960s.<p>It dates to at least the 1940s with signal flow graphs (1) but from what I&#x27;ve heard, Shannon was working on fire control systems for the Navy and his work was classified. Some of that was famously published in <i>A Mathematical Theory of Communication</i> (2) where there are block diagrams for information systems, and Mason worked out Mason&#x27;s Gain Rule&#x2F;Formula in the early 1950s.<p>I would not be surprised if graphical representations date back to the 1920s&#x2F;30s when abstracting electrical systems into things like circuit diagrams that ignore grounding were pretty common, or even earlier.<p>(1) <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signal-flow_graph" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signal-flow_graph</a></div><br/></div></div><div id="41068200" class="c"><input type="checkbox" id="c-41068200" checked=""/><div class="controls bullet"><span class="by">jocaal</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41075726">prev</a><span>|</span><a href="#41075471">next</a><span>|</span><label class="collapse" for="c-41068200">[-]</label><label class="expand" for="c-41068200">[26 more]</label></div><br/><div class="children"><div class="content">The people using matlab are typically experts in things other than programming. Matlab is for people designing antennas or control systems, where the math is more important than the code.</div><br/><div id="41068231" class="c"><input type="checkbox" id="c-41068231" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068200">parent</a><span>|</span><a href="#41068286">next</a><span>|</span><label class="collapse" for="c-41068231">[-]</label><label class="expand" for="c-41068231">[18 more]</label></div><br/><div class="children"><div class="content">Most definitely, but my point was to my programmer-brain, nearly any text-based modeling language would be better than some sort of awkward graphical diagram. And since the same company makes MATLAB, why not?<p>It turns out non-programmers actually like graphical tools. Go figure.</div><br/><div id="41069860" class="c"><input type="checkbox" id="c-41069860" checked=""/><div class="controls bullet"><span class="by">FredPret</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068231">parent</a><span>|</span><a href="#41074489">next</a><span>|</span><label class="collapse" for="c-41069860">[-]</label><label class="expand" for="c-41069860">[6 more]</label></div><br/><div class="children"><div class="content">I once wrote a linear programming optimal solver for a business problem.<p>But because it was all equations and logical reasoning, it was hard to understand, and boring to non-enthusiasts.<p>So my manager had me make a visual simulation instead, which we could then present to his managers.<p>This isn&#x27;t as stupid as it sounds - we humans have huge visual processing networks. It makes sense to tap into that when interfacing with other humans.<p>I think to learn programming or math, you actually end up learning to use this visual wiring to think about written symbols. But this process of rewiring - while valuable - is very hard and slow, and only a tiny fraction of humans have gone through it.</div><br/><div id="41070300" class="c"><input type="checkbox" id="c-41070300" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069860">parent</a><span>|</span><a href="#41074489">next</a><span>|</span><label class="collapse" for="c-41070300">[-]</label><label class="expand" for="c-41070300">[5 more]</label></div><br/><div class="children"><div class="content">Related to the visual simulations, one of Alan Kay&#x27;s favorite demos over the years has been to show folks Sketchpad,<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=495nCzxM9PI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=495nCzxM9PI</a><p>partly as a &quot;this is what we were doing in 1962, you are now as far removed from that demo as that demo was removed from the year 1900 -- do you really feel like you&#x27;ve made the analogous&#x2F;concomitant progress in programming?&quot; ... and one of his points there was that a lot of programming acts as a &quot;pop music&quot; where you are trying to replicate the latest new sounds and marginally iterate on those, rather than study the classics and the greats and the legacy of awesome things that had been done in the past.</div><br/><div id="41071726" class="c"><input type="checkbox" id="c-41071726" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41070300">parent</a><span>|</span><a href="#41074489">next</a><span>|</span><label class="collapse" for="c-41071726">[-]</label><label class="expand" for="c-41071726">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re trying to say here.<p>That specialist interfaces make you productive?<p>Sketchpad was just a cad tool, one of the first ones to be sure, but still a design tool.<p>We have substantially better ones today: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CIa4LpqI2EI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CIa4LpqI2EI</a><p>So in 62 years have we improved the state of the art in design by as much as between 1900 to 1962?<p>Yes. I&#x27;d say we have and more.</div><br/><div id="41072263" class="c"><input type="checkbox" id="c-41072263" checked=""/><div class="controls bullet"><span class="by">zogrodea</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41071726">parent</a><span>|</span><a href="#41073197">next</a><span>|</span><label class="collapse" for="c-41072263">[-]</label><label class="expand" for="c-41072263">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just putting this Alan Kay question (from Stack Overflow) here because of relevance.<p>In that question, he&#x27;s considered not with implementation or how good the execution of an idea is (which is certainly one type of progress), but in genuinely new ideas.<p>I don&#x27;t think I personally am qualified to say yes or no. There are new data structures since then for example, but those tend to be improvements over existing ideas rather than &quot;fundamental new ideas&quot; which I understand him (perhaps wrongly) to be asking for.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;432922&#x2F;significant-new-inventions-in-computing-since-1980" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;432922&#x2F;significant-new-i...</a></div><br/></div></div><div id="41073197" class="c"><input type="checkbox" id="c-41073197" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41071726">parent</a><span>|</span><a href="#41072263">prev</a><span>|</span><a href="#41074489">next</a><span>|</span><label class="collapse" for="c-41073197">[-]</label><label class="expand" for="c-41073197">[2 more]</label></div><br/><div class="children"><div class="content">this is awfully manual, does autocad have parametric topology tools ?<p>programs like houdini are more reactive and mathematical (no need to create width&#x2F;volume by hand and trim intersections by hand), i think mech engineering tools (memory fail here) have options like this</div><br/><div id="41075532" class="c"><input type="checkbox" id="c-41075532" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41073197">parent</a><span>|</span><a href="#41074489">next</a><span>|</span><label class="collapse" for="c-41075532">[-]</label><label class="expand" for="c-41075532">[1 more]</label></div><br/><div class="children"><div class="content">No idea, I mostly use freecad and I&#x27;ve been told autocad has more tools.<p>In freecard there are parametric tools which are very much like what was shown in the demo but in 3d.<p>I tend to use script which render to openscad for the parts that I want to be parametric.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41074489" class="c"><input type="checkbox" id="c-41074489" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068231">parent</a><span>|</span><a href="#41069860">prev</a><span>|</span><a href="#41069363">next</a><span>|</span><label class="collapse" for="c-41074489">[-]</label><label class="expand" for="c-41074489">[1 more]</label></div><br/><div class="children"><div class="content">One thing that I think diagrams are better at than common text-base PLs is that with diagrams (when the blocks are placed nicely) you can _very quickly_ tell what is going into something (both directly and indirectly).<p>Of course you can abstract away a bit with functions or intermediate values in programming, but at one point if you do that too much you now have a bunch of indirection that harms overall readability.<p>All a balance of course, but &quot;what takes part in this calculation&quot; often feels more valuable than &quot;what is the calculation itself&quot;.</div><br/></div></div><div id="41069363" class="c"><input type="checkbox" id="c-41069363" checked=""/><div class="controls bullet"><span class="by">jocaal</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068231">parent</a><span>|</span><a href="#41074489">prev</a><span>|</span><a href="#41068304">next</a><span>|</span><label class="collapse" for="c-41069363">[-]</label><label class="expand" for="c-41069363">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It turns out non-programmers actually like graphical tools. Go figure.<p>I&#x27;d rather say that visual tools are better abstractions than what text based tools can provide for those specific scenarios. Some problems are easier solved with diagrams.</div><br/><div id="41073159" class="c"><input type="checkbox" id="c-41073159" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069363">parent</a><span>|</span><a href="#41068304">next</a><span>|</span><label class="collapse" for="c-41073159">[-]</label><label class="expand" for="c-41073159">[1 more]</label></div><br/><div class="children"><div class="content">text is bad with cross reference and impact.. every time your problem grows too many of them you end up charting a diagram</div><br/></div></div></div></div><div id="41068304" class="c"><input type="checkbox" id="c-41068304" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068231">parent</a><span>|</span><a href="#41069363">prev</a><span>|</span><a href="#41069546">next</a><span>|</span><label class="collapse" for="c-41068304">[-]</label><label class="expand" for="c-41068304">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve linked this thread from HN in the article about visual programming, if you find it useful or insightful,<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14484244">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14484244</a></div><br/></div></div><div id="41069546" class="c"><input type="checkbox" id="c-41069546" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068231">parent</a><span>|</span><a href="#41068304">prev</a><span>|</span><a href="#41068286">next</a><span>|</span><label class="collapse" for="c-41069546">[-]</label><label class="expand" for="c-41069546">[7 more]</label></div><br/><div class="children"><div class="content">Programmers just don&#x27;t like switching between representations - it&#x27;s the same reason that &quot;printf debugging&quot; will still be widespread after all of us are gone.</div><br/><div id="41071402" class="c"><input type="checkbox" id="c-41071402" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069546">parent</a><span>|</span><a href="#41070028">next</a><span>|</span><label class="collapse" for="c-41071402">[-]</label><label class="expand" for="c-41071402">[1 more]</label></div><br/><div class="children"><div class="content">Printf debugging is actually a very primitive case of predicate reasoning. Hopefully in the not too distant future instead of using prints to check our assumptions about the code we will instead statically check them as SMT solvable assertions.</div><br/></div></div><div id="41070028" class="c"><input type="checkbox" id="c-41070028" checked=""/><div class="controls bullet"><span class="by">archgoon</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069546">parent</a><span>|</span><a href="#41071402">prev</a><span>|</span><a href="#41068286">next</a><span>|</span><label class="collapse" for="c-41070028">[-]</label><label class="expand" for="c-41070028">[5 more]</label></div><br/><div class="children"><div class="content">Printf debugging will exist for as long as access to logs is easier than direct access to memory.</div><br/><div id="41073368" class="c"><input type="checkbox" id="c-41073368" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41070028">parent</a><span>|</span><a href="#41073761">next</a><span>|</span><label class="collapse" for="c-41073368">[-]</label><label class="expand" for="c-41073368">[1 more]</label></div><br/><div class="children"><div class="content">Another thing is the ability to actually have a breakpoint in the program. There is a lot of distributed systems (especially embedded ones) where just stoping the program and inspecting the state will cause the rest of the system to enter some kind of failure state.</div><br/></div></div><div id="41073761" class="c"><input type="checkbox" id="c-41073761" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41070028">parent</a><span>|</span><a href="#41073368">prev</a><span>|</span><a href="#41070721">next</a><span>|</span><label class="collapse" for="c-41073761">[-]</label><label class="expand" for="c-41073761">[1 more]</label></div><br/><div class="children"><div class="content">I use printf debugging locally as well. Interactive debuggers and I just don&#x27;t get on, and my test cases are built to start fast enough that it works out for me. Usually I have a &#x27;debug_stderr&#x27; function of some sort that serialises + writes its argument and then returns it so I can stick it in the middle of expressions.<p>(I do make sure that anybody learning from me understands that debuggers are not evil, they&#x27;re just not my thing, and that shouldn&#x27;t stop everybody else at least trying to learn to use them)</div><br/></div></div><div id="41070721" class="c"><input type="checkbox" id="c-41070721" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41070028">parent</a><span>|</span><a href="#41073761">prev</a><span>|</span><a href="#41068286">next</a><span>|</span><label class="collapse" for="c-41070721">[-]</label><label class="expand" for="c-41070721">[2 more]</label></div><br/><div class="children"><div class="content">Sure, that&#x27;s just one use case.  And logs can be useful for history as well as current state.  But I think it&#x27;s the mode shift to &quot;do I set a breakpoint here, and then inspect the program state&quot; as opposed to just continuing to sling code to print the state out.</div><br/><div id="41072925" class="c"><input type="checkbox" id="c-41072925" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41070721">parent</a><span>|</span><a href="#41068286">next</a><span>|</span><label class="collapse" for="c-41072925">[-]</label><label class="expand" for="c-41072925">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s funny is that I learned to debug with breakpoints, stepping, and inspectors. I use printf debugging now because the more experience you get, the easier and faster it becomes. There&#x27;s a point where it&#x27;s just a faster tool to validate your mental model than watching values churn in memory.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41068286" class="c"><input type="checkbox" id="c-41068286" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068200">parent</a><span>|</span><a href="#41068231">prev</a><span>|</span><a href="#41075471">next</a><span>|</span><label class="collapse" for="c-41068286">[-]</label><label class="expand" for="c-41068286">[7 more]</label></div><br/><div class="children"><div class="content">Well, software developers in the embedded field of automotive use Matlab and Simulink quite extensively. I haven&#x27;t worked with it myself but the &quot;excuse&quot; for using it was that &quot;we have complicated state machines that would be difficult to write directly in C&quot;.</div><br/><div id="41069274" class="c"><input type="checkbox" id="c-41069274" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068286">parent</a><span>|</span><a href="#41069431">next</a><span>|</span><label class="collapse" for="c-41069274">[-]</label><label class="expand" for="c-41069274">[4 more]</label></div><br/><div class="children"><div class="content">You would think about a lot of the things that they do, &quot;how hard can it be?&quot;.  Take a look at the <i>simplified</i> example statechart here (scroll down) for a power window control and ponder all the ways an embedded programmer could struggle to get the behavior right in plain procedural C code as well as how difficult it would be to get a typical team to document their design intent.<p><a href="https:&#x2F;&#x2F;www.mathworks.com&#x2F;help&#x2F;simulink&#x2F;ug&#x2F;power-window-example-case-study.html" rel="nofollow">https:&#x2F;&#x2F;www.mathworks.com&#x2F;help&#x2F;simulink&#x2F;ug&#x2F;power-window-exam...</a><p>Where statechart design is appropriate, it is a very powerful tool.</div><br/><div id="41073869" class="c"><input type="checkbox" id="c-41073869" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069274">parent</a><span>|</span><a href="#41069431">next</a><span>|</span><label class="collapse" for="c-41073869">[-]</label><label class="expand" for="c-41073869">[3 more]</label></div><br/><div class="children"><div class="content">Those do strike me as elucidating the power in suitable contexts very nicely.<p>For those following along at home, click <a href="https:&#x2F;&#x2F;uk.mathworks.com&#x2F;help&#x2F;simulink&#x2F;ug&#x2F;powerwindow_02.png" rel="nofollow">https:&#x2F;&#x2F;uk.mathworks.com&#x2F;help&#x2F;simulink&#x2F;ug&#x2F;powerwindow_02.png</a> first and then realise that&#x27;s a top level chart with per-case sub charts (and then follow buescher&#x27;s link if you want to see those) ... and that at the very least this is probably the Correct approach to developing and documenting a design for something like that.<p>Thank you kindly for the Informative Example.</div><br/><div id="41074076" class="c"><input type="checkbox" id="c-41074076" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41073869">parent</a><span>|</span><a href="#41069431">next</a><span>|</span><label class="collapse" for="c-41074076">[-]</label><label class="expand" for="c-41074076">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re welcome, and yeah, that is the statechart.  It&#x27;s actually at the low zoomed-in level.  That&#x27;s the controller at the heart of the example.  A lot of the diagrams in the article are higher-level, not sub-charts.   I am not a 100% advocate for the BDUF-flavored model-driven-design approach in the whole document at that link, though I can understand why some industries would take it.<p>Remember, too, this is undoubtedly a simplified example.  Just off the cuff I&#x27;d expect a real-world window motor controller in 2024 to have at least open-loop ramp-up and ramp-down in speed, if not closed-loop speed control.  I also would expect there&#x27;d be more to their safety requirements.</div><br/><div id="41074197" class="c"><input type="checkbox" id="c-41074197" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41074076">parent</a><span>|</span><a href="#41069431">next</a><span>|</span><label class="collapse" for="c-41074197">[-]</label><label class="expand" for="c-41074197">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of the diagrams in the article are higher-level, not sub-charts.<p>I must have failed to understand even more things than I thought I did. I&#x27;ll have to read through again when more awake if I want to fix that, I suspect.<p>I think if faced with that class of problem (am not automative developer, just spitballing) I would probably try using some sort of (no, not YAML) config format to express the various things.<p>But that&#x27;s a &#x27;how my brain works&#x27; and I am aware of that - for database designs, I&#x27;ve both ensured there was a reasonable diagram generated when the point of truth was a .sql file, and happily accepted an ERD as the point of truth once I figured out how to get a .sql file out of it to review myself.</div><br/></div></div></div></div></div></div></div></div><div id="41069431" class="c"><input type="checkbox" id="c-41069431" checked=""/><div class="controls bullet"><span class="by">jocaal</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068286">parent</a><span>|</span><a href="#41069274">prev</a><span>|</span><a href="#41068829">next</a><span>|</span><label class="collapse" for="c-41069431">[-]</label><label class="expand" for="c-41069431">[1 more]</label></div><br/><div class="children"><div class="content">What they didn&#x27;t tell you is that these state-machines are differential equations as well. Again, the math is more important than the code. If you want to look more into it, just search for state variable control.</div><br/></div></div><div id="41068829" class="c"><input type="checkbox" id="c-41068829" checked=""/><div class="controls bullet"><span class="by">pantsforbirds</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068286">parent</a><span>|</span><a href="#41069431">prev</a><span>|</span><a href="#41075471">next</a><span>|</span><label class="collapse" for="c-41068829">[-]</label><label class="expand" for="c-41068829">[1 more]</label></div><br/><div class="children"><div class="content">Matlab also solves a ton of common engineering problems with efficient BLAS wrappers. And it is (or at least used to be) pretty trivial to drop in a CUDA kernel for hotter code paths.<p>It&#x27;s still great for simulation work imo.</div><br/></div></div></div></div></div></div><div id="41075471" class="c"><input type="checkbox" id="c-41075471" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41068200">prev</a><span>|</span><a href="#41068884">next</a><span>|</span><label class="collapse" for="c-41075471">[-]</label><label class="expand" for="c-41075471">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the anecdotal perspective. That&#x27;s interesting!<p>As someone who cut their teeth on a graphical language and is a big diagramming person, it&#x27;s always been curious to me as to why people want to write out stuff in text. It often feels extremely primitive. I&#x27;ve done large codebases in a graphical language before, and it felt so easy to orient myself as to where I was at in the system. In text-based languages, I feel lost in a sea of text that has almost zero differentiating factors.</div><br/><div id="41075490" class="c"><input type="checkbox" id="c-41075490" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41075471">parent</a><span>|</span><a href="#41068884">next</a><span>|</span><label class="collapse" for="c-41075490">[-]</label><label class="expand" for="c-41075490">[1 more]</label></div><br/><div class="children"><div class="content">There are lots of reason for why text is preferable though. I did some work on an drag-and-drop sort of a programming language for a ETL pipeline a while back. The absence of unit test cases makes it very hard to deploy changes without being sure you are not introducing breaking changes. There are other things as well. People tend to make big flow in one canvas. Which makes it very hard to understand.<p>There are few more things, like wherever a GUI component relevant to a case was missing, the tool provided a way to add a javascript snippet, eventually on some canvases all you see is JS components talking to each other. At that point you are better off writing plain JS code.</div><br/></div></div></div></div><div id="41068884" class="c"><input type="checkbox" id="c-41068884" checked=""/><div class="controls bullet"><span class="by">dugmartin</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41075471">prev</a><span>|</span><a href="#41072844">next</a><span>|</span><label class="collapse" for="c-41068884">[-]</label><label class="expand" for="c-41068884">[5 more]</label></div><br/><div class="children"><div class="content">I used to work on GE&#x27;s programmable logic controller product on the realtime OS side.  PLCs are primarily programmed in ladder logic (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ladder_logic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ladder_logic</a>) and we had a full graphical UI to do that.  IIRC (its been nearly 30 years) we also had a parser that parsed text based ladder logic diagrams to drive the OS tests.</div><br/><div id="41069045" class="c"><input type="checkbox" id="c-41069045" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068884">parent</a><span>|</span><a href="#41070124">next</a><span>|</span><label class="collapse" for="c-41069045">[-]</label><label class="expand" for="c-41069045">[3 more]</label></div><br/><div class="children"><div class="content">Ladder logic is sort of a similar case right?  Supposedly it derives from notation  for documenting relay racks in factory automation that could very well date to the 1800s.  And it&#x27;s a pretty brilliant implementation - you don&#x27;t need a degreed engineer or C programmer to set up fairly sophisticated <i>concurrent</i> system with it.</div><br/><div id="41073496" class="c"><input type="checkbox" id="c-41073496" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069045">parent</a><span>|</span><a href="#41070076">next</a><span>|</span><label class="collapse" for="c-41073496">[-]</label><label class="expand" for="c-41073496">[1 more]</label></div><br/><div class="children"><div class="content">The idea behind that is neat. And well, the conversion from the ladder diagram to PLC bytecode is intentionally so trivial that it can be done by hand if the ladder diagram is drawn in certain way (which is the way the first PLCs were programmed).<p>Then there is the reality: every single one of Simatic projects I have seen was done by âPLC programmersâ and had this peculiar feature of using the abstractions the wrong way around. Straightforward logic written as Instruction Lists (ie. assembly that produces the bytecode) and things that were straightforward sequential programming built from ridiculously complex schematic diagrams.</div><br/></div></div><div id="41070076" class="c"><input type="checkbox" id="c-41070076" checked=""/><div class="controls bullet"><span class="by">dugmartin</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41069045">parent</a><span>|</span><a href="#41073496">prev</a><span>|</span><a href="#41070124">next</a><span>|</span><label class="collapse" for="c-41070076">[-]</label><label class="expand" for="c-41070076">[1 more]</label></div><br/><div class="children"><div class="content">Yes it is very similar and as you say the notation lets you define really complex concurrent logic.</div><br/></div></div></div></div><div id="41070124" class="c"><input type="checkbox" id="c-41070124" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41068884">parent</a><span>|</span><a href="#41069045">prev</a><span>|</span><a href="#41072844">next</a><span>|</span><label class="collapse" for="c-41070124">[-]</label><label class="expand" for="c-41070124">[1 more]</label></div><br/><div class="children"><div class="content">Any Ladder logic editor would have two views: the block view and the text view.
I used to work on Siemens PLCs. I started using only the block view, but over time migrated to only using the text view.
Now, I understand that the text view is basically a kind of Assembler. I liked it because I was able to think and visualize things in my head much better using text. But for simple flows, and people not versed in programming, the only option, really, is the block view.</div><br/></div></div></div></div><div id="41072844" class="c"><input type="checkbox" id="c-41072844" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41068884">prev</a><span>|</span><a href="#41071105">next</a><span>|</span><label class="collapse" for="c-41072844">[-]</label><label class="expand" for="c-41072844">[3 more]</label></div><br/><div class="children"><div class="content">Simulink is a really nice way to do some control problems in.<p>Like, the &#x27;flow&#x27; is really clear. Adding a feedback, saturation or integral or whatever is clear to the eye.<p>Stateflow charts are also a really nice way to do statemachines, which are used alot in automotive.<p>Simulink is terrible in many ways too, but in some perverted way I like it for the specific usecase.</div><br/><div id="41073099" class="c"><input type="checkbox" id="c-41073099" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41072844">parent</a><span>|</span><a href="#41071105">next</a><span>|</span><label class="collapse" for="c-41073099">[-]</label><label class="expand" for="c-41073099">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Simulink is a really nice way to do some control problems in.<p>Agreed. But it needs to stop there. BTW I never understood why the tool needs to know what processor the code is for. I asked them to provide a C99 target so they don&#x27;t need to define their own data types in generated code. Does that exist yet? Or do they still define their own UINT_16 types depending on the target?</div><br/><div id="41074525" class="c"><input type="checkbox" id="c-41074525" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#41068095">root</a><span>|</span><a href="#41073099">parent</a><span>|</span><a href="#41071105">next</a><span>|</span><label class="collapse" for="c-41074525">[-]</label><label class="expand" for="c-41074525">[1 more]</label></div><br/><div class="children"><div class="content">Dunno and I haven&#x27;t worked with Simulink since 2019. There is this &quot;type replacement&quot; setting such that you can make Coder spit out &quot;uint16_t&quot; instead, but if I remember correctly, there was bugs such that you still needed to have the manual translation header. Like, some module of Simulink didn&#x27;t follow the setting. God I don&#x27;t miss working with Mathworks products.<p>&gt; Agreed. But it needs to stop there.<p>Heh. Ye ... about that.</div><br/></div></div></div></div></div></div><div id="41071105" class="c"><input type="checkbox" id="c-41071105" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41072844">prev</a><span>|</span><a href="#41072943">next</a><span>|</span><label class="collapse" for="c-41071105">[-]</label><label class="expand" for="c-41071105">[1 more]</label></div><br/><div class="children"><div class="content">This gets to a fairly stark difference in how people model things.  It is very common to model things in ways that are close to what is physically being described.  Is why circuit simulators often let you show where and how the circuits are connected.  Knowing what all can run at the same time is now very clear and knowing what can and cannot be reduced to each other is the same.  If they are separate things in the model, then they remain separate.<p>Contrast this with symbolic code.  Especially with the advent of optimizing compilers, you get very little to no reliable intuition on the order things operate.  Or, even, how they operate.<p>Now, this is even crazier when you consider how people used to model things mathematically.  It really drives home why people used to be far more interested in polynomials and such.  Those were the bread and butter of mathematical modelling for a long time.  Nowadays, we have moved far more strongly into a different form of metaphor for our modeling.</div><br/></div></div><div id="41072943" class="c"><input type="checkbox" id="c-41072943" checked=""/><div class="controls bullet"><span class="by">GabeIsko</span><span>|</span><a href="#41068095">parent</a><span>|</span><a href="#41071105">prev</a><span>|</span><a href="#41070225">next</a><span>|</span><label class="collapse" for="c-41072943">[-]</label><label class="expand" for="c-41072943">[1 more]</label></div><br/><div class="children"><div class="content">This is kind of the mixed feeling I have about this blog post. There is a recognition that we need universal tools that are designed with honest intentions to be effective in general problem domains. But determining the boundaries of those domains is ultimately a political exercise and not a technical one.<p>It becomes presumptive to assume that Lisp is the be all, end all of car networking woes. Even if you accept that a tool to manage and organize computational tasks using a more functional paradigm would be helpful, that doesn&#x27;t mean that a somewhat archaic, syntactically maligned language is the answer.<p>ROS tackles this somewhat yeah? But it&#x27;s still very much a research project, despite its use in some parts of industry. The most significant development for computation in vehicles in recent times is still the automotive Linux efforts, so we are not really even in the ballpark to discuss specific languages.</div><br/></div></div></div></div><div id="41070225" class="c"><input type="checkbox" id="c-41070225" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41068095">prev</a><span>|</span><a href="#41075997">next</a><span>|</span><label class="collapse" for="c-41070225">[-]</label><label class="expand" for="c-41070225">[15 more]</label></div><br/><div class="children"><div class="content">Without Lisp-like macros, you need preprocessors or code generators.  Something like Yacc&#x2F;Bison is easily done with suitable macros.<p>In Common Lisp, macros also enable a kind of Aspect Oriented Programming.  That&#x27;s because one can dynamically modify macro expansion using the macroexpand hook.  It&#x27;s a way to modify a code base without changing the source files, which has all sorts of uses.<p><a href="http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;v_mexp_h.htm#STmacroexpand-hookST" rel="nofollow">http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;v_mexp_h.htm#STmacroexpand-hookST</a><p>One can implement things natively in Common Lisp, like code coverage tools, that require separate tooling in other languages.</div><br/><div id="41072020" class="c"><input type="checkbox" id="c-41072020" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#41070225">parent</a><span>|</span><a href="#41073553">next</a><span>|</span><label class="collapse" for="c-41072020">[-]</label><label class="expand" for="c-41072020">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a way to modify a code base without changing the source files<p>Is another way of saying your source files might not do what they say! You&#x27;re not selling it to me.</div><br/><div id="41076292" class="c"><input type="checkbox" id="c-41076292" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41072020">parent</a><span>|</span><a href="#41073937">next</a><span>|</span><label class="collapse" for="c-41076292">[-]</label><label class="expand" for="c-41076292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; your source files might not do what they say!<p>The disconnect between what your source file &quot;does&quot; and what it &quot;says&quot; is present in everything above assembly.<p>Change implementation of `foo(...)` and suddenly dozens of source files (none of which is modified!) which make calls like `foo(x)`, `foo(y)` and `foo(y+1)` change what they &quot;do&quot;, all this without changing a single line in these files.</div><br/></div></div><div id="41073937" class="c"><input type="checkbox" id="c-41073937" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41072020">parent</a><span>|</span><a href="#41076292">prev</a><span>|</span><a href="#41072218">next</a><span>|</span><label class="collapse" for="c-41073937">[-]</label><label class="expand" for="c-41073937">[1 more]</label></div><br/><div class="children"><div class="content">Wrapping the existing code in hooks of some sort to enable injecting profiling or whatever is really quite nice.<p>A lot of javascript hot reloading implementations rely on using Babel to do that as part of a build step so they output the wrapped code and your app loads that instead (and it&#x27;s not that dissimilar to compilers having a debug mode where they output very different code).<p>I would certainly side-eye you for using the relevant common lisp hooks in production without a very convincing reason, but for many development time tasks it&#x27;s basically the civilised version of widely used techniques.</div><br/></div></div><div id="41072218" class="c"><input type="checkbox" id="c-41072218" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41072020">parent</a><span>|</span><a href="#41073937">prev</a><span>|</span><a href="#41073416">next</a><span>|</span><label class="collapse" for="c-41072218">[-]</label><label class="expand" for="c-41072218">[1 more]</label></div><br/><div class="children"><div class="content">A use case is code coverage: you can instrument your code by compiling it in a dynamic environment where the hook causes extra coverage recording code to be inserted.  You&#x27;d like to be able to do this without changing the source code itself.</div><br/></div></div><div id="41073416" class="c"><input type="checkbox" id="c-41073416" checked=""/><div class="controls bullet"><span class="by">diffxx</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41072020">parent</a><span>|</span><a href="#41072218">prev</a><span>|</span><a href="#41073553">next</a><span>|</span><label class="collapse" for="c-41073416">[-]</label><label class="expand" for="c-41073416">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rdriley&#x2F;487&#x2F;papers&#x2F;Thompson_1984_ReflectionsonTrustingTrust.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rdriley&#x2F;487&#x2F;papers&#x2F;Thompson_1984_Ref...</a></div><br/></div></div></div></div><div id="41073553" class="c"><input type="checkbox" id="c-41073553" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41070225">parent</a><span>|</span><a href="#41072020">prev</a><span>|</span><a href="#41071892">next</a><span>|</span><label class="collapse" for="c-41073553">[-]</label><label class="expand" for="c-41073553">[2 more]</label></div><br/><div class="children"><div class="content">The common definition of âAspect oriented programmingâ is more or less âjust bolt whatever CLOS method combinators already can do onto another languageâ. That is powerful concept, but maybe somewhat orthogonal to macros, unless you want to do that with macros, which you certainly can.</div><br/><div id="41074175" class="c"><input type="checkbox" id="c-41074175" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41073553">parent</a><span>|</span><a href="#41071892">next</a><span>|</span><label class="collapse" for="c-41074175">[-]</label><label class="expand" for="c-41074175">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s certainly <i>a</i> form of AOP, but the hook mechanism here would enable arbitrary expansion time code transformations, not just injections at method calls.</div><br/></div></div></div></div><div id="41071892" class="c"><input type="checkbox" id="c-41071892" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41070225">parent</a><span>|</span><a href="#41073553">prev</a><span>|</span><a href="#41072969">next</a><span>|</span><label class="collapse" for="c-41071892">[-]</label><label class="expand" for="c-41071892">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>one can dynamically modify macro expansion using the macroexpand hook</i><p>That&#x27;s an incredibly bad idea, and it&#x27;s not dynamic except in purely interpreted Lisps that expand the same piece of code each time it is executed.<p>The hooks is absolutely global; whatever you put in there must not break anything.<p>From the spec itself: &quot;For this reason, it is frequently best to confine its uses to debugging situations.&quot;</div><br/><div id="41072196" class="c"><input type="checkbox" id="c-41072196" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41071892">parent</a><span>|</span><a href="#41072969">next</a><span>|</span><label class="collapse" for="c-41072196">[-]</label><label class="expand" for="c-41072196">[2 more]</label></div><br/><div class="children"><div class="content">One would bind the macroexpand hook variable around the call to COMPILE or COMPILE-FILE for that code.  The binding goes away after that.  It wouldn&#x27;t be global at all.</div><br/><div id="41076553" class="c"><input type="checkbox" id="c-41076553" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41072196">parent</a><span>|</span><a href="#41072969">next</a><span>|</span><label class="collapse" for="c-41076553">[-]</label><label class="expand" for="c-41076553">[1 more]</label></div><br/><div class="children"><div class="content">yah dynamic binding id another thing I dearly miss.<p>thread local is like global in that it doesn&#x27;t support for partial stacks of coroutines or generators.<p>I&#x27;d love to have some dynamic _call stack based_ context lookup in languages like Python or c++.</div><br/></div></div></div></div></div></div><div id="41072969" class="c"><input type="checkbox" id="c-41072969" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41070225">parent</a><span>|</span><a href="#41071892">prev</a><span>|</span><a href="#41075997">next</a><span>|</span><label class="collapse" for="c-41072969">[-]</label><label class="expand" for="c-41072969">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Something like Yacc&#x2F;Bison is easily done with suitable macros.<p>Is this true?  I may have misunderstood what macros can do in terms of remembering state, while applying.  Looking it up again to see what i overlooked...</div><br/><div id="41073008" class="c"><input type="checkbox" id="c-41073008" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41072969">parent</a><span>|</span><a href="#41075997">next</a><span>|</span><label class="collapse" for="c-41073008">[-]</label><label class="expand" for="c-41073008">[3 more]</label></div><br/><div class="children"><div class="content">You can write a macro that expands a grammar definition into the appropriate code.  Anything a preprocessor can do, a macro can do like that.</div><br/><div id="41073648" class="c"><input type="checkbox" id="c-41073648" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41073008">parent</a><span>|</span><a href="#41075997">next</a><span>|</span><label class="collapse" for="c-41073648">[-]</label><label class="expand" for="c-41073648">[2 more]</label></div><br/><div class="children"><div class="content">But itâs the reverse direction that Bison&#x2F;Yacc does, as it writes code to recognize essentially expanded grammar rules&#x2F;macros, collapsing existing code into an expandable grammar rule&#x2F;macro that would correspond.<p>Thinkingâ¦if thereâs an obvious equivalence</div><br/><div id="41073997" class="c"><input type="checkbox" id="c-41073997" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41070225">root</a><span>|</span><a href="#41073648">parent</a><span>|</span><a href="#41075997">next</a><span>|</span><label class="collapse" for="c-41073997">[-]</label><label class="expand" for="c-41073997">[1 more]</label></div><br/><div class="children"><div class="content">Um, what?  Bison&#x2F;yacc generate compilable C from a grammar file.  A CL macro would expand to Common Lisp starting from a grammar description.  It&#x27;s not the reverse at all.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41075997" class="c"><input type="checkbox" id="c-41075997" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41070225">prev</a><span>|</span><a href="#41076710">next</a><span>|</span><label class="collapse" for="c-41075997">[-]</label><label class="expand" for="c-41075997">[4 more]</label></div><br/><div class="children"><div class="content">&gt; A confirmation of Greenspun&#x27;s Tenth Rule, if you will.<p>I&#x27;ve always found this rule suspect.<p>If it were true you&#x27;d have had lispers loudly reimplementing well-known, slowly-and-buggy mid-size C programs in common lisp, at roughly the rateand loudness the Rust people reimplement old C programs in Rust.<p>Did that actually happen?<p>If not, this has to be the greatest expression of envy in all of programming language lore.</div><br/><div id="41076124" class="c"><input type="checkbox" id="c-41076124" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41075997">parent</a><span>|</span><a href="#41076710">next</a><span>|</span><label class="collapse" for="c-41076124">[-]</label><label class="expand" for="c-41076124">[3 more]</label></div><br/><div class="children"><div class="content">No, it just means you can&#x27;t avoid the reality and the complexity of the problems you&#x27;ll be dealing with and you won&#x27;t be able to tackle them unless you bring in more tools or programming languages, be them visual or special languages invented just for the purpose, or some clever way to use excel sheets and generate code from that, for example.<p>Or it means that, yes, you can choose the easier language, the more intuitive one instead of the abstract beasts and it all goes well for a while. But eventually you&#x27;ll have to go past the &quot;they did this and then they did that&quot;, past the simple to understand if&#x27;s and else&#x27;s of everyday life. Then you&#x27;ll realize that yes, we need this special extra feature here, this clever way of doing things there and before you know it, you&#x27;ve developed dozens of tools, standards and languages just to make up for the lack of power of your initial language. Or you could have chosen the harder language, harder to learn and wield, that is, and it would have offered you better abstractions, it would have offered you better means to develop your ideas and put them into practice without you needing to invent your own tooling.<p>That&#x27;s how I&#x27;ve seen it happen in practice. I&#x27;ve expanded it in this article, but it came the other way round. I had a feeling that all this tooling is actually unnecessary or just the result of having bad tooling to start with. Once I&#x27;ve developed these ideas I&#x27;ve remembered about Greenspun&#x27;s Tenth Rule that I&#x27;ve read and heard about all these years without quite understanding it 100%. Now I think I do. You have to see it with your own eyes, though. If you read it once and it doesn&#x27;t make sense, re-reading it probably wouldn&#x27;t.<p>I hope this helps.</div><br/><div id="41076312" class="c"><input type="checkbox" id="c-41076312" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#41075997">root</a><span>|</span><a href="#41076124">parent</a><span>|</span><a href="#41076710">next</a><span>|</span><label class="collapse" for="c-41076312">[-]</label><label class="expand" for="c-41076312">[2 more]</label></div><br/><div class="children"><div class="content">I think the article was pretty convincing. Even painfully so as it went through the atrocities people are doing in this particular industry to achieve things that, you&#x27;re completely right, would be trivial in Lisp.<p>Unfortunately, most critique you&#x27;re getting here is coming from people who didn&#x27;t read the article, as you can see by the lack of comments addressing any specific part of the article.</div><br/><div id="41076366" class="c"><input type="checkbox" id="c-41076366" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41075997">root</a><span>|</span><a href="#41076312">parent</a><span>|</span><a href="#41076710">next</a><span>|</span><label class="collapse" for="c-41076366">[-]</label><label class="expand" for="c-41076366">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as you can see by the lack of comments addressing any specific part of the article<p>Yes, rightly so! I would have been more than glad to address and discuss any of the points made or tools mentioned in the article but that happiness has been stolen from me by the lack of such comments. You&#x27;re right.<p>&gt; I think the article was pretty convincing. Even painfully so as it went through the atrocities people are doing in this particular industry to achieve things that, you&#x27;re completely right, would be trivial in Lisp.<p>Yes, some of these tools I&#x27;ve mentioned I&#x27;ve also worked with for years. It has been a few years since I&#x27;ve exited from that industry and now I&#x27;ve tried to bring back the feelings and remember the tools and standards so I&#x27;ve had to do some research. It slowly came back. But I did discover some new tools and languages that I haven&#x27;t used  so the horror was even greater than what I&#x27;ve remembered and then I couldn&#x27;t stop digging for more. Good observation.</div><br/></div></div></div></div></div></div></div></div><div id="41076710" class="c"><input type="checkbox" id="c-41076710" checked=""/><div class="controls bullet"><span class="by">continuational</span><span>|</span><a href="#41075997">prev</a><span>|</span><a href="#41067908">next</a><span>|</span><label class="collapse" for="c-41076710">[-]</label><label class="expand" for="c-41076710">[1 more]</label></div><br/><div class="children"><div class="content">Macros allow you to bring highly tailored DSLs into your code base. You can practice language oriented programming.<p>It&#x27;s seductive, but there&#x27;s a steep cost. You bring in a bunch of new notation, which you have to learn and teach and remember. You have to consider all the interactions that happen when you mix notations. You have to implement all the tooling.<p>Usually what happens is you don&#x27;t quite remember what things mean after a while, and you have to study it again. You didn&#x27;t consider all the interactions, so it isn&#x27;t that well behaved. And you never got around to implement quality tooling - and there&#x27;s no obvious place to plug that tooling in, either. And then it turns out that the notation wasn&#x27;t quite right for implementing the changing requirements of the business.</div><br/></div></div><div id="41067908" class="c"><input type="checkbox" id="c-41067908" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41076710">prev</a><span>|</span><a href="#41076321">next</a><span>|</span><label class="collapse" for="c-41067908">[-]</label><label class="expand" for="c-41067908">[11 more]</label></div><br/><div class="children"><div class="content">In my experience (Clojure) macro-heavy libraries tend to be powerful but brittle. A lisp programmer can do things in a library that non-lisp programmers can&#x27;t realistically attempt (Typed Clojure, for example). But the trade offs are very real though hard to put a finger on.<p>There are several Clojure libraries that are cool and completely reliant on macros to be implemented. Eventually, good Clojure programmers seem to stop using them because the trade-offs are worse error messages or uncomfortable edge-case behaviours. The base language is just so good that it doesn&#x27;t really matter, but I&#x27;ve had several experiences where the theoretically-great library had to be abandoned because of how it interacts with debugging tools and techniques.<p>It isn&#x27;t the macros fault, they just hint that a programmer is about to do something that, when it fails, fails in a way that is designed in to the system and can&#x27;t be easily worked around. Macros are basically for creating new syntax constructs - great but when the syntax has bugs, the programmer has a problem. And the community tooling probably won&#x27;t understand it.</div><br/><div id="41068990" class="c"><input type="checkbox" id="c-41068990" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#41067908">parent</a><span>|</span><a href="#41068810">next</a><span>|</span><label class="collapse" for="c-41068990">[-]</label><label class="expand" for="c-41068990">[1 more]</label></div><br/><div class="children"><div class="content">In racket you can define simple macros with define-syntax-rule but in case of an error you get a horrible ininteligible message that shows part of the expanded code.<p>But the recomendation is tp use syntax-parse that is almost a DSL to write macros, for example you can specify that a part is an identifier like x instead of an arbitrary expresssion like (+ x 1). It takes more time to use syntax-parse, but when someone uses the macro they get a nice error at the expansion time.<p>(And syntax-parse is implemented in racket using functions and macros. A big part of the racket features are implemented in racket itself.)</div><br/></div></div><div id="41068810" class="c"><input type="checkbox" id="c-41068810" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41067908">parent</a><span>|</span><a href="#41068990">prev</a><span>|</span><a href="#41068411">next</a><span>|</span><label class="collapse" for="c-41068810">[-]</label><label class="expand" for="c-41068810">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Eventually, good Clojure programmers seem to stop using them because the trade-offs are worse error messages or uncomfortable edge-case behaviours.<p>I am not so familiar with Clojure, but I am familiar with Scheme. The thing is not, that a good programmer stops using macros completely, but that a good programmer knows, when they have to reach for a macro, in order to make something syntactically nicer. I&#x27;ve done a few examples:<p>pipeline&#x2F;threading macro: It needs to be a macro in order to avoid having to write (lambda ...) all the time.<p>inventing new define forms: To define things on the module or top level without needed set! or similar. I used this to make a (define-route ...) for communicating with the docker engine. define-route would define a procedure whose name depends on for which route it is.<p>writing a timing macro: This makes for the cleanest syntax, that does not have anything but (time expr1 expr2 expr3 ...).<p>Perhaps the last example is the least necessary.<p>Many things can be solved by using higher-order functions instead.</div><br/><div id="41069039" class="c"><input type="checkbox" id="c-41069039" checked=""/><div class="controls bullet"><span class="by">hellcow</span><span>|</span><a href="#41067908">root</a><span>|</span><a href="#41068810">parent</a><span>|</span><a href="#41068411">next</a><span>|</span><label class="collapse" for="c-41069039">[-]</label><label class="expand" for="c-41069039">[5 more]</label></div><br/><div class="children"><div class="content">My canonical use-case for macros in Scheme is writing unit tests. If you want to see the unevaluated expression that caused the test failure, you&#x27;ll need a macro.<p><pre><code>    (define-syntax test (syntax-rules ()
      ((_ test-expr expected-expr)
       (let ((tv (call-with-values (lambda () test-expr) list))
             (ev (call-with-values (lambda () expected-expr) list)))
         (if (not (equal? tv ev))
             (printf
              &quot;\nTest failed: ~s\nWanted:      ~s\nGot:         ~s\n&quot;
              &#x27;test-expr
              ev
              tv)))))))</code></pre></div><br/><div id="41070385" class="c"><input type="checkbox" id="c-41070385" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#41067908">root</a><span>|</span><a href="#41069039">parent</a><span>|</span><a href="#41069919">next</a><span>|</span><label class="collapse" for="c-41070385">[-]</label><label class="expand" for="c-41070385">[1 more]</label></div><br/><div class="children"><div class="content">Also, with `syntax-case` or `syntax-parse`, you can have the IDE know the syntax for the test case that failed:<p><a href="https:&#x2F;&#x2F;www.neilvandyke.org&#x2F;racket&#x2F;overeasy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.neilvandyke.org&#x2F;racket&#x2F;overeasy&#x2F;</a></div><br/></div></div><div id="41069919" class="c"><input type="checkbox" id="c-41069919" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41067908">root</a><span>|</span><a href="#41069039">parent</a><span>|</span><a href="#41070385">prev</a><span>|</span><a href="#41073400">next</a><span>|</span><label class="collapse" for="c-41069919">[-]</label><label class="expand" for="c-41069919">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got another similar use-case: Function contracts. There you also probably want to see the unevaluated form of the assertion on failure.</div><br/></div></div><div id="41073400" class="c"><input type="checkbox" id="c-41073400" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#41067908">root</a><span>|</span><a href="#41069039">parent</a><span>|</span><a href="#41069919">prev</a><span>|</span><a href="#41068411">next</a><span>|</span><label class="collapse" for="c-41073400">[-]</label><label class="expand" for="c-41073400">[2 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s pytest framework achieves this without macros. As I understand it, it disassembles the test function bytecode and inspects the AST nodes that have assertions in them.</div><br/><div id="41074337" class="c"><input type="checkbox" id="c-41074337" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41067908">root</a><span>|</span><a href="#41073400">parent</a><span>|</span><a href="#41068411">next</a><span>|</span><label class="collapse" for="c-41074337">[-]</label><label class="expand" for="c-41074337">[1 more]</label></div><br/><div class="children"><div class="content">Inspecting the AST ... That kind of sounds like what macros do. Just that pytest is probably forced to do it in way less elegant ways, due to not having a macro system. I mean, if it has to disassemble things, then it has already lost, basically, considering how much its introspection is lauded sometimes.</div><br/></div></div></div></div></div></div></div></div><div id="41068411" class="c"><input type="checkbox" id="c-41068411" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41067908">parent</a><span>|</span><a href="#41068810">prev</a><span>|</span><a href="#41074028">next</a><span>|</span><label class="collapse" for="c-41068411">[-]</label><label class="expand" for="c-41068411">[2 more]</label></div><br/><div class="children"><div class="content">For a few years I&#x27;ve tried some crazy experiments towards metaprogramming in Java<p><a href="https:&#x2F;&#x2F;github.com&#x2F;paulhoule&#x2F;ferocity">https:&#x2F;&#x2F;github.com&#x2F;paulhoule&#x2F;ferocity</a><p>my plan there was to write ferocity0 in Java that is able to stub out the standard library and then write ferocity1 in ferocity0 (and maybe a ferocity2 in ferocity1) so that I don&#x27;t have to write repetitive code to stub out all the operators,  the eight primitive data types,  etc.  I worked out a way to write out Java code in a form that looks like S-expressions<p><a href="https:&#x2F;&#x2F;github.com&#x2F;paulhoule&#x2F;ferocity&#x2F;blob&#x2F;main&#x2F;ferocity0&#x2F;src&#x2F;test&#x2F;java&#x2F;com&#x2F;ontology2&#x2F;ferocity&#x2F;TestFierceStrings.java">https:&#x2F;&#x2F;github.com&#x2F;paulhoule&#x2F;ferocity&#x2F;blob&#x2F;main&#x2F;ferocity0&#x2F;sr...</a><p>which bulks up the code even more than ordinary Java so to make up for it I want to use &quot;macros&quot; aggressively which might get the code size reasonable but I&#x27;m sure people would struggle to understand it.<p>I switched to other projects but yesterday I was working on some Java that had a lot of boilerplate and was thinking it ought to be possible to do something with compile time annotations along the lines of<p><pre><code>   @CompileTime
   static void generate(LiveClass that) {
       that.addMethod(&quot;methodName&quot;,... arguments ...,... body...)
   }
</code></pre>
and even write a function like that which might see a class annotation<p><pre><code>   @Boilerplate(&quot;argument&quot;)
</code></pre>
and add<p><pre><code>   final static PARAM_ARGUMENT = &quot;${argument}&quot;
</code></pre>
or something like that.</div><br/><div id="41069770" class="c"><input type="checkbox" id="c-41069770" checked=""/><div class="controls bullet"><span class="by">RaftPeople</span><span>|</span><a href="#41067908">root</a><span>|</span><a href="#41068411">parent</a><span>|</span><a href="#41074028">next</a><span>|</span><label class="collapse" for="c-41069770">[-]</label><label class="expand" for="c-41069770">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I want to use &quot;macros&quot; aggressively which might get the code size reasonable but I&#x27;m sure people would struggle to understand it.</i><p>A long time ago I wrote a macro language for the environment I was working in and had grand plans to simplify the dev process quite a bit.<p>While it did work from one perspective, I was able to generate code much much faster for the use cases I was targeting.  But the downside was that it was too abstract to follow easily.<p>It required simulating the macro system in the mind when looking at code to figure out whether it was generating an apple or an orange. I realized there is a limit to the usability of extremely generalized abstraction.<p>EDIT: I just remembered my additional thought back then was that a person that is really an expert in the macro language and the macros created could support+maintain the macro based code generation system.<p>So the dev wouldn&#x27;t be expected to be the maintainer of the underlying macro system, they would just be using the systems templates+macros to generate code, which would give them significant power+speed.  But it&#x27;s also then a one-off language that nobody else knows and that the dev can&#x27;t transfer to next job.</div><br/></div></div></div></div><div id="41074028" class="c"><input type="checkbox" id="c-41074028" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41067908">parent</a><span>|</span><a href="#41068411">prev</a><span>|</span><a href="#41076321">next</a><span>|</span><label class="collapse" for="c-41074028">[-]</label><label class="expand" for="c-41074028">[1 more]</label></div><br/><div class="children"><div class="content">Macros are something where usage tends to go<p>1) OMG confusing -&gt; almost never use them
2) OMG exciting -&gt; use them faaar too much
3) Huh. Powerful, but so powerful you should use only when required. Cool.<p>Quite a few things turn out to be like that skill-progression-wise and at this point I&#x27;ve just accepted it as human nature.</div><br/></div></div></div></div><div id="41076321" class="c"><input type="checkbox" id="c-41076321" checked=""/><div class="controls bullet"><span class="by">RealityVoid</span><span>|</span><a href="#41067908">prev</a><span>|</span><a href="#41069976">next</a><span>|</span><label class="collapse" for="c-41076321">[-]</label><label class="expand" for="c-41076321">[2 more]</label></div><br/><div class="children"><div class="content">IMO, someone should kill XCP and A2L. They are in effect, a semihosted debugger. I would rather have semihosted gdb and use .elf. The tooling around A2L is horrendous.</div><br/><div id="41076414" class="c"><input type="checkbox" id="c-41076414" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41076321">parent</a><span>|</span><a href="#41069976">next</a><span>|</span><label class="collapse" for="c-41076414">[-]</label><label class="expand" for="c-41076414">[1 more]</label></div><br/><div class="children"><div class="content">Well, yes! I&#x27;m trying my best to make your wish come true by spreading the word.<p>Good to know I&#x27;m not the only one finding it a bit too complicated and sad.
Do share your experience with it, if you will.</div><br/></div></div></div></div><div id="41069976" class="c"><input type="checkbox" id="c-41069976" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41076321">prev</a><span>|</span><a href="#41074462">next</a><span>|</span><label class="collapse" for="c-41069976">[-]</label><label class="expand" for="c-41069976">[1 more]</label></div><br/><div class="children"><div class="content">On that subject, I once made a serious effort at explaining why Lisp macros are so useful:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;codr7&#x2F;whirlisp">https:&#x2F;&#x2F;github.com&#x2F;codr7&#x2F;whirlisp</a></div><br/></div></div><div id="41074462" class="c"><input type="checkbox" id="c-41074462" checked=""/><div class="controls bullet"><span class="by">qohen</span><span>|</span><a href="#41069976">prev</a><span>|</span><a href="#41069241">next</a><span>|</span><label class="collapse" for="c-41074462">[-]</label><label class="expand" for="c-41074462">[3 more]</label></div><br/><div class="children"><div class="content">BTW, for anyone interested in learning more about Lisp macros, Paul Graham&#x27;s book about advanced Lisp programming, <i>On Lisp</i>, covers the topic pretty extensively and it&#x27;s freely downloadable from his website:<p>Book description: <a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;onlisp.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;onlisp.html</a><p>Download page: <a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;onlisptext.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;onlisptext.html</a></div><br/><div id="41076960" class="c"><input type="checkbox" id="c-41076960" checked=""/><div class="controls bullet"><span class="by">lkuty</span><span>|</span><a href="#41074462">parent</a><span>|</span><a href="#41075414">next</a><span>|</span><label class="collapse" for="c-41076960">[-]</label><label class="expand" for="c-41076960">[1 more]</label></div><br/><div class="children"><div class="content">And then LoL: <a href="https:&#x2F;&#x2F;letoverlambda.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;letoverlambda.com&#x2F;</a>
I started to read the book years ago but it was too wild for me. I should give it another try. One of the so many things I have to read.</div><br/></div></div><div id="41075414" class="c"><input type="checkbox" id="c-41075414" checked=""/><div class="controls bullet"><span class="by">ocodo</span><span>|</span><a href="#41074462">parent</a><span>|</span><a href="#41076960">prev</a><span>|</span><a href="#41069241">next</a><span>|</span><label class="collapse" for="c-41075414">[-]</label><label class="expand" for="c-41075414">[1 more]</label></div><br/><div class="children"><div class="content">The Giga Monkeys Book, Practical Common Lisp is also excellent:<p><a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;</a></div><br/></div></div></div></div><div id="41069241" class="c"><input type="checkbox" id="c-41069241" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41074462">prev</a><span>|</span><a href="#41066545">next</a><span>|</span><label class="collapse" for="c-41069241">[-]</label><label class="expand" for="c-41069241">[4 more]</label></div><br/><div class="children"><div class="content">Macros are more abstract, one meta level up, hence errors are more difficult to relate to code and reason about. They are also more powerful, so errors can have dramatic consequences.<p>Any kind of code generation setup will have the same characteristics.<p>Sloppy macros clashing with local names can lead to pretty long debug sessions, but it&#x27;s the first thing you learn to avoid.<p>And you&#x27;re basically inventing your own ad hoc programming language to some extent, the effort spent on error handling tend to not live up to those requirements.<p>All of that being said, I wouldn&#x27;t trade them for anything, and I haven&#x27;t seen any convincing alternatives to Lisp for the full experience.</div><br/><div id="41076532" class="c"><input type="checkbox" id="c-41076532" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#41069241">parent</a><span>|</span><a href="#41073582">next</a><span>|</span><label class="collapse" for="c-41076532">[-]</label><label class="expand" for="c-41076532">[1 more]</label></div><br/><div class="children"><div class="content">With care to make the build step &quot;ergonomic&quot;, I prefer working with code generation than with macros. Everything about macros is &quot;cleverer&quot; than code generation:<p>* Implementation of macros require clever algorithms [1] where code generation is mostly straightforward.<p>* It is harder for IDE&#x27;s (and most importantly, humans!) to make use of the code because it is not trivial to determine the end result of a macro (&quot;run the code in your head&quot; kind of situation).<p>There are features that a language can adopt to make it even easier to benefit from code generation, like partial classes [2] and extension methods [3]. Again, these things are a lot more straightforward for both humans and IDEs to understand and work with.<p>--<p>1: <a href="https:&#x2F;&#x2F;www-old.cs.utah.edu&#x2F;plt&#x2F;publications&#x2F;popl16-f.pdf" rel="nofollow">https:&#x2F;&#x2F;www-old.cs.utah.edu&#x2F;plt&#x2F;publications&#x2F;popl16-f.pdf</a><p>2: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-guide&#x2F;classes-and-structs&#x2F;partial-classes-and-methods" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-...</a><p>3: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-guide&#x2F;classes-and-structs&#x2F;extension-methods" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-...</a></div><br/></div></div><div id="41073582" class="c"><input type="checkbox" id="c-41073582" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41069241">parent</a><span>|</span><a href="#41076532">prev</a><span>|</span><a href="#41066545">next</a><span>|</span><label class="collapse" for="c-41073582">[-]</label><label class="expand" for="c-41073582">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>one meta level up</i><p>Which level is that? Is <i>cond</i> higher than <i>if</i>? Which one is the macro, again?</div><br/><div id="41074776" class="c"><input type="checkbox" id="c-41074776" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41069241">root</a><span>|</span><a href="#41073582">parent</a><span>|</span><a href="#41066545">next</a><span>|</span><label class="collapse" for="c-41074776">[-]</label><label class="expand" for="c-41074776">[1 more]</label></div><br/><div class="children"><div class="content">When you write macros, you&#x27;re working one meta level up, since you&#x27;re writing code that generates code (that generates code etc, but one level higher than usual).<p>From a user perspective it&#x27;s different. Macros are more limited; not first class and can&#x27;t be passed around and called like functions.</div><br/></div></div></div></div></div></div><div id="41067603" class="c"><input type="checkbox" id="c-41067603" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41066545">prev</a><span>|</span><a href="#41072212">next</a><span>|</span><label class="collapse" for="c-41067603">[-]</label><label class="expand" for="c-41067603">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;I don&#x27;t think this is truly realized, but all this information written down in word sheets, requirements, knowledge passed on in meetings, little tricks and short hacks solved in video calls, information passed in emails and instant messaging is information that is part of the project, that is put down in some kind of a language, a non-formal one like English or tables or boxes or scribbles or laughs and jokes. The more a project has of these, the harder it is to talk about and verify the actual state of the project as it is obviously impossible to evaluate a non-formal language like you would a formal programming language and thus it becomes that much harder to explore and play with, test and explore the project.&quot;<p>I&#x27;ve thought all this sloppy side information would be a good target for the currently in vogue AI techniques.</div><br/><div id="41067942" class="c"><input type="checkbox" id="c-41067942" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41067603">parent</a><span>|</span><a href="#41072212">next</a><span>|</span><label class="collapse" for="c-41067942">[-]</label><label class="expand" for="c-41067942">[2 more]</label></div><br/><div class="children"><div class="content">That would only mean we&#x27;d add even more tools on top of the tools that currently sit themselves on top of C (in this particular case) to fix our &#x27;sloppy&#x27; ways, no?</div><br/><div id="41070052" class="c"><input type="checkbox" id="c-41070052" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41067603">root</a><span>|</span><a href="#41067942">parent</a><span>|</span><a href="#41072212">next</a><span>|</span><label class="collapse" for="c-41070052">[-]</label><label class="expand" for="c-41070052">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the hope would be a more general tool rather than a raft of specialized tools.</div><br/></div></div></div></div></div></div><div id="41072212" class="c"><input type="checkbox" id="c-41072212" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41067603">prev</a><span>|</span><a href="#41075990">next</a><span>|</span><label class="collapse" for="c-41072212">[-]</label><label class="expand" for="c-41072212">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Replacing Lisp&#x27;s beautiful parentheses with dozens of special tools and languages, none powerful enough to conquer the whole software landscape, leads to fragmentation and extra effort from everyone, vendors and developers alike. The automotive field is a case in point.<p>This completely ignores Haskell.</div><br/></div></div><div id="41075990" class="c"><input type="checkbox" id="c-41075990" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41072212">prev</a><span>|</span><a href="#41067791">next</a><span>|</span><label class="collapse" for="c-41075990">[-]</label><label class="expand" for="c-41075990">[2 more]</label></div><br/><div class="children"><div class="content">I am not reading 10,000+ words on why macros are good.  I know macros are good because smart people tell me they are.  There is also plentiful evidence of macros being useful to programmers.  Who are you trying to convince here?</div><br/><div id="41076219" class="c"><input type="checkbox" id="c-41076219" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41075990">parent</a><span>|</span><a href="#41067791">next</a><span>|</span><label class="collapse" for="c-41076219">[-]</label><label class="expand" for="c-41076219">[1 more]</label></div><br/><div class="children"><div class="content">I am writing for myself. I&#x27;ve also worked in the automotive industry as a consultant for a few years and I&#x27;ve seen the effects of these extra tools I&#x27;m mentioning in the article on me and my colleagues and the industry as a whole. I&#x27;ve gathered all the observations in one place. It has been a nice experience for me writing it, it has cleared up some ideas, brought to life new ones, as it always happens when you think you see something very clearly only to change your opinion and see new angles once you put it in words or once you try to articulate it.<p>I am glad if it&#x27;s useful to others as what others write and wrote over the years, including about Lisp, was useful to me. It&#x27;s just free food, if you will. They&#x27;ve charged nothing for it, even if they worked for years on producing it, I&#x27;m grateful for that and now I&#x27;m returning the favor. If it&#x27;s good food or not, I can&#x27;t say. If you don&#x27;t like it, leave it to others, no harm in that.</div><br/></div></div></div></div><div id="41067791" class="c"><input type="checkbox" id="c-41067791" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#41075990">prev</a><span>|</span><a href="#41068433">next</a><span>|</span><label class="collapse" for="c-41067791">[-]</label><label class="expand" for="c-41067791">[51 more]</label></div><br/><div class="children"><div class="content">So how would we go about switching the entire software industry to use LISP more?  I&#x27;ve been struggling with this idea for awhile.  It seems that the best languages don&#x27;t get adopted.<p>The only consistent explanation I&#x27;ve seen that it is about &#x27;easy&#x27;.  The other languages have tools to make them easy, easy IDE&#x27;s,  the languages &#x27;solve&#x27; one &#x27;thing&#x27; and using them for that &#x27;one thing&#x27; is easier to than building your own in LISP.<p>You can do anything with LISP, sure, but there is a learning curve, lot of &#x27;ways of thinking&#x27; to adopt the brain to in order to solve problems.<p>Personally, I do wish we could somehow re-vamp the CS Education system to focus on LISP and other ML languages, and train more for the thinking process,  not just how to connect up some Java Libraries.</div><br/><div id="41068538" class="c"><input type="checkbox" id="c-41068538" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41067791">parent</a><span>|</span><a href="#41068028">next</a><span>|</span><label class="collapse" for="c-41068538">[-]</label><label class="expand" for="c-41068538">[19 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to argue that Lisp already won.<p>That is, other programming languages have adopted many of the features of Lisp that made Lisp special such as garbage collection (Rustifarians are learning the hard way that garbage collection is the most important feature for building programs out of reusable modules), facile data structures (like the scalar, list, dict trinity), higher order functions, dynamic typing, REPL, etc.<p>People struggled to specify programming languages up until 1990 or so,  some standards were successful such as FORTRAN but COBOL was a hot mess that people filed lawsuits over it,  PL&#x2F;I a failure,  etc.  C was a clear example of &quot;worse is better&quot; with some kind of topological defect in the design such that there&#x27;s a circularity in the K&amp;R book that makes it confusing if you read it all the way through.  Ada was a heroic attempt to write a great language spec but people didn&#x27;t want it.<p>I see the Common Lisp spec as the first modern language spec written by adults which inspired the Java spec and the Python spec and pretty much all languages developed afterwards.  Pedants will consistently deny that the spec is influenced by the implementation but that&#x27;s absolutely silly:  modern specifications are successful because somebody thinks through questions like &quot;How do we make a Lisp that&#x27;s going to perform well on the upcoming generation of 32 bit processors?&quot;<p>In 1980 you had a choice of Lisp, BASIC, PASCAL, FORTRAN, FORTH, etc.  C wound up taking PL&#x2F;I&#x27;s place.  The gap between (say) Python and Lisp is much smaller than the gap between C and Lisp.  I wouldn&#x27;t feel that I could do the macro-heavy stuff in<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Lisp-Advanced-Techniques-Common&#x2F;dp&#x2F;0130305529" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Lisp-Advanced-Techniques-Common&#x2F;dp&#x2F;01...</a><p>in Python but I could write most of the examples in<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Paradigms-Artificial-Intelligence-Programming-Studies&#x2F;dp&#x2F;1558601910" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Paradigms-Artificial-Intelligence-Pro...</a><p>pretty easily.</div><br/><div id="41070439" class="c"><input type="checkbox" id="c-41070439" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068538">parent</a><span>|</span><a href="#41069498">next</a><span>|</span><label class="collapse" for="c-41070439">[-]</label><label class="expand" for="c-41070439">[9 more]</label></div><br/><div class="children"><div class="content">Similarly, Lisp has lost.<p>It&#x27;s clear to me that S-expr are not popular.<p>Other languages and environments have captured much of what Lisp has offered forever, but not S-expr, and, less so, not macros.<p>Any argument one has against Lisp is answered by modern implementations. But, specifically, by Clojure. Modern, fast, &quot;works with everything&quot;, &quot;lots of libraries&quot;, the JVM &quot;lifts all boats&quot;, including Clojure.<p>But despite all that, it&#x27;s still S-expr based, and its still a niche &quot;geek&quot; language. A popular one, for its space, but niche. It&#x27;s not mainstream.<p>Folks have been pivoting away from S-expr all the way back to Dylan.<p>I&#x27;m a Lisp guy, I like Lisp, and by Lisp I mean Common Lisp. But I like CLOS more than macros, specifically mulithmethod dispatch. I&#x27;d rather have CLOS in a language than macros.<p>I don&#x27;t hate S-expr, but I think their value diminishes rather quickly if you don&#x27;t have macros. Most languages have structured static data now, which is another plus of S-expr.<p>I don&#x27;t use many macros in my Lisp code. Mostly convenience methods (like (with-&lt;some-scope&gt; scope &lt;body&gt;)), things like that). Real obvious boiler plate stuff. Everyone else would just wrap a lambda, but that&#x27;s not so much the Common Lisp way.<p>In my Not Lisp work, I don&#x27;t really miss macros.<p>Anyway, S-expr hinder adoption. It&#x27;s had all the time in the world to &quot;break through&quot;, and it hasn&#x27;t. &quot;Wisdom of the crowds&quot; says nay.</div><br/><div id="41070535" class="c"><input type="checkbox" id="c-41070535" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41070439">parent</a><span>|</span><a href="#41076014">next</a><span>|</span><label class="collapse" for="c-41070535">[-]</label><label class="expand" for="c-41070535">[2 more]</label></div><br/><div class="children"><div class="content">What did win is the scalar&#x2F;list&#x2F;dict trinity which I first saw clearly articulated in Perl but is core to dynamic langauges like Python and Javascript and in the stdlib and used heavily in almost every static language except for the one that puts the C in Cthulu.</div><br/><div id="41073139" class="c"><input type="checkbox" id="c-41073139" checked=""/><div class="controls bullet"><span class="by">dudinax</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41070535">parent</a><span>|</span><a href="#41076014">next</a><span>|</span><label class="collapse" for="c-41073139">[-]</label><label class="expand" for="c-41073139">[1 more]</label></div><br/><div class="children"><div class="content">And a lot of lisps have clunky dicts.</div><br/></div></div></div></div><div id="41076014" class="c"><input type="checkbox" id="c-41076014" checked=""/><div class="controls bullet"><span class="by">cylinder714</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41070439">parent</a><span>|</span><a href="#41070535">prev</a><span>|</span><a href="#41073612">next</a><span>|</span><label class="collapse" for="c-41076014">[-]</label><label class="expand" for="c-41076014">[1 more]</label></div><br/><div class="children"><div class="content">As an aside, Ron Rivest and Donald Eastlake last updated &quot;SPKI S-Expressions&quot; just a couple of months ago: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-rivest-sexp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-rivest-sexp&#x2F;</a></div><br/></div></div><div id="41073612" class="c"><input type="checkbox" id="c-41073612" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41070439">parent</a><span>|</span><a href="#41076014">prev</a><span>|</span><a href="#41075803">next</a><span>|</span><label class="collapse" for="c-41073612">[-]</label><label class="expand" for="c-41073612">[4 more]</label></div><br/><div class="children"><div class="content">This is kind of backwards. Languages which imitate everything from the Lisp family except S-exprs and macros are, because of that, other languages. Those that have S-exprs and macros are identified as in the Lisp family.<p>The appearance of new languages like this has not stopped.</div><br/><div id="41074931" class="c"><input type="checkbox" id="c-41074931" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41073612">parent</a><span>|</span><a href="#41075803">next</a><span>|</span><label class="collapse" for="c-41074931">[-]</label><label class="expand" for="c-41074931">[3 more]</label></div><br/><div class="children"><div class="content">This is kind of a no true Scotsman argument. The point is that most of the key ideas of lisp have been enthusiastically adopted by many very popular languages but lisp itself remains a small niche.</div><br/><div id="41075002" class="c"><input type="checkbox" id="c-41075002" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41074931">parent</a><span>|</span><a href="#41076224">next</a><span>|</span><label class="collapse" for="c-41075002">[-]</label><label class="expand" for="c-41075002">[1 more]</label></div><br/><div class="children"><div class="content">A language that enthusiastically adopts all key ideas is identified as a Lisp.<p>There aren&#x27;t &quot;many&quot; popular languages; only a fairly small number. The vast majority of languages are destined for unpopularity, regardless of what they copy from where.</div><br/></div></div><div id="41076224" class="c"><input type="checkbox" id="c-41076224" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41074931">parent</a><span>|</span><a href="#41075002">prev</a><span>|</span><a href="#41075803">next</a><span>|</span><label class="collapse" for="c-41076224">[-]</label><label class="expand" for="c-41076224">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll need to say what this &quot;lisp&quot; and the &quot;lisp features&quot; are.<p>When we go back to the original idea of LISP, we have the following things:<p>idea -&gt; what follows from those<p>1) programming with Symbolic Expressions -&gt; support the implementation&#x2F;implementation of languages<p>2) &quot;programming with Symbolic Expressions&quot; applied to itself -&gt; Lisp in itself, code as data, macros, self-hosting compiler, Lisp interpreter<p>3) linked lists and symbols as data structures for Symbolic Expressions<p>4) a programming system to build algorithms and programs based on the ideas of above -&gt; symbols repository, late binding, recursive functions, symbols with properties, garbage collection, Lisp interpreter using s-expressions, Lisp compiler, reader, printer, read-eval-print-loop, a resident development environment, managed memory, saving&#x2F;loading heap dumps, dynamic data structures,...<p>LISP means &quot;List Processor&quot; (not &quot;List Processing&quot;). Which indicates that this is at its core, not a library or an add on.<p>There aren&#x27;t that many other languages which are based on these ideas.<p>We can define three levels of &quot;feature adoption&quot;:<p>* enables a feature (the language provides mechanisms to provide a feature)<p>* supports a feature (the language actually includes those features, but use is optional)<p>* requires a feature (the language requires the use of that feature, its not optional for the developer)<p>If we use a programming system, which requires the four core ideas above (and many of the features that follow from those) and is based on them, it is still very (!) different to what most people use.<p>Example:<p>Smalltalk development was started more than a decade after LISP. It adopted a huge amount of features from Lisp: managed memory, resident development environment, garbage collection, late binding, interactive use, runtime evaluation, dumping&amp;loading heaps, etc. etc. For a decade Xerox PARC developed a Smalltalk system and a Lisp system side-by side: Smalltalk 80 systems and Interlisp-D systems were the results.<p>Still: Smalltalk 80 did not use the first three core ideas from above and replaced them with another core idea: objects+classes communicating via message passing.<p>Thus mass feature adoption alone does not make Smalltalk fundamentally to be a LISP. Nor does feature adoption make a language popular.<p>So we can ask use, will those core ideas of Lisp make it very popular? Seems like it did not. Still many of the useful features which were following from it could be replicated&#x2F;adopted&#x2F;morphed into other languages.<p>The original article was probably taking a view that a language&amp;programming system which enables domain specific embedded languages would be &quot;better&quot; than the diverse stack of tools and languages in the automotive domain. Lisp is such a tool for embedded languages (embedded into a hosting language, not in the sense of languages for embedded systems), but that does not make it the best for that domain, which has a lot more requirements than language embedding (like reliability, robustness, etc. ...). In Germany A-SPICE gives a lot of hints what a development process needs to do, to deliver reliable software for the automotive domain. I don&#x27;t think Lisp would fit well into such a development process.</div><br/></div></div></div></div></div></div><div id="41075803" class="c"><input type="checkbox" id="c-41075803" checked=""/><div class="controls bullet"><span class="by">Straw</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41070439">parent</a><span>|</span><a href="#41073612">prev</a><span>|</span><a href="#41069498">next</a><span>|</span><label class="collapse" for="c-41075803">[-]</label><label class="expand" for="c-41075803">[1 more]</label></div><br/><div class="children"><div class="content">You can implement CLOS with macros, but not the other way round!</div><br/></div></div></div></div><div id="41069498" class="c"><input type="checkbox" id="c-41069498" checked=""/><div class="controls bullet"><span class="by">munch117</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068538">parent</a><span>|</span><a href="#41070439">prev</a><span>|</span><a href="#41073030">next</a><span>|</span><label class="collapse" for="c-41069498">[-]</label><label class="expand" for="c-41069498">[3 more]</label></div><br/><div class="children"><div class="content">Lisp is the original dynamic language; for decades more or less the only one.  Dynamic languages have been incredibly successful.<p>The code-as-data, self-similar aspect of Lisp, which is at the core of Lisp&#x27;s macro features, hasn&#x27;t reached the same popularity.<p>I would say that Lisp has both won and lost.</div><br/><div id="41069897" class="c"><input type="checkbox" id="c-41069897" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069498">parent</a><span>|</span><a href="#41073030">next</a><span>|</span><label class="collapse" for="c-41069897">[-]</label><label class="expand" for="c-41069897">[2 more]</label></div><br/><div class="children"><div class="content">As much as it sucked,  BASIC had an important place as a dynamic language as early as 1963 at Dartmouth.  GOTO wasn&#x27;t all that different from a JMP in assembly.<p>BASIC was mature as a teaching language that you could run on a minicomputer by the early-1970s (see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RSTS&#x2F;E" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RSTS&#x2F;E</a>) and it came to dominate the market because there were implementations like Tiny BASIC and Microsoft BASIC that would run in machines with 4K of RAM.<p>There was endless handwringing at the time that we were exposing beginners to a language that would teach them terrible habits but the alternatives weren&#x27;t great:  it was a struggle to fit a PASCAL (or FORTRAN or COBOL or ...) compiler into a 64k address space (often using virtual machine techniques like UCSD Pascal which led to terrible performance)  FORTH was a reasonable alternative but never got appeal beyond enthusiasts.<p>There was a lot of hope among pedagogues that we&#x27;d switch to LOGO which was more LISP-like in many ways and you could buy LOGO interpreters for everything from the TI-99&#x2F;4A and TRS-80 Color Computer to the Apple ][.  There was also ÂµLISP which was available on some architectures but again wasn&#x27;t that popular.  For serious coding,  assembly language was popular.<p>In the larger computer space there were a lot of languages like APL and SNOBOL early on that were dynamic too.</div><br/><div id="41074120" class="c"><input type="checkbox" id="c-41074120" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069897">parent</a><span>|</span><a href="#41073030">next</a><span>|</span><label class="collapse" for="c-41074120">[-]</label><label class="expand" for="c-41074120">[1 more]</label></div><br/><div class="children"><div class="content">I cut my teeth on BBC BASIC with the occasional inline arm2 assembly block on an Acorn Archimedes A310.<p>It had its limitations, but it damn well worked and you could have total control of the machine if you needed it.<p>(also the Acorn Archimedes manual was about 40% &quot;how to use the gui&quot; and 60% a complete introduction and reference for BBC BASIC, which definitely helped; I had to buy a book to get an explanation of the ASM side of things but, I mean, fair enough)<p>Then again the second time I fell in love with a programming language was perl5 so I am perhaps an outlier here.</div><br/></div></div></div></div></div></div><div id="41073030" class="c"><input type="checkbox" id="c-41073030" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068538">parent</a><span>|</span><a href="#41069498">prev</a><span>|</span><a href="#41075131">next</a><span>|</span><label class="collapse" for="c-41073030">[-]</label><label class="expand" for="c-41073030">[2 more]</label></div><br/><div class="children"><div class="content">I really like that argument.<p>I&#x27;ve often thought Sun and Solaris also won, since so much of Linux is open source reimaginings of what Solaris had in the mid-late 90s, essentially a few year head start on Linux (which i used in the early 90s and still do, but along with Solaris back then, and NeXTstep).</div><br/><div id="41074233" class="c"><input type="checkbox" id="c-41074233" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41073030">parent</a><span>|</span><a href="#41075131">next</a><span>|</span><label class="collapse" for="c-41074233">[-]</label><label class="expand" for="c-41074233">[1 more]</label></div><br/><div class="children"><div class="content">20 years back I remember chatting to a sysadmin over beer and the conversation included &quot;Linux mostly does either whatever Solaris does or whatever BSD does, you just have to check which it is before trying to write anything.&quot;<p>(this was not a complaint, we were both veterans of the &quot;How Many UNICES?!?!?!&quot; era)</div><br/></div></div></div></div><div id="41075131" class="c"><input type="checkbox" id="c-41075131" checked=""/><div class="controls bullet"><span class="by">mighmi</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068538">parent</a><span>|</span><a href="#41073030">prev</a><span>|</span><a href="#41072514">next</a><span>|</span><label class="collapse" for="c-41075131">[-]</label><label class="expand" for="c-41075131">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s a circularity in the K&amp;R book that makes it confusing if you read it all the way through<p>What do you mean?</div><br/></div></div><div id="41072514" class="c"><input type="checkbox" id="c-41072514" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068538">parent</a><span>|</span><a href="#41075131">prev</a><span>|</span><a href="#41073442">next</a><span>|</span><label class="collapse" for="c-41072514">[-]</label><label class="expand" for="c-41072514">[2 more]</label></div><br/><div class="children"><div class="content">&gt; C was a clear example of &quot;worse is better&quot; with some kind of topological defect in the design such that there&#x27;s a circularity in the K&amp;R book that makes it confusing if you read it all the way through.<p>Whaaaaat???<p>I read the K&amp;R book (rev 1) all the way through.  The only thing I found confusing (without a compiler to experiment wiht) was argc and argv.  Other than that, I found it very clear.<p>What, specifically, are you referring to?</div><br/><div id="41073037" class="c"><input type="checkbox" id="c-41073037" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41072514">parent</a><span>|</span><a href="#41073442">next</a><span>|</span><label class="collapse" for="c-41073037">[-]</label><label class="expand" for="c-41073037">[1 more]</label></div><br/><div class="children"><div class="content">oh how i wish i had kept my rev1 K&amp;R rather than donate it to my hometown library 20+ years ago.</div><br/></div></div></div></div><div id="41073442" class="c"><input type="checkbox" id="c-41073442" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068538">parent</a><span>|</span><a href="#41072514">prev</a><span>|</span><a href="#41068028">next</a><span>|</span><label class="collapse" for="c-41073442">[-]</label><label class="expand" for="c-41073442">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt;C was a clear example of &quot;worse is better&quot; with some kind of topological defect in the design such that there&#x27;s a circularity in the K&amp;R book that makes it confusing if you read it all the way through.</i><p>Aww you can&#x27;t just leave us hanging like this. What&#x27;s the paradox?</div><br/></div></div></div></div><div id="41068028" class="c"><input type="checkbox" id="c-41068028" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#41067791">parent</a><span>|</span><a href="#41068538">prev</a><span>|</span><a href="#41067914">next</a><span>|</span><label class="collapse" for="c-41068028">[-]</label><label class="expand" for="c-41068028">[12 more]</label></div><br/><div class="children"><div class="content">Imo the issue is undergrad cs programs have an identity crisis.<p>Are they the entry into the world of computer science. Should they teach set theory, computer organization, language theory, etc.<p>OR<p>are they trying to prepare the new wave of workers. Should they teach protocols like http, industry tools like Java and python, and good test practices?<p>A well rounded engineer should have a grasp on it all, but with only 4 years, what will attract more funding and more students?</div><br/><div id="41068587" class="c"><input type="checkbox" id="c-41068587" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068028">parent</a><span>|</span><a href="#41068168">next</a><span>|</span><label class="collapse" for="c-41068587">[-]</label><label class="expand" for="c-41068587">[1 more]</label></div><br/><div class="children"><div class="content">20 years ago I found CS students at my Uni usually didn&#x27;t know how to do version control,  use an issue tracker,  etc.  Today they all use Github.<p>Remember computer science professors and grad students get ahead in their careers by writing papers not by writing programs.  You do find some great programmers,  but you also find a lot of awful code.  There was the time that a well-known ML professor emailed me a C program which crashed before it got into main() and it was because the program allocated a 4GB array that it never used.  He could get away with it because he had a 64 bit machine but I will still on 32 bits.<p>Early in grad school for physics I had a job developing Java applets for education and got invited to a CS conference in Syracuse where I did a live demo.  None of the computer scientists had a working demo and I was told I was very brave to have one.</div><br/></div></div><div id="41068168" class="c"><input type="checkbox" id="c-41068168" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068028">parent</a><span>|</span><a href="#41068587">prev</a><span>|</span><a href="#41069281">next</a><span>|</span><label class="collapse" for="c-41068168">[-]</label><label class="expand" for="c-41068168">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been advocating for years that CS departments need to bifurcate. Actual CS classes, the theory-heavy kind, need to be reabsorbed into math departments. People who want to study computer science academically would be better served by getting a math degree. The &quot;how to write software&quot; courses need be absorbed into engineering departments, and maybe the extra discipline gains from actual engineers teaching these courses can start turning software engineers from computer programmers with an inflated job title into actual engineers.<p>Students can then make a choice. Do I get a degree in computer science and be better prepared for academia, essentially being a mathematician who specializes in computation? Or do I get a degree in computer engineering and be better prepared to write reliable software in industry?<p>Of course this distinction exists today, and some universities do offer separate CS and CE degrees, but in practice it seems more often to be smashed together into a catch-all CS degree that may or may not be more theory or practice focused depending on the program.</div><br/><div id="41071173" class="c"><input type="checkbox" id="c-41071173" checked=""/><div class="controls bullet"><span class="by">scott_s</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068168">parent</a><span>|</span><a href="#41075065">next</a><span>|</span><label class="collapse" for="c-41071173">[-]</label><label class="expand" for="c-41071173">[2 more]</label></div><br/><div class="children"><div class="content">First, &quot;computer engineering&quot; is already a name for an established discipline. And regarding academic computer scientists, a significant amount of them are on the &quot;systems&quot; side; it would be inaccurate to call their work a specialization of math.</div><br/><div id="41076239" class="c"><input type="checkbox" id="c-41076239" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41071173">parent</a><span>|</span><a href="#41075065">next</a><span>|</span><label class="collapse" for="c-41076239">[-]</label><label class="expand" for="c-41076239">[1 more]</label></div><br/><div class="children"><div class="content">At my university, &quot;computer science&quot; and &quot;computer engineering&quot; were under different departments, and the latter focused less on algorithms and more on embedded digital hardware.</div><br/></div></div></div></div><div id="41075065" class="c"><input type="checkbox" id="c-41075065" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068168">parent</a><span>|</span><a href="#41071173">prev</a><span>|</span><a href="#41068227">next</a><span>|</span><label class="collapse" for="c-41075065">[-]</label><label class="expand" for="c-41075065">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s still the case for a lot of CS programs. At least mine is still part of the maths department. We also had a distinction between CS and Software engineering, and even between normal CS and a hybrid program between CS and Software engineering.</div><br/></div></div><div id="41068227" class="c"><input type="checkbox" id="c-41068227" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068168">parent</a><span>|</span><a href="#41075065">prev</a><span>|</span><a href="#41069281">next</a><span>|</span><label class="collapse" for="c-41068227">[-]</label><label class="expand" for="c-41068227">[2 more]</label></div><br/><div class="children"><div class="content">Just to add another angle to this: of course you can have CS classes and all that good stuff, but would the businesses only employ these kind of graduates? Or would they spread even thinner to grab market share or increase profits and hire non-experts as a result, for which &quot;easy&quot; and intuitive tools have to be developed and employed? I mean, I see this problem with abstraction, maths, compilers, Lisp, etc, you know, the fundamental stuff. That is, the deeper you go it will become that much harder to find people willing or able to dive deep. So eventually you run out of manpower and that what? Use these &quot;intuitive&quot; tools, probably.</div><br/><div id="41068268" class="c"><input type="checkbox" id="c-41068268" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068227">parent</a><span>|</span><a href="#41069281">next</a><span>|</span><label class="collapse" for="c-41068268">[-]</label><label class="expand" for="c-41068268">[1 more]</label></div><br/><div class="children"><div class="content">I mean, this is already a thing today. Programmers who can hack together a CRUD app in &lt;insert popular web dev stack&gt; are a dime a dozen. People who know more about compilers than &quot;oh yeah I got a C in that class&quot; are pretty hard to find.<p>At some point businesses who need &quot;deep experts&quot; have to hire non-experts and invest in training them. This is what I have seen in practice. You don&#x27;t use the &quot;intuitive&quot; tools, you hire people who are willing to learn and teach them the other tools.</div><br/></div></div></div></div></div></div><div id="41069281" class="c"><input type="checkbox" id="c-41069281" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068028">parent</a><span>|</span><a href="#41068168">prev</a><span>|</span><a href="#41070263">next</a><span>|</span><label class="collapse" for="c-41069281">[-]</label><label class="expand" for="c-41069281">[1 more]</label></div><br/><div class="children"><div class="content">When I was a student in Crete, the nearby CSD was a gorgeous example of doing both competently.  They had rigorous theory courses (like mandatory DS, Algos, logic, compilers etc) as well as hardcore applied stuff.<p>Side-knowledge like source control, Unix systems and utilities, editors&#x2F;IDEs were supposed to be picked by students themselves with the help of lab TAs, because assignments were to be delivered over ssh through specific channels etc.  Sometimes, the quirky teacher would not give precise instructions for certain projects, but tell the students to find the documentation in the departmental network directories for the class and decrypt them with their ID numbers.  So the students would go on to crawl the unix and windows nodes for the relevant info.<p>A &quot;good&quot; (7.5+&#x2F;10) graduate from the CSD of the University of Crete could do rigorous algorithmic analysis, hack system stuff in C and time in Verilog.  OOP was hot at the time, so it also meant students were expected to produce significant amounts of code in Java and C++.  Specializations abounded: networks and OSs, theory, arithmetic and analysis, hardware (including VLSI etc. at the undergraduate level, with labs).  I won&#x27;t even go into the graduate stuff.<p>And although this curriculum was quite demanding and onerous (the number of projects in each class was quite crazy), it was just something students dealt with.  Heck, this was not even the most famous CS school in Greece: the elite hackers mostly went to the National Technical University of Athens.<p>I am not sure what the situation is now, but at least at the time, graduates were ready both for academic and serious industry careers.  It is a 4 year curriculum, though many if not most students went on for 5 or 6 years.  Of course, free.</div><br/></div></div><div id="41070263" class="c"><input type="checkbox" id="c-41070263" checked=""/><div class="controls bullet"><span class="by">FredPret</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068028">parent</a><span>|</span><a href="#41069281">prev</a><span>|</span><a href="#41068536">next</a><span>|</span><label class="collapse" for="c-41070263">[-]</label><label class="expand" for="c-41070263">[1 more]</label></div><br/><div class="children"><div class="content">In my traditional-engineering education, we spent a ton of time on the basic science and theory, with a super broad overview of actual methods used in practice.<p>The expectation was that you graduate and you&#x27;re then equipped to go to a company and start learning to be an engineer that does some specific thing, and you&#x27;re just barely useful enough to justify getting paid.</div><br/></div></div><div id="41068536" class="c"><input type="checkbox" id="c-41068536" checked=""/><div class="controls bullet"><span class="by">blacklion</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068028">parent</a><span>|</span><a href="#41070263">prev</a><span>|</span><a href="#41067914">next</a><span>|</span><label class="collapse" for="c-41068536">[-]</label><label class="expand" for="c-41068536">[2 more]</label></div><br/><div class="children"><div class="content">IMHO, it is University-level vs College (vocational college) difference.
Industry should not require University-level training from workers. Academy should.<p>Plumber or electrician don&#x27;t need university degree, only professional training till you design whole sewer system or power grid for city.<p>So, yes, bifurcate CS to science and trade. And fight requirements for Bachelor&#x2F;Major degree in jobs offerings.</div><br/><div id="41070409" class="c"><input type="checkbox" id="c-41070409" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068536">parent</a><span>|</span><a href="#41067914">next</a><span>|</span><label class="collapse" for="c-41070409">[-]</label><label class="expand" for="c-41070409">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Industry should not require University-level training from workers. 
&gt; Plumber or electrician don&#x27;t need university degree, only professional training [...]<p>Oh come on, this is ridiculous.<p>Sure <i>you</i> might be able to do good programming without a college degree.<p>The typical student? I give them very little chance.<p>Here&#x27;s what I think you would see:<p>* Students trapped in small skill-set jobs, struggling to branch out.<p>* Poor ability to manage complexity. The larger the system, the worse an ad-hoc job is going to be.<p>* Lack of awareness of how much tools can help. &quot;Make impossible states not representable?&quot; Write a DSL with a type system so another department stops making so many errors?<p>* Even more incompetence. Had to learn to recognize an O(N^2) algorithm on the job, but you didn&#x27;t even know what asymptotic complexity was? People are going to end up believing ridiculous cargo cult things like &quot;two nested loops = slow&quot;.<p>* Less rigorous thinking. Do you think they&#x27;re even going to be able to pick up recursion? Have you watched a beginner try to understand something like mergesort or quicksort? Imagine that they never had a class where they programmed recursively. Is depth first search taught on the job? Sure, but... how deeply.<p>* Even less innovation. Who is going to be making the decisions about how to manage state? Would you ever see ideas like Effect?<p>I&#x27;m not saying that a university education is a cure-all, or that it is essential to the jobs that many of us do. I AM saying that if you look at the level of complexity of the work we do, it&#x27;s obvious (to me) that there is something to study and something to gain from the study.</div><br/></div></div></div></div></div></div><div id="41067914" class="c"><input type="checkbox" id="c-41067914" checked=""/><div class="controls bullet"><span class="by">adamddev1</span><span>|</span><a href="#41067791">parent</a><span>|</span><a href="#41068028">prev</a><span>|</span><a href="#41069311">next</a><span>|</span><label class="collapse" for="c-41067914">[-]</label><label class="expand" for="c-41067914">[2 more]</label></div><br/><div class="children"><div class="content">There was a great episode of Type Theory for All with Conal Elliot as a guest where he decried MITs decision to switch to teaching Python instead of Scheme for introductory programming. He makes a very good case for how CS education should be aiming to pursue the greatest truths and not just equipping people with whatever employers want.</div><br/><div id="41068126" class="c"><input type="checkbox" id="c-41068126" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41067914">parent</a><span>|</span><a href="#41069311">next</a><span>|</span><label class="collapse" for="c-41068126">[-]</label><label class="expand" for="c-41068126">[1 more]</label></div><br/><div class="children"><div class="content">A podcast about type theory and other programming language design topics? Oh well auto subscribe :)</div><br/></div></div></div></div><div id="41069311" class="c"><input type="checkbox" id="c-41069311" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#41067791">parent</a><span>|</span><a href="#41067914">prev</a><span>|</span><a href="#41068124">next</a><span>|</span><label class="collapse" for="c-41069311">[-]</label><label class="expand" for="c-41069311">[1 more]</label></div><br/><div class="children"><div class="content">Not calling it LISP would help. And though you get used to it and even kind of appreciate it sometimes, the default behavior of most Common Lisp implementations to SHOUT its symbols at you is rather unfortunate.<p>Go back to 2005 and look at how &#x27;easy&#x27; Python, Perl, PHP, Ruby, JavaScript, C++, and Java were. Look at them today. Why has their popularity hierarchy not remained the same? How about vs. Lisp then and now (or even Clojure later)? You&#x27;ll find answers that explain Lisp&#x27;s current popularity (which isn&#x27;t all that bad) better than anything to do with initial or eventual easiness.</div><br/></div></div><div id="41068124" class="c"><input type="checkbox" id="c-41068124" checked=""/><div class="controls bullet"><span class="by">ryan-duve</span><span>|</span><a href="#41067791">parent</a><span>|</span><a href="#41069311">prev</a><span>|</span><a href="#41069017">next</a><span>|</span><label class="collapse" for="c-41068124">[-]</label><label class="expand" for="c-41068124">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The only consistent explanation I&#x27;ve seen that it is about &#x27;easy&#x27;. The other languages have tools to make them easy, easy IDE&#x27;s, the languages &#x27;solve&#x27; one &#x27;thing&#x27; and using them for that &#x27;one thing&#x27; is easier to than building your own in LISP.<p>I have thought something similar, perhaps with a bit more emphasis on network effects and initial luck of popularity, but the same idea.  Then about a week ago, I was one of the lucky 10,000[0] that learned about The Lisp Curse[1].  It&#x27;s as old as the hills, but I hadn&#x27;t come across anything like it before.  I think it better explains the reason &quot;the best languages don&#x27;t get adopted&quot; than the above.<p>The TL;DR is with unconstrained coding power comes dispersion.  This dilutes solutions across equally optimal candidates instead of consolidation on a single (arbitrary) optimal solution.<p>[0] <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1053&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1053&#x2F;</a><p>[1] <a href="http:&#x2F;&#x2F;winestockwebdesign.com&#x2F;Essays&#x2F;Lisp_Curse.html" rel="nofollow">http:&#x2F;&#x2F;winestockwebdesign.com&#x2F;Essays&#x2F;Lisp_Curse.html</a></div><br/><div id="41068325" class="c"><input type="checkbox" id="c-41068325" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068124">parent</a><span>|</span><a href="#41069017">next</a><span>|</span><label class="collapse" for="c-41068325">[-]</label><label class="expand" for="c-41068325">[2 more]</label></div><br/><div class="children"><div class="content">Guess today I&#x27;m one of the lucky 10,000 to read this essay.</div><br/><div id="41069165" class="c"><input type="checkbox" id="c-41069165" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41068325">parent</a><span>|</span><a href="#41069017">next</a><span>|</span><label class="collapse" for="c-41069165">[-]</label><label class="expand" for="c-41069165">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say you were unlucky, because it&#x27;s a rather terrible essay and doesn&#x27;t actually get the diagnosis correct at all; indeed if some of its claims were true, you&#x27;d think they would apply just as well to other more popular languages, or rule out existing Lisp systems comprised of millions of lines of code with large teams. The author never even participated in Lisp, and is ignorant of most of Lisp history. I wish it&#x27;d stop being circulated.</div><br/></div></div></div></div></div></div><div id="41069017" class="c"><input type="checkbox" id="c-41069017" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41067791">parent</a><span>|</span><a href="#41068124">prev</a><span>|</span><a href="#41068433">next</a><span>|</span><label class="collapse" for="c-41069017">[-]</label><label class="expand" for="c-41069017">[13 more]</label></div><br/><div class="children"><div class="content">&gt; <i>So how would we go about switching the entire software industry to use LISP more?</i><p>There are two answers to this, depending on how broadly you interpret the &quot;Lisp&quot; part of the question. The fundamentalist, and worse, answer is simply: you don&#x27;t. The objections to Lisp are not mere surface-level syntactic quibbles, it&#x27;s deeper than that.  But also, the syntax is a barrier to adoption. Some people think in S-expressions quite naturally, I personally find them pleasant if a bit strange. But the majority simply do not.  Let&#x27;s not downplay the actual success of Common Lisp, Scheme, and particularly Clojure, all of them are actively used. But you&#x27;ve got your work cut out for you trying to get broader adoption for any of those, teams which want to be using them, are.<p>The better, more liberal answer, is: use Julia! The language is consciously placed in the Lisp family in the broader sense, it resembles Dylan more than any other language. Critically, it has first-class macros, which one might argue are less <i>eloquent</i> than macros in Common Lisp, but which are equally <i>expressive</i>.<p>It also has multiple dispatch, and is a JIT-compiled LLVM language, meaning that type-stable Julia code is as fast as a dynamic language can be, genuinely competitive with C++ for CPU-bound numeric computation.<p>Perhaps most important, it&#x27;s simply a pleasure to work with. The language is typecast into a role in scientific computing, and the library ecosystem does reflect that, but the language itself is well suited to general server-side programming, and library support is a chicken-and-egg thing: if more people start choosing Julia over, say, Go, then it will naturally grow more libraries for those applications over time.</div><br/><div id="41074379" class="c"><input type="checkbox" id="c-41074379" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069017">parent</a><span>|</span><a href="#41069336">next</a><span>|</span><label class="collapse" for="c-41074379">[-]</label><label class="expand" for="c-41074379">[1 more]</label></div><br/><div class="children"><div class="content">Elixir feels like that as well (in the same broader sense).<p>Their trick of &#x27;use&#x27; being require+import (ala perl) becomes brilliant when you realise import can be a macro, and that&#x27;s how libraries inject things into your current namespace.<p>Consider also: <a href="https:&#x2F;&#x2F;github.com&#x2F;elixir-lang&#x2F;elixir&#x2F;blob&#x2F;main&#x2F;lib&#x2F;elixir&#x2F;lib&#x2F;kernel.ex">https:&#x2F;&#x2F;github.com&#x2F;elixir-lang&#x2F;elixir&#x2F;blob&#x2F;main&#x2F;lib&#x2F;elixir&#x2F;l...</a><p>Julia looks beautiful but I keep forgetting to play with it. I&#x27;d use the startup time as an excuse, but it really is just &#x27;I keep forgetting&#x27; if I&#x27;m honest.</div><br/></div></div><div id="41069336" class="c"><input type="checkbox" id="c-41069336" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069017">parent</a><span>|</span><a href="#41074379">prev</a><span>|</span><a href="#41068433">next</a><span>|</span><label class="collapse" for="c-41069336">[-]</label><label class="expand" for="c-41069336">[11 more]</label></div><br/><div class="children"><div class="content">&gt;The objections to Lisp are not mere surface-level syntactic quibbles, it&#x27;s deeper than that.<p>I am interested in the specifics; if you have the time to write details I&#x27;d love that, otherwise I welcome some links!</div><br/><div id="41069965" class="c"><input type="checkbox" id="c-41069965" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069336">parent</a><span>|</span><a href="#41071672">next</a><span>|</span><label class="collapse" for="c-41069965">[-]</label><label class="expand" for="c-41069965">[9 more]</label></div><br/><div class="children"><div class="content">My very rough and wet finger take:<p>* Scheme is just too fragmented and lacking in arguments to seduce the current industry; its macros are unintuitive, continuations are hard to reason with (<a href="https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;continuations&#x2F;against-callcc.html" rel="nofollow">https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;continuations&#x2F;against-callcc.html</a>), small stdlib, no concept of static typing, etc...<p>* CL is old, unfashionable and full of scary warts (function names, eq&#x2F;eql&#x2F;equal&#x2F;equalp, etc...), and its typing story is also pretty janky even if better than the others (no recursive deftype meaning you can&#x27;t statically type lists&#x2F;trees, no parametric deftype, the only one you&#x27;ll get is array). Few people value having such a solid ANSI standard when it doesn&#x27;t include modern stuff like iterators&#x2F;extensible sequences, regexps or threads&#x2F;atomics.<p>* Clojure is the most likely to succeed, but the word Java scares a lot of people (for both good and bad reasons) in my experience. As does the &quot;FP means immutable data structs&quot; ML cult. And its current state for static typing is pretty dire, from what I understand.<p>All of these also don&#x27;t work that well with VSCode and other popular IDEs (unless stuff like Alive and Calva has gotten way better and less dead than I remember, but even then, SLIME isn&#x27;t the same as LSP). So, basically, that and static typing having a huge mindshare in the programming world.</div><br/><div id="41072060" class="c"><input type="checkbox" id="c-41072060" checked=""/><div class="controls bullet"><span class="by">nsm</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069965">parent</a><span>|</span><a href="#41071168">next</a><span>|</span><label class="collapse" for="c-41072060">[-]</label><label class="expand" for="c-41072060">[1 more]</label></div><br/><div class="children"><div class="content">I agree with your comment for the most part (particularly the IDE situation)<p>I do want to callout that while Racket started off from Scheme (and still maintains compatibility with a bunch of it), it should be considered a different platform at this point and solves a bunch of the problems you called out with Scheme - macros are apparently much better, continuations are usually delimited, has user-mode threads and generators, so you very rarely need to reach for raw continuations, a very nice concurrency system, large stdlib, and Typed Racket also adds static typing.<p>The DrRacket&#x2F;SLIME experience is great for smaller projects. I do agree that the language server needs more love.
However I still think it gets a lot of stuff right, and is much faster than Python&#x2F;Ruby due to being powered by Chez Scheme.</div><br/></div></div><div id="41071168" class="c"><input type="checkbox" id="c-41071168" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069965">parent</a><span>|</span><a href="#41072060">prev</a><span>|</span><a href="#41072644">next</a><span>|</span><label class="collapse" for="c-41071168">[-]</label><label class="expand" for="c-41071168">[6 more]</label></div><br/><div class="children"><div class="content">Thank you so much for the info!  I am mostly interested in CL.<p>&gt;Few people value having such a solid ANSI standard when it doesn&#x27;t include modern stuff like iterators&#x2F;extensible sequences, regexps or threads&#x2F;atomics.<p>For everyone: are there plans to include such topics in the Standard, or are there canonical extensions that people are using?</div><br/><div id="41071761" class="c"><input type="checkbox" id="c-41071761" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41071168">parent</a><span>|</span><a href="#41072644">next</a><span>|</span><label class="collapse" for="c-41071761">[-]</label><label class="expand" for="c-41071761">[5 more]</label></div><br/><div class="children"><div class="content">There is little chance the Standard is gonna get updated again, especially since CDR (the Common Lisp Directory Repository) kinda stopped. That said there are a few libraries that are kinda considered to be the default go-tos for various needs:<p>CL-PPCRE for regular expressions.<p>Bordeaux-threads for threads.<p>Alexandria for various miscellaneous stuff.<p>Trivia for pattern matching.<p>CFFI for, well, FFI.<p>And Series for functional iterative sequence-like data structures.<p>There&#x27;s also ASDF and UIOP, but I&#x27;m not sure whether or not they&#x27;re part of the Standard.</div><br/><div id="41073780" class="c"><input type="checkbox" id="c-41073780" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41071761">parent</a><span>|</span><a href="#41074223">next</a><span>|</span><label class="collapse" for="c-41073780">[-]</label><label class="expand" for="c-41073780">[3 more]</label></div><br/><div class="children"><div class="content">Too bad cl-ppcre is extremely slow in my experience, but that&#x27;s what we have.
ASDF and UIOP are the same as the rest, de facto standards, but not ANSI nor CLtL.<p>I would also add iterate to the &quot;must haves&quot;. All noobs should constantly look at the CLHS (available for dash, zeal and emacs too!), <a href="https:&#x2F;&#x2F;lispcookbook.github.io&#x2F;cl-cookbook&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lispcookbook.github.io&#x2F;cl-cookbook&#x2F;</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;CodyReichert&#x2F;awesome-cl">https:&#x2F;&#x2F;github.com&#x2F;CodyReichert&#x2F;awesome-cl</a>, anyway.<p>Truly, someone could tie himself to SBCL and its extensions and get a much more modern environment, but I think it&#x27;s worth targeting ECL and CCL in addition.</div><br/><div id="41074624" class="c"><input type="checkbox" id="c-41074624" checked=""/><div class="controls bullet"><span class="by">bo-tato</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41073780">parent</a><span>|</span><a href="#41074223">next</a><span>|</span><label class="collapse" for="c-41074624">[-]</label><label class="expand" for="c-41074624">[2 more]</label></div><br/><div class="children"><div class="content">there&#x27;s a much faster regex library: <a href="https:&#x2F;&#x2F;github.com&#x2F;telekons&#x2F;one-more-re-nightmare">https:&#x2F;&#x2F;github.com&#x2F;telekons&#x2F;one-more-re-nightmare</a></div><br/><div id="41076857" class="c"><input type="checkbox" id="c-41076857" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41074624">parent</a><span>|</span><a href="#41074223">next</a><span>|</span><label class="collapse" for="c-41076857">[-]</label><label class="expand" for="c-41076857">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not yet operational, sadly. Missing ^ and $ isn&#x27;t a small thing.</div><br/></div></div></div></div></div></div><div id="41074223" class="c"><input type="checkbox" id="c-41074223" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41071761">parent</a><span>|</span><a href="#41073780">prev</a><span>|</span><a href="#41072644">next</a><span>|</span><label class="collapse" for="c-41074223">[-]</label><label class="expand" for="c-41074223">[1 more]</label></div><br/><div class="children"><div class="content">ASDF is one of the symptoms of what is wrong about CL. You have this thing that is not really sure whether it is image based or source based and has a bunch of global state while reading the source. Solution to that is ASDF, which is a ridiculously hairy and complex thing.</div><br/></div></div></div></div></div></div><div id="41072644" class="c"><input type="checkbox" id="c-41072644" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069965">parent</a><span>|</span><a href="#41071168">prev</a><span>|</span><a href="#41071672">next</a><span>|</span><label class="collapse" for="c-41072644">[-]</label><label class="expand" for="c-41072644">[1 more]</label></div><br/><div class="children"><div class="content">Calva is way better than Alive, currently. It pretty much does everything you need.</div><br/></div></div></div></div><div id="41071672" class="c"><input type="checkbox" id="c-41071672" checked=""/><div class="controls bullet"><span class="by">screcth</span><span>|</span><a href="#41067791">root</a><span>|</span><a href="#41069336">parent</a><span>|</span><a href="#41069965">prev</a><span>|</span><a href="#41068433">next</a><span>|</span><label class="collapse" for="c-41071672">[-]</label><label class="expand" for="c-41071672">[1 more]</label></div><br/><div class="children"><div class="content">Lisp is too powerful and flexible. That&#x27;s an advantage and a disadvantage.<p>On the one hand, you can use that power to write elegant programs with great abstractions.
One the other hand it&#x27;s really really easy to create unmaintainable messes full of ad-hoc macros that no-one, not even you next month, will be able to understand.<p>Even if the program is well-written, it can be a really steep learning curve for junior hires unless it&#x27;s  very well documented and there&#x27;s support from the original writers available.<p>Compare it to other languages that limit your ability to express yourself while writing code.<p>The truth is that most programs are not really interesting and having a code base that can be hacked-on easily by any random programmer that you can hire is a really valuable proposition from the business point of view, and using less powerful languages is a good way to prevent non-experts from making a mess.</div><br/></div></div></div></div></div></div></div></div><div id="41068433" class="c"><input type="checkbox" id="c-41068433" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#41067791">prev</a><span>|</span><label class="collapse" for="c-41068433">[-]</label><label class="expand" for="c-41068433">[6 more]</label></div><br/><div class="children"><div class="content">Macros are one of the widely touted superpowers of lisp. And yet in Clojure, which is the most widely used dialect in modern use, it is idiomatic to avoid macros as much as possible. None of the claimed advantages really hold up under scrutiny.</div><br/><div id="41074440" class="c"><input type="checkbox" id="c-41074440" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41068433">parent</a><span>|</span><a href="#41072540">next</a><span>|</span><label class="collapse" for="c-41074440">[-]</label><label class="expand" for="c-41074440">[1 more]</label></div><br/><div class="children"><div class="content">Macros are an escape hatch.<p>&quot;Don&#x27;t use a macro unless you need to&quot; is good advice, but when you -do- need to, having macros around is lovely.<p>Yes, you can achieve the same thing by typing out what would&#x27;ve been the expansion yourself, but in cases where macros are a good idea the expansion would&#x27;ve been sufficiently prone to mistakes when tweaking it that maintaining the macro is an improvement.</div><br/></div></div><div id="41072540" class="c"><input type="checkbox" id="c-41072540" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#41068433">parent</a><span>|</span><a href="#41074440">prev</a><span>|</span><a href="#41072947">next</a><span>|</span><label class="collapse" for="c-41072540">[-]</label><label class="expand" for="c-41072540">[2 more]</label></div><br/><div class="children"><div class="content">&gt; idiomatic to avoid macros as much as possible.<p>Same in all lisps. The advantages of having macros vary on a case-by-case basis, but one thing is quite sure: the number of programmers collaborating on a project is inversely proportional to how much you should use macros. For a solo dev, especially when doing science-y stuff, they&#x27;re invaluable.</div><br/><div id="41073089" class="c"><input type="checkbox" id="c-41073089" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#41068433">root</a><span>|</span><a href="#41072540">parent</a><span>|</span><a href="#41072947">next</a><span>|</span><label class="collapse" for="c-41073089">[-]</label><label class="expand" for="c-41073089">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only true of macros created for the purpose of reducing boilerplate code. However, the best macros actually reduce errors and improve code quality by enforcing invariants more than can be done without macros.</div><br/></div></div></div></div><div id="41072947" class="c"><input type="checkbox" id="c-41072947" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#41068433">parent</a><span>|</span><a href="#41072540">prev</a><span>|</span><a href="#41072653">next</a><span>|</span><label class="collapse" for="c-41072947">[-]</label><label class="expand" for="c-41072947">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it is idiomatic to avoid macros as much as possible.<p>Of course, don&#x27;t use a macro if you don&#x27;t need one. But when you do hit a case where you need one, it&#x27;s better than using&#x2F;writing external tooling to solve the problem.<p>&gt; None of the claimed advantages really hold up under scrutiny.<p>This doesn&#x27;t follow.</div><br/></div></div><div id="41072653" class="c"><input type="checkbox" id="c-41072653" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41068433">parent</a><span>|</span><a href="#41072947">prev</a><span>|</span><label class="collapse" for="c-41072653">[-]</label><label class="expand" for="c-41072653">[1 more]</label></div><br/><div class="children"><div class="content">Many people use macros as a poor man&#x27;s inliner, to generate code in a way that adds no benefits over a good compiler.<p>You rarely actually need syntactic abstractions, but when you do you need macros.</div><br/></div></div></div></div></div></div></div></div></div></body></html>