<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715245271374" as="style"/><link rel="stylesheet" href="styles.css?v=1715245271374"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hereket.com/posts/from-scratch-x11-windowing/">Opening Windows in Linux with sockets, bare hands and 200 lines of C</a> <span class="domain">(<a href="https://hereket.com">hereket.com</a>)</span></div><div class="subtext"><span>libcheet</span> | <span>40 comments</span></div><br/><div><div id="40306001" class="c"><input type="checkbox" id="c-40306001" checked=""/><div class="controls bullet"><span class="by">txdv</span><span>|</span><a href="#40305306">next</a><span>|</span><label class="collapse" for="c-40306001">[-]</label><label class="expand" for="c-40306001">[3 more]</label></div><br/><div class="children"><div class="content">The X Windowing system is a hackers delight.<p>If you have a remote server with UI, you can set up a X Window server on your Windows&#x2F;MacOS machine and forward via SSH X messages to use GUI apps on your server, but view the result locally. The Responsiveness of the UI depends on your network capabilities.</div><br/><div id="40306347" class="c"><input type="checkbox" id="c-40306347" checked=""/><div class="controls bullet"><span class="by">cyberpunk</span><span>|</span><a href="#40306001">parent</a><span>|</span><a href="#40305306">next</a><span>|</span><label class="collapse" for="c-40306347">[-]</label><label class="expand" for="c-40306347">[2 more]</label></div><br/><div class="children"><div class="content">Meh we used to have to install oracle databases this way, and the performance was always shit even over direct connections w&#x2F;cross cables.<p>I don’t think x over ssh is useful for much, can you imagine a browser this way?</div><br/><div id="40306422" class="c"><input type="checkbox" id="c-40306422" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#40306001">root</a><span>|</span><a href="#40306347">parent</a><span>|</span><a href="#40305306">next</a><span>|</span><label class="collapse" for="c-40306422">[-]</label><label class="expand" for="c-40306422">[1 more]</label></div><br/><div class="children"><div class="content">x2go is a bit smarter than pure x-forwardning and also allows you to resume a session at a different time (or on a different machine) similar to something like tmux. Much much better performance and does pretty well even on cellular.<p>A bit rough around the edges but brilliant for some usecases.</div><br/></div></div></div></div></div></div><div id="40305306" class="c"><input type="checkbox" id="c-40305306" checked=""/><div class="controls bullet"><span class="by">hiccuphippo</span><span>|</span><a href="#40306001">prev</a><span>|</span><a href="#40305091">next</a><span>|</span><label class="collapse" for="c-40305306">[-]</label><label class="expand" for="c-40305306">[2 more]</label></div><br/><div class="children"><div class="content">Related, a talk about replacing Xlib with their own abstraction with zig:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aPWFLkHRIAQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aPWFLkHRIAQ</a></div><br/><div id="40305745" class="c"><input type="checkbox" id="c-40305745" checked=""/><div class="controls bullet"><span class="by">izoow</span><span>|</span><a href="#40305306">parent</a><span>|</span><a href="#40305091">next</a><span>|</span><label class="collapse" for="c-40305745">[-]</label><label class="expand" for="c-40305745">[1 more]</label></div><br/><div class="children"><div class="content">Was just about to mention this. Also, just to add to this, even though it&#x27;s a zig talk, it&#x27;s not really the main focus of the talk. I enjoyed it and I don&#x27;t even know zig.</div><br/></div></div></div></div><div id="40305091" class="c"><input type="checkbox" id="c-40305091" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#40305306">prev</a><span>|</span><a href="#40306313">next</a><span>|</span><label class="collapse" for="c-40305091">[-]</label><label class="expand" for="c-40305091">[3 more]</label></div><br/><div class="children"><div class="content">I share the author&#x27;s opinion that xlib is harder to grok than the X11 protocol, because it&#x27;s the X11 protocol plus a queuing system where you will sometimes receive out-of-band messages, plus a large number of seldom-used utilities.</div><br/><div id="40305662" class="c"><input type="checkbox" id="c-40305662" checked=""/><div class="controls bullet"><span class="by">donio</span><span>|</span><a href="#40305091">parent</a><span>|</span><a href="#40305171">next</a><span>|</span><label class="collapse" for="c-40305662">[-]</label><label class="expand" for="c-40305662">[1 more]</label></div><br/><div class="children"><div class="content">Working with X11 client libraries written in other languages is a revelation in how much nicer an X11 client can be. CLX (Common Lisp) or xgb (Go) are some good examples.<p>(Talking about native implementations here not xlib bindings).</div><br/></div></div><div id="40305171" class="c"><input type="checkbox" id="c-40305171" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40305091">parent</a><span>|</span><a href="#40305662">prev</a><span>|</span><a href="#40306313">next</a><span>|</span><label class="collapse" for="c-40305171">[-]</label><label class="expand" for="c-40305171">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve not been a fan of xlib. xcb is a much better library, IMHO, although it&#x27;s not much more than talking X11 yourself. With Xlib, it seems like they tried to make things &#x27;easier&#x27; by having high level concepts and a lot of synchronous apis, but they don&#x27;t really fit on top of X, so you&#x27;re fighting the library. Unfortunately, xcb came later and lots of things were already built on xlib, so lots of software has unnecessary synchronicity that makes things slow when you use the network stuff.</div><br/></div></div></div></div><div id="40306313" class="c"><input type="checkbox" id="c-40306313" checked=""/><div class="controls bullet"><span class="by">pantalaimon</span><span>|</span><a href="#40305091">prev</a><span>|</span><a href="#40304894">next</a><span>|</span><label class="collapse" for="c-40306313">[-]</label><label class="expand" for="c-40306313">[2 more]</label></div><br/><div class="children"><div class="content">C also has structs, there is no need to assemble data structures in byte arrays.</div><br/><div id="40306385" class="c"><input type="checkbox" id="c-40306385" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#40306313">parent</a><span>|</span><a href="#40304894">next</a><span>|</span><label class="collapse" for="c-40306385">[-]</label><label class="expand" for="c-40306385">[1 more]</label></div><br/><div class="children"><div class="content">With the caveat that structs are padded by default so that members are aligned on architecture-friendly boundaries.<p>For example, if a struct contains a char <i>a</i> followed by an int <i>b</i>, typically b would be at offset 4, even though sizeof(a) is 1.<p>To get tight packing, you need to explicitly tell the compiler to disable padding.</div><br/></div></div></div></div><div id="40304894" class="c"><input type="checkbox" id="c-40304894" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40306313">prev</a><span>|</span><a href="#40306246">next</a><span>|</span><label class="collapse" for="c-40304894">[-]</label><label class="expand" for="c-40304894">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I was very surprised to learn that it is actually just a “regular” network protocol for two parties to communicate like HTTP, FTP, IMAP, SMPT and etc.<p>Typo: Simple Mail Transfer Protocol<p>And I suspect many of us tend to think of those as magical abstractions best dealt with through libraries as well:)</div><br/></div></div><div id="40306246" class="c"><input type="checkbox" id="c-40306246" checked=""/><div class="controls bullet"><span class="by">throwthrow5643</span><span>|</span><a href="#40304894">prev</a><span>|</span><a href="#40305488">next</a><span>|</span><label class="collapse" for="c-40306246">[-]</label><label class="expand" for="c-40306246">[1 more]</label></div><br/><div class="children"><div class="content">Can you do the same but in Wayland next?</div><br/></div></div><div id="40305488" class="c"><input type="checkbox" id="c-40305488" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40306246">prev</a><span>|</span><a href="#40304928">next</a><span>|</span><label class="collapse" for="c-40305488">[-]</label><label class="expand" for="c-40305488">[6 more]</label></div><br/><div class="children"><div class="content">One of the neat things we&#x27;ll be losing with X11 is the fact that you can do graphics -- fast -- entirely with the wire protocol. It was really a protocol for a sort of smart graphical terminal, so it&#x27;s like having an Amiga blitter at the other end of the network connection. From a &quot;zero to something on the screen&quot; standpoint, it&#x27;s fast and convenient, as you don&#x27;t have to manage your own framebuffer, shaders, dirty rectangle list, or any of that.<p>Of course, as any Gen-Z graphics hacker will tell you, That&#x27;s Just Not How Things Work Anymore, and rendering is and should be client-side, leaving the compositor to only present the final display. But it was fun while it lasted.</div><br/><div id="40305905" class="c"><input type="checkbox" id="c-40305905" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40305488">parent</a><span>|</span><a href="#40305983">next</a><span>|</span><label class="collapse" for="c-40305905">[-]</label><label class="expand" for="c-40305905">[4 more]</label></div><br/><div class="children"><div class="content">&gt; One of the neat things we&#x27;ll be losing with X11 is the fact that you can do graphics -- fast -- entirely with the wire protocol.<p>As long as you only want to do very basic graphics -- no antialiasing, no color blending, no subpixel coordinates. And it isn&#x27;t even that fast; everything ends up rendered on the CPU, possibly even all on a single thread, using code paths that haven&#x27;t seen much optimization in the last 20+ years.</div><br/><div id="40306399" class="c"><input type="checkbox" id="c-40306399" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40305488">root</a><span>|</span><a href="#40305905">parent</a><span>|</span><a href="#40306116">next</a><span>|</span><label class="collapse" for="c-40306399">[-]</label><label class="expand" for="c-40306399">[1 more]</label></div><br/><div class="children"><div class="content">Nothing on your feature list is incompatible with the client&#x2F;server approach though. The only downside would be when large pixel image blobs need to be sent over a network each frame.<p>In the end, modern 3D APIs are also a &#x27;wire protocol&#x27;, commands are recorded into local command buffers and played back by the GPU (often only connected to the CPU by a relatively slow bus), the only limiting factor is the amount of data that&#x27;s communicated between the CPU and GPU - and of course any additional latency that would be added by a network connection.</div><br/></div></div><div id="40306116" class="c"><input type="checkbox" id="c-40306116" checked=""/><div class="controls bullet"><span class="by">sprash</span><span>|</span><a href="#40305488">root</a><span>|</span><a href="#40305905">parent</a><span>|</span><a href="#40306399">prev</a><span>|</span><a href="#40305983">next</a><span>|</span><label class="collapse" for="c-40306116">[-]</label><label class="expand" for="c-40306116">[2 more]</label></div><br/><div class="children"><div class="content">This is why the XRender extension was introduced. There you have antialiasing, all blending modes you could wish for, subpixel coordinates, advanced drawing operations like gradients and it is fast because it is fully hardware accelerated. All working over a very efficient wire protocol. E.g. Cairo uses Xrender as a backend.</div><br/><div id="40306288" class="c"><input type="checkbox" id="c-40306288" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#40305488">root</a><span>|</span><a href="#40306116">parent</a><span>|</span><a href="#40305983">next</a><span>|</span><label class="collapse" for="c-40306288">[-]</label><label class="expand" for="c-40306288">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not all hardware accelerated though is it. Both the X server and Cairo depend on the pixman library, which is a CPU&#x2F;SIMD optimized pixel manipulation library.<p>Even xf86-video-intel, the intel X11 driver package, on my system depends on pixman.</div><br/></div></div></div></div></div></div><div id="40305983" class="c"><input type="checkbox" id="c-40305983" checked=""/><div class="controls bullet"><span class="by">caf</span><span>|</span><a href="#40305488">parent</a><span>|</span><a href="#40305905">prev</a><span>|</span><a href="#40304928">next</a><span>|</span><label class="collapse" for="c-40305983">[-]</label><label class="expand" for="c-40305983">[1 more]</label></div><br/><div class="children"><div class="content">Actual hardware &quot;smart graphical terminals&quot; that used that wire protocol were built for a while, too - I had some Labtam &#x2F; Tektronix XP400 X11 thin terminals.</div><br/></div></div></div></div><div id="40304928" class="c"><input type="checkbox" id="c-40304928" checked=""/><div class="controls bullet"><span class="by">PlunderBunny</span><span>|</span><a href="#40305488">prev</a><span>|</span><a href="#40304030">next</a><span>|</span><label class="collapse" for="c-40304928">[-]</label><label class="expand" for="c-40304928">[15 more]</label></div><br/><div class="children"><div class="content">To someone that’s reasonably computer savvy (professional developer but Windows and macOS only), what does X11 do? What are the benefits of this approach? What’s the ‘equivalent’ in Windows or macOS (if there is one)?</div><br/><div id="40306388" class="c"><input type="checkbox" id="c-40306388" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40305030">next</a><span>|</span><label class="collapse" for="c-40306388">[-]</label><label class="expand" for="c-40306388">[1 more]</label></div><br/><div class="children"><div class="content">Same thing as Cocoa or the windowing API in User32.dll, but as a network-transparent client&#x2F;server architecture (usually behind a library though, so doing things like opening a window is quite similar, except that Xlib isn&#x27;t very ergonomic).</div><br/></div></div><div id="40305030" class="c"><input type="checkbox" id="c-40305030" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40306388">prev</a><span>|</span><a href="#40305568">next</a><span>|</span><label class="collapse" for="c-40305030">[-]</label><label class="expand" for="c-40305030">[5 more]</label></div><br/><div class="children"><div class="content">A user on any X11 desktop can open a GUI from any X11 app, even one running in a datacenter. It&#x27;s like a Javascript app in a browser today, but every Unix GUI app knew how to do it on late 1980s hardware, so you didn&#x27;t even have to buy and admin a complete desktop computer for each user.<p>Windows sort of has this with RDP, but it&#x27;s tied in with the app&#x27;s GDI desktop, and I don&#x27;t know whether it works without buying a bunch of video cards for the headless app server. NeXTSTEP had Display PostScript (remote rendering worked like printing!) but macOS lost support for it.</div><br/><div id="40305074" class="c"><input type="checkbox" id="c-40305074" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305030">parent</a><span>|</span><a href="#40305568">next</a><span>|</span><label class="collapse" for="c-40305074">[-]</label><label class="expand" for="c-40305074">[4 more]</label></div><br/><div class="children"><div class="content">Somewhat misleading. Because these days, none of the network transparent primitives are used anymore. All the rendering happens server side, and bitmaps are sent over the wire. It&#x27;s basically a crappy VNC. And at that point, just use RDP or VNC</div><br/><div id="40305722" class="c"><input type="checkbox" id="c-40305722" checked=""/><div class="controls bullet"><span class="by">donio</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305074">parent</a><span>|</span><a href="#40306244">next</a><span>|</span><label class="collapse" for="c-40305722">[-]</label><label class="expand" for="c-40305722">[1 more]</label></div><br/><div class="children"><div class="content">That greatly depends on the type of applications you run and the toolkits and font rendering they use. My most commonly used applications (terminal emulator, Emacs) do their font rendering using the the glyph compositing functionality of the RENDER extension. Server side glyphs are created when a font is loaded and all the compositing is done on the server side based on the client&#x27;s CompositeGlyphs requests. Same for images (in Emacs) using CreatePixmap and CopyArea.</div><br/></div></div><div id="40306244" class="c"><input type="checkbox" id="c-40306244" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305074">parent</a><span>|</span><a href="#40305722">prev</a><span>|</span><a href="#40305244">next</a><span>|</span><label class="collapse" for="c-40306244">[-]</label><label class="expand" for="c-40306244">[1 more]</label></div><br/><div class="children"><div class="content">XPRA using h264 or h265 does a decent job in my experience in term of performance to increase over ssh -X.<p>On wayland from I am also getting good results with waypipe opening individual apps from VMs  to make it a poor man&#x27;s QubeOS without the complexity and without having to open the whole remote desktop.</div><br/></div></div><div id="40305244" class="c"><input type="checkbox" id="c-40305244" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305074">parent</a><span>|</span><a href="#40306244">prev</a><span>|</span><a href="#40305568">next</a><span>|</span><label class="collapse" for="c-40305244">[-]</label><label class="expand" for="c-40305244">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I have nothing constructive to say about apps and toolkits that choose only local rendering with no hardware, but it&#x27;s pretty funny to see <i>Javascript</i> apps beating them on performance.</div><br/></div></div></div></div></div></div><div id="40305568" class="c"><input type="checkbox" id="c-40305568" checked=""/><div class="controls bullet"><span class="by">neerajsi</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40305030">prev</a><span>|</span><a href="#40305053">next</a><span>|</span><label class="collapse" for="c-40305568">[-]</label><label class="expand" for="c-40305568">[2 more]</label></div><br/><div class="children"><div class="content">Afaik, Windows RDP used to do more complex remoting of drawing primitives so that the host computer would send the clients instructions for drawing individual elements.<p>But for many years now, they switched to an approach of rendering all the graphics on the host side and then sending a video stream to the client using standard video compression.  I think this compression based approach scales better for the common use cases, especially office apps where the display is mostly static. I guess the approach has almost gotten good enough that you can play games remotely that way.</div><br/><div id="40305682" class="c"><input type="checkbox" id="c-40305682" checked=""/><div class="controls bullet"><span class="by">bananskalhalk</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305568">parent</a><span>|</span><a href="#40305053">next</a><span>|</span><label class="collapse" for="c-40305682">[-]</label><label class="expand" for="c-40305682">[1 more]</label></div><br/><div class="children"><div class="content">You got any source for this? I am only asking since I got the impression rdp was a superior protocol to vnc, nx etc because of the complex handling of graphical primitives. But I know next to nothing about the real technical details.</div><br/></div></div></div></div><div id="40305053" class="c"><input type="checkbox" id="c-40305053" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40305568">prev</a><span>|</span><a href="#40305069">next</a><span>|</span><label class="collapse" for="c-40305053">[-]</label><label class="expand" for="c-40305053">[3 more]</label></div><br/><div class="children"><div class="content">X11 is a distributed systems clustering protocol for asynchronous message passing that outputs graphics as a side effect. It&#x27;s like Erlang&#x27;s dist, but with a side channel to a display.<p>A more real answer, is the X server manages access to the input and output devices... Roughly speaking, it lets a client define a region (rectangle) and get clicks and mouse motion and keyboard input sometimes (maybe too often), and lets the client send things to be displayed. In modern times, that&#x27;s mostly images, but it used to be lines and curves and letters and things, or like OpenGL display lists. The server can tell the client when it is exposed and need to redraw or it can use a backing store to keep obscured parts of the region local to the display. Additionally, clients can adjust other client&#x27;s resources (this is what a window manager does) and clients can communicate with each other through the server (no full mesh like in Erlang dist) ... that part is a bit confusing.<p>On Windows and macOS (either one), there&#x27;s no sense of a network involved, similar things happen, but mostly with system calls, I think. Otoh macOS X has all those mach ports? does UI go through that? But there are X11 servers for most platforms that integrate reasonably well, so it&#x27;s not like you can&#x27;t use X concepts there, it&#x27;s just a bit more setup to get started. Windows also has RDP which can be used to run a program on one computer and display it on another.<p>The benefit of this approach is you can take better advantage of asynchrony... Many GUI libraries and toolkits run in a synchronous model where you do a request and can&#x27;t continue until you get the answer. That&#x27;s fine when everything is fast, but when there&#x27;s a network between the client and server, it&#x27;s better to send requests when you have them and only wait for the response when you need it. (See also xcb vs xlib)</div><br/><div id="40305671" class="c"><input type="checkbox" id="c-40305671" checked=""/><div class="controls bullet"><span class="by">jack_pp</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305053">parent</a><span>|</span><a href="#40305369">next</a><span>|</span><label class="collapse" for="c-40305671">[-]</label><label class="expand" for="c-40305671">[1 more]</label></div><br/><div class="children"><div class="content">I might be wrong but I think the closest thing in windows land is RDP with regard to low level rendering of the display over the network</div><br/></div></div><div id="40305369" class="c"><input type="checkbox" id="c-40305369" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#40304928">root</a><span>|</span><a href="#40305053">parent</a><span>|</span><a href="#40305671">prev</a><span>|</span><a href="#40305069">next</a><span>|</span><label class="collapse" for="c-40305369">[-]</label><label class="expand" for="c-40305369">[1 more]</label></div><br/><div class="children"><div class="content">Yeah on macos the communication between your app and the window server (which is conveniently called WindowServer) happens via mach ports. Most of it is undocumented, in fact anything more &quot;low-level&quot; than using AppKit is undocumented, although IIRC it is in principle possible to use undocumented CG* apis to create and manipulate windows yourself without going through the appkit layers. I think each CG* api is basically a thin shim that communicates to the window server, which has a corresponding CGX* implementation which does the actual logic. This article has some details <a href="https:&#x2F;&#x2F;keenlab.tencent.com&#x2F;en&#x2F;2016&#x2F;07&#x2F;22&#x2F;WindowServer-The-privilege-chameleon-on-macOS-Part-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;keenlab.tencent.com&#x2F;en&#x2F;2016&#x2F;07&#x2F;22&#x2F;WindowServer-The-p...</a></div><br/></div></div></div></div><div id="40305069" class="c"><input type="checkbox" id="c-40305069" checked=""/><div class="controls bullet"><span class="by">naruhodo</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40305053">prev</a><span>|</span><a href="#40305076">next</a><span>|</span><label class="collapse" for="c-40305069">[-]</label><label class="expand" for="c-40305069">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a network transparent display protocol.<p>Real life scenario: you have a headless server that has GUI software installed at a remote site. You connect to the network from home with a VPN. Then SSH in to the server with &quot;ssh -X user@server&quot; and run the GUI program in that terminal. The GUI appears on your local display. SSH sends the X11 protocol traffic through an encrypted tunnel from the remote server to the local X11 display server, because of the -X.</div><br/></div></div><div id="40305076" class="c"><input type="checkbox" id="c-40305076" checked=""/><div class="controls bullet"><span class="by">TheDauthi</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40305069">prev</a><span>|</span><a href="#40305041">next</a><span>|</span><label class="collapse" for="c-40305076">[-]</label><label class="expand" for="c-40305076">[1 more]</label></div><br/><div class="children"><div class="content">In Windows, it&#x27;s kinda split between the Windows Display Driver Model (WDDM) and the Desktop Window Manager (DWM). That&#x27;s not a 1:1 match, though, as those two combined cover more components of a functioning whole than X11&#x2F;XOrg itself does. X11 just split the components needed to draw everything you&#x27;d need for graphical environment into a different choice of layers.<p>X11 got network transparency out of the box (a sibling comment touches this), and the capability of switching out the components more easily, while Windows had less work to do to smooth out the overall desktop experience.</div><br/></div></div><div id="40305041" class="c"><input type="checkbox" id="c-40305041" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#40304928">parent</a><span>|</span><a href="#40305076">prev</a><span>|</span><a href="#40304030">next</a><span>|</span><label class="collapse" for="c-40305041">[-]</label><label class="expand" for="c-40305041">[1 more]</label></div><br/><div class="children"><div class="content">I am not very familiar with any of them at a low level but I think you can sum it up as Apple and Microsoft defined their display server as an api, a programing interface. MIT defined theirs as a protocol, a communication interface. With the intention that any api supplied should have a very flexible transport.</div><br/></div></div></div></div><div id="40304030" class="c"><input type="checkbox" id="c-40304030" checked=""/><div class="controls bullet"><span class="by">pestatije</span><span>|</span><a href="#40304928">prev</a><span>|</span><a href="#40304971">next</a><span>|</span><label class="collapse" for="c-40304030">[-]</label><label class="expand" for="c-40304030">[1 more]</label></div><br/><div class="children"><div class="content">X11 Windows, not the obvious Windows</div><br/></div></div><div id="40304971" class="c"><input type="checkbox" id="c-40304971" checked=""/><div class="controls bullet"><span class="by">leeman2016</span><span>|</span><a href="#40304030">prev</a><span>|</span><a href="#40305645">next</a><span>|</span><label class="collapse" for="c-40304971">[-]</label><label class="expand" for="c-40304971">[4 more]</label></div><br/><div class="children"><div class="content">I think the “Windows” in the title should be written with small “w”</div><br/><div id="40305747" class="c"><input type="checkbox" id="c-40305747" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#40304971">parent</a><span>|</span><a href="#40305254">next</a><span>|</span><label class="collapse" for="c-40305747">[-]</label><label class="expand" for="c-40305747">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and the first sentence of the post should have &quot;a window&quot; rather than &quot;a Windows&quot;, because as is it add to the title&#x27;s confusion between X windows and MS Windows.</div><br/></div></div><div id="40305254" class="c"><input type="checkbox" id="c-40305254" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#40304971">parent</a><span>|</span><a href="#40305747">prev</a><span>|</span><a href="#40306072">next</a><span>|</span><label class="collapse" for="c-40305254">[-]</label><label class="expand" for="c-40305254">[1 more]</label></div><br/><div class="children"><div class="content">even if this is technical article, the title is very clickbaity.</div><br/></div></div></div></div></div></div></div></div></div></body></html>