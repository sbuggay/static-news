<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736240477098" as="style"/><link rel="stylesheet" href="styles.css?v=1736240477098"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zone.dog/braindump/spline_fields/">Spline Distance Fields</a> <span class="domain">(<a href="https://zone.dog">zone.dog</a>)</span></div><div class="subtext"><span>ibobev</span> | <span>27 comments</span></div><br/><div><div id="42612529" class="c"><input type="checkbox" id="c-42612529" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42613295">next</a><span>|</span><label class="collapse" for="c-42612529">[-]</label><label class="expand" for="c-42612529">[3 more]</label></div><br/><div class="children"><div class="content">This reminds me when i worked on an open world game ~12 years ago. I implemented spline-based &quot;stripes&quot; (think long decals), mainly to be used for roads (though could also be used for smaller things like blood trails) and i added a button in the editor to align the terrain with the stripe with a configurable falloff so that it transitions smoothly from the stripe to the surrounding terrain - and optionally you could use a (grayscale) texture to modulate the falloff so that the transition isn&#x27;t completely smooth.<p>Next thing i knew, the environment artists had started using stripes to sculpt the terrain :-P</div><br/><div id="42613288" class="c"><input type="checkbox" id="c-42613288" checked=""/><div class="controls bullet"><span class="by">Minor49er</span><span>|</span><a href="#42612529">parent</a><span>|</span><a href="#42613295">next</a><span>|</span><label class="collapse" for="c-42613288">[-]</label><label class="expand" for="c-42613288">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re Bad Sector from the Rome.ro forums (way back when those existed), aren&#x27;t you?</div><br/><div id="42613506" class="c"><input type="checkbox" id="c-42613506" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42612529">root</a><span>|</span><a href="#42613288">parent</a><span>|</span><a href="#42613295">next</a><span>|</span><label class="collapse" for="c-42613506">[-]</label><label class="expand" for="c-42613506">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;d be me :-)</div><br/></div></div></div></div></div></div><div id="42613295" class="c"><input type="checkbox" id="c-42613295" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#42612529">prev</a><span>|</span><a href="#42618567">next</a><span>|</span><label class="collapse" for="c-42613295">[-]</label><label class="expand" for="c-42613295">[9 more]</label></div><br/><div class="children"><div class="content">It’s nice to see some real-world graphics programming in a visual language.<p>Node-based environments can be powerful for exploring solutions like this, but they don’t often make it to Hacker News.</div><br/><div id="42613838" class="c"><input type="checkbox" id="c-42613838" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42613295">parent</a><span>|</span><a href="#42614831">next</a><span>|</span><label class="collapse" for="c-42613838">[-]</label><label class="expand" for="c-42613838">[5 more]</label></div><br/><div class="children"><div class="content">They can also be quite messy and hard&#x2F;annoying to follow&#x2F;parse since a lot of screen real estate is used for trivial things. For example the first graph wastes 300x250 pixels several times for what would be a single character in a text-based language (and that&#x27;s if you ignore the padding between the nodes since you could claim that whitespace in a text-based language serves the same purpose).<p>And unlike a text-based language where there is (usually) a single flow path going towards a single direction, with graphics like the one in the article you have several &quot;flows&quot; so your eyes need to move all over the place all the time to connect the &quot;bits&quot; in order to figure out what is going on.<p>Though that last part could probably be solved by using DRAKON graphs instead (which can also use less screen space) since those have a more strict flow.<p>IMO graph-based visual languages are nice for very high level flows but the moment you need to use more than a couple &quot;dot product&quot; or &quot;add values&quot; nodes, it is time to switch to a text-based one.</div><br/><div id="42614622" class="c"><input type="checkbox" id="c-42614622" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#42613295">root</a><span>|</span><a href="#42613838">parent</a><span>|</span><a href="#42614841">next</a><span>|</span><label class="collapse" for="c-42614622">[-]</label><label class="expand" for="c-42614622">[2 more]</label></div><br/><div class="children"><div class="content">I agree that large node graphs get unwieldy and nobody has come up with a great solution for that. Macros and independently scalable groups and visual annotations can help, but it depends on the type of program.<p>I disagree about the single-direction “1D” nature of textual programs being unequivocally a benefit. When there are many independent paths that eventually combine, it’s easier to see the complete flow in a 2D graph. Linear text creates the illusion of dependency and order, even if your computation doesn’t actually have those properties.<p>Conserving screen space is a double-edged sword. If that were the most important thing in programming, we’d all be writing APL-style dense one-liners for production. But code legibility and reusability is a lot more than just who does the most with the least symbols.</div><br/><div id="42616410" class="c"><input type="checkbox" id="c-42616410" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42613295">root</a><span>|</span><a href="#42614622">parent</a><span>|</span><a href="#42614841">next</a><span>|</span><label class="collapse" for="c-42616410">[-]</label><label class="expand" for="c-42616410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I disagree about the single-direction “1D” nature of textual programs being unequivocally a benefit. When there are many independent paths that eventually combine, it’s easier to see the complete flow in a 2D graph.<p>This is where having separate functions help - as a bonus you can focus on that independent path without the rest being a distraction.<p>If there are <i>multiple</i> independent paths that connect at separate points where you can&#x27;t isolate them easily if they were a function, the graph is already a mess.<p>&gt; Conserving screen space is a double-edged sword. If that were the most important thing in programming, we’d all be writing APL-style dense one-liners for production.<p>That is a bit of an extreme case, it isn&#x27;t about conserving <i>all</i> the screen real estate, just not being overly wasteful. After all the most common argument you&#x27;d see about -say- Pascal-style syntax is that it is too verbose compared to C-like syntax, despite the difference not being that great. You&#x27;ll notice that despite APL-like syntax not being very popular, COBOL-like syntax isn&#x27;t popular either.<p>You don&#x27;t have to go to extremes - notice that in my comment i never wrote that <i>all</i> uses of graphs should be avoided.</div><br/></div></div></div></div><div id="42614841" class="c"><input type="checkbox" id="c-42614841" checked=""/><div class="controls bullet"><span class="by">nkrisc</span><span>|</span><a href="#42613295">root</a><span>|</span><a href="#42613838">parent</a><span>|</span><a href="#42614622">prev</a><span>|</span><a href="#42614831">next</a><span>|</span><label class="collapse" for="c-42614841">[-]</label><label class="expand" for="c-42614841">[2 more]</label></div><br/><div class="children"><div class="content">I would wager that Blender&#x27;s geometry nodes are over all a net saving in screen real estate when compared to the amount of code they abstract away. Sure, in a trivial example they seem unnecessarily large, but there are some nodes that do a lot of heavy lifting, and are no bigger than any other node. Overall a strange metric to track, IMO, unless all your variable names are one letter.</div><br/><div id="42616460" class="c"><input type="checkbox" id="c-42616460" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42613295">root</a><span>|</span><a href="#42614841">parent</a><span>|</span><a href="#42614831">next</a><span>|</span><label class="collapse" for="c-42616460">[-]</label><label class="expand" for="c-42616460">[1 more]</label></div><br/><div class="children"><div class="content">Which is why i wrote that last paragraph: for high level stuff with nodes that abstract the heavy lifting they are fine. Sometimes you may even need these &quot;add&quot; and &quot;dot product&quot; nodes to glue these together. The issue is when you start using a lot of &quot;low level&quot; nodes.<p>Think of it like using a shell script vs something like Python: you can do a ton of things in shell scripts and write very complex shell scripts, but chances are if a shell script is more than a few lines that glue other programs together, it&#x27;d be better to use Python (or something similar) despite both being &quot;scripting&quot; languages.</div><br/></div></div></div></div></div></div><div id="42614831" class="c"><input type="checkbox" id="c-42614831" checked=""/><div class="controls bullet"><span class="by">nkrisc</span><span>|</span><a href="#42613295">parent</a><span>|</span><a href="#42613838">prev</a><span>|</span><a href="#42614107">next</a><span>|</span><label class="collapse" for="c-42614831">[-]</label><label class="expand" for="c-42614831">[2 more]</label></div><br/><div class="children"><div class="content">There are times when using Blender&#x27;s shading node graph that I&#x27;d really just rather be writing GLSL&#x2F;HLSL. But overall I still like it.<p>Geometry nodes, on the other hand, I think are amazing. They really do provide a very useful abstraction over what would be <i>a lot</i> of tedious and error-prone boiler plate code.<p>With just a few nodes I can instances and properly rotate some mesh on every face of some other mesh. Boom, done in two minutes. And you can do so, so much more, of course.<p>The obvious downside is in complex scenarios the graph can be more difficult to manage and because of the nature of how its evaluated there are times you need to think about &quot;capturing&quot; attributes (basically a variable to hold an older value of something that gets changed later). But nothing is perfect.</div><br/><div id="42618348" class="c"><input type="checkbox" id="c-42618348" checked=""/><div class="controls bullet"><span class="by">MrLeap</span><span>|</span><a href="#42613295">root</a><span>|</span><a href="#42614831">parent</a><span>|</span><a href="#42614107">next</a><span>|</span><label class="collapse" for="c-42618348">[-]</label><label class="expand" for="c-42618348">[1 more]</label></div><br/><div class="children"><div class="content">In unity shadergraph there&#x27;s a &quot;custom node&quot; that just lets you type in hlsl&#x2F;glsl or choose a file. You set its inputs and outputs and that becomes its handles. It&#x27;s pretty nice.<p>Looks like blender has something reminiscent? Maybe? I haven&#x27;t used it.
<a href="https:&#x2F;&#x2F;docs.blender.org&#x2F;manual&#x2F;en&#x2F;latest&#x2F;render&#x2F;shader_nodes&#x2F;osl.html" rel="nofollow">https:&#x2F;&#x2F;docs.blender.org&#x2F;manual&#x2F;en&#x2F;latest&#x2F;render&#x2F;shader_node...</a></div><br/></div></div></div></div><div id="42614107" class="c"><input type="checkbox" id="c-42614107" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42613295">parent</a><span>|</span><a href="#42614831">prev</a><span>|</span><a href="#42618567">next</a><span>|</span><label class="collapse" for="c-42614107">[-]</label><label class="expand" for="c-42614107">[1 more]</label></div><br/><div class="children"><div class="content">One of my favourites is:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;derkork&#x2F;openscad-graph-editor">https:&#x2F;&#x2F;github.com&#x2F;derkork&#x2F;openscad-graph-editor</a><p>though I usually use:<p><a href="https:&#x2F;&#x2F;www.blockscad3d.com&#x2F;editor&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.blockscad3d.com&#x2F;editor&#x2F;</a></div><br/></div></div></div></div><div id="42618567" class="c"><input type="checkbox" id="c-42618567" checked=""/><div class="controls bullet"><span class="by">ckrailo</span><span>|</span><a href="#42613295">prev</a><span>|</span><a href="#42617099">next</a><span>|</span><label class="collapse" for="c-42618567">[-]</label><label class="expand" for="c-42618567">[1 more]</label></div><br/><div class="children"><div class="content">The surfels and isolines examples were great, reminded me of reticulating splines! [1]<p>[1] <a href="https:&#x2F;&#x2F;66.media.tumblr.com&#x2F;142beeb156e568a2e1329775ad053fde&#x2F;tumblr_nlttn5BfU41uo5d9jo1_540.gif" rel="nofollow">https:&#x2F;&#x2F;66.media.tumblr.com&#x2F;142beeb156e568a2e1329775ad053fde...</a></div><br/></div></div><div id="42617099" class="c"><input type="checkbox" id="c-42617099" checked=""/><div class="controls bullet"><span class="by">mclau156</span><span>|</span><a href="#42618567">prev</a><span>|</span><a href="#42612588">next</a><span>|</span><label class="collapse" for="c-42617099">[-]</label><label class="expand" for="c-42617099">[1 more]</label></div><br/><div class="children"><div class="content">Terrain deformation by curves in Godot:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=s1s1zdTGliQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=s1s1zdTGliQ</a></div><br/></div></div><div id="42612588" class="c"><input type="checkbox" id="c-42612588" checked=""/><div class="controls bullet"><span class="by">r1chardnl</span><span>|</span><a href="#42617099">prev</a><span>|</span><a href="#42612215">next</a><span>|</span><label class="collapse" for="c-42612588">[-]</label><label class="expand" for="c-42612588">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of Quake patchDef (Biquadratic Bézier surface patches)
<a href="https:&#x2F;&#x2F;quark.sourceforge.io&#x2F;infobase&#x2F;maped.curves.html" rel="nofollow">https:&#x2F;&#x2F;quark.sourceforge.io&#x2F;infobase&#x2F;maped.curves.html</a></div><br/></div></div><div id="42612215" class="c"><input type="checkbox" id="c-42612215" checked=""/><div class="controls bullet"><span class="by">kvark</span><span>|</span><a href="#42612588">prev</a><span>|</span><label class="collapse" for="c-42612215">[-]</label><label class="expand" for="c-42612215">[11 more]</label></div><br/><div class="children"><div class="content">They developed a content generation tool based on splines, as well as a rendering algorithm based on finding the closest splines to each point. They are claiming real-time rendering (4k at 120hz) on CPU... why not run this on GPU?</div><br/><div id="42612609" class="c"><input type="checkbox" id="c-42612609" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#42612215">parent</a><span>|</span><a href="#42612489">next</a><span>|</span><label class="collapse" for="c-42612609">[-]</label><label class="expand" for="c-42612609">[1 more]</label></div><br/><div class="children"><div class="content">Because you can use tools on the splines. You can&#x27;t do that on the GPU.</div><br/></div></div><div id="42612489" class="c"><input type="checkbox" id="c-42612489" checked=""/><div class="controls bullet"><span class="by">felipellrocha</span><span>|</span><a href="#42612215">parent</a><span>|</span><a href="#42612609">prev</a><span>|</span><a href="#42613818">next</a><span>|</span><label class="collapse" for="c-42612489">[-]</label><label class="expand" for="c-42612489">[1 more]</label></div><br/><div class="children"><div class="content">Boy... I hate questions of the form &quot;Why not just&quot;. Which, to be fair... is not the exact form, but the intent of the question.</div><br/></div></div><div id="42613818" class="c"><input type="checkbox" id="c-42613818" checked=""/><div class="controls bullet"><span class="by">dcrazy</span><span>|</span><a href="#42612215">parent</a><span>|</span><a href="#42612489">prev</a><span>|</span><a href="#42613492">next</a><span>|</span><label class="collapse" for="c-42613818">[-]</label><label class="expand" for="c-42613818">[1 more]</label></div><br/><div class="children"><div class="content">Run _what_ on the GPU? All of Blender?</div><br/></div></div><div id="42612637" class="c"><input type="checkbox" id="c-42612637" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#42612215">parent</a><span>|</span><a href="#42613492">prev</a><span>|</span><label class="collapse" for="c-42612637">[-]</label><label class="expand" for="c-42612637">[6 more]</label></div><br/><div class="children"><div class="content">If the claims of real-time use are true, why bother?</div><br/><div id="42612846" class="c"><input type="checkbox" id="c-42612846" checked=""/><div class="controls bullet"><span class="by">kvark</span><span>|</span><a href="#42612215">root</a><span>|</span><a href="#42612637">parent</a><span>|</span><label class="collapse" for="c-42612846">[-]</label><label class="expand" for="c-42612846">[5 more]</label></div><br/><div class="children"><div class="content">Because it has to go through gpu anyway before it reaches the screen, gpu can be more efficient at doing this (better battery, etc), and we are wasting time transferring the pixels to gpu where the splines would be much more compact.</div><br/><div id="42613842" class="c"><input type="checkbox" id="c-42613842" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#42612215">root</a><span>|</span><a href="#42612846">parent</a><span>|</span><label class="collapse" for="c-42613842">[-]</label><label class="expand" for="c-42613842">[4 more]</label></div><br/><div class="children"><div class="content">minor nit: it seems like they&#x27;re not rasterizing every pixel on cpu, instead just generating heightmap values instead, which is a lot lower resolution?<p>and games like Dreams have proven that you can ship world class experiences using CPU rasterization. If it&#x27;s easier and it performs good enough, nothing wrong with it.</div><br/><div id="42617266" class="c"><input type="checkbox" id="c-42617266" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42612215">root</a><span>|</span><a href="#42613842">parent</a><span>|</span><label class="collapse" for="c-42617266">[-]</label><label class="expand" for="c-42617266">[3 more]</label></div><br/><div class="children"><div class="content">We there are two different things here.<p>The custom CPU rasteriser (Star Machine) that pushes 4k 120hz is mentioned in the intro, but the implementation of spline-based terrain covered by the article is just a prototype developed in blender. Blender is used for faster rapid iteration of the algorithm.<p>While the Blender version is at least partially GPU accelerated, the final implementation in Star Machine will be entirely on the CPU. It&#x27;s currently unknown if the CPU implementation will trace against the cached height map or against a sparse point cloud (also cached)</div><br/><div id="42617938" class="c"><input type="checkbox" id="c-42617938" checked=""/><div class="controls bullet"><span class="by">pragmatic8</span><span>|</span><a href="#42612215">root</a><span>|</span><a href="#42617266">parent</a><span>|</span><label class="collapse" for="c-42617938">[-]</label><label class="expand" for="c-42617938">[2 more]</label></div><br/><div class="children"><div class="content">I looked at the Star Machine repository and it looks like its using SDL_gpu [1,2], so I am a little confused about where the &#x27;CPU&#x27; rasteriser designation comes from.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Aeva&#x2F;star-machine&#x2F;blob&#x2F;excelsior&#x2F;star_machine&#x2F;SDL3.cs">https:&#x2F;&#x2F;github.com&#x2F;Aeva&#x2F;star-machine&#x2F;blob&#x2F;excelsior&#x2F;star_mac...</a><p>[2] <a href="https:&#x2F;&#x2F;wiki.libsdl.org&#x2F;SDL3&#x2F;CategoryGPU" rel="nofollow">https:&#x2F;&#x2F;wiki.libsdl.org&#x2F;SDL3&#x2F;CategoryGPU</a></div><br/><div id="42618186" class="c"><input type="checkbox" id="c-42618186" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42612215">root</a><span>|</span><a href="#42617938">parent</a><span>|</span><label class="collapse" for="c-42618186">[-]</label><label class="expand" for="c-42618186">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t read though the whole thing, but my rough understanding is:<p>- A ray tracer runs on the CPUs, and generates surfels (aka splats)<p>- The surfels are uploaded to the GPU<p>- Then the GPU rasterizes the surfels into a framebuffer (and draws the UI, probably other things too)<p>So it&#x27;s the ray tracing that&#x27;s running on the CPU, not the rasterizer. Compared to a traditional CPU ray tracer, the GPU is not idle and still doing what it does best (memory intensive rasterization), and the CPU can do the branchy parts of ray tracing (which GPU ray tracing implementations struggle with).<p>The number of surfels can be adjusted dynamically per frame, to keep a consistent framerate, and there will be far less surfels than pixels, reducing the PCIe bandwidth requirements. The surfels can also by dynamically allocated within a frame, focusing on the parts with high-frequency detail.<p>It&#x27;s an interesting design, and I&#x27;m curious what else is possible. Can you do temporal reproduction of surfels? Can you move materials partially onto the GPU?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>