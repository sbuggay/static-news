<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708419661424" as="style"/><link rel="stylesheet" href="styles.css?v=1708419661424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://thradams.com/cake/ownership.html">Cake – C23 and Beyond (2023)</a> <span class="domain">(<a href="http://thradams.com">thradams.com</a>)</span></div><div class="subtext"><span>hudon</span> | <span>67 comments</span></div><br/><div><div id="39439039" class="c"><input type="checkbox" id="c-39439039" checked=""/><div class="controls bullet"><span class="by">Rucadi</span><span>|</span><a href="#39436740">next</a><span>|</span><label class="collapse" for="c-39439039">[-]</label><label class="expand" for="c-39439039">[1 more]</label></div><br/><div class="children"><div class="content">This project is amazing because it also seems that has #embed included, IIRC no other compiler has it yet.<p>Just for that #embed directive I would already use cake for the moment (although it seems like it is only doing the file-&gt;array conversion)</div><br/></div></div><div id="39436740" class="c"><input type="checkbox" id="c-39436740" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#39439039">prev</a><span>|</span><a href="#39437774">next</a><span>|</span><label class="collapse" for="c-39436740">[-]</label><label class="expand" for="c-39436740">[7 more]</label></div><br/><div class="children"><div class="content">Nice. If this can be reasonably retrofitted to existing libraries and projects so that the safety properties compose from local to global, then this could actually be a meaningful improvement to the safety of real-world C code.<p>There would be many more steps required &quot;toward&quot; memory safety, such as eliminating all forms of UB including uninitialized memory, out of bounds pointers, data races, etc. but if this direction is to be pursued it has to start somewhere.</div><br/><div id="39437421" class="c"><input type="checkbox" id="c-39437421" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39436740">parent</a><span>|</span><a href="#39437484">next</a><span>|</span><label class="collapse" for="c-39437421">[-]</label><label class="expand" for="c-39437421">[1 more]</label></div><br/><div class="children"><div class="content">&quot;uninitialized memory&quot; and  &quot;null checks&quot; is part of flow analysis.
UB and out of bound is not part of it.</div><br/></div></div><div id="39437484" class="c"><input type="checkbox" id="c-39437484" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39436740">parent</a><span>|</span><a href="#39437421">prev</a><span>|</span><a href="#39437774">next</a><span>|</span><label class="collapse" for="c-39437484">[-]</label><label class="expand" for="c-39437484">[5 more]</label></div><br/><div class="children"><div class="content">It’s hard to imagine that ownership composes all that well.</div><br/><div id="39437578" class="c"><input type="checkbox" id="c-39437578" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39436740">root</a><span>|</span><a href="#39437484">parent</a><span>|</span><a href="#39437774">next</a><span>|</span><label class="collapse" for="c-39437578">[-]</label><label class="expand" for="c-39437578">[4 more]</label></div><br/><div class="children"><div class="content">The real experience so far is the cake source itself.</div><br/><div id="39437647" class="c"><input type="checkbox" id="c-39437647" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39436740">root</a><span>|</span><a href="#39437578">parent</a><span>|</span><a href="#39437774">next</a><span>|</span><label class="collapse" for="c-39437647">[-]</label><label class="expand" for="c-39437647">[3 more]</label></div><br/><div class="children"><div class="content">Not sure I agree with that premise as the cake source would have been written in a way to be compatible with ownership annotations from the get go vs retrofitting an existing codebase. Help me understand how something like this composes:<p><pre><code>    FILE* open_file(const char* p) {
        FILE* owner f = …
        return f;
    }
</code></pre>
Now open_file callers would need to know that ownership is being returned which means that local variables would need to have the owner annotation propagated. That’s what I mean when I say it’s not composable - the ownership has to propagate fully throughout the codebase for a specific resource. Of course maybe you know better as this is just an initial glimpse on my part.</div><br/><div id="39437769" class="c"><input type="checkbox" id="c-39437769" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39436740">root</a><span>|</span><a href="#39437647">parent</a><span>|</span><a href="#39437834">next</a><span>|</span><label class="collapse" for="c-39437769">[-]</label><label class="expand" for="c-39437769">[1 more]</label></div><br/><div class="children"><div class="content">This code will not compile because we cannot return owner as non owner.<p>To fix we need  to add qualifier owner at return type.<p><pre><code>    FILE* owner open_file(const char* p) {
        FILE* owner f = …
        return f;
    }
</code></pre>
Then when returning f , f is moved. Because f was moved the compiler will not complain at the end of scope of f.<p><a href="https:&#x2F;&#x2F;thradams.com&#x2F;cake&#x2F;playground.html?code=I2luY2x1ZGUgPG93bmVyc2hpcC5oPiANCiNpbmNsdWRlIDxzdGRsaWIuaD4NCiNpbmNsdWRlIDxzdGRpby5oPg0KRklMRSAqIG93bmVyIG9wZW5maWxlKGNvbnN0IGNoYXIqIG5hbWUpDQp7DQogRklMRSAqb3duZXIgZiA9IGZvcGVuKCJmaWxlLnR4dCIsICJyIik7IA0KICByZXR1cm4gZjsNCn0NCg0KaW50IG1haW4oKQ0Kew0KICAgIEZJTEUgKm93bmVyIGYgPSBvcGVuZmlsZSgiZmlsZS50eHQiKTsgDQogICAgaWYgKGYpIGZjbG9zZShmKTsNCn0%3D&amp;to=-1&amp;options=" rel="nofollow">https:&#x2F;&#x2F;thradams.com&#x2F;cake&#x2F;playground.html?code=I2luY2x1ZGUgP...</a></div><br/></div></div><div id="39437834" class="c"><input type="checkbox" id="c-39437834" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39436740">root</a><span>|</span><a href="#39437647">parent</a><span>|</span><a href="#39437769">prev</a><span>|</span><a href="#39437774">next</a><span>|</span><label class="collapse" for="c-39437834">[-]</label><label class="expand" for="c-39437834">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if I understood. the usage of old and new (checked and unchecked) is a challenge.We may have the same headers used in both codes.
The other challenging is that same source may compile in compiler with or without support.<p>Ownership Feature Strategy (Inspired by stdbool.h)<p>If the compiler supports ownership checks and qualifiers such as _Owner, _View, _Obj_view, etc., it must define __STDC_OWNERSHIP__.<p>However, even if the compiler implements ownership, it is not active by default. The objective is to have a smooth transition allowing some files without checks. For instance, a thirty part code inside your project.<p>For instance, when compiling this file, even if the compiler supports ownership we don&#x27;t have errors or warnings because the checks are not enabled by default.<p><pre><code>    #include &lt;stdlib.h&gt;

    int main() {
      void \* p = malloc(1);
    }
</code></pre>
A second define __OWNERSHIP_H__, is used to enable ownership. This define is set when we include &lt;ownership.h&gt; at beginning.<p><pre><code>    #include &lt;ownership.h&gt;
    #include &lt;stdlib.h&gt;

    int main() {
      void \* p = malloc(1); &#x2F;&#x2F;error: missing owner qualifier
    }
</code></pre>
The other advantage of having a &lt;ownership.h&gt; is because owner is a macro that can be defined as empty in case the compiler does not support ownership, allowing the same code to be compiled in compilers without ownership support.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39437774" class="c"><input type="checkbox" id="c-39437774" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#39436740">prev</a><span>|</span><a href="#39437066">next</a><span>|</span><label class="collapse" for="c-39437774">[-]</label><label class="expand" for="c-39437774">[2 more]</label></div><br/><div class="children"><div class="content">I might be missing something, but this seems to require ownership annotations on all functions, e.g. a compatible and correct prototype for `fclose` to correctly note that the owned `FILE *` is moved into the call.<p>If that&#x27;s correct, then this is somewhat practically limited: either pre-existing codebases will need to be retrofitted with an essentially bespoke set of macros, or the compiler will need to be &quot;fail open&quot; by default. The tradeoffs between these two are hard (substantial developer pain versus being ineffective against the bulk of a compiled program&#x27;s API surface).<p>(Also, this design appears to be for temporal safety only, not spatial safety. But again I might have missed something.)</div><br/><div id="39437855" class="c"><input type="checkbox" id="c-39437855" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437774">parent</a><span>|</span><a href="#39437066">next</a><span>|</span><label class="collapse" for="c-39437855">[-]</label><label class="expand" for="c-39437855">[1 more]</label></div><br/><div class="children"><div class="content">currently cake uses existing msvc and gcc headers.
These headers does not have any owner qualifiers.<p>The temporary solution, is the re-declare the malloc etc when compiling with cake and not complain withe the function signature difference only by owner qualifiers.<p>if this ownership were standard then gcc and mscv headers would have the qualifiers there enabled or not , but they would be there.</div><br/></div></div></div></div><div id="39437066" class="c"><input type="checkbox" id="c-39437066" checked=""/><div class="controls bullet"><span class="by">ahgamut</span><span>|</span><a href="#39437774">prev</a><span>|</span><a href="#39437325">next</a><span>|</span><label class="collapse" for="c-39437066">[-]</label><label class="expand" for="c-39437066">[2 more]</label></div><br/><div class="children"><div class="content">&gt; new methods of communication with the compiler have been established.<p>From what I understand, this appears to a be separate binary from GCC&#x2F;Clang that does static analysis and outputs C99.<p>Can this be a GCC plugin? I know we can write plugins that are activated when a specific macro is provided, and the GCC plugin event list allows intercepting the AST at every function declaration&#x2F;definition. Unless you&#x27;re rewriting the AST substantially, I feel this could be a compiler plugin. I&#x27;d like to know a bit more about what kinds of AST transformations&#x2F;checks are run as part of Cake.</div><br/><div id="39437359" class="c"><input type="checkbox" id="c-39437359" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437066">parent</a><span>|</span><a href="#39437325">next</a><span>|</span><label class="collapse" for="c-39437359">[-]</label><label class="expand" for="c-39437359">[1 more]</label></div><br/><div class="children"><div class="content">Cake is a C23 front end, but it can also be used as a static analysis tool.
The qualifiers can be empty macros then the same code can be compiled with gcc , clang and the static analysis of ownership can be using cake.<p>Inside visual studio for instance, we can have on external tools<p>C:\Program Files (x86)\cake\cake.exe
$(ItemPath) -msvc-output  -no-output -analyze -nullchecks<p>The main annotations are qualifiers (similar to const). C23 attributes were considered instead of qualifiers, but qualifiers have better integration with the type system. In any case, macros are used to be declared as empty when necessary.<p>The qualifiers and the rules can be applied to any compiler.
Something harder to specify (but not impossible) is the flow analysis.<p>Sample of rule for compilers.<p>int * owner a;
int * b;
a = b;<p>we cannot assign view to an owner object.
this kind of rule does not require flow analysis.</div><br/></div></div></div></div><div id="39437325" class="c"><input type="checkbox" id="c-39437325" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437066">prev</a><span>|</span><a href="#39438399">next</a><span>|</span><label class="collapse" for="c-39437325">[-]</label><label class="expand" for="c-39437325">[20 more]</label></div><br/><div class="children"><div class="content">I think that ownership for C is gross. It&#x27;s hard to convert code to something like this.<p>But you could get most of the benefit by just isoheaping (strictly allocate different types in different heaps).</div><br/><div id="39437428" class="c"><input type="checkbox" id="c-39437428" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39437325">parent</a><span>|</span><a href="#39437407">next</a><span>|</span><label class="collapse" for="c-39437428">[-]</label><label class="expand" for="c-39437428">[13 more]</label></div><br/><div class="children"><div class="content">This doesn’t help for a lot of things, including some of the examples described in the article. For example trying to segregate file descriptors (or similar resource handles) to an isolated heap would be mostly worthless because a UAF through a “stale reference” would let you mess with a completely different file. In general the problem of figuring out which objects are safe to confuse with each other is very difficult. There are a handful of “obvious” types (collections, ports, etc.) that it’s clear cannot be allocated together because they hold capabilities but doing this in general is not tractable.</div><br/><div id="39437504" class="c"><input type="checkbox" id="c-39437504" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437428">parent</a><span>|</span><a href="#39437407">next</a><span>|</span><label class="collapse" for="c-39437504">[-]</label><label class="expand" for="c-39437504">[12 more]</label></div><br/><div class="children"><div class="content">Sure ownership protects against more things. But some coding patterns are impossible under it.</div><br/><div id="39437545" class="c"><input type="checkbox" id="c-39437545" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437504">parent</a><span>|</span><a href="#39437660">next</a><span>|</span><label class="collapse" for="c-39437545">[-]</label><label class="expand" for="c-39437545">[9 more]</label></div><br/><div class="children"><div class="content">The analysis can be disabled or silenced in some functions.
the &quot;static state&quot; also can be override. (see the realloc sample)<p>Because this is C, the programmers can do wherever they want, but before it must do some negotiation with the static analysis.</div><br/><div id="39437628" class="c"><input type="checkbox" id="c-39437628" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437545">parent</a><span>|</span><a href="#39437660">next</a><span>|</span><label class="collapse" for="c-39437628">[-]</label><label class="expand" for="c-39437628">[8 more]</label></div><br/><div class="children"><div class="content">I’d rather just have memory safety.<p>If all you give me is half measures, then I’ll either just use plain old C&#x2F;C++ or I’ll switch to a totally different language. Maybe one with a GC so I don’t have to please some ownership thingy.</div><br/><div id="39438139" class="c"><input type="checkbox" id="c-39438139" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437628">parent</a><span>|</span><a href="#39437704">next</a><span>|</span><label class="collapse" for="c-39438139">[-]</label><label class="expand" for="c-39438139">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a common misconception that ownership is there to make you suffer compiler shenanigans. When in my experience it changes the way you model programs. Turns out, that structuring your program in a way were it&#x27;s clear who owns what makes for easier to understand and debug programs. It&#x27;s a bit analogous to static typing, saying I&#x27;ll use a language like Python without type hints, because its gonna make me avoid compiler errors, is a bit short sighted when I plan on developing the piece of code for a longer time.<p>Here is a blog post that explains this in more detail <a href="https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;notes-on-a-smaller-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;notes-on-a-smaller-rust&#x2F;</a>.</div><br/><div id="39439023" class="c"><input type="checkbox" id="c-39439023" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39438139">parent</a><span>|</span><a href="#39438616">next</a><span>|</span><label class="collapse" for="c-39439023">[-]</label><label class="expand" for="c-39439023">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think it&#x27;s a common misconception that ownership is there to make you suffer compiler shenanigans.<p>I don&#x27;t think it&#x27;s a misconception. When I tried Rust I tried to implement a cyclic data structure but couldn&#x27;t because there is no clear &quot;owner&quot; in a cyclic data structure. The &quot;safe&quot; solution recommended by the rustaceans was to use integer handles. So, instead of juggling pointers I was juggling integers which made the code harder to debug and find logic errors. At least when I was troubleshooting C I could rely on the debugger to break on a bad pointer, but finding where an integer became &quot;bad&quot; was more time consuming.<p>&gt; When in my experience it changes the way you model programs.<p>Having to rearchitect my code to please the borrow checker gave me flashbacks to Java where I&#x27;d be forced to architect my code as a hierarchy of objects. In both languages you need design patterns and other work-arounds since both force a specific model onto your code whether it makes sense or not.</div><br/></div></div><div id="39438616" class="c"><input type="checkbox" id="c-39438616" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39438139">parent</a><span>|</span><a href="#39439023">prev</a><span>|</span><a href="#39437704">next</a><span>|</span><label class="collapse" for="c-39438616">[-]</label><label class="expand" for="c-39438616">[2 more]</label></div><br/><div class="children"><div class="content">Having to change how you write your program is the worst case of suffering compiler shenanigans that I can think of.</div><br/><div id="39438830" class="c"><input type="checkbox" id="c-39438830" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39438616">parent</a><span>|</span><a href="#39437704">next</a><span>|</span><label class="collapse" for="c-39438830">[-]</label><label class="expand" for="c-39438830">[1 more]</label></div><br/><div class="children"><div class="content">If you want to keep doing programming in a way you are already familiar with, and are not willing to change your way of thinking about programs, yes then it&#x27;s a bad fit. If you want to write reliable programs, there is evidence that changing the way we think about and express programming problems, can have substantial effects on reliability.</div><br/></div></div></div></div></div></div><div id="39437704" class="c"><input type="checkbox" id="c-39437704" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437628">parent</a><span>|</span><a href="#39438139">prev</a><span>|</span><a href="#39437660">next</a><span>|</span><label class="collapse" for="c-39437704">[-]</label><label class="expand" for="c-39437704">[3 more]</label></div><br/><div class="children"><div class="content">Everything related to safety is on my list. (the list is big)
I think big problems can be broken down into smaller ones.</div><br/><div id="39437753" class="c"><input type="checkbox" id="c-39437753" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437704">parent</a><span>|</span><a href="#39437660">next</a><span>|</span><label class="collapse" for="c-39437753">[-]</label><label class="expand" for="c-39437753">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s very compelling to convert C code to a thing that gives you a safety half-measure. You&#x27;ll still have security bugs, so it&#x27;ll just feel like theatre.</div><br/><div id="39438588" class="c"><input type="checkbox" id="c-39438588" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437753">parent</a><span>|</span><a href="#39437660">next</a><span>|</span><label class="collapse" for="c-39438588">[-]</label><label class="expand" for="c-39438588">[1 more]</label></div><br/><div class="children"><div class="content">huh? There are also security bugs in Rust, so it is theatre as well?<p>Pointer ownership could eliminate a class of bugs. And such an approach can be combined with run-time checks for bounds and signed overflow, and then you have a memory-safe C more or less (some minor pieces are still missing, but nothing essential),</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39437660" class="c"><input type="checkbox" id="c-39437660" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437504">parent</a><span>|</span><a href="#39437545">prev</a><span>|</span><a href="#39437407">next</a><span>|</span><label class="collapse" for="c-39437660">[-]</label><label class="expand" for="c-39437660">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Sure ownership protects against more things. But some coding patterns are impossible under it.<p>In Rust you&#x27;re told that if it&#x27;s impossible under ownership then you should find a different way to express it rather than trying to circumvent ownership. I guess it&#x27;s different in C.</div><br/><div id="39437726" class="c"><input type="checkbox" id="c-39437726" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437660">parent</a><span>|</span><a href="#39437407">next</a><span>|</span><label class="collapse" for="c-39437726">[-]</label><label class="expand" for="c-39437726">[1 more]</label></div><br/><div class="children"><div class="content">It works in both ways. 
We can just tell the compiler to ignore some function.
We can be also creative writing the code that at same time is good and makes the static analysis happy.
A good sample is linked lists.<p><pre><code>    #include &lt;ownership.h&gt; 
    #include &lt;stdlib.h&gt;
    #include &lt;assert.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    struct node {
    char * owner text;
    struct node* owner next;
    };

    struct list {
    struct node * owner head;
    struct node * tail;
    };

    void list_append(struct list* list, struct node* owner node)
    {
    if (list-&gt;head == NULL) {
        list-&gt;head = node;
    }
    else {
        assert(list-&gt;tail-&gt;next == 0);
        list-&gt;tail-&gt;next = node; &#x2F;&#x2F;ZERO OVERHEAD
    }
    list-&gt;tail = node;
    }

    void list_destroy(struct list* obj_owner list)
    {
    struct node * owner p = list-&gt;head;
    while (p) {
        struct node *  owner next = p-&gt;next;
        free(p-&gt;text); 
        free(p);
        p = next;
    }
    }

    void list_print(const struct list* list)
    {
    const struct node * p = list-&gt;head;
    while (p) {
        printf(&quot;%s &quot;, p-&gt;text);
        p = p-&gt;next;
    }
    }

    int main()
    {
    struct list list = {};
    struct node  * owner p =  calloc(1, sizeof * p);
    
    if (p) {
        p-&gt;text = strdup(&quot;item1&quot;);
        list_append(&amp;list, p);
    }

    list_print(&amp;list);
    list_destroy(&amp;list);
    }</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="39437407" class="c"><input type="checkbox" id="c-39437407" checked=""/><div class="controls bullet"><span class="by">DriftRegion</span><span>|</span><a href="#39437325">parent</a><span>|</span><a href="#39437428">prev</a><span>|</span><a href="#39437457">next</a><span>|</span><label class="collapse" for="c-39437407">[-]</label><label class="expand" for="c-39437407">[3 more]</label></div><br/><div class="children"><div class="content">Say more about isoheaping and how it helps? Is this related to arena allocation? A quick search doesn&#x27;t find anything on this. Thanks.</div><br/><div id="39437500" class="c"><input type="checkbox" id="c-39437500" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437407">parent</a><span>|</span><a href="#39437457">next</a><span>|</span><label class="collapse" for="c-39437500">[-]</label><label class="expand" for="c-39437500">[2 more]</label></div><br/><div class="children"><div class="content">One heap per type.<p>Here’s an allocator optimized for that use case.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;WebKit&#x2F;WebKit&#x2F;blob&#x2F;main&#x2F;Source&#x2F;bmalloc&#x2F;libpas&#x2F;Documentation.md">https:&#x2F;&#x2F;github.com&#x2F;WebKit&#x2F;WebKit&#x2F;blob&#x2F;main&#x2F;Source&#x2F;bmalloc&#x2F;li...</a></div><br/><div id="39437631" class="c"><input type="checkbox" id="c-39437631" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437500">parent</a><span>|</span><a href="#39437457">next</a><span>|</span><label class="collapse" for="c-39437631">[-]</label><label class="expand" for="c-39437631">[1 more]</label></div><br/><div class="children"><div class="content">The ownership works for non pointers. We can have integers (handles) that are owners. This allow custom allocators for instance.
The concept of owner is some value that works as reference to an object and manages its lifetime.</div><br/></div></div></div></div></div></div><div id="39437457" class="c"><input type="checkbox" id="c-39437457" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437325">parent</a><span>|</span><a href="#39437407">prev</a><span>|</span><a href="#39437510">next</a><span>|</span><label class="collapse" for="c-39437457">[-]</label><label class="expand" for="c-39437457">[1 more]</label></div><br/><div class="children"><div class="content">Converting code can be challenging. The cake code has been successfully converted. null-checks are not ready, and something similar already happened to c#.<p>The experience is similar to changing a header file to use a const argument where previously the argument was non-const. This change will propagate everywhere.<p>I also think a similar experience is converting JavaScript to typescript.
The type system will complain before it stabilizes.</div><br/></div></div><div id="39437510" class="c"><input type="checkbox" id="c-39437510" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39437325">parent</a><span>|</span><a href="#39437457">prev</a><span>|</span><a href="#39438399">next</a><span>|</span><label class="collapse" for="c-39437510">[-]</label><label class="expand" for="c-39437510">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But you could get most of the benefit by just isoheaping (strictly allocate different types in different heaps).<p>Can you elaborate on this? I&#x27;ve been reading up on memory allocation algorithms and most of them seem to favor segregation of blocks by element size instead. Are there additional benefits to coming up with a complex typing scheme for a custom memory allocation interface?</div><br/><div id="39437633" class="c"><input type="checkbox" id="c-39437633" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39437325">root</a><span>|</span><a href="#39437510">parent</a><span>|</span><a href="#39438399">next</a><span>|</span><label class="collapse" for="c-39437633">[-]</label><label class="expand" for="c-39437633">[1 more]</label></div><br/><div class="children"><div class="content">No benefits other than safety.</div><br/></div></div></div></div></div></div><div id="39438399" class="c"><input type="checkbox" id="c-39438399" checked=""/><div class="controls bullet"><span class="by">irogers</span><span>|</span><a href="#39437325">prev</a><span>|</span><a href="#39437951">next</a><span>|</span><label class="collapse" for="c-39438399">[-]</label><label class="expand" for="c-39438399">[1 more]</label></div><br/><div class="children"><div class="content">Agreed this is awesome, obviously sanitizers fill some of this gap currently but they aren&#x27;t great with things like reference counting that RAII makes a doddle. Fwiw, here is an implementation of a runtime RAII style checking on top of leak sanitizer:
<a href="https:&#x2F;&#x2F;perf.wiki.kernel.org&#x2F;index.php&#x2F;Reference_Count_Checking" rel="nofollow">https:&#x2F;&#x2F;perf.wiki.kernel.org&#x2F;index.php&#x2F;Reference_Count_Check...</a>
There&#x27;s an interesting overlap with the cleanup attribute that is now appearing in the Linux kernel (by way of systemd):
<a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;include&#x2F;linux&#x2F;cleanup.h" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/></div></div><div id="39437951" class="c"><input type="checkbox" id="c-39437951" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39438399">prev</a><span>|</span><a href="#39437729">next</a><span>|</span><label class="collapse" for="c-39437951">[-]</label><label class="expand" for="c-39437951">[3 more]</label></div><br/><div class="children"><div class="content">This is awesome. Could they reconcile this with [[gsl::Owner]] or gsl::owner&lt;T&gt; somehow so we don&#x27;t end up with multiple syntaxes in C++?<p><a href="https:&#x2F;&#x2F;reviews.llvm.org&#x2F;D64448" rel="nofollow">https:&#x2F;&#x2F;reviews.llvm.org&#x2F;D64448</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;GSL&#x2F;blob&#x2F;main&#x2F;docs&#x2F;headers.md#gslowner">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;GSL&#x2F;blob&#x2F;main&#x2F;docs&#x2F;headers.md#g...</a></div><br/><div id="39437994" class="c"><input type="checkbox" id="c-39437994" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437951">parent</a><span>|</span><a href="#39437729">next</a><span>|</span><label class="collapse" for="c-39437994">[-]</label><label class="expand" for="c-39437994">[2 more]</label></div><br/><div class="children"><div class="content">I think gsl::Owner is related with RAII.<p>The difference with cake ownership and RAII , is that with C++ RAII, the destructor is unconditionally called at end of scope.
Then flow analysis is not required in RAII.<p>Cake requires flow analysis because &quot;destructor&quot; is not unconditionally called.<p>When the compiler can see that the owner is not owning a object (because the pointer is null for instance) then the &quot;destructor&quot; is not necessary.<p>To understand the difference.<p>With flow analysis (how it works today)<p><pre><code>    int main() 
    {
      FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;); 
      if (f)
        fclose(f);
    }

</code></pre>
Without flow analysis (or with a very simple one, where the destroy must be the last statement)<p><pre><code>    void fclose2(FILE * owner p) {
       if (p) fclose(p);
    }

    int main() 
    {
      FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;); 
      if (f){
      }
      fclose2(f);
    }</code></pre></div><br/><div id="39438014" class="c"><input type="checkbox" id="c-39438014" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437951">root</a><span>|</span><a href="#39437994">parent</a><span>|</span><a href="#39437729">next</a><span>|</span><label class="collapse" for="c-39438014">[-]</label><label class="expand" for="c-39438014">[1 more]</label></div><br/><div class="children"><div class="content">the other difference in RAII destructor cannot be turned off.
In cake the same object can be a &quot;view&quot;<p><pre><code>    struct X x = {0};
    &#x2F;&#x2F;...
    view struct X x2 = x;
    destroy(&amp;x);
    &#x2F;&#x2F;x2 does not need destructor</code></pre></div><br/></div></div></div></div></div></div><div id="39437729" class="c"><input type="checkbox" id="c-39437729" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39437951">prev</a><span>|</span><a href="#39438747">next</a><span>|</span><label class="collapse" for="c-39437729">[-]</label><label class="expand" for="c-39437729">[13 more]</label></div><br/><div class="children"><div class="content">C safety addons like this (there have been many) is that they don&#x27;t prevent extracting raw pointers from controlled pointers. Optional memory safety isn&#x27;t.<p>&gt; If this can be reasonably retrofitted to existing libraries and projects<p>That&#x27;s the problem.<p>If you want to fool around in this space, consider revisiting C++ to Rust conversion.
There&#x27;s something called Corrode, which compiles C to a weird subset of Rust full of objects that implement C raw pointers. The output is verbose and unmaintainable.
What&#x27;s needed is something that can figure out how big things are and who owns what, possibly guessing, and generate appropriate ideomatic Rust. Now that LLMs are sort of working, that might be possible.<p>Can you ask Github Co-pilot to look at C code and answer the question &quot;What is the length of the array &#x27;buf&#x27; passed to this function&quot;? That tells you how to express the array in a language where arrays have enforced lengths, whicn includes both C++ and Rust. With hints like that, ideomatic translation becomes possible. Bad guesses will result in programs that subscript out of range, which is caught at run time. But guesses should be correct most of the time, because C programmers tend to use the same idioms for arrays with lengths. Forms such as &quot;int read(int fd, char* buf, size_t buf_l)&quot; show up often.<p>Using LLMs to help with tightening up existing code might work.</div><br/><div id="39438150" class="c"><input type="checkbox" id="c-39438150" checked=""/><div class="controls bullet"><span class="by">quatrefoil</span><span>|</span><a href="#39437729">parent</a><span>|</span><a href="#39438107">next</a><span>|</span><label class="collapse" for="c-39438150">[-]</label><label class="expand" for="c-39438150">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Optional memory safety isn&#x27;t.<p>Optional memory safety is, when you can opt an entire project into a &quot;strict&quot; mode, and this becomes trivially verifiable by others. I imagine that&#x27;s the goal here.<p>Optional security is a problem only when you need to remember a million different rules and gotchas, because you will inevitably miss a spot. But if it&#x27;s a global toggle, it&#x27;s pretty good. &quot;Use &#x27;-fmemsafe&#x27; for C&#x2F;C++&quot; is as tractable as &quot;don&#x27;t use &#x27;unsafe&#x27; in Rust&quot;.<p>Yeah, as you note, library compatibility is an issue. But it&#x27;s an even bigger issue when bootstrapping a new, safe language: you gotta implement the libraries from scratch, and you never really get to full parity with C&#x2F;C++. Getting it done for the top 10 most-used libraries would make a spectacular difference in itself.<p>I should note that I&#x27;m not a huge believer in &quot;saving&quot; C&#x2F;C++ as the memory-safe language of the future - I think there are lingering cultural problems around the standards that we had no luck overcoming for decades - but I also don&#x27;t think the duo is going away any time soon, so might as well expend some effort on making it a safer tool.</div><br/></div></div><div id="39438107" class="c"><input type="checkbox" id="c-39438107" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437729">parent</a><span>|</span><a href="#39438150">prev</a><span>|</span><a href="#39438434">next</a><span>|</span><label class="collapse" for="c-39438107">[-]</label><label class="expand" for="c-39438107">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Can you ask Github Co-pilot to look at C code and answer the question &quot;What is &gt;the length of the array &#x27;buf&#x27; passed to this function&quot;? That tells you how to &gt;express the array in a language where arrays have enforced lengths, whicn &gt;includes both C++ and Rust<p>this is the way you tell C what is the size of array.<p><pre><code>    void f(int n, int a[n]) {
    }</code></pre></div><br/><div id="39438718" class="c"><input type="checkbox" id="c-39438718" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39438107">parent</a><span>|</span><a href="#39438597">next</a><span>|</span><label class="collapse" for="c-39438718">[-]</label><label class="expand" for="c-39438718">[1 more]</label></div><br/><div class="children"><div class="content">You can write that in C, but it doesn&#x27;t really do anything. It&#x27;s equivalent to<p><pre><code>    void f(int n, int a[]) {
    }
</code></pre>
Why? So that you can write<p><pre><code>    void f(int n, int m, int a[n][m]) {
    }
</code></pre>
which declares a 2-dimensional array parameter. In that case, the &quot;m&quot; is used to compute the position in the array for a 2D array. The &quot;m&quot; doesn&#x27;t do anything.
This is equivalent to writing<p><pre><code>   void f(int n, int m, int a[][m]) {
   }
</code></pre>
This is C&#x27;s minimal multidimensional array support, known by few and used by fewer.<p>Over a decade ago, I proposed that sizes in parameters should be checkable and readable I worked out how to make it work.[1] But I didn&#x27;t have time for the politics of C standards.<p>[1] <a href="http:&#x2F;&#x2F;animats.com&#x2F;papers&#x2F;languages&#x2F;safearraysforc43.pdf" rel="nofollow">http:&#x2F;&#x2F;animats.com&#x2F;papers&#x2F;languages&#x2F;safearraysforc43.pdf</a></div><br/></div></div><div id="39438597" class="c"><input type="checkbox" id="c-39438597" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39438107">parent</a><span>|</span><a href="#39438718">prev</a><span>|</span><a href="#39438434">next</a><span>|</span><label class="collapse" for="c-39438597">[-]</label><label class="expand" for="c-39438597">[2 more]</label></div><br/><div class="children"><div class="content">Do you have source on this syntax? Does the `[n]` actually do anything here? Fooling around in godbolt, `void f(int n, int a[n]) {` is the same as `void f(int n, int a[]) {` and doesn&#x27;t appear to change assembly or generate any warnings&#x2F;errors with improper usage.</div><br/><div id="39438843" class="c"><input type="checkbox" id="c-39438843" checked=""/><div class="controls bullet"><span class="by">unnah</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39438597">parent</a><span>|</span><a href="#39438434">next</a><span>|</span><label class="collapse" for="c-39438843">[-]</label><label class="expand" for="c-39438843">[1 more]</label></div><br/><div class="children"><div class="content">It looks like standard C99 variable-length array (VLA) syntax: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;array#Variable-length_arrays" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;array#Variable-leng...</a><p>The major difference is when the array is multi-dimensional. If you don&#x27;t have VLAs then you can only set the inner dimensions at compile time, or alternatively use pointer-based work-arounds.<p>Even in the case of one-dimensional arrays, a compiler or a static analyzer can take advantage of the VLA size information to insert run-time checks in debug mode, or to perform compile-time checks.</div><br/></div></div></div></div></div></div><div id="39438434" class="c"><input type="checkbox" id="c-39438434" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39437729">parent</a><span>|</span><a href="#39438107">prev</a><span>|</span><a href="#39437876">next</a><span>|</span><label class="collapse" for="c-39438434">[-]</label><label class="expand" for="c-39438434">[1 more]</label></div><br/><div class="children"><div class="content">These are tools. How well they work largely depends on the discipline and processes followed by the development team using them. If the concern is that raw pointers can be extracted from controlled pointers, then the development team needs to check for this. No tool is perfect, but tools like these can be used effectively to reduce attack surfaces and improve safety.<p>Even languages like Rust make memory safety optional. One can drop into an unsafe block and perform all sorts of abominable things. Such escape hatches are necessary to color outside of the lines when one must do system software development or optimize software beyond what the compiler can do on its own. At some point, the developer must be trusted to learn the tool or to use discretion when considering something like unsafe. In both cases, a development team can peer review these choices.<p>What makes me interested in tools like Cake and similar tools is that these bring us closer to being able to use proof assistants to build up reasoning about the times when we must color outside of the lines. Whether C, C++, or Rust, being able to import code into a proof assistant or extract efficient code from a proof assistant can further assist us when our use cases exceed what is possible with the safety features in our language or tooling.</div><br/></div></div><div id="39437876" class="c"><input type="checkbox" id="c-39437876" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437729">parent</a><span>|</span><a href="#39438434">prev</a><span>|</span><a href="#39438447">next</a><span>|</span><label class="collapse" for="c-39437876">[-]</label><label class="expand" for="c-39437876">[5 more]</label></div><br/><div class="children"><div class="content">the cake implementation cannot be mapped to rust. I am not rust specialist but one concept for instance is that a owner pointer owns two resources at same time, the memory and object. In rust it is one concept.<p>Owner pointers take on the responsibility of owning the pointed object and its associated memory, treating them as distinct entities. A common practice is to implement a delete function to release both resources, as illustrated in Listing 7:<p>Listing 7 - Implementing the delete function<p><pre><code>    #include &lt;ownership.h&gt;

    #include &lt;stdlib.h&gt;


    struct X { 
      char *owner text; 
   };

    void x_delete(struct X *owner p) {
      if (p) {
        &#x2F;*releasing the object*&#x2F; 
        free(p-&gt;text);
    
       &#x2F;*releasing the memory*&#x2F; 
       free(p); 
     }
   }

   int main() {
      struct X \* owner pX = calloc( 1, sizeof \* pX);
      if (pX) {
       &#x2F;*...*&#x2F;;
       x_delete( pX); 
      }  
   }</code></pre></div><br/><div id="39438041" class="c"><input type="checkbox" id="c-39438041" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39437876">parent</a><span>|</span><a href="#39438447">next</a><span>|</span><label class="collapse" for="c-39438041">[-]</label><label class="expand" for="c-39438041">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why that couldn&#x27;t be represented like this in Rust:<p><pre><code>    struct X {
        text: Option&lt;Box&lt;str&gt;&gt;,
    }
    fn main() {
        let pX = Box::new(X { text: None });
        &#x2F;&#x2F; automatically dropped (freed) at end of scope
    }</code></pre></div><br/><div id="39438079" class="c"><input type="checkbox" id="c-39438079" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39438041">parent</a><span>|</span><a href="#39438447">next</a><span>|</span><label class="collapse" for="c-39438079">[-]</label><label class="expand" for="c-39438079">[3 more]</label></div><br/><div class="children"><div class="content">In cake object and memory are two resources. We can for instance, delete the object and reuse the same memory.<p>For instance, this code is correct.<p><pre><code>    #include &lt;ownership.h&gt; 
    #include &lt;stdlib.h&gt;

    struct X {
       char * owner text;
    };

    void x_delete(struct X * owner p)
    {
        if (p)
        {
           free(p-&gt;text);
           free(p);    
        }
    }

    int main() {   
       struct X * owner p = malloc(sizeof(struct X));
        
       p-&gt;text = malloc(10);

       free(p-&gt;text); &#x2F;&#x2F;object text destroyed

       struct X x2 = {0};

       *p = x2; &#x2F;&#x2F;x2 MOVED TO *p

       x_delete(p);   

       &#x2F;&#x2F;no need to destroy x2
    }</code></pre></div><br/><div id="39438271" class="c"><input type="checkbox" id="c-39438271" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39438079">parent</a><span>|</span><a href="#39438447">next</a><span>|</span><label class="collapse" for="c-39438271">[-]</label><label class="expand" for="c-39438271">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    let p: Box&lt;X&gt; = Box::new(X { ... });

    let x2 = X { ... };

    &#x2F;&#x2F; Moves x2 into the same memory as the first X.
    &#x2F;&#x2F; The first X is automatically dropped as part of this assignment.
    &#x2F;&#x2F; Also consumes x2 so x2 is not available any more.
    *p = x2;

    &#x2F;&#x2F; Drops the X that was originally assigned to x2 and then moved into p.
    drop(p);

    &#x2F;&#x2F; No need, nor is it possible, to destroy x2.</code></pre></div><br/><div id="39438927" class="c"><input type="checkbox" id="c-39438927" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39437729">root</a><span>|</span><a href="#39438271">parent</a><span>|</span><a href="#39438447">next</a><span>|</span><label class="collapse" for="c-39438927">[-]</label><label class="expand" for="c-39438927">[1 more]</label></div><br/><div class="children"><div class="content">And as bonus there is no temporal hole where you could access a null or dangling text.<p>Here it is as a runnable snippet: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;fc4Gfxrfd" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;fc4Gfxrfd</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39438447" class="c"><input type="checkbox" id="c-39438447" checked=""/><div class="controls bullet"><span class="by">naitgacem</span><span>|</span><a href="#39437729">parent</a><span>|</span><a href="#39437876">prev</a><span>|</span><a href="#39438747">next</a><span>|</span><label class="collapse" for="c-39438447">[-]</label><label class="expand" for="c-39438447">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Bad guesses will result in programs that subscript out of range, which is caught at run time.
</code></pre>
That is sadly not always the case.</div><br/></div></div></div></div><div id="39438747" class="c"><input type="checkbox" id="c-39438747" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#39437729">prev</a><span>|</span><a href="#39437560">next</a><span>|</span><label class="collapse" for="c-39438747">[-]</label><label class="expand" for="c-39438747">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been dabbling in embedded programming. Everything is written in C. I just don&#x27;t understand why. C++ solves pretty much all problems if you want it too (RAII, smart pointers, move semantics) and the frameworks writers wouldn&#x27;t need to implement their bespoke OOP system on top of opaque pointers and callbacks.<p>Maybe it was bad luck on my part, and other embedded frameworks are better; but I got into both ESP32 and STM32, both frameworks are the worst spaghetti code I have ever seen. You need to jump through at least one, often two layers of indirection to understand what a particular function call will do. Here&#x27;s an example of what I mean:<p><pre><code>    &#x2F;&#x2F; peripheral_conf.h
    #define USE_FOOBAR_PERIPHERAL 1
    &#x2F;&#x2F; obj_t.h
    #define USE_OBJ_PARAM2

    &#x2F;&#x2F; In the library header
    #ifdef USE_FOOBAR_PERIPHERAL
    #define DoSomethingCallback FoobarCallback
    #endif

   &#x2F;&#x2F; foobar.h
   status_t FoobarCallback(int32_t data, int32_t param);

    &#x2F;&#x2F; obj_t.c
    status_t Init(Obj_t* obj) {
        obj-&gt;param1 = obj-&gt;init.initparam &amp; 0xFF;
        #ifdef USE_OBJ_PARAM2
        obj-&gt;param2 = (obj-&gt;init.initparam &gt;&gt; 16) &amp; 0xFF;
        #endif
        obj-&gt;callback = DoSomethingCallback;
        return OK;
    }
    
    status_t DoSomething(Obj_t *obj, int32_t data) {
        #ifdef USE_OBJ_PARAM2
        return obj-&gt;callback(data, obj-&gt;param2);
        #else
        return obj-&gt;callback(data, obj-&gt;param1);
        #endif
    }

    &#x2F;&#x2F; main.c
    Obj obj = {0};
    obj.init.initparam = 0x12345678;
    Init(obj);
    DoSomething(obj, 0x42);
</code></pre>
And that&#x27;s an <i>easy</i> example. Macros everywhere, you need to grok what&#x27;s happening in four different files to understand what the hell a single function call will <i>actually</i> do. Sure, the code is super efficient, because once it&#x27;s compiled all the extraneous information is pre-processed away if you don&#x27;t use such and such peripheral or configuration option. But all this could be replaced by an abstract class, perhaps some templates... And if you disable stuff you may not need (RTTI, exceptions) then you&#x27;d get just as efficient compiled code. It would be much easier to understand what going on, and <i>you wouldn&#x27;t be able call DoSomething on uninitialized data</i>... Because you&#x27;d have to call the constructor first to even have access to the method.<p>Anyway, thank god for debuggers, step-by-step execution, and IDEs.</div><br/><div id="39438802" class="c"><input type="checkbox" id="c-39438802" checked=""/><div class="controls bullet"><span class="by">outsomnia</span><span>|</span><a href="#39438747">parent</a><span>|</span><a href="#39437560">next</a><span>|</span><label class="collapse" for="c-39438802">[-]</label><label class="expand" for="c-39438802">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But all this could be replaced by an abstract class, perhaps some templates... And if you disable stuff you may not need (RTTI, exceptions) then you&#x27;d get just as efficient compiled code.<p>Isn&#x27;t it just that your personal in-head GPT has been trained on C++ and wants to see it everywhere?  It&#x27;s not so easy to make very small embedded implementations and there&#x27;s a reason after 25+ years C++ has not made inroads there.</div><br/><div id="39438880" class="c"><input type="checkbox" id="c-39438880" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#39438747">root</a><span>|</span><a href="#39438802">parent</a><span>|</span><a href="#39437560">next</a><span>|</span><label class="collapse" for="c-39438880">[-]</label><label class="expand" for="c-39438880">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d appreciate if you made your point in a less condescending and dismissing manner. Anyway.<p>No, C++ is not even my programming language of predilection. Not sure why you would make assumptions about my background while knowing nothing about me. But I can recognize OOP patterns when I see them. There&#x27;s even a book about that <a href="https:&#x2F;&#x2F;www.cs.rit.edu&#x2F;~ats&#x2F;books&#x2F;ooc.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.rit.edu&#x2F;~ats&#x2F;books&#x2F;ooc.pdf</a> C-styled OOP is not a new concept. C++ just does it better.<p>The reason C++ has &quot;not made inroads&quot; may just be inertia, you know. And look at Arduino - if C++ code can run on an 8bit ATmega MCU, it can run anywhere. The whole language is designed around &quot;pay for what you use and nothing else&quot;.</div><br/></div></div></div></div></div></div><div id="39437560" class="c"><input type="checkbox" id="c-39437560" checked=""/><div class="controls bullet"><span class="by">taminka</span><span>|</span><a href="#39438747">prev</a><span>|</span><a href="#39436834">next</a><span>|</span><label class="collapse" for="c-39437560">[-]</label><label class="expand" for="c-39437560">[2 more]</label></div><br/><div class="children"><div class="content">lowkey smart pointers are often just used to deflect the responsibility of thinking about memory layouts<p><a href="https:&#x2F;&#x2F;floooh.github.io&#x2F;2018&#x2F;06&#x2F;17&#x2F;handles-vs-pointers.html" rel="nofollow">https:&#x2F;&#x2F;floooh.github.io&#x2F;2018&#x2F;06&#x2F;17&#x2F;handles-vs-pointers.html</a><p>and most issues can be caught by using a static analyser of a memory leak checker (getting ppl to consistently use them is another issue, but still)</div><br/><div id="39437603" class="c"><input type="checkbox" id="c-39437603" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39437560">parent</a><span>|</span><a href="#39436834">next</a><span>|</span><label class="collapse" for="c-39437603">[-]</label><label class="expand" for="c-39437603">[1 more]</label></div><br/><div class="children"><div class="content">Static analysis has a significant advantage over runtime checks for memory leaks, especially in code that is almost never executed, because bugs can remain hidden until they appear in production. The code where I found the bug last year was executed occasionally, and to create a unit test, it was necessary to integrate with another server. So it wasn&#x27;t easy to check at runtime.<p>On the other hand static analysis will catch the error at first compilation even on those almost never executed code.</div><br/></div></div></div></div><div id="39436834" class="c"><input type="checkbox" id="c-39436834" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#39437560">prev</a><span>|</span><a href="#39438075">next</a><span>|</span><label class="collapse" for="c-39436834">[-]</label><label class="expand" for="c-39436834">[2 more]</label></div><br/><div class="children"><div class="content">Do I need to use the Cake frontend to use the ownership library or is it actually macros (or an extension?) I could use in code compiled with gcc or clang?</div><br/><div id="39437412" class="c"><input type="checkbox" id="c-39437412" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39436834">parent</a><span>|</span><a href="#39438075">next</a><span>|</span><label class="collapse" for="c-39437412">[-]</label><label class="expand" for="c-39437412">[1 more]</label></div><br/><div class="children"><div class="content">The answer you can have the same source code and compile with gcc, but only cake is implementing the checks at this moment.
The have the same source code compiling in any compiler a header ownership.h is used to define owner etc as empty macro.
This strategy is used on cake source itself, that is checked with cake, but compiled with gcc msvc and clang.</div><br/></div></div></div></div><div id="39438075" class="c"><input type="checkbox" id="c-39438075" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#39436834">prev</a><span>|</span><a href="#39438414">next</a><span>|</span><label class="collapse" for="c-39438075">[-]</label><label class="expand" for="c-39438075">[9 more]</label></div><br/><div class="children"><div class="content">This is overly complicated, there is no need to bring Rust semantics to C to ensure memory safety.<p>A good mempool implementation is all you need (i.e keeps track of every request, and zeros out the memory on release)</div><br/><div id="39438086" class="c"><input type="checkbox" id="c-39438086" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#39438075">parent</a><span>|</span><a href="#39438095">next</a><span>|</span><label class="collapse" for="c-39438086">[-]</label><label class="expand" for="c-39438086">[4 more]</label></div><br/><div class="children"><div class="content">Compiler optimizations and other forms of UB like integer overflow would like a word with you. If it were that simple, someone would have had success at scale by now <a href="https:&#x2F;&#x2F;alexgaynor.net&#x2F;2020&#x2F;may&#x2F;27&#x2F;science-on-memory-unsafety-and-security&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alexgaynor.net&#x2F;2020&#x2F;may&#x2F;27&#x2F;science-on-memory-unsafet...</a>.</div><br/><div id="39438337" class="c"><input type="checkbox" id="c-39438337" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#39438075">root</a><span>|</span><a href="#39438086">parent</a><span>|</span><a href="#39438095">next</a><span>|</span><label class="collapse" for="c-39438337">[-]</label><label class="expand" for="c-39438337">[3 more]</label></div><br/><div class="children"><div class="content">&gt;If it were that simple, someone would have had success at scale by now<p>A lot of code in that article doesn&#x27;t use mempools, and furthermore, just because a double free exists doesn&#x27;t mean that its always exploitable. And if its exploitable, it doesn&#x27;t mean that you can gain a shell or even exfil data, sometimes it means you can just crash the program.<p>Fundamentally, if you write a wrapper around memory management that keeps track of allocated resources, much in the same way how rust includes some runtime code during compilation for memory safety, you gain the same functionality.</div><br/><div id="39438851" class="c"><input type="checkbox" id="c-39438851" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#39438075">root</a><span>|</span><a href="#39438337">parent</a><span>|</span><a href="#39438710">next</a><span>|</span><label class="collapse" for="c-39438851">[-]</label><label class="expand" for="c-39438851">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fundamentally, if you write a wrapper around memory management that keeps track of allocated resources, much in the same way how rust includes some runtime code during compilation for memory safety, you gain the same functionality.<p>Can you substantiate that? There are commonly employed tracking allocators, such as ASAN that can catch certain kinds of UB, and UBSAN other, and with special interpreters you can catch even more. But even basic ASAN is more exhaustive than what you are suggesting, and it provably can&#x27;t provide the same guarantees that safe and sound Rust gives you <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;48902567" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;48902567</a>:<p>&gt; And that is not accounting for the fact that sanitizers are incompatible with each others. That is, even if you were willing to accept the combined slow-down (15x-45x?) and memory overhead (15x-30x?), you would still NOT manage for a C++ program to be as safe as a Rust one.<p>Also, I think you misunderstand the way Rust works, it does compile-time ownership checking, which allows it to avoid run-time checking, so this part &quot;same way how rust includes some runtime code during compilation for memory safety&quot; is factually wrong.</div><br/></div></div><div id="39438710" class="c"><input type="checkbox" id="c-39438710" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39438075">root</a><span>|</span><a href="#39438337">parent</a><span>|</span><a href="#39438851">prev</a><span>|</span><a href="#39438095">next</a><span>|</span><label class="collapse" for="c-39438710">[-]</label><label class="expand" for="c-39438710">[1 more]</label></div><br/><div class="children"><div class="content">malloc() already keeps track of every memory allocation. Just what kind of tracking are we talking about here?</div><br/></div></div></div></div></div></div><div id="39438095" class="c"><input type="checkbox" id="c-39438095" checked=""/><div class="controls bullet"><span class="by">thradams</span><span>|</span><a href="#39438075">parent</a><span>|</span><a href="#39438086">prev</a><span>|</span><a href="#39438414">next</a><span>|</span><label class="collapse" for="c-39438095">[-]</label><label class="expand" for="c-39438095">[4 more]</label></div><br/><div class="children"><div class="content">mempool does not solve double free, use after free (at least at compile time) or fopen sample.
But mempool and ownership can be complementary.</div><br/><div id="39438426" class="c"><input type="checkbox" id="c-39438426" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#39438075">root</a><span>|</span><a href="#39438095">parent</a><span>|</span><a href="#39438414">next</a><span>|</span><label class="collapse" for="c-39438426">[-]</label><label class="expand" for="c-39438426">[3 more]</label></div><br/><div class="children"><div class="content">If you are talking about a very naive version of mempool, then you are correct, but thats why I said a good implementation.<p>The whole point of a good mempool is that you malloc once, and only call free when you exit the program.  The data structures for memory allocation will never get corrupted. And the memory pool will never release chunk twice cause it keeps tracks of allocated chunks.<p>User after free is mitigated in the same way. When you allocate, you get a struct back that contains a pointer to the data. When you release, that pointer is zeroed out.</div><br/><div id="39438576" class="c"><input type="checkbox" id="c-39438576" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39438075">root</a><span>|</span><a href="#39438426">parent</a><span>|</span><a href="#39438719">next</a><span>|</span><label class="collapse" for="c-39438576">[-]</label><label class="expand" for="c-39438576">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you are talking about a very naive version of mempool, then you are correct, but thats why I said a good implementation.<p>No true Scotsman.<p>&gt; The whole point of a good mempool is that you malloc once, and only call free when you exit the program. The data structures for memory allocation will never get corrupted. And the memory pool will never release chunk twice cause it keeps tracks of allocated chunks.<p>Then you&#x27;ve just moved the same problem one layer up - &quot;use after returned to mempool&quot; takes the place of &quot;use after free&quot; and causes the same kind of problems.<p>&gt; When you allocate, you get a struct back that contains a pointer to the data. When you release, that pointer is zeroed out.<p>And the program - or, more likely, library code that it called - still has a copy of that pointer that it made when it was valid?</div><br/></div></div><div id="39438719" class="c"><input type="checkbox" id="c-39438719" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39438075">root</a><span>|</span><a href="#39438426">parent</a><span>|</span><a href="#39438576">prev</a><span>|</span><a href="#39438414">next</a><span>|</span><label class="collapse" for="c-39438719">[-]</label><label class="expand" for="c-39438719">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The whole point of a good mempool is that you malloc once, and only call free when you exit the program<p>So you&#x27;re describing fork() and _exit(). That&#x27;s my favorite memory manager. For example, chibicc never calls free() and instead just forks a process for each item of work in the compile pipeline. It makes the codebase infinitely simpler. Rui literally solved memory leaks! No idea what you&#x27;re talking about.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>