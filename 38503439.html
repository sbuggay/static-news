<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701594056206" as="style"/><link rel="stylesheet" href="styles.css?v=1701594056206"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.infoq.com/presentations/high-performance-asynchronous3/">Performance: Adventures in Thread-per-Core Async with Redpanda and Seastar</a> <span class="domain">(<a href="https://www.infoq.com">www.infoq.com</a>)</span></div><div class="subtext"><span>rbanffy</span> | <span>5 comments</span></div><br/><div><div id="38504811" class="c"><input type="checkbox" id="c-38504811" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38505399">next</a><span>|</span><label class="collapse" for="c-38504811">[-]</label><label class="expand" for="c-38504811">[2 more]</label></div><br/><div class="children"><div class="content">If you have never designed a thread-per-core architecture and want some gritty inside color on what designing these systems is like, this is the article for you. I’ve designed thread-per-core architectures for 15 years now and this captures the zeitgeist perfectly. As for why you might want to care about “thread-per-core architectures”, the performance metrics are qualitatively better than any other software architecture you can use, it isn’t even close. These architectures were first developed in the supercomputing&#x2F;HPC world but the principles apply to most software.<p>An issue is that there are few libraries that are designed or optimized for thread-per-core architectures. Storage management is a reusable concept in these architectures but there is a lack of competent and scalable libraries that do this optimally. For someone coming into the space, you have to learn how to design e.g. high-performance storage allocators that can keep up with a JBOD of NVMe. I have mature libraries like this but they are tightly coupled to the rest of the software I design.<p>When I first designed these architectures I sharded up resources across cores but there are many cases where this requires giving up a lot of performance. The problem of shedding load and resources across cores is really interesting. An implication is that some structures should be shared globally but you really want the performance to be as close to contention-free as possible or you defeat the purpose of thread-per-core.  This is possible and there are design heuristics that approximate it but it isn’t discussed much.<p>As mentioned in the article, no matter how you build these things your software will require a sophisticated understanding of lifetimes. Sometimes the builtin tools of the language will help with this, other times they can’t and you will have to build your own tools.<p>I have never used Seastar. Not because I am not familiar with it but because it makes tradeoffs that are not appropriate for the workloads I tend to support. It is a good choice for many workloads. The only thing this indicates is that we are still in the early days of these types of architectures. Even if you don’t care or need to improve your architectural efficiency, these types of architectures significantly reduce the carbon&#x2F;cost footprint of software systems.</div><br/><div id="38505666" class="c"><input type="checkbox" id="c-38505666" checked=""/><div class="controls bullet"><span class="by">kosolam</span><span>|</span><a href="#38504811">parent</a><span>|</span><a href="#38505399">next</a><span>|</span><label class="collapse" for="c-38505666">[-]</label><label class="expand" for="c-38505666">[1 more]</label></div><br/><div class="children"><div class="content">Hello! Please tell me what kind of stuff you are doing that requires this and what are the different tradeoffs that seastar makes? I used seastar to build a software switch for SDNs some years ago…</div><br/></div></div></div></div><div id="38505399" class="c"><input type="checkbox" id="c-38505399" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#38504811">prev</a><span>|</span><label class="collapse" for="c-38505399">[-]</label><label class="expand" for="c-38505399">[2 more]</label></div><br/><div class="children"><div class="content">Not once did I see the author mention “actors”, an entire generation of skilled engineers tries to reinvent them (with conflicting naming) poorly, this is a failing of our industry’s academia and trade press.<p>Actors are asynchronous objects with a message queue, designed to run on a thread pool. You can pin them to a core, or allow migration via work stealing (to spread the workload). Did you know that in modern many core systems, a hot CPU core will halt to cool down? Work stealing will offload non-pinned actors, balancing the load.<p>There is one stumbling issue with Actors which is “sync” work, a transaction which requires one actor to update anothers state before continuing. This can be resolved by “locking” an actor, but this mechanism is consceptually “dirty”, but solves real world problems.</div><br/><div id="38505526" class="c"><input type="checkbox" id="c-38505526" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38505399">parent</a><span>|</span><label class="collapse" for="c-38505526">[-]</label><label class="expand" for="c-38505526">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or allow migration via work stealing (to spread the workload)<p>FWIW, work stealing is often not recommended in thread-per-core architectures because it introduces quite a bit of unnecessary thread contention. You are correct that load balancing is a central problem in these architectures but it is usually achieved by shedding data since that can be done with minimal locking and inter-thread coordination. This moves the problem to figuring out what data to shed but this has satisfactory inexpensive solutions in many system designs.</div><br/></div></div></div></div></div></div></div></div></div></body></html>