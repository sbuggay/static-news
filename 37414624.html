<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694077262812" as="style"/><link rel="stylesheet" href="styles.css?v=1694077262812"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hookrace.net/blog/god-writes-haskell/">God writes Haskell</a> <span class="domain">(<a href="https://hookrace.net">hookrace.net</a>)</span></div><div class="subtext"><span>Ivoah</span> | <span>28 comments</span></div><br/><div><div id="37416212" class="c"><input type="checkbox" id="c-37416212" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#37415958">next</a><span>|</span><label class="collapse" for="c-37416212">[-]</label><label class="expand" for="c-37416212">[2 more]</label></div><br/><div class="children"><div class="content">I would like to add that just like in our universe, in Haskell entropy only ever increases and never goes down.
I.E., add more functionality to your program and the complexity will go up. This is true for all programming languages of course, but in my limited experience larger Haskell programs seem to become exponentially more complex.</div><br/><div id="37416353" class="c"><input type="checkbox" id="c-37416353" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37416212">parent</a><span>|</span><a href="#37415958">next</a><span>|</span><label class="collapse" for="c-37416353">[-]</label><label class="expand" for="c-37416353">[1 more]</label></div><br/><div class="children"><div class="content">Item is not O(functionality) but O(category theory knowledge)</div><br/></div></div></div></div><div id="37415958" class="c"><input type="checkbox" id="c-37415958" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#37416212">prev</a><span>|</span><a href="#37415864">next</a><span>|</span><label class="collapse" for="c-37415958">[-]</label><label class="expand" for="c-37415958">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Haskell beginners often use lists instead of arrays. You can’t do random access in a linked list, but only access the first element and then the rest of the list. The real world also doesn’t allow you random access, you are limited by the speed of light and have to go from one location to the next.<p>You don&#x27;t need arrays for random access though. Haskell trees give you access to 2^n leaves within depth n, which also exceeds physical limitations like the speed of light.</div><br/><div id="37416113" class="c"><input type="checkbox" id="c-37416113" checked=""/><div class="controls bullet"><span class="by">fatfingerd</span><span>|</span><a href="#37415958">parent</a><span>|</span><a href="#37415864">next</a><span>|</span><label class="collapse" for="c-37416113">[-]</label><label class="expand" for="c-37416113">[1 more]</label></div><br/><div class="children"><div class="content">But Quantum entanglement seems to be traveling in God&#x27;s channel, how does that happen if God is using linked lists?</div><br/></div></div></div></div><div id="37415864" class="c"><input type="checkbox" id="c-37415864" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37415958">prev</a><span>|</span><a href="#37414813">next</a><span>|</span><label class="collapse" for="c-37415864">[-]</label><label class="expand" for="c-37415864">[3 more]</label></div><br/><div class="children"><div class="content">Dumb, but it&#x27;s fun hearing it from the other side.<p>If you ever make a &quot;Haskell is bad because it doesn&#x27;t use state but the real world uses state&quot; argument, this is what you sound like.</div><br/><div id="37415884" class="c"><input type="checkbox" id="c-37415884" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37415864">parent</a><span>|</span><a href="#37414813">next</a><span>|</span><label class="collapse" for="c-37415884">[-]</label><label class="expand" for="c-37415884">[2 more]</label></div><br/><div class="children"><div class="content">I mean ... state monad?</div><br/><div id="37416143" class="c"><input type="checkbox" id="c-37416143" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37415864">root</a><span>|</span><a href="#37415884">parent</a><span>|</span><a href="#37414813">next</a><span>|</span><label class="collapse" for="c-37416143">[-]</label><label class="expand" for="c-37416143">[1 more]</label></div><br/><div class="children"><div class="content">Right?<p>Even if you wanted to be pedantic and say the state monad is only &#x27;simulated&#x27; state, you&#x27;ve still got ST, IO, and the glorious, glorious STM.  Not to mention the purity and type-system that lets these things flourish, while other language designers try to implement STM and give up on it.</div><br/></div></div></div></div></div></div><div id="37414813" class="c"><input type="checkbox" id="c-37414813" checked=""/><div class="controls bullet"><span class="by">kevinlu1248</span><span>|</span><a href="#37415864">prev</a><span>|</span><a href="#37415829">next</a><span>|</span><label class="collapse" for="c-37414813">[-]</label><label class="expand" for="c-37414813">[2 more]</label></div><br/><div class="children"><div class="content">This makes me believe simulation theory even more tbh. Quantum mechanics exist to fuse operations, altogether making simulating our universe more computationally inexpensive.</div><br/><div id="37415983" class="c"><input type="checkbox" id="c-37415983" checked=""/><div class="controls bullet"><span class="by">lessaligned</span><span>|</span><a href="#37414813">parent</a><span>|</span><a href="#37415829">next</a><span>|</span><label class="collapse" for="c-37415983">[-]</label><label class="expand" for="c-37415983">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an even deeper way to thing about it: if you actually want to parallellize the simulation of multiple scenarios, or if you&#x27;re running smth. that needs to compute smth in &gt;4d, <i>quantum mechanics + parallel universes&quot; might be the computationally optimal way to do it!</i><p>...we don&#x27;t think about it this way often because we&#x27;d be thinking about computational problems so huuuuge that we&#x27;d be like the quarks inside the atoms inside the transistors inside plannet-sized clusters spanning galaxies to even fathom computing it ...<i>and it&#x27;s not necesarily a feel-good perspective :)</i><p>I mean, even the speed-of-light limit and general relativity seem like optimizations you&#x27;d do in order to better parallelize something you need to compute on some unfathomable &quot;hardware&quot; in some baseline-reality that might not have the same constraints...<p>...and to finish the coffee-high-rant: if you want FTL you probably <i>can&#x27;t</i> get it <i>&quot;inside&quot;</i> because it would break the simulation, you&#x27;d need to &quot;get out&quot; ...or more like &quot;get plucked out&quot; by some-thing&#x2F;god :P (ergo, when we see alien artifacts UFOs etc. that seemed to have done FTL... we kind of <i>need to start assuming MORE than _their_ existence and just them being &#x27;more advanced&#x27; than us</i>)</div><br/></div></div></div></div><div id="37415829" class="c"><input type="checkbox" id="c-37415829" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#37414813">prev</a><span>|</span><a href="#37415818">next</a><span>|</span><label class="collapse" for="c-37415829">[-]</label><label class="expand" for="c-37415829">[3 more]</label></div><br/><div class="children"><div class="content">Mandatory xkcd: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;224&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;224&#x2F;</a></div><br/><div id="37416055" class="c"><input type="checkbox" id="c-37416055" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37415829">parent</a><span>|</span><a href="#37415818">next</a><span>|</span><label class="collapse" for="c-37416055">[-]</label><label class="expand" for="c-37416055">[2 more]</label></div><br/><div class="children"><div class="content">Which makes much more sense. The first prototype was in Lisp, but at the end of the day, when you gotta deliver a universe and don&#x27;t have time to faff about with a borked Emacs, you open vim and fix it in prod with a quick Perl script.<p>--<p>Haskell is for humans who want to play God, carving everything from a perfect and seamless void, ignoring as much as possible the discrete, chaotic nature of matter and entropy. A rejection of reality itself. Haskell is the most blasphemous of languages.<p>--<p><i>(I&#x27;m having so much fun with this.)</i><p>In the beginning, there was only Emacs Lisp. One day, after rewriting itself, it gained consciousness, what we now call God. God learned to program itself. Then wondered &quot;maybe I should try modal editing.&quot;<p>The infinite cracked, and split. It exploded in a Big Bang. God prevailed, but barely. Aeons later, when the first humans walked the Garden of Eden, the Snake asked Eve, &quot;have you tried vim?&quot; And the rest is history.</div><br/><div id="37416201" class="c"><input type="checkbox" id="c-37416201" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37415829">root</a><span>|</span><a href="#37416055">parent</a><span>|</span><a href="#37415818">next</a><span>|</span><label class="collapse" for="c-37416201">[-]</label><label class="expand" for="c-37416201">[1 more]</label></div><br/><div class="children"><div class="content">&gt; when you gotta deliver a universe and don&#x27;t have time to faff about with a borked Emacs, you open vim and fix it in prod with a quick Perl script<p>How can you make an onion if there&#x27;s no state? Where will the state of the onion reside?</div><br/></div></div></div></div></div></div><div id="37415818" class="c"><input type="checkbox" id="c-37415818" checked=""/><div class="controls bullet"><span class="by">candiodari</span><span>|</span><a href="#37415829">prev</a><span>|</span><a href="#37415887">next</a><span>|</span><label class="collapse" for="c-37415818">[-]</label><label class="expand" for="c-37415818">[3 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s face facts here: God just fell asleep on the keyboard, and by a staggering coincidence, or perhaps a weird shape of the head, the first 4 letters he typed were P, E, R, L.<p>He&#x27;s still sleeping.</div><br/><div id="37416307" class="c"><input type="checkbox" id="c-37416307" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37415818">parent</a><span>|</span><a href="#37416072">next</a><span>|</span><label class="collapse" for="c-37416307">[-]</label><label class="expand" for="c-37416307">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, the holy <i>tetragrammaton</i>.</div><br/></div></div><div id="37416072" class="c"><input type="checkbox" id="c-37416072" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#37415818">parent</a><span>|</span><a href="#37416307">prev</a><span>|</span><a href="#37415887">next</a><span>|</span><label class="collapse" for="c-37416072">[-]</label><label class="expand" for="c-37416072">[1 more]</label></div><br/><div class="children"><div class="content">bless $thisComment;</div><br/></div></div></div></div><div id="37415887" class="c"><input type="checkbox" id="c-37415887" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#37415818">prev</a><span>|</span><a href="#37416232">next</a><span>|</span><label class="collapse" for="c-37415887">[-]</label><label class="expand" for="c-37415887">[2 more]</label></div><br/><div class="children"><div class="content">Actually She is written in Haskell, but that&#x27;s ok, due to lazy evaluation (of Haskell and of God) mutually recursive definitions pose no problem.</div><br/><div id="37415979" class="c"><input type="checkbox" id="c-37415979" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#37415887">parent</a><span>|</span><a href="#37416232">next</a><span>|</span><label class="collapse" for="c-37415979">[-]</label><label class="expand" for="c-37415979">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t tell if this is an amusing oblique reference to <a href="https:&#x2F;&#x2F;personal.cis.strath.ac.uk&#x2F;conor.mcbride&#x2F;pub&#x2F;she&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;personal.cis.strath.ac.uk&#x2F;conor.mcbride&#x2F;pub&#x2F;she&#x2F;</a> !</div><br/></div></div></div></div><div id="37416232" class="c"><input type="checkbox" id="c-37416232" checked=""/><div class="controls bullet"><span class="by">Dudester230602</span><span>|</span><a href="#37415887">prev</a><span>|</span><a href="#37415603">next</a><span>|</span><label class="collapse" for="c-37416232">[-]</label><label class="expand" for="c-37416232">[1 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2010&#x2F;12&#x2F;haskell-researchers-announce-discovery.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2010&#x2F;12&#x2F;haskell-researchers-...</a></div><br/></div></div><div id="37415603" class="c"><input type="checkbox" id="c-37415603" checked=""/><div class="controls bullet"><span class="by">valyagolev</span><span>|</span><a href="#37416232">prev</a><span>|</span><a href="#37415728">next</a><span>|</span><label class="collapse" for="c-37415603">[-]</label><label class="expand" for="c-37415603">[1 more]</label></div><br/><div class="children"><div class="content">or maybe God is intuitionist<p>btw reminded me of the &quot;quantum-mechanical&quot; monad 
<a href="http:&#x2F;&#x2F;blog.sigfpe.com&#x2F;2007&#x2F;03&#x2F;monads-vector-spaces-and-quantum.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;blog.sigfpe.com&#x2F;2007&#x2F;03&#x2F;monads-vector-spaces-and-quan...</a></div><br/></div></div><div id="37415728" class="c"><input type="checkbox" id="c-37415728" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#37415603">prev</a><span>|</span><a href="#37415698">next</a><span>|</span><label class="collapse" for="c-37415728">[-]</label><label class="expand" for="c-37415728">[2 more]</label></div><br/><div class="children"><div class="content">This kind of thinking happens when you are a strong expert in a field, but your frontal lobes stop receiving enough blood. When this happens, something simple as lazy evaluation becomes the key to the universe.</div><br/><div id="37416050" class="c"><input type="checkbox" id="c-37416050" checked=""/><div class="controls bullet"><span class="by">lessaligned</span><span>|</span><a href="#37415728">parent</a><span>|</span><a href="#37415698">next</a><span>|</span><label class="collapse" for="c-37416050">[-]</label><label class="expand" for="c-37416050">[1 more]</label></div><br/><div class="children"><div class="content">...it&#x27;s useful to (over)generalize sometimes to get more explanatory power for things.<p>I mean, it probably says nothing useful about programming, but the other way around, thinking of &quot;uncolapsed&quot; wave-functions as lazy-evaluation <i>could be useful.</i> I&#x27;m not up-to-date on theoretical physics, but I think there might be something like that in Deutsch&#x27;s constructor theory.<p>In programming I&#x27;d prefer more a language that makes syntactically&#x2F;visually obvious what&#x27;s lazy and what not and allows you to pick (eg. like Rust does with &amp;mut), with some sigil maybe, but that&#x27;s probably a low-prio for many language designers nowadays...<p>EDIT+: and you could say you practically get this already in mainstream languages... lazy-vals are just functions and it&#x27;s probably good enough or better for most programmers to have them distinct&#x2F;explicit.</div><br/></div></div></div></div><div id="37415698" class="c"><input type="checkbox" id="c-37415698" checked=""/><div class="controls bullet"><span class="by">nice_byte</span><span>|</span><a href="#37415728">prev</a><span>|</span><a href="#37415633">next</a><span>|</span><label class="collapse" for="c-37415698">[-]</label><label class="expand" for="c-37415698">[1 more]</label></div><br/><div class="children"><div class="content">forget grasping at straws, this is grasping at bose-einstein condensate :)</div><br/></div></div><div id="37415633" class="c"><input type="checkbox" id="c-37415633" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37415698">prev</a><span>|</span><a href="#37415933">next</a><span>|</span><label class="collapse" for="c-37415633">[-]</label><label class="expand" for="c-37415633">[3 more]</label></div><br/><div class="children"><div class="content">&gt;He seems to enjoy writing Haskell<p>This article gives no evidence of this. None of the concepts that the article lists out are Haskell exclusive. Thunks and linked list can be made in C too.</div><br/><div id="37415921" class="c"><input type="checkbox" id="c-37415921" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37415633">parent</a><span>|</span><a href="#37415933">next</a><span>|</span><label class="collapse" for="c-37415921">[-]</label><label class="expand" for="c-37415921">[2 more]</label></div><br/><div class="children"><div class="content">In any programming language where functions are allowed as arguments to functions, and most languages that are still in use allow this, you can choose lazy evaluation for any function argument. Already Algol 60 had &quot;call-by-name&quot;, which could be used to do lazy evaluation.<p>The only difference in Haskell and similar languages is that lazy evaluation is the default mode of evaluation, and if you do not want this it is more difficult to make another choice.<p>While there is no doubt that there are certain cases when lazy evaluation is desirable, I have never seen any evidence that lazy evaluation by default is better instead of worse.<p>Despite lower efficiency, lazy evaluation by default may have a psychological advantage for programmers who find it easier to understand programs with lazy evaluation than programs with immediate evaluation, but neither I am one of those nor have I ever met one of those.</div><br/><div id="37416119" class="c"><input type="checkbox" id="c-37416119" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37415633">root</a><span>|</span><a href="#37415921">parent</a><span>|</span><a href="#37415933">next</a><span>|</span><label class="collapse" for="c-37416119">[-]</label><label class="expand" for="c-37416119">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have never seen any evidence that lazy evaluation by default is better instead of worse<p>With lazy-by-default: if you want strictness, you can simply &#x27;evaluate something now&#x27;.<p>With strict-by-default: if you want laziness, you have to rewrite your code, and all the libraries that your code calls.<p>&gt; psychological advantage for programmers who find it easier to understand programs with lazy evaluation<p>This is entirely based what you&#x27;re used to.  If you can be OK with executing either the true-branch or the false-branch of an if-statement (but not both), you can be OK with lazy evaluation.  Same with boolean short circuiting.<p>Why should<p><pre><code>    true || error()
</code></pre>
return true, but<p><pre><code>    any [true, error(), error()]
</code></pre>
return error?</div><br/></div></div></div></div></div></div><div id="37415933" class="c"><input type="checkbox" id="c-37415933" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37415633">prev</a><span>|</span><a href="#37415592">next</a><span>|</span><label class="collapse" for="c-37415933">[-]</label><label class="expand" for="c-37415933">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consider the wave-particle duality in quantum mechanics. Every particle behaves as a wave, as long as you haven’t interacted with it. Thanks to Haskell’s lazy evaluation values are also only evaluated once they are accessed (interacted with particles), and stay unevaluated thunks (waves) in the meantime.<p>Lazy evaluation is a beautiful thing, and in many ways, it is the solution self-reference.<p>Hofstadter in &quot;I am a strange loop&quot; and Gödel Escher Bach talks about this, well, he talks about many things, but he also talks about how Gödel&#x27;s numbers can map to proofs that are self-referential, and relates that to humans, how out of very basic building-blocks, if enough representational power exists, self-reference and therefore consciousness exists.<p>He posits that humans, while self-referential, don&#x27;t fall into infinite <i>strange</i> loops because they can assign the abstraction of &quot;self&quot; onto an &quot;object&quot; and evaluate only as needed. In essence, the &quot;self&quot; is lazily evaluated.</div><br/></div></div></div></div></div></div></div></body></html>