<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713089488691" as="style"/><link rel="stylesheet" href="styles.css?v=1713089488691"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wingolog.org/archives/2023/11/24/tree-shaking-the-horticulturally-misguided-algorithm">Tree-shaking, the horticulturally misguided algorithm (2023)</a> <span class="domain">(<a href="https://wingolog.org">wingolog.org</a>)</span></div><div class="subtext"><span>andsoitis</span> | <span>130 comments</span></div><br/><div><div id="40023606" class="c"><input type="checkbox" id="c-40023606" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#40023541">next</a><span>|</span><label class="collapse" for="c-40023606">[-]</label><label class="expand" for="c-40023606">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve kept openEtG&#x27;s wasm blob (card game engine) &lt;400kb while migrating a lot of logic (card text generation, etc) to wasm. It&#x27;s Rust. Doing so takes some care:<p>1. avoid floats (fixed point arithmetic saved quite a bit of space)<p>2. avoid hashmaps (originally used hashmaps since it was easy to port JS maps to, have since ported everything to vecs)<p>3. avoid strings (for awhile there were no strings, but eventually brought it in for display logic)<p>4. use a small allocator, like talc<p>5. avoid dependencies. I only use rand &amp; fxhash. I should probably get rid of rand (fxhash only used to hash game state to check for desyncs)<p>6. avoid generic diversity. I try to keep a small set of instantiated types, for example Vec&lt;i16&gt; is there so no need to bring in Box&lt;[i16]&gt; or anything. Getting away from floats&#x2F;hashmaps helped reduce type diversity<p>7. design algorithms with size in mind, I have a couple lookup tables where I pack bits <a href="https:&#x2F;&#x2F;github.com&#x2F;serprex&#x2F;openEtG&#x2F;blob&#x2F;2011007dec2616d1a24d3de6dd7cad93478711dd&#x2F;src&#x2F;rs&#x2F;src&#x2F;etg.rs#L12">https:&#x2F;&#x2F;github.com&#x2F;serprex&#x2F;openEtG&#x2F;blob&#x2F;2011007dec2616d1a24d...</a> encodes an adrenaline mechanic where multiple attacks give lower attack power creatures more attacks than higher attack power creatures. Care was taken comparing how much decoding logic cost compared to storing unpacked values. AI evaluation uses 6 bit fixed precision because 64 encodes more efficiently than 128 in webassembly<p>Similarly there&#x27;s a targeting mechanism with AND&#x2F;OR &amp; predicates. I used to have an AST like format with each predicate getting an enum &amp; AND&#x2F;OR being a slice of expressions. Now each expression is 32 bit integers encoding expression in polish notation, AND&#x2F;OR have 2 bit codes &amp; predicates are 6 bits (polish notation won over reverse polish here because with polish notation I was able to have AND&#x2F;OR short circuit evaluation)</div><br/><div id="40028539" class="c"><input type="checkbox" id="c-40028539" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40027991">next</a><span>|</span><label class="collapse" for="c-40028539">[-]</label><label class="expand" for="c-40028539">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 1. avoid floats (fixed point arithmetic saved quite a bit of space)<p>This is really interesting, since WASM has built in float types of course - is there any more detail you can go into &#x2F; examples you can show us?<p>I have a problem at work where I was thinking fixed point arithmetic might help, because I know my maximum resolution needs (e.g. I know the problem will never care about sub-millimetre positioning). I&#x27;d be interested to hear more about related issues.</div><br/></div></div><div id="40027991" class="c"><input type="checkbox" id="c-40027991" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40028539">prev</a><span>|</span><a href="#40025206">next</a><span>|</span><label class="collapse" for="c-40027991">[-]</label><label class="expand" for="c-40027991">[1 more]</label></div><br/><div class="children"><div class="content">More things that I&#x27;ve found helped:<p>- Use wasm-opt from binaryen. That seems to reliably drop wasm size by ~20-30%. ( <a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;binaryen">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;binaryen</a> )<p>- Use brotli compression for serving wasm bundles to the browser, and make sure your web server is setup to use the brotli compressed files. (Its a 1 line change in nginx, for example). Brotli drops the size of wasm bundles by about 3x. Its much better than gzip for wasm.</div><br/></div></div><div id="40025206" class="c"><input type="checkbox" id="c-40025206" checked=""/><div class="controls bullet"><span class="by">WanderPanda</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40027991">prev</a><span>|</span><a href="#40023776">next</a><span>|</span><label class="collapse" for="c-40025206">[-]</label><label class="expand" for="c-40025206">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working on a C++ deep RL library (RLtools) and also created some WASM examples (<a href="https:&#x2F;&#x2F;rl.tools" rel="nofollow">https:&#x2F;&#x2F;rl.tools</a>). I didn&#x27;t pay any attention to the binary size at all but it turns out it is also just around 200-300kb (including everything, deep learning forward&#x2F;backward, RL algo and dynamics simulation).<p>Even though it&#x27;s not prohibitive rn, I&#x27;m curious how small it could be and hopefully find some time soon to squeeze it down</div><br/></div></div><div id="40023776" class="c"><input type="checkbox" id="c-40023776" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40025206">prev</a><span>|</span><a href="#40024579">next</a><span>|</span><label class="collapse" for="c-40023776">[-]</label><label class="expand" for="c-40023776">[4 more]</label></div><br/><div class="children"><div class="content">Wow! Do you have numbers anywhere showing the space saved? Especially for step 6, using a Vec as a Box, I would not expect that to save much.</div><br/><div id="40024264" class="c"><input type="checkbox" id="c-40024264" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#40023606">root</a><span>|</span><a href="#40023776">parent</a><span>|</span><a href="#40023792">next</a><span>|</span><label class="collapse" for="c-40024264">[-]</label><label class="expand" for="c-40024264">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Especially for step 6, using a Vec as a Box, I would not expect that to save much.<p>It&#x27;s not that using a Vec as a Box saves anything at all. It&#x27;s that generics require monomorphisation, and that eats up a bunch of space, and more instances of generic types translates into more space.<p>If your application uses Vec&lt;i16&gt; elsewhere, you&#x27;ve already paid the binary size price for using it. Vec&lt;i16&gt; is close enough to Box&lt;[i16]&gt; that the functional differences don&#x27;t warrant the extra code generation.</div><br/></div></div><div id="40023792" class="c"><input type="checkbox" id="c-40023792" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#40023606">root</a><span>|</span><a href="#40023776">parent</a><span>|</span><a href="#40024264">prev</a><span>|</span><a href="#40026745">next</a><span>|</span><label class="collapse" for="c-40023792">[-]</label><label class="expand" for="c-40023792">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately nothing concrete, it&#x27;s a few kb here &amp; there. I&#x27;d estimate I&#x27;ve saved ~300kb overall. I&#x27;d have to go back to compare these things. Removing floats saved more space than I expected<p>Also important is configuring compiler correctly,<p><pre><code>  [profile.release]
  opt-level = &quot;z&quot;
  lto = &quot;fat&quot;
  codegen-units = 1</code></pre></div><br/></div></div><div id="40026745" class="c"><input type="checkbox" id="c-40026745" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40023606">root</a><span>|</span><a href="#40023776">parent</a><span>|</span><a href="#40023792">prev</a><span>|</span><a href="#40024579">next</a><span>|</span><label class="collapse" for="c-40026745">[-]</label><label class="expand" for="c-40026745">[1 more]</label></div><br/><div class="children"><div class="content">he meant Box&lt;[T]&gt; (aka fixed-size vec or heap allocated array) rather than Box&lt;T&gt; (a single heap allocated element)</div><br/></div></div></div></div><div id="40024579" class="c"><input type="checkbox" id="c-40024579" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40023776">prev</a><span>|</span><a href="#40027337">next</a><span>|</span><label class="collapse" for="c-40024579">[-]</label><label class="expand" for="c-40024579">[3 more]</label></div><br/><div class="children"><div class="content"><i>avoid floats (fixed point arithmetic saved quite a bit of space)</i><p>Can someone help me understand how this works? I thought JavaScript uses doubles for everything. Is WASM completely different in this regard?</div><br/><div id="40024826" class="c"><input type="checkbox" id="c-40024826" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#40023606">root</a><span>|</span><a href="#40024579">parent</a><span>|</span><a href="#40027337">next</a><span>|</span><label class="collapse" for="c-40024826">[-]</label><label class="expand" for="c-40024826">[2 more]</label></div><br/><div class="children"><div class="content">Yes. WASM has proper integer and floating-point types.</div><br/><div id="40025160" class="c"><input type="checkbox" id="c-40025160" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40023606">root</a><span>|</span><a href="#40024826">parent</a><span>|</span><a href="#40027337">next</a><span>|</span><label class="collapse" for="c-40025160">[-]</label><label class="expand" for="c-40025160">[1 more]</label></div><br/><div class="children"><div class="content">And even JavaScript only <i>conceptually</i> uses doubles everywhere, JavaScript engines do use integers where they get away with it. Your loop counter is almost certainly an int. You can use this to your advantage for optimization purposes if you carefully craft your statements to probably fit in integers (e.g. by adding bitwise operations)</div><br/></div></div></div></div></div></div><div id="40027337" class="c"><input type="checkbox" id="c-40027337" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40024579">prev</a><span>|</span><a href="#40028294">next</a><span>|</span><label class="collapse" for="c-40027337">[-]</label><label class="expand" for="c-40027337">[2 more]</label></div><br/><div class="children"><div class="content">Why do floats and strings have such a high cost?</div><br/><div id="40028122" class="c"><input type="checkbox" id="c-40028122" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40023606">root</a><span>|</span><a href="#40027337">parent</a><span>|</span><a href="#40028294">next</a><span>|</span><label class="collapse" for="c-40028122">[-]</label><label class="expand" for="c-40028122">[1 more]</label></div><br/><div class="children"><div class="content">Strings seem to have a high cost because there&#x27;s a lot of complexity in rust&#x27;s format! macros. And the generated code seems to end up with a lot of obscure ways it can panic.<p>I&#x27;ve found just having one stray dbg!() in my rust code can add ~20kb to my wasm bundle size. Look at what a single dbg!(some_u32) generates: <a href="https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;bex9z8vx7" rel="nofollow">https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;bex9z8vx7</a> . Its also calling into a bunch of garbled functions in the standard library - which will bring in a lot more code.<p>I suspect zig&#x27;s comptime approach might work much better for for this sort of thing, if we want smaller binary sizes.</div><br/></div></div></div></div><div id="40028294" class="c"><input type="checkbox" id="c-40028294" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#40023606">parent</a><span>|</span><a href="#40027337">prev</a><span>|</span><a href="#40023541">next</a><span>|</span><label class="collapse" for="c-40028294">[-]</label><label class="expand" for="c-40028294">[1 more]</label></div><br/><div class="children"><div class="content">jesus christ, just do a desktop app. by your own admission you only saved 300k with all that. a desktop app at 700k is nothing, which means you could ignore all these optimizations and focus on improving speed or adding features</div><br/></div></div></div></div><div id="40023541" class="c"><input type="checkbox" id="c-40023541" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#40023606">prev</a><span>|</span><a href="#40024001">next</a><span>|</span><label class="collapse" for="c-40023541">[-]</label><label class="expand" for="c-40023541">[40 more]</label></div><br/><div class="children"><div class="content">Tree-shaking is such a bad misnomer. Virgil&#x27;s compiler calls this &quot;reachability analysis&quot; and it&#x27;s built into the compilation model. The compiler will parse and typecheck a program&#x27;s (and libraries&#x27; code), and run initializers, but after that the compilation proceeds by exploring from the main entrypoint(s) and only reachable code is analyzed and ends in the final binary. It will happily generate a program (without runtime system) that just consists of a single main function. The runtime system is only necessary for stacktraces and GC, and can be omitted if desired.</div><br/><div id="40024513" class="c"><input type="checkbox" id="c-40024513" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40023541">parent</a><span>|</span><a href="#40025119">next</a><span>|</span><label class="collapse" for="c-40024513">[-]</label><label class="expand" for="c-40024513">[3 more]</label></div><br/><div class="children"><div class="content">The name &quot;treeshaker&quot; for an application delivery tool possibly originated in Lisp. The first time I&#x27;ve found it was in Lucid Common Lisp, a (no longer available) commercial implementation of Common Lisp for UNIX. Lucid CL 4.1 in 1992 included a tool called Treeshaker. Lucid CL was one of those Lisps which have the idea of an image (see for example the &quot;image&quot; feature of Lisp 1 in 1960), a saved memory dump of the current heap of a running Lisp. An application then is an image plus a runtime. The image typically includes almost all code AND data from the memory, which sometimes creates the wish to create smaller images for application delivery. Lucid CL then included a tool, which before saving that image, removes all kinds of unused code and data, depending on some meaning of what „unused“ means. For example the symbol table may have variables, types, functions, etc. which are not referenced anywhere. A treeshaker tool might also get a list of things to remove. Thus in a graph of reachable Lisp data&amp;code, the connections are pruned. Either a GC or a specialized piece of code then collects the garbage, shrinks memory (-&gt; shakes the tree and everything which is cut loose is falling down) and dumps it as a possibly smaller image.<p>The treeshaker thus was not a compiler tool, but a tool to remove what was determined to be unused code of a Lisp heap. Remember, by default such a Lisp image would also contain a compiler, an interpreter and an implementation of a read-eval-print loop. Thus if we break (-&gt; interrupt a thread which then provides a REPL) a running program into such a read-eval-print loop, we could still use all the code, which is in this heap (which was restored from an image). Thus it would make sense to remove the compiler too, and possibly the read-eval-print loop, too.</div><br/><div id="40027288" class="c"><input type="checkbox" id="c-40027288" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024513">parent</a><span>|</span><a href="#40029670">next</a><span>|</span><label class="collapse" for="c-40027288">[-]</label><label class="expand" for="c-40027288">[1 more]</label></div><br/><div class="children"><div class="content">I could be wrong, but I&#x27;ve heard that the term originated in Smalltalk. Smalltalk is also image-based, and tree-shaking was a way to produce a smaller image for deploying.</div><br/></div></div><div id="40029670" class="c"><input type="checkbox" id="c-40029670" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024513">parent</a><span>|</span><a href="#40027288">prev</a><span>|</span><a href="#40025119">next</a><span>|</span><label class="collapse" for="c-40029670">[-]</label><label class="expand" for="c-40029670">[1 more]</label></div><br/><div class="children"><div class="content">References:<p>Lucid Inc. used the word internally at least since 1987, mentioning a treeshaker for Lucid CL 3.0 on the VAX.<p>&quot;Lisp Systems in the 1990s&quot;, Layer&#x2F;Richardson, 1991
<a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;114669.114674" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;114669.114674</a><p>From above: &quot;In contrast, tree shaking uses the approach of eliminating --shaking out-- what is not needed in a static fashion. Programmers specify the requirements of their application and the unneeded parts of the Lisp system are removed using their detailed knowledge of the application. The disadvantages of tree shaking are that it requires programmer intervention and that a function which is shaken out cannot be easily restored.&quot;<p>&quot;Building Common Lisp Applications with Reasonable Performance&quot;, Boreczky&#x2F;Rowe, 1993, <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;1040032.174174" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;1040032.174174</a><p>&quot;Lisp: Good News, Bad News, How to Win Big&quot;, Gabriel, (not sure from when this version is, the original article is from 1989)   <a href="https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;Files&#x2F;LispGoodNewsBadNews.pdf" rel="nofollow">https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;Files&#x2F;LispGoodNewsBadNews.pdf</a><p>From Gabriel&#x27;s essay:<p>&gt; &quot;1.6.3 The Treeshaker<p>&gt; Most Lisp development systems, including Lucid’s, provide all the resources of the Lisp system by default, and this in turn leads to a style of development in which the programmer makes use of whatever tool happens to be most convenient. Because much of the basic Lisp system (or any development system built on top of the basic Lisp system) will generally be unused by a given application, it is very worthwhile to have a tool for excising these unused parts. This tool is called the Treeshaker.<p>&gt; Treeshaker execution occurs in three phases: walking, testing and writing. In the walking phase, the Treeshaker accumulates a set of objects that need to be included in the saved image. After making this set, the treeshaker runs a test of the application to check that all objects which are used in a typical run have been included. The writing phase then generates an executable image which will run the application.<p>&gt; To a first approximation, the walk phase is just a matter of computing the connected component of the Lisp image (treated as a directed graph in the obvious way) generated by the application’s toplevel function. However, because of the way that Lisp objects are generally connected this usually includes almost the entire Lisp image including the unused subsystems. Therefore the treeshaker uses several techniques to find connections between objects that do not actually need to be followed in the walk.&quot;<p>&gt; &quot;The name Treeshaker is meant to be evocative of the idea of actually shaking a tree to dislodge dead branches or other trash.&quot;<p>On the more funny side, LispWorks has a keyword to the DELIVER function :shake-shake-shake , which invokes the treeshaker during application delivery.<p><a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;lw80&#x2F;deliv&#x2F;deliv-keywords-2.htm#DELIV):shake-shake-shake%20keyword" rel="nofollow">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;lw80&#x2F;deliv&#x2F;deliv-key...</a></div><br/></div></div></div></div><div id="40025119" class="c"><input type="checkbox" id="c-40025119" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40023541">parent</a><span>|</span><a href="#40024513">prev</a><span>|</span><a href="#40024057">next</a><span>|</span><label class="collapse" for="c-40025119">[-]</label><label class="expand" for="c-40025119">[2 more]</label></div><br/><div class="children"><div class="content">The correct general term is “dead-code elimination” [0]. Reachability analysis is commonly used do determine what code can be removed, but other methods are possible, and the analysis by itself doesn’t remove any code, that’s a subsequent step.<p>“Tree-shaking” as commonly used implies that the granularity of the removal is functions, whereas dead-code elimination can generally be at arbitrarily fine levels, for example eliminating branches of conditional expressions, and can be based on all kinds of static program analyses.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dead-code_elimination" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dead-code_elimination</a></div><br/><div id="40027767" class="c"><input type="checkbox" id="c-40027767" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025119">parent</a><span>|</span><a href="#40024057">next</a><span>|</span><label class="collapse" for="c-40027767">[-]</label><label class="expand" for="c-40027767">[1 more]</label></div><br/><div class="children"><div class="content">Although true, in most cases when people talk about dead code elimination, they refer to eliminating code inside a function, whereas tree-shaking unambiguously refers to inter-procedural dead code elimination.</div><br/></div></div></div></div><div id="40024057" class="c"><input type="checkbox" id="c-40024057" checked=""/><div class="controls bullet"><span class="by">SkyPuncher</span><span>|</span><a href="#40023541">parent</a><span>|</span><a href="#40025119">prev</a><span>|</span><a href="#40025856">next</a><span>|</span><label class="collapse" for="c-40024057">[-]</label><label class="expand" for="c-40024057">[3 more]</label></div><br/><div class="children"><div class="content">Many things in software are misnomers.<p>Personally, I think it’s an amazing name. The first time I saw the term, I knew exactly what it was without any further research.<p>You shake a tree to remove the loose things. In this case, it was clear that unused packages are being “shaken” from the tree.</div><br/><div id="40027718" class="c"><input type="checkbox" id="c-40027718" checked=""/><div class="controls bullet"><span class="by">cout</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024057">parent</a><span>|</span><a href="#40026240">next</a><span>|</span><label class="collapse" for="c-40027718">[-]</label><label class="expand" for="c-40027718">[1 more]</label></div><br/><div class="children"><div class="content">It makes sense to me now, but the first time I heard the term it brought to mind Wreckx-n-Effect.  I am glad there was no connection.</div><br/></div></div><div id="40026240" class="c"><input type="checkbox" id="c-40026240" checked=""/><div class="controls bullet"><span class="by">torgoguys</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024057">parent</a><span>|</span><a href="#40027718">prev</a><span>|</span><a href="#40025856">next</a><span>|</span><label class="collapse" for="c-40026240">[-]</label><label class="expand" for="c-40026240">[1 more]</label></div><br/><div class="children"><div class="content">The reason I didn&#x27;t like the name when I first came across it is that I think of shaking the tree for harvesting the fruit. The fruit is what you want, not what you want to eliminate.<p>But it&#x27;s an ok term overall.</div><br/></div></div></div></div><div id="40025856" class="c"><input type="checkbox" id="c-40025856" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#40023541">parent</a><span>|</span><a href="#40024057">prev</a><span>|</span><a href="#40023914">next</a><span>|</span><label class="collapse" for="c-40025856">[-]</label><label class="expand" for="c-40025856">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Tree-shaking is such a bad misnomer.<p>I don&#x27;t think so. I never considered tree-shaking to refer to the plants, rather the data structure.<p>If you imagine the diagram of some source code as a physical object, then shaking it would cause anything unreachable from the root to fall away.<p>I really don&#x27;t see how reachability analysis is any different. One term just invokes a more spacial sense of reasoning.</div><br/><div id="40026110" class="c"><input type="checkbox" id="c-40026110" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025856">parent</a><span>|</span><a href="#40023914">next</a><span>|</span><label class="collapse" for="c-40026110">[-]</label><label class="expand" for="c-40026110">[1 more]</label></div><br/><div class="children"><div class="content">Reachability analysis is a far far far far superior term because it actually describes what it is. Wtf is &quot;tree shaking&quot;? I was confused about this for ages until I realised it was just a fucking stupid term for dead code elimination.<p>If your term is confusing as fuck until you say &quot;it just means X&quot; then that is a stupid useless idiotic term.</div><br/></div></div></div></div><div id="40023914" class="c"><input type="checkbox" id="c-40023914" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40023541">parent</a><span>|</span><a href="#40025856">prev</a><span>|</span><a href="#40024112">next</a><span>|</span><label class="collapse" for="c-40023914">[-]</label><label class="expand" for="c-40023914">[17 more]</label></div><br/><div class="children"><div class="content">How so?<p>There is lots of code (tree).<p>Some of the code is not connected to the entry point (trunk).<p>Tree shaking removes the disconnected parts (loose leaves, dead branches).</div><br/><div id="40023999" class="c"><input type="checkbox" id="c-40023999" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40023914">parent</a><span>|</span><a href="#40024112">next</a><span>|</span><label class="collapse" for="c-40023999">[-]</label><label class="expand" for="c-40023999">[16 more]</label></div><br/><div class="children"><div class="content">Dead branches and loose leaves are still connected to a real tree, that&#x27;s why it&#x27;s a misnomer. &quot;Raking&quot; would be a better name if you want to keep to the metaphor. Dead code elimination is the most precise term, and is already well established.</div><br/><div id="40028934" class="c"><input type="checkbox" id="c-40028934" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40023999">parent</a><span>|</span><a href="#40024528">next</a><span>|</span><label class="collapse" for="c-40028934">[-]</label><label class="expand" for="c-40028934">[1 more]</label></div><br/><div class="children"><div class="content">Tree shaking is the established lisp term, but not used for compilers, but packagers, to shrink images. Dead branches are NOT stored in the pruned image.<p>Dead code elimination came 20 years later with C compilers.<p>The problem with treeshaking - I wrote my first for my lisp 30 years ago, it was trivial - is the lack of compile-time evaluation. The more the compiler knows, the more it can prune. Every run-time branch, late binding and esp. dynamic call by string kills it. With simple tricks you can eliminate 90% of your code. IO, error handling, the number tree, lots of slack in the stdlib&#x27;s. With GUI even more. I heard from CL images shrinked from 2GB down to a floppy disk.</div><br/></div></div><div id="40024528" class="c"><input type="checkbox" id="c-40024528" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40023999">parent</a><span>|</span><a href="#40028934">prev</a><span>|</span><a href="#40024468">next</a><span>|</span><label class="collapse" for="c-40024528">[-]</label><label class="expand" for="c-40024528">[1 more]</label></div><br/><div class="children"><div class="content">One is pruning dead stuff and shaking the tree is then letting them fall down. The garbage collector then takes it away.</div><br/></div></div><div id="40024468" class="c"><input type="checkbox" id="c-40024468" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40023999">parent</a><span>|</span><a href="#40024528">prev</a><span>|</span><a href="#40024241">next</a><span>|</span><label class="collapse" for="c-40024468">[-]</label><label class="expand" for="c-40024468">[6 more]</label></div><br/><div class="children"><div class="content">dead branches and loose leaves are connected to a real tree in the same way that dead code is connected to the program in a file. if you break off the dead branch, nothing happens to the tree, just like when you remove unused code, nothing happens to the program.</div><br/><div id="40025103" class="c"><input type="checkbox" id="c-40025103" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024468">parent</a><span>|</span><a href="#40024241">next</a><span>|</span><label class="collapse" for="c-40025103">[-]</label><label class="expand" for="c-40025103">[5 more]</label></div><br/><div class="children"><div class="content">&gt; if you break of the dead branch, nothing happens to the tree, just like when you remove unused code, nothing happens to the program.<p>Indeed, and this has been known since the 80s as dead code elimination. So why are we using a new, less descriptive, more confusing term again?</div><br/><div id="40025587" class="c"><input type="checkbox" id="c-40025587" checked=""/><div class="controls bullet"><span class="by">HumanOstrich</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025103">parent</a><span>|</span><a href="#40025949">next</a><span>|</span><label class="collapse" for="c-40025587">[-]</label><label class="expand" for="c-40025587">[3 more]</label></div><br/><div class="children"><div class="content">Language and terminology evolve over time. It can be uncomfortable and challenging to adapt.<p>Some new developers might be introduced to the concept initially as &quot;tree-shaking&quot;. It&#x27;s not wrong; it just differs from your preference.</div><br/><div id="40026412" class="c"><input type="checkbox" id="c-40026412" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025587">parent</a><span>|</span><a href="#40025949">next</a><span>|</span><label class="collapse" for="c-40026412">[-]</label><label class="expand" for="c-40026412">[2 more]</label></div><br/><div class="children"><div class="content">I learned of tree shaking first, and DCE is clearly superior as a term: 1) it&#x27;s actually descriptive, 2) there&#x27;s a large literature using this term to look for further information, and 3) as the original poster noted, it&#x27;s not actually a misnomer. There is literally no advantage to the new term that I can think of.</div><br/><div id="40028413" class="c"><input type="checkbox" id="c-40028413" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40026412">parent</a><span>|</span><a href="#40025949">next</a><span>|</span><label class="collapse" for="c-40028413">[-]</label><label class="expand" for="c-40028413">[1 more]</label></div><br/><div class="children"><div class="content">DCE is too general.<p>Tree-shaking is specifically the form of DCE where you remove unreferenced functions&#x2F;modules.<p>Especially important is that you can do tree-shaking without analyzing control flow, while by default &quot;DCE&quot; implies you&#x27;re analyzing control flow.<p>And I don&#x27;t think tree-shaking is a misnomer.  Depending on how you visualize the metaphor, unreferenced functions are either barely attached or not attached.  Shaking them off is simple and sufficiently realistic.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40024241" class="c"><input type="checkbox" id="c-40024241" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40023999">parent</a><span>|</span><a href="#40024468">prev</a><span>|</span><a href="#40024568">next</a><span>|</span><label class="collapse" for="c-40024241">[-]</label><label class="expand" for="c-40024241">[4 more]</label></div><br/><div class="children"><div class="content">Tree shaking is also well established in the JavaScript world, more so than DCE, so it&#x27;s pretty natural for it to be used in a wasm context.</div><br/><div id="40025095" class="c"><input type="checkbox" id="c-40025095" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024241">parent</a><span>|</span><a href="#40024568">next</a><span>|</span><label class="collapse" for="c-40025095">[-]</label><label class="expand" for="c-40025095">[3 more]</label></div><br/><div class="children"><div class="content">DCE is a standard compiler optimization that&#x27;s been been around since at least the 80s. It&#x27;s done in multiple different ways, and &quot;tree shaking&quot; is just one more way. Whether the term DCE is known doesn&#x27;t seem relevant to what is the most descriptive and meaningful term for this optimization.</div><br/><div id="40029496" class="c"><input type="checkbox" id="c-40029496" checked=""/><div class="controls bullet"><span class="by">fenomas</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025095">parent</a><span>|</span><a href="#40028046">next</a><span>|</span><label class="collapse" for="c-40029496">[-]</label><label class="expand" for="c-40029496">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak to origins, but currently in the JS world DCE and tree-shaking refer to different things. &quot;Tree-shaking&quot; normally refers to when the <i>bundler</i> omits unreachable code, that a more naive bundler would have included. It&#x27;s an oft-discussed topic because it wasn&#x27;t possible to do in some earlier module formats, and some bundlers do it better than others. In this context the &quot;tree&quot; mostly refers to the dependency tree.<p>In contrast DCE usually refers what the JS <i>engine</i> does at runtime, via whatever means. But DCE isn&#x27;t much discussed, unless one talking about v8 internals or the like.</div><br/></div></div><div id="40028046" class="c"><input type="checkbox" id="c-40028046" checked=""/><div class="controls bullet"><span class="by">ratmice</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025095">parent</a><span>|</span><a href="#40029496">prev</a><span>|</span><a href="#40024568">next</a><span>|</span><label class="collapse" for="c-40028046">[-]</label><label class="expand" for="c-40028046">[1 more]</label></div><br/><div class="children"><div class="content">DCE has been around at least since 1971 Frances E. Allen&#x27;s &quot;A catalogue of optimizing trasformations&quot;, but I don&#x27;t have her earlier papers&#x2F;internal ibm memos to be able to say, but the section on DCE in that paper didn&#x27;t appear to contain any further references.</div><br/></div></div></div></div></div></div><div id="40024568" class="c"><input type="checkbox" id="c-40024568" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40023999">parent</a><span>|</span><a href="#40024241">prev</a><span>|</span><a href="#40024112">next</a><span>|</span><label class="collapse" for="c-40024568">[-]</label><label class="expand" for="c-40024568">[3 more]</label></div><br/><div class="children"><div class="content">Have you... Ever seen a tree?<p>And what happens when the wind blows?<p>Shaking and raking are hardly different in kind.</div><br/><div id="40025116" class="c"><input type="checkbox" id="c-40025116" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024568">parent</a><span>|</span><a href="#40024112">next</a><span>|</span><label class="collapse" for="c-40025116">[-]</label><label class="expand" for="c-40025116">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And what happens when the wind blows?<p>And wind blowing has what to do with compiler optimizations again?<p>&gt; Shaking and raking are hardly different in kind.<p>The only way they&#x27;re similar is that they&#x27;re both kinda dumb names for this optimization that has had a standard name for 40 years.</div><br/><div id="40026587" class="c"><input type="checkbox" id="c-40026587" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025116">parent</a><span>|</span><a href="#40024112">next</a><span>|</span><label class="collapse" for="c-40026587">[-]</label><label class="expand" for="c-40026587">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And wind blowing has what to do with compiler optimizations again?<p>The wind blowing shakes the tree.<p>When the tree shakes, the dead branches and loose leaves are removed.<p>---<p>This is similar to when a bundler will traverse the connected code graph and remove the things that are not attached.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40024112" class="c"><input type="checkbox" id="c-40024112" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40023541">parent</a><span>|</span><a href="#40023914">prev</a><span>|</span><a href="#40024001">next</a><span>|</span><label class="collapse" for="c-40024112">[-]</label><label class="expand" for="c-40024112">[12 more]</label></div><br/><div class="children"><div class="content">Proving yet again that there aren’t enough gardeners in computer science.<p>The metaphor we use for optimization is “low hanging fruit” which no orchard owner would ever do. It’s massively wasteful, be you a programmer or a farmer. It’s what amateurs do. I do tree shaking. Pick a tree (subject matter in the code) and get all of the fruit that’s willing to fall off before moving to the next. It’s more efficient, more effective, and more sustainable. It works with human factors instead of against them.<p>What we call tree shaking is more like tree pruning. Specifically what you’d call thinning (tracing a misplaced or damaged branch back to the parent and cutting it there).</div><br/><div id="40024185" class="c"><input type="checkbox" id="c-40024185" checked=""/><div class="controls bullet"><span class="by">mankyd</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024112">parent</a><span>|</span><a href="#40025199">next</a><span>|</span><label class="collapse" for="c-40024185">[-]</label><label class="expand" for="c-40024185">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The metaphor we use for optimization is “low hanging fruit” which no orchard owner would ever do.<p>This is just over-extending the metaphor.<p>The term has existed long before software was a thing, and refers simply to grabbing something that&#x27;s easy. That&#x27;s it.<p>The same goes for tree-shaking. The author does the same thing - over-extends the metaphor. Tree shaking simply means giving everything a jiggle and seeing what comes loose. It&#x27;s easy to understand and shouldn&#x27;t be read into any more than that.</div><br/></div></div><div id="40025199" class="c"><input type="checkbox" id="c-40025199" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024112">parent</a><span>|</span><a href="#40024185">prev</a><span>|</span><a href="#40024176">next</a><span>|</span><label class="collapse" for="c-40025199">[-]</label><label class="expand" for="c-40025199">[7 more]</label></div><br/><div class="children"><div class="content">I believe low hanging fruit is not specific to CS.<p>Regardless, it is a perfect metaphor. You want to eat an apple: which one do you pick? Taking the low-hanging fruit is less work right now and gets you to your immediate goal, but disregards general efficiency. Sure, picking a whole tree is more efficient. But if you want a single apple, taking the low hanging fruit is the fastest approach. The metaphor works because it actually implies that it&#x27;s not the most efficient approach, just the easiest</div><br/><div id="40025237" class="c"><input type="checkbox" id="c-40025237" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025199">parent</a><span>|</span><a href="#40024176">next</a><span>|</span><label class="collapse" for="c-40025237">[-]</label><label class="expand" for="c-40025237">[6 more]</label></div><br/><div class="children"><div class="content">As I said, it’s what amateurs do. We are not amateurs.</div><br/><div id="40025848" class="c"><input type="checkbox" id="c-40025848" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025237">parent</a><span>|</span><a href="#40025824">next</a><span>|</span><label class="collapse" for="c-40025848">[-]</label><label class="expand" for="c-40025848">[1 more]</label></div><br/><div class="children"><div class="content">Everyone, even the amateurs and complete non–gardeners, know that this is not the best way to pick fruit. The whole point of the phrase is to point out that someone was lazy. It is saying that all they did was the absolute minimum amount of work.</div><br/></div></div><div id="40025824" class="c"><input type="checkbox" id="c-40025824" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025237">parent</a><span>|</span><a href="#40025848">prev</a><span>|</span><a href="#40025315">next</a><span>|</span><label class="collapse" for="c-40025824">[-]</label><label class="expand" for="c-40025824">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still a good metaphor. Nobody said picking low hanging fruit is the best approach in harvesting fruit or in computer science.</div><br/></div></div><div id="40025315" class="c"><input type="checkbox" id="c-40025315" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025237">parent</a><span>|</span><a href="#40025824">prev</a><span>|</span><a href="#40026027">next</a><span>|</span><label class="collapse" for="c-40025315">[-]</label><label class="expand" for="c-40025315">[2 more]</label></div><br/><div class="children"><div class="content">Are you intentionally missing the point to find a reason to talk about what you know about harvesting fruit?</div><br/><div id="40025495" class="c"><input type="checkbox" id="c-40025495" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40025315">parent</a><span>|</span><a href="#40026027">next</a><span>|</span><label class="collapse" for="c-40025495">[-]</label><label class="expand" for="c-40025495">[1 more]</label></div><br/><div class="children"><div class="content">I think you might be projecting.</div><br/></div></div></div></div></div></div></div></div><div id="40024176" class="c"><input type="checkbox" id="c-40024176" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024112">parent</a><span>|</span><a href="#40025199">prev</a><span>|</span><a href="#40026281">next</a><span>|</span><label class="collapse" for="c-40024176">[-]</label><label class="expand" for="c-40024176">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and cutting it there<p>I think the idea behind calling it &quot;shaking&quot; is these branches and leaves that are already cut (inaccessible from the root), and just need a strong breeze to shake the tree and make them fall out.</div><br/><div id="40025509" class="c"><input type="checkbox" id="c-40025509" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024176">parent</a><span>|</span><a href="#40026281">next</a><span>|</span><label class="collapse" for="c-40025509">[-]</label><label class="expand" for="c-40025509">[1 more]</label></div><br/><div class="children"><div class="content">Those are called widowmakers, and shaking the tree rarely frees them.<p>We had an ice storm this year and there are loads of them all over town still.</div><br/></div></div></div></div><div id="40026281" class="c"><input type="checkbox" id="c-40026281" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40023541">root</a><span>|</span><a href="#40024112">parent</a><span>|</span><a href="#40024176">prev</a><span>|</span><a href="#40024001">next</a><span>|</span><label class="collapse" for="c-40026281">[-]</label><label class="expand" for="c-40026281">[1 more]</label></div><br/><div class="children"><div class="content">You think of orchard owners, but that&#x27;s not the image it conjures for me. I remember the neighborhood of my childhood. The fruit trees there were 90% decoration. Usually someone would pick one (1) fruit whenever they felt like getting one. Most of the fruits would never get picked at all. The ground would be full of overripe and rotting fruit, until someone could be bothered to clean it up.</div><br/></div></div></div></div></div></div><div id="40024001" class="c"><input type="checkbox" id="c-40024001" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#40023541">prev</a><span>|</span><a href="#40024093">next</a><span>|</span><label class="collapse" for="c-40024001">[-]</label><label class="expand" for="c-40024001">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If your language’s compiler toolchain can manage to produce useful Wasm in a file that is less than a handful of over-the-wire kilobytes, you can win.<p>I agree that tiny binaries will open up new use cases for wasm! And WasmGC definitely helps.<p>As more context, Java and Kotlin can do fairly well there today, around 2-3 K:<p><a href="https:&#x2F;&#x2F;developer.chrome.com&#x2F;blog&#x2F;wasmgc" rel="nofollow">https:&#x2F;&#x2F;developer.chrome.com&#x2F;blog&#x2F;wasmgc</a><p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;bashorov&#x2F;status&#x2F;1661377260274720770" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;bashorov&#x2F;status&#x2F;1661377260274720770</a><p>Though as Andy says, it depends which APIs you use - I am sure there are Java&#x2F;Kotlin APIs that would pull in large amounts of code, so you do need to be careful there. But these languages are already doing a lot better than C++ and Rust on code size, thanks to WasmGC (no need to bundle several K of memory management code, in particular).</div><br/><div id="40028089" class="c"><input type="checkbox" id="c-40028089" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40024001">parent</a><span>|</span><a href="#40024093">next</a><span>|</span><label class="collapse" for="c-40028089">[-]</label><label class="expand" for="c-40028089">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if wasmgc will help with rust as well. I can imagine it helping when handling javascript objects. And I think it could be used as an alternative, less efficient memory allocator.<p>But even so, the default rust allocator in wasm is probably fine in most cases. Once you start compiling for size, using wasm-opt and brotli compressing your wasm code, you can fit a massive amount of code in less than 100kb of downloaded content. And its a mistake to directly compare the cost of 100kb of wasm with 100kb of bundled javascript. Javascript is many times slower to parse and initialize. The download time is real, but actual time-to-first-paint is much better using 100kb of wasm vs 100kb of javascript.<p>But smaller is better. I&#x27;m quite excited for Java, Kotlin, C#, Python, Go and friends to all become viable languages for web applications. I&#x27;m curious what the resulting size of real applications will end up being. I suspect one of the biggest differences will be in how the frameworks are made. Virtual DOM diffing will always be more complex and slow than reactive component libraries like Svelte, Solidjs, Leptos (rust) and so on. Once wasmgc lands everywhere, I think which web framework you use will have a much bigger impact on performance than language.</div><br/></div></div></div></div><div id="40024093" class="c"><input type="checkbox" id="c-40024093" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#40024001">prev</a><span>|</span><a href="#40023625">next</a><span>|</span><label class="collapse" for="c-40024093">[-]</label><label class="expand" for="c-40024093">[8 more]</label></div><br/><div class="children"><div class="content">Why did tree shaking as a phrase come to exist when “dead code elimination” had been around forever?</div><br/><div id="40027313" class="c"><input type="checkbox" id="c-40027313" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40024093">parent</a><span>|</span><a href="#40024662">next</a><span>|</span><label class="collapse" for="c-40027313">[-]</label><label class="expand" for="c-40027313">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Dead code elimination&quot; usually refers to smaller-scale compiler optimizations where within a function, you&#x27;re discarding pieces of code that will never be reached.<p>&quot;Tree-shaking&quot; refers to a whole-program analysis where you discard entire modules and functions if they are never invoked.<p>They are conceptually the same, but a compiler author will likely have to implement them separately, so having two names helps.</div><br/><div id="40028871" class="c"><input type="checkbox" id="c-40028871" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40024093">root</a><span>|</span><a href="#40027313">parent</a><span>|</span><a href="#40024662">next</a><span>|</span><label class="collapse" for="c-40028871">[-]</label><label class="expand" for="c-40028871">[1 more]</label></div><br/><div class="children"><div class="content">Feels like it became “usually” only recently, cause before “web2.0” DCE always meant eliminating both codepaths and unreachable symbols.</div><br/></div></div></div></div><div id="40024662" class="c"><input type="checkbox" id="c-40024662" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40024093">parent</a><span>|</span><a href="#40027313">prev</a><span>|</span><a href="#40024800">next</a><span>|</span><label class="collapse" for="c-40024662">[-]</label><label class="expand" for="c-40024662">[1 more]</label></div><br/><div class="children"><div class="content">If it really originated in the Lisp context (as someone claimed here), it&#x27;s because it&#x27;s about as much about eliminating unnecessary data and metadata as it&#x27;s about executable code.</div><br/></div></div><div id="40024800" class="c"><input type="checkbox" id="c-40024800" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#40024093">parent</a><span>|</span><a href="#40024662">prev</a><span>|</span><a href="#40024959">next</a><span>|</span><label class="collapse" for="c-40024800">[-]</label><label class="expand" for="c-40024800">[1 more]</label></div><br/><div class="children"><div class="content">1) What words persist or become mainstream has little to do with how old they are. Tree shaking is evocative and is probably more appealing&#x2F;approachable to say than &quot;dead code elimination&quot;, so it became the more popular term.<p>2) I was curious about which term actually came first.<p>The first use of &quot;dead-code elimination&quot; I could find was this 1973 dissertation: <a href="https:&#x2F;&#x2F;research-repository.st-andrews.ac.uk&#x2F;bitstream&#x2F;handle&#x2F;10023&#x2F;22636&#x2F;NicholasAlexandrakisMScThesis1973_original_C.pdf?sequence=1" rel="nofollow">https:&#x2F;&#x2F;research-repository.st-andrews.ac.uk&#x2F;bitstream&#x2F;handl...</a><p>I couldn&#x27;t find any use of the term &quot;tree shaking&quot; or &quot;tree shaker&quot; in the realm of computing on Google Scholar (it was all citrus tree or other arboreal topics, weird). The earliest discussion I could find with the word is this on comp.lang.lisp: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;forum&#x2F;#!topic&#x2F;comp.lang.lisp&#x2F;pspFr1XByZk" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;forum&#x2F;#!topic&#x2F;comp.lang.lisp&#x2F;pspFr...</a></div><br/></div></div><div id="40024959" class="c"><input type="checkbox" id="c-40024959" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#40024093">parent</a><span>|</span><a href="#40024800">prev</a><span>|</span><a href="#40024196">next</a><span>|</span><label class="collapse" for="c-40024959">[-]</label><label class="expand" for="c-40024959">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s an evocative phrase, and sounds more colloquial than &quot;dead code elimination&quot;. not hard to see why it caught on.</div><br/></div></div><div id="40024196" class="c"><input type="checkbox" id="c-40024196" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#40024093">parent</a><span>|</span><a href="#40024959">prev</a><span>|</span><a href="#40025619">next</a><span>|</span><label class="collapse" for="c-40024196">[-]</label><label class="expand" for="c-40024196">[1 more]</label></div><br/><div class="children"><div class="content">why did &quot;dead code elimination&quot; come to exist when dead&#x2F;dying trees have existed for millions of years?</div><br/></div></div><div id="40025619" class="c"><input type="checkbox" id="c-40025619" checked=""/><div class="controls bullet"><span class="by">gardenhedge</span><span>|</span><a href="#40024093">parent</a><span>|</span><a href="#40024196">prev</a><span>|</span><a href="#40023625">next</a><span>|</span><label class="collapse" for="c-40025619">[-]</label><label class="expand" for="c-40025619">[1 more]</label></div><br/><div class="children"><div class="content">I like dead code elimination much better.</div><br/></div></div></div></div><div id="40023625" class="c"><input type="checkbox" id="c-40023625" checked=""/><div class="controls bullet"><span class="by">ElectricSpoon</span><span>|</span><a href="#40024093">prev</a><span>|</span><a href="#40024843">next</a><span>|</span><label class="collapse" for="c-40023625">[-]</label><label class="expand" for="c-40023625">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Wasm makes it thinkable to do DOM programming in languages other than JavaScript<p>Does it really? AFAIK, if I want to do any kind of DOM manipulation in say, rust, I need bindings that will basically serialize calls to be done on the JS side. So with the current incarnation of wasm, I believe you&#x27;re still stuck with JS.</div><br/><div id="40023692" class="c"><input type="checkbox" id="c-40023692" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#40023625">parent</a><span>|</span><a href="#40028032">next</a><span>|</span><label class="collapse" for="c-40023692">[-]</label><label class="expand" for="c-40023692">[4 more]</label></div><br/><div class="children"><div class="content">Important to include the preceding &quot;With GC,&quot;<p>In theory you can import DOM functions from runtime &amp; call with references to dom objects now, bypassing JS to call directly into runtime (I say in theory because I&#x27;m not in the know whether this is actually possible, but GC at least brings prerequisite mechanisms to get to that point)</div><br/><div id="40024110" class="c"><input type="checkbox" id="c-40024110" checked=""/><div class="controls bullet"><span class="by">posix86</span><span>|</span><a href="#40023625">root</a><span>|</span><a href="#40023692">parent</a><span>|</span><a href="#40028032">next</a><span>|</span><label class="collapse" for="c-40024110">[-]</label><label class="expand" for="c-40024110">[3 more]</label></div><br/><div class="children"><div class="content">How does GC help with that?</div><br/><div id="40024167" class="c"><input type="checkbox" id="c-40024167" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#40023625">root</a><span>|</span><a href="#40024110">parent</a><span>|</span><a href="#40024200">next</a><span>|</span><label class="collapse" for="c-40024167">[-]</label><label class="expand" for="c-40024167">[1 more]</label></div><br/><div class="children"><div class="content">GC feature in wasm extends to having opaque references outside linear memory (which may reference objects controlled by host system&#x27;s gc) avoiding need for js caller to handle resource being freed by wasm code with a pool or something keyed by handles (integers) passed to wasm</div><br/></div></div><div id="40024200" class="c"><input type="checkbox" id="c-40024200" checked=""/><div class="controls bullet"><span class="by">SpaghettiCthulu</span><span>|</span><a href="#40023625">root</a><span>|</span><a href="#40024110">parent</a><span>|</span><a href="#40024167">prev</a><span>|</span><a href="#40028032">next</a><span>|</span><label class="collapse" for="c-40024200">[-]</label><label class="expand" for="c-40024200">[1 more]</label></div><br/><div class="children"><div class="content">I think it would enable WASM code to hold references to DOM objects that have been designed around garbage collection.</div><br/></div></div></div></div></div></div><div id="40028032" class="c"><input type="checkbox" id="c-40028032" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40023625">parent</a><span>|</span><a href="#40023692">prev</a><span>|</span><a href="#40024843">next</a><span>|</span><label class="collapse" for="c-40028032">[-]</label><label class="expand" for="c-40028032">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been playing around with leptos for rust lately - which is a super fast framework for doing web frontend work with rust via wasm. It seems fine, honestly. Basically the same as solidjs:<p><pre><code>    #[component]
    fn App() -&gt; impl IntoView {
        let (count, set_count) = create_signal(0);
        view! {
            &lt;button on:click=move |_| { set_count(3); }&gt;
                &quot;Click me: &quot;{move || count()}
            &lt;&#x2F;button&gt;
        }
    }
</code></pre>
There&#x27;s some extra size overhead from wasm compared to javascript, but its honestly not that bad. After wasm-opt and brotli compression, the wasm bundle for this counter app is 37kb. So its in the same general ballpark as react, but much faster once its up and running.<p>I haven&#x27;t tried doing direct DOM manipulation with it. But for general components it seems great.</div><br/></div></div></div></div><div id="40024843" class="c"><input type="checkbox" id="c-40024843" checked=""/><div class="controls bullet"><span class="by">dwoldrich</span><span>|</span><a href="#40023625">prev</a><span>|</span><a href="#40029304">next</a><span>|</span><label class="collapse" for="c-40024843">[-]</label><label class="expand" for="c-40024843">[3 more]</label></div><br/><div class="children"><div class="content">My philosophy is to work hard at optimizing my javascript with algorithms and design simplifications for size&#x2F;performance to make room  (in bundle size and CPU) for parts of my code that require brute force compute to solve.<p>In my ClubCompy project, I use WASM to implement a FAT filesystem atop local storage, which has proven to be very computationally expensive.  And, I plan to use WASM for pixel-perfect sprite collision detection when I reintroduce that feature later this year.<p>My first implementation of collision detection was in plain javascript. With 256 sprites on the screen all colliding with one another, the framerate dropped to below 1fps.  I believe I can get that done on a worker thread basically for free and have no performance impacts.</div><br/><div id="40026462" class="c"><input type="checkbox" id="c-40026462" checked=""/><div class="controls bullet"><span class="by">mrob</span><span>|</span><a href="#40024843">parent</a><span>|</span><a href="#40025142">next</a><span>|</span><label class="collapse" for="c-40026462">[-]</label><label class="expand" for="c-40026462">[1 more]</label></div><br/><div class="children"><div class="content">&gt;pixel-perfect sprite collision detection<p>This is something that sounds like a good idea when you first hear it, but feels unpleasant when you actually play it. Most 2D games use rectangular collision hitboxes for good reason: it&#x27;s easier for the player to predict if sprites will collide or not. With pixel-perfect collisions, the same movement will collide or not depending on the phase of the animation cycles. It feels bad to fail a movement that always worked before just because the animations happened to line up poorly. And pixel perfect isn&#x27;t even realistic in many cases; small details on sprites can represent things like cloth or hair that in reality wouldn&#x27;t cause a hard collision. And sprites often move multiple pixels per frame, so colliding individual pixels increases the chance of them clipping through each other. Simple, predictable collision detection is generally best.</div><br/></div></div><div id="40025142" class="c"><input type="checkbox" id="c-40025142" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#40024843">parent</a><span>|</span><a href="#40026462">prev</a><span>|</span><a href="#40029304">next</a><span>|</span><label class="collapse" for="c-40025142">[-]</label><label class="expand" for="c-40025142">[1 more]</label></div><br/><div class="children"><div class="content">1fps is the kind of frame rate you should be getting with 20000 collisions, not 256. Your algorithm is the bottleneck, here, not the programming language.<p>You say &quot;pixel-perfect&quot;. If you have enough spare memory, one simple algorithm would be: render an offscreen canvas of the whole arena, draw each sprite as a stencil in a different colour, and test against that. Linear time, and no need to segment anything. (You might need to use the high bits of the canvas, though: I don&#x27;t know how anti-fingerprinting measures work, but I expect they replace the low bits of a canvas&#x27; data with noise.)</div><br/></div></div></div></div><div id="40029304" class="c"><input type="checkbox" id="c-40029304" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#40024843">prev</a><span>|</span><a href="#40023854">next</a><span>|</span><label class="collapse" for="c-40029304">[-]</label><label class="expand" for="c-40029304">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If your language’s compiler toolchain can manage to produce useful Wasm in a file that is less than a handful of over-the-wire kilobytes, you can win.<p>Zig is perfect for this.<p>Personally, I don&#x27;t think this is an important factor if Wasm file size is less than 100K. It does matter if the file size is over MB.<p>Builtin GC is only important for some apps, not all. It is best to make your web app GC-free.<p>The most important factor for apps using Wasm to succeed is still performance benefit.</div><br/></div></div><div id="40023854" class="c"><input type="checkbox" id="c-40023854" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#40029304">prev</a><span>|</span><a href="#40027839">next</a><span>|</span><label class="collapse" for="c-40023854">[-]</label><label class="expand" for="c-40023854">[24 more]</label></div><br/><div class="children"><div class="content">This article is very correct: Wasm has a code size problem. This is a problem in browsers because all that code has to be downloaded to start the site. It&#x27;s also a problem for serverless architectures, where code is often loaded from cold storage to a specific server on-demand while a client waits.<p>Tree-shaking might help, but I feel like it&#x27;s only an incremental optimization. Fundamentally the reason Wasm programs are so bloated is because they have to bring their whole language runtimes and standard libraries with them. In contrast, with JavaScript, the implementation and basic libraries are provided by the browser. But obviously the browser can be expected to have language runtimes for every language pre-loaded...<p>... or... could it?<p>I think we need to consider another approach as well: Shared libraries and dynamic linking.<p>WebAssembly supports dynamic linking. Multiple Wasm modules can be loaded at the same time and call each other. However, many Wasm toolchains do not attempt to support it. Instead, they are often design to statically link an entire program (plus language runtime) into a single gargantuan module.<p>Pyodide (CPython on Wasm) is a counter-example. It is designed for dynamic linking today. This is precisely why Cloudflare Workers (a serverless platform) was recently able to add first-class support for Python[0]. (I&#x27;m the tech lead for the overall Workers platform.) A single compiled copy of the Pyodide runtime is shared by all Workers running on the same machine, so it doesn&#x27;t have to be separately loaded for each one.<p>If dynamic linking were more widely supported, then we could start thinking about an architecture where browsers have various popular language runtimes (and perhaps even popular libraries) preloaded, so that all web pages requiring that runtime can share the same (read-only) copy of that code. These runtimes would still run inside the sandbox, so there&#x27;s no need for the browser to trust them, just make them available. This way we can actually have browsers that have &quot;built-in&quot; support for languages beyond JavaScript -- without the browser maintainers having to fully vet or think about those language implementations.<p>[0] <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;python-workers" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;python-workers</a></div><br/><div id="40023963" class="c"><input type="checkbox" id="c-40023963" checked=""/><div class="controls bullet"><span class="by">azornathogron</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40024170">next</a><span>|</span><label class="collapse" for="c-40023963">[-]</label><label class="expand" for="c-40023963">[6 more]</label></div><br/><div class="children"><div class="content">&gt; browsers have various popular language runtimes (and perhaps even popular libraries) preloaded, so that all web pages requiring that runtime can share the same (read-only) copy of that code.<p>That sounds a lot like the idea from some years past that commonly used JavaScript frameworks would be served from a few common CDNs and would be widely enough used to be almost always in cache in the browser, and therefore won&#x27;t need to actually be downloaded for most pages (hence, the size of the js frameworks shouldn&#x27;t matter so much)<p>I&#x27;m no expert but from what I understand, that didn&#x27;t really work out very well. A combination of too many different versions of these libraries (so each individual version is actually not <i>that</i> widely used), and later privacy concerns that moved browsers toward partitioning cache by site or origin. Maybe other reasons too.<p>Of course, you didn&#x27;t mention caching and perhaps that&#x27;s not what you had in mind, but I think it&#x27;s a tricky problem (a social problem more than a technical one): do you add baseline browser support for increasing numbers of language runtimes? That raises the bar for new browsers even further and anyway you&#x27;ll never support all the libraries and runtimes people want. Do you let people bring their own and rely on caching? Then how do you avoid the problems previously encountered with caching JS libs?</div><br/><div id="40024161" class="c"><input type="checkbox" id="c-40024161" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023963">parent</a><span>|</span><a href="#40026407">next</a><span>|</span><label class="collapse" for="c-40024161">[-]</label><label class="expand" for="c-40024161">[4 more]</label></div><br/><div class="children"><div class="content">These are good questions and I think there&#x27;s more than one answer that&#x27;s worth exploring.<p>I think that the privacy problems caused by shared caches could be solved, without simply prohibiting them altogether. Like, what if you only use the shared cache after N different web sites have requested the same module?<p>But if we really can&#x27;t get around that problem, then I think another approach worth exploring is for there to be some sort of curated repository somewhere of Wasm modules that are popular enough that browsers should pre-download them. Then the existence of the module in a user&#x27;s browser doesn&#x27;t say anything about what sites they have been to.<p>Versioning is a problem, yes. If every incremental minor release of a language runtime is considered a separate version then it may be rare for any two web sites to share the same version. The way the browser solves this for JavaScript is to run all sites on the latest version of the JS runtime, and fully commit to backwards compatibility. If particular language runtimes could also commit to backwards compatibility at the ABI level, then you only need to pre-download one runtime per language. I realize this may be a big cultural change for some of them. It may be more palatable to say that a language is allowed to do occasional major releases with breaking changes, but is expected to keep minor releases backwards-compatible, so that there are only a couple different runtime version needed. And once a version gets too old, it falls out of the preload set -- websites which can&#x27;t be bothered to stay up to date get slower, but that&#x27;s on them.<p>This is definitely the kind of thing where there&#x27;s no answer that is technically ideal and people are going to argue a lot about it. But I think if we want to have the web platform really support more than just JavaScript, we need to figure this out.</div><br/><div id="40025182" class="c"><input type="checkbox" id="c-40025182" checked=""/><div class="controls bullet"><span class="by">thenameipicked</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024161">parent</a><span>|</span><a href="#40025294">next</a><span>|</span><label class="collapse" for="c-40025182">[-]</label><label class="expand" for="c-40025182">[1 more]</label></div><br/><div class="children"><div class="content">I think a better model would be for the site itself to provide the modules, but the browser will hash and cache them for the next site that may want to use the same module.<p>This way, there&#x27;s no central authority that determines what is common enough.<p>This model does not allow for versioning.  For this model, it would be risky to allow it (one website could provide a malicious model that infects the next site you visit).</div><br/></div></div><div id="40025294" class="c"><input type="checkbox" id="c-40025294" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024161">parent</a><span>|</span><a href="#40025182">prev</a><span>|</span><a href="#40026407">next</a><span>|</span><label class="collapse" for="c-40025294">[-]</label><label class="expand" for="c-40025294">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Like, what if you only use the shared cache after N different web sites have requested the same module?</i><p>That would still let websites perform timing attacks to deanonymise people. There&#x27;s no way to verify that &quot;N different websites&quot; isn&#x27;t just the same website with N different names.<p>Though, we could promote certain domains as CDNs, exempt from the no-shared-cache rules: so long as we added artificial delay when it &quot;would have&quot; been downloaded, that&#x27;d be just as safe. We&#x27;re already doing this with domains (HSTS preload list), so why not CDNs?<p>Web browser developers seem to labour under the assumption that anyone will use the HTML5 features they&#x27;ve so lovingly hand-crafted. Who wants something as complicated as:<p><pre><code>  &lt;details&gt;
    &lt;summary&gt;Eat me&lt;&#x2F;summary&gt;
    &lt;p&gt;Lorem ipsum and so on and so forth…&lt;&#x2F;p&gt;
  &lt;&#x2F;details&gt;
</code></pre>
when we have the stunning simplicity of:<p><pre><code>  &lt;div class=&quot;MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters css-1aj41gs&quot;&gt;
    &lt;div class=&quot;MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters css-1oqimao&quot; tabindex=&quot;0&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;panel-content&quot; id=&quot;panel-header&quot;&gt;
      &lt;div class=&quot;MuiAccordionSummary-content MuiAccordionSummary-contentGutters css-l0jafl&quot;&gt;Eat me&lt;&#x2F;div&gt;
      &lt;div class=&quot;MuiAccordionSummary-expandIconWrapper css-1fx8m19&quot;&gt;
        &lt;svg class=&quot;MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv&quot; focusable=&quot;false&quot; aria-hidden=&quot;true&quot; viewBox=&quot;0 0 24 24&quot; data-testid=&quot;ExpandMoreIcon&quot;&gt;
          &lt;path d=&quot;M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z&quot;&gt;&lt;&#x2F;path&gt;
        &lt;&#x2F;svg&gt;
      &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden css-a0y2e3&quot; style=&quot;min-height:0px&quot;&gt;
      &lt;div class=&quot;MuiCollapse-wrapper MuiCollapse-vertical css-hboir5&quot;&gt;
        &lt;div class=&quot;MuiCollapse-wrapperInner MuiCollapse-vertical css-8atqhb&quot;&gt;
          &lt;div aria-labelledby=&quot;panel-header&quot; id=&quot;panel-content&quot; role=&quot;region&quot; class=&quot;MuiAccordion-region&quot;&gt;
            &lt;div class=&quot;MuiAccordionDetails-root css-u7qq7e&quot;&gt;Lorem ipsum and so on and so forth…&lt;&#x2F;div&gt;
          &lt;&#x2F;div&gt;
        &lt;&#x2F;div&gt;
      &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  &lt;&#x2F;div&gt;
</code></pre>
Example modified from <a href="https:&#x2F;&#x2F;mui.com&#x2F;material-ui&#x2F;react-accordion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mui.com&#x2F;material-ui&#x2F;react-accordion&#x2F;</a>. Though, in fairness, the developer UX is much better:<p><pre><code>  &lt;Accordion&gt;
    &lt;AccordionSummary id=&quot;panel-header&quot; aria-controls=&quot;panel-content&quot;&gt;
      Eat me
    &lt;&#x2F;AccordionSummary&gt;
    &lt;AccordionDetails&gt;
      Lorem ipsum and so on and so forth…
    &lt;&#x2F;AccordionDetails&gt;
  &lt;&#x2F;Accordion&gt;
</code></pre>
Maybe the problem isn&#x27;t the libraries. Maybe the problem is us.</div><br/><div id="40026609" class="c"><input type="checkbox" id="c-40026609" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40025294">parent</a><span>|</span><a href="#40026407">next</a><span>|</span><label class="collapse" for="c-40026609">[-]</label><label class="expand" for="c-40026609">[1 more]</label></div><br/><div class="children"><div class="content">The problem is the libraries. Browsers are still mostly incapable of delivering usable workable building blocks especially in the realm of UI. <a href="https:&#x2F;&#x2F;open-ui.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;open-ui.org&#x2F;</a> is a good start, but it will be a while before we see major pay offs.<p>Another reason is that the DOM is horrendously bad at building anything UI-related. Laying out static text and images? Sure, barely. Providing actual building blocks for a UI? Emphatically no.<p>And that&#x27;s the reason why devs keep reinventing controls. Because while details&#x2F;summary is good, it&#x27;s extremely limited, does not provide all the needed features, and is impossible to properly extend.</div><br/></div></div></div></div></div></div><div id="40026407" class="c"><input type="checkbox" id="c-40026407" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023963">parent</a><span>|</span><a href="#40024161">prev</a><span>|</span><a href="#40024170">next</a><span>|</span><label class="collapse" for="c-40026407">[-]</label><label class="expand" for="c-40026407">[1 more]</label></div><br/><div class="children"><div class="content">Maybe not so tricky.<p>What&#x27;s wrong with having package management for dynamics libs built into the browser, using signed packages?<p>Any dynamic lib that is referenced, say &#x2F;glibc.6.0.2, is downloaded only once, ever.<p>This is a problem Linux distributions more or less solved ages ago for distribution packages.<p>Why does a new, more complicated and over-engineered thing need to be invented when a tried and tested mechanism exists?</div><br/></div></div></div></div><div id="40024170" class="c"><input type="checkbox" id="c-40024170" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40023963">prev</a><span>|</span><a href="#40024116">next</a><span>|</span><label class="collapse" for="c-40024170">[-]</label><label class="expand" for="c-40024170">[1 more]</label></div><br/><div class="children"><div class="content">It seems like limited dynamic linking support could go a long way.<p>For example, there could be a Go shared library that includes the runtime and core parts of the standard library that many programs use. It would decrease the size of all Go programs, without needing to have dynamic library support within an app. The language runtime might not need heavy optimization for space. It’s already loaded, and as long as any program uses a function, it’s not wasted space.<p>It changes the cost model for optimizing programs in that language for space. Since included standard library functions are free (if you’re using the language at all), you might as well use them.<p>Though, the problem reoccurs with commonly used libraries and frameworks. You’d also want Cloudflare’s standard library for Go to be shared when running on Cloudflare.<p>One problem with this model is that languages don’t evolve in lockstep with the runtime. Either there would be limited support for different versions of a language, or the shared libraries available would pile up over time, resulting in limited sharing between apps. JavaScript has the “you don’t get a choice” versioning model, which requires strong backward compatibility and sometimes polyfills. It might not be as suitable for other languages.<p>When a runtime really wants to cut down on space, it can be done by limiting plugin diversity. Though there are complaints, “you must use JavaScript” worked out pretty well for browsers.<p>Maybe we don’t need a lot of different WebAssembly-based languages? It’s a tower of babel situation. Diversity has costs.</div><br/></div></div><div id="40024116" class="c"><input type="checkbox" id="c-40024116" checked=""/><div class="controls bullet"><span class="by">screcth</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40024170">prev</a><span>|</span><a href="#40024761">next</a><span>|</span><label class="collapse" for="c-40024116">[-]</label><label class="expand" for="c-40024116">[6 more]</label></div><br/><div class="children"><div class="content">Could it be possible to do &quot;profile guided tree-shaking&quot; to build a small module with all the code that&#x27;s necessary for the application and pull-in less used functionality on-demand using dynamic linking?<p>If tree-shaking was done based on production information it may be possible to prune a lot of dead&#x2F;almost-dead code without having to implement sophisticated static analysis algorithms.</div><br/><div id="40024744" class="c"><input type="checkbox" id="c-40024744" checked=""/><div class="controls bullet"><span class="by">nurple</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024116">parent</a><span>|</span><a href="#40024725">next</a><span>|</span><label class="collapse" for="c-40024744">[-]</label><label class="expand" for="c-40024744">[1 more]</label></div><br/><div class="children"><div class="content">A lazy chunked delivery strategy like used in the k8s stargz-snapshotter[0] project could be effective here, where it only pulls chunks as needed, but it would probably require wasm platform changes.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;containerd&#x2F;stargz-snapshotter">https:&#x2F;&#x2F;github.com&#x2F;containerd&#x2F;stargz-snapshotter</a></div><br/></div></div><div id="40024725" class="c"><input type="checkbox" id="c-40024725" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024116">parent</a><span>|</span><a href="#40024744">prev</a><span>|</span><a href="#40027029">next</a><span>|</span><label class="collapse" for="c-40024725">[-]</label><label class="expand" for="c-40024725">[3 more]</label></div><br/><div class="children"><div class="content">There is a substantial risk there unless you can hit all the edge cases and error conditions when profiling.  Even a good fuzzer can miss a very rare state.  Then when you hit it in real use there&#x27;s no code to handle it!<p>Profile-based optimization and JITting is plausible because the corner cases are still there, just not optimized.</div><br/><div id="40024932" class="c"><input type="checkbox" id="c-40024932" checked=""/><div class="controls bullet"><span class="by">screcth</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024725">parent</a><span>|</span><a href="#40027093">next</a><span>|</span><label class="collapse" for="c-40024932">[-]</label><label class="expand" for="c-40024932">[1 more]</label></div><br/><div class="children"><div class="content">I completely agree, that&#x27;s why in that case you could download the missing code from the server and load it using dynamic linking.<p>The server would then mark it as reachable so it&#x27;s delivered as part of the main bundle next time.<p>I would expect the bundle to converge quickly to the set of functions that are actually reachable.<p>Aditionally, it&#x27;s very likely that the sets of reachable code of two versions of the same app have significant overlap, so the information collected for version N could be used as a starting point for N+1, and so on.</div><br/></div></div><div id="40027093" class="c"><input type="checkbox" id="c-40027093" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024725">parent</a><span>|</span><a href="#40024932">prev</a><span>|</span><a href="#40027029">next</a><span>|</span><label class="collapse" for="c-40027093">[-]</label><label class="expand" for="c-40027093">[1 more]</label></div><br/><div class="children"><div class="content">&quot;less used functionality on-demand&quot; - so the code to handle the rare case remains available, on demand.</div><br/></div></div></div></div><div id="40027029" class="c"><input type="checkbox" id="c-40027029" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40024116">parent</a><span>|</span><a href="#40024725">prev</a><span>|</span><a href="#40024761">next</a><span>|</span><label class="collapse" for="c-40027029">[-]</label><label class="expand" for="c-40027029">[1 more]</label></div><br/><div class="children"><div class="content">I experimented with that for javascript: <a href="https:&#x2F;&#x2F;github.com&#x2F;avodonosov&#x2F;pocl">https:&#x2F;&#x2F;github.com&#x2F;avodonosov&#x2F;pocl</a></div><br/></div></div></div></div><div id="40024761" class="c"><input type="checkbox" id="c-40024761" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40024116">prev</a><span>|</span><a href="#40025341">next</a><span>|</span><label class="collapse" for="c-40024761">[-]</label><label class="expand" for="c-40024761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; we could start thinking about an architecture where browsers have various popular language runtimes (and perhaps even popular libraries) preloaded<p>that could potentially lead to hundreds of versions of runtimes downloaded in the browser, filling up the cache with binaries that might be used by 1 site each</div><br/></div></div><div id="40025341" class="c"><input type="checkbox" id="c-40025341" checked=""/><div class="controls bullet"><span class="by">jonnycomputer</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40024761">prev</a><span>|</span><a href="#40023890">next</a><span>|</span><label class="collapse" for="c-40025341">[-]</label><label class="expand" for="c-40025341">[2 more]</label></div><br/><div class="children"><div class="content">Lot I don&#x27;t know about how browsers are shipped, but it seems to me like browsers could easily get away with packing in a few languages and their STLs as part of their default installs. Python is what, 25MB? Would another couple hundred megs of disk space be such a big deal?</div><br/><div id="40025915" class="c"><input type="checkbox" id="c-40025915" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40025341">parent</a><span>|</span><a href="#40023890">next</a><span>|</span><label class="collapse" for="c-40025915">[-]</label><label class="expand" for="c-40025915">[1 more]</label></div><br/><div class="children"><div class="content">Possibly – if you can find a single version of Python that everybody will be happy with, forever.<p>Being able to cache runtimes and libraries like that across sites would be nice, though (but probably enables fingerprinting, so one Python runtime per origin it is).</div><br/></div></div></div></div><div id="40023890" class="c"><input type="checkbox" id="c-40023890" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40025341">prev</a><span>|</span><a href="#40023884">next</a><span>|</span><label class="collapse" for="c-40023890">[-]</label><label class="expand" for="c-40023890">[5 more]</label></div><br/><div class="children"><div class="content">Does browsers support wasm with dynamic linking?</div><br/><div id="40024827" class="c"><input type="checkbox" id="c-40024827" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023890">parent</a><span>|</span><a href="#40023908">next</a><span>|</span><label class="collapse" for="c-40024827">[-]</label><label class="expand" for="c-40024827">[1 more]</label></div><br/><div class="children"><div class="content">The way Emscripten does it, IIRC, doesn&#x27;t require any special browser support. The toolchain generates glue code in JavaScript to support calls between dynamically linked Wasm modules.</div><br/></div></div><div id="40023908" class="c"><input type="checkbox" id="c-40023908" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023890">parent</a><span>|</span><a href="#40024827">prev</a><span>|</span><a href="#40023884">next</a><span>|</span><label class="collapse" for="c-40023908">[-]</label><label class="expand" for="c-40023908">[3 more]</label></div><br/><div class="children"><div class="content">Yes.</div><br/><div id="40023925" class="c"><input type="checkbox" id="c-40023925" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023908">parent</a><span>|</span><a href="#40023884">next</a><span>|</span><label class="collapse" for="c-40023925">[-]</label><label class="expand" for="c-40023925">[2 more]</label></div><br/><div class="children"><div class="content">Do you happen to know where can I check out the cutoff version for each browser? <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;?search=wasm" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;?search=wasm</a> doesn&#x27;t  have it (or other things like WasmGC for that matter)</div><br/><div id="40024043" class="c"><input type="checkbox" id="c-40024043" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023925">parent</a><span>|</span><a href="#40023884">next</a><span>|</span><label class="collapse" for="c-40024043">[-]</label><label class="expand" for="c-40024043">[1 more]</label></div><br/><div class="children"><div class="content">I believe dynamic linking has been a core feature of WebAssembly from the beginning. You have always been able to load multiple Wasm modules in the same isolate and make them call each other.<p>(But, language toolchains have to actually be designed to use this feature. Most aren&#x27;t.)</div><br/></div></div></div></div></div></div></div></div><div id="40023884" class="c"><input type="checkbox" id="c-40023884" checked=""/><div class="controls bullet"><span class="by">beepbooptheory</span><span>|</span><a href="#40023854">parent</a><span>|</span><a href="#40023890">prev</a><span>|</span><a href="#40027839">next</a><span>|</span><label class="collapse" for="c-40023884">[-]</label><label class="expand" for="c-40023884">[2 more]</label></div><br/><div class="children"><div class="content">I think I agree overall, just want to point out that with Wasm, you still end up using a fair bit of the built-into-browser js to accomplish things not purely computational. Especially in this context with Hoot [1], where things like appendChild are external functions you call inside the scheme. One could theoretically do this for much of the js standard library in any kind of wasm context.<p>1. <a href="https:&#x2F;&#x2F;spritely.institute&#x2F;news&#x2F;building-interactive-web-pages-with-guile-hoot.html" rel="nofollow">https:&#x2F;&#x2F;spritely.institute&#x2F;news&#x2F;building-interactive-web-pag...</a></div><br/><div id="40024025" class="c"><input type="checkbox" id="c-40024025" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#40023854">root</a><span>|</span><a href="#40023884">parent</a><span>|</span><a href="#40027839">next</a><span>|</span><label class="collapse" for="c-40024025">[-]</label><label class="expand" for="c-40024025">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, I&#x2F;O APIs (anything that talks to the outside world) are another sore point for WebAssembly, as browsers do not currently expose any particular APIs directly to Wasm, only to JavaScript. So Wasm has to make calls to a JavaScript middleman layer to use those APIs.<p>But browsers are understandably hesitant to create a whole parallel API surface designed specifically for Wasm callers. That&#x27;s a lot of work.<p>I am not totally convinced that this is a real problem, vs. just something that makes people feel bad. Like, if you are coding Rust, the idea that all your &quot;system calls&quot; are calling into a layer of JavaScript feels disgusting. But is it a real problem? Most of these calls are probably not so performance sensitive that this FFI layer matters that much.<p>If it is a real problem, I&#x27;d guess the answer is for browsers to come up with a more efficient way to expose WebIDL-defined APIs to Wasm, but without reinventing any individual APIs. Being derived from WebIDL, they are still going to have JS idioms in their design, but maybe we can at least skip invoking actual JavaScript.</div><br/></div></div></div></div></div></div><div id="40027839" class="c"><input type="checkbox" id="c-40027839" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#40023854">prev</a><span>|</span><a href="#40023681">next</a><span>|</span><label class="collapse" for="c-40027839">[-]</label><label class="expand" for="c-40027839">[1 more]</label></div><br/><div class="children"><div class="content">Two other examples of apps that use wasm.<p>Google Maps uses wasm so if you need an app lots of people use that uses wasm then that&#x27;s pretty big.<p>Google Earth is now entirely wasm but Google Earth is not that popular (<a href="https:&#x2F;&#x2F;earth.google.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;earth.google.com&#x2F;</a>)</div><br/></div></div><div id="40023681" class="c"><input type="checkbox" id="c-40023681" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#40027839">prev</a><span>|</span><a href="#40025249">next</a><span>|</span><label class="collapse" for="c-40023681">[-]</label><label class="expand" for="c-40023681">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Wasm makes it thinkable to do DOM programming in languages other than JavaScript<p>Can&#x27;t help but picking this out for correction - people have been doing it for a long time in compile-to-JS languages - eg ClojureScript, TypeScript, ReasonML and many others.<p>And people have also been compiling native-ish stuff for the web a long time before Wasm through asm.js &amp; emscripten, like C and through that C-based languages such as Python: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asm.js#Adoption" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asm.js#Adoption</a></div><br/></div></div><div id="40025249" class="c"><input type="checkbox" id="c-40025249" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#40023681">prev</a><span>|</span><a href="#40026263">next</a><span>|</span><label class="collapse" for="c-40025249">[-]</label><label class="expand" for="c-40025249">[2 more]</label></div><br/><div class="children"><div class="content">Another example - flutter can tree shake unused icons&#x2F;glyphs from fonts -<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;FlutterDev&#x2F;comments&#x2F;f4h3l9&#x2F;tree_shake_icon_fonts_since_v1151&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;FlutterDev&#x2F;comments&#x2F;f4h3l9&#x2F;tree_sha...</a></div><br/><div id="40025937" class="c"><input type="checkbox" id="c-40025937" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40025249">parent</a><span>|</span><a href="#40026263">next</a><span>|</span><label class="collapse" for="c-40025937">[-]</label><label class="expand" for="c-40025937">[1 more]</label></div><br/><div class="children"><div class="content">PDFs can do the same thing for embedded fonts, I believe.</div><br/></div></div></div></div><div id="40026263" class="c"><input type="checkbox" id="c-40026263" checked=""/><div class="controls bullet"><span class="by">low_tech_punk</span><span>|</span><a href="#40025249">prev</a><span>|</span><a href="#40027140">next</a><span>|</span><label class="collapse" for="c-40026263">[-]</label><label class="expand" for="c-40026263">[1 more]</label></div><br/><div class="children"><div class="content">A microcosm of the wasm issue was captured in this thread:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;isomorphic-git&#x2F;isomorphic-git&#x2F;issues&#x2F;268">https:&#x2F;&#x2F;github.com&#x2F;isomorphic-git&#x2F;isomorphic-git&#x2F;issues&#x2F;268</a><p>The community had good reasoning around implementing a web based git in JavaScript from scratch instead of compiling libgit2 to wasm.</div><br/></div></div><div id="40027140" class="c"><input type="checkbox" id="c-40027140" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#40026263">prev</a><span>|</span><a href="#40025597">next</a><span>|</span><label class="collapse" for="c-40027140">[-]</label><label class="expand" for="c-40027140">[1 more]</label></div><br/><div class="children"><div class="content">A possible alternative to tree shaking: <a href="https:&#x2F;&#x2F;github.com&#x2F;avodonosov&#x2F;pocl">https:&#x2F;&#x2F;github.com&#x2F;avodonosov&#x2F;pocl</a></div><br/></div></div><div id="40025597" class="c"><input type="checkbox" id="c-40025597" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#40027140">prev</a><span>|</span><a href="#40023761">next</a><span>|</span><label class="collapse" for="c-40025597">[-]</label><label class="expand" for="c-40025597">[1 more]</label></div><br/><div class="children"><div class="content">It feels like OCaml is well positioned for this kind of flow analysis to perform aggressive tree shaking. With GC support in WASM OCaml should produce tiny binaries.</div><br/></div></div><div id="40023761" class="c"><input type="checkbox" id="c-40023761" checked=""/><div class="controls bullet"><span class="by">mindslight</span><span>|</span><a href="#40025597">prev</a><span>|</span><a href="#40023817">next</a><span>|</span><label class="collapse" for="c-40023761">[-]</label><label class="expand" for="c-40023761">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the tree shaking metaphor based on how some fruit trees are harvested? When you shake the tree, the ripe fruit falls off. It&#x27;s not the best metaphor in that with fruit harvesting you want the fruit, whereas when storing a serialized image you discard what falls off, but alas.</div><br/><div id="40027227" class="c"><input type="checkbox" id="c-40027227" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#40023761">parent</a><span>|</span><a href="#40023817">next</a><span>|</span><label class="collapse" for="c-40027227">[-]</label><label class="expand" for="c-40027227">[1 more]</label></div><br/><div class="children"><div class="content">Nuts are typically harvesting by shaking. Fruit is usually picked by hand since it&#x27;s more delicate and will get bruised if it falls too far.<p>The shaking is quite violent, but it doesn&#x27;t hurt the tree.</div><br/></div></div></div></div><div id="40023817" class="c"><input type="checkbox" id="c-40023817" checked=""/><div class="controls bullet"><span class="by">internetter</span><span>|</span><a href="#40023761">prev</a><span>|</span><a href="#40024349">next</a><span>|</span><label class="collapse" for="c-40023817">[-]</label><label class="expand" for="c-40023817">[1 more]</label></div><br/><div class="children"><div class="content">The big utility of WASM for me, like OP hints at, is bringing things that would be infeasible to port to the web to it, like, say <a href="https:&#x2F;&#x2F;pgaskin.net&#x2F;kepubify&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pgaskin.net&#x2F;kepubify&#x2F;</a> and other conversion tools (eg ffmpeg-wasm). Much preferable to downloading something or uploading a file to some random person’s server</div><br/></div></div><div id="40024349" class="c"><input type="checkbox" id="c-40024349" checked=""/><div class="controls bullet"><span class="by">AtNightWeCode</span><span>|</span><a href="#40023817">prev</a><span>|</span><a href="#40023806">next</a><span>|</span><label class="collapse" for="c-40024349">[-]</label><label class="expand" for="c-40024349">[3 more]</label></div><br/><div class="children"><div class="content">I have Blazor apps running on Cloudflare pages. They download fast and the performance is great. The load time is terrible though. I think it is unsolvable with .NET. I think the core issue is how everything is entangled by design in oo langs.<p>Also, the amount of money put into js is hard to compete with. Then to also have copy&#x2F;paste as a lang feature in js is like cheating.<p>Third. With Blazor at least you still need js and skills in that area. I think this is my main issue.</div><br/><div id="40024877" class="c"><input type="checkbox" id="c-40024877" checked=""/><div class="controls bullet"><span class="by">mdasen</span><span>|</span><a href="#40024349">parent</a><span>|</span><a href="#40026501">next</a><span>|</span><label class="collapse" for="c-40024877">[-]</label><label class="expand" for="c-40024877">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the core issue is how everything is entangled by design in oo langs.<p>It&#x27;s not an issue with object orientation. An issue is that languages of that era often relied on reflection for many use cases. People are actually working hard to rid large parts of .NET from these use cases and mark them as safe for eliminating unused code.<p>When there&#x27;s the possibility of using reflection to call a method, you don&#x27;t really know what you can safely eliminate. It might look like nothing is calling `Foo.Bar()`, but what if someone has done `Reflection.getClass(someClass).runMethod(someVar)` and those variables have been set to &quot;Foo&quot; and &quot;Bar&quot;?<p>For example, Dart doesn&#x27;t allow reflection with precompiled apps because it allows them to safely eliminate unused code (<a href="https:&#x2F;&#x2F;docs.flutter.dev&#x2F;resources&#x2F;faq#does-flutter-come-with-a-reflection-mirrors-system" rel="nofollow">https:&#x2F;&#x2F;docs.flutter.dev&#x2F;resources&#x2F;faq#does-flutter-come-wit...</a>). Dart is an object oriented language, but it has eschewed runtime code generation and runtime reflection for compile time code generation.<p>.NET is also headed in this direction, but that doesn&#x27;t happen overnight.<p>However, as others have pointed out, part of the issue will be that non-JS languages will still need to ship implementations of standard library stuff that&#x27;s included in the JS runtime in the browser (at least the pieces of the standard library you&#x27;re using post-tree-shaking).</div><br/></div></div><div id="40026501" class="c"><input type="checkbox" id="c-40026501" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40024349">parent</a><span>|</span><a href="#40024877">prev</a><span>|</span><a href="#40023806">next</a><span>|</span><label class="collapse" for="c-40026501">[-]</label><label class="expand" for="c-40026501">[1 more]</label></div><br/><div class="children"><div class="content">Blazor...is not great at this. Currently, the packaging model does not do the justice to capabilities of .NET trimming because of the limitations of how the WASM is currently packaged on top of Mono. If you want to see how well it can actually trim (which everyone seems to like calling tree-shaking, even though it&#x27;s not exactly right), it is better to try out building regular applications with AOT - they produce small binaries.<p>The experimental support in runtimelab for NativeAOT-LLVM targeting WASM provides much smaller bundle sizes and much better performance but given that it still is under dotnet&#x2F;runtimelab rather than dotnet&#x2F;runtime, I don&#x27;t know when it will be available.</div><br/></div></div></div></div><div id="40023806" class="c"><input type="checkbox" id="c-40023806" checked=""/><div class="controls bullet"><span class="by">hiddencost</span><span>|</span><a href="#40024349">prev</a><span>|</span><a href="#40023752">next</a><span>|</span><label class="collapse" for="c-40023806">[-]</label><label class="expand" for="c-40023806">[1 more]</label></div><br/><div class="children"><div class="content">As someone who regularly shakes his fiddle leaf fig to encourage growth, title confused me.</div><br/></div></div><div id="40023752" class="c"><input type="checkbox" id="c-40023752" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#40023806">prev</a><span>|</span><a href="#40023862">next</a><span>|</span><label class="collapse" for="c-40023752">[-]</label><label class="expand" for="c-40023752">[8 more]</label></div><br/><div class="children"><div class="content">Maybe off-topic.<p>But can&#x27;t you use WASM to create GUI&#x27;s like Photoshop, with no JavaScript or DOM?<p>Isn&#x27;t the bigger goal of GUI&#x27;s on WASM is we can jettison JavaScript&#x2F;DOM and go back to writing GUI&#x27;s like 10-20 years ago, with simpler libraries.  Like SKIA, or something. Using non-web GUI libraries, since they could be compiled to WASM and run in web.<p>EDIT:  Native. I mean pre-web, when GUI libraries were native, everything ran locally.<p>Seemed like WASM would let apps be built like that again, but would be in browser for deployment.</div><br/><div id="40024085" class="c"><input type="checkbox" id="c-40024085" checked=""/><div class="controls bullet"><span class="by">codelikeawolf</span><span>|</span><a href="#40023752">parent</a><span>|</span><a href="#40023791">next</a><span>|</span><label class="collapse" for="c-40024085">[-]</label><label class="expand" for="c-40024085">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s a very good goal. Jettisoning the DOM means jettisoning accessibility and being able to leverage everything that the browser gives you out-of-the-box. You have to render to a canvas and build everything from scratch. I think Wasm is great for supplementing a JS app, not replacing it (e.g. using a Wasm module to do some calculations in a Worker). I like to use the right tool for the job, and trying to use something other than JS to build a web app just seems a little janky to me.<p>At one point, there was a Host Bindings proposal that would enable you to do DOM manipulation (it looks like it was archived and moved to the Component Model spec [1]). That would probably be the ideal way to avoid as much JS as possible. However, browser vendors have been heavily optimizing their JS runtimes, and in some cases, Wasm may actually be slower than JS.<p>I&#x27;ve been following Wasm&#x27;s progress for several years, which has been slow, but steady. Ironically, I think the web is actually the worst place to use it. There&#x27;s so much cool non-web stuff being done with it and I&#x27;m more interested to see where that goes.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;component-model?tab=readme-ov-file">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;component-model?tab=readme-ov...</a></div><br/></div></div><div id="40023791" class="c"><input type="checkbox" id="c-40023791" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40023752">parent</a><span>|</span><a href="#40024085">prev</a><span>|</span><a href="#40026620">next</a><span>|</span><label class="collapse" for="c-40023791">[-]</label><label class="expand" for="c-40023791">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll have to be GPU accelerated somehow, outside the wasm boundary. At 1080p it&#x27;s hard to make pixels move fast enough to get away with CPU rasterization.</div><br/></div></div><div id="40026620" class="c"><input type="checkbox" id="c-40026620" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#40023752">parent</a><span>|</span><a href="#40023791">prev</a><span>|</span><a href="#40025332">next</a><span>|</span><label class="collapse" for="c-40026620">[-]</label><label class="expand" for="c-40026620">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But can&#x27;t you use WASM to create GUI&#x27;s like Photoshop, with no JavaScript or DOM?<p>Yes, you can. If you have the time and the money. To quote Figma: &quot;Pulling this off was really hard; we’ve basically ended up building a browser inside a browser.&quot;: <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;building-a-professional-design-tool-on-the-web&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;building-a-professional-design-to...</a> And that&#x27;s just for the canvas part. Figma&#x27;s UI is React.<p>you need a good UI library if you want to do it like native. And native platforms have those. There&#x27;s nothing of the sort for any of WebGL&#x2F;Canvas&#x2F;WebGPU</div><br/></div></div><div id="40025332" class="c"><input type="checkbox" id="c-40025332" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#40023752">parent</a><span>|</span><a href="#40026620">prev</a><span>|</span><a href="#40023862">next</a><span>|</span><label class="collapse" for="c-40025332">[-]</label><label class="expand" for="c-40025332">[4 more]</label></div><br/><div class="children"><div class="content">Wasm doesn&#x27;t let you do that unless the native bindings are exposed. The web is really not a bad interface for building GUIs: Microsoft reckoned it was the way forward, back in 1999. <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;previous-versions&#x2F;ms536496(v=vs.85)" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;previous-versions&#x2F;ms536496...</a></div><br/><div id="40026432" class="c"><input type="checkbox" id="c-40026432" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#40023752">root</a><span>|</span><a href="#40025332">parent</a><span>|</span><a href="#40023862">next</a><span>|</span><label class="collapse" for="c-40026432">[-]</label><label class="expand" for="c-40026432">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware web pages exist.<p>I don&#x27;t think there is much argument that HTML+JavaScript was actually a set backwards that we&#x27;ve been trying to build out of for 20 years.<p>What the web solves is mass distribution.<p>But for programming it is awful.</div><br/><div id="40026598" class="c"><input type="checkbox" id="c-40026598" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#40023752">root</a><span>|</span><a href="#40026432">parent</a><span>|</span><a href="#40023862">next</a><span>|</span><label class="collapse" for="c-40026598">[-]</label><label class="expand" for="c-40026598">[2 more]</label></div><br/><div class="children"><div class="content">Are you familiar with the WAI&#x27;s Authoring Practices Guide? <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;WAI&#x2F;ARIA&#x2F;apg&#x2F;patterns&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;WAI&#x2F;ARIA&#x2F;apg&#x2F;patterns&#x2F;</a><p>&quot;Old-fashioned&quot; desktop GUI systems, like Win32 MDI, are built out of composeable widgets. HTML is built out of composeable widgets. Whatever you do with Wasm and direct pixel rendering? That isn&#x27;t.<p>The travesty that is modern web development is, absolutely, a step back from what we had back in the day. But that&#x27;s not inherent to the web: it&#x27;s a deficiency of practice. Many web APIs are delightful, and while they&#x27;re all clunky, Win32 MDI also has its footguns. <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20120213-00&#x2F;?p=8323" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20120213-00&#x2F;?p=83...</a></div><br/><div id="40027041" class="c"><input type="checkbox" id="c-40027041" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#40023752">root</a><span>|</span><a href="#40026598">parent</a><span>|</span><a href="#40023862">next</a><span>|</span><label class="collapse" for="c-40027041">[-]</label><label class="expand" for="c-40027041">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Still looking for something that bridges that gap, to make modern web pages as simple as old WinForms.<p>The only web based tools that I&#x27;ve come across that seem to hide all the JavaScript&#x2F;html, and be &#x27;simple&#x27; are tools like Elmish, or some of the other functional programming &#x27;DSL&#x27;s.  Where the page is kind of composed by functions that compile into the JavaScript.   With JavaScript, by the time I&#x27;m manipulating the DOM, I keep thinking some tool should be handling this for me.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40023862" class="c"><input type="checkbox" id="c-40023862" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#40023752">prev</a><span>|</span><a href="#40023636">next</a><span>|</span><label class="collapse" for="c-40023862">[-]</label><label class="expand" for="c-40023862">[8 more]</label></div><br/><div class="children"><div class="content">As things go along, I’m more and more mystified by WASM’s apparent design. It feels like 1996 Java for applets, but without the built-in GC, stdlib, or even the most basic hooks into the browser. Which means it’s basically useless for what I assume its goal is, of letting you use languages other than JavaScript to code a web page. Without trivial DOM access, what’s the point?<p>Other proposed usages like for FaaS-style edge widget computing honestly don’t make a lot of sense. Why target an artificial VM for that purpose instead of existing architectures that work just fine with less overhead.<p>For compute that could happen in either the browser or the edge, maybe, but how much is that level of portability really realistic or worthwhile? I’m guessing it might be in a few narrow cases, but it’s not going to be a common pattern.</div><br/><div id="40024121" class="c"><input type="checkbox" id="c-40024121" checked=""/><div class="controls bullet"><span class="by">codelikeawolf</span><span>|</span><a href="#40023862">parent</a><span>|</span><a href="#40026253">next</a><span>|</span><label class="collapse" for="c-40024121">[-]</label><label class="expand" for="c-40024121">[1 more]</label></div><br/><div class="children"><div class="content">In a nutshell, Wasm is essentially a CPU with a tiny instruction set. It&#x27;s very primitive and minimal, but I think that was the point. If you need to do something with numbers in a web app, it&#x27;s pretty neat. If you need to work with strings, you&#x27;re going to end up crying in the fetal position under your desk.</div><br/></div></div><div id="40026253" class="c"><input type="checkbox" id="c-40026253" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#40023862">parent</a><span>|</span><a href="#40024121">prev</a><span>|</span><a href="#40023971">next</a><span>|</span><label class="collapse" for="c-40026253">[-]</label><label class="expand" for="c-40026253">[1 more]</label></div><br/><div class="children"><div class="content">The current iteration of WebAssembly was always an &quot;MVP.&quot; It&#x27;s got the core instruction set and memory model to run, essentially, C programs safely and efficiently, and just enough interop with the host to get data in and out.<p>But it was always the plan to expand on that, and make a wider set of use cases easier and more efficient. Working directly with the DOM really requires some amount of integration with the GC that manages the DOM, for example.<p>The thing that makes this interesting outside the browser is the security model. Unlike typical environments used for FaaS or whatever else, it&#x27;s capability based and starts from literally zero- everything a WebAssembly module can touch has to be passed in explicitly when it&#x27;s instantiated. That&#x27;s a lot narrower, lighter weight, and more flexible than things like containers.</div><br/></div></div><div id="40023971" class="c"><input type="checkbox" id="c-40023971" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#40023862">parent</a><span>|</span><a href="#40026253">prev</a><span>|</span><a href="#40023636">next</a><span>|</span><label class="collapse" for="c-40023971">[-]</label><label class="expand" for="c-40023971">[5 more]</label></div><br/><div class="children"><div class="content">I might not be understanding.<p>But I thought WASM was to replace .NET and JAVA VM&#x27;s.  But, without a VM, to be more a pass through to the underlying CPU.  So much faster.  So compile down to a &#x27;byte code&#x27; like thing, that does not run on a VM, but runs on the underlying HW.<p>So goal was speed.<p>And to allow other languages to compile to it.</div><br/><div id="40024090" class="c"><input type="checkbox" id="c-40024090" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#40023862">root</a><span>|</span><a href="#40023971">parent</a><span>|</span><a href="#40026638">next</a><span>|</span><label class="collapse" for="c-40024090">[-]</label><label class="expand" for="c-40024090">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So compile down to a &#x27;byte code&#x27; like thing, that does not run on a VM, but runs on the underlying HW.<p>I think you may be confusing &quot;system&quot; virtual machines and &quot;process&quot; virtual machines. The VM here is the thing executing the WASM bytecode; it works the same was as .NET and JAVA VMs.</div><br/><div id="40026457" class="c"><input type="checkbox" id="c-40026457" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#40023862">root</a><span>|</span><a href="#40024090">parent</a><span>|</span><a href="#40026638">next</a><span>|</span><label class="collapse" for="c-40026457">[-]</label><label class="expand" for="c-40026457">[1 more]</label></div><br/><div class="children"><div class="content">I understand it is a VM like Java.  I was just under the impression that it was somehow better, more streamlined, that would offer enough performance improvement that you could start treating it like running a &#x27;native&#x27; local app.  Like if I build a &#x27;native&#x27; app, a &#x27;thick client&#x27;, I could now run it on WASM in a browser.  Thus not need any local installs, but have same performance.<p>I&#x27;ve seen some apps doing that.  But guess it isn&#x27;t considered &#x27;the way&#x27; for the future?</div><br/></div></div></div></div><div id="40026638" class="c"><input type="checkbox" id="c-40026638" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#40023862">root</a><span>|</span><a href="#40023971">parent</a><span>|</span><a href="#40024090">prev</a><span>|</span><a href="#40023636">next</a><span>|</span><label class="collapse" for="c-40026638">[-]</label><label class="expand" for="c-40026638">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But I thought WASM was to replace .NET and JAVA VM&#x27;s.<p>It&#x27;s name is literally <i>web</i> assembly. It&#x27;s goal was never and still isn&#x27;t to replace those VMs. It was literally an idea to create a faster code sandbox for the web based on the idea&#x27;s from Mozilla&#x27;s asm.js<p>&gt; to be more a pass through to the underlying CPU. So much faster. So compile down to a &#x27;byte code&#x27; like thing, that does not run on a VM, but runs on the underlying HW.<p>wat.<p>&gt; So goal was speed. And to allow other languages to compile to it.<p>Yes, it was. Has nothing to do with the fantasy of replacing JVM and .Net VM or running directly on hardware.</div><br/><div id="40026952" class="c"><input type="checkbox" id="c-40026952" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#40023862">root</a><span>|</span><a href="#40026638">parent</a><span>|</span><a href="#40023636">next</a><span>|</span><label class="collapse" for="c-40026952">[-]</label><label class="expand" for="c-40026952">[1 more]</label></div><br/><div class="children"><div class="content">Of course, that is where it started.
I&#x27;m probably being loose in terminology.<p>I assumed that to gain this speed, that it was a little closer to the metal than a VM like Java.  That it must have some kind of pass through to allow commands to run on the local HW, not just emulated in a VM.  So like a VM in that you can compile to it, but it would execute natively.<p>From the FAQ.<p>&quot;WebAssembly aims to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms. It is a low-level assembly-like language with a compact binary format that runs with near-native performance&quot;<p>And when looking at the Use Cases, it seems to be trying to do a lot more than javascript.<p><a href="https:&#x2F;&#x2F;webassembly.org&#x2F;docs&#x2F;use-cases&#x2F;" rel="nofollow">https:&#x2F;&#x2F;webassembly.org&#x2F;docs&#x2F;use-cases&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>