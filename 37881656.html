<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697360454267" as="style"/><link rel="stylesheet" href="styles.css?v=1697360454267"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.righto.com/2023/10/intel-386-die-versions.html">Examining the silicon dies of the Intel 386 processor</a> <span class="domain">(<a href="http://www.righto.com">www.righto.com</a>)</span></div><div class="subtext"><span>Tomte</span> | <span>54 comments</span></div><br/><div><div id="37881814" class="c"><input type="checkbox" id="c-37881814" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37883744">next</a><span>|</span><label class="collapse" for="c-37881814">[-]</label><label class="expand" for="c-37881814">[29 more]</label></div><br/><div class="children"><div class="content">Author here. I&#x27;ve been looking at the 386 if anyone has questions. This post was inspired by userbinator&#x27;s discussion on HN a couple of weeks ago about how many transistors there are in the 386.</div><br/><div id="37886065" class="c"><input type="checkbox" id="c-37886065" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37882232">next</a><span>|</span><label class="collapse" for="c-37886065">[-]</label><label class="expand" for="c-37886065">[1 more]</label></div><br/><div class="children"><div class="content">Great article as always! One nit:<p>&gt; <i>...&quot;tapeout&quot;, when the chip data is sent on magnetic tape to the mask fabrication company.</i><p>That&#x27;s roughly true in a temporal sense, but it&#x27;s not where the term &quot;tapeout&quot; comes from. They could have shipped the data on a Winchester disk, and the event would still be called tapeout.<p>In the earlier days of printed circuit board (PCB) manufacturing, you would literally &quot;tape out&quot; your circuit manually with black tape on a white board, typically in an enlarged form.<p>&quot;Tapeout&quot; came to mean the point in time when you finished taping out your circuit and it was ready to be sent to be photographed and reduced and boards manufactured from the layout.<p>There wasn&#x27;t even any &quot;data&quot; involved here, magnetic or otherwise. Just a physical art board with tape on it.<p>Wikipedia has a pretty good article on this:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tape-out" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tape-out</a><p>And for the young&#x27;uns who are wondering &quot;what the heck is a Winchester disk?&quot;<p><a href="https:&#x2F;&#x2F;www.pcmag.com&#x2F;encyclopedia&#x2F;term&#x2F;winchester-disk" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pcmag.com&#x2F;encyclopedia&#x2F;term&#x2F;winchester-disk</a><p>I taped out my first printed circuit board as a third-grader sometime around 1960 and shared the story here:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32116169">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32116169</a></div><br/></div></div><div id="37882232" class="c"><input type="checkbox" id="c-37882232" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37886065">prev</a><span>|</span><a href="#37882161">next</a><span>|</span><label class="collapse" for="c-37882232">[-]</label><label class="expand" for="c-37882232">[2 more]</label></div><br/><div class="children"><div class="content">Great post. The most interesting thing to me was how historically significant the 386SL turned out to be. I had always mentally slotted it as a cheap cut-down part for the emerging laptop market, but it actually was a relatively sophisticated (3X the transistors!) precursor of the modern SoC.</div><br/><div id="37887094" class="c"><input type="checkbox" id="c-37887094" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882232">parent</a><span>|</span><a href="#37882161">next</a><span>|</span><label class="collapse" for="c-37887094">[-]</label><label class="expand" for="c-37887094">[1 more]</label></div><br/><div class="children"><div class="content">Level of integration wasnt the thing that made 386SL special, there were 8088&#x2F;8086 SoCs before it like NEC V40 used in 1987 Zenith Eazy PC or V50 in 1988 Akai S1000 <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NEC_V20#Variants_and_successors" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NEC_V20#Variants_and_successor...</a><p>What made 386SL special was introduction of System Management Mode (SMM). Intel sued AMD over Am386 SMM implementation, AMD tried claiming its not really SMM but jut some left over debugging ICE implementation :D <a href="https:&#x2F;&#x2F;ir.amd.com&#x2F;sec-filings&#x2F;content&#x2F;0000898430-94-000804&#x2F;EX-99_1.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;ir.amd.com&#x2F;sec-filings&#x2F;content&#x2F;0000898430-94-000804&#x2F;...</a></div><br/></div></div></div></div><div id="37882161" class="c"><input type="checkbox" id="c-37882161" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37882232">prev</a><span>|</span><a href="#37882236">next</a><span>|</span><label class="collapse" for="c-37882161">[-]</label><label class="expand" for="c-37882161">[6 more]</label></div><br/><div class="children"><div class="content">Total amateur here: does a 386 have “cleverness” or optimizations or does it just quite literally chug through a stream of instructions, adjusting registers and memory?<p>I guess by this I am thinking about how newer processors do all kinds of stuff at the microcode level that mean you cannot anticipate precisely what instructions are being executed in what order.</div><br/><div id="37882744" class="c"><input type="checkbox" id="c-37882744" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882161">parent</a><span>|</span><a href="#37882360">next</a><span>|</span><label class="collapse" for="c-37882744">[-]</label><label class="expand" for="c-37882744">[1 more]</label></div><br/><div class="children"><div class="content">Well, yes and no. The 386 is chugging through the stream of instructions sequentially, unlike modern processors. There are various clever optimizations, though. First, there is some pipelining, so the microcode for the next instruction can execute while the previous one is finishing. Second, the CPU has 16 bytes of prefetching, so instructions are fetched from memory asynchronously from their execution. So you know what instructions are executed and in what order, but the timing is fairly unpredictable.<p>I should mention that microcode in the 386 is pretty different from micro-ops that modern processors run. They both break machine instructions down into smaller steps. But microcode runs sequentially, while micro-ops are sort of tossed into the CPU and run independently through a dataflow engine, with everything sorted out at the end to look sequential. Confusingly, modern processors use &quot;microcode&quot; to hold the micro-ops for complicated instructions that can&#x27;t be handled by the regular instruction decoder; this is sort of like old-style microcode, but not exactly.</div><br/></div></div><div id="37882360" class="c"><input type="checkbox" id="c-37882360" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882161">parent</a><span>|</span><a href="#37882744">prev</a><span>|</span><a href="#37885189">next</a><span>|</span><label class="collapse" for="c-37882360">[-]</label><label class="expand" for="c-37882360">[1 more]</label></div><br/><div class="children"><div class="content">Out of order execution was introduced in the Pentium Pro, the Pentium was already able to execute two instructions per cycle but was still in-order.<p>Note that this &quot;magic&quot; is mostly implemented not in microcode, but rather in hardwired logic.</div><br/></div></div><div id="37885189" class="c"><input type="checkbox" id="c-37885189" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882161">parent</a><span>|</span><a href="#37882360">prev</a><span>|</span><a href="#37887182">next</a><span>|</span><label class="collapse" for="c-37885189">[-]</label><label class="expand" for="c-37885189">[1 more]</label></div><br/><div class="children"><div class="content">One of the assertions of RISC is that microcode is a performance penalty, to be avoided.<p>And many have.<p>&quot;To provide this rich set of instructions, CPUs used microcode to decode the user-visible instruction into a series of internal operations. This microcode represented perhaps 1⁄4 to 1⁄3 of the transistors of the overall design. If... the majority of these opcodes would never be used in practice, then this significant resource was being wasted.&quot;<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Berkeley_RISC" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Berkeley_RISC</a></div><br/></div></div><div id="37887182" class="c"><input type="checkbox" id="c-37887182" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882161">parent</a><span>|</span><a href="#37885189">prev</a><span>|</span><a href="#37882236">next</a><span>|</span><label class="collapse" for="c-37887182">[-]</label><label class="expand" for="c-37887182">[2 more]</label></div><br/><div class="children"><div class="content">386 is actually somewhat slower clock for clock than 286 for same 16bit code. So no, no optimizations. For example <a href="https:&#x2F;&#x2F;web.itu.edu.tr&#x2F;kesgin&#x2F;mul06&#x2F;intel&#x2F;instr&#x2F;movs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.itu.edu.tr&#x2F;kesgin&#x2F;mul06&#x2F;intel&#x2F;instr&#x2F;movs.html</a>, 486 was only slightly optimized, it was Pentium where they finally started working on IPC.</div><br/><div id="37887275" class="c"><input type="checkbox" id="c-37887275" checked=""/><div class="controls bullet"><span class="by">vikingerik</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37887182">parent</a><span>|</span><a href="#37882236">next</a><span>|</span><label class="collapse" for="c-37887275">[-]</label><label class="expand" for="c-37887275">[1 more]</label></div><br/><div class="children"><div class="content">Right, the 486 was only slightly optimized for IPC.  Most of the 486&#x27;s performance over the 386DX was from its L1 cache (or just called CPU cache at the time, there weren&#x27;t different cache levels yet.)  You can turn the cache off in a 486&#x27;s BIOS and it will be barely any faster than a 386 of the same clock speed.</div><br/></div></div></div></div></div></div><div id="37882236" class="c"><input type="checkbox" id="c-37882236" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37882161">prev</a><span>|</span><a href="#37882407">next</a><span>|</span><label class="collapse" for="c-37882236">[-]</label><label class="expand" for="c-37882236">[7 more]</label></div><br/><div class="children"><div class="content">Love the post!<p>Some DOI and Bitsavers links are broken (linking to righto.com or 404s). Also, where can I find &quot;Automatic Place and Route Used on the 80386&quot;? DDG only contains one result: this post.</div><br/><div id="37882658" class="c"><input type="checkbox" id="c-37882658" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882236">parent</a><span>|</span><a href="#37882681">next</a><span>|</span><label class="collapse" for="c-37882658">[-]</label><label class="expand" for="c-37882658">[4 more]</label></div><br/><div class="children"><div class="content">There was some discussion of the automatic placement in this panel interview.<p>If I remember correctly, the software that performed the placement was written by a graduate student who debugged it from a terminal at his dormitory. It was one of many project decisions on the i386 that management would have absolutely stopped had they been made aware.<p><a href="https:&#x2F;&#x2F;www.computerhistory.org&#x2F;collections&#x2F;catalog&#x2F;102702019" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.computerhistory.org&#x2F;collections&#x2F;catalog&#x2F;10270201...</a><p>&quot;386 is a complicated processor (by 1980s standards), with 285,000 transistors...&quot;<p>Interesting that ARM1 was only 25,000 transistors. Did the i386 really have additional features that justify an order of magnitude?<p>One thing is certain in retrospect: Intel should have bought Acorn, not Olivetti.<p>Edit: Wow, there is even more detail on the placement software in the Righto article; the software was &quot;Timberwolf&quot; written by Dr. Carl Sechen.<p>Edit2: It appears that later versions of Timberwolf were sucked into Yale&#x27;s licensing.<p>...Sechen served as an expert witness in the Cadence&#x2F;Avanti trial in 2000 and 2001... &quot;I had a chance to examine a great deal of the code in question when I was an expert witness on the trial. It was amazing – I even saw my own TimberWolf code in their tool, where only a single line of code had been changed. And I don’t mean the earlier, far-inferior version of TimberWolf available from Berkeley. The version I found in Avanti’s suite was a far more state-of-the-art version that had somehow been ‘acquired’ from Yale.&quot;<p><a href="http:&#x2F;&#x2F;www.aycinena.com&#x2F;index2&#x2F;index3&#x2F;archive&#x2F;uw%20-%20sechen.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.aycinena.com&#x2F;index2&#x2F;index3&#x2F;archive&#x2F;uw%20-%20seche...</a><p>Edit3: Graywolf is a fork of the last free version of Yale&#x27;s Timberwolf.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rubund&#x2F;graywolf">https:&#x2F;&#x2F;github.com&#x2F;rubund&#x2F;graywolf</a></div><br/><div id="37884334" class="c"><input type="checkbox" id="c-37884334" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882658">parent</a><span>|</span><a href="#37887209">next</a><span>|</span><label class="collapse" for="c-37884334">[-]</label><label class="expand" for="c-37884334">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Did the i386 really have additional features<p>Here are a few:<p>- &gt; 26 bit address space<p>- multiplication in hardware<p>- more complex instructions<p>- backwards compatibility with the 80286<p>- on-chip MMU<p>- support for a FPU<p>&gt; that justify an order of magnitude?<p>I wouldn’t know. Backwards compatibility certainly is high on the list because, when it was released, many users had fairly high investments in commercial software.</div><br/><div id="37884840" class="c"><input type="checkbox" id="c-37884840" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37884334">parent</a><span>|</span><a href="#37887209">next</a><span>|</span><label class="collapse" for="c-37884840">[-]</label><label class="expand" for="c-37884840">[1 more]</label></div><br/><div class="children"><div class="content">Well, 26 bits would have made the 80286 a king. Would that itself have killed ARM?<p>Of course, SSE&#x2F;NEON was decades in the future.<p>As we note, Intel did not value backwards compatibility at the outset of the i386.<p>Perhaps an Acorn acquisition and the sudden ownership of a low-power CPU that they could make for peanuts might have also had a profound impact.<p>It would have been interesting to see Intel making BBC Micros.</div><br/></div></div></div></div><div id="37887209" class="c"><input type="checkbox" id="c-37887209" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882658">parent</a><span>|</span><a href="#37884334">prev</a><span>|</span><a href="#37882681">next</a><span>|</span><label class="collapse" for="c-37887209">[-]</label><label class="expand" for="c-37887209">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>interesting that ARM1 was only 25,000 transistors. Did the i386 really have additional features that justify an order of magnitude?</i><p>you&#x27;re asking somebody to answer RISC vs CISC in a subthread? there&#x27;s not simple answer to that question, but the x86 family had a leg up with MSWindows compatibility and the processors they developed maintained that hegemony till they went astray with Itanium and were saved by amd64</div><br/></div></div></div></div><div id="37882681" class="c"><input type="checkbox" id="c-37882681" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882236">parent</a><span>|</span><a href="#37882658">prev</a><span>|</span><a href="#37882407">next</a><span>|</span><label class="collapse" for="c-37882681">[-]</label><label class="expand" for="c-37882681">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! I&#x27;ve fixed the links, so let me know if you see any other broken ones.<p>The  &quot;Automatic Place and Route Used on the 80386&quot; article is from Intel Technology Journal, Spring 1986, p29-34. I don&#x27;t think you can find it anywhere; Pat Gelsinger sent me a copy. Email me (ken.shirriff@gmail.com) and I&#x27;ll send it to you.</div><br/><div id="37883133" class="c"><input type="checkbox" id="c-37883133" checked=""/><div class="controls bullet"><span class="by">pbjtime</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882681">parent</a><span>|</span><a href="#37882407">next</a><span>|</span><label class="collapse" for="c-37883133">[-]</label><label class="expand" for="c-37883133">[1 more]</label></div><br/><div class="children"><div class="content">You can always upload it to Archive.org if you feel so inclined</div><br/></div></div></div></div></div></div><div id="37882407" class="c"><input type="checkbox" id="c-37882407" checked=""/><div class="controls bullet"><span class="by">johnklos</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37882236">prev</a><span>|</span><a href="#37886361">next</a><span>|</span><label class="collapse" for="c-37882407">[-]</label><label class="expand" for="c-37882407">[2 more]</label></div><br/><div class="children"><div class="content">Every time I see something new on righto.com, I get excited! I get to learn :D<p>Thank you so much, both for constantly sharing what you know and for preserving what&#x27;s one of the most interesting times in the evolution of computing.</div><br/><div id="37883796" class="c"><input type="checkbox" id="c-37883796" checked=""/><div class="controls bullet"><span class="by">RetroTechie</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882407">parent</a><span>|</span><a href="#37886361">next</a><span>|</span><label class="collapse" for="c-37883796">[-]</label><label class="expand" for="c-37883796">[1 more]</label></div><br/><div class="children"><div class="content">+1<p>What I like most about these articles, is that it shows how messy even high-tech can be:<p>All the details in fabrication techniques (and its effect on what logic designers can&#x2F;can&#x27;t do), some opcodes removed to make room on the die for a bugfix (?, see note 26), etc etc. &quot;Ultimately all digital electronics is analog&quot;.<p>The business mistakes, and lucky recoveries.<p>Keep up the good work, Ken! (btw you typo&#x27;d an &quot;8&quot; and &quot;6&quot; in note 25 :-)</div><br/></div></div></div></div><div id="37886361" class="c"><input type="checkbox" id="c-37886361" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37882407">prev</a><span>|</span><a href="#37883128">next</a><span>|</span><label class="collapse" for="c-37886361">[-]</label><label class="expand" for="c-37886361">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for getting to the bottom of the doubt!<p>The SL die photo seems to really show the differences in density that careful layout can produce; one wouldn&#x27;t think that bus&#x2F;memory controllers are of the same complexity as the CPU itself, but due to being entirely standard cells, they are almost the same size as the CPU.</div><br/></div></div><div id="37883128" class="c"><input type="checkbox" id="c-37883128" checked=""/><div class="controls bullet"><span class="by">srejk</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37886361">prev</a><span>|</span><a href="#37882282">next</a><span>|</span><label class="collapse" for="c-37883128">[-]</label><label class="expand" for="c-37883128">[5 more]</label></div><br/><div class="children"><div class="content">Great post! Any idea how the turbo button worked? It seems like, given the transistor difference between the 8086 and 386, that merely decreasing the clock frequency wouldn&#x27;t be enough?</div><br/><div id="37883551" class="c"><input type="checkbox" id="c-37883551" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37883128">parent</a><span>|</span><a href="#37887218">next</a><span>|</span><label class="collapse" for="c-37883551">[-]</label><label class="expand" for="c-37883551">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think the turbo button just changes the clock speed. The 386 was designed to be binary compatible with the 8086, but normally ran faster.</div><br/></div></div><div id="37887218" class="c"><input type="checkbox" id="c-37887218" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37883128">parent</a><span>|</span><a href="#37883551">prev</a><span>|</span><a href="#37887259">next</a><span>|</span><label class="collapse" for="c-37887218">[-]</label><label class="expand" for="c-37887218">[1 more]</label></div><br/><div class="children"><div class="content">the lack-of-turbo button was included to enhance compatibility with older software that using timing tricks that relied on the clockspeeds of the older generations of processors. Those older processors would not have used the enhanced features of the new processors, just the backward compatible features. Turbo was a motherboard OEM feature, not a 386 feature. Otherwise, there was no reason not to run &quot;turbo&quot;</div><br/></div></div><div id="37887259" class="c"><input type="checkbox" id="c-37887259" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37883128">parent</a><span>|</span><a href="#37887218">prev</a><span>|</span><a href="#37883671">next</a><span>|</span><label class="collapse" for="c-37887259">[-]</label><label class="expand" for="c-37887259">[1 more]</label></div><br/><div class="children"><div class="content">Chipset&#x2F;motherboard specific. Clock, wait states, cache, later even SMM sleep.</div><br/></div></div><div id="37883671" class="c"><input type="checkbox" id="c-37883671" checked=""/><div class="controls bullet"><span class="by">irdc</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37883128">parent</a><span>|</span><a href="#37887259">prev</a><span>|</span><a href="#37882282">next</a><span>|</span><label class="collapse" for="c-37883671">[-]</label><label class="expand" for="c-37883671">[1 more]</label></div><br/><div class="children"><div class="content">This was often done by introducing wait states, so the processor would slow down while accessing main memory.</div><br/></div></div></div></div><div id="37882282" class="c"><input type="checkbox" id="c-37882282" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37883128">prev</a><span>|</span><a href="#37881863">next</a><span>|</span><label class="collapse" for="c-37882282">[-]</label><label class="expand" for="c-37882282">[2 more]</label></div><br/><div class="children"><div class="content">About what rough area percentage (or some other metric if you think there&#x27;s a clearer comparison) of a 386DX is standard cells versus hand layout?</div><br/><div id="37882803" class="c"><input type="checkbox" id="c-37882803" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37881814">root</a><span>|</span><a href="#37882282">parent</a><span>|</span><a href="#37881863">next</a><span>|</span><label class="collapse" for="c-37882803">[-]</label><label class="expand" for="c-37882803">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the die, I&#x27;d say roughly 1&#x2F;3 of the die is standard cell. I think some of it was standard cell but with hand layout, rather than automatic place and route. About 1&#x2F;4 is the datapath, which is highly optimized. Maybe 10% is the microcode ROM.</div><br/></div></div></div></div><div id="37886985" class="c"><input type="checkbox" id="c-37886985" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#37881814">parent</a><span>|</span><a href="#37881863">prev</a><span>|</span><a href="#37883744">next</a><span>|</span><label class="collapse" for="c-37886985">[-]</label><label class="expand" for="c-37886985">[1 more]</label></div><br/><div class="children"><div class="content">Sadly Computerworld &#x27;Intel backs off 80386 claims but denies chip recast needed (1986)&#x27; article was devoid of technical details :(<p>Do you have more detailed information about what were the main issues with multiple OSes in Protected Mode? Was it implementation bug or fundamental architectural problems?<p>Do you know by any chance why did Intel miss POPF trap in Protected Mode?<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20160411-00&#x2F;?p=93281" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20160411-00&#x2F;?p=93...</a> <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;virtualization&#x2F;virtualbox&#x2F;6.0&#x2F;admin&#x2F;swvirt-details.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;virtualization&#x2F;virtualbox&#x2F;6.0&#x2F;adm...</a>  <a href="https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;popf:popfd:popfq" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;popf:popfd:popfq</a><p>Pentium Virtual Mode Extension (VME) and its Protected Mode Virtual Interrupts (PVI) solve performance burden of trapping, but despite being named _Protected Mode_ Virtual Interrupts this works only in V86 mode leaving Protected with this bug:<p>&quot;The protected-mode virtual-interrupt feature — enabled by setting CR4.PVI — affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. POPF, however, is not affected by CR4.PVI&quot;<p>They even planned to patent PVI this in ~1992 <a href="https:&#x2F;&#x2F;patents.google.com&#x2F;patent&#x2F;GB2259794A&#x2F;en" rel="nofollow noreferrer">https:&#x2F;&#x2F;patents.google.com&#x2F;patent&#x2F;GB2259794A&#x2F;en</a> and clearly knew about popf pitfalls back then.<p>Could this be what people in Computerworld article were complaining about? I dont understand how Intel not fixed it at all to this day.<p>Btw I find it funny and weird that Intel was lawyering around all the way in 1998 trying to suppress any knowledge of Virtual Mode Extension! Dr. Dobb&#x27;s &#x27;VME: Coming Out of the Cold&#x27; <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20001217233100&#x2F;http:&#x2F;&#x2F;www.rcollins.org&#x2F;ddj&#x2F;May98&#x2F;May98.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20001217233100&#x2F;http:&#x2F;&#x2F;www.rcolli...</a></div><br/></div></div></div></div><div id="37883744" class="c"><input type="checkbox" id="c-37883744" checked=""/><div class="controls bullet"><span class="by">bradfitz</span><span>|</span><a href="#37881814">prev</a><span>|</span><a href="#37882589">next</a><span>|</span><label class="collapse" for="c-37883744">[-]</label><label class="expand" for="c-37883744">[9 more]</label></div><br/><div class="children"><div class="content">My dad worked on that processor, among others. I see his KF initials in that die photo! :)</div><br/><div id="37883787" class="c"><input type="checkbox" id="c-37883787" checked=""/><div class="controls bullet"><span class="by">EMIRELADERO</span><span>|</span><a href="#37883744">parent</a><span>|</span><a href="#37884048">next</a><span>|</span><label class="collapse" for="c-37883787">[-]</label><label class="expand" for="c-37883787">[5 more]</label></div><br/><div class="children"><div class="content">How were those processors made in a day-to-day basis? What did a typical Intel workspace look like back in the day?</div><br/><div id="37885592" class="c"><input type="checkbox" id="c-37885592" checked=""/><div class="controls bullet"><span class="by">bradfitz</span><span>|</span><a href="#37883744">root</a><span>|</span><a href="#37883787">parent</a><span>|</span><a href="#37884048">next</a><span>|</span><label class="collapse" for="c-37885592">[-]</label><label class="expand" for="c-37885592">[4 more]</label></div><br/><div class="children"><div class="content">I remember they had cubicles. Relatively glamorous compared to entirely open and echoey offices.</div><br/><div id="37886953" class="c"><input type="checkbox" id="c-37886953" checked=""/><div class="controls bullet"><span class="by">sacnoradhq</span><span>|</span><a href="#37883744">root</a><span>|</span><a href="#37885592">parent</a><span>|</span><a href="#37886371">next</a><span>|</span><label class="collapse" for="c-37886953">[-]</label><label class="expand" for="c-37886953">[1 more]</label></div><br/><div class="children"><div class="content">Ah, the days of cubicles. Trimble Nav in Sunnyvale had medium-height, solid fabric-backed 6x8&#x27; and 8x8&#x27; cubicles in 2000. And it was nice to be tucked in a quiet corner of the building by the foosball table room before there was such thing as startup culture. Was almost detained by SGI security by Shoreline Amphitheater (near the &#x27;plex now) doing field radio testing off a coworker&#x27;s truck that looked like Van Eck phreaking equipment. I should&#x27;ve worn a hi-vis vest. ;D<p>PS: Raise a paw if you remember the rainbow Apple logo on the triangle building along 280.</div><br/></div></div><div id="37886371" class="c"><input type="checkbox" id="c-37886371" checked=""/><div class="controls bullet"><span class="by">EMIRELADERO</span><span>|</span><a href="#37883744">root</a><span>|</span><a href="#37885592">parent</a><span>|</span><a href="#37886953">prev</a><span>|</span><a href="#37884048">next</a><span>|</span><label class="collapse" for="c-37886371">[-]</label><label class="expand" for="c-37886371">[2 more]</label></div><br/><div class="children"><div class="content">What did the design process actually look like? Did they design at the gate level? Drawing manually or via software?</div><br/><div id="37886591" class="c"><input type="checkbox" id="c-37886591" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37883744">root</a><span>|</span><a href="#37886371">parent</a><span>|</span><a href="#37884048">next</a><span>|</span><label class="collapse" for="c-37886591">[-]</label><label class="expand" for="c-37886591">[1 more]</label></div><br/><div class="children"><div class="content">This is partially answered in the artice when the author discusses the creation of the 386. Specifically, footnote #23 calls out his sources.</div><br/></div></div></div></div></div></div></div></div><div id="37884048" class="c"><input type="checkbox" id="c-37884048" checked=""/><div class="controls bullet"><span class="by">boulos</span><span>|</span><a href="#37883744">parent</a><span>|</span><a href="#37883787">prev</a><span>|</span><a href="#37882589">next</a><span>|</span><label class="collapse" for="c-37884048">[-]</label><label class="expand" for="c-37884048">[3 more]</label></div><br/><div class="children"><div class="content">The author even mentioned him in the notes. Do you know any of the other designers names?</div><br/><div id="37884060" class="c"><input type="checkbox" id="c-37884060" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37883744">root</a><span>|</span><a href="#37884048">parent</a><span>|</span><a href="#37884684">next</a><span>|</span><label class="collapse" for="c-37884060">[-]</label><label class="expand" for="c-37884060">[1 more]</label></div><br/><div class="children"><div class="content">I updated the article with Brad&#x27;s info :)</div><br/></div></div><div id="37884684" class="c"><input type="checkbox" id="c-37884684" checked=""/><div class="controls bullet"><span class="by">bradfitz</span><span>|</span><a href="#37883744">root</a><span>|</span><a href="#37884048">parent</a><span>|</span><a href="#37884060">prev</a><span>|</span><a href="#37882589">next</a><span>|</span><label class="collapse" for="c-37884684">[-]</label><label class="expand" for="c-37884684">[1 more]</label></div><br/><div class="children"><div class="content">My dad says he does. I&#x27;ve connected him with Ken.</div><br/></div></div></div></div></div></div><div id="37882589" class="c"><input type="checkbox" id="c-37882589" checked=""/><div class="controls bullet"><span class="by">DIVx0</span><span>|</span><a href="#37883744">prev</a><span>|</span><a href="#37886886">next</a><span>|</span><label class="collapse" for="c-37882589">[-]</label><label class="expand" for="c-37882589">[1 more]</label></div><br/><div class="children"><div class="content">One of my greatest treasures as a young computer nerd was a bare 386(I think) chip that I received after sending away for it via an Intel ad I found in Byte magazine. I just had to cut out part of the page and mail it in. Several months later I get a package back with the naked processor glued to stiff card along with a low powered magnifying glass to scope it out with.<p>I really wish I still had that thing.</div><br/></div></div><div id="37886886" class="c"><input type="checkbox" id="c-37886886" checked=""/><div class="controls bullet"><span class="by">sacnoradhq</span><span>|</span><a href="#37882589">prev</a><span>|</span><a href="#37883255">next</a><span>|</span><label class="collapse" for="c-37886886">[-]</label><label class="expand" for="c-37886886">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;If management had known that we were using a tool by some grad student as the key part of the methodology, they would never have let us use it.&quot;<p>This is why managers shouldn&#x27;t micromanage technical decisions.</div><br/></div></div><div id="37883255" class="c"><input type="checkbox" id="c-37883255" checked=""/><div class="controls bullet"><span class="by">macote</span><span>|</span><a href="#37886886">prev</a><span>|</span><a href="#37886928">next</a><span>|</span><label class="collapse" for="c-37883255">[-]</label><label class="expand" for="c-37883255">[5 more]</label></div><br/><div class="children"><div class="content">Today I learned that the &quot;s&quot; in SX means &quot;single&quot; and &quot;d&quot; in DX means double. The DX has double the data bus width of the SX (32-bit vs 16-bit).</div><br/><div id="37883575" class="c"><input type="checkbox" id="c-37883575" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37883255">parent</a><span>|</span><a href="#37883388">next</a><span>|</span><label class="collapse" for="c-37883575">[-]</label><label class="expand" for="c-37883575">[3 more]</label></div><br/><div class="children"><div class="content">But then the 486 DX has a floating-point unit, while the 486 SX does not. So Intel just went with DX is better than SX.</div><br/><div id="37883989" class="c"><input type="checkbox" id="c-37883989" checked=""/><div class="controls bullet"><span class="by">RachelF</span><span>|</span><a href="#37883255">root</a><span>|</span><a href="#37883575">parent</a><span>|</span><a href="#37883388">next</a><span>|</span><label class="collapse" for="c-37883989">[-]</label><label class="expand" for="c-37883989">[2 more]</label></div><br/><div class="children"><div class="content">There were rumours that the DX and SX chips were exactly the same:<p>Intel zapped the FPU on the SX to disable it. Apparently it cost more to make, but sold for less.</div><br/><div id="37885260" class="c"><input type="checkbox" id="c-37885260" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#37883255">root</a><span>|</span><a href="#37883989">parent</a><span>|</span><a href="#37883388">next</a><span>|</span><label class="collapse" for="c-37885260">[-]</label><label class="expand" for="c-37885260">[1 more]</label></div><br/><div class="children"><div class="content">The (80-bit) floating point in historic Intel processors is deprecated, FYI.<p>After the exchange of MMX and 3d-NOW, it was AMD that adopted Intel SSE into amd64.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions</a></div><br/></div></div></div></div></div></div><div id="37883388" class="c"><input type="checkbox" id="c-37883388" checked=""/><div class="controls bullet"><span class="by">christkv</span><span>|</span><a href="#37883255">parent</a><span>|</span><a href="#37883575">prev</a><span>|</span><a href="#37886928">next</a><span>|</span><label class="collapse" for="c-37883388">[-]</label><label class="expand" for="c-37883388">[1 more]</label></div><br/><div class="children"><div class="content">The 386sx was my first overclock switching time crystals out on the board.</div><br/></div></div></div></div><div id="37886928" class="c"><input type="checkbox" id="c-37886928" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#37883255">prev</a><span>|</span><a href="#37882469">next</a><span>|</span><label class="collapse" for="c-37886928">[-]</label><label class="expand" for="c-37886928">[1 more]</label></div><br/><div class="children"><div class="content">wasn&#x27;t the page mode mmu the most important new feature?  iirc this allowed for fully protected virtual memory, even for legacy applications.</div><br/></div></div><div id="37882469" class="c"><input type="checkbox" id="c-37882469" checked=""/><div class="controls bullet"><span class="by">twism</span><span>|</span><a href="#37886928">prev</a><span>|</span><a href="#37882220">next</a><span>|</span><label class="collapse" for="c-37882469">[-]</label><label class="expand" for="c-37882469">[1 more]</label></div><br/><div class="children"><div class="content">reminds me of the days computers had a &quot;turbo&quot; button and a LCD read out of the clock speed on the case. &quot;66Mhz&quot; =&gt; &quot;90&quot; ...  now we&#x27;re cooking</div><br/></div></div><div id="37882220" class="c"><input type="checkbox" id="c-37882220" checked=""/><div class="controls bullet"><span class="by">jewillco</span><span>|</span><a href="#37882469">prev</a><span>|</span><a href="#37883299">next</a><span>|</span><label class="collapse" for="c-37882220">[-]</label><label class="expand" for="c-37882220">[3 more]</label></div><br/><div class="children"><div class="content">Could the “C” in 80C386I stand for CMOS? Wasn’t that pattern used for the 80C88, for example?</div><br/><div id="37882730" class="c"><input type="checkbox" id="c-37882730" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#37882220">parent</a><span>|</span><a href="#37887889">next</a><span>|</span><label class="collapse" for="c-37882730">[-]</label><label class="expand" for="c-37882730">[1 more]</label></div><br/><div class="children"><div class="content">All Intel 386s were CMOS though, so the added C on the die-shrink shouldn&#x27;t mean CMOS.</div><br/></div></div><div id="37887889" class="c"><input type="checkbox" id="c-37887889" checked=""/><div class="controls bullet"><span class="by">anticensor</span><span>|</span><a href="#37882220">parent</a><span>|</span><a href="#37882730">prev</a><span>|</span><a href="#37883299">next</a><span>|</span><label class="collapse" for="c-37887889">[-]</label><label class="expand" for="c-37887889">[1 more]</label></div><br/><div class="children"><div class="content">More like compact.</div><br/></div></div></div></div><div id="37883299" class="c"><input type="checkbox" id="c-37883299" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#37882220">prev</a><span>|</span><label class="collapse" for="c-37883299">[-]</label><label class="expand" for="c-37883299">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always interested in all things (80)386 because this was basically the processor that launched the 32-bit computing revolution, at least as far as popular adoption of computers based on this processor go (there were earlier 32-bit processors -- but no earlier processor became as commercially popular (or as adopted by the mass population) as much as the (80)386).<p>So this processor is of particular interest to me -- and should be to future computing historians...<p>This is truly a great article about that processor!<p>It&#x27;s information rich (I have not seen a more information rich source about the 386 on the entire Internet, except for perhaps 386 technical manuals and manual fragments, but those documents lack general human readability), and it is of great value to anyone who wishes to study the 386, and it will be of great value to future computer historians...<p>So, well done!<p>Upvoted and favorited!</div><br/><div id="37883646" class="c"><input type="checkbox" id="c-37883646" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37883299">parent</a><span>|</span><label class="collapse" for="c-37883646">[-]</label><label class="expand" for="c-37883646">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for your kind comments!<p>Personally, I&#x27;d say that the IBM System&#x2F;360 (1964) was the first widespread and influential 32-bit architecture. The Motorola 68000 (1979) also deserves a mention for its use in the Macintosh. (And I&#x27;ll argue with anyone who says it wasn&#x27;t a real 32-bit processor :-) But, yes, the 386 started the 32-bit x86 architecture on most (non-phone) computers today.</div><br/><div id="37886406" class="c"><input type="checkbox" id="c-37886406" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#37883299">root</a><span>|</span><a href="#37883646">parent</a><span>|</span><label class="collapse" for="c-37886406">[-]</label><label class="expand" for="c-37886406">[1 more]</label></div><br/><div class="children"><div class="content">Excellent points!<p>System&#x2F;360 is indeed interesting because (if my memory serves me) it was one of the first computational architectures to implement microcode (also, if I recall correctly, the necessity of updating of this microcode was one of the reasons that floppy drives were invented...)<p>I&#x27;m also a fan of the Motorola 68000 -- I used to have an Amiga 1000 &quot;back in the day&quot;.  I&#x27;d choose it over any 8 or 16 bit CPU of the time period, but (correct me if I am wrong) <i>it didn&#x27;t have an MMU</i> -- which would have made it a less-than-ideal candidate for writing a modern-day Unix compatible operating system, although the authors of AmigaOS managed to pull off quite an impressive multitasking OS on it, despite this fact, nonetheless...<p>Also, as a 32-bit <i>architecture</i> (as opposed to discrete single-package IC CPU) we&#x27;d probably additionally want to remember the <i>VAX 11&#x2F;780</i> (1977) -- whose CPU was implemented as circuits of multiple simpler TTL IC&#x27;s...<p>(Oh sure, IBM might have done something like that earlier -- but the VAX 11&#x2F;780 brought down the cost of IBM&#x27;s comparable computing offerings by at least <i>one order of magnitude</i>! -- Although, even so, the 11&#x2F;780 still would have been ridiculously expensive to the average person of that time period... (and yes, I know it was intended for mid-sized to large businesses, not people! :-))<p>But anyway, great article, and yes, the IBM System&#x2F;360 and 68000 were indeed groundbreaking!</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>