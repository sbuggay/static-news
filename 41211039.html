<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723366868474" as="style"/><link rel="stylesheet" href="styles.css?v=1723366868474"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dl.acm.org/doi/10.1145/3591264">Interval parsing grammars for file format parsing (2023)</a> <span class="domain">(<a href="https://dl.acm.org">dl.acm.org</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>26 comments</span></div><br/><div><div id="41211674" class="c"><input type="checkbox" id="c-41211674" checked=""/><div class="controls bullet"><span class="by">pointlessone</span><span>|</span><a href="#41213111">next</a><span>|</span><label class="collapse" for="c-41211674">[-]</label><label class="expand" for="c-41211674">[9 more]</label></div><br/><div class="children"><div class="content">They definitely did not implement PDF parsing, even a subset of it. They make some assumptions that will definitely result in incorrect parsing. For instance, they assume, objects are tightly packed. They&#x27;re not required to. They should be to save space but are not required to. Moreover, it is possible to place objects inside other objects. It&#x27;s not advised but not prohibited. As far as I can tell this is where their PDF parsing ends. They don&#x27;t parse the objects themselves (not regular objects, nor stream objects). So they&#x27;ve chosen PDF &quot;because it is the most complicated format to our knowledge&quot; but ended up just (incorrectly) chunking the stream by offset table.</div><br/><div id="41212921" class="c"><input type="checkbox" id="c-41212921" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41211674">parent</a><span>|</span><a href="#41211805">next</a><span>|</span><label class="collapse" for="c-41212921">[-]</label><label class="expand" for="c-41212921">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For instance, they assume, objects are tightly packed. They&#x27;re not required to. They should be to save space but are not required to.<p>The PDF 2.0 spec says in section 7.5.3, &quot;The body of a PDF file shall consist of a sequence of indirect objects representing the contents of a document.&quot; I&#x27;d read that as establishing the entire contents of the file body. Of course, real-world PDFs might have all sorts of garbage that a practical parser should be prepared for, but I don&#x27;t think that it&#x27;s condoned by the standard.<p>&gt; Moreover, it is possible to place objects inside other objects. It&#x27;s not advised but not prohibited.<p>I think the standard tokenization would prevent any string &quot;obj&quot; inside of an indirect object from actually being a <i>keyword</i> obj that starts a new indirect object. (And if the file body as a whole weren&#x27;t tokenized from start to end, then &quot;a <i>sequence</i> of indirect objects&quot; would be nonsensical.)</div><br/><div id="41214429" class="c"><input type="checkbox" id="c-41214429" checked=""/><div class="controls bullet"><span class="by">pointlessone</span><span>|</span><a href="#41211674">root</a><span>|</span><a href="#41212921">parent</a><span>|</span><a href="#41211805">next</a><span>|</span><label class="collapse" for="c-41214429">[-]</label><label class="expand" for="c-41214429">[1 more]</label></div><br/><div class="children"><div class="content">An object can be placed into a stream without breaking any syntactic or semantic rules.</div><br/></div></div></div></div><div id="41211805" class="c"><input type="checkbox" id="c-41211805" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#41211674">parent</a><span>|</span><a href="#41212921">prev</a><span>|</span><a href="#41212278">next</a><span>|</span><label class="collapse" for="c-41211805">[-]</label><label class="expand" for="c-41211805">[2 more]</label></div><br/><div class="children"><div class="content">Yeah this work is far away from what a real PDF parser requires. It’s not uncommon for the lengths at the beginning of streams to be wrong or the data to be encoded in a format different from the one claimed. The offset table can also be wrong or missing.</div><br/><div id="41211944" class="c"><input type="checkbox" id="c-41211944" checked=""/><div class="controls bullet"><span class="by">pointlessone</span><span>|</span><a href="#41211674">root</a><span>|</span><a href="#41211805">parent</a><span>|</span><a href="#41212278">next</a><span>|</span><label class="collapse" for="c-41211944">[-]</label><label class="expand" for="c-41211944">[1 more]</label></div><br/><div class="children"><div class="content">Malformed file is a whole another can of worms a good parser should know how to deal with but here it doesn&#x27;t even format compliant.<p>I think they wanted to demonstrate that their work can slice a stream by offset table, in a declarative fashion. It is a useful property. I think they would&#x27;ve better picked OTF&#x2F;TTF for demonstration of this particular feature.</div><br/></div></div></div></div><div id="41212278" class="c"><input type="checkbox" id="c-41212278" checked=""/><div class="controls bullet"><span class="by">airstrike</span><span>|</span><a href="#41211674">parent</a><span>|</span><a href="#41211805">prev</a><span>|</span><a href="#41213111">next</a><span>|</span><label class="collapse" for="c-41212278">[-]</label><label class="expand" for="c-41212278">[4 more]</label></div><br/><div class="children"><div class="content">Sounds to me like that&#x27;s more of an issue with the PDF specification than with the work presented in the paper, in which case that&#x27;s hardly the metric by which we should measure its merit.</div><br/><div id="41212559" class="c"><input type="checkbox" id="c-41212559" checked=""/><div class="controls bullet"><span class="by">pointlessone</span><span>|</span><a href="#41211674">root</a><span>|</span><a href="#41212278">parent</a><span>|</span><a href="#41213111">next</a><span>|</span><label class="collapse" for="c-41212559">[-]</label><label class="expand" for="c-41212559">[3 more]</label></div><br/><div class="children"><div class="content">I’m not saying PDF is a good format. I’m pointing out that they’ve made a poor choice going for PDF. There are other formats they could’ve used to demonstrate this specific technique. Like OTF&#x2F;TTF which is a more traditional binary format with a whole range of approaches, including offset tables.</div><br/><div id="41212862" class="c"><input type="checkbox" id="c-41212862" checked=""/><div class="controls bullet"><span class="by">airstrike</span><span>|</span><a href="#41211674">root</a><span>|</span><a href="#41212559">parent</a><span>|</span><a href="#41213090">next</a><span>|</span><label class="collapse" for="c-41212862">[-]</label><label class="expand" for="c-41212862">[1 more]</label></div><br/><div class="children"><div class="content">The abstract says &quot;We have used IPGs to specify a number of file formats including ZIP, ELF, GIF, PE, and part of PDF&quot;. Sounds to me like they threw PDF in there to test the limits of the technique _after_ using it on a bunch of other unrelated formats.<p>In fact, the authors state &quot;PDF is picked because it is the most complicated format to our knowledge, which requires some unusual parser behaviors. We did not implement a full PDF parser due to its complexity, but a functional subset to show how IPGs can support some interesting features (...) PDF is a more complicated format. Our IPG grammar for PDF does not support full PDF parsing but focuses on how some interesting features in PDF are supported. As a result, the parser generated from our IPG PDF grammar can parse simple PDF files&quot;</div><br/></div></div><div id="41213090" class="c"><input type="checkbox" id="c-41213090" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#41211674">root</a><span>|</span><a href="#41212559">parent</a><span>|</span><a href="#41212862">prev</a><span>|</span><a href="#41213111">next</a><span>|</span><label class="collapse" for="c-41213090">[-]</label><label class="expand" for="c-41213090">[1 more]</label></div><br/><div class="children"><div class="content">Kinda sounds like you didn’t read what they actually wrote in its entirety but have still taken the first possible chance to jump in and quite aggressively tell them how what they’re doing is wrong.</div><br/></div></div></div></div></div></div></div></div><div id="41213111" class="c"><input type="checkbox" id="c-41213111" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#41211674">prev</a><span>|</span><a href="#41213598">next</a><span>|</span><label class="collapse" for="c-41213111">[-]</label><label class="expand" for="c-41213111">[1 more]</label></div><br/><div class="children"><div class="content">Snippets from the summary about the most promising aspects<p>&gt; With attributes and intervals, IPGs allow the specification of data dependence as well as the dependence between control and data.<p>&gt; Moreover, parser termination checking becomes possible.<p>&gt; To further utilize the idea of intervals, an interval-based, monadic parser combinator library is proposed.<p>This sounds like a well-behaved variant.  Adding local attribute references simplifies the grammar and is tractably implemented.<p>This might support classifying and implementing formats by severability + composability, i.e., whether you can parse one part at the same time as another, or at least find&#x2F;prioritize precursor structures like indexes.<p>The yet-unaddressed streaming case is most interesting:<p>&gt; We can first have an analysis that determines if it is possible to generate a stream parser from an IPG: within each production rule, it checks if the attribute dependency is only from left to right. After this analysis, a stream parser can be generated to parse in a bottom-up way<p>For parallel composition, you&#x27;d want to distinguish the attributes required by the consuming&#x2F;combining (whole-assembly) operation from those only used in the part-parsing operation to plan the interfaces.<p>Aside from their mid-level parser-combinators, you might want some binary-specific lowering operations (as they did with Int) specific to your target architecture and binary encodings.<p>For the overall architecture it seems wise for flatbuffers et al to expressly avoid unbounded hierarchy. Perhaps three phases (prelude+split, process, merge+finish) would be more manageable than fully-general dependency stages possible with arbitrary attribute dependencies.<p>I would hate to see a parser technology discounted because it doesn&#x27;t handle the crap of PDF or even MS xml.  I&#x27;d be very interested in a language that could constrain&#x2F;direct us to more performant data formats, particularly for data archives like genomics or semantics where an archive-resident index can avoid full-archive scans in most use-cases.</div><br/></div></div><div id="41213598" class="c"><input type="checkbox" id="c-41213598" checked=""/><div class="controls bullet"><span class="by">khaledh</span><span>|</span><a href="#41213111">prev</a><span>|</span><a href="#41211355">next</a><span>|</span><label class="collapse" for="c-41213598">[-]</label><label class="expand" for="c-41213598">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of binarylang[0] (a library for binary parsing written in Nim). I used it in a small hobby project to parse ELF binaries in a declarative manner (well just the headers + string table)[1].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;sealmove&#x2F;binarylang">https:&#x2F;&#x2F;github.com&#x2F;sealmove&#x2F;binarylang</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;khaledh&#x2F;elfdump&#x2F;blob&#x2F;master&#x2F;elfparse.nim">https:&#x2F;&#x2F;github.com&#x2F;khaledh&#x2F;elfdump&#x2F;blob&#x2F;master&#x2F;elfparse.nim</a></div><br/></div></div><div id="41211355" class="c"><input type="checkbox" id="c-41211355" checked=""/><div class="controls bullet"><span class="by">andrybak</span><span>|</span><a href="#41213598">prev</a><span>|</span><a href="#41211804">next</a><span>|</span><label class="collapse" for="c-41211355">[-]</label><label class="expand" for="c-41211355">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We have used IPGs to specify a number of file formats including ZIP, ELF, GIF, PE, and part of PDF<p>For PDF, that&#x27;s fair. Video &quot;Types of PDF - Computerphile&quot; covers this: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=K7oxZCgO1dY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=K7oxZCgO1dY</a></div><br/><div id="41211769" class="c"><input type="checkbox" id="c-41211769" checked=""/><div class="controls bullet"><span class="by">jgalt212</span><span>|</span><a href="#41211355">parent</a><span>|</span><a href="#41211804">next</a><span>|</span><label class="collapse" for="c-41211769">[-]</label><label class="expand" for="c-41211769">[1 more]</label></div><br/><div class="children"><div class="content">I&quot;ll watch any and all Professor Brailsford videos.</div><br/></div></div></div></div><div id="41211804" class="c"><input type="checkbox" id="c-41211804" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#41211355">prev</a><span>|</span><a href="#41213476">next</a><span>|</span><label class="collapse" for="c-41211804">[-]</label><label class="expand" for="c-41211804">[2 more]</label></div><br/><div class="children"><div class="content">Is this really a new thing? It feels like they&#x27;ve just crammed a sliver of the same bog-standard parsing we&#x27;ve been doing for decades back into the CFG.<p>I guess that&#x27;s good for preventing off-by-one-based parsing errors, but surely there&#x27;s prior art from long ago.</div><br/></div></div><div id="41214450" class="c"><input type="checkbox" id="c-41214450" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#41213476">prev</a><span>|</span><a href="#41211673">next</a><span>|</span><label class="collapse" for="c-41214450">[-]</label><label class="expand" for="c-41214450">[1 more]</label></div><br/><div class="children"><div class="content">So cool to see that binary format parsing is finally being formalized.<p>I once asked a question related to this on the computer science stack overflow:<p><a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;q&#x2F;60718" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;q&#x2F;60718</a><p>Would someone like to add this as an answer?</div><br/></div></div><div id="41211673" class="c"><input type="checkbox" id="c-41211673" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41214450">prev</a><span>|</span><a href="#41211719">next</a><span>|</span><label class="collapse" for="c-41211673">[-]</label><label class="expand" for="c-41211673">[4 more]</label></div><br/><div class="children"><div class="content">&gt; ZIP files that are prefixed by random garbage can still be extracted by unzip but fail to be recognized by a parser that conforms to the format specification<p>To be fair, the ability to stick a ZIP file at the end of any other kind of file enables all sorts of neat tricks (like the old self-extracting zips).</div><br/><div id="41212310" class="c"><input type="checkbox" id="c-41212310" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41211673">parent</a><span>|</span><a href="#41211719">next</a><span>|</span><label class="collapse" for="c-41212310">[-]</label><label class="expand" for="c-41212310">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because zip files are read from the end.</div><br/><div id="41212582" class="c"><input type="checkbox" id="c-41212582" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#41211673">root</a><span>|</span><a href="#41212310">parent</a><span>|</span><a href="#41211719">next</a><span>|</span><label class="collapse" for="c-41212582">[-]</label><label class="expand" for="c-41212582">[2 more]</label></div><br/><div class="children"><div class="content">And this is in fact what the spec lays out, contrary to the quote from the paper. The PK header is a convention. Conforming parsers don&#x27;t require it, but lazy implementations often do. This has led to more than one security incident over the years.</div><br/><div id="41212646" class="c"><input type="checkbox" id="c-41212646" checked=""/><div class="controls bullet"><span class="by">bloatfish</span><span>|</span><a href="#41211673">root</a><span>|</span><a href="#41212582">parent</a><span>|</span><a href="#41211719">next</a><span>|</span><label class="collapse" for="c-41212646">[-]</label><label class="expand" for="c-41212646">[1 more]</label></div><br/><div class="children"><div class="content">Yeah and PK is the signature <i>per record</i> - it&#x27;s not a file header. Did these guys read the format specification at all?</div><br/></div></div></div></div></div></div></div></div><div id="41211719" class="c"><input type="checkbox" id="c-41211719" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#41211673">prev</a><span>|</span><a href="#41211161">next</a><span>|</span><label class="collapse" for="c-41211719">[-]</label><label class="expand" for="c-41211719">[3 more]</label></div><br/><div class="children"><div class="content">How about MS office document ?</div><br/><div id="41211742" class="c"><input type="checkbox" id="c-41211742" checked=""/><div class="controls bullet"><span class="by">tithe</span><span>|</span><a href="#41211719">parent</a><span>|</span><a href="#41211859">next</a><span>|</span><label class="collapse" for="c-41211742">[-]</label><label class="expand" for="c-41211742">[1 more]</label></div><br/><div class="children"><div class="content">DOCX, PPTX, and XLSX Microsoft Office files are actually ZIP archives (which the paper addresses).  You can append a &quot;.zip&quot; extension onto the end of them and explore.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Office_Open_XML" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Office_Open_XML</a></div><br/></div></div><div id="41211859" class="c"><input type="checkbox" id="c-41211859" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#41211719">parent</a><span>|</span><a href="#41211742">prev</a><span>|</span><a href="#41211161">next</a><span>|</span><label class="collapse" for="c-41211859">[-]</label><label class="expand" for="c-41211859">[1 more]</label></div><br/><div class="children"><div class="content">The old office binary formats are basically a FAT file system containing streams of unremarkable records. Knowing what those records do is the hard part!</div><br/></div></div></div></div></div></div></div></div></div></body></html>