<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731747659969" as="style"/><link rel="stylesheet" href="styles.css?v=1731747659969"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.bleepingcomputer.com/news/security/hackers-now-use-zip-file-concatenation-to-evade-detection/">Hackers use ZIP file concatenation to evade detection</a>Â <span class="domain">(<a href="https://www.bleepingcomputer.com">www.bleepingcomputer.com</a>)</span></div><div class="subtext"><span>sandwichsphinx</span> | <span>52 comments</span></div><br/><div><div id="42152909" class="c"><input type="checkbox" id="c-42152909" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#42153314">next</a><span>|</span><label class="collapse" for="c-42152909">[-]</label><label class="expand" for="c-42152909">[14 more]</label></div><br/><div class="children"><div class="content">From a security perspective, and as a programmer, I&#x27;ve never liked ZIP files precisely because there are <i>two</i> mechanisms to identify the contents, the per-file header and the central directory. When you&#x27;re defining a format, protocol, or w&#x27;ever, ideally there <i>should</i> be a single source of truth, a single valid &amp; useable parse, etc; basically, the structure of the data or process should be intrinsically constraining. There shouldn&#x27;t be a pathway for multiple implementations to produce different functional results, and ZIP archives are in my mind the archetype for getting this wrong. tar files aren&#x27;t ideal, but in the abstract (ignoring issues with long file names) they don&#x27;t have this problem. (tar files don&#x27;t support random access, either, but better to rely on something suboptimal than something that&#x27;s fundamentally broken.)<p>A similar security problem, though not as fundamentally baked into the format, is MIME parsing. The header section is supposed to be delimited from the body by an empty line (likewise for nested entities). But what if it&#x27;s not? For better or worse, Sendmail was tolerant of the absence of an empty line and treated as headers everything up to the first line that didn&#x27;t parse as a header or header continuation.[1] Later systems, like Postfix, originally copied this behavior. But Microsoft Exchange and Outlook are even more tolerant, yet in a much more horrendous way, by parsing as a header anything that looks like a Content-Type or related header immediately <i>after</i> the first empty line. They have similar hacks for other, similar violations. So today, depending on the receiving software, you can send messages that appear differently, including having different attachments. It&#x27;s a security nightmare!<p>I not a Postel&#x27;s Law hater, but ZIP archives and Microsoft&#x27;s MIME parsing behaviors are just egregiously wrong and indefensible. And even if you think the Robustness Principle is inherently bad policy, you still have to design your formats, protocols, and systems to be as intrinsically constraining as possible. You can&#x27;t rely on vendors adhering to a MUST rule in an RFC, unless it&#x27;s unquestioningly crystal clear what the repercussions will be--everybody else will (because it&#x27;s the natural and convenient thing to do) reject your output as trash and drop it on the floor immediately so violations never have a chance to get a foothold.<p>[1] MTAs don&#x27;t necessarily need to care about MIME parsing, but Sendmail eventually gained features where parsing message contents mattered, setting the de facto norm (for those paying attention) until Microsoft came along.</div><br/><div id="42153922" class="c"><input type="checkbox" id="c-42153922" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#42152909">parent</a><span>|</span><a href="#42153990">next</a><span>|</span><label class="collapse" for="c-42153922">[-]</label><label class="expand" for="c-42153922">[10 more]</label></div><br/><div class="children"><div class="content">The central directory allows zip archives to be split across multiple files on separate media without needing to read them all in for selective extraction. Not particularly useful today but invaluable in the sneakernet era with floppies.</div><br/><div id="42154324" class="c"><input type="checkbox" id="c-42154324" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42153922">parent</a><span>|</span><a href="#42153990">next</a><span>|</span><label class="collapse" for="c-42154324">[-]</label><label class="expand" for="c-42154324">[9 more]</label></div><br/><div class="children"><div class="content">Still useful today.<p>Try to transmit a 100G file through any service is usually a pain especially if one end has non-stable Internet.</div><br/><div id="42154890" class="c"><input type="checkbox" id="c-42154890" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42154324">parent</a><span>|</span><a href="#42154892">next</a><span>|</span><label class="collapse" for="c-42154890">[-]</label><label class="expand" for="c-42154890">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very bad way of solving that issue. If transmission is a problem, either use a proper retry-friendly protocol (such as bittorrent) or split the file. Using hacks on the data format just leads to additional pain</div><br/><div id="42155000" class="c"><input type="checkbox" id="c-42155000" checked=""/><div class="controls bullet"><span class="by">meehai</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42154890">parent</a><span>|</span><a href="#42154892">next</a><span>|</span><label class="collapse" for="c-42155000">[-]</label><label class="expand" for="c-42155000">[3 more]</label></div><br/><div class="children"><div class="content">couldn&#x27;t agree more!<p>We need to separate and design modules as unitary as possible:<p>- zip should ARCHIVE&#x2F;COMPRESS, i.e. reduce the file size and create a single file from the file system point of view. The complexity should go in the compression algorithm.<p>- Sharding&#x2F;sending multiple coherent pieces of the same file (zip or not) is a different module and should be handled by specialized and agnostic protocols that do this like the ones you mentioned.<p>People are always doing tools that handle 2 or more use cases instead of following the UNIX principle to create generic and good single respectability tools that can be combined together (thus allowing a &#x27;whitelist&#x27; of combinations which is safe). Quite frankly it&#x27;s annoying and very often leads to issues such as this that weren&#x27;t even thought in the original design because of the exponential problem of combining tools together.</div><br/><div id="42155151" class="c"><input type="checkbox" id="c-42155151" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42155000">parent</a><span>|</span><a href="#42154892">next</a><span>|</span><label class="collapse" for="c-42155151">[-]</label><label class="expand" for="c-42155151">[2 more]</label></div><br/><div class="children"><div class="content">Well, 1) is zip with compression into single file, 2) is zip <i>without</i> compression into multiple files. You can also combine the two. And in all cases, you need a container format.<p>The tasks are related enough that I don&#x27;t really see the problem here.</div><br/><div id="42155187" class="c"><input type="checkbox" id="c-42155187" checked=""/><div class="controls bullet"><span class="by">meehai</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42155151">parent</a><span>|</span><a href="#42154892">next</a><span>|</span><label class="collapse" for="c-42155187">[-]</label><label class="expand" for="c-42155187">[1 more]</label></div><br/><div class="children"><div class="content">I meant that they should be separate tools that can be piped together.
For example: you have 1 directory of many files (1Gb in total)<p>`zip out.zip dir&#x2F;`<p>This results in a single out.zip file that is, let&#x27;s say 500Mb (1:2 compression)<p>If you want to shard it, you have a separate tool, let&#x27;s call it `shard` that works on any type of byte streams:<p>`shard -I out.zip -O out_shards&#x2F; --shard_size 100Mb`<p>This results in `out_shards&#x2F;1.shard, ..., out_shards&#x2F;5.shard`, each of 100Mb each.<p>And then you have the opposite: `unshard` (back into 1 zip file) and `unzip`.<p>No need for &#x27;sharding&#x27; to exist as a feature in the zip utility.<p>And... if you want only the shard from the get go without the original 1 file archive, you can do something like:<p>`zip dir&#x2F; | shard -O out_shards&#x2F;`<p>Now, these can be copied to the floppy disks (as discussed above) or sent via the network etc. The main thing here is that the sharding tool works on bytes only (doesn&#x27;t know if it&#x27;s an mp4 file, a zip file, a txt file etc.) and does no compression and the zip tool does no sharding but optimizes compression.</div><br/></div></div></div></div></div></div></div></div><div id="42154892" class="c"><input type="checkbox" id="c-42154892" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42154324">parent</a><span>|</span><a href="#42154890">prev</a><span>|</span><a href="#42154383">next</a><span>|</span><label class="collapse" for="c-42154892">[-]</label><label class="expand" for="c-42154892">[3 more]</label></div><br/><div class="children"><div class="content">If the point is being able to access some files even if the whole archive isnât uploaded, why not create 100 separate archives each with a partial set of files?<p>Or use a protocol that supports resume of partial transmits.</div><br/><div id="42155361" class="c"><input type="checkbox" id="c-42155361" checked=""/><div class="controls bullet"><span class="by">ZoomZoomZoom</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42154892">parent</a><span>|</span><a href="#42155329">next</a><span>|</span><label class="collapse" for="c-42155361">[-]</label><label class="expand" for="c-42155361">[1 more]</label></div><br/><div class="children"><div class="content">This carries the information that all those files are a pack in an inseparable and immutable way, contrary to encoding that in the archive&#x27;s name or via some parallel channel.</div><br/></div></div><div id="42155329" class="c"><input type="checkbox" id="c-42155329" checked=""/><div class="controls bullet"><span class="by">rawling</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42154892">parent</a><span>|</span><a href="#42155361">prev</a><span>|</span><a href="#42154383">next</a><span>|</span><label class="collapse" for="c-42155329">[-]</label><label class="expand" for="c-42155329">[1 more]</label></div><br/><div class="children"><div class="content">Presumably it compresses better if it&#x27;s all one archive?</div><br/></div></div></div></div><div id="42154383" class="c"><input type="checkbox" id="c-42154383" checked=""/><div class="controls bullet"><span class="by">SubiculumCode</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42154324">parent</a><span>|</span><a href="#42154892">prev</a><span>|</span><a href="#42153990">next</a><span>|</span><label class="collapse" for="c-42154383">[-]</label><label class="expand" for="c-42154383">[1 more]</label></div><br/><div class="children"><div class="content">I recently had to do this with about 700Gb, and yeah OneDrive hated that. I ended up concatenating tars together.</div><br/></div></div></div></div></div></div><div id="42153990" class="c"><input type="checkbox" id="c-42153990" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#42152909">parent</a><span>|</span><a href="#42153922">prev</a><span>|</span><a href="#42153375">next</a><span>|</span><label class="collapse" for="c-42153990">[-]</label><label class="expand" for="c-42153990">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you understand the reason for the ZIP archive file design.<p>Back in the late 1980s, backup media for consumers was limited to mostly floppy disks, some users had tape&#x2F;another hard disk.<p>Say you had a variable number of files to compress and write out to a ZIP archive.<p>IF you write out the central directory first, followed by all the individually possibly compressed and&#x2F;or encrypted files, you&#x27;d have to calculate all the files to be archived, process them (compress and&#x2F;or encrypt), write them out, then go back and update the info for the actual compressed values and offsets for the ZIP local entries.<p>Now if you wanted to add files to the ZIP archive, the central directory will grow and push the following individual compressed&#x2F;encrypted files further out and you&#x27;ll have to update ALL the central directory entries since each entry includes an offset from the beginning of the disk - if the archive does not span multiple disks, this offset is from the start of the ZIP archive file.<p>So that&#x27;s one reason for why the ZIP central directory is placed at the end of the ZIP archive file. If you&#x27;re streaming the output from a ZIP program, then placing the ZIP central dir at the start of the file is a non-starter since you can&#x27;t rewind a stream to update the ZIP central directory entries.<p>Why do some programs ignore the ZIP central directory as the ONE source of truth?<p>Before SSDs and their minimal seek latency, coders discovered that scanning the ZIP local entries to be a faster way to build up the ZIP archive entries, otherwise you&#x27;re forced to seek all the way to the end of a ZIP archive and work backwards to locate the central directory and proceed accordingly.<p>If the central directory in the ZIP archive is corrupted or missing, the user could still recover the data for the individual files (if all the ZIP local entries are intact). In this case, ignoring the ZIP central dir and scanning sequentially for ZIP local entries is REQUIRED.<p>The fault here is the security scanners. There&#x27;s never been any guarantee that the ONLY data in the ZIP archive was only valid ZIP local file entries followed by the ZIP central directory. Between ZIP local file entries, one can place any data. Unzip programs don&#x27;t care.</div><br/><div id="42154566" class="c"><input type="checkbox" id="c-42154566" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42152909">root</a><span>|</span><a href="#42153990">parent</a><span>|</span><a href="#42153375">next</a><span>|</span><label class="collapse" for="c-42154566">[-]</label><label class="expand" for="c-42154566">[1 more]</label></div><br/><div class="children"><div class="content">The more general principle is that single source of truth is not ideal for data storage where you&#x27;re worried about corruption. There&#x27;s a backup MBR on your hard disk at the end, your ext4 filesystem has <i>many</i> backups of your superblock.<p>When it comes to user data the natural programmer instinct for &quot;is exactly what I expect or fail&quot; which is typically good design, falls to pragmatism where try your hardest to not lose data, partial results are better then nothing, is desired.</div><br/></div></div></div></div><div id="42153375" class="c"><input type="checkbox" id="c-42153375" checked=""/><div class="controls bullet"><span class="by">failbuffer</span><span>|</span><a href="#42152909">parent</a><span>|</span><a href="#42153990">prev</a><span>|</span><a href="#42153314">next</a><span>|</span><label class="collapse" for="c-42153375">[-]</label><label class="expand" for="c-42153375">[1 more]</label></div><br/><div class="children"><div class="content">In a similar vein, HTTP header smuggling attacks exploit differences in header parsing. For instance, a reverse proxy and a web server might handle repetition of headers or the presence of whitespace differently.</div><br/></div></div></div></div><div id="42153314" class="c"><input type="checkbox" id="c-42153314" checked=""/><div class="controls bullet"><span class="by">_pdp_</span><span>|</span><a href="#42152909">prev</a><span>|</span><a href="#42103034">next</a><span>|</span><label class="collapse" for="c-42153314">[-]</label><label class="expand" for="c-42153314">[5 more]</label></div><br/><div class="children"><div class="content">This attack vector has been known for at least 17 years, if not longer.<p><a href="https:&#x2F;&#x2F;gnucitizen.org&#x2F;blog&#x2F;java-jar-attacks-and-features&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gnucitizen.org&#x2F;blog&#x2F;java-jar-attacks-and-features&#x2F;</a>
<a href="https:&#x2F;&#x2F;gnucitizen.org&#x2F;blog&#x2F;gifars-and-other-issues&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gnucitizen.org&#x2F;blog&#x2F;gifars-and-other-issues&#x2F;</a></div><br/><div id="42154136" class="c"><input type="checkbox" id="c-42154136" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42153314">parent</a><span>|</span><a href="#42153917">next</a><span>|</span><label class="collapse" for="c-42154136">[-]</label><label class="expand" for="c-42154136">[2 more]</label></div><br/><div class="children"><div class="content">17 years? We played tricks with zip bombs that used this approach during 90-s.</div><br/><div id="42155208" class="c"><input type="checkbox" id="c-42155208" checked=""/><div class="controls bullet"><span class="by">shreddit</span><span>|</span><a href="#42153314">root</a><span>|</span><a href="#42154136">parent</a><span>|</span><a href="#42153917">next</a><span>|</span><label class="collapse" for="c-42155208">[-]</label><label class="expand" for="c-42155208">[1 more]</label></div><br/><div class="children"><div class="content">Yeah the 90s are just 17 yeâ¦ oh no Iâm old</div><br/></div></div></div></div><div id="42153917" class="c"><input type="checkbox" id="c-42153917" checked=""/><div class="controls bullet"><span class="by">tedk-42</span><span>|</span><a href="#42153314">parent</a><span>|</span><a href="#42154136">prev</a><span>|</span><a href="#42103034">next</a><span>|</span><label class="collapse" for="c-42153917">[-]</label><label class="expand" for="c-42153917">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you.<p>I&#x27;ve evaded all sorts of scanning tools by base64 encoding data (i.e. binary data) to and copy pasting the text from insecure to highly secured environments.<p>At the end of the day, these malware databases rely on hashing and detecting for known bad hashes and there are lots of command line tools to help get over that sort of thing like zip&#x2F;tar etc.</div><br/><div id="42155085" class="c"><input type="checkbox" id="c-42155085" checked=""/><div class="controls bullet"><span class="by">athrowaway3z</span><span>|</span><a href="#42153314">root</a><span>|</span><a href="#42153917">parent</a><span>|</span><a href="#42103034">next</a><span>|</span><label class="collapse" for="c-42155085">[-]</label><label class="expand" for="c-42155085">[1 more]</label></div><br/><div class="children"><div class="content">rot13 must be outlawed for its use by cyber-criminals!</div><br/></div></div></div></div></div></div><div id="42103034" class="c"><input type="checkbox" id="c-42103034" checked=""/><div class="controls bullet"><span class="by">avidiax</span><span>|</span><a href="#42153314">prev</a><span>|</span><a href="#42153974">next</a><span>|</span><label class="collapse" for="c-42103034">[-]</label><label class="expand" for="c-42103034">[3 more]</label></div><br/><div class="children"><div class="content">This is sometimes used non-maliciously to concatenate zipped eBooks to a JPEG of the cover art. 4Chan&#x27;s &#x2F;lit&#x2F; board used to do this, but I can&#x27;t find any reference to it anymore.<p><a href="https:&#x2F;&#x2F;entropymine.wordpress.com&#x2F;2018&#x2F;11&#x2F;01&#x2F;about-that-jpeg-zip-shakespeare-hybrid-file&#x2F;" rel="nofollow">https:&#x2F;&#x2F;entropymine.wordpress.com&#x2F;2018&#x2F;11&#x2F;01&#x2F;about-that-jpeg...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;Anti-Forensics&#x2F;tucker">https:&#x2F;&#x2F;github.com&#x2F;Anti-Forensics&#x2F;tucker</a></div><br/><div id="42153901" class="c"><input type="checkbox" id="c-42153901" checked=""/><div class="controls bullet"><span class="by">theoreticalmal</span><span>|</span><a href="#42103034">parent</a><span>|</span><a href="#42154265">next</a><span>|</span><label class="collapse" for="c-42153901">[-]</label><label class="expand" for="c-42153901">[1 more]</label></div><br/><div class="children"><div class="content">I think the reason itâs not used anymore is because it was used maliciously to share CSAM on other boards and 4chan banned uploading anything that looks like a concatenated zip</div><br/></div></div><div id="42154265" class="c"><input type="checkbox" id="c-42154265" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#42103034">parent</a><span>|</span><a href="#42153901">prev</a><span>|</span><a href="#42153974">next</a><span>|</span><label class="collapse" for="c-42154265">[-]</label><label class="expand" for="c-42154265">[1 more]</label></div><br/><div class="children"><div class="content">That first read should be an HN post in its own right.</div><br/></div></div></div></div><div id="42153974" class="c"><input type="checkbox" id="c-42153974" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#42103034">prev</a><span>|</span><a href="#42153299">next</a><span>|</span><label class="collapse" for="c-42153974">[-]</label><label class="expand" for="c-42153974">[2 more]</label></div><br/><div class="children"><div class="content">Remember, secure encryption, good compression, and truely random data are indistinguishable.<p>It&#x27;s best to paste that encrypted payload into a JPG with some bullshit magic headers and upload that to a trusted Exfil pivot instead.<p>Or, to get SuperMarioKart.rom to work with your chromeApp-XEMU emulator to play during down-time at work, just rename it to SMB.png, and email it you yourself.</div><br/><div id="42155139" class="c"><input type="checkbox" id="c-42155139" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42153974">parent</a><span>|</span><a href="#42153299">next</a><span>|</span><label class="collapse" for="c-42155139">[-]</label><label class="expand" for="c-42155139">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; Remember, secure encryption, good compression, and truely random data are indistinguishable.
</code></pre>
Yes, and the only reason the bad guys get away with this is the people who trust signature-based scanning at the perimeter to detect all threats.<p>One of the hacks I&#x27;m most proud of in my whole career was when we were doing a proof of concept at an enterprise client we were being deliberately obstructed by the internal IT group due to politics between their boss and the boss who sponsored our POC.  For unrelated trademark-related reasons we were prevented by a third party from having the software on physical media but we had a specific contractual clause agreeing to let us download it for install.  So while we had been contractually engaged to provide this software and we had a strict deadline to prove value, the enterprise IT group were preventing us from actually getting it through the virus-scanning firewall to get it installed. What to do?<p>The scanner looked for the signature of executable or zipped files and blocked them. It would also block any files larger than a certain size. So what I did was write two shell scripts called &quot;shred&quot; and &quot;unshred&quot;.  &quot;Shred&quot; would take any files you gave it as input, make them into a tarball, encrypt that to confuse the virus scanner and then split it up into chunks small enough to get through the firewall, and &quot;unshred&quot; would reverse this.  This almost worked, but I found that the first chunk was always failing to transmit through the firewall. The scanner noticed some signature that openssl was putting at the front of the file when encrypting it.  The solution? Change shred to add 1k of random noise to the front of the file and unshred to remove it.<p>Job done.  Our files were transmitted perfectly (I got the scripts to check the md5sum on both sides to be sure), and though the process was slow, we could continue.<p>The funny thing was the POC was a bake-off versus another (more established) vendor and they couldn&#x27;t get their software installed until they had done a couple of weeks of trench warfare with enterprise IT. &quot;To keep things fair&quot; the people organising the POC decided to delay to let them have time to install, and eventually the person blocking us from installing was persuaded to change their mind (by being fired), so &quot;shred&quot; and &quot;unshred&quot; could be retired.</div><br/></div></div></div></div><div id="42153299" class="c"><input type="checkbox" id="c-42153299" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42153974">prev</a><span>|</span><a href="#42152848">next</a><span>|</span><label class="collapse" for="c-42153299">[-]</label><label class="expand" for="c-42153299">[6 more]</label></div><br/><div class="children"><div class="content">Related, my two favourite ZIP parser issues:<p><a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1534483" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1534483</a> &quot;Ambiguous zip parsing allows hiding add-on files from linter and reviewers&quot;<p><a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40082940" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40082940</a> &quot;Security: Crazy Linker on Android allows modification of Chrome APK without breaking signature&quot;<p>The big problem with the ZIP format is that although the &quot;spec&quot; says what a ZIP file looks like, it does not tell you in concrete terms how to parse it, leading to all sorts of ambiguities and divergent implementations. Someone needs to write a &quot;strict ZIP&quot; spec that has explicit and well-defined parsing rules, and then we need to get every existing ZIP implementation to agree to follow said spec.</div><br/><div id="42153481" class="c"><input type="checkbox" id="c-42153481" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#42153299">parent</a><span>|</span><a href="#42152848">next</a><span>|</span><label class="collapse" for="c-42153481">[-]</label><label class="expand" for="c-42153481">[5 more]</label></div><br/><div class="children"><div class="content">Or: better yet, just use an archive format for archival and a compression layer for compression.  Don&#x27;t use zip at all.</div><br/><div id="42154068" class="c"><input type="checkbox" id="c-42154068" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42153299">root</a><span>|</span><a href="#42153481">parent</a><span>|</span><a href="#42152848">next</a><span>|</span><label class="collapse" for="c-42154068">[-]</label><label class="expand" for="c-42154068">[4 more]</label></div><br/><div class="children"><div class="content">What non-compressing archive format would you suggest? tar doesn&#x27;t support random access which is a non-starter for many use cases.</div><br/><div id="42154560" class="c"><input type="checkbox" id="c-42154560" checked=""/><div class="controls bullet"><span class="by">acka</span><span>|</span><a href="#42153299">root</a><span>|</span><a href="#42154068">parent</a><span>|</span><a href="#42154280">next</a><span>|</span><label class="collapse" for="c-42154560">[-]</label><label class="expand" for="c-42154560">[2 more]</label></div><br/><div class="children"><div class="content">DAR (Disk ARchiver)[1] looks to be a good alternative. It supports random access, encryption, and individual file compression within the archive.<p>[1] <a href="http:&#x2F;&#x2F;dar.linux.free.fr&#x2F;" rel="nofollow">http:&#x2F;&#x2F;dar.linux.free.fr&#x2F;</a></div><br/><div id="42154872" class="c"><input type="checkbox" id="c-42154872" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42153299">root</a><span>|</span><a href="#42154560">parent</a><span>|</span><a href="#42154280">next</a><span>|</span><label class="collapse" for="c-42154872">[-]</label><label class="expand" for="c-42154872">[1 more]</label></div><br/><div class="children"><div class="content">That seems counter to GP&#x27;s suggestion of doing compression at a separate layer</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42152848" class="c"><input type="checkbox" id="c-42152848" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#42153299">prev</a><span>|</span><a href="#42102949">next</a><span>|</span><label class="collapse" for="c-42152848">[-]</label><label class="expand" for="c-42152848">[1 more]</label></div><br/><div class="children"><div class="content">WinRAR does it right, 7zip and Windows Explorer do it wrong according to <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;ZIP_(file_format)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;ZIP_(file_format)</a><p>&gt; only files specified in the central directory at the end of the file are valid. Scanning a ZIP file for local file headers is invalid (except in the case of corrupted archives)</div><br/></div></div><div id="42102949" class="c"><input type="checkbox" id="c-42102949" checked=""/><div class="controls bullet"><span class="by">kencausey</span><span>|</span><a href="#42152848">prev</a><span>|</span><a href="#42153222">next</a><span>|</span><label class="collapse" for="c-42102949">[-]</label><label class="expand" for="c-42102949">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><a href="https:&#x2F;&#x2F;isc.sans.edu&#x2F;forums&#x2F;diary&#x2F;zipdump+Evasive+ZIP+Concatenation&#x2F;31426&#x2F;" rel="nofollow">https:&#x2F;&#x2F;isc.sans.edu&#x2F;forums&#x2F;diary&#x2F;zipdump+Evasive+ZIP+Concat...</a><p><a href="https:&#x2F;&#x2F;isc.sans.edu&#x2F;forums&#x2F;diary&#x2F;zipdump+PKZIP+Records&#x2F;31428&#x2F;" rel="nofollow">https:&#x2F;&#x2F;isc.sans.edu&#x2F;forums&#x2F;diary&#x2F;zipdump+PKZIP+Records&#x2F;3142...</a></div><br/></div></div><div id="42153222" class="c"><input type="checkbox" id="c-42153222" checked=""/><div class="controls bullet"><span class="by">waltbosz</span><span>|</span><a href="#42102949">prev</a><span>|</span><a href="#42106513">next</a><span>|</span><label class="collapse" for="c-42153222">[-]</label><label class="expand" for="c-42153222">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done similar stuff. Concat a zip (that keeps throwing false positives) to a jpg and scanners will treat it like a jpg. Then write a script that chops off the jpg to access the zip. All this so I could automate a web a
app deploy.</div><br/><div id="42153862" class="c"><input type="checkbox" id="c-42153862" checked=""/><div class="controls bullet"><span class="by">ttyprintk</span><span>|</span><a href="#42153222">parent</a><span>|</span><a href="#42106513">next</a><span>|</span><label class="collapse" for="c-42153862">[-]</label><label class="expand" for="c-42153862">[1 more]</label></div><br/><div class="children"><div class="content">Or attach a zip through Exhange</div><br/></div></div></div></div><div id="42106513" class="c"><input type="checkbox" id="c-42106513" checked=""/><div class="controls bullet"><span class="by">486sx33</span><span>|</span><a href="#42153222">prev</a><span>|</span><a href="#42153610">next</a><span>|</span><label class="collapse" for="c-42106513">[-]</label><label class="expand" for="c-42106513">[8 more]</label></div><br/><div class="children"><div class="content">Encrypted ZIP files have long been a way to evade any sort of malware detection during transmission.</div><br/><div id="42152911" class="c"><input type="checkbox" id="c-42152911" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#42106513">parent</a><span>|</span><a href="#42152526">next</a><span>|</span><label class="collapse" for="c-42152911">[-]</label><label class="expand" for="c-42152911">[2 more]</label></div><br/><div class="children"><div class="content">you dont need to even encrypt zip, since encrypted ZIP file can trigger tripwires during transmission.<p>unencrypted zip, but using .docx or .xlsx format is the way to go (the best way is to hide inside one of the openxml tags or xml comments )</div><br/><div id="42153958" class="c"><input type="checkbox" id="c-42153958" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#42106513">root</a><span>|</span><a href="#42152911">parent</a><span>|</span><a href="#42152526">next</a><span>|</span><label class="collapse" for="c-42153958">[-]</label><label class="expand" for="c-42153958">[1 more]</label></div><br/><div class="children"><div class="content">encode it with enough filler as to reduce its &quot;entropy&quot; :)</div><br/></div></div></div></div><div id="42152526" class="c"><input type="checkbox" id="c-42152526" checked=""/><div class="controls bullet"><span class="by">mmcgaha</span><span>|</span><a href="#42106513">parent</a><span>|</span><a href="#42152911">prev</a><span>|</span><a href="#42152743">next</a><span>|</span><label class="collapse" for="c-42152526">[-]</label><label class="expand" for="c-42152526">[4 more]</label></div><br/><div class="children"><div class="content">I doubt it still works but things I needed to get through email I would embed in word documents.</div><br/><div id="42152672" class="c"><input type="checkbox" id="c-42152672" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42106513">root</a><span>|</span><a href="#42152526">parent</a><span>|</span><a href="#42152667">next</a><span>|</span><label class="collapse" for="c-42152672">[-]</label><label class="expand" for="c-42152672">[2 more]</label></div><br/><div class="children"><div class="content">Would probably still work.  There&#x27;s just too many formats which makes it very hard for a content blocker to really stop.<p>I pity the programmer that has to decode the 1000 versions of xls to find the binary blob that could be a virus.</div><br/><div id="42154284" class="c"><input type="checkbox" id="c-42154284" checked=""/><div class="controls bullet"><span class="by">telgareith</span><span>|</span><a href="#42106513">root</a><span>|</span><a href="#42152672">parent</a><span>|</span><a href="#42152667">next</a><span>|</span><label class="collapse" for="c-42154284">[-]</label><label class="expand" for="c-42154284">[1 more]</label></div><br/><div class="children"><div class="content">1000? No. There&#x27;s two. Openxml and the original xls. OpenXML can be scanned for issues like any other XML file.<p>Alas, it&#x27;s more difficult to get excel to accept that it shouldn&#x27;t delete leading zeros than it is to check a spreadsheet&#x27;s sus-o-scale.</div><br/></div></div></div></div><div id="42152667" class="c"><input type="checkbox" id="c-42152667" checked=""/><div class="controls bullet"><span class="by">mplewis9z</span><span>|</span><a href="#42106513">root</a><span>|</span><a href="#42152526">parent</a><span>|</span><a href="#42152672">prev</a><span>|</span><a href="#42152743">next</a><span>|</span><label class="collapse" for="c-42152667">[-]</label><label class="expand" for="c-42152667">[1 more]</label></div><br/><div class="children"><div class="content">A modern word document file (.docx) is literally just a Zip archive with a special folder structure, so unless your company is scanning word document contents I canât imagine thereâs any issue.</div><br/></div></div></div></div><div id="42152743" class="c"><input type="checkbox" id="c-42152743" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#42106513">parent</a><span>|</span><a href="#42152526">prev</a><span>|</span><a href="#42153610">next</a><span>|</span><label class="collapse" for="c-42152743">[-]</label><label class="expand" for="c-42152743">[1 more]</label></div><br/><div class="children"><div class="content">Pretty common in corporate world. Email scanner will helpfully drop all manner of useful files between staff, so make an encrypted zip with simple password.</div><br/></div></div></div></div><div id="42153610" class="c"><input type="checkbox" id="c-42153610" checked=""/><div class="controls bullet"><span class="by">mtnGoat</span><span>|</span><a href="#42106513">prev</a><span>|</span><a href="#42154656">next</a><span>|</span><label class="collapse" for="c-42153610">[-]</label><label class="expand" for="c-42153610">[1 more]</label></div><br/><div class="children"><div class="content">Nice remix of an old technique.<p>I remember file packing exes together for fun and profit back in the day.</div><br/></div></div><div id="42154656" class="c"><input type="checkbox" id="c-42154656" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#42153610">prev</a><span>|</span><a href="#42154241">next</a><span>|</span><label class="collapse" for="c-42154656">[-]</label><label class="expand" for="c-42154656">[3 more]</label></div><br/><div class="children"><div class="content">&gt; To defend against concatenated ZIP files, Perception Point suggests that users and organizations use security solutions that support recursive unpacking<p>Yeah, or, you know, just outright reject any ZIP file that doesn&#x27;t start with a file entry, where a forward-scan of the file entries doesn&#x27;t match the result of the central-directory-based walk.<p>There is just so much malicious crud coming in via email that you just want to instantly reject anything that doesn&#x27;t look &#x27;normal&#x27;, and you <i>definitely</i> don&#x27;t want to descend into the madness of recursive unpacking, &#x27;cuz that enables another class of well-known attacks.<p>And no, &quot;but my <i>precious</i> use-case&quot; simply doesn&#x27;t apply, as you&#x27;re practically limited to a whole 50MB per attachment anyway. Sure, &quot;this ZIP file is also a PDF is also a PNG is also a NES cartridge which displays its own MD5&quot; (viz <a href="https:&#x2F;&#x2F;github.com&#x2F;angea&#x2F;pocorgtfo&#x2F;tree&#x2F;master&#x2F;writeups&#x2F;19">https:&#x2F;&#x2F;github.com&#x2F;angea&#x2F;pocorgtfo&#x2F;tree&#x2F;master&#x2F;writeups&#x2F;19</a>) has a place (and should definitely be required study material for anyone writing mail filters!), but business email ain&#x27;t it.</div><br/><div id="42155015" class="c"><input type="checkbox" id="c-42155015" checked=""/><div class="controls bullet"><span class="by">exmadscientist</span><span>|</span><a href="#42154656">parent</a><span>|</span><a href="#42154241">next</a><span>|</span><label class="collapse" for="c-42155015">[-]</label><label class="expand" for="c-42155015">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair, but do realize that sometimes people do have to send around archives from the last century (they got archived for a reason!) or created by eldritch-horror tools that just make weird files (which, sometimes, are the gold masters for certain very important outputs...). And it&#x27;s kind of annoying when these weird but standard files get silently dropped. Especially when that same file went through just fine yesterday, before the duly zealous security settings changed for whatever reason.<p>All I&#x27;m saying is, don&#x27;t drop my stuff silently because your code couldn&#x27;t be arsed to deal with (ugly) standard formats. At least give me a warning (&quot;file of type not scannable&quot; or whatever, the actual words are not so important). And then when I have to yell at the Shanghai people I can yell at them for the correct reasons.</div><br/><div id="42155304" class="c"><input type="checkbox" id="c-42155304" checked=""/><div class="controls bullet"><span class="by">PreInternet01</span><span>|</span><a href="#42154656">root</a><span>|</span><a href="#42155015">parent</a><span>|</span><a href="#42154241">next</a><span>|</span><label class="collapse" for="c-42155304">[-]</label><label class="expand" for="c-42155304">[1 more]</label></div><br/><div class="children"><div class="content">Oh, nothing gets dropped silently, but bounced right back with `550 5.7.1 Message rejected due to content (Attachment refused: MATCH-<i>code</i>)`.<p>And for anything oversized, funny or otherwise non-standard, we offer a very convenient file transfer service.</div><br/></div></div></div></div></div></div><div id="42154485" class="c"><input type="checkbox" id="c-42154485" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#42154241">prev</a><span>|</span><a href="#42153754">next</a><span>|</span><label class="collapse" for="c-42154485">[-]</label><label class="expand" for="c-42154485">[1 more]</label></div><br/><div class="children"><div class="content">Not really a new technique. A long time ago in a galaxy far far away, I needed to get libraries from the internet onto an air-gapped network, and the supported way was to burn them to a disk and bring the disk to be scanned. The scanner never allowed executables so it would always reject the libraries. Can&#x27;t make this up, but the supported way that InfoSec (!!) explained to us to get past the scanner was to take advantage of WinRAR being available on the network, so split the rar archive a bunch of times (foo.r01, foo.r02,...) and the scanner, being unable to parse them nor execute them, would happily rubber-stamp them and pass them along. As long as the process was followed, InfoSec was happy. Thankfully this was before the days when people were really worried about supply chain security.<p>Glad to see this bit of security theater recognized as such.</div><br/></div></div><div id="42153754" class="c"><input type="checkbox" id="c-42153754" checked=""/><div class="controls bullet"><span class="by">unnouinceput</span><span>|</span><a href="#42154485">prev</a><span>|</span><a href="#42152978">next</a><span>|</span><label class="collapse" for="c-42153754">[-]</label><label class="expand" for="c-42153754">[2 more]</label></div><br/><div class="children"><div class="content">Quote: &quot;To defend against concatenated ZIP files, Perception Point suggests that users and organizations use security solutions that support recursive unpacking.&quot;<p>That&#x27;s the worse advice actually. You want the hidden shit to stay there unable to be seen by default programs. That&#x27;s how you got all the crap in Windows mail starting from 90&#x27;s when Outlook started to trying to be &quot;smart&quot; and automatically detect and run additional content. Be dumb and don&#x27;t discover anything, let it rot in there. The only one that should do this is the antivirus, rest of unpackers&#x2F;readers&#x2F;whatever stay dumb.</div><br/><div id="42155131" class="c"><input type="checkbox" id="c-42155131" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42153754">parent</a><span>|</span><a href="#42152978">next</a><span>|</span><label class="collapse" for="c-42155131">[-]</label><label class="expand" for="c-42155131">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The ZIP definition is extremely clear that the contents of the ZIP are defined by the single Central Directory at the end of the file. Local headers are only valid if pointed to by the Central Directory. Any other local headers are just supposed to be treated as garbage, except by software that is specifically meant to recover corrupted ZIP archive&#x27;s contents.</div><br/></div></div></div></div><div id="42152978" class="c"><input type="checkbox" id="c-42152978" checked=""/><div class="controls bullet"><span class="by">pjdkoch</span><span>|</span><a href="#42153754">prev</a><span>|</span><label class="collapse" for="c-42152978">[-]</label><label class="expand" for="c-42152978">[1 more]</label></div><br/><div class="children"><div class="content">Now?</div><br/></div></div></div></div></div></div></div></body></html>