<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726218064028" as="style"/><link rel="stylesheet" href="styles.css?v=1726218064028"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.gtf.io/musings/why-haskell">Why Haskell?</a> <span class="domain">(<a href="https://www.gtf.io">www.gtf.io</a>)</span></div><div class="subtext"><span>mesaoptimizer</span> | <span>370 comments</span></div><br/><div><div id="41520434" class="c"><input type="checkbox" id="c-41520434" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#41519486">next</a><span>|</span><label class="collapse" for="c-41520434">[-]</label><label class="expand" for="c-41520434">[42 more]</label></div><br/><div class="children"><div class="content">&gt; We can generalise this idea of being forced to handle the failure cases by saying that Haskell makes us write total functions rather than partial functions.<p>Haskell <i>doesn&#x27;t</i> prevent endless recursion. (try e.g. `main = main`)<p>As the typed FP ecosystem is moving towards dependent typing (Agda, Idris, Lean), this becomes an issue, because you don&#x27;t want the type checker to run indefinitely.<p>The many ad-hoc extensions to Haskell (TypeFamilies, DataKinds) are tying it down. Even the foundations might be a bit too ad-hoc: I&#x27;ve seen the type class resolution algorithm compared to a bad implementation of Prolog.<p>That&#x27;s why, if you like the Haskell philosophy, why would you restrict yourself to Haskell? It&#x27;s not bleeding edge any more.<p>Haskell had the possibility of being a standardized language, but look at how few packages MicroHS compiles (Lennart admitted to this at ICFP &#x27;24[0]). So the standardization has failed. The ecosystem is built upon C. The Wasm backend can&#x27;t use the Wasm GC because of how idiosyncratic GHC&#x27;s RTS is.[1]<p>So what does unique value proposition does GHC have left? Possibly the GHC runtime system, but it&#x27;s not as sexy to pitch in a blog post like this.<p>[0]: Lennart Augustsson, MicroHS: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uMurx1a6Zck&amp;t=36m" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uMurx1a6Zck&amp;t=36m</a><p>[1]: Cheng Shao, the Wasm backend for GHC: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uMurx1a6Zck&amp;t=13290s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uMurx1a6Zck&amp;t=13290s</a></div><br/><div id="41529319" class="c"><input type="checkbox" id="c-41529319" checked=""/><div class="controls bullet"><span class="by">throwthrow5643</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41520959">next</a><span>|</span><label class="collapse" for="c-41529319">[-]</label><label class="expand" for="c-41529319">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Haskell doesn&#x27;t prevent endless recursion. (try e.g. `main = main`)<p>Do you mean to say Haskell hasn&#x27;t solved the halting problem yet?</div><br/></div></div><div id="41520959" class="c"><input type="checkbox" id="c-41520959" checked=""/><div class="controls bullet"><span class="by">lemonwaterlime</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41529319">prev</a><span>|</span><a href="#41520608">next</a><span>|</span><label class="collapse" for="c-41520959">[-]</label><label class="expand" for="c-41520959">[4 more]</label></div><br/><div class="children"><div class="content">&gt; why would you restrict yourself to Haskell? It&#x27;s not bleeding edge any more.<p>I&#x27;m not using Haskell because it&#x27;s bleeding edge.<p>I use it because it is advanced enough and practical enough. It&#x27;s at a good balanced spot now to do practical things while tapping into some of the advances in programming language theory.<p>The compiler and the build system have gotten a lot more stable over the past several years. The libraries for most production-type activities have gotten a  lot more mature.<p>And I get all of the above plus strong type safety and composability, which helps me maintain applications in a way that I find satisfactory. For someone who aims to be pragmatic with a hint of scholarliness, Haskell is great.</div><br/><div id="41522068" class="c"><input type="checkbox" id="c-41522068" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520959">parent</a><span>|</span><a href="#41520608">next</a><span>|</span><label class="collapse" for="c-41522068">[-]</label><label class="expand" for="c-41522068">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The compiler and the build system have gotten a lot more stable over the past several years.<p>GHC2021 promises backwards compatibility, but it includes ill-specified extensions like ScopedTypeVariables. TypeAbstractions were just added, and they do the same thing, but differently.[0] It hasn&#x27;t even been decided yet which extensions are stable[1], yet GHC2021 still promises compatibility in future compiler versions. So either, you&#x27;ll have GHC retain inferior semantics because of backwards compatibility, or multiple ways of doing the same thing.<p>GHC2024 goes even further and includes extensions that are even more unstable, like DataKinds.<p>Another sign of instability is the fact that GHC 9.4 is still the recommended[2] release even though there are three newer &#x27;stable&#x27; GHCs. I don&#x27;t know of other languages where the recommendation is so far behind! GHC 9.4.1 is from Aug 2022.<p>It was the same situation with Cabal, it took forever to move beyond Cabal 3.6 because the subsequent releases had bugs.[3]<p>[0]: <a href="https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;ghc-dependent-types-in-haskell-3" rel="nofollow">https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;ghc-dependent-types-in-haskell-3</a>
[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ghc-proposals&#x2F;ghc-proposals&#x2F;pull&#x2F;669">https:&#x2F;&#x2F;github.com&#x2F;ghc-proposals&#x2F;ghc-proposals&#x2F;pull&#x2F;669</a>
[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;ghcup-metadata&#x2F;issues&#x2F;220">https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;ghcup-metadata&#x2F;issues&#x2F;220</a>
[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;ghcup-metadata&#x2F;issues&#x2F;40">https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;ghcup-metadata&#x2F;issues&#x2F;40</a></div><br/><div id="41528945" class="c"><input type="checkbox" id="c-41528945" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41522068">parent</a><span>|</span><a href="#41522372">next</a><span>|</span><label class="collapse" for="c-41528945">[-]</label><label class="expand" for="c-41528945">[1 more]</label></div><br/><div class="children"><div class="content">&gt; GHC2024 goes even further and includes extensions that are even more unstable, like DataKinds.<p>But DataKinds is not stable. It&#x27;s one of the most stable extensions possible!  The link you provided even says it&#x27;s stable:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;telser&#x2F;ghc-proposals&#x2F;blob&#x2F;initial-extension-categorization&#x2F;proposals&#x2F;0000-initial-extension-categorization.md#211-stable-extensions">https:&#x2F;&#x2F;github.com&#x2F;telser&#x2F;ghc-proposals&#x2F;blob&#x2F;initial-extensi...</a><p>&gt; It hasn&#x27;t even been decided yet which extensions are stable<p>It&#x27;s essentially known, but it&#x27;s not formally agreed.  The fact that this proposal exists is evidence of that!<p>&gt; GHC2021 still promises compatibility in future compiler versions. So either, you&#x27;ll have GHC retain inferior semantics because of backwards compatibility, or multiple ways of doing the same thing.<p>GHC2021 will always provide ScopedTypeVariables. A future edition will probably provide TypeAbstractions instead.  Being able to make progress to the default language like this is the point of having language editions!</div><br/></div></div></div></div></div></div><div id="41520608" class="c"><input type="checkbox" id="c-41520608" checked=""/><div class="controls bullet"><span class="by">samvher</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41520959">prev</a><span>|</span><a href="#41521057">next</a><span>|</span><label class="collapse" for="c-41520608">[-]</label><label class="expand" for="c-41520608">[20 more]</label></div><br/><div class="children"><div class="content">For a long time already I&#x27;ve wanted to make the leap towards learning dependently typed programming, but I was never sure which language to invest in - they all seemed either very focused on just proofs (Coq, Lean) or just relatively far from Haskell in terms of maturity (Agda, Idris).<p>I went through Software Foundations [0] (Coq) which was fun and interesting but I can&#x27;t say I ever really applied what I used there in software (I did get more comfortable with induction proofs).<p>You&#x27;re mentioning Lean with Agda and Idris - is Lean usable as a general purpose language? I&#x27;ve been curious about Lean but I got the impression it sort of steps away from Haskell&#x27;s legacy in terms of syntax and the like (unlike Agda and Idris) so was concerned it would be a large investment and wouldn&#x27;t add much to what I&#x27;ve learned from Coq.<p>I&#x27;d love any insights on what&#x27;s a useful way to learn more in the area of dependent types for a working engineer today.<p>[0] <a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;</a></div><br/><div id="41525223" class="c"><input type="checkbox" id="c-41525223" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520608">parent</a><span>|</span><a href="#41520713">next</a><span>|</span><label class="collapse" for="c-41525223">[-]</label><label class="expand" for="c-41525223">[4 more]</label></div><br/><div class="children"><div class="content">When I last looked into Lean, I was highly unimpressed, even for doing math proofs. There&#x27;s no way I&#x27;d invest into as a general-purpose language.<p>Idris at least does state that they what people building real programs with it and don&#x27;t want it to just be a research language.<p>For dependent types, I myself am skeptical about languages trying to continuously push more and more stuff into types. I am not certain that such efforts are a net positive on writing good software. By their very definition, the more typed a language gets, the less programs it can represents. That obviously reduces buggy programs, but it also reduces non-buggy programs that you can implement. Highly typed languages force more and more effort into pre-compile time and you will often find yourself trying to fit a problem into the chains of the type system.<p>Rather, I think reasonably multi-paradigm languages like F# are the sweet spot. Just enough strict typing and functional core to get you going for most of your program, but then it allows classes and imperative programming when those paradigms are appropriate.<p>I think the way to go to write better software is better tooling and ergonomics. I don&#x27;t think type systems are going to magically save us.</div><br/><div id="41525731" class="c"><input type="checkbox" id="c-41525731" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41525223">parent</a><span>|</span><a href="#41528817">next</a><span>|</span><label class="collapse" for="c-41525731">[-]</label><label class="expand" for="c-41525731">[2 more]</label></div><br/><div class="children"><div class="content">&gt; By their very definition, the more typed a language gets, the less programs it can represents. That obviously reduces buggy programs, but it also reduces non-buggy programs that you can implement.<p>While I generally share your skepticism, I think this is quite wrong. A good part of the point of advanced type systems is to make more complex problems possible while still being well typed. For example, in C, if you want a function whose return type is tied to an input argument&#x27;s type, you either use void* and casts (no type safety), or you don&#x27;t write that function. In languages with even slightly more advanced type systems, you can write that function and still get full type safety.<p>Even more advanced type systems achieve the same things: you can take programs that can only be written in a simpler type system and make them safe. In standard Haskell, for example, you can&#x27;t write a Monad and actually have the compiler check that it respects the Monad laws - the implementation of Monad functions just assumes that any type that implements the right shape of functions will work as a monad. With dependent types, you can actually enforce that functions designed to work with monads only apply to types that actually respect the monad laws.<p>The trade-off with very complex type systems is different, in my opinion: after some point, you start duplicating your program&#x27;s logic, once in the implentation code, but again in the type signatures. For example, if you want to specify that a sort function actually sorts the input list, you might find that the type specification ends up not much shorter than the actual code of the function. And apart from raw effort, this means that your type specifications start being large enough that they have their own bugs.</div><br/><div id="41527537" class="c"><input type="checkbox" id="c-41527537" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41525731">parent</a><span>|</span><a href="#41528817">next</a><span>|</span><label class="collapse" for="c-41527537">[-]</label><label class="expand" for="c-41527537">[1 more]</label></div><br/><div class="children"><div class="content">I think GP&#x27;s point was that most[1] programs that can be represented will fail to please the programmer or his principals. The act of programming is navigating the state space of all possible programs and somehow finding one that has the desired properties and also doesn&#x27;t otherwise suck. When viewed through that lens, a type system preventing most programs from being represented is a good thing, since odds are every single program it prevents is one that is unpleasant or otherwise sucks.<p>[1] of the countably infinite possible programs, virtually all</div><br/></div></div></div></div><div id="41528817" class="c"><input type="checkbox" id="c-41528817" checked=""/><div class="controls bullet"><span class="by">a57721</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41525223">parent</a><span>|</span><a href="#41525731">prev</a><span>|</span><a href="#41520713">next</a><span>|</span><label class="collapse" for="c-41528817">[-]</label><label class="expand" for="c-41528817">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When I last looked into Lean, I was highly unimpressed, even for doing math proofs.<p>I remember exploring different proof assistants for the first time in the 2000s. Back then, only people with a background in logic were involved, and most of the proofs that were formalized as showcases were of textbook results from the 19th century at most, or some combinatorial stuff like the four-color theorem.<p>I believe Voevodsky was one of the first prominent non-logicians to become interested in proof assistants, using Coq around 2010. Nowadays, several mathematicians coming from algebraic geometry, number theory, etc. are promoting formal proofs, and it seems like most of them have chosen Lean. I don&#x27;t know whether this is because Lean is somehow better suited for working mathematicians, or if it was simply a random personal preference among people who got enthusiastic about this stuff and started advertising it to their colleagues?<p>I am not familiar with every proof assistant out there, but many of them are a very hard sell for mathematicians and lack a comprehensive math library. Lean seems to be one of the few exceptions.</div><br/></div></div></div></div><div id="41520713" class="c"><input type="checkbox" id="c-41520713" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520608">parent</a><span>|</span><a href="#41525223">prev</a><span>|</span><a href="#41521318">next</a><span>|</span><label class="collapse" for="c-41520713">[-]</label><label class="expand" for="c-41520713">[6 more]</label></div><br/><div class="children"><div class="content">Lean aims to be a general purpose language, but I haven&#x27;t seen people actually write HTTP servers in it. If Leo de Moura really wanted it to be general purpose, what does the concurrent runtime look like then? To my knowledge, there isn&#x27;t one?<p>That&#x27;s why I&#x27;ve been writing an HTTP server in Idris2 instead. Here&#x27;s a todo list demo app[1] and a hello world demo[2]. The advantage of Idris is that it compiles to e.g. Racket, a high level language with a concurrent runtime you can bind to from Idris.<p>It&#x27;s also interesting how languages don&#x27;t need their own hosting (e.g. Hackage) any more. Idris packages are just listed in a TOML file[3] (like Stackage) but still hosted on GitHub. No need for versions, just use git commit hashes. It&#x27;s all experimental anyway.<p>[1]: <a href="https:&#x2F;&#x2F;janus.srht.site&#x2F;docs&#x2F;todolist.html" rel="nofollow">https:&#x2F;&#x2F;janus.srht.site&#x2F;docs&#x2F;todolist.html</a>
[2]: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~janus&#x2F;web-server-racket-hello-world&#x2F;tree&#x2F;master&#x2F;item&#x2F;src&#x2F;HelloWorld.idr" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~janus&#x2F;web-server-racket-hello-world&#x2F;tree&#x2F;...</a>
[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;stefan-hoeck&#x2F;idris2-pack-db&#x2F;blob&#x2F;main&#x2F;STATUS.md">https:&#x2F;&#x2F;github.com&#x2F;stefan-hoeck&#x2F;idris2-pack-db&#x2F;blob&#x2F;main&#x2F;STA...</a></div><br/><div id="41522152" class="c"><input type="checkbox" id="c-41522152" checked=""/><div class="controls bullet"><span class="by">orbifold</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520713">parent</a><span>|</span><a href="#41520861">next</a><span>|</span><label class="collapse" for="c-41522152">[-]</label><label class="expand" for="c-41522152">[1 more]</label></div><br/><div class="children"><div class="content">There are tasks, which are implemented as part of the runtime and they appear to plan to integrate libuv in the future. Some of the runtime seems to be fairly easy to hack and have somewhat nice ways of interoperating with both C, C++ and Rust.</div><br/></div></div><div id="41520861" class="c"><input type="checkbox" id="c-41520861" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520713">parent</a><span>|</span><a href="#41522152">prev</a><span>|</span><a href="#41521318">next</a><span>|</span><label class="collapse" for="c-41520861">[-]</label><label class="expand" for="c-41520861">[4 more]</label></div><br/><div class="children"><div class="content">&gt; (like Stackage) but still hosted on GitHub<p>I don&#x27;t have much experience with Haskell, but one of the worst experiences has been Stack&#x27;s compile time dependency on GitHub. GitHub rate limits you and builds take forever.</div><br/><div id="41521957" class="c"><input type="checkbox" id="c-41521957" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520861">parent</a><span>|</span><a href="#41521318">next</a><span>|</span><label class="collapse" for="c-41521957">[-]</label><label class="expand" for="c-41521957">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting. Could you say more? This is something that we (speaking as part of the Haskell community) should fix.  As far as I know Stack&#x2F;Stackage should pick up packages from Hackage.  What does it use GitHub for?</div><br/><div id="41526344" class="c"><input type="checkbox" id="c-41526344" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41521957">parent</a><span>|</span><a href="#41521318">next</a><span>|</span><label class="collapse" for="c-41526344">[-]</label><label class="expand" for="c-41526344">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not entirely sure where it uses GitHub and where Hackage, but there are a few GitHub issues on the Stack repo about it:<p>-  Binary upgrade of Stack fails due to GitHub API request limit #4979 (<a href="https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;issues&#x2F;4979">https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;issues&#x2F;4979</a>)<p>-  GitHub rate limiting can affect Stack CI #6034 (<a href="https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;issues&#x2F;6034">https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;issues&#x2F;6034</a>)<p>And a few more. The &quot;fix&quot; is having Stack impersonate the user (<a href="https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;pull&#x2F;6036">https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;pull&#x2F;6036</a>) and authenticate to the API. This unblocks progress, but this is really a design bug and not something I think people should emulate.<p>Every other language I&#x27;ve used allows you to build code without authenticating to a remote service.</div><br/><div id="41528961" class="c"><input type="checkbox" id="c-41528961" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41526344">parent</a><span>|</span><a href="#41521318">next</a><span>|</span><label class="collapse" for="c-41528961">[-]</label><label class="expand" for="c-41528961">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! So it seems to be not packages, but templates, and this comment suggests it wasn&#x27;t GitHub doing the rate limiting after all: <a href="https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;issues&#x2F;4979#issuecomment-1603388213">https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;issues&#x2F;4979#issue...</a><p>&gt; Every other language I&#x27;ve used allows you to build code without authenticating to a remote service.<p>Sure, the problem here wasn&#x27;t &quot;building&quot;. It was downloading a package template (which one doesn&#x27;t tend to do 60 times per hour).  I agree packages shouldn&#x27;t be fetched from GitHub.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41521318" class="c"><input type="checkbox" id="c-41521318" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520608">parent</a><span>|</span><a href="#41520713">prev</a><span>|</span><a href="#41522938">next</a><span>|</span><label class="collapse" for="c-41521318">[-]</label><label class="expand" for="c-41521318">[2 more]</label></div><br/><div class="children"><div class="content">Lean <i>can</i> be used to write software in [0]. I dare say that it may even be the intended use for Lean 4. Work on porting <i>mathlib</i> to Lean 4 is far along and the mathematicians using it will certainly continue to do so. However there is more space for software written in Lean 4 as well.<p>However...<p>it&#x27;s no where near ready for production use. They don&#x27;t care about maintaining backwards compatibility. They are more focused on getting the language itself right than they are about helping people build and maintain software written in it. At least for the foreseeable future. If you do build things in it you&#x27;re working on shifting ground.<p>But it has a lot of potential. The C code generated by Lean 4 is good. Although, that&#x27;s another trade-off: compiling to C is another source of &quot;quirks.&quot;<p>[0] <a href="https:&#x2F;&#x2F;agentultra.github.io&#x2F;lean-4-hackers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;agentultra.github.io&#x2F;lean-4-hackers&#x2F;</a></div><br/><div id="41525547" class="c"><input type="checkbox" id="c-41525547" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41521318">parent</a><span>|</span><a href="#41522938">next</a><span>|</span><label class="collapse" for="c-41525547">[-]</label><label class="expand" for="c-41525547">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Work on porting mathlib to Lean 4 is far along<p>As far as I understand, that work is in fact <i>done</i>.</div><br/></div></div></div></div><div id="41522938" class="c"><input type="checkbox" id="c-41522938" checked=""/><div class="controls bullet"><span class="by">mebassett</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520608">parent</a><span>|</span><a href="#41521318">prev</a><span>|</span><a href="#41527792">next</a><span>|</span><label class="collapse" for="c-41522938">[-]</label><label class="expand" for="c-41522938">[1 more]</label></div><br/><div class="children"><div class="content">Lean definitely intends to be usable as a general purpose language someday. but I think the bulk of the people involved are more focused on automated theorem proving.  The Lean FRO [0] has funds to guide development of the language and they are planning to carve out a niche for stuff that requires formal verification.   I&#x27;d say in terms of general purpose programming it fits into the category of being &quot;relatively far from haskell in terms of maturity&quot;.<p>[0] <a href="https:&#x2F;&#x2F;lean-fro.org&#x2F;about&#x2F;roadmap-y2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lean-fro.org&#x2F;about&#x2F;roadmap-y2&#x2F;</a></div><br/></div></div><div id="41527792" class="c"><input type="checkbox" id="c-41527792" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520608">parent</a><span>|</span><a href="#41522938">prev</a><span>|</span><a href="#41523205">next</a><span>|</span><label class="collapse" for="c-41527792">[-]</label><label class="expand" for="c-41527792">[1 more]</label></div><br/><div class="children"><div class="content">I took that course as well, and for me, the big takeaway wasn&#x27;t that I specifically want to use Coq for anything practical, but the idea that you can actually do quite a lot with a non-Turing complete language. Realizing that constraints in a language can be an asset rather than a limitation is something that I think isn&#x27;t as widely understood as it should be.</div><br/></div></div><div id="41523205" class="c"><input type="checkbox" id="c-41523205" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41520608">parent</a><span>|</span><a href="#41527792">prev</a><span>|</span><a href="#41521057">next</a><span>|</span><label class="collapse" for="c-41523205">[-]</label><label class="expand" for="c-41523205">[5 more]</label></div><br/><div class="children"><div class="content">One reason I took interest in Idris (and lately Roc, although it&#x27;s even less mature) is the promise of a functional <i>but usable to solve problems today</i> language with all the latest thinking on writing good code baked-in already, compiling to a single binary (something I always envied about Go, although unfortunately it&#x27;s Go). There simply isn&#x27;t a lot there yet in the space of &quot;pure functional language with only immutable values and compile time type checking that builds a single fast binary (and has some neat developer-friendly features&#x2F;ideas such as dependent types, Roc&#x27;s &quot;tags&quot; or pattern-matching with destructuring)&quot; (this rules out OCaml, for example, despite it being mature). You get a lot of that, but not all of it, with other options (OCaml, Elixir&#x2F;Erlang, Haskell... but those 3 offer a far larger library of ready-to-import software at this point). Haskell did manage to teach everyone who cares about these things that managing side-effects and keeping track of &quot;purity&quot; is important.<p>But it&#x27;s frankly still early-days and we&#x27;re still far from nirvana; Rust is starting to show some warts (despite still being a massive improvement over C from a safety perspective), and people are looking around for what&#x27;s next.<p>One barely-touched thing is that there are compiler optimizations made possible by pure functional&#x2F;pure immutable languages (such as caching a guaranteed result of an operation where those guarantees simply can&#x27;t be given elsewhere) that have simply been impossible until now. (Roc is trying to go there, from what I can tell, and I&#x27;m here for it! Presumably, Rust has already, as long as you stick with its functional constructs, which I hear is hard sometimes)</div><br/><div id="41525610" class="c"><input type="checkbox" id="c-41525610" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41523205">parent</a><span>|</span><a href="#41521057">next</a><span>|</span><label class="collapse" for="c-41525610">[-]</label><label class="expand" for="c-41525610">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is starting to show some warts (despite still being a massive improvement over C from a safety perspective)<p>The way it seems to me is that actually Rust aims to be an improvement over C++ rather than C. (And Zig aims to be an improvement over C rather than C++.)<p>The major downsides of both will be the same as their reference point: Rust will eventually be too complicated for anyone to understand while still not being really safe (and the complexity then comes back to bite you one more time). Zig will be easy to understand and use but too unsafe to use for important applications (at least once people start really caring about software in important applications).<p>Both of these will be fairly niche because compiling to a single binary just isn&#x27;t as important, as elegant as it might be.</div><br/><div id="41526836" class="c"><input type="checkbox" id="c-41526836" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41525610">parent</a><span>|</span><a href="#41521057">next</a><span>|</span><label class="collapse" for="c-41526836">[-]</label><label class="expand" for="c-41526836">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Zig will be easy to understand and use but too unsafe to use for important applications</i><p>This is an outside perspective on Zig, and I have to say, not an informed one.<p>If you&#x27;d like to understand Zig (and what I mean) better, this video is a good start: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=w3WYdYyjek4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=w3WYdYyjek4</a><p>Zig is, right now, being used for high-assurance systems where correctness is a terminal value, and it provides many tools and affordances to assist in doing so.  It isn&#x27;t a good choice for projects which give lip-service to correctness, but for ones which actually mean it, and are willing and able to put in the effort and expense to achieve it, it&#x27;s an excellent choice.  I&#x27;m willing to gloss that domain as &quot;important applications&quot;, but perhaps you meant something different by that term.</div><br/><div id="41528828" class="c"><input type="checkbox" id="c-41528828" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41526836">parent</a><span>|</span><a href="#41527559">next</a><span>|</span><label class="collapse" for="c-41528828">[-]</label><label class="expand" for="c-41528828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Zig is, right now, being used for high-assurance systems<p>I&#x27;m not convinced this is telling us very much. I was talking about software that, e.g., causes deaths when it fails. But regardless of what level of assurance one looks at, most &quot;high assurance&quot; systems continue to be built using C. The very few that use Zig surely chose it primarily due to compatibility with C, with the hope that it&#x27;s <i>safer than C</i> (a low bar). Maybe in some cases also a wish to play around with new toys played a role in the decision, though in &quot;important applicatios&quot; I&#x27;d like to hope that&#x27;s rare.<p>In the end, we&#x27;d have to look at harm done due to bugs. For C, I&#x27;d say the record is abysmal. For Zig, it&#x27;s way to early to look at this.<p>My judgement above is mostly based on Zig not making it at all hard to violate memory safety and the analogy with C. Needless to say, Zig is better than C in this respect and that&#x27;s a good thing. If your argument is something like &quot;memory safety doesn&#x27;t really matter, even for critical applications&quot;, we&#x27;ll just not agree on this.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41521057" class="c"><input type="checkbox" id="c-41521057" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41520608">prev</a><span>|</span><a href="#41521475">next</a><span>|</span><label class="collapse" for="c-41521057">[-]</label><label class="expand" for="c-41521057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s why, if you like the Haskell philosophy, why would you restrict yourself to Haskell?<p>In the essay, I didn&#x27;t say &quot;Haskell is the only thing you should use&quot;, what I said was:<p>&gt; Many languages have bits of these features, but only a few have all of them, and, of those languages (others include Idris, Agda, and Lean), Haskell is the most mature, and therefore has the largest ecosystem.<p>On this:<p>&gt; It&#x27;s not bleeding edge any more.<p>&quot;Bleeding edge&quot; is certainly not something I&#x27;ve used as a benefit in this essay, so not really sure where this comes from (unless you&#x27;re not actually responding to the linked essay itself, but rather to ... something else?).</div><br/></div></div><div id="41521475" class="c"><input type="checkbox" id="c-41521475" checked=""/><div class="controls bullet"><span class="by">mightybyte</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41521057">prev</a><span>|</span><a href="#41523167">next</a><span>|</span><label class="collapse" for="c-41521475">[-]</label><label class="expand" for="c-41521475">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s why, if you like the Haskell philosophy, why would you restrict yourself to Haskell? It&#x27;s not bleeding edge any more.<p>Because it has a robust and mature ecosystem that is more viable for mainstream commercial use than any of the other &quot;bleeding edge&quot; languages.</div><br/></div></div><div id="41523167" class="c"><input type="checkbox" id="c-41523167" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41521475">prev</a><span>|</span><a href="#41522139">next</a><span>|</span><label class="collapse" for="c-41523167">[-]</label><label class="expand" for="c-41523167">[7 more]</label></div><br/><div class="children"><div class="content">&gt; So what does unique value proposition does GHC have left? Possibly the GHC runtime system, but it&#x27;s not as sexy to pitch in a blog post like this.<p>The point is that programming in a pure language with typed side effects and immutable data dramatically reduces the size of the state space that must be reasoned about. This makes programming significantly easier (especially over the long term).<p>Of the languages that support this programming style Haskell remains the one with the largest library ecosystem, most comprehensive documentation, and most optimised compiler. I love lean and use it professionally, but it is nowhere near the usability of Haskell when it comes to being a production ready general purpose language.</div><br/><div id="41526321" class="c"><input type="checkbox" id="c-41526321" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41523167">parent</a><span>|</span><a href="#41527613">next</a><span>|</span><label class="collapse" for="c-41526321">[-]</label><label class="expand" for="c-41526321">[4 more]</label></div><br/><div class="children"><div class="content">&gt; dramatically reduces the size of the state space that must be reasoned about<p>True<p>&gt; This makes programming significantly easier (especially over the long term)<p>Not true. (As in, the implication is not true.)<p>There are many many factors that affect ease of programming and the structure of the stage space is just one of them.</div><br/><div id="41527813" class="c"><input type="checkbox" id="c-41527813" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41526321">parent</a><span>|</span><a href="#41527613">next</a><span>|</span><label class="collapse" for="c-41527813">[-]</label><label class="expand" for="c-41527813">[3 more]</label></div><br/><div class="children"><div class="content">It’s true that things like docs and error messages are also important, but the fundamental task of understanding and reasoning about code is significantly easier if you restrict yourself to pure functions over immutable data.</div><br/><div id="41527859" class="c"><input type="checkbox" id="c-41527859" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41527813">parent</a><span>|</span><a href="#41527613">next</a><span>|</span><label class="collapse" for="c-41527859">[-]</label><label class="expand" for="c-41527859">[2 more]</label></div><br/><div class="children"><div class="content">No, I didn&#x27;t mean docs and error messages, I meant even more basic things. Like sheer code size, visual noise, and intuitiveness, to give a few examples. There&#x27;s no free lunch, everything is a tradeoff. Just because you&#x27;re constraining the program&#x27;s state space that doesn&#x27;t imply you&#x27;re making the code more succinct or intuitive. You could easily be adding a ton of distracting noise or obscuring the core logic with all your awesome static typing.</div><br/><div id="41528872" class="c"><input type="checkbox" id="c-41528872" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41527859">parent</a><span>|</span><a href="#41527613">next</a><span>|</span><label class="collapse" for="c-41528872">[-]</label><label class="expand" for="c-41528872">[1 more]</label></div><br/><div class="children"><div class="content">I think the relative importance of syntax compared to actual semantics when it comes to ease of understanding is probably rather low.<p>Either way Haskell is also probably the language that lets you produce the most succinct code of anything that could be reasonably be used in production.</div><br/></div></div></div></div></div></div></div></div><div id="41527613" class="c"><input type="checkbox" id="c-41527613" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41523167">parent</a><span>|</span><a href="#41526321">prev</a><span>|</span><a href="#41522139">next</a><span>|</span><label class="collapse" for="c-41527613">[-]</label><label class="expand" for="c-41527613">[2 more]</label></div><br/><div class="children"><div class="content">When you start mathematically characterizing state spaces it quickly becomes apparent that pure functional languages advantage over imperative ones is more a matter of the poor design of popular imperative languages rather than an intrinsic difference.<p>That (in)famous goto paper isn&#x27;t really about spaghetti code, it&#x27;s about how on Earth do you mathematically define the semantics of any statement in a language with unrestricted goto. If any continuation can follow literally anything then you&#x27;re pretty much in no man&#x27;s land. On the other hand imperative code is easy and natural to reason about when it uses a small set of well defined primitives.<p>If that sounds surprising, consider how mathematical logic itself, especially obviously in the calculational proof style, is essentially a series of assignment statements.</div><br/><div id="41527838" class="c"><input type="checkbox" id="c-41527838" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41527613">parent</a><span>|</span><a href="#41522139">next</a><span>|</span><label class="collapse" for="c-41527838">[-]</label><label class="expand" for="c-41527838">[1 more]</label></div><br/><div class="children"><div class="content">I’m not quite sure what the point is here. I agree that well written imperative code can be easy to read, and that it’s often the natural style for many problems. I just think it’s always better to use that style in a system that makes the available context explicit and enforces a strict discipline via the type system (e.g. a State monad).<p>Regarding semantics my experience is that defining formal semantics for languages with unrestricted mutation (or even worse aliased pointers into mutable state) than one that avoids those features.</div><br/></div></div></div></div></div></div><div id="41522139" class="c"><input type="checkbox" id="c-41522139" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41523167">prev</a><span>|</span><a href="#41521426">next</a><span>|</span><label class="collapse" for="c-41522139">[-]</label><label class="expand" for="c-41522139">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As the typed FP ecosystem is moving towards dependent typing (Agda, Idris, Lean), this becomes an issue, because you don&#x27;t want the type checker to run indefinitely.<p>First of all, does ecosystem move to dependent types? I think the practical value of Hindley-Milner is exactly in the fact that there is a nice boundary between types and terms.<p>Second, why would type checking running indefinitely be a practical problem? If I can&#x27;t prove a theorem, I can&#x27;t use it. The program that doesn&#x27;t typecheck in practical amount of time is in practice identical to non-type-checked program, i.e. no worse than a status quo.</div><br/><div id="41524591" class="c"><input type="checkbox" id="c-41524591" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41522139">parent</a><span>|</span><a href="#41521426">next</a><span>|</span><label class="collapse" for="c-41524591">[-]</label><label class="expand" for="c-41524591">[2 more]</label></div><br/><div class="children"><div class="content">No, the FP community at large is definitely not moving toward dependent types. However, much more of the FP <i>research</i> community is now focused on dependent types, but a good chunk of that research is concerned with questions like &quot;How do we make X benefit of dependent types work in a more limited fashion for languages without a fully dependent type system?&quot;<p>I think we&#x27;ll continue to see lots of work in this direction and, subsequently, a lot of more mainstream FP languages will adopt features derived from dependent types research, but it&#x27;s not like everybody&#x27;s going to be writing Agda or Coq or Idris in 10 years instead of, like, OCaml and Haskell.</div><br/><div id="41526289" class="c"><input type="checkbox" id="c-41526289" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41524591">parent</a><span>|</span><a href="#41521426">next</a><span>|</span><label class="collapse" for="c-41526289">[-]</label><label class="expand" for="c-41526289">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not even sure if any human is still writing code in 10 years.</div><br/></div></div></div></div></div></div><div id="41521426" class="c"><input type="checkbox" id="c-41521426" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41522139">prev</a><span>|</span><a href="#41525927">next</a><span>|</span><label class="collapse" for="c-41521426">[-]</label><label class="expand" for="c-41521426">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As the typed FP ecosystem is moving towards dependent typing (Agda, Idris, Lean)<p>I&#x27;m not really sure where the borders of &quot;the typed FP language ecosystem&quot; would be but feel pretty certain that such a thing would enclose also F#, Haskell, and OCaml. Any one of which has more users and more successful &quot;public facing&quot; projects than the languages you mentioned combined. This is not a dig on those languages, but they are niche languages even by the standards of the niche we&#x27;re talking about.<p>You could argue that they point to the future but I don&#x27;t seriously believe a trend among them represents a shift in the main stream of functional programming.</div><br/><div id="41526520" class="c"><input type="checkbox" id="c-41526520" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41521426">parent</a><span>|</span><a href="#41525927">next</a><span>|</span><label class="collapse" for="c-41526520">[-]</label><label class="expand" for="c-41526520">[1 more]</label></div><br/><div class="children"><div class="content">This is the F# time that I&#x27;ve seen F# contrasted as the more mainstream option and it warms my heart.</div><br/></div></div></div></div><div id="41525927" class="c"><input type="checkbox" id="c-41525927" checked=""/><div class="controls bullet"><span class="by">aSanchezStern</span><span>|</span><a href="#41520434">parent</a><span>|</span><a href="#41521426">prev</a><span>|</span><a href="#41519486">next</a><span>|</span><label class="collapse" for="c-41525927">[-]</label><label class="expand" for="c-41525927">[2 more]</label></div><br/><div class="children"><div class="content">Uhh, endless recursion doesn&#x27;t cause your typechecker to run indefinitely; all recursion is sort of &quot;endless&quot; from a type perspective, since the recursion only hits a base case based on values. The problem with non-well-founded recursion like `main = main` is that it prevents you from soundly using types as propositions, since you can trivially inhabit any type.</div><br/><div id="41527455" class="c"><input type="checkbox" id="c-41527455" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#41520434">root</a><span>|</span><a href="#41525927">parent</a><span>|</span><a href="#41519486">next</a><span>|</span><label class="collapse" for="c-41527455">[-]</label><label class="expand" for="c-41527455">[1 more]</label></div><br/><div class="children"><div class="content">The infinite loop case is:<p><pre><code>    loopType : Int -&gt; Type
    loopType x = loopType x

    foo : List (loopType 3) -&gt; Int
    foo _ = 42

    bar : List (loopType 4)
    bar = []

    baz : Int
    baz = foo bar
</code></pre>
Determining if baz type-checks requires evaluating loopType 3 and loopType 4 to determine if they&#x27;re equal.</div><br/></div></div></div></div></div></div><div id="41519486" class="c"><input type="checkbox" id="c-41519486" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#41520434">prev</a><span>|</span><a href="#41529066">next</a><span>|</span><label class="collapse" for="c-41519486">[-]</label><label class="expand" for="c-41519486">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used Haskell for a decade or so, and tooling has improved immensely, with ghcup and cabal sandboxing and HLS now being quite stable. Maybe I&#x27;ve been lucky, but I haven&#x27;t found much missing in the library ecosystem, or maybe I just have a lower threshold for using other languages when I see something is easier to do with a library from Python or whatever (typically nlp stuff). The one thing I still find annoying about Haskell is compile times. For the project itself, one can do fast compiles during development, but say you want to experiment with different GHC versions and base libraries, then you have to wait forever for your whole set of dependencies to compile (or buy some harddrives to store &#x2F;nix on if you go that route). And installing some random Haskell program from source also becomes a drag due to dependency compile times (I&#x27;m always happy when I see a short dependency tree). 
Still, when deps are all compiled, it really is a <i>fun</i> language to program in.</div><br/><div id="41525210" class="c"><input type="checkbox" id="c-41525210" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#41519486">parent</a><span>|</span><a href="#41529066">next</a><span>|</span><label class="collapse" for="c-41525210">[-]</label><label class="expand" for="c-41525210">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; ghcup and cabal sandboxing</i><p>Would you recommend using cabal or stack to package Haskell components in a Yocto layer, for sandboxed, reproducible, cross-compiled builds that are independent of host toolchains?</div><br/></div></div></div></div><div id="41529066" class="c"><input type="checkbox" id="c-41529066" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#41519486">prev</a><span>|</span><a href="#41518959">next</a><span>|</span><label class="collapse" for="c-41529066">[-]</label><label class="expand" for="c-41529066">[1 more]</label></div><br/><div class="children"><div class="content">I believe Haskell is worth learning.<p>But I don&#x27;t want to spend any more time near purely functional programmers in my professional life, so I will spend some time to unfairly nitpick the article.<p>&gt; a lot of the new features ... are either inspired by, or at least more robustly implemented in, Haskell.<p>This is like some programmers, who don&#x27;t know much about the history of programming languages, saying Java is stealing features from Kotlin (a language I enjoy). In both cases the inspiration usually comes from ML (a language family which includes OCaml - a language I deeply admire).<p>Type classes (first implemented in Haskell) are neat though. I heard that Java is considering adopting them.<p>&gt; Let’s imagine we represented these as plain old strings ... `Theatre String String -- venue name and event name respectively` `checkForSeats :: String -&gt; String -&gt; IO [Seat]`<p>If your language has named arguments, and sum type cases are records where you have to name your fields, using plain strings is just fine, and probably more ergonomic than wrapping the strings in another type.<p>&gt; `Either AddressParseError ValidAddress`<p>Real world procedures usually involves many steps which can fail in many ways. The HM type system does not have subtypes. To stuff all possible failures into the `Left` case of `Either` you have to wrap all possible failure types into a sum type, possibly with multiple layers of nesting (huge PITA).<p>&gt; concurrent Haskell<p>For all the hassle with the IO monad, you cannot offload your understanding of memory model to the compiler when you use an `IORef`.<p>Maybe most your problems are embarrassingly parallel and STM is fast enough for the rest. Maybe.<p>&gt; exactly encode the effects we want a function to be permitted to perform<p><a href="https:&#x2F;&#x2F;degoes.net&#x2F;articles&#x2F;no-effect-tracking" rel="nofollow">https:&#x2F;&#x2F;degoes.net&#x2F;articles&#x2F;no-effect-tracking</a> &quot;Effect Tracking Is Commercially Worthless&quot;<p>See &quot;Tagless-Final Effect-Tracked Java™&quot; for a chuckle.<p>&gt; small sample program<p>The `Money` type is monomorphic, and `Functor`s are higher-kinded.
You get the error message `Expected kind ‘* -&gt; *’, but ‘Money’ has kind ‘*’`</div><br/></div></div><div id="41518959" class="c"><input type="checkbox" id="c-41518959" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41529066">prev</a><span>|</span><a href="#41519406">next</a><span>|</span><label class="collapse" for="c-41518959">[-]</label><label class="expand" for="c-41518959">[73 more]</label></div><br/><div class="children"><div class="content">I love Haskell the language, but Haskell the ecosystem still has a way to go:<p>* The compiler is slower than most mainstream language compilers<p>* Its ability to effectively report errors is poorer<p>* It tends to have &#x27;first error, breaks rest of compile&#x27; problems<p>* I don&#x27;t mind the more verbose &#x27;stack trace&#x27; of errors, but I know juniors&#x2F;noobs can find that quite overwhelming.<p>* The tooling, although significantly better than it was, is still poor compared to other some other functional languages, and really poor compared to mainstream languages like C#<p>* This ^ significantly steepens the learning curve for juniors and those new to Haskell and generally gets in the way for those more experienced.<p>* The library ecosystem for key capabilities in &#x27;enterprise dev&#x27; is poor. Many unmaintained, substandard, or incomplete implementations.  Often trying their best to be academically interesting, but not necessarily usable.<p>The library ecosystem is probably the biggest issue.  Because it&#x27;s not something you can easily overcome without a lot of effort.<p>I used to be very bullish on Haskell and brought it into my company for a greenfield project.  The company had already been using pure-FP techniques (functors, monads, etc.), so it wasn&#x27;t a stretch.  We ran a weekly book club studying Haskell to help out the juniors and newbies.  So, we really gave it its best chance.<p>After a year of running a team with it, I came to the conclusions above. Everything was much slower -- I kept telling myself that the code would be less brittle, so slower was OK -- but in reality it sapped momentum from the team.<p>I think Haskell&#x27;s biggest contribution to the wider community is its ideas, which have influenced many other languages. I&#x27;m not sure it will ever have its moment in the sun unfortunately.</div><br/><div id="41519294" class="c"><input type="checkbox" id="c-41519294" checked=""/><div class="controls bullet"><span class="by">catgary</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41528985">next</a><span>|</span><label class="collapse" for="c-41519294">[-]</label><label class="expand" for="c-41519294">[14 more]</label></div><br/><div class="children"><div class="content">I kind of agree that Haskell missed its window, and a big part of the problem is the academic-heavy ecosystem (everyone is doing great work, but there is a difference between academic and industrial code).<p>I’m personally quite interested in the Koka language. It has some novel ideas (functional-but-in-place algorithms, effect-handler-aware compilation, it uses reference counting rather than garbage collection) and is a Microsoft Research project. It’s starting to look more and more like an actual production-ready language. I can daydream about Microsoft throwing support behind it, along with some tooling to add some sort of Koka-Rust interoperability.</div><br/><div id="41519357" class="c"><input type="checkbox" id="c-41519357" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519294">parent</a><span>|</span><a href="#41524218">next</a><span>|</span><label class="collapse" for="c-41519357">[-]</label><label class="expand" for="c-41519357">[12 more]</label></div><br/><div class="children"><div class="content">Koka is indeed incredibly cool, but:<p>It sees sporadic bursts of activity, probably when an intern is working on it, and otherwise remains mostly dormant. There is no package manager that could facilitate ecosystem growth. There is no effort to market and popularize it.<p>I believe it is fated to remain a research language indefinitely.</div><br/><div id="41519533" class="c"><input type="checkbox" id="c-41519533" checked=""/><div class="controls bullet"><span class="by">catgary</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519357">parent</a><span>|</span><a href="#41524218">next</a><span>|</span><label class="collapse" for="c-41519533">[-]</label><label class="expand" for="c-41519533">[11 more]</label></div><br/><div class="children"><div class="content">You’re probably right. I just think it’s the only real candidate for a functional language that could enter the zeitgeist like Rust or Swift did, it’s a research language that has been percolating at Microsoft for some time. A new language requires a major company’s support, and they should build an industry-grade ecosystem for at least one problem domain.</div><br/><div id="41520478" class="c"><input type="checkbox" id="c-41520478" checked=""/><div class="controls bullet"><span class="by">mgdev</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519533">parent</a><span>|</span><a href="#41527351">next</a><span>|</span><label class="collapse" for="c-41520478">[-]</label><label class="expand" for="c-41520478">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just now discovering Koka. I&#x27;m kinda blown away.<p>I&#x27;m also a little sad at this defeatist attitude. What you said might be true, but those things are solvable problems. Just requires a coordinated force of will from a few dedicated individuals.</div><br/><div id="41524390" class="c"><input type="checkbox" id="c-41524390" checked=""/><div class="controls bullet"><span class="by">catgary</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520478">parent</a><span>|</span><a href="#41521136">next</a><span>|</span><label class="collapse" for="c-41524390">[-]</label><label class="expand" for="c-41524390">[1 more]</label></div><br/><div class="children"><div class="content">There is a team of dedicated people working on Koka. They say the language isn’t production ready, and they don’t seem to be rushing. But I don’t think they’d bother with VSCode&#x2F;IDE support if they didn’t feel like they were getting close.</div><br/></div></div><div id="41521136" class="c"><input type="checkbox" id="c-41521136" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520478">parent</a><span>|</span><a href="#41524390">prev</a><span>|</span><a href="#41527351">next</a><span>|</span><label class="collapse" for="c-41521136">[-]</label><label class="expand" for="c-41521136">[2 more]</label></div><br/><div class="children"><div class="content">Be the change you want to see?</div><br/><div id="41521364" class="c"><input type="checkbox" id="c-41521364" checked=""/><div class="controls bullet"><span class="by">mgdev</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41521136">parent</a><span>|</span><a href="#41527351">next</a><span>|</span><label class="collapse" for="c-41521364">[-]</label><label class="expand" for="c-41521364">[1 more]</label></div><br/><div class="children"><div class="content">Hear, hear!</div><br/></div></div></div></div></div></div><div id="41527351" class="c"><input type="checkbox" id="c-41527351" checked=""/><div class="controls bullet"><span class="by">alpinisme</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519533">parent</a><span>|</span><a href="#41520478">prev</a><span>|</span><a href="#41520304">next</a><span>|</span><label class="collapse" for="c-41527351">[-]</label><label class="expand" for="c-41527351">[1 more]</label></div><br/><div class="children"><div class="content">A big if, granted, but if roc delivers on its promises it could also be a pretty compelling language — maybe a bit too niche for super enterprisey stuff but it could definitely have a zeitgeisty moment.</div><br/></div></div><div id="41520304" class="c"><input type="checkbox" id="c-41520304" checked=""/><div class="controls bullet"><span class="by">psd1</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519533">parent</a><span>|</span><a href="#41527351">prev</a><span>|</span><a href="#41524218">next</a><span>|</span><label class="collapse" for="c-41520304">[-]</label><label class="expand" for="c-41520304">[5 more]</label></div><br/><div class="children"><div class="content">F# exists</div><br/><div id="41523879" class="c"><input type="checkbox" id="c-41523879" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520304">parent</a><span>|</span><a href="#41520414">next</a><span>|</span><label class="collapse" for="c-41523879">[-]</label><label class="expand" for="c-41523879">[1 more]</label></div><br/><div class="children"><div class="content">I keep (seems mistakenly) expecting them to try and push F# along with their dotnet ML tooling more since, while it is strictly typed, F# lets you mostly avoid making your types explicit so exploration of ideas in code is closer to Python than it is to c# while giving you the benefits of a type system and lots of functional goodies.</div><br/></div></div><div id="41520414" class="c"><input type="checkbox" id="c-41520414" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520304">parent</a><span>|</span><a href="#41523879">prev</a><span>|</span><a href="#41524218">next</a><span>|</span><label class="collapse" for="c-41520414">[-]</label><label class="expand" for="c-41520414">[3 more]</label></div><br/><div class="children"><div class="content">Yups. And that&#x27;s about it for F#. One can await the announcement that MSFT stops maintaining it.</div><br/><div id="41524525" class="c"><input type="checkbox" id="c-41524525" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520414">parent</a><span>|</span><a href="#41524365">next</a><span>|</span><label class="collapse" for="c-41524525">[-]</label><label class="expand" for="c-41524525">[1 more]</label></div><br/><div class="children"><div class="content">A lot of major C# features were first implemented in F#. I think of it as a place for Microsoft engineers&#x2F;researchers to be more experimental with novel features that still need to target the CLR (the dotnet VM). Sometimes even requiring changes to the CLR itself. 
In that lens, it has had a very large indirect financial impact on the dotnet ecosystem.</div><br/></div></div><div id="41524365" class="c"><input type="checkbox" id="c-41524365" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520414">parent</a><span>|</span><a href="#41524525">prev</a><span>|</span><a href="#41524218">next</a><span>|</span><label class="collapse" for="c-41524365">[-]</label><label class="expand" for="c-41524365">[1 more]</label></div><br/><div class="children"><div class="content">People have been predicting the imminent demise of F# since its first version 20 years ago.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41528985" class="c"><input type="checkbox" id="c-41528985" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41519294">prev</a><span>|</span><a href="#41519143">next</a><span>|</span><label class="collapse" for="c-41528985">[-]</label><label class="expand" for="c-41528985">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It tends to have &#x27;first error, breaks rest of compile&#x27; problems<p>Sort of.  It has a &quot;failure at a stage prevents progress to next stage&quot;, so a parse error means you won&#x27;t type check (or indeed, continue parsing).  See these proposals for some progress on the matter<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;haskellfoundation&#x2F;tech-proposals&#x2F;pull&#x2F;63">https:&#x2F;&#x2F;github.com&#x2F;haskellfoundation&#x2F;tech-proposals&#x2F;pull&#x2F;63</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;ghc-proposals&#x2F;ghc-proposals&#x2F;pull&#x2F;333">https:&#x2F;&#x2F;github.com&#x2F;ghc-proposals&#x2F;ghc-proposals&#x2F;pull&#x2F;333</a></div><br/></div></div><div id="41519143" class="c"><input type="checkbox" id="c-41519143" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41528985">prev</a><span>|</span><a href="#41519182">next</a><span>|</span><label class="collapse" for="c-41519143">[-]</label><label class="expand" for="c-41519143">[23 more]</label></div><br/><div class="children"><div class="content">&gt; * It tends to have &#x27;first error, breaks rest of compile&#x27; problems<p>`-fdefer-type-errors` will report those errors as warnings and fail at runtime, which is good when writing&#x2F;refactoring code. Even better the Haskell LSP does this out of the box.<p>&gt; * The tooling, although significantly better than it was, is still poor compared to other some other functional languages, and really poor compared to mainstream languages like C#<p>Which other functional programming languages do you think have better tooling? Experimenting lately with OCaml, feels like Haskell&#x27;s tooling is more mature, though OCaml&#x27;s LSP starts up faster, almost instantly.</div><br/><div id="41519171" class="c"><input type="checkbox" id="c-41519171" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519143">parent</a><span>|</span><a href="#41519374">next</a><span>|</span><label class="collapse" for="c-41519171">[-]</label><label class="expand" for="c-41519171">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Which other functional programming languages do you think have better tooling?<p>F#, Scala<p>&gt; OCaml&#x27;s LSP starts up faster<p>It was two years ago that I used Haskell last and the LSP was often crashing. But in general there were always lots of &#x27;niggles&#x27; with all parts of the tool-chain that just killed developer flow.<p>As I state in a sibling comment, the tooling is on the right trajectory, it just isn&#x27;t there yet.  So, this isn&#x27;t the main reason to not do Haskell.</div><br/><div id="41519273" class="c"><input type="checkbox" id="c-41519273" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519171">parent</a><span>|</span><a href="#41519274">next</a><span>|</span><label class="collapse" for="c-41519273">[-]</label><label class="expand" for="c-41519273">[4 more]</label></div><br/><div class="children"><div class="content">Coincidentally I&#x27;ve started using the Haskell LSP around two years ago, and crashing is not one of the issues I&#x27;ve had with it.<p>Since you mention F#, and C# in your previous comment, are you on the Windows platform? Maybe our experience different because of platform as well. Using GHCup to keep in sync compatible versions of GHC, Cabal and the LSP probably contributed a lot to the consistent feel of the tooling.<p>I use the Haskell LSP for its autocompletion, reporting compile errors in my editor, and highlighting of types under cursor. There are still shortcomings with it that are annoyances:<p>* When I open up vim, it takes a good 5-10 seconds (if not a bit more) until the LSP is finally running.<p>* When a new dependency is added to the cabal file, the LSP needs to be restarted (usually I quit vim and reopen the project).<p>* Still no support for goto definition for external libraries. The workaround I   have to use in this case is to `cabal get dependency-version` in a gitignored directory and use hasktags to keep a tags file to jump to those definitions and read the source code&#x2F;comments.<p>The later two have open GitHub issues, so at least I know they will get solved at some point.</div><br/><div id="41524612" class="c"><input type="checkbox" id="c-41524612" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519273">parent</a><span>|</span><a href="#41519292">next</a><span>|</span><label class="collapse" for="c-41524612">[-]</label><label class="expand" for="c-41524612">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been using f# in production for 4+ years and haven’t used windows in like 15 years.<p>Speaking of LSP, the lsp standard is developed by Microsoft so naturally any dotnet language will have good lsp support.</div><br/></div></div><div id="41519292" class="c"><input type="checkbox" id="c-41519292" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519273">parent</a><span>|</span><a href="#41524612">prev</a><span>|</span><a href="#41523902">next</a><span>|</span><label class="collapse" for="c-41519292">[-]</label><label class="expand" for="c-41519292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since you mention F#, and C# in your previous comment, are you on the Windows platform?<p>Linux Mint.</div><br/></div></div><div id="41523902" class="c"><input type="checkbox" id="c-41523902" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519273">parent</a><span>|</span><a href="#41519292">prev</a><span>|</span><a href="#41519274">next</a><span>|</span><label class="collapse" for="c-41523902">[-]</label><label class="expand" for="c-41523902">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since you mention F#, and C# in your previous comment, are you on the Windows platform?<p>Since dotnet core (now dotnet 5+), the Microsoft version of dotnet has not been tied to windows outside a few exceptions like old Windows UI libraries (WPF&#x2F;WinForms) and stuff like WCF once they revived it.</div><br/></div></div></div></div><div id="41519274" class="c"><input type="checkbox" id="c-41519274" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519171">parent</a><span>|</span><a href="#41519273">prev</a><span>|</span><a href="#41519514">next</a><span>|</span><label class="collapse" for="c-41519274">[-]</label><label class="expand" for="c-41519274">[1 more]</label></div><br/><div class="children"><div class="content">The Haskell LSP crashes less often now than 2 years ago. It isn&#x27;t perfect yet, but pretty usable for us.</div><br/></div></div><div id="41519514" class="c"><input type="checkbox" id="c-41519514" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519171">parent</a><span>|</span><a href="#41519274">prev</a><span>|</span><a href="#41519374">next</a><span>|</span><label class="collapse" for="c-41519514">[-]</label><label class="expand" for="c-41519514">[10 more]</label></div><br/><div class="children"><div class="content">Has Scala gotten better because I remember it being quite painful in the past (tho probably mostly due to language issues more than anything)</div><br/><div id="41520708" class="c"><input type="checkbox" id="c-41520708" checked=""/><div class="controls bullet"><span class="by">bad_user</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519514">parent</a><span>|</span><a href="#41519823">next</a><span>|</span><label class="collapse" for="c-41520708">[-]</label><label class="expand" for="c-41520708">[5 more]</label></div><br/><div class="children"><div class="content">The IntelliJ IDEA plugin for Scala is built by Jetbrains, so it has official support. It has its quirks, but so does the Kotlin plugin.<p>Sbt is better than Gradle IMO, as it has a saner mental model, although for apps you can use Gradle or Maven. Sbat has had some awesome plugins that can help in bigger teams, such as Scalafmt (automatic formatting), Scalafix (automatic refactoring), Wartremover and others. Scalafmt specifically is best in class. With Sbt you can also specify  versioning schemes for your dependencies and so you can make the build fail on problematic dependency evictions.<p>Scala CLI is also best in class, making it comfortable to use Scala for scripting – it replaced Python and Ruby for me: <a href="https:&#x2F;&#x2F;scala-cli.virtuslab.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;scala-cli.virtuslab.org&#x2F;</a><p>Note that Java and Kotlin have Jbang, but Scala CLI is significantly better, also functioning as a REPL. Worth mentioning that other JVM languages hardly have a usable REPL, if at all.<p>The Scala compiler can be slow, but that&#x27;s when you use libraries doing a lot of compile-time derivation or other uses of macros. You get the same effect in similar languages (with the exception of Ocaml). OTOH the Scala compiler can do incremental compilation, and alongside Sbt&#x27;s support for multiple sub-projects or continuous testing, it works fairly well.<p>Scala also has a really good LSP implementation, Metals, built in cooperation with the compiler team, so you get good support in VS Code or Vim. To get a sense of where this matters, consider that Scala 3.5 introduces &quot;best effort compilation&quot;: <a href="https:&#x2F;&#x2F;github.com&#x2F;scala&#x2F;scala3&#x2F;pull&#x2F;17582">https:&#x2F;&#x2F;github.com&#x2F;scala&#x2F;scala3&#x2F;pull&#x2F;17582</a><p>I also like Kotlin and sadly, it&#x27;s missing a good LSP implementation, and I don&#x27;t think Jetbrains is interested in developing it.<p>Also you get all the tooling that&#x27;s JVM specific, including  all the profilers and debuggers. With GraalVM&#x27;s native image, for example, Scala fares better than Java actually, because Scala code relies less on runtime reflection.<p>I&#x27;d also mention Scala Native or ScalaJS which are nice to have. Wasm support is provided via LLVM, but there&#x27;s also initial support for Wasm GC.<p>So to answer your question, yes, Scala has really good tooling compared to other languages, although there&#x27;s room for improvement. And if you&#x27;re comparing it to any other language that people use for FP, then Scala definitely has better tooling.</div><br/><div id="41522770" class="c"><input type="checkbox" id="c-41522770" checked=""/><div class="controls bullet"><span class="by">ldite</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520708">parent</a><span>|</span><a href="#41527050">next</a><span>|</span><label class="collapse" for="c-41522770">[-]</label><label class="expand" for="c-41522770">[3 more]</label></div><br/><div class="children"><div class="content">SBT is awful. I&#x27;ve never used Gradle, but if SBT is saner then I&#x27;m worried. This blogpost is a bit old, but still on-target: <a href="https:&#x2F;&#x2F;www.lihaoyi.com&#x2F;post&#x2F;SowhatswrongwithSBT.html" rel="nofollow">https:&#x2F;&#x2F;www.lihaoyi.com&#x2F;post&#x2F;SowhatswrongwithSBT.html</a></div><br/><div id="41528139" class="c"><input type="checkbox" id="c-41528139" checked=""/><div class="controls bullet"><span class="by">bad_user</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41522770">parent</a><span>|</span><a href="#41523924">next</a><span>|</span><label class="collapse" for="c-41528139">[-]</label><label class="expand" for="c-41528139">[1 more]</label></div><br/><div class="children"><div class="content">All build tools are terrible, and among the available build tools, Sbt is OK.<p>Let me give you an example … in Gradle, the order in which you specify plugins matters, due to the side effects. Say, if you specify something complex, like Kotlin&#x27;s multiplatform plugin, in the wrong order with something else, it can break your build definition. I bumped into this right off the gate, with my first Kotlin project.<p>In Sbt this used to matter as well, but because Sbt has this design of having the build definition as an immutable data structure that&#x27;s fairly declarative, people worked on solving the problem (via auto-loading), and since then, I&#x27;ve never bumped again into ordering issues.<p>There are other examples as well, such as consistency. In Sbt there&#x27;s only one way to specify common settings, and the keys used are consistent. Specifying Java&#x27;s targeted version, for example, uses the same key, regardless if the project is a plain JVM one, or a multiplatform one.<p>Sharing settings and code across subprojects is another area where Gradle is a clusterfuck, whereas in Sbt it&#x27;s pretty straightforward.<p>Don&#x27;t get me wrong, Gradle doesn&#x27;t bother me, and it has some niceties too. Other ecosystems would be lucky to have something like Gradle. But I find it curious to see so many people criticizing it when almost everything else is pretty terrible, with few exceptions.<p>---<p>Note that Li Haoyi has great taste, and Mill is looking good, actually. But he also likes reinventing the wheel, and the problem with that for build tools is that standardization has value.<p>Standardization has so much value for me that I would have liked for Scala to use Gradle as the standard build tool, and for Scala folks to work with Gradle&#x27;s authors to introduce Scala as an alternative scripting language for it, despite me liking Gradle a lot less. Because it would&#x27;ve made switching and cross-language JVM development easier.</div><br/></div></div><div id="41523924" class="c"><input type="checkbox" id="c-41523924" checked=""/><div class="controls bullet"><span class="by">dionian</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41522770">parent</a><span>|</span><a href="#41528139">prev</a><span>|</span><a href="#41527050">next</a><span>|</span><label class="collapse" for="c-41523924">[-]</label><label class="expand" for="c-41523924">[1 more]</label></div><br/><div class="children"><div class="content">SBT has a learning curve but it also has a nice ecosystem, for example sbt-native-packager is better than its competitors in maven or gradle.</div><br/></div></div></div></div><div id="41527050" class="c"><input type="checkbox" id="c-41527050" checked=""/><div class="controls bullet"><span class="by">rbonvall</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520708">parent</a><span>|</span><a href="#41522770">prev</a><span>|</span><a href="#41519823">next</a><span>|</span><label class="collapse" for="c-41527050">[-]</label><label class="expand" for="c-41527050">[1 more]</label></div><br/><div class="children"><div class="content">Sbt is too complex and powerful for its own good. I had a love-hate relationship with it, and now I try to avoid it if I can.<p>I like scala-cli a lot. It&#x27;s very promising, but I think it&#x27;s too new to be proclaimed best-in-class yet. Time will tell, and I&#x27;m rooting for it.</div><br/></div></div></div></div><div id="41519823" class="c"><input type="checkbox" id="c-41519823" checked=""/><div class="controls bullet"><span class="by">draven</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519514">parent</a><span>|</span><a href="#41520708">prev</a><span>|</span><a href="#41519886">next</a><span>|</span><label class="collapse" for="c-41519823">[-]</label><label class="expand" for="c-41519823">[2 more]</label></div><br/><div class="children"><div class="content">Well, there&#x27;s Intellij IDEA with the scala plugin, and it&#x27;s pretty good. I regularly debug my code in the IDE with conditional breakpoints, etc.<p>SBT still makes me want to throw the laptop through the window.</div><br/><div id="41520479" class="c"><input type="checkbox" id="c-41520479" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519823">parent</a><span>|</span><a href="#41519886">next</a><span>|</span><label class="collapse" for="c-41520479">[-]</label><label class="expand" for="c-41520479">[1 more]</label></div><br/><div class="children"><div class="content">In the pre-LSP era, I worked as a novice Scala developer, and I didn most of my Scala work in Emacs with ENSIME. It was pretty good. I imagine the language server is pretty usable by now.</div><br/></div></div></div></div><div id="41519886" class="c"><input type="checkbox" id="c-41519886" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519514">parent</a><span>|</span><a href="#41519823">prev</a><span>|</span><a href="#41519374">next</a><span>|</span><label class="collapse" for="c-41519886">[-]</label><label class="expand" for="c-41519886">[2 more]</label></div><br/><div class="children"><div class="content">Scala&#x27;s has made some horrible language compromises in order to live on the JVM in my opinion.</div><br/><div id="41520727" class="c"><input type="checkbox" id="c-41520727" checked=""/><div class="controls bullet"><span class="by">bad_user</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519886">parent</a><span>|</span><a href="#41519374">next</a><span>|</span><label class="collapse" for="c-41520727">[-]</label><label class="expand" for="c-41520727">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that Scala&#x27;s &quot;compromises&quot; in general make it a better language than many others, independent of the JVM.<p>But we can talk specifics if you want. Name some compromises.</div><br/></div></div></div></div></div></div></div></div><div id="41519374" class="c"><input type="checkbox" id="c-41519374" checked=""/><div class="controls bullet"><span class="by">lkmain</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519143">parent</a><span>|</span><a href="#41519171">prev</a><span>|</span><a href="#41521968">next</a><span>|</span><label class="collapse" for="c-41519374">[-]</label><label class="expand" for="c-41519374">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t yet felt the need for third party tooling in OCaml. OCaml has real abstractions, easily readable modules and one can keep the whole language in one&#x27;s head.<p>Usually people do not use objects, and if they do, they don&#x27;t create a tightly coupled object mess that can only be unraveled by an IDE.</div><br/></div></div><div id="41521968" class="c"><input type="checkbox" id="c-41521968" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519143">parent</a><span>|</span><a href="#41519374">prev</a><span>|</span><a href="#41524899">next</a><span>|</span><label class="collapse" for="c-41521968">[-]</label><label class="expand" for="c-41521968">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Experimenting lately with OCaml, feels like Haskell&#x27;s tooling is more mature.<p>I feel like OCaml has been on a fast upward trajectory the past couple of years.  Both in terms of language features and tooling.  I expect the developer experience to surpass Haskell if it hasn&#x27;t already.<p>I really like Merlin&#x2F;ocaml-lsp.  Sure, it doesn&#x27;t have every LSP feature like a tool with a lot of eyes on it, such as clangd, but it handles nearly everything.<p>And yeah, dune is a little odd, but I haven&#x27;t had any issues with it in a while.  I even have some curve-ball projects that involve a fair amount of C&#x2F;FFI work.<p>My only complaint with opam is how switches feel a little clunky.  But still, I&#x27;ll take it over pip, npm, all day.<p>I&#x27;ve been using OCaml for years now and compared to most other languages, the experience has been pretty pleasant.</div><br/><div id="41523549" class="c"><input type="checkbox" id="c-41523549" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41521968">parent</a><span>|</span><a href="#41524899">next</a><span>|</span><label class="collapse" for="c-41523549">[-]</label><label class="expand" for="c-41523549">[1 more]</label></div><br/><div class="children"><div class="content">My little experiments with OCaml have been pleasant thus far (in terms of language ergonomics), but on the tooling side Haskell (or rather I should say GHC) is pretty sweet.<p>For what I had to do thus far, at one point I needed to step debug through my code. Whereas in GHC land I reload my project in the interpreter (GHCi or cabal repl), set a break point on function name and step through the execution. With OCaml I have to go through the separate bytecode compiler to build it with debug symbols and the I can navigate through program execution. The nice thing is that I can easily go back in execution in flow (&quot;timetravel debugging&quot;), but a less ergonomic. Also less experienced with this flow, to consider my issues authoritative.<p>I don&#x27;t have that much experience with dune (aside from setting up a project and running dune build), but one thing that confused me at first, is that the libraries I have to add to the configuration do not necessarily match the Opam package names.<p>The LSP is fast, as mentioned before, it supports goto definition, but once I jump to a definition to one of my dependencies I get a bunch of squiggly lines in those files (probably can&#x27;t see transitive dependency symbols, if I where to guess). I can navigate dependencies one level deeper than I can with the Haskell language server, though.<p>I actually want to better understand how to build my projects without Dune, and probably will attempt to do so in the future. The same way I know how to manage a Haskell project without Cabal. Feels like it gives me a better understanding of the ecosystem.</div><br/></div></div></div></div><div id="41524899" class="c"><input type="checkbox" id="c-41524899" checked=""/><div class="controls bullet"><span class="by">innocentoldguy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519143">parent</a><span>|</span><a href="#41521968">prev</a><span>|</span><a href="#41519241">next</a><span>|</span><label class="collapse" for="c-41524899">[-]</label><label class="expand" for="c-41524899">[2 more]</label></div><br/><div class="children"><div class="content">Elixir’s tooling is awesome, in my opinion.</div><br/><div id="41527774" class="c"><input type="checkbox" id="c-41527774" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41524899">parent</a><span>|</span><a href="#41519241">next</a><span>|</span><label class="collapse" for="c-41527774">[-]</label><label class="expand" for="c-41527774">[1 more]</label></div><br/><div class="children"><div class="content">I’m curious what you think is awesome about its tooling? For me,  mix is capable enough, but I consider the IDE story to be pretty lacking actually.</div><br/></div></div></div></div></div></div><div id="41519182" class="c"><input type="checkbox" id="c-41519182" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41519143">prev</a><span>|</span><a href="#41519727">next</a><span>|</span><label class="collapse" for="c-41519182">[-]</label><label class="expand" for="c-41519182">[1 more]</label></div><br/><div class="children"><div class="content">No lies detected. I love Haskell, but productivity is a function of the entire ecosystem, and it’s just not there compared to most mainstream languages.</div><br/></div></div><div id="41519727" class="c"><input type="checkbox" id="c-41519727" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41519182">prev</a><span>|</span><a href="#41524340">next</a><span>|</span><label class="collapse" for="c-41519727">[-]</label><label class="expand" for="c-41519727">[3 more]</label></div><br/><div class="children"><div class="content">Most of your comments boil down to two items:<p>- The Haskell ecosystem doesn&#x27;t have the budget of languages like Java or C# to build its tooling.<p>- The haskell ecosystem was innovative 20 years ago, but some newer languages like Rust or Elm have much better ergonomics due to learning from their forebearers.<p>Yes, it&#x27;s true. And it&#x27;s true for almost any smaller language out there.</div><br/><div id="41520260" class="c"><input type="checkbox" id="c-41520260" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519727">parent</a><span>|</span><a href="#41519898">next</a><span>|</span><label class="collapse" for="c-41520260">[-]</label><label class="expand" for="c-41520260">[1 more]</label></div><br/><div class="children"><div class="content">If you boil down my comments, sure, you could say that.  But, that&#x27;s why I didn&#x27;t boil down my comments and used more words, because ultimately, it doesn&#x27;t say that.<p>The thread is &quot;Why Haskell?&quot;, I&#x27;m offering a counterpoint based on experience. YMMV and that&#x27;s fine.</div><br/></div></div><div id="41519898" class="c"><input type="checkbox" id="c-41519898" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519727">parent</a><span>|</span><a href="#41520260">prev</a><span>|</span><a href="#41524340">next</a><span>|</span><label class="collapse" for="c-41519898">[-]</label><label class="expand" for="c-41519898">[1 more]</label></div><br/><div class="children"><div class="content">Counterpoint: Elixir. While it sits on top of industrial-grade Erlang VM, the language itself produced a huge ecosystem of pragmatic and useful tools and libraries.</div><br/></div></div></div></div><div id="41524340" class="c"><input type="checkbox" id="c-41524340" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41519727">prev</a><span>|</span><a href="#41521004">next</a><span>|</span><label class="collapse" for="c-41524340">[-]</label><label class="expand" for="c-41524340">[1 more]</label></div><br/><div class="children"><div class="content">The Haskell community is also very opinionated when it comes to style and some of the choices are not to everyone taste. I’m mostly thinking of point-free being seen as an ideal and the liberal usage of operators.</div><br/></div></div><div id="41521004" class="c"><input type="checkbox" id="c-41521004" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41524340">prev</a><span>|</span><a href="#41519201">next</a><span>|</span><label class="collapse" for="c-41521004">[-]</label><label class="expand" for="c-41521004">[3 more]</label></div><br/><div class="children"><div class="content">I completely agree. I&#x27;m interested in making the Haskell tooling system better. I would welcome anyone with Haskell experience to let me know what you think would be the highest priority items here.<p>I&#x27;m also curious about the slowness of compilation and whether that&#x27;s intrinsic to the design of GHC.</div><br/><div id="41522958" class="c"><input type="checkbox" id="c-41522958" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41521004">parent</a><span>|</span><a href="#41519201">next</a><span>|</span><label class="collapse" for="c-41522958">[-]</label><label class="expand" for="c-41522958">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I would welcome anyone with Haskell experience to let me know what you think would be the highest priority items here.<p>Simplifying cabal probably, though that&#x27;s a system-level problem, just just a cabal codebase problem.</div><br/><div id="41526302" class="c"><input type="checkbox" id="c-41526302" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41522958">parent</a><span>|</span><a href="#41519201">next</a><span>|</span><label class="collapse" for="c-41526302">[-]</label><label class="expand" for="c-41526302">[1 more]</label></div><br/><div class="children"><div class="content">thanks!</div><br/></div></div></div></div></div></div><div id="41519201" class="c"><input type="checkbox" id="c-41519201" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41521004">prev</a><span>|</span><a href="#41522671">next</a><span>|</span><label class="collapse" for="c-41519201">[-]</label><label class="expand" for="c-41519201">[8 more]</label></div><br/><div class="children"><div class="content">&gt; The library ecosystem is probably the biggest issue.<p>I&#x27;d love to know which things specifically you&#x27;re thinking about. For what we&#x27;ve been building, the &quot;integration&quot; libraries for postgres, AWS, etc. have been fine for us, likewise HTTP libraries (e.g. Servant) have been great.<p>I haven&#x27;t _yet_ encountered a library problem, so am just very curious.</div><br/><div id="41519392" class="c"><input type="checkbox" id="c-41519392" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519201">parent</a><span>|</span><a href="#41519477">next</a><span>|</span><label class="collapse" for="c-41519392">[-]</label><label class="expand" for="c-41519392">[3 more]</label></div><br/><div class="children"><div class="content">A few years ago I tried to use Servant to make a CAS[0] implementation for an academic project.<p>One issue I ran into was that Servant didn&#x27;t have a proper way of overriding content negotiation: the CAS protocol specified a &quot;?format=json&quot; &#x2F; &quot;?format=xml&quot; parameter, but Servant had no proper way of overriding its automatic content negotiation - which is baked deeply into its type system. I believe at the time I came across an ancient bug report which concluded that it was an &quot;open research question&quot; which would require &quot;probably a complete rework&quot;.<p>Another issue was that Servant doesn&#x27;t have proper integrated error handling. The library is designed around returning a 200 response, and provides a lot of tooling to make that easy and safe. However, I noticed that at the time its design essentially completely ignored failures! Your best option was basically a `Maybe SomeResponseType` which in the `None` case gave a 200 response with a &quot;{&#x27;status&#x27;: &#x27;error&#x27;}&quot; content. There was a similar years-old bug report for this issue, which is quite worrying considering it&#x27;s not exactly rocket science, and pretty much every single web developer is going to run into it.<p>All of this gave a feeling of a very rough and unfinished library, whose author was more concerned about writing a research paper than actually making useful software. Luckily those issues had no real-world implication for me, as I was only a student losing a few days on some minor project. But if I were to come across this during professional software development I&#x27;d be seriously pissed, and probably write off the entire ecosystem: if <i>this</i> is what I can expect from &quot;great&quot; libraries, what does the average ones look like - am I going to have to write every single trivial thing from scratch?<p>I really love the core language of Haskell, but after running into issues like these a few dozen times I unfortunately have trouble justifying using it to myself. Maybe Haskell will be great five or ten years from now, but in its current state I fear it is probably best to use something else.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Central_Authentication_Service" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Central_Authentication_Service</a></div><br/><div id="41520651" class="c"><input type="checkbox" id="c-41520651" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519392">parent</a><span>|</span><a href="#41519477">next</a><span>|</span><label class="collapse" for="c-41520651">[-]</label><label class="expand" for="c-41520651">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Your best option was basically a `Maybe SomeResponseType` which in the `None` case gave a 200 response with a &quot;{&#x27;status&#x27;: &#x27;error&#x27;}&quot; content.<p>This seems to be an area where my tastes diverge from the mainstream, but I&#x27;m not a fan of folding errors together. I&#x27;d rather a http status code only correspond to the actual http transport part, and if an API hosted there has an error to tell me, that should be layered on top.</div><br/><div id="41525083" class="c"><input type="checkbox" id="c-41525083" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520651">parent</a><span>|</span><a href="#41519477">next</a><span>|</span><label class="collapse" for="c-41525083">[-]</label><label class="expand" for="c-41525083">[1 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s why errors have categories:<p>HTTP status ranges in a nutshell:<p>1xx: hold on<p>2xx: here you go<p>3xx: go away<p>4xx: you fucked up<p>5xx: I fucked up<p>(<a href="https:&#x2F;&#x2F;x.com&#x2F;stevelosh&#x2F;status&#x2F;372740571749572610" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;stevelosh&#x2F;status&#x2F;372740571749572610</a>)</div><br/></div></div></div></div></div></div><div id="41519477" class="c"><input type="checkbox" id="c-41519477" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519201">parent</a><span>|</span><a href="#41519392">prev</a><span>|</span><a href="#41519342">next</a><span>|</span><label class="collapse" for="c-41519477">[-]</label><label class="expand" for="c-41519477">[1 more]</label></div><br/><div class="children"><div class="content">I tried building a couple small projects to get familiar with the language.<p>One project did a bunch of calculation based on geolocation and geometry. I needed to output graphs and after looking around, reached for gnuplot. Turns out, it’s a wrapper around a system call to launch gnuplot in a child process. There is no handle returned so you can never know when the plot is done. If you exit as soon as the call returns, you get to race gnuplot to the temp file that gets automatically cleaned up by your process. The only way to eliminate the race is by sleeping… so if you add more plots, make sure you increase your sleep time too. :-&#x2F;<p>Another utility was a network oriented daemon. I needed to capture packets and then run commands based on them… so I reached for pcap. It uses old bindings (which is fine) and doesn’t expose the socket or any way to set options for the socket. Long story short, it never worked. I looked at the various other interfaces around pcap but there was always a significant deficiency of some kind for my use case.<p>Now, I’m not a seasoned Haskell programmer by any means and it’s possible I am just missing out on something fundamental. However, it really looks to me like someone did a quick hack that worked for a very specific use-case for both of these libraries.<p>The language is cool but I’ve definitely struggled with libraries.</div><br/></div></div><div id="41519342" class="c"><input type="checkbox" id="c-41519342" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519201">parent</a><span>|</span><a href="#41519477">prev</a><span>|</span><a href="#41519277">next</a><span>|</span><label class="collapse" for="c-41519342">[-]</label><label class="expand" for="c-41519342">[1 more]</label></div><br/><div class="children"><div class="content">The project was a cloud agnostic platform-as-a-service for building healthcare applications.  It needed graph-DBs, Postgres, all clouds, localisation, event-streams, UIs, etc.  I won&#x27;t list where the problems were, because I don&#x27;t think it&#x27;s helpful -- each project has its own needs, you may well be lucky where we were not.  Certainly the project wasn&#x27;t a standard enterprise app, it was much more complex, so we had some foundational things we needed that perhaps your average dev doesn&#x27;t need.  However, other ecosystems would usually have a decent off-the-shelf versions, because they&#x27;re more mature&#x2F;evolved.<p>You have to realise that none of the problems were insurmountable, I had a talented team who could overcome any of the issues, it just became like walking through treacle trying to get moving.<p>And yes, Servant was great, we used that also.  Although we didn&#x27;t get super far in testing its range.</div><br/></div></div><div id="41519277" class="c"><input type="checkbox" id="c-41519277" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519201">parent</a><span>|</span><a href="#41519342">prev</a><span>|</span><a href="#41522671">next</a><span>|</span><label class="collapse" for="c-41519277">[-]</label><label class="expand" for="c-41519277">[2 more]</label></div><br/><div class="children"><div class="content">Probably referring to something like spring (for java), which is a one stop shop for everything, including things like integration with monitoring&#x2F;analytics, rate-limiting, etc</div><br/><div id="41519507" class="c"><input type="checkbox" id="c-41519507" checked=""/><div class="controls bullet"><span class="by">okkdev</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519277">parent</a><span>|</span><a href="#41522671">next</a><span>|</span><label class="collapse" for="c-41519507">[-]</label><label class="expand" for="c-41519507">[1 more]</label></div><br/><div class="children"><div class="content">Spring is probably the worst framework created, so I wouldn&#x27;t list that as an example :&#x2F;</div><br/></div></div></div></div></div></div><div id="41522671" class="c"><input type="checkbox" id="c-41522671" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41519201">prev</a><span>|</span><a href="#41520640">next</a><span>|</span><label class="collapse" for="c-41522671">[-]</label><label class="expand" for="c-41522671">[7 more]</label></div><br/><div class="children"><div class="content">It is a shame that the article almost completely ignores the issue of the tooling. I particularly find the attitude in the following paragraph offensively academically true:<p><pre><code>  All mainstream, general purpose programming languages are (basically) Turing-complete, and therefore any programme you can write in one you can, in fact, write in another. There is a computational equivalence between them. The main differences are instead in the expressiveness of the languages, the guardrails they give you, and their performance characteristics (although this is possibly more of a runtime&#x2F;compiler implementation question).
</code></pre>
I decided to have a go at learning the basics of Haskell and the first error I got immediately phased me because it reminded me of unhelpful compilers of the 80s. I have bashed my head against different languages and poor tooling enough times to know I can learn, but I&#x27;ve also done it enough times that I am unwilling to masochistically force myself through that gauntlet unless I have a very good reason to do so. The &quot;joy&quot; of learning is absent with unfriendly tools.<p>The syntax summary in the article is really good. Short and clear.</div><br/><div id="41524300" class="c"><input type="checkbox" id="c-41524300" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41522671">parent</a><span>|</span><a href="#41526035">next</a><span>|</span><label class="collapse" for="c-41524300">[-]</label><label class="expand" for="c-41524300">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is a shame that the article almost completely ignores the issue of the tooling.<p>Mostly because while I found of the tooling occasionally difficult, I didn’t find Haskell particularly bad compared to other language ecosystems I’ve played with, with the exception of Rust, for which the compiler errors are really good.<p>&gt; The syntax summary in the article is really good<p>Thanks, I wasn’t so sure how to balance that bit.</div><br/></div></div><div id="41526035" class="c"><input type="checkbox" id="c-41526035" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41522671">parent</a><span>|</span><a href="#41524300">prev</a><span>|</span><a href="#41520640">next</a><span>|</span><label class="collapse" for="c-41526035">[-]</label><label class="expand" for="c-41526035">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>All mainstream, general purpose programming languages are (basically) Turing-complete, and therefore any programme you can write in one you can, in fact, write in another.</i><p>That stuck out to me as well, I said out loud &quot;that is a very Haskell thing to say&quot;. It would be more accurate to say that Turing Completeness means that any programme you write in one language, may be run in another language by writing an emulator for the first programme&#x27;s runtime, and executing the first programme in the second.<p>Because it is not &quot;in fact&quot; the case that a given developer can write a programme in language B just because that developer can write the program in language A.  It isn&#x27;t even &quot;in principle&quot; the case, computability and programming just aren&#x27;t that closely related, it&#x27;s like saying anything you can do with a chainsaw you can do with a pocketknife because they&#x27;re both Sharp Complete.<p>I shook it off and enjoyed the rest of the article, though. Haskell will never be my jam but I like reading people sing the virtues of what they love.</div><br/><div id="41526312" class="c"><input type="checkbox" id="c-41526312" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41526035">parent</a><span>|</span><a href="#41520640">next</a><span>|</span><label class="collapse" for="c-41526312">[-]</label><label class="expand" for="c-41526312">[4 more]</label></div><br/><div class="children"><div class="content">I think this is being taken as me saying “therefore you can write any programme in Haskell” which, while true, was not the point I was trying to make. Instead I was trying to reduce the possible interpretation that I was suggesting that Haskell can write more programmes than other languages, which I don’t think is true.<p>&gt; computability and programming just aren’t that related<p>I … don’t think I understand</div><br/><div id="41526645" class="c"><input type="checkbox" id="c-41526645" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41526312">parent</a><span>|</span><a href="#41520640">next</a><span>|</span><label class="collapse" for="c-41526645">[-]</label><label class="expand" for="c-41526645">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; <i>computability and programming just aren’t that related</i><p>&gt; <i>I … don’t think I understand</i><p>That&#x27;s such a Haskell thing to say!<p>Ok, I&#x27;m teasing a bit now. But there&#x27;s a kernel of truth to it: a good model of the FP school which forked off Lisp into ML, Miranda, Haskell, is as an exploration of the question &quot;what if programming was more like computability theory?&quot;, and fairly successfully, by its own &quot;avoid success at all costs&quot; criteria.<p>Computability: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computability_theory" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computability_theory</a><p>&gt; <i>Computability theory, also known as recursion theory, is a branch of mathematical logic, computer science, and the theory of computation that originated in the 1930s with the study of computable functions and Turing degrees.</i><p>Programming: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computer_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computer_programming</a><p>&gt; <i>Computer programming or coding is the composition of sequences of instructions, called programs, that computers can follow to perform tasks.</i><p>Related, yes, of course, much as physics and engineering are related. But engineering has many constraints which are not found in the physics of the domain, and many engineering decisions are not grounded in physics as a discipline.<p>So it is with computability and programming.<p>&gt; <i>“therefore you can write any programme in Haskell” which, while true</i><p>It is not. That&#x27;s my point. One can write an emulator for any programme in Haskell, <i>in principle</i>, but that&#x27;s not at all the same thing as saying <i>you</i> can write <i>any programme</i> in <i>fact</i>.<p>For instance, you cannot write this in Haskell:<p><a href="http:&#x2F;&#x2F;krue.net&#x2F;avrforth&#x2F;" rel="nofollow">http:&#x2F;&#x2F;krue.net&#x2F;avrforth&#x2F;</a><p>You could write something in Haskell <i>in which you could write this</i>, but those are different complexity classes, different programs, and very, <i>very</i> different practices. They aren&#x27;t the same, they don&#x27;t reduce to each other.  You can write an AVR emulator and run avrforth in it. But that&#x27;s not going to get the blinkenlichten to flippen floppen on the dev board.<p>Haskell, in fact, goes to great lengths to restrict the possible programs one can write! That&#x27;s one of the fundamental premises of the language, because (the hope is that) most of those programs are <i>wrong</i>.  About the first half of your post is about things like accidental null dereferencing which Haskell won&#x27;t let you do.<p>In programming, the tools one chooses, and ones abilities with those tools, and the nature of the problem domain, all intersect to, <i>in fact</i>, restrict and shape the nature, quality, completeness, and even getting-startedness, of the program.  Turing Completeness doesn&#x27;t change that, and even has limited bearing on it.</div><br/><div id="41529264" class="c"><input type="checkbox" id="c-41529264" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41526645">parent</a><span>|</span><a href="#41528206">next</a><span>|</span><label class="collapse" for="c-41529264">[-]</label><label class="expand" for="c-41529264">[1 more]</label></div><br/><div class="children"><div class="content">Oh ok I get what you mean now, I thought you were being a bit more obtuse than that.<p>So my original intent with that paragraph was very different, but you&#x27;re right that I was not very precise with some of those statements.<p>Thanks for taking the time to explain, you&#x27;ve definitely helped expand the way I&#x27;ve thought about this.</div><br/></div></div><div id="41528206" class="c"><input type="checkbox" id="c-41528206" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41526645">parent</a><span>|</span><a href="#41529264">prev</a><span>|</span><a href="#41520640">next</a><span>|</span><label class="collapse" for="c-41528206">[-]</label><label class="expand" for="c-41528206">[1 more]</label></div><br/><div class="children"><div class="content">Nicely said, this in particular;<p>&gt; In programming, the tools one chooses, and ones abilities with those tools, and the nature of the problem domain, all intersect to, in fact, restrict and shape the nature, quality, completeness, and even getting-startedness, of the program.<p>Language shapes thought and hence once the simpler Imperative programming models (Procedural, OOP) are learnt it becomes quite hard for the Programmer to switch mental models to FP. The FP community has really not done a good job of educating such programmers who are the mainstay in the Industry.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41520640" class="c"><input type="checkbox" id="c-41520640" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41522671">prev</a><span>|</span><a href="#41519010">next</a><span>|</span><label class="collapse" for="c-41520640">[-]</label><label class="expand" for="c-41520640">[3 more]</label></div><br/><div class="children"><div class="content">&gt; compared to mainstream languages like C#<p>Out of curiosity does this also hold true for F#?</div><br/><div id="41523650" class="c"><input type="checkbox" id="c-41523650" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41520640">parent</a><span>|</span><a href="#41519010">next</a><span>|</span><label class="collapse" for="c-41523650">[-]</label><label class="expand" for="c-41523650">[2 more]</label></div><br/><div class="children"><div class="content">F#’s tooling is worse than C# for sure, but it’s a big step-up from Haskell and has access to the .NET framework.<p>I listed C# because that’s the mainstream language I know the best, and arguably has best-in-class tooling.<p>Of course you have to be prepared to lose some of the creature comforts when using a more left-field language. But, you still need to be productive. The whole ecosystem has to be a net gain in productivity, or stability, or security, or maintainability — pick your poison depending on what matters to your situation.<p>I had hoped Haskell would pay dividends due to its purity, expressive type-system, battle tested-ness, etc.  I expected us to be slower, just not as slow as it turned out.<p>Ultimately the trade off didn’t work for us.</div><br/><div id="41528023" class="c"><input type="checkbox" id="c-41528023" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41523650">parent</a><span>|</span><a href="#41519010">next</a><span>|</span><label class="collapse" for="c-41528023">[-]</label><label class="expand" for="c-41528023">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the answer. It’s exactly because of C#’s excellent tooling I was wondering if they had done similar for F#.<p>&gt; The whole ecosystem has to be a net gain in productivity, or stability, or security, or maintainability — pick your poison depending on what matters to your situation.<p>I very much agree with you on this. I’ve worked in places where we used Typescript on the back-end because it was easier for a small team to work together (and go on vacations) while working in the same language even though there was a trade off performance wise. Ultimately I think it’s always about finding the best way to be productive.</div><br/></div></div></div></div></div></div><div id="41519010" class="c"><input type="checkbox" id="c-41519010" checked=""/><div class="controls bullet"><span class="by">Vosporos</span><span>|</span><a href="#41518959">parent</a><span>|</span><a href="#41520640">prev</a><span>|</span><a href="#41519099">next</a><span>|</span><label class="collapse" for="c-41519010">[-]</label><label class="expand" for="c-41519010">[7 more]</label></div><br/><div class="children"><div class="content">If you are willing &#x2F; able to report these pain points in detail to the Haskell Foundation, this is going to be valuable feedback that will help orient the investments in tooling in the near future.</div><br/><div id="41519142" class="c"><input type="checkbox" id="c-41519142" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519010">parent</a><span>|</span><a href="#41519109">next</a><span>|</span><label class="collapse" for="c-41519142">[-]</label><label class="expand" for="c-41519142">[4 more]</label></div><br/><div class="children"><div class="content">All bug reports are good. But is this not obvious? Do the Haskell developers not use other language ecosystems? This goes beyond “this edge case is difficult” and into “the whole tooling stack is infamously hard to work with.” I just assumed Haskell, like eMacs, attracted a certain kind of developer that embraced the warts.</div><br/><div id="41519230" class="c"><input type="checkbox" id="c-41519230" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519142">parent</a><span>|</span><a href="#41519278">next</a><span>|</span><label class="collapse" for="c-41519230">[-]</label><label class="expand" for="c-41519230">[2 more]</label></div><br/><div class="children"><div class="content">No, we use plenty of other stuff.<p>My $DAYJOB language:<p>* Can&#x27;t build a binary<p>* Uses an inexplicable amount of memory.<p>* Has an IDE which constantly puts itself into a bad state.  E.g. it highlights and underlines code with red even when I know it&#x27;s a pristine copy that passes its tests.  I periodically have to close the project, navigate to it in the terminal, run &#x27;git status --ignored&#x27; and delete all that crap and re-open the project.<p>* Is slow to start up.<p>* Has a build system with no obvious way to use a &#x27;master list&#x27; of version numbers.  In our microservice&#x2F;microrepo system, it is a PITA to try to track down and remove a vulnerable dependency.<p>* Has been receiving loads of praise over the last 18 months for starting to include stuff that Haskell has included for ages.  How&#x27;s the latest &quot;we&#x27;re solving the null problem&quot; going?<p>What the GHC compiler does for me is just so much better at producing working software than $DAYJOB language + professional $DAYJOB IDE, that I don&#x27;t think about the tooling.<p>If you want to put yourself in my shoes: imagine you&#x27;re getting shit done with TypeScript every day, and some C programmers come along and complain that it&#x27;s missing the bare minimum of tools: strace, valgrind and gdb.  How do you even reply to that?</div><br/><div id="41519312" class="c"><input type="checkbox" id="c-41519312" checked=""/><div class="controls bullet"><span class="by">actualwitch</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519230">parent</a><span>|</span><a href="#41519278">next</a><span>|</span><label class="collapse" for="c-41519312">[-]</label><label class="expand" for="c-41519312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you want to put yourself in my shoes: imagine you&#x27;re getting shit done with TypeScript every day, and some C programmers come along and complain that it&#x27;s missing the bare minimum of tools: strace, valgrind and gdb. How do you even reply to that?<p>You tell them to strace&#x2F;valgrind node whatever.js and instead of gdb use built-in v8 debugger as node inspect whatever.js</div><br/></div></div></div></div><div id="41519278" class="c"><input type="checkbox" id="c-41519278" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519142">parent</a><span>|</span><a href="#41519230">prev</a><span>|</span><a href="#41519109">next</a><span>|</span><label class="collapse" for="c-41519278">[-]</label><label class="expand" for="c-41519278">[1 more]</label></div><br/><div class="children"><div class="content">We do use other ecosystems, yes. I haven&#x27;t really found the tooling for Haskell to be particularly obstructive compared to other languages. I&#x27;ve run into plenty of mysteries in the typescript, python, ObjC&#x2F;Swift, etc. ecosystems that have been just as irritating (sometimes much more irritating), and generally find that while HLS can be a bit janky, GHC is very good and I spend less time scratching my head looking at a piece of code that should work but does something wild than in other languages.</div><br/></div></div></div></div><div id="41519109" class="c"><input type="checkbox" id="c-41519109" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41518959">root</a><span>|</span><a href="#41519010">parent</a><span>|</span><a href="#41519142">prev</a><span>|</span><a href="#41519099">next</a><span>|</span><label class="collapse" for="c-41519109">[-]</label><label class="expand" for="c-41519109">[2 more]</label></div><br/><div class="children"><div class="content">I think tooling is something that is clearly on a good trajectory.  When I consider what the Haskell tooling was like when I first started using it, well, it was non-existent! (and Cabal didn&#x27;t even understand what dependencies were, haha!)<p>So, it&#x27;s much, much better than it was.  It&#x27;s still not comparable to mainstream languages, but it&#x27;s going the right way.  So, I wouldn&#x27;t necessarily take that as the killer.<p>The biggest issue was the library ecosystem.  We spent an not-small amount of time evaluating libraries, realising they were not up to scratch, trying to do build our own, or interacting with the authors to understand the plans.  When you&#x27;re trying to get moving at the start of a project, this can be quite painful.  It takes longer to get to an MVP.  That&#x27;s tough when there are eyes on its success or not.<p>Even though I&#x27;d been using Haskell for at least a decade before we embarked upon that path, I hadn&#x27;t really ever built anything substantial.  The greenfield project was a complex beast on a number of levels (which was one of the reasons I felt Haskell would excel, it would force us to be more robust with our architecture).  But, we just couldn&#x27;t find the libraries that were good enough.<p>My sense was there&#x27;s a lot of academics writing libraries.  I&#x27;m not implying that academics write poor code; just that their motivations aren&#x27;t always aligned with what an industry dev might want.  Usually this is around simplicity and ease-of-use.  And, because quite a lot of libraries were either poorly documented or their intent was impenetrable, it would take longer to evaluate.<p>I think if the Haskell Foundation are going to do anything, then they should probably write down the top 50 needed packages in industry, and then put some funding&#x2F;effort towards helping the authors of existing libraries to bring them up to scratch (or potentially, developing their own), perhaps even create a &#x27;mainstream adoption style guide&#x27;, that standardises the library surfaces -- there&#x27;s far too much variability. It needs a keen eye on what your average industry dev needs though.<p>I realise there are plenty of companies using Haskell successfully, so this should only be one data point.  But, it is a data point of someone who is a massive Haskell (language) fan.<p>Haskell has had a massive influence on me and how I write code.  It&#x27;s directly influenced a major open-source project I have developed [1]. But, unfortunately, I don&#x27;t think I&#x27;ll use it again for a pro project.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;louthy&#x2F;language-ext">https:&#x2F;&#x2F;github.com&#x2F;louthy&#x2F;language-ext</a></div><br/></div></div></div></div></div></div><div id="41519406" class="c"><input type="checkbox" id="c-41519406" checked=""/><div class="controls bullet"><span class="by">Coolbeanstoo</span><span>|</span><a href="#41518959">prev</a><span>|</span><a href="#41519643">next</a><span>|</span><label class="collapse" for="c-41519406">[-]</label><label class="expand" for="c-41519406">[19 more]</label></div><br/><div class="children"><div class="content">I would like to use haskell or another functional language professionally.<p>I try them out (ocaml,haskell,clojure,etc) from time to time and think they&#x27;re fairly interesting, but i struggle to figure out how to make bigger programs with them as I&#x27;ve never seen how you build up a code base with the tools they provide and with someone to review the code i produce and so never have any luck with jobs i&#x27;ve applied to.<p>On the flipside I never had too much trouble figuring out how to make things with Go, as it has so little going on and because it was the first language i worked with professionally for an extended period of time. I think that also leads me to trying to apply the same patterns because I know them even if they dont really work in the world of functional languages<p>Not sure what the point of this comment is, but I think i just want to experience the moment of mind opening-ness that people talk about when it comes to working with these kinds of languages on a really good team</div><br/><div id="41519809" class="c"><input type="checkbox" id="c-41519809" checked=""/><div class="controls bullet"><span class="by">bedman12345</span><span>|</span><a href="#41519406">parent</a><span>|</span><a href="#41519778">next</a><span>|</span><label class="collapse" for="c-41519809">[-]</label><label class="expand" for="c-41519809">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been working with pure functional languages and custom lisp dialects professionally my whole tenure.
You get a whole bag of problems for a very subjective upside.
Teams fragment into those that know how to work with these fringe tools and those who don’t. The projects using them that I worked on all had trouble with getting&#x2F;retaining people. They also all had performance issues and had bugs like all other software. You’re not missing out on anything.</div><br/><div id="41529340" class="c"><input type="checkbox" id="c-41529340" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41519809">parent</a><span>|</span><a href="#41519778">next</a><span>|</span><label class="collapse" for="c-41529340">[-]</label><label class="expand" for="c-41529340">[1 more]</label></div><br/><div class="children"><div class="content">Many problems stem from people not being willing to learn another paradigm of computer programming. Of course teams will split, if some people are not willing to learn, because then some will be unable to work on certain things, while other will be able to do so.<p>You mention performance. However, if we look at how many Python shops there are, this can hardly be a problem. I imagine ecosystems to be a much bigger issue than performance. Many implementations of functional languages have better performance than Python anyway.<p>There are many reasons why a company can have issues retaining people. A shitty uninteresting product, bad management, low wages, bad culture ... Lets eliminate those and see whether they still have issues retaining devs. I suspect, that an interesting tech stack could make people stay, because it is not so easy to find a job with such a tech stack.<p>However, many companies want easily replaceable cogs, which FP programmers are definitely not these days. So they would rather hire low skill easily replaceable than highly skilled but more expensive workforce. They know they will not be able to retain the highly skilled, because they know their other factors are not in line for that.</div><br/></div></div></div></div><div id="41519778" class="c"><input type="checkbox" id="c-41519778" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#41519406">parent</a><span>|</span><a href="#41519809">prev</a><span>|</span><a href="#41527414">next</a><span>|</span><label class="collapse" for="c-41519778">[-]</label><label class="expand" for="c-41519778">[8 more]</label></div><br/><div class="children"><div class="content">I have also initially struggled with structuring Haskell programs. Without knowing anything about what you want to do, here&#x27;s my general approach:<p>1. Decide on an effect system<p>Remember, Haskell is pure, so any side-effect will be strictly explicit. What broad capabilities do you want? 
Usually, you need to access some program-level configuration (e.g. command-line options) and the ability to do IO (networking, reading&#x2F;writing files, etc), so most people start with that.<p><a href="https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;2017&#x2F;06&#x2F;readert-design-pattern&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;2017&#x2F;06&#x2F;readert-design-patt...</a><p>2. Encode your business logic in functions (purely if possible)<p>Your application does some processing of data. The details don&#x27;t matter. Use pure functions as much as possible, and factor effectful computations (e.g. database accesses) out into their own functions.<p>3. Glue everything together in a monadic context<p>Once you have all your business logic, glue everything together in a context with your effect system (usually a monad stack using ReaderT). This is usually where concurrency comes in (e.g. launch 1 thread per request).<p>---<p>Beyond this, your application design will depend on your use-case.<p>If you are interested, I strongly suggest to read &#x27;Production Haskell&#x27; by Matt Parsons, which has many chapters on &#x27;Haskell application structure&#x27;.</div><br/><div id="41522421" class="c"><input type="checkbox" id="c-41522421" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41519778">parent</a><span>|</span><a href="#41522846">next</a><span>|</span><label class="collapse" for="c-41522421">[-]</label><label class="expand" for="c-41522421">[6 more]</label></div><br/><div class="children"><div class="content">&gt; 1. Decide on an effect system<p>This shouldn&#x27;t even be proposed as a question to someone new to Haskell. They should learn how monad transformers work and just use them. 90% of developers playing around effect systems would be just fine with MTL or even just concrete transformers. All Haskell effect systems should be considered experimental at this point with unclear shelf lives.<p>Everything else you said I agree with as solid advice!</div><br/><div id="41529048" class="c"><input type="checkbox" id="c-41529048" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522421">parent</a><span>|</span><a href="#41522632">next</a><span>|</span><label class="collapse" for="c-41529048">[-]</label><label class="expand" for="c-41529048">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This shouldn&#x27;t even be proposed as a question to someone new to Haskell. They should learn how monad transformers work and just use them. 90% of developers playing around effect systems would be just fine with MTL or even just concrete transformers. All Haskell effect systems should be considered experimental at this point with unclear shelf lives.<p>This is highly debatable. I would say that the effect systems effectful and Bluefin are actually significantly simpler than MTL and transformers, particularly as soon as you need to do prompt resource cleanup.<p>Personally I&#x27;d say that if newbies should start with naked IO and then switch to effectful or Bluefin once they&#x27;ve realised the downside of IO being available everywhere.<p>&gt; All Haskell effect systems should be considered experimental at this point with unclear shelf lives.<p>effectful and Bluefin are here to stay. I guarantee it. For non-IO-based effect systems (e.g. polysemy, freer-effects) I agree.<p>(Disclaimer: I&#x27;m the author of Bluefin)</div><br/></div></div><div id="41522632" class="c"><input type="checkbox" id="c-41522632" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522421">parent</a><span>|</span><a href="#41529048">prev</a><span>|</span><a href="#41522846">next</a><span>|</span><label class="collapse" for="c-41522632">[-]</label><label class="expand" for="c-41522632">[4 more]</label></div><br/><div class="children"><div class="content">Someone truly new to Haskell shouldn&#x27;t use it professionally.<p>Once you&#x27;ve learned what is necessary to, say, modify already-existing applications, you should be familiar with monads and some basic monad transformers like ReaderT.<p>Once you&#x27;re there, I don&#x27;t think &#x27;choosing an effect system&#x27; is a perilous question. The monad transformer library, mtl, <i>is an effect system</i>, the second simplest one after IO.</div><br/><div id="41522897" class="c"><input type="checkbox" id="c-41522897" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522632">parent</a><span>|</span><a href="#41522846">next</a><span>|</span><label class="collapse" for="c-41522897">[-]</label><label class="expand" for="c-41522897">[3 more]</label></div><br/><div class="children"><div class="content">The original poster said they want to use Haskell professionally but that they are struggling to understand how to structure programs.<p>&gt; Once you&#x27;re there, I don&#x27;t think &#x27;choosing an effect system&#x27; is a perilous question. The monad transformer library, mtl, is an effect system, the second simplest one after IO.<p>I&#x27;m aware of that, generally when people say &quot;choose effect system&quot; they mean choose some algebraic effect system, all of which (in Haskell) have huge pitfalls. The default should be monad transformers unless you have some exceptional situation.</div><br/><div id="41529053" class="c"><input type="checkbox" id="c-41529053" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522897">parent</a><span>|</span><a href="#41523418">next</a><span>|</span><label class="collapse" for="c-41529053">[-]</label><label class="expand" for="c-41529053">[1 more]</label></div><br/><div class="children"><div class="content">&gt; generally when people say &quot;choose effect system&quot; they mean choose some algebraic effect system<p>This isn&#x27;t really true.  Bluefin and effectful are effect  systems, but not algebraic effect systems.</div><br/></div></div><div id="41523418" class="c"><input type="checkbox" id="c-41523418" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522897">parent</a><span>|</span><a href="#41529053">prev</a><span>|</span><a href="#41522846">next</a><span>|</span><label class="collapse" for="c-41523418">[-]</label><label class="expand" for="c-41523418">[1 more]</label></div><br/><div class="children"><div class="content">I realize I didn&#x27;t mention monad transformers at all in my original post, I only linked to them!<p>I should have mentioned that, as you say, monad transformers should be the default effect system choice for 99% of people</div><br/></div></div></div></div></div></div></div></div><div id="41522846" class="c"><input type="checkbox" id="c-41522846" checked=""/><div class="controls bullet"><span class="by">jsbg</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41519778">parent</a><span>|</span><a href="#41522421">prev</a><span>|</span><a href="#41527414">next</a><span>|</span><label class="collapse" for="c-41522846">[-]</label><label class="expand" for="c-41522846">[1 more]</label></div><br/><div class="children"><div class="content">This is excellent advice that unfortunately seems to get lost in a lot of Haskell teachings. I learned Haskell in school but until I had to use it professionally I would have never been able to wrap my head around effect systems. I still think that part of Haskell is unfortunate as it can get in the way of getting things done if you&#x27;re not an expert, but being able to separate pure functions from effectful ones is a massive advantage.</div><br/></div></div></div></div><div id="41527414" class="c"><input type="checkbox" id="c-41527414" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#41519406">parent</a><span>|</span><a href="#41519778">prev</a><span>|</span><a href="#41521091">next</a><span>|</span><label class="collapse" for="c-41527414">[-]</label><label class="expand" for="c-41527414">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been using Haskell professionally off and on, along with other languages, since 2008. Professional experience certainly will help you learn some patterns, but honestly my best advice for structuring programs is to not think too hard about it.<p>Use modules as your basic unit of abstraction. Don’t go out of your way to make their organization over-engineered, but each module should basically do one thing, and should define everything it needs to do that thing (types, classes, functions).<p>Use parametric polymorphism as much as you can, without making the code too hard to read. Prefer functions and records over type classes as much as possible. Type classes that only ever have a single instance, don’t have laws, or type classes defined for unit data types are major code smells.<p>Don’t worry about avoiding IO, but as much as you can try to keep IO code separate from pure code. For example, if you need to read a value from the user, do some calculations, then print a message, it’s far better to factor the “do some calculations” part out into a pure function that takes the things you read in as arguments and returns a value to print. It’s really tempting to interleave logic with IO but you’ll save so much time, energy, and pain if you avoid this.<p>Essentially, keep things as simple as you can without getting belligerent about it. The type system will help you a lot with refactoring.<p>Start at the beginning. Write functions. When you see some piece of functionality that you need, use `undefined` to make a placeholder function. Then, go to your place holder and start implementing it. Use undefined to fill in bits that you need, and so on.<p>Fancy types are neat but it’s easy to end up with a solution in search of a problem. Avoid them until you really have a concrete problem that they solve- then embrace them for that problem (and only that problem).<p>You’ll refactor a lot, and learn to have a better gut feeling for how to structure things, but that’s just the process of gaining experience. Leaning into the basics of FP (pure functions, composed together) will be the path of least resistance as you are getting there.</div><br/></div></div><div id="41521091" class="c"><input type="checkbox" id="c-41521091" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#41519406">parent</a><span>|</span><a href="#41527414">prev</a><span>|</span><a href="#41521562">next</a><span>|</span><label class="collapse" for="c-41521091">[-]</label><label class="expand" for="c-41521091">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used Haskell professionally for two years. It is the right pick for the project I&#x27;m working on (static analysis). I&#x27;m less sold on the overall Haskell ecosystem, tooling, and the overall Haskell culture.<p>There are still plenty of ways to do things wrong. Strong types don&#x27;t prevent that. Laziness is a double-edged sword and can be difficult to reason about.</div><br/></div></div><div id="41521562" class="c"><input type="checkbox" id="c-41521562" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41519406">parent</a><span>|</span><a href="#41521091">prev</a><span>|</span><a href="#41519643">next</a><span>|</span><label class="collapse" for="c-41521562">[-]</label><label class="expand" for="c-41521562">[6 more]</label></div><br/><div class="children"><div class="content">People love to talk about the upsides and the fun and what you can learn from Haskell.<p>I am one of these people.<p>People are much more reluctant to share what it is that led them to the conclusion that Haskell isn&#x27;t something they want to use professionally, or something they can&#x27;t use professionally. It&#x27;s a combination of things, such as it just generally being less energizing to talk about that, and also some degree of frankly-justified fear of being harassed by people who will argue loudly and insultingly that you just Don&#x27;t Get It.<p>I am not one of those people.<p>I will share the three main reasons I don&#x27;t even consider it professionally.<p>First, Hacker News has a stronger-than-average egalitarian streak and really wants to believe that everybody in the world is already a developer with 15 years of experience and expert-level knowledge in all they survey from atop their accomplished throne, but that&#x27;s not how the real world works. In the real world I work with coworkers who I have to train why in my Go code, a &quot;DomainName&quot; is a type instead of just a string. Then, just as the light bulb goes off, they move on from the project and I get the next junior dev who I have to explain it to. I&#x27;m hardly going to get to the point where I have a team of people who are Haskell experts when I&#x27;m explaining this basic thing over and over.<p>And, to be 100% clear, this is not their &quot;fault&quot;, because being a junior programmer in 2024 is facing a mountain of issues I didn&#x27;t face at their age: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33911633">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33911633</a> I wasn&#x27;t expected to know about how to do source control or write everything to be rollback-able or interact with QA, or, well, see linked post for more examples. Haskell is another stack of requirements on top of a modern junior dev that is a <i>hell</i> of an ask. There better be some damn good reasons for me to add this to my minimim-viable developer for a project. I am not expressing contempt for the junior programmers here from atop my own lofty perch; I am encouraging people to have sympathy with them, especially if you also come up in the 90s when it was really relatively easy, and to make sure you don&#x27;t spec out projects where you&#x27;re basically pulling the ladder up after yourself. You need to have an onboarding plan, and &quot;spend a whole bunch of time learning Haskell&quot; is spending a lot of your onboarding plan currency.<p>Second, while a Haskell program that has the <i>chef&#x27;s kiss</i> perfect architecture is a joy to work with, it is much more difficult to get there for a real project. When I was playing with Haskell it was a frequent occurrence to discover I&#x27;d architected something wrong, and to essentially need to rewrite the whole program, because there is no intermediate functioning program between where I was and where I needed to be. The strength of the type system is a great benefit, but it does not put up with your crap. But &quot;your crap&quot; includes things like being able to rearchitect a system in phases, or partially, and still have a functioning system, and some other things that are harder to characterize but you do a lot of without even realizing it.<p>I&#x27;d analogize it to a metalworker working with titanium. If you need it, you need it. If you can afford it, great. The end result is amazing. But it&#x27;s a much harder metal to work with for the exact same reason it&#x27;s amazing. The strength of the end part is directly reflected in the metal resisting you working with it.<p>I expect at a true expert level you can get over this, but then as per my first point, demanding that all my fellow developers become true experts in this obscure language is taking it up another level past just being able to work in it at all.<p>Finally, a lot of programming requirements have changed over the years. 10-15 years ago I could feasibly break my program into a &quot;functional core&quot; and an external IO system. This has become a great deal less true, because the baseline requirement for logging, metrics, and visibility have gone up a lot, and suddenly that &quot;pure core&quot; becomes a lot less appealing. Yes, of course, our pure functions could all return logs and metrics and whathaveyou, and sure, you can set up the syntax to the point that it&#x27;s almost tolerable, but you&#x27;re still going to face issues where basically everything is now in some sort of IO. If nothing else, those beautiful (Int -&gt; Int -&gt; Int) functions all become (Int -&gt; Int -&gt; LoggingMetrics Int) and now it isn&#x27;t just that you &quot;get&quot; to use monadic interfaces but you&#x27;re in the LoggingMetrics monad for <i>everything</i> and the advantages of Haskell, while they do not go away entirely, are somewhat mitigated, because it really wants purity. It puts me halfway to being in the &quot;imperative monad&quot; already, and makes the plan of just going ahead and being there and programming carefully a lot more appealing. Especially when you combine that with the junior devs being able to understand the resulting code.<p>In the end, while I still strongly recommend professional programmers spend some time in this world to glean some lessons from it that are much more challenging to learn anywhere else, it is better to take the lessons learned and learn how to apply them back into conventional languages than to try to insist on using the more pure functional languages in an engineering environment. This isn&#x27;t even the complete list of issues, but they&#x27;re sufficient to eliminate them from consideration for almost every engineering task. And in fact every case I have personally witnessed where someone pushed through anyhow and did it, it was ultimately a business failure.</div><br/><div id="41521690" class="c"><input type="checkbox" id="c-41521690" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41521562">parent</a><span>|</span><a href="#41522091">next</a><span>|</span><label class="collapse" for="c-41521690">[-]</label><label class="expand" for="c-41521690">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d analogize it to a metalworker working with titanium. If you need it, you need it. If you can afford it, great. The end result is amazing. But it&#x27;s a much harder metal to work with for the exact same reason it&#x27;s amazing.<p>What a beautiful, succinct analogy. I&#x27;m stealing this.</div><br/></div></div><div id="41522091" class="c"><input type="checkbox" id="c-41522091" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41521562">parent</a><span>|</span><a href="#41521690">prev</a><span>|</span><a href="#41519643">next</a><span>|</span><label class="collapse" for="c-41522091">[-]</label><label class="expand" for="c-41522091">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d analogize it to a metalworker working with titanium. If you need it, you need it. If you can afford it, great. The end result is amazing. But it&#x27;s a much harder metal to work with for the exact same reason it&#x27;s amazing. The strength of the end part is directly reflected in the metal resisting you working with it.<p>I’d say you missed one of the main points of Haskell and functional programming in general.<p>The combinator is the most modular and fundamental computational primitive available in programming. When you make a functional program it should be constructed out of the composition of thousands of these primitive with extremely strict separation from IO and multiple layers of abstraction. Each layer is simply composed functions from the layer below.<p>If you think of fp programming this way. It becomes the most modular most reconfigurable programming pattern in existence.<p>You have access to all layers of abstraction and within each layer are independent modules of composed combinators. Your titanium is given super powers where you can access the engine, the part, the molecule and the atom.<p>All the static safety and beauty Haskell provides is actually a side thing. What Haskell and functional programming in general provides is the most fundamental and foundational way to organize your program such that any architectural change only requires you replacing and changing the minimum amount of required modules. Literally the opposite of what you’re saying.<p>The key is to make your program just a bunch of combinators all the way down with an imperative io shell that is as thin as possible. This is nirvana of program organization and patterns.</div><br/><div id="41522882" class="c"><input type="checkbox" id="c-41522882" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522091">parent</a><span>|</span><a href="#41523406">next</a><span>|</span><label class="collapse" for="c-41522882">[-]</label><label class="expand" for="c-41522882">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m well aware of functional programming as focusing on composition.<p>One of the reasons you end up with &quot;refactoring the entire program because of some change&quot; is when you discover that your entire composition scheme you built your entire program around is <i>wrong</i>, e.g., &quot;Gee, this effects library I built my entire code base around to date is really nifty but also I can&#x27;t actually express my needs in it after all&quot;. In a conventional language, you just build in the exceptions, and maybe feel briefly sad, but it works. It can ruin a codebase if you let it, but it&#x27;s at least an option. In Haskell, you have a <i>much</i> bigger problem.<p>Now filter that back through what I wrote. You want to explain to your junior developer who is still struggling with the concept of using things other than strings why we have to rewrite the entire code base to use raw IO instead of the effects system we were using because it turns out the compilation time went exponential and we can&#x27;t fix it in any reasonable amount of effort? How happy are they going to be with you after you just spent a whole bunch of time explaining the way to work with the effects system? They&#x27;re not going to come away with a good impression of either Haskell or you.</div><br/><div id="41529082" class="c"><input type="checkbox" id="c-41529082" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519406">root</a><span>|</span><a href="#41522882">parent</a><span>|</span><a href="#41523406">next</a><span>|</span><label class="collapse" for="c-41529082">[-]</label><label class="expand" for="c-41529082">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Gee, this effects library I built my entire code base around to date is really nifty but also I can&#x27;t actually express my needs in it after all&quot;<p>This is why I recommend IO-based effect systems like Bluefin and effectful.  If you find that you get stuck you always have the escape hatch of just doing whatever you want in IO.  Maybe feel briefly sad, but it works.<p>(I&#x27;m the author of Bluefin)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41519643" class="c"><input type="checkbox" id="c-41519643" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#41519406">prev</a><span>|</span><a href="#41522355">next</a><span>|</span><label class="collapse" for="c-41519643">[-]</label><label class="expand" for="c-41519643">[11 more]</label></div><br/><div class="children"><div class="content">I, like probably many people, like the idea of Haskell, but don&#x27;t need a bottom-up language tutorial. Instead, I need:<p>- how easy is it to make a web application with a hello world endpoint?<p>- How easy is it to auth a JWT?<p>- Is there a good ORM that supports migrations?<p>- Do I have to remodel half my type system because a product owner told me about this weird business logic edge case we have to deal with?<p>- How do I do logging?<p>Etc.</div><br/><div id="41519742" class="c"><input type="checkbox" id="c-41519742" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519643">parent</a><span>|</span><a href="#41528698">prev</a><span>|</span><a href="#41524396">next</a><span>|</span><label class="collapse" for="c-41519742">[-]</label><label class="expand" for="c-41519742">[4 more]</label></div><br/><div class="children"><div class="content">&gt; - how easy is it to make a web application with a hello world endpoint?<p>If that&#x27;s all you want it to do, it&#x27;s very easy with Wai&#x2F;Warp.<p>&gt; - How easy is it to auth a JWT?<p>We don&#x27;t use JWTs, but we did look at it and Servant (which is a library for building HTTP APIs) has built in functionality for them.<p>&gt; - Is there a good ORM that supports migrations?<p>There are several with quite interesting properties. Some (like persistent) do automatic migrations based on your schema definitions. Others you have to write migration SQL&#x2F;other DSL.<p>&gt; - Do I have to remodel half my type system because a product owner told me about this weird business logic edge case we have to deal with?<p>I think that&#x27;s going to really depend on how you have structured your domain model, it&#x27;s not a language question as much as a design question.<p>&gt; - How do I do logging?<p>We use a library called Katip for logging, but there are others which are simpler. You can also just print to stdout if you want to.</div><br/><div id="41519802" class="c"><input type="checkbox" id="c-41519802" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#41519643">root</a><span>|</span><a href="#41519742">parent</a><span>|</span><a href="#41524396">next</a><span>|</span><label class="collapse" for="c-41519802">[-]</label><label class="expand" for="c-41519802">[3 more]</label></div><br/><div class="children"><div class="content">Thank you! What I was more saying was that an article like this would do better showing some practical simple examples, that would let people do things, rather than bemoaning how Haskell is viewed in 2024.</div><br/><div id="41520920" class="c"><input type="checkbox" id="c-41520920" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519643">root</a><span>|</span><a href="#41519802">parent</a><span>|</span><a href="#41521909">next</a><span>|</span><label class="collapse" for="c-41520920">[-]</label><label class="expand" for="c-41520920">[1 more]</label></div><br/><div class="children"><div class="content">Oh! I hope I wasn&#x27;t bemoaning too much -- that was the lead-in, but it&#x27;s mostly about what I really like about the language (and had some examples but I also didn&#x27;t want to write a tutorial).</div><br/></div></div><div id="41521909" class="c"><input type="checkbox" id="c-41521909" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519643">root</a><span>|</span><a href="#41519802">parent</a><span>|</span><a href="#41520920">prev</a><span>|</span><a href="#41524396">next</a><span>|</span><label class="collapse" for="c-41521909">[-]</label><label class="expand" for="c-41521909">[1 more]</label></div><br/><div class="children"><div class="content">For reference (in case it&#x27;s helpful), my website (where this essay is hosted) is written in Haskell and is basically a fairly simple webserver.<p>For the &quot;hello world&quot; webserver, this might be a bit instructive: <a href="https:&#x2F;&#x2F;github.com&#x2F;gfarrell&#x2F;gtf.io&#x2F;blob&#x2F;main&#x2F;src&#x2F;GTF&#x2F;Router.hs#L95">https:&#x2F;&#x2F;github.com&#x2F;gfarrell&#x2F;gtf.io&#x2F;blob&#x2F;main&#x2F;src&#x2F;GTF&#x2F;Router....</a></div><br/></div></div></div></div></div></div><div id="41524396" class="c"><input type="checkbox" id="c-41524396" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#41519643">parent</a><span>|</span><a href="#41519742">prev</a><span>|</span><a href="#41522566">next</a><span>|</span><label class="collapse" for="c-41524396">[-]</label><label class="expand" for="c-41524396">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t work.<p>Imagine you talk to someone who has done assembly his whole life and now wants to write something in, let&#x27;s say, Java.<p>What would you think if he asks the question in the way you did?<p>Sometimes, when you learn a language that is <i>so different</i> you really really should NOT try to assume that your current knowledge just translates.</div><br/></div></div><div id="41522566" class="c"><input type="checkbox" id="c-41522566" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41519643">parent</a><span>|</span><a href="#41524396">prev</a><span>|</span><a href="#41523972">next</a><span>|</span><label class="collapse" for="c-41522566">[-]</label><label class="expand" for="c-41522566">[2 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t do any of that without having first understood a bottom-up introduction. There are so many web frameworks from Yesod to Scotty to Servant (these are just the ones I&#x27;ve used personally) but you can&#x27;t use any of them without at least an understanding of the language.</div><br/></div></div><div id="41523972" class="c"><input type="checkbox" id="c-41523972" checked=""/><div class="controls bullet"><span class="by">justinhj</span><span>|</span><a href="#41519643">parent</a><span>|</span><a href="#41522566">prev</a><span>|</span><a href="#41523488">next</a><span>|</span><label class="collapse" for="c-41523972">[-]</label><label class="expand" for="c-41523972">[1 more]</label></div><br/><div class="children"><div class="content">That sounds valuable too but maybe it comes after the basic concepts or you may find people immediately dismiss it. There is all kinds of extra syntax and baggage that may seem pointless at first.</div><br/></div></div><div id="41523488" class="c"><input type="checkbox" id="c-41523488" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#41519643">parent</a><span>|</span><a href="#41523972">prev</a><span>|</span><a href="#41522355">next</a><span>|</span><label class="collapse" for="c-41523488">[-]</label><label class="expand" for="c-41523488">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;haskell-beam.github.io&#x2F;beam&#x2F;" rel="nofollow">https:&#x2F;&#x2F;haskell-beam.github.io&#x2F;beam&#x2F;</a> is fantastic, but good luck understanding it if you don&#x27;t already know some Haskell</div><br/></div></div></div></div><div id="41522355" class="c"><input type="checkbox" id="c-41522355" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#41519643">prev</a><span>|</span><a href="#41519079">next</a><span>|</span><label class="collapse" for="c-41522355">[-]</label><label class="expand" for="c-41522355">[6 more]</label></div><br/><div class="children"><div class="content">Haskell is an experiment on having laziness at language level. This experiment clearly shows, that laziness on language level is a bad idea.You can get all the benefits of laziness at standard library level, as illustrated by Clojure and Twitter Storm using it in production.<p>All the other FP stuff (union types, etc) existed before Haskell in non-lazy FP languages.</div><br/><div id="41523749" class="c"><input type="checkbox" id="c-41523749" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41522355">parent</a><span>|</span><a href="#41522436">next</a><span>|</span><label class="collapse" for="c-41523749">[-]</label><label class="expand" for="c-41523749">[1 more]</label></div><br/><div class="children"><div class="content">Right, I was surprised I had to scroll down here so far to see the first mention of laziness; it&#x27;s <i>the</i> core feature of Haskell (copied from Miranda so researchers had a non-proprietary language to build their work on).<p>From everything I&#x27;ve ready about people&#x27;s experiences with using Haskell for large projects, it sounds like lazy evaluation unfortunately adds more problems than it removes.</div><br/></div></div><div id="41522436" class="c"><input type="checkbox" id="c-41522436" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41522355">parent</a><span>|</span><a href="#41523749">prev</a><span>|</span><a href="#41522512">next</a><span>|</span><label class="collapse" for="c-41522436">[-]</label><label class="expand" for="c-41522436">[1 more]</label></div><br/><div class="children"><div class="content">There’s a strong case that laziness should be the default: <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=fSqE-HSh_NU" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=fSqE-HSh_NU</a><p>I’m not sure I’m experienced enough in PLT enough to have a strong opinion myself.<p>However, from experience, laziness has a lot of advantages both from a program construction and performance perspective.</div><br/></div></div><div id="41522512" class="c"><input type="checkbox" id="c-41522512" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41522355">parent</a><span>|</span><a href="#41522436">prev</a><span>|</span><a href="#41526242">next</a><span>|</span><label class="collapse" for="c-41522512">[-]</label><label class="expand" for="c-41522512">[2 more]</label></div><br/><div class="children"><div class="content">Laziness is but one mistake in Haskell. It should not prevent you from using other parts of the language that are wonderful. There&#x27;s a reason Mu exists, which is to take Haskell and make it strict by default: there are plenty of good things about Haskell even if you consider laziness to be a mistake.<p>(Of course a small minority of people don&#x27;t consider laziness as a mistake as it enables equational reasoning; let&#x27;s not go there.)</div><br/><div id="41529090" class="c"><input type="checkbox" id="c-41529090" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41522355">root</a><span>|</span><a href="#41522512">parent</a><span>|</span><a href="#41526242">next</a><span>|</span><label class="collapse" for="c-41529090">[-]</label><label class="expand" for="c-41529090">[1 more]</label></div><br/><div class="children"><div class="content">Having used Mu I concluded that Haskell got function laziness correct.  (Data type laziness is a different issue, but that can be solved by `StrictData`).</div><br/></div></div></div></div><div id="41526242" class="c"><input type="checkbox" id="c-41526242" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#41522355">parent</a><span>|</span><a href="#41522512">prev</a><span>|</span><a href="#41519079">next</a><span>|</span><label class="collapse" for="c-41526242">[-]</label><label class="expand" for="c-41526242">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This experiment clearly shows, that laziness on language level is a bad idea.<p>This is quite the claim. I know plenty of experienced and productive Haskellers who disagree with this (myself included)</div><br/></div></div></div></div><div id="41519079" class="c"><input type="checkbox" id="c-41519079" checked=""/><div class="controls bullet"><span class="by">cpa</span><span>|</span><a href="#41522355">prev</a><span>|</span><a href="#41525287">next</a><span>|</span><label class="collapse" for="c-41519079">[-]</label><label class="expand" for="c-41519079">[96 more]</label></div><br/><div class="children"><div class="content">Haskell has had a profound impact on the way I think about programming and how I architect my code and build services. The stateless nature of Haskell is something that many rediscover at different points in their careers. Eg in webdev, it&#x27;s mostly about offloading state to the database and treating the application as &quot;dumb nodes.&quot; That&#x27;s what most K8s deployments do.<p>The type system in Haskell, particularly union types, is incredibly powerful, easy to understand for the most part (you don&#x27;t need to understand monads that deeply to use them), and highly useful.<p>And I&#x27;ve had a lot of fun micro-optimizing Haskell code for Project Euler problems when I was studying.<p>Give it a try. Especially, if you don&#x27;t know what to expect, I can guarantee that you&#x27;ll be surprised!<p>Granted, the tooling is sh*t.</div><br/><div id="41519436" class="c"><input type="checkbox" id="c-41519436" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41519148">next</a><span>|</span><label class="collapse" for="c-41519436">[-]</label><label class="expand" for="c-41519436">[14 more]</label></div><br/><div class="children"><div class="content">&gt; Haskell has had a profound impact on the way I think about programming and how I architect my code and build services.<p>&gt; And I&#x27;ve had a lot of fun micro-optimizing Haskell code for Project Euler problems when I was studying.<p>Sounds a lot like my experience. I never really used Haskell for &quot;real work&quot;, where I need support for high-performance numerical calculations that is simply better in other languages (Python, Julia, C&#x2F;C++, Fortran).<p>But learning functional programming through Haskell – mostly by following the &quot;Learn you a Haskell&quot; book and then spending time working through Project Euler exercises using it – had a quite formative effect on how I write code.<p>I even ended up baking some functional programming concepts into my Fortran code later. For instance, I implemented the ability to &quot;map&quot; functions on my data structures, and made heavy use of &quot;pure functions&quot; which are supported by the modern Fortran standard (the compiler then checks for side effects).<p>It&#x27;s however hard to go all the way on functional programming in HPC contexts, although I wish there were better libraries available to enable this.</div><br/><div id="41520409" class="c"><input type="checkbox" id="c-41520409" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519436">parent</a><span>|</span><a href="#41521034">next</a><span>|</span><label class="collapse" for="c-41520409">[-]</label><label class="expand" for="c-41520409">[11 more]</label></div><br/><div class="children"><div class="content">&gt; But learning functional programming through Haskell [...] had a quite formative effect on how I write code.<p>I think it is a shame Haskell has gained a reputation of being hard, because it can be an enriching learning experience. Lots of its complexity is accidental, and comes from the myriad of language extensions that have been created for research purposes.<p>There was an initiative to define a simpler subset of the language, which IMHO would have been great, but it didn&#x27;t take off: <a href="https:&#x2F;&#x2F;www.simplehaskell.org" rel="nofollow">https:&#x2F;&#x2F;www.simplehaskell.org</a>. Ultimately, one can stick to Haskell 98 or Haskell 2010 plus some newer cherry-picked extensions.</div><br/><div id="41520873" class="c"><input type="checkbox" id="c-41520873" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520409">parent</a><span>|</span><a href="#41520512">next</a><span>|</span><label class="collapse" for="c-41520873">[-]</label><label class="expand" for="c-41520873">[9 more]</label></div><br/><div class="children"><div class="content">I think Elm is a fantastic &quot;simplified Haskell&quot; with pretty good beginner-friendly guides. It&#x27;s unfortunate that Elm is mostly tied to the frontend and has been effectively abandoned for the last couple of years.<p>Interestingly, Elm has inspired a host of &quot;successors&quot;, including Gleam + Lustre, which look really great (I haven&#x27;t had a chance to really try them yet).</div><br/><div id="41522131" class="c"><input type="checkbox" id="c-41522131" checked=""/><div class="controls bullet"><span class="by">earth_walker</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520873">parent</a><span>|</span><a href="#41522860">next</a><span>|</span><label class="collapse" for="c-41522131">[-]</label><label class="expand" for="c-41522131">[2 more]</label></div><br/><div class="children"><div class="content">Elm&#x27;s strengths are its constraints, which allow for simple, readable code that&#x27;s easy to test and reason about - partly because libraries are also guaranteed to work within those constraints.<p>I&#x27;ve tried and failed several times to write Haskell in an Elm style, even though the syntax is so similar. It&#x27;s probably me (it&#x27;s definitely me!), but I&#x27;ve found that as soon as you depend on a library or two outside of prelude their complexities bleed into your project and eventually force you into peppering that readable, simple code with lifts, lenses, transformations and hidden magic.<p>Not to mention the error messages and compile times make developing in Haskell a chore in comparison.<p>p.s. Elm has not been abandoned, it&#x27;s very active and getting better every day. You just can&#x27;t measure by updates to the (stable, but with a few old bugs) core. 
For a small, unpopular language there is so much work going into high quality libraries and development tools. Check out<p><a href="https:&#x2F;&#x2F;elmcraft.org&#x2F;lore&#x2F;elm-core-development" rel="nofollow">https:&#x2F;&#x2F;elmcraft.org&#x2F;lore&#x2F;elm-core-development</a><p>for a discussion.<p>Elm is so nice to work in. Great error messages, and near instant compile times, and a great ecosystem of static analysis, scaffolding, scripting, and hot reloading tools make the live development cycle super nice - it actually feels like what the lispers always promised would happen if we embraced repl-driven development.</div><br/><div id="41522449" class="c"><input type="checkbox" id="c-41522449" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522131">parent</a><span>|</span><a href="#41522860">next</a><span>|</span><label class="collapse" for="c-41522449">[-]</label><label class="expand" for="c-41522449">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the Elmcraft FAQ link. It&#x27;s a great succinct explanation from the Elm leadership perspective (though tellingly not from the Elm leadership).<p>I feel like I understand that perspective, but I also don&#x27;t think I&#x27;m wrong in claiming Elm has been effectively abandoned in a world where an FAQ like that needs to be written.<p>I&#x27;m not going to try to convince you though, enjoy Elm!!</div><br/></div></div></div></div><div id="41522860" class="c"><input type="checkbox" id="c-41522860" checked=""/><div class="controls bullet"><span class="by">britzkopf</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520873">parent</a><span>|</span><a href="#41522131">prev</a><span>|</span><a href="#41520982">next</a><span>|</span><label class="collapse" for="c-41522860">[-]</label><label class="expand" for="c-41522860">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often wondered if it having a reputation as being hard is accurate. Not necessarily because of syntax etc. but because of you don&#x27;t already have a grounding in programming&#x2F;engineering&#x2F;comp sci. it can be difficult to fit the insights Haskell provides into any meaningful framework. 
That was my experience anyway, came to it too early and didn&#x27;t understand the significance.</div><br/></div></div><div id="41520982" class="c"><input type="checkbox" id="c-41520982" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520873">parent</a><span>|</span><a href="#41522860">prev</a><span>|</span><a href="#41520512">next</a><span>|</span><label class="collapse" for="c-41520982">[-]</label><label class="expand" for="c-41520982">[5 more]</label></div><br/><div class="children"><div class="content">What about Roc or Koka? Or simply moving to OCaml? It&#x27;s looking pretty great after v5, with multicore and effect handlers.</div><br/><div id="41521477" class="c"><input type="checkbox" id="c-41521477" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520982">parent</a><span>|</span><a href="#41520512">next</a><span>|</span><label class="collapse" for="c-41521477">[-]</label><label class="expand" for="c-41521477">[4 more]</label></div><br/><div class="children"><div class="content">OCaml is great but the type system is actually quite different from Haskell&#x27;s once you get into it. It also has many &quot;escape hatches&quot; out of the functional pathway. Even if you approach it with a learner&#x27;s discipline you&#x27;ll run into them even in the standard lib.<p>With haskell you can look to the ecosystem to see how to accomplish specific things with a pure functional approach. When you look at ocaml projects in that way you often find people choosing not to.</div><br/><div id="41521767" class="c"><input type="checkbox" id="c-41521767" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521477">parent</a><span>|</span><a href="#41520512">next</a><span>|</span><label class="collapse" for="c-41521767">[-]</label><label class="expand" for="c-41521767">[3 more]</label></div><br/><div class="children"><div class="content">Oh but the OCaml module system is the bees knees.</div><br/><div id="41521794" class="c"><input type="checkbox" id="c-41521794" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521767">parent</a><span>|</span><a href="#41520512">next</a><span>|</span><label class="collapse" for="c-41521794">[-]</label><label class="expand" for="c-41521794">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I didn&#x27;t mean any of this as a negative lol. I haven&#x27;t touched haskell since I learned ocaml. I still think haskell has the edge as an educational language for functional programming and type systems though, which is kind of what we&#x27;re talking about but not entirely.</div><br/><div id="41522472" class="c"><input type="checkbox" id="c-41522472" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521794">parent</a><span>|</span><a href="#41520512">next</a><span>|</span><label class="collapse" for="c-41522472">[-]</label><label class="expand" for="c-41522472">[1 more]</label></div><br/><div class="children"><div class="content">No worries, I was just adding my two cents.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41520512" class="c"><input type="checkbox" id="c-41520512" checked=""/><div class="controls bullet"><span class="by">gtirloni</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520409">parent</a><span>|</span><a href="#41520873">prev</a><span>|</span><a href="#41521034">next</a><span>|</span><label class="collapse" for="c-41520512">[-]</label><label class="expand" for="c-41520512">[1 more]</label></div><br/><div class="children"><div class="content">Sounds a lot like the C++ experience.<p>In my time learning Haskell a decade ago, it was rare to find some code that wasn&#x27;t using an experimental extension.</div><br/></div></div></div></div><div id="41521034" class="c"><input type="checkbox" id="c-41521034" checked=""/><div class="controls bullet"><span class="by">l5870uoo9y</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519436">parent</a><span>|</span><a href="#41520409">prev</a><span>|</span><a href="#41527350">next</a><span>|</span><label class="collapse" for="c-41521034">[-]</label><label class="expand" for="c-41521034">[1 more]</label></div><br/><div class="children"><div class="content">Pure functions are a crazy useful abstractions. Complex business logic? Extract it into a type-safe pure function. Still to &quot;unsafe&quot;? Testing pure functions are fast and simple. Unclear what a complex function does? Extract it into meaningful pure functions.</div><br/></div></div><div id="41527350" class="c"><input type="checkbox" id="c-41527350" checked=""/><div class="controls bullet"><span class="by">ayakang31415</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519436">parent</a><span>|</span><a href="#41521034">prev</a><span>|</span><a href="#41519148">next</a><span>|</span><label class="collapse" for="c-41527350">[-]</label><label class="expand" for="c-41527350">[1 more]</label></div><br/><div class="children"><div class="content">Haskell sounds like a good language to hone your programming skills. What kind of projects is Haskell suited for to get started (besides Euler project)? I use Python primarily for scientific research (mostly numerical computation).</div><br/></div></div></div></div><div id="41519148" class="c"><input type="checkbox" id="c-41519148" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41519436">prev</a><span>|</span><a href="#41519186">next</a><span>|</span><label class="collapse" for="c-41519148">[-]</label><label class="expand" for="c-41519148">[39 more]</label></div><br/><div class="children"><div class="content">Haskell also changed the way I think about programming. But I wonder if it would have as much of an impact on someone coming from a language like Rust or even modern C++ which has adopted many of haskell’s features?</div><br/><div id="41519222" class="c"><input type="checkbox" id="c-41519222" checked=""/><div class="controls bullet"><span class="by">mmoll</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519148">parent</a><span>|</span><a href="#41519472">next</a><span>|</span><label class="collapse" for="c-41519222">[-]</label><label class="expand" for="c-41519222">[20 more]</label></div><br/><div class="children"><div class="content">True. I often think of Rust as a best-of compilation of Haskell and C++ (although I read somewhere that OCaml had a greater influence on it, but I don’t know that language well enough)<p>In real life, I find that Haskell suffers from trying too hard to use the most general concept that‘s applicable (no pun intended). Haskell programs happily use “Either Err Val” and “Left x” where other languages would use the more expressive but less general “Result Err Val” and “Error x”. Also, I don’t want to mentally parse nested liftM2s or learn the 5th effect system ;-)</div><br/><div id="41520361" class="c"><input type="checkbox" id="c-41520361" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519222">parent</a><span>|</span><a href="#41519472">next</a><span>|</span><label class="collapse" for="c-41520361">[-]</label><label class="expand" for="c-41520361">[19 more]</label></div><br/><div class="children"><div class="content">&gt;I read somewhere that OCaml had a greater influence on it<p>Whoever wrote that is wrong.</div><br/><div id="41520513" class="c"><input type="checkbox" id="c-41520513" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520361">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41520513">[-]</label><label class="expand" for="c-41520513">[7 more]</label></div><br/><div class="children"><div class="content">If we could wave a magic wand and remove Haskell&#x27;s influence on Rust, Rust would still exist in some kind of partial form. If we waved the same wand and removed OCaml&#x27;s influence, Rust would no longer exist at all.<p>You are the one who is wrong, I&#x27;m afraid.</div><br/><div id="41521104" class="c"><input type="checkbox" id="c-41521104" checked=""/><div class="controls bullet"><span class="by">lkitching</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520513">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41521104">[-]</label><label class="expand" for="c-41521104">[6 more]</label></div><br/><div class="children"><div class="content">Which OCaml features exist in Rust but not Haskell? The trait system looks very similar to Haskell typeclasses, but I&#x27;m not aware of any novel OCaml influence on the language.</div><br/><div id="41521237" class="c"><input type="checkbox" id="c-41521237" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521104">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41521237">[-]</label><label class="expand" for="c-41521237">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Which OCaml features exist in Rust but not Haskell?</i><p>Rust&#x27;s most important feature! The bootstrapped implementation.</div><br/><div id="41521502" class="c"><input type="checkbox" id="c-41521502" checked=""/><div class="controls bullet"><span class="by">lkitching</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521237">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41521502">[-]</label><label class="expand" for="c-41521502">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced the implementation language of the compiler counts as a feature of the Rust language. If the argument is that Rust wouldn&#x27;t have been invented without the original author wanting a &#x27;systems OCaml&#x27; then fine. But it&#x27;s possible Rust would still look similar to how it does now in a counterfactual world where the original inspiration was Haskell rather than OCaml, but removing the Haskell influence from Rust as it is now would result in something quite different.</div><br/><div id="41521596" class="c"><input type="checkbox" id="c-41521596" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521502">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41521596">[-]</label><label class="expand" for="c-41521596">[3 more]</label></div><br/><div class="children"><div class="content">Rust isn&#x27;t just a language, though.<p>Additionally, unlike some languages that are formally specified before turning to implementation, Rust has subscribed to design-by-implementation. The implementation <i>is</i> the language.</div><br/><div id="41521953" class="c"><input type="checkbox" id="c-41521953" checked=""/><div class="controls bullet"><span class="by">lkitching</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521596">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41521953">[-]</label><label class="expand" for="c-41521953">[2 more]</label></div><br/><div class="children"><div class="content">That just means the semantics of the language are defined by whatever the default implementation does. It&#x27;s a big stretch to conclude that means Rust &#x27;was&#x27; OCaml in some sense when the compiler was written with it. Especially now the Rust compiler is written in Rust itself.</div><br/><div id="41522049" class="c"><input type="checkbox" id="c-41522049" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521953">parent</a><span>|</span><a href="#41520660">next</a><span>|</span><label class="collapse" for="c-41522049">[-]</label><label class="expand" for="c-41522049">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re overthinking again. Read what is said, not what you want it to say in some fairytale land.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41520660" class="c"><input type="checkbox" id="c-41520660" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520361">parent</a><span>|</span><a href="#41520513">prev</a><span>|</span><a href="#41520614">next</a><span>|</span><label class="collapse" for="c-41520660">[-]</label><label class="expand" for="c-41520660">[2 more]</label></div><br/><div class="children"><div class="content">Rust was bootsrapped in OCaml.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;rust&#x2F;tree&#x2F;ef75860a0a72f79f97216f8aaa5b388d98da6480&#x2F;src&#x2F;boot">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;rust&#x2F;tree&#x2F;ef75860a0a72f79f97216f8...</a></div><br/></div></div><div id="41520614" class="c"><input type="checkbox" id="c-41520614" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520361">parent</a><span>|</span><a href="#41520660">prev</a><span>|</span><a href="#41526891">next</a><span>|</span><label class="collapse" for="c-41520614">[-]</label><label class="expand" for="c-41520614">[5 more]</label></div><br/><div class="children"><div class="content">The original rust compiler was written in OCaml. That&#x27;s not evidence it &quot;had an influence&quot;, but it&#x27;s highly striking considering how many other languages Greydon could&#x27;ve used.</div><br/><div id="41521322" class="c"><input type="checkbox" id="c-41521322" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520614">parent</a><span>|</span><a href="#41526891">next</a><span>|</span><label class="collapse" for="c-41521322">[-]</label><label class="expand" for="c-41521322">[4 more]</label></div><br/><div class="children"><div class="content">Yes: if a person knows <i>nothing else</i> about Rust and the languages that might have influenced it, then the fact that the original Rust compiler was written in OCaml should make that person conclude <i>tentatively</i> that OCaml was the language that influenced the design of Rust the most.<p>I&#x27;m not one to hold that one shouldn&#x27;t form tentative conclusions until one &quot;has all the fact&quot;. Also, I&#x27;m not one to hold that readers should trust the opinion of an internet comment writer they know nothing about. I could write a long explanation to support my opinion, but I&#x27;m probably not going to.</div><br/><div id="41521678" class="c"><input type="checkbox" id="c-41521678" checked=""/><div class="controls bullet"><span class="by">dimitrios1</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521322">parent</a><span>|</span><a href="#41526891">next</a><span>|</span><label class="collapse" for="c-41521678">[-]</label><label class="expand" for="c-41521678">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like trying to say Elixir wasn&#x27;t influenced the most by Erlang</div><br/><div id="41522045" class="c"><input type="checkbox" id="c-41522045" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521678">parent</a><span>|</span><a href="#41526891">next</a><span>|</span><label class="collapse" for="c-41522045">[-]</label><label class="expand" for="c-41522045">[2 more]</label></div><br/><div class="children"><div class="content">Was any Elixir interpreter or compiler every written in Erlang?<p>If not, what is the relevance of your comment?</div><br/><div id="41522122" class="c"><input type="checkbox" id="c-41522122" checked=""/><div class="controls bullet"><span class="by">jolux</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522045">parent</a><span>|</span><a href="#41526891">next</a><span>|</span><label class="collapse" for="c-41522122">[-]</label><label class="expand" for="c-41522122">[1 more]</label></div><br/><div class="children"><div class="content">Elixir’s implementation still has significant parts written in Erlang. I don’t know if it’s a majority but it’s a lot. e.g.: <a href="https:&#x2F;&#x2F;github.com&#x2F;elixir-lang&#x2F;elixir&#x2F;blob&#x2F;aef7e4eab521dfba9e81708b0f5d28bfe428babe&#x2F;lib&#x2F;elixir&#x2F;src&#x2F;elixir_erl_for.erl">https:&#x2F;&#x2F;github.com&#x2F;elixir-lang&#x2F;elixir&#x2F;blob&#x2F;aef7e4eab521dfba9...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41526891" class="c"><input type="checkbox" id="c-41526891" checked=""/><div class="controls bullet"><span class="by">liveranga</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520361">parent</a><span>|</span><a href="#41520614">prev</a><span>|</span><a href="#41520484">next</a><span>|</span><label class="collapse" for="c-41526891">[-]</label><label class="expand" for="c-41526891">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;influences.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;influences.html</a></div><br/></div></div><div id="41527007" class="c"><input type="checkbox" id="c-41527007" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520361">parent</a><span>|</span><a href="#41520484">prev</a><span>|</span><a href="#41519472">next</a><span>|</span><label class="collapse" for="c-41527007">[-]</label><label class="expand" for="c-41527007">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>SML, OCaml: algebraic data types, pattern matching, type inference, semicolon statement separation</i><p>&gt; <i>Haskell (GHC): typeclasses, type families</i><p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;influences.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;influences.html</a></div><br/><div id="41527208" class="c"><input type="checkbox" id="c-41527208" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41527007">parent</a><span>|</span><a href="#41519472">next</a><span>|</span><label class="collapse" for="c-41527208">[-]</label><label class="expand" for="c-41527208">[1 more]</label></div><br/><div class="children"><div class="content">Haskell has algebraic data types, pattern matching and type inference, too, and has had them since Haskell first appeared in 1990.<p>Although SML is older (1983), OCaml is younger than Haskell.</div><br/></div></div></div></div></div></div></div></div><div id="41519472" class="c"><input type="checkbox" id="c-41519472" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519148">parent</a><span>|</span><a href="#41519222">prev</a><span>|</span><a href="#41522711">next</a><span>|</span><label class="collapse" for="c-41519472">[-]</label><label class="expand" for="c-41519472">[14 more]</label></div><br/><div class="children"><div class="content">I think it does, actually. Python also has many of Haskell&#x27;s features (list comprehensions, map&#x2F;filter&#x2F;reduce, itertools, functools, etc.). But I only started reaching for those features after learning about them in Haskell.<p>In Python, it&#x27;s very easy to just write out a for-loops to do these things, and you don&#x27;t necessarily go looking for alternative ways to do these things unless you know the functional equivalents already. But in Haskell you&#x27;re forced to do things this way since there is no for-loop available. But after learning that way of thinking, the result is then more compact code with arguably less risk of bugs.</div><br/><div id="41520424" class="c"><input type="checkbox" id="c-41520424" checked=""/><div class="controls bullet"><span class="by">z500</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519472">parent</a><span>|</span><a href="#41522711">next</a><span>|</span><label class="collapse" for="c-41520424">[-]</label><label class="expand" for="c-41520424">[13 more]</label></div><br/><div class="children"><div class="content">If anything, Python encourages you to use loops because the backwards arrangement of the arguments to map and filter makes it painful to chain them.</div><br/><div id="41520604" class="c"><input type="checkbox" id="c-41520604" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520424">parent</a><span>|</span><a href="#41520775">next</a><span>|</span><label class="collapse" for="c-41520604">[-]</label><label class="expand" for="c-41520604">[11 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    map(function, iterable)
</code></pre>
That seems very logical to me, but then, I’m not a functional programmer, I just like map. It’s elegant, compact, and isn’t hard to understand. Not that list comps are hard to understand either, but they can sometimes get overly verbose.<p>filter has also lost ground in favor of list comps, partially because Guido hates FP [0], and probably due to that, there has been a lot of effort towards optimizing list comps over the years, and they’re now generally faster than filter (or map, sometimes).<p>[0]: <a href="https:&#x2F;&#x2F;www.artima.com&#x2F;weblogs&#x2F;viewpost.jsp?thread=98196" rel="nofollow">https:&#x2F;&#x2F;www.artima.com&#x2F;weblogs&#x2F;viewpost.jsp?thread=98196</a></div><br/><div id="41521885" class="c"><input type="checkbox" id="c-41521885" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520604">parent</a><span>|</span><a href="#41520775">next</a><span>|</span><label class="collapse" for="c-41521885">[-]</label><label class="expand" for="c-41521885">[10 more]</label></div><br/><div class="children"><div class="content">Yes, but how do you chain them?<p><pre><code>    map(func4, map(func3, map(func2, map(func1, iter))))
</code></pre>
vs<p><pre><code>    iter.map(f1).map(f2).map(f3).map(f4)
</code></pre>
I made up the syntax for the last one, but most functional languages have a nice syntax for it. Here&#x27;s F#:<p><pre><code>    iter |&gt; f1 |&gt; f2 |&gt; f3 |&gt; f4
</code></pre>
Or plain shell:<p><pre><code>    command | f1 | f2 | f3 | f4</code></pre></div><br/><div id="41522727" class="c"><input type="checkbox" id="c-41522727" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521885">parent</a><span>|</span><a href="#41520775">next</a><span>|</span><label class="collapse" for="c-41522727">[-]</label><label class="expand" for="c-41522727">[9 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t.<p>Use generator syntax, which is really the more pythonic way to it.<p><pre><code>    &gt;&gt;&gt; iter = [1,2,3,4]
    &gt;&gt;&gt; f1 = lambda x: x*2
    &gt;&gt;&gt; f2 = lambda x: x+4
    &gt;&gt;&gt; f3 = lambda x: x*1.25
    &gt;&gt;&gt; [f3(f2(f1(x))) for x in iter]
    [7.5, 10.0, 12.5, 15.0]</code></pre></div><br/><div id="41524668" class="c"><input type="checkbox" id="c-41524668" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522727">parent</a><span>|</span><a href="#41523081">next</a><span>|</span><label class="collapse" for="c-41524668">[-]</label><label class="expand" for="c-41524668">[1 more]</label></div><br/><div class="children"><div class="content">Generators require a __next__ method, yield statement, or generator comprehension. What you&#x27;ve got is lambdas and a list comprehension. Rewriting using generators would look something like:<p><pre><code>    items = [1,2,3,4]
    gen1 = (x*2 for x in items)
    gen2 = (x+4 for x in gen1)
    gen3 = (x*1.25 for x in gen2)
    result = list(gen3)
</code></pre>
It&#x27;s nicer in a way, certainly closer to the pipe syntax the commenter your replying to is looking for, but kind of janky to have to name all the intermediate steps.</div><br/></div></div><div id="41523081" class="c"><input type="checkbox" id="c-41523081" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522727">parent</a><span>|</span><a href="#41524668">prev</a><span>|</span><a href="#41523367">next</a><span>|</span><label class="collapse" for="c-41523081">[-]</label><label class="expand" for="c-41523081">[5 more]</label></div><br/><div class="children"><div class="content">First off, writing f3(f2(f1(x))) is painful - keeping track of parentheses. If you want to insert a function in the middle of the chain you have some bookkeeping to do.<p>Second, that&#x27;s all good and well if all you want to do is map. But what if you need combinations of map and filter as well? You&#x27;re suddenly dealing with nested comprehensions, which few people like.<p>In F#, it&#x27;ll still be:<p><pre><code>    iter |&gt; f1 |&gt; f2 |&gt; f3 |&gt; f4
</code></pre>
Here&#x27;s an example from real code I wrote:<p><pre><code>    graph
    |&gt; Map.filter isSubSetFunc
    |&gt; Map.filter doesNotContainFunc
    |&gt; Map.values
    |&gt; Set.ofSeq
</code></pre>
This would not be fun to write in List Comprehensions, but you could manage (only two list comprehensions). Now here&#x27;s other code:<p><pre><code>    graph
    |&gt; removeTerminalExerciseNodes
    |&gt; Map.filter isEmpty
    |&gt; Map.keys
    |&gt; Seq.map LookUpFunc
    |&gt; Seq.map RemoveTrivialNodes
    |&gt; Seq.sortBy GetLength
    |&gt; Seq.rev
    |&gt; Seq.toList
</code></pre>
BTW, some of the named functions above are defined with their own chain of maps and filters.</div><br/><div id="41523608" class="c"><input type="checkbox" id="c-41523608" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41523081">parent</a><span>|</span><a href="#41523367">next</a><span>|</span><label class="collapse" for="c-41523608">[-]</label><label class="expand" for="c-41523608">[4 more]</label></div><br/><div class="children"><div class="content">An alternative for python is to flip what you&#x27;re iterating over at the outermost level.  It&#x27;s certainly not as clean as F# but neither is it as bad as the original example if there&#x27;s a lot of functions:<p><pre><code>  iter = [1,2,3,4]
  f1 = lambda x: x*2
  f2 = lambda x: x+4
  f3 = lambda x: x*1.25
  
  result = iter
  for f in [f1, f2, f3]:
    result = [f(v) for v in result]
</code></pre>
Then the list comprehension can be moved up to mimic more closely what you&#x27;re doing with F#, allowing for operations other than &quot;map&quot;:<p><pre><code>   result = iter
   for f in [
     lambda a: [f1(v) for v in a],
     lambda a: [f2(v) for v in a],
     lambda a: [f3(v) for v in a],
   ]:
     result = f(result)
</code></pre>
And a step further if you don&#x27;t like the &quot;result&quot; reassignment:<p><pre><code>  from functools import reduce
  result = reduce(lambda step, f: f(step), [
    lambda a: [f1(v) for v in a],
    lambda a: [f2(v) for v in a],
    lambda a: [f3(v) for v in a],
  ], iter)</code></pre></div><br/><div id="41524447" class="c"><input type="checkbox" id="c-41524447" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41523608">parent</a><span>|</span><a href="#41523367">next</a><span>|</span><label class="collapse" for="c-41524447">[-]</label><label class="expand" for="c-41524447">[3 more]</label></div><br/><div class="children"><div class="content">Fair, but how would it look if you had some filters and reduces thrown in the middle?<p>In my F# file of 300 lines[1], I do this chaining over 20 times in various functions. Would you really want to write the Python code your way every time, or wouldn&#x27;t you prefer a simpler syntax? People generally don&#x27;t do it your way often because it has a higher mental burden than it does with the simple syntax in F# and other languages. I don&#x27;t do it 20 times because of an obsession, but because it&#x27;s natural.<p>[1] Line count is seriously inflated due to my habit of chaining across multiple lines as in my example above.</div><br/><div id="41526253" class="c"><input type="checkbox" id="c-41526253" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41524447">parent</a><span>|</span><a href="#41523367">next</a><span>|</span><label class="collapse" for="c-41526253">[-]</label><label class="expand" for="c-41526253">[2 more]</label></div><br/><div class="children"><div class="content">My example was just a way to do it with plain python and nothing special.  There are libraries that use operator overloading to get more F#-style syntax.<p>For example: <a href="https:&#x2F;&#x2F;ryi.medium.com&#x2F;flexible-piping-in-python-with-pipey-e8762db3a4ab" rel="nofollow">https:&#x2F;&#x2F;ryi.medium.com&#x2F;flexible-piping-in-python-with-pipey-...</a><p>And another mentioned there: <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;pipe&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;pipe&#x2F;</a></div><br/><div id="41528159" class="c"><input type="checkbox" id="c-41528159" checked=""/><div class="controls bullet"><span class="by">kingdomcome50</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41526253">parent</a><span>|</span><a href="#41523367">next</a><span>|</span><label class="collapse" for="c-41528159">[-]</label><label class="expand" for="c-41528159">[1 more]</label></div><br/><div class="children"><div class="content">I think we can just let this rest. These kinds of operations are not as ergonomic in python. That&#x27;s pretty clear. No example provided is even remotely close to the simplicity of the F# example. Acquiesce.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41523367" class="c"><input type="checkbox" id="c-41523367" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522727">parent</a><span>|</span><a href="#41523081">prev</a><span>|</span><a href="#41528108">next</a><span>|</span><label class="collapse" for="c-41523367">[-]</label><label class="expand" for="c-41523367">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not using generator syntax anywhere in that example.</div><br/></div></div><div id="41528108" class="c"><input type="checkbox" id="c-41528108" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522727">parent</a><span>|</span><a href="#41523367">prev</a><span>|</span><a href="#41520775">next</a><span>|</span><label class="collapse" for="c-41528108">[-]</label><label class="expand" for="c-41528108">[1 more]</label></div><br/><div class="children"><div class="content">f3(f2(f1<p>This is still backwards?</div><br/></div></div></div></div></div></div></div></div><div id="41520775" class="c"><input type="checkbox" id="c-41520775" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520424">parent</a><span>|</span><a href="#41520604">prev</a><span>|</span><a href="#41522711">next</a><span>|</span><label class="collapse" for="c-41520775">[-]</label><label class="expand" for="c-41520775">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t Haskell and Python use the same argument order?<p><pre><code>    filter(lambda x: x&lt;5, map(lambda x: 2*x, [1,2,3,4,5]))

    filter (&lt;5) . map (*2) $ [1,2,3,4,5]
</code></pre>
(Technically the Python version should be cast to a list to have identical behavior.)<p>Same with comprehensions (although nesting comprehensions will always get weird).<p><pre><code>    [x for x in [2*x for x in [1,2,3,4,5]] if x&lt;5]

    [x | x &lt;- [2*x | x &lt;- [1,2,3,4,5]], x&lt;5]</code></pre></div><br/></div></div></div></div></div></div><div id="41522692" class="c"><input type="checkbox" id="c-41522692" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519148">parent</a><span>|</span><a href="#41522711">prev</a><span>|</span><a href="#41520086">next</a><span>|</span><label class="collapse" for="c-41522692">[-]</label><label class="expand" for="c-41522692">[1 more]</label></div><br/><div class="children"><div class="content">Heck, even coming from Python (2) it felt very underwhelming and hugely oversold. (Edit: To be fair, I&#x27;d done a bit of Ocaml years earlier so algebraic data types weren&#x27;t some huge revelation).<p>Laziness is mostly an anti-pattern.</div><br/></div></div><div id="41520086" class="c"><input type="checkbox" id="c-41520086" checked=""/><div class="controls bullet"><span class="by">odyssey7</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519148">parent</a><span>|</span><a href="#41522692">prev</a><span>|</span><a href="#41519186">next</a><span>|</span><label class="collapse" for="c-41520086">[-]</label><label class="expand" for="c-41520086">[2 more]</label></div><br/><div class="children"><div class="content">Check out Swift, too!</div><br/><div id="41521583" class="c"><input type="checkbox" id="c-41521583" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520086">parent</a><span>|</span><a href="#41519186">next</a><span>|</span><label class="collapse" for="c-41521583">[-]</label><label class="expand" for="c-41521583">[1 more]</label></div><br/><div class="children"><div class="content">Why would I use swift when more cross-platform solutions exist?</div><br/></div></div></div></div></div></div><div id="41519186" class="c"><input type="checkbox" id="c-41519186" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41519148">prev</a><span>|</span><a href="#41519562">next</a><span>|</span><label class="collapse" for="c-41519186">[-]</label><label class="expand" for="c-41519186">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Granted, the tooling is sh*t.<p>I hear this a lot, but am curious about two things: (a) which bit(s) of the toolchain are you thinking about specifically -- I know HLS can be quite janky but I haven&#x27;t really been blocked by any tooling problems myself; (b) have you done much Haskell in production recently -- i.e. is this scar tissue from some ago or have you tried the toolchain recently and still found it to be lacking?</div><br/><div id="41519335" class="c"><input type="checkbox" id="c-41519335" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519186">parent</a><span>|</span><a href="#41519562">next</a><span>|</span><label class="collapse" for="c-41519335">[-]</label><label class="expand" for="c-41519335">[3 more]</label></div><br/><div class="children"><div class="content">Everytime I use cabal and&#x2F;or stack, it gives me a wall of errors and i just reinstall everyrhing all the time.</div><br/><div id="41523111" class="c"><input type="checkbox" id="c-41523111" checked=""/><div class="controls bullet"><span class="by">simonmic</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519335">parent</a><span>|</span><a href="#41521983">next</a><span>|</span><label class="collapse" for="c-41523111">[-]</label><label class="expand" for="c-41523111">[1 more]</label></div><br/><div class="children"><div class="content">And if you share stack transcripts I’ll look into those for you.<p>I’ve experienced this too, the tools can certainly be improved, but also a little more understanding of what they do and how to interpret their error messages could help you (I am guessing).</div><br/></div></div><div id="41521983" class="c"><input type="checkbox" id="c-41521983" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519335">parent</a><span>|</span><a href="#41523111">prev</a><span>|</span><a href="#41519562">next</a><span>|</span><label class="collapse" for="c-41521983">[-]</label><label class="expand" for="c-41521983">[1 more]</label></div><br/><div class="children"><div class="content">If you share a transcript from a cabal session I&#x27;ll look into this for you.</div><br/></div></div></div></div></div></div><div id="41519562" class="c"><input type="checkbox" id="c-41519562" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41519186">prev</a><span>|</span><a href="#41523034">next</a><span>|</span><label class="collapse" for="c-41519562">[-]</label><label class="expand" for="c-41519562">[11 more]</label></div><br/><div class="children"><div class="content">I think the tooling being not ideal is a reflection of how mature&#x2F;serious the community is about non academic usage. Haskell has been around for ages but it never really escaped its academic nature. I actually studied in Utrecht in the nineties where there was a lot of activity around this topic at the time. Eric Meyer who later created F# at MS was a teacher there and there was a lot of activity around doing stuff with Gopher which is a Haskell predecessor, which I learned and used at the time. All our compiler courses were basically fiddling with compiler generator frameworks that came straight out of the graduate program. Awesome research group at the time.<p>My take on this is that this was all nice and interesting but a lot of this stuff was a bit academic. F# is probably the closest the community got to having a mature tooling and developer ecosystem.<p>I don&#x27;t use Haskell myself and have no strong opinions on the topic. But usually a good community response to challenges like this is somebody stepping up and doing something about it. That starts with caring enough. If nobody cares, nothing happens.<p>Smalltalk kicked off a small tool revolution in the nineties with its refactoring browser. Smalltalk was famous for having its own IDE. That was no accident. Alan Kay, who was at Xerox PARC famously said that the best way to predict the future was to invent it. And of course he was (and is) very active in the Smalltalk community and its early development. Smalltalk was a language community that was from day one focused on having great tools. Lots of good stuff came out of that community at IBM (Visual Age, Eclipse) and later Jetbrains and other IDE makers.<p>Rust is a good recent example of a community that&#x27;s very passionate about having good tools as well. Down to the firmware and operating system and everything up. In terms of IDE support they could do better perhaps. But I think there are ongoing efforts on making the compiler more suitable for IDE features (which overlap with compiler features). And of course Cargo has a good reputation. That&#x27;s a community that cares.<p>I use Kotlin myself. Made by Jetbrains and heavily used in their IDEs and toolchains. It shows. This is a language made by tool specialists. Which is why I love it. Not necessarily for functional purists. Even though som Scala users have reluctantly switched to it. And the rest is flirting with things like Haskel and Elixir.</div><br/><div id="41520461" class="c"><input type="checkbox" id="c-41520461" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519562">parent</a><span>|</span><a href="#41520172">next</a><span>|</span><label class="collapse" for="c-41520461">[-]</label><label class="expand" for="c-41520461">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think the tooling being not ideal is a reflection of how mature&#x2F;serious the community is about non academic usage.<p>I&#x27;d say it&#x27;s more of a reflection of how having a very big company funding the language is making a difference.<p>People like to link Haskell&#x27;s situation to its academic origins, but in reality, most of the issues with the ecosystem are related to acute underfunding compared to mainstream languages.</div><br/><div id="41520606" class="c"><input type="checkbox" id="c-41520606" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520461">parent</a><span>|</span><a href="#41520172">next</a><span>|</span><label class="collapse" for="c-41520606">[-]</label><label class="expand" for="c-41520606">[3 more]</label></div><br/><div class="children"><div class="content">One doesn&#x27;t happen without the other. Haskell is hugely influential with it&#x27;s ideas and impact. But commercially it never really took off. Stuff like that needs to come from within the community; it&#x27;s never going to come from the outside.</div><br/><div id="41522035" class="c"><input type="checkbox" id="c-41522035" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520606">parent</a><span>|</span><a href="#41520172">next</a><span>|</span><label class="collapse" for="c-41522035">[-]</label><label class="expand" for="c-41522035">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Stuff like that needs to come from within the community<p>Either the community is large enough for it, or it comes from the sponsoring company.<p>Few languages start off by being in the first situation. The first example that comes to my mind (Python), well... Tooling was a long and painful road. And if the language hadn&#x27;t been used&#x2F;backed by many prominent companies, I don&#x27;t see how man-hours would have flowed into tooling.</div><br/><div id="41528321" class="c"><input type="checkbox" id="c-41528321" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522035">parent</a><span>|</span><a href="#41520172">next</a><span>|</span><label class="collapse" for="c-41528321">[-]</label><label class="expand" for="c-41528321">[1 more]</label></div><br/><div class="children"><div class="content">Python is a good example. Guido van Rossum was an academic when he built python. And then later he got employed to work on Python because indeed a lot of people found his work useful. By the time that happened, python was already quite widely used though.<p>Also time wise it&#x27;s a good example because python emerged early nineties around the same time the Haskell community started forming. Haskell had a few years head start actually.<p>The difference was that python became popular quite early in things like Linux distributions and even though Haskell was available and similarly easy to install in those, it never really caught on. Sponsored development usually happens as a result of people finding uses for a language, not before.</div><br/></div></div></div></div></div></div></div></div><div id="41520172" class="c"><input type="checkbox" id="c-41520172" checked=""/><div class="controls bullet"><span class="by">odyssey7</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519562">parent</a><span>|</span><a href="#41520461">prev</a><span>|</span><a href="#41522607">next</a><span>|</span><label class="collapse" for="c-41520172">[-]</label><label class="expand" for="c-41520172">[4 more]</label></div><br/><div class="children"><div class="content">“Greece, Rome’s captive, took Rome captive.”<p>The languages of engineering-aligned communities may appear to have won the race, though they have been adopting significant ideas from Haskell and related languages in their victories.</div><br/><div id="41521010" class="c"><input type="checkbox" id="c-41521010" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520172">parent</a><span>|</span><a href="#41522607">next</a><span>|</span><label class="collapse" for="c-41521010">[-]</label><label class="expand" for="c-41521010">[3 more]</label></div><br/><div class="children"><div class="content">Something went wrong in the adoption process.<p>Haskell&#x27;s biggest benefit is <i>functions</i>, not <i>methods</i>.  To define a function, you need to stop directly mutating, and instead rely maps, folds, filters, etc.  The bargain was: you give up your familiar and beloved for-loops, and in return you get software that <i>will yield the same output given the same input</i>.<p>So what happened with the adoption?  The Java people willingly gave up the for-loops in favour of the Streams&#x2F;maps&#x2F;filters.  But they didn&#x27;t take up the reward of <i>software that yields the same input given the same output</i>.<p>What&#x27;s something else in the top-5 killer Haskell features?  No nulls.  The value proposition is: <i>if you have a value, then you have a value</i>, no wondering about whether it&#x27;s &quot;uninitialised&quot;.  The penalty you pay for this is more verbosity when representing missing values (i.e. Maybe).<p>Again, the penalty (verbose missing values ie. Optional&lt;&gt;) was adopted, and the reward (confidently-present values) was not.</div><br/><div id="41524289" class="c"><input type="checkbox" id="c-41524289" checked=""/><div class="controls bullet"><span class="by">odyssey7</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521010">parent</a><span>|</span><a href="#41525433">next</a><span>|</span><label class="collapse" for="c-41524289">[-]</label><label class="expand" for="c-41524289">[1 more]</label></div><br/><div class="children"><div class="content">The type system is a big part and elements of that have shown up elsewhere. I’m with you on the belief that we should have better adoption for immutability, pure functions, and equational reasoning.<p>JavaScript promises can work analogously to the Maybe monad if you want them to.<p>Swift’s optionals are essentially the same thing as the Maybe monad.</div><br/></div></div><div id="41525433" class="c"><input type="checkbox" id="c-41525433" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41521010">parent</a><span>|</span><a href="#41524289">prev</a><span>|</span><a href="#41522607">next</a><span>|</span><label class="collapse" for="c-41525433">[-]</label><label class="expand" for="c-41525433">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Again, the penalty (verbose missing values ie. Optional&lt;&gt;) was adopted, and the reward (confidently-present values) was not.</i><p>Ah, the joys of having a Scala `Option` type and still having to consider the cases or Some[thing], Nothing and... null!<p>Yes, well-written Scala code knows not to use null with reckless abandon, but since when your coworkers coming from Java know to show restraint?</div><br/></div></div></div></div></div></div><div id="41522607" class="c"><input type="checkbox" id="c-41522607" checked=""/><div class="controls bullet"><span class="by">Nelkins</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519562">parent</a><span>|</span><a href="#41520172">prev</a><span>|</span><a href="#41523034">next</a><span>|</span><label class="collapse" for="c-41522607">[-]</label><label class="expand" for="c-41522607">[2 more]</label></div><br/><div class="children"><div class="content">Pretty sure F# was created by Don Syme, not Erik Meijer.</div><br/><div id="41528354" class="c"><input type="checkbox" id="c-41528354" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522607">parent</a><span>|</span><a href="#41523034">next</a><span>|</span><label class="collapse" for="c-41528354">[-]</label><label class="expand" for="c-41528354">[1 more]</label></div><br/><div class="children"><div class="content">You are right. My mistake. They both worked for Microsoft though and Erik Meijer did work on things like Linq, which was an important part of the F# ecosystem. Also his work seems to have inspired Don Syme.</div><br/></div></div></div></div></div></div><div id="41523034" class="c"><input type="checkbox" id="c-41523034" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41519562">prev</a><span>|</span><a href="#41522857">next</a><span>|</span><label class="collapse" for="c-41523034">[-]</label><label class="expand" for="c-41523034">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Give it a try. Especially, if you don&#x27;t know what to expect, I can guarantee that you&#x27;ll be surprised!<p>And I will as <i>strongly</i> as possible emphasize the opposite you should not.<p>If you are are already experienced in functional programming, as well as in statically typed functional programming or something lovely in the ML family of languages then only then does Haskell make sense to learn.<p>If you are looking to learn about either FP in general, or staticly typed FP Haskell is about the single worst language anyone can start with. More people have been discouraged from using FP because they started with Haskell than is probably appreciated. The effort to insight ratio for Haskell is incredibly high.<p>You can learn the majority of the concepts faster in another language with likely 1&#x2F;10th the effort. For general FP learn clojure, Racket, or another scheme. For statically typed FP learn F# or Scala or OCAML or even Elm.<p>In fact if you really want to learn Haskell is is faster to learn Elm and then Haskell than it is to just learn Haskel. Because the amout or weeds you have to navigate through to get to the concepts in Haskell are so high that you can first learn the concepts and approach in a tiny language like Elm and it will more than save the amount of time it would take to understand those approaches from trying to learn Haskell. It seems unbelievable but ai found it to be very try. You can learn two languages faster than just one because of how muddy Haskell is.<p>Now that said FP is valuable and in my opinion a cleaner design and why in general our industry keeps shifting that way. Monoids, Functors, Applicative are nice design patterns. Pushing side effects to the edge of your code (which is enforced by types) is a great practice. Monads are way overhyped, thinking in types is way undervalued. But you can get all of these concepts without learning Haskell.<p>So that&#x27;s the end of my rant as I&#x27;ve grown tired of watching people dismiss FP because they confuse the great concepts of FP with the horrible warts that come with Haskell.<p>Haskell is a great language, and I&#x27;m glad I learned it (and am in no way an expert at it)- but it is the single worst language for an introduction to FP concepts. If you&#x27;re already deep in FP it&#x27;s and awesome addition to your toolbox of concepts and for that specific purpose I highly recommend it.<p>And finally, LYAH is a terrible resource.</div><br/><div id="41526191" class="c"><input type="checkbox" id="c-41526191" checked=""/><div class="controls bullet"><span class="by">dietlbomb</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41523034">parent</a><span>|</span><a href="#41525404">next</a><span>|</span><label class="collapse" for="c-41526191">[-]</label><label class="expand" for="c-41526191">[2 more]</label></div><br/><div class="children"><div class="content">Is it worth learning JavaScript before learning Elm?</div><br/><div id="41527841" class="c"><input type="checkbox" id="c-41527841" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41526191">parent</a><span>|</span><a href="#41525404">next</a><span>|</span><label class="collapse" for="c-41527841">[-]</label><label class="expand" for="c-41527841">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not front end expert, but I have a working knowledge of html &amp; js. I feel like it would still be ok without any JS background, but I could be wrong on that.<p>That said the language is small enough you can go through the tutorial in a weekend. You&#x27;ll know pretty quickly if you feel like you&#x27;re picking it up or feels too foreign.<p>My gut feel is general programming experience is enough, but don&#x27;t hold me to that one.</div><br/></div></div></div></div><div id="41525404" class="c"><input type="checkbox" id="c-41525404" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41523034">parent</a><span>|</span><a href="#41526191">prev</a><span>|</span><a href="#41522857">next</a><span>|</span><label class="collapse" for="c-41525404">[-]</label><label class="expand" for="c-41525404">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And finally, LYAH is a terrible resource.<p>Could you elaborate? I know LYAH doesn&#x27;t teach enough to write real programs, and does not introduce necessary concepts such as monad transformers, but why is it so terrible as an introduction to Haskell and FP? (In my mind, incomplete&#x2F;flawed != terrible... Terrible means &quot;avoid at all costs&quot;).<p>As for your overall point, I remember articles posted here on HN about someone teaching Haskell to children (no prior exposure to any other prog lang) with great success.</div><br/><div id="41526830" class="c"><input type="checkbox" id="c-41526830" checked=""/><div class="controls bullet"><span class="by">everial</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41525404">parent</a><span>|</span><a href="#41522857">next</a><span>|</span><label class="collapse" for="c-41526830">[-]</label><label class="expand" for="c-41526830">[1 more]</label></div><br/><div class="children"><div class="content">(not gp, and from memory awhile ago so please forgive lack of exact quotes &amp; page numbers)<p>Bunch of places where the tone masked or downplayed real issues in ways that made other text suspect. As a concrete example, `head [] -&gt; Exception` with something like &quot;of course it errors if you take the first part of something that&#x27;s not there&quot; and `take 1 [] -&gt; []` with &quot;obviously taking one thing from an empty list gets you an empty list&quot; -- uh, no. Maybe it&#x27;s a historical wart, maybe there are good technical reasons, but different behavior in these cases is <i>definitely not</i> obvious!</div><br/></div></div></div></div></div></div><div id="41522857" class="c"><input type="checkbox" id="c-41522857" checked=""/><div class="controls bullet"><span class="by">0x3444ac53</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41523034">prev</a><span>|</span><a href="#41520377">next</a><span>|</span><label class="collapse" for="c-41522857">[-]</label><label class="expand" for="c-41522857">[2 more]</label></div><br/><div class="children"><div class="content">Would you mind explaining what you mean by stateless?</div><br/><div id="41524079" class="c"><input type="checkbox" id="c-41524079" checked=""/><div class="controls bullet"><span class="by">jgwil2</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522857">parent</a><span>|</span><a href="#41520377">next</a><span>|</span><label class="collapse" for="c-41524079">[-]</label><label class="expand" for="c-41524079">[1 more]</label></div><br/><div class="children"><div class="content">Haskell functions are pure, like mathematical functions: the same input to a function produces the same output every time, regardless of the state of the application. That means the function cannot read or write any data that is not passed directly to it as an argument. So the program is &quot;stateless&quot; in that the behavior does not depend on anything other than its inputs.<p>This is valuable because you as the developer have a lot less stuff to think about when you&#x27;re trying to reason about your program&#x27;s behavior.</div><br/></div></div></div></div><div id="41520377" class="c"><input type="checkbox" id="c-41520377" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41522857">prev</a><span>|</span><a href="#41523048">next</a><span>|</span><label class="collapse" for="c-41520377">[-]</label><label class="expand" for="c-41520377">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Haskell has had a profound impact on the way I think about programming and how I architect my code and build services.<p>Exactly the same for me.<p>&gt; Granted, the tooling is sh*t.<p>Stack and Stackage (one of the package managers and library distribution systems in Haskell-land) is the best I found in any language.<p>Other than that I also found some tools to be lacking.</div><br/><div id="41521405" class="c"><input type="checkbox" id="c-41521405" checked=""/><div class="controls bullet"><span class="by">dario_od</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520377">parent</a><span>|</span><a href="#41523048">next</a><span>|</span><label class="collapse" for="c-41521405">[-]</label><label class="expand" for="c-41521405">[2 more]</label></div><br/><div class="children"><div class="content">What makes you say that stack is the best you found in any language?
I use it daily, and in my experience I&#x27;d put it just a bit above PHP&#x27;s composer</div><br/></div></div></div></div><div id="41519261" class="c"><input type="checkbox" id="c-41519261" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41519079">parent</a><span>|</span><a href="#41523048">prev</a><span>|</span><a href="#41525287">next</a><span>|</span><label class="collapse" for="c-41519261">[-]</label><label class="expand" for="c-41519261">[16 more]</label></div><br/><div class="children"><div class="content">Sum types are finally coming to C#. That’ll make it the first “Mainstream” language to adopt them. Will it be as solid and simple as Haskell’s implementation? Of course not. Will having a backing ecosystem make up for that deficiency? Yes.</div><br/><div id="41519407" class="c"><input type="checkbox" id="c-41519407" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519261">parent</a><span>|</span><a href="#41519328">next</a><span>|</span><label class="collapse" for="c-41519407">[-]</label><label class="expand" for="c-41519407">[6 more]</label></div><br/><div class="children"><div class="content">What counts as mainstream for you?<p>Java has recently added sealed classes&#x2F;interfaces which offer the same features as sum types, and I would argue that Java is definitely mainstream.<p>Kotlin has a similar feature. It might be used less than Java, but it&#x27;s the default language for Android.<p>Swift has `enum` for sum types and is the default language for iOS and MacOS.<p>Likewise for Rust, which is gaining traction recently.<p>Typescript also has union&#x2F;sum types and is gaining lot of traction.</div><br/><div id="41520181" class="c"><input type="checkbox" id="c-41520181" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519407">parent</a><span>|</span><a href="#41522281">next</a><span>|</span><label class="collapse" for="c-41520181">[-]</label><label class="expand" for="c-41520181">[2 more]</label></div><br/><div class="children"><div class="content">For that matter, PASCAL has had variant records (i.e. sum types) since the 1970s.</div><br/><div id="41520259" class="c"><input type="checkbox" id="c-41520259" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520181">parent</a><span>|</span><a href="#41522281">next</a><span>|</span><label class="collapse" for="c-41520259">[-]</label><label class="expand" for="c-41520259">[1 more]</label></div><br/><div class="children"><div class="content">Did it have an ergonomic way to exhaustively match on all the variants? Since the 70s?<p>How does the ABI work? If a library adds a new constructor, but I am still linking against the old version, I imagine that it could be reading the wrong fields, since the constructor it&#x27;s reading is now at a different index?</div><br/></div></div></div></div><div id="41522281" class="c"><input type="checkbox" id="c-41522281" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519407">parent</a><span>|</span><a href="#41520181">prev</a><span>|</span><a href="#41519328">next</a><span>|</span><label class="collapse" for="c-41522281">[-]</label><label class="expand" for="c-41522281">[3 more]</label></div><br/><div class="children"><div class="content">Sealed classes still won&#x27;t let you have e.g. String|Integer, though I&#x27;ll grant you that java is certainly mainstream.</div><br/><div id="41525280" class="c"><input type="checkbox" id="c-41525280" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522281">parent</a><span>|</span><a href="#41523264">next</a><span>|</span><label class="collapse" for="c-41525280">[-]</label><label class="expand" for="c-41525280">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t really need `String|Integer`, for most usecases an isomorphic type that you can exhaustively pattern match on is more than enough, and sealed classes (along with the support in `switch` expressions) does exactly that.</div><br/></div></div><div id="41523264" class="c"><input type="checkbox" id="c-41523264" checked=""/><div class="controls bullet"><span class="by">kagakuninja</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41522281">parent</a><span>|</span><a href="#41525280">prev</a><span>|</span><a href="#41519328">next</a><span>|</span><label class="collapse" for="c-41523264">[-]</label><label class="expand" for="c-41523264">[1 more]</label></div><br/><div class="children"><div class="content">Scala 3 has had union types for 4 years now. Scala can be used to do Haskell style pure FP, but with much better tooling. And it has the power of the JVM, you can fall back to Java libraries if you want.</div><br/></div></div></div></div></div></div><div id="41519328" class="c"><input type="checkbox" id="c-41519328" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519261">parent</a><span>|</span><a href="#41519407">prev</a><span>|</span><a href="#41520329">next</a><span>|</span><label class="collapse" for="c-41519328">[-]</label><label class="expand" for="c-41519328">[2 more]</label></div><br/><div class="children"><div class="content">Rust is mainstream, just not use in enterprise applications</div><br/><div id="41527431" class="c"><input type="checkbox" id="c-41527431" checked=""/><div class="controls bullet"><span class="by">gamegoblin</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519328">parent</a><span>|</span><a href="#41520329">next</a><span>|</span><label class="collapse" for="c-41527431">[-]</label><label class="expand" for="c-41527431">[1 more]</label></div><br/><div class="children"><div class="content">AWS uses Rust extensively</div><br/></div></div></div></div><div id="41520329" class="c"><input type="checkbox" id="c-41520329" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519261">parent</a><span>|</span><a href="#41519328">prev</a><span>|</span><a href="#41520457">next</a><span>|</span><label class="collapse" for="c-41520329">[-]</label><label class="expand" for="c-41520329">[1 more]</label></div><br/><div class="children"><div class="content">Not really, other mainstream languages got there first.</div><br/></div></div><div id="41520457" class="c"><input type="checkbox" id="c-41520457" checked=""/><div class="controls bullet"><span class="by">pid-1</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41519261">parent</a><span>|</span><a href="#41520329">prev</a><span>|</span><a href="#41525287">next</a><span>|</span><label class="collapse" for="c-41520457">[-]</label><label class="expand" for="c-41520457">[6 more]</label></div><br/><div class="children"><div class="content">Python has sum types<p>optional_int: int | None = None</div><br/><div id="41520765" class="c"><input type="checkbox" id="c-41520765" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520457">parent</a><span>|</span><a href="#41520492">next</a><span>|</span><label class="collapse" for="c-41520765">[-]</label><label class="expand" for="c-41520765">[3 more]</label></div><br/><div class="children"><div class="content">This is semantically not the same as a sum type (as understood in the sense of Rust, which is afaik the academically accepted way)!<p>Python&#x27;s `A | B` is a union operation, but in Rust a sum type is always a disjoint union. In Python, if `A = B = None`, then `A | B` has one possible instance.<p>In Rust, this sum type has two possible instances. This might not sound like a big deal, but the semantics are quite different.</div><br/><div id="41526126" class="c"><input type="checkbox" id="c-41526126" checked=""/><div class="controls bullet"><span class="by">pid-1</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520765">parent</a><span>|</span><a href="#41520492">next</a><span>|</span><label class="collapse" for="c-41526126">[-]</label><label class="expand" for="c-41526126">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, I could not grok the difference, even after reading a few Rust examples.<p>def foo(int | None = None) ...<p>... just means the variable&#x27;s default value is None in a function definition. But it could be either in an actual function call.</div><br/><div id="41527284" class="c"><input type="checkbox" id="c-41527284" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41526126">parent</a><span>|</span><a href="#41520492">next</a><span>|</span><label class="collapse" for="c-41527284">[-]</label><label class="expand" for="c-41527284">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no difference there because the types are already disjoint.<p>Say you wanted to define some function taking `YYMMDD | MMDDYY`. If both YYMMDD  and MMDDYY are just aliases to `str`, then you gain no information, you cannot discriminate on which one it is, since the union `str | str` just reduces to `str`.<p>Sum types are disjointed unions, you can&#x27;t just say `str | str`, the terms are wrapped in unique nominal data constructors, like:<p>enum Date { MMDDYY(String), YYMMDD(String) }<p>Then when accepting a `Date` you can discriminate which format it&#x27;s in. You could do the same in Python by defining two unique types and using `MMDDYY | YYMMDD`.</div><br/></div></div></div></div></div></div><div id="41520492" class="c"><input type="checkbox" id="c-41520492" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520457">parent</a><span>|</span><a href="#41520765">prev</a><span>|</span><a href="#41525287">next</a><span>|</span><label class="collapse" for="c-41520492">[-]</label><label class="expand" for="c-41520492">[2 more]</label></div><br/><div class="children"><div class="content">Every dynamically typed language effectively has one big Sum type that holds all of the other types. IMO this is one reason why dynamic languages have been so popular (because Sum types are incredibly useful, and mainstream statically typed languages have historically had very poor support for them).</div><br/><div id="41529121" class="c"><input type="checkbox" id="c-41529121" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519079">root</a><span>|</span><a href="#41520492">parent</a><span>|</span><a href="#41525287">next</a><span>|</span><label class="collapse" for="c-41529121">[-]</label><label class="expand" for="c-41529121">[1 more]</label></div><br/><div class="children"><div class="content">I like this observation!  It explains a lot.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41525287" class="c"><input type="checkbox" id="c-41525287" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41519079">prev</a><span>|</span><a href="#41519451">next</a><span>|</span><label class="collapse" for="c-41525287">[-]</label><label class="expand" for="c-41525287">[5 more]</label></div><br/><div class="children"><div class="content">As far as I&#x27;ve heard, Haskell&#x27;s type system doesn&#x27;t normally prove functions to be total; they can diverge. This fine, though, because for ordinary programming, a proof of totality isn&#x27;t a useful guarantee. You care how long programs actually take to run, not whether they would theoretically finish eventually.<p>It&#x27;s only when proving theorems that a mathematical proof of totality matters, and there are specialized languages for that.<p>For most people, we test in order to make a <i>scientific</i> claim, that we tried running it, and it worked for the inputs we tried, and completed in a reasonable amount of time.<p>This is true of property testing and even model-checking; in simple cases, sometimes an exhaustive test can be done, but they don&#x27;t actually prove statements outside the bounds used when testing.</div><br/><div id="41528785" class="c"><input type="checkbox" id="c-41528785" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41525287">parent</a><span>|</span><a href="#41525687">next</a><span>|</span><label class="collapse" for="c-41528785">[-]</label><label class="expand" for="c-41528785">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As far as I&#x27;ve heard, Haskell&#x27;s type system doesn&#x27;t normally prove functions to be total; they can diverge.<p>This is true.  You can write a function which is the natural numbers, and I wouldn&#x27;t want the type system to preclude it.<p><pre><code>  nats :: [Integer]
  nats = [1..]
</code></pre>
However, I would love to be able to opt in to declaring functions total on a case-by-case basis, like Idris can.<p>&gt; This fine, though, because for ordinary programming, a proof of totality isn&#x27;t a useful guarantee. You care how long programs actually take to run, not whether they would theoretically finish eventually.<p>This wouldn&#x27;t be the point of the guarantee for me.  Haskell functions already give you assurances that you&#x27;ve not made any mistakes:<p>* You haven&#x27;t accidentally introduced null, or missed any null checks.
* You haven&#x27;t written code which will do a different thing tomorrow than it did today.
* Your function won&#x27;t race, nor will it cause other functions to race.<p>If you have a function Foo-&gt;Bar, and you give it a Foo, you&#x27;ve all-but-proved that you&#x27;ll get a valid Bar back.  How can you screw that up?  By diverging.  I&#x27;m not trying to put a bound on a long-running function, I just want the type system to make sure the function isn&#x27;t sucking on its own tailpipe.</div><br/></div></div><div id="41525687" class="c"><input type="checkbox" id="c-41525687" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#41525287">parent</a><span>|</span><a href="#41528785">prev</a><span>|</span><a href="#41519451">next</a><span>|</span><label class="collapse" for="c-41525687">[-]</label><label class="expand" for="c-41525687">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s perfectly feasible to have proofs about programs together with a guaranteed upper bound on (something like) the &quot;number of processor instructions it will take&quot; (given known finite bounds for all inputs).<p>Of course, just like any other system that allows correctness <i>proofs</i>, it wouldn&#x27;t be nearly useful enough to justify the effort for all but a negligible number of applications. That&#x27;s at least until the levels of effort required are significantly reduced.</div><br/><div id="41525888" class="c"><input type="checkbox" id="c-41525888" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41525287">root</a><span>|</span><a href="#41525687">parent</a><span>|</span><a href="#41519451">next</a><span>|</span><label class="collapse" for="c-41525888">[-]</label><label class="expand" for="c-41525888">[2 more]</label></div><br/><div class="children"><div class="content">Yes, a theoretical calculation like that would be useful as an estimate. But theoretical performance on ideal machines is only loosely related to performance on real machines under real conditions. That&#x27;s true of testing, too. Benchmark performance varies even between runs.<p>So there&#x27;s still going to be a theoretical math versus science and engineering divide.<p>Another perspective is that we have a useful division of concerns. Static checking is useful to find some kinds of errors. API&#x27;s help to ensure that certain things don&#x27;t change in a new version, so that performance improvements are less likely to break callers.<p>Depending on the domain, leaving some things like performance and size limits deliberately unspecified in API&#x27;s seems like more of a feature than a bug? Stricter interfaces aren&#x27;t always an improvement.</div><br/><div id="41529005" class="c"><input type="checkbox" id="c-41529005" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#41525287">root</a><span>|</span><a href="#41525888">parent</a><span>|</span><a href="#41519451">next</a><span>|</span><label class="collapse" for="c-41529005">[-]</label><label class="expand" for="c-41529005">[1 more]</label></div><br/><div class="children"><div class="content">&gt; leaving some things like performance and size limits deliberately unspecified in API&#x27;s seems like more of a feature than a bug<p>In rare cases there might be exceptions. Hard real time applications and constant time cryptography come to mind.<p>Regardless, I didn&#x27;t mean for such proofs to be part of an API or any kind of interface. It&#x27;s just a guarantee you would get about your program. E.g., &quot;it never times out&quot;, or &quot;the worst case data throughout is X&quot; (in whatever hardware model the proof assumes, which in theory could be made very close to the actual hardware).</div><br/></div></div></div></div></div></div></div></div><div id="41519451" class="c"><input type="checkbox" id="c-41519451" checked=""/><div class="controls bullet"><span class="by">axilmar</span><span>|</span><a href="#41525287">prev</a><span>|</span><a href="#41519694">next</a><span>|</span><label class="collapse" for="c-41519451">[-]</label><label class="expand" for="c-41519451">[17 more]</label></div><br/><div class="children"><div class="content">My question for Haskellers is how to do updates of values on a large scale, let&#x27;s say in a simulation.<p>In imperative languages, the program will have a list of entities, and there will be an update() function for each entity that updates its state (position, etc) inline, i.e. new values are overwriten onto old values in memory, invoked at each simulation step.<p>In Haskell, how is that handled? do I have to recreate the list of entities with their changes at every simulation step? does Haskell have a special construct that allows for values to be overwritten, just like in imperative languages?<p>Please don&#x27;t respond with &#x27;use the IO monad&#x27; or &#x27;better use another language because Haskell is not up for the task&#x27;. I want an actual answer. I&#x27;ve asked this question in the past in this and some other forums and never got a straight answer.<p>If you reply with &#x27;use the IO monad&#x27; or something similar, can you please say if  whatever you propose allows for in place update of values? It&#x27;s important to know, for performance reasons. I wouldn&#x27;t want to start simulations in a language that requires me to reconstruct every object at every simulation step.<p>I am asking for this because the answer to &#x27;why Haskell&#x27; has always been for me &#x27;why not Haskell: because I write simulations and performance is of concern to me&#x27;.</div><br/><div id="41521540" class="c"><input type="checkbox" id="c-41521540" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41520102">next</a><span>|</span><label class="collapse" for="c-41521540">[-]</label><label class="expand" for="c-41521540">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure why you say not to respond with &#x27;use the IO monad&#x27; because that&#x27;s exactly how you&#x27;d do it!  As an example, here&#x27;s some code that updates elements of a vector.<p><pre><code>    import Data.Vector.Unboxed.Mutable
    
    import Data.Foldable (for_)
    import Prelude hiding (foldr, read, replicate)
    
    -- ghci&gt; main
    -- [0,0,0,0,0,0,0,0,0,0]
    -- [0,5,10,15,20,25,30,35,40,45]
    main = do
      v &lt;- replicate 10 0
    
      printVector v
    
      for_ [1 .. 5] $ \_ -&gt; do
        for_ [0 .. 9] $ \i -&gt; do
          v_i &lt;- read v i
          write v i (v_i + i)
    
      printVector v
    
    printVector :: (Show a, Unbox a) =&gt; MVector RealWorld a -&gt; IO ()
    printVector v = do
      list &lt;- foldr (:) [] v
      print list
</code></pre>
It does roughly the same as this Python:<p><pre><code>    # python &#x2F;tmp&#x2F;test28.py
    # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    # [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]
    def main():
        v = [0] * 10
    
        print(v)
    
        for _ in range(5):
            for i in range(10):
                v_i = v[i]
                v[i] = v_i + i
    
    
        print(v)
    
    if __name__ == &#x27;__main__&#x27;: main()</code></pre></div><br/></div></div><div id="41520102" class="c"><input type="checkbox" id="c-41520102" checked=""/><div class="controls bullet"><span class="by">contificate</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41521540">prev</a><span>|</span><a href="#41522157">next</a><span>|</span><label class="collapse" for="c-41520102">[-]</label><label class="expand" for="c-41520102">[1 more]</label></div><br/><div class="children"><div class="content">I have a rather niche theory that many Hindley-Milner type inference tutorials written by Haskellers insist on teaching the error-prone, slow, details of algorithm W because otherwise the authors would need to commit to a way to do destructive unification (as implied by algorithm J) that doesn&#x27;t attract pedantic criticism from other Haskellers.<p>For me, I stopped trying to learn Haskell because I couldn&#x27;t quite make the jump from writing trivial (but neat) little self-contained programs to writing larger, more involved, programs. You seem to need to buy into a contorted way of mentally modelling the problem domain that doesn&#x27;t quite pay off in the ways advertised to you by Haskell&#x27;s proponents (as arguments against contrary approaches tend to be hyperbolic). I&#x27;m all for persistent data structures, avoiding global state, monadic style, etc. but I find that OCaml is a simpler, pragmatic, vehicle for these ideas without being forced to bend over backwards at every hurdle for limited benefit.</div><br/></div></div><div id="41522157" class="c"><input type="checkbox" id="c-41522157" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41520102">prev</a><span>|</span><a href="#41519572">next</a><span>|</span><label class="collapse" for="c-41522157">[-]</label><label class="expand" for="c-41522157">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In imperative languages, the program will have a list of entities, and there will be an update() function for each entity that updates its state (position, etc) inline, i.e. new values are overwriten onto old values in memory, invoked at each simulation step.<p>&gt; In Haskell, how is that handled? do I have to recreate the list of entities with their changes at every simulation step? does Haskell have a special construct that allows for values to be overwritten, just like in imperative languages?<p>You don&#x27;t _have to_ recreate the list each time, but that&#x27;s probably where I&#x27;d suggest starting. GHC is optimized for these kinds of patterns, and in many cases it&#x27;ll compile your code to something that does in-place updates for you, while letting you write pure functions that return a new list. Even when it can&#x27;t, the runtime is designed for these kinds of small allocations and updates, and the performance is much better than what you&#x27;d get with that kind of code in another language.<p>If you decided that you really did need in-place updates, then there are a few options. Instead of storing a vector of values (if you are thinking about performance you probably want vectors instead of lists), you can store a vector of references that can be updated. IO is one way to do that (with IORefs) but you can also get &quot;internal mutability&quot; using STRefs. ST is great because it lets you write a function that uses mutable memory but still looks like a pure function to the callers because it guarantees that the impure stuff is only visible inside of the pure function. If you need concurrency, you might use STM and store them as MVars. Ultimately all of these options are different variations on &quot;Store a list of pointers, rather than a list of values&quot;.<p>There are various other optimizations you could do too. For example, you can use unboxed mutable vectors to avoid having to do a bunch of pointer chasing. You can use GHC primitives to eek out even better performance. In the best case scenario I&#x27;ve seen programs like this written in Haskell be competitive with Java (after the warmup period), and you can keep the memory utilization pretty low. You probably won&#x27;t get something that&#x27;s competitive with C unless you are writing extremely optimized code, and at that point most of the time I&#x27;d suggest just writing the critical bits in C and using the FFI to link that into your program.</div><br/></div></div><div id="41519572" class="c"><input type="checkbox" id="c-41519572" checked=""/><div class="controls bullet"><span class="by">lieks</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41522157">prev</a><span>|</span><a href="#41519482">next</a><span>|</span><label class="collapse" for="c-41519572">[-]</label><label class="expand" for="c-41519572">[2 more]</label></div><br/><div class="children"><div class="content">You... don&#x27;t. You have to rely on compiler optimizations to get good performance.<p>Monads are more-or-less syntax sugar. They give you a structure that allows these optimizations more easily, and also make the code more readable sometimes.<p>But in your example, update returns a new copy of the state, and you map it over a list for each step. The compiler tries to optimize that into in-place mutation.<p>IMO, having to rely so much on optimization is one of the weak points of the language.</div><br/><div id="41520447" class="c"><input type="checkbox" id="c-41520447" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#41519451">root</a><span>|</span><a href="#41519572">parent</a><span>|</span><a href="#41519482">next</a><span>|</span><label class="collapse" for="c-41520447">[-]</label><label class="expand" for="c-41520447">[1 more]</label></div><br/><div class="children"><div class="content"><i>You do</i>, and you&#x27;ll have to use do destructive updates within either ST or IO monad using their respective single variable or array types. It looks roundabouty, but does do the thing you want and <i>it is</i> fast.<p>ST and IO are &quot;libraries&quot; though, in the sense that they not special parts of the language, but appear like any other types.</div><br/></div></div></div></div><div id="41519482" class="c"><input type="checkbox" id="c-41519482" checked=""/><div class="controls bullet"><span class="by">bedman12345</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41519572">prev</a><span>|</span><a href="#41519557">next</a><span>|</span><label class="collapse" for="c-41519482">[-]</label><label class="expand" for="c-41519482">[1 more]</label></div><br/><div class="children"><div class="content">An example of how to use the io monad for simulations <a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;q6600&#x2F;program&#x2F;nbody-ghc-2.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a> 
It’s one of the nicer to read ones I’ve seen. Still is terrible imo.</div><br/></div></div><div id="41519557" class="c"><input type="checkbox" id="c-41519557" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41519482">prev</a><span>|</span><a href="#41519581">next</a><span>|</span><label class="collapse" for="c-41519557">[-]</label><label class="expand" for="c-41519557">[1 more]</label></div><br/><div class="children"><div class="content">In your imperative language, imagine this:<p><pre><code>    World simulation(Stream&lt;Event&gt; events, World world) =&gt;
       events.IsComplete
           ? world
           : simulation(applyEventToWorld(events.Head, world), events.Tail);

    World applyEventToWorld(Event event, World world) =&gt;
       &#x2F;&#x2F; .. create a new World using the immutable inputs
</code></pre>
That takes the first event that arrives, transforms the World, then recursively calls itself with the remaining events and the transformed World.  This is the most pure way of doing what you ask.  Recursion is the best way to &#x27;mutate&#x27;, without using mutable structures.<p>However, there are real mutation constructs, like IORef [1] It will do actual in-place (atomic) mutation if you really want in-place updates.  It requires the IO monad.<p>[1] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.20.0.1&#x2F;docs&#x2F;Data-IORef.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.20.0.1&#x2F;docs&#x2F;Data-...</a></div><br/></div></div><div id="41519581" class="c"><input type="checkbox" id="c-41519581" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41519557">prev</a><span>|</span><a href="#41521208">next</a><span>|</span><label class="collapse" for="c-41519581">[-]</label><label class="expand" for="c-41519581">[2 more]</label></div><br/><div class="children"><div class="content">I mean, Haskell has mutable vectors[1]. You can mutate them in place either in the IO monad or in the ST monad. They fundamentally work the same way as mutable data structures in any other garbage collected language.<p>When I worked on a relatively simple simulation in Haskell, that&#x27;s exactly what I did: the individual entities were immutable, but the state of the system was stored in a mutable vector and updated in place. The actual &quot;loop&quot; of the simulation was a stream[2] of events, which is what managed the actual IO effect.<p>My favorite aspect of designing the system in Haskell was that I could separate out the core logic of the simulation which could mutate the state on each event from observers which could only <i>read</i> the state on events. This separation between logic and pure metrics made the code much easier to maintain, especially since most of the business needs and complexity ended up being in the metrics rather than the core simulation dynamics. (Not to say that this would always be the case, that&#x27;s just what happened for this specific supply chain domain.)<p>Looking back, if I were going to write a more complex performance-sensitive simulation, I&#x27;d probably end up with state stored in a bunch of different mutable arrays, which sounds a lot like an ECS. Doing that with base Haskell would be <i>really</i> awkward, but luckily Haskell is expressive enough that you can build a legitimately nice interface on top of the low-level mutable code. I haven&#x27;t used it but I imagine that&#x27;s exactly what apces[3] does and that&#x27;s where I&#x27;d start if I were writing a similar sort of simulation today, but, who knows, sometimes it&#x27;s straight-up faster to write your own abstractions instead...<p>[1]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;vector-0.13.1.0&#x2F;docs&#x2F;Data-Vector-Mutable.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;vector-0.13.1.0&#x2F;docs&#x2F;Dat...</a><p>[2]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;streaming" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;streaming</a><p>[3]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;apecs" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;apecs</a></div><br/><div id="41526265" class="c"><input type="checkbox" id="c-41526265" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#41519451">root</a><span>|</span><a href="#41519581">parent</a><span>|</span><a href="#41521208">next</a><span>|</span><label class="collapse" for="c-41526265">[-]</label><label class="expand" for="c-41526265">[1 more]</label></div><br/><div class="children"><div class="content">apecs is really nice! it&#x27;s not without its issues, but it really is a sweet library. and some of its issues are arguably just issues with ECS than apecs itself.</div><br/></div></div></div></div><div id="41521208" class="c"><input type="checkbox" id="c-41521208" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41519581">prev</a><span>|</span><a href="#41519591">next</a><span>|</span><label class="collapse" for="c-41521208">[-]</label><label class="expand" for="c-41521208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My question for Haskellers is how to do updates of values on a large scale, let&#x27;s say in a simulation.<p>The same way games do it.  The whole world, one frame at a time.  If you are simulating objects affected by gravity, you <i>do not</i> recalculate the position of each item in-place before moving onto the next item.  You figure out <i>all</i> the new accelerations, velocities and positions, and then apply them all.</div><br/></div></div><div id="41519591" class="c"><input type="checkbox" id="c-41519591" checked=""/><div class="controls bullet"><span class="by">icrbow</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41521208">prev</a><span>|</span><a href="#41526252">next</a><span>|</span><label class="collapse" for="c-41519591">[-]</label><label class="expand" for="c-41519591">[2 more]</label></div><br/><div class="children"><div class="content">&gt; does Haskell have a special construct that allows for values to be overwritten<p>Yes and no.<p>No, the <i>language</i> doesn&#x27;t have a special construct.
Yes, there are all kinds of mutable values for different usage patterns and restrictions.<p>Most likely you end up with mutable containers with some space reserved for entity state.<p>You can start with putting `IORef EntityState` as a field and let the `update` write there. Or multiple fields for state sub-parts that mutate at different rates.
The next step is putting all entity state into big blobs of data and let entities keep an index to their stuff inside that big blob.
If your entities are a mishmash of data, then there&#x27;s `apecs`, ECS library that will do it in AoS way. It even can do concurrent updates in STM if you need that.<p>Going further, there&#x27;s `massiv` library with integrated task supervisor and `repa`&#x2F;`accelerate` that can produce even faster kernels.
Finally, you can have your happy Haskell glue code and offload all the difficult work to GPU with `vulkan` compute.</div><br/><div id="41522767" class="c"><input type="checkbox" id="c-41522767" checked=""/><div class="controls bullet"><span class="by">icrbow</span><span>|</span><a href="#41519451">root</a><span>|</span><a href="#41519591">parent</a><span>|</span><a href="#41526252">next</a><span>|</span><label class="collapse" for="c-41522767">[-]</label><label class="expand" for="c-41522767">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ECS library that will do it in AoS way<p>TLAs aren&#x27;t my forte. It&#x27;s SoA of course.</div><br/></div></div></div></div><div id="41526252" class="c"><input type="checkbox" id="c-41526252" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41519591">prev</a><span>|</span><a href="#41520654">next</a><span>|</span><label class="collapse" for="c-41526252">[-]</label><label class="expand" for="c-41526252">[1 more]</label></div><br/><div class="children"><div class="content">You can use apecs, a pretty-fast Haskell ECS for those sorts of things.</div><br/></div></div><div id="41520654" class="c"><input type="checkbox" id="c-41520654" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41526252">prev</a><span>|</span><a href="#41519492">next</a><span>|</span><label class="collapse" for="c-41520654">[-]</label><label class="expand" for="c-41520654">[1 more]</label></div><br/><div class="children"><div class="content">Well what kind of values and how many updates?  You might have to call an external library to get decent performance, like you would use NumPy in Python.  This might be of interest: <a href="https:&#x2F;&#x2F;www.acceleratehs.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.acceleratehs.org&#x2F;</a></div><br/></div></div><div id="41519492" class="c"><input type="checkbox" id="c-41519492" checked=""/><div class="controls bullet"><span class="by">gspr</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41520654">prev</a><span>|</span><a href="#41522686">next</a><span>|</span><label class="collapse" for="c-41519492">[-]</label><label class="expand" for="c-41519492">[1 more]</label></div><br/><div class="children"><div class="content">Use the ST monad? :)</div><br/></div></div><div id="41522686" class="c"><input type="checkbox" id="c-41522686" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41519451">parent</a><span>|</span><a href="#41519492">prev</a><span>|</span><a href="#41519694">next</a><span>|</span><label class="collapse" for="c-41522686">[-]</label><label class="expand" for="c-41522686">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why you hate the IO monad so much. I mean I&#x27;ve seen very large codebases doing web apps and almost everything is inside the IO monad. It&#x27;s not as &quot;clean&quot; and not following best practices, but still gets the job done and is convenient. Having pervasive access to IO is just the norm in all other languages so it&#x27;s not even a drawback.<p>But let&#x27;s put that aside. You can instead use the ST monad (not to be confused with the State monad) and get the same performance benefit of in-place update of values.</div><br/></div></div></div></div><div id="41519694" class="c"><input type="checkbox" id="c-41519694" checked=""/><div class="controls bullet"><span class="by">maleldil</span><span>|</span><a href="#41519451">prev</a><span>|</span><a href="#41520998">next</a><span>|</span><label class="collapse" for="c-41519694">[-]</label><label class="expand" for="c-41519694">[14 more]</label></div><br/><div class="children"><div class="content">I feel like part of the problem is Haskell&#x27;s extremism towards purity and immutability. I find some code easier to express with procedural&#x2F;mutable loops than recursion, and I believe the vast majority of programmers. I think that one thing that makes Rust so successful is its capable type of system and use of many functional idioms, but you can use loops and mutability when it&#x27;s more comfortable. And of course, the borrow checker to ensure that such mutability is sound.</div><br/><div id="41529119" class="c"><input type="checkbox" id="c-41529119" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41520566">next</a><span>|</span><label class="collapse" for="c-41529119">[-]</label><label class="expand" for="c-41529119">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find some code easier to express with procedural&#x2F;mutable loops than recursion<p>Do you mean like this example of calculating the 5th triangular number with a procedural loop and mutable state?  Haskell supports them just fine!<p><a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin-0.0.7.0&#x2F;docs&#x2F;Bluefin-Jump.html#v:jumpTo" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin-0.0.7.0&#x2F;docs&#x2F;Blu...</a></div><br/></div></div><div id="41520566" class="c"><input type="checkbox" id="c-41520566" checked=""/><div class="controls bullet"><span class="by">enugu</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41529119">prev</a><span>|</span><a href="#41520379">next</a><span>|</span><label class="collapse" for="c-41520566">[-]</label><label class="expand" for="c-41520566">[1 more]</label></div><br/><div class="children"><div class="content">Haskell doesn&#x27;t stop you from mutation, it just makes you explicitly mark  it, like types of inputs&#x2F;output are explicit in statically typed languages instead of being implicit or borrowing is explicit in Rust.<p>Mutations becomes first class values like numbers or arays, and hence can be primitives for more complex mutations,  whose types can be inferred from the types of primitive mutations.<p>This means that the we have compile time guarantees that certain piece of code wont change anything in certain part of the state - This function wont change anything in that part of the data.<p>It is no joke, though not strictly true, that Haskell has been called the world&#x27;s best imperative language.</div><br/></div></div><div id="41520379" class="c"><input type="checkbox" id="c-41520379" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41520566">prev</a><span>|</span><a href="#41521145">next</a><span>|</span><label class="collapse" for="c-41520379">[-]</label><label class="expand" for="c-41520379">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find some code easier to express with procedural&#x2F;mutable loops than recursion, and I believe the vast majority of programmers<p>I think this comes from early and continuous exposure to some forms of programming, rather than inherent to pure functional programming.<p>I personally find it much easier to use recursion and other functional techniques because it composes better. This probable comes from my exposure to Haskell much earlier than most.</div><br/></div></div><div id="41521145" class="c"><input type="checkbox" id="c-41521145" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41520379">prev</a><span>|</span><a href="#41519835">next</a><span>|</span><label class="collapse" for="c-41521145">[-]</label><label class="expand" for="c-41521145">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find some code easier to express with procedural&#x2F;mutable loops than recursion<p>This is what I was talking about in the section &quot;Unlearning and relearning&quot;. While there are _some_ domains (like embedded systems) for which Haskell is a poor fit, a lot of the difficulties people have with it (and with FP in general) is that they have been heavily educated to think in a particular way about computation. That&#x27;s an accident of history, rather than any fundamental issue with the programming paradigm.</div><br/></div></div><div id="41519835" class="c"><input type="checkbox" id="c-41519835" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41521145">prev</a><span>|</span><a href="#41521728">next</a><span>|</span><label class="collapse" for="c-41519835">[-]</label><label class="expand" for="c-41519835">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a problem no haskell user has, honestly. Your issue seems to be about getting your feet wet. Could you imagine people saying the issue with Java is its extremism towards objects and method calls?<p>Sure, a determined Fortran programmer can write Fortran in any language, but if they have trouble doing so, maybe the issue isn&#x27;t the language.</div><br/><div id="41520282" class="c"><input type="checkbox" id="c-41520282" checked=""/><div class="controls bullet"><span class="by">bedman12345</span><span>|</span><a href="#41519694">root</a><span>|</span><a href="#41519835">parent</a><span>|</span><a href="#41520360">next</a><span>|</span><label class="collapse" for="c-41520282">[-]</label><label class="expand" for="c-41520282">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Could you imagine people saying the issue with Java is its extremism towards objects and method calls?<p>I think exactly that all the time. It’s ridiculous.<p>&gt; That&#x27;s a problem no haskell user has, honestly.<p>I had this problem all the time when trying to write games in Haskell. Not every subject matter decomposes into semirings. Just like not everything decomposes nicely into objects.
People tried to fix this with FRP or lenses. Both are worse than imperative programming for games imo.</div><br/></div></div><div id="41520360" class="c"><input type="checkbox" id="c-41520360" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#41519694">root</a><span>|</span><a href="#41519835">parent</a><span>|</span><a href="#41520282">prev</a><span>|</span><a href="#41521110">next</a><span>|</span><label class="collapse" for="c-41520360">[-]</label><label class="expand" for="c-41520360">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s a problem no haskell user has, honestly.<p>In a sense, that&#x27;s true: people who do have this trouble constantly (e.g. me) very quickly cease being Haskell users. But that&#x27;s hardly an argument for TFA&#x27;s claim that &quot;Haskell is probably the best choice for most programmers, especially if one cares about being able to productively write robust software, and even more so if one wants to have fun while doing it&quot;; if anything, it&#x27;s a counter-argument.</div><br/></div></div><div id="41521110" class="c"><input type="checkbox" id="c-41521110" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41519694">root</a><span>|</span><a href="#41519835">parent</a><span>|</span><a href="#41520360">prev</a><span>|</span><a href="#41520808">next</a><span>|</span><label class="collapse" for="c-41521110">[-]</label><label class="expand" for="c-41521110">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Could you imagine people saying the issue with Java is its extremism towards objects and method calls?<p>&quot;Execution in the Kingdom of Nouns&quot; comes to mind.<p><a href="https:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2006&#x2F;03&#x2F;execution-in-kingdom-of-nouns.html" rel="nofollow">https:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2006&#x2F;03&#x2F;execution-in-kingdo...</a></div><br/></div></div></div></div><div id="41521728" class="c"><input type="checkbox" id="c-41521728" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41519835">prev</a><span>|</span><a href="#41520495">next</a><span>|</span><label class="collapse" for="c-41521728">[-]</label><label class="expand" for="c-41521728">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I feel like part of the problem is Haskell&#x27;s extremism towards purity and immutability<p>Eh. Elm has achieved quite a bit of success just by having good tooling and a good ecosystem. Says something about people&#x27;s willingness to learn pure functional programming, if the situation is right.<p>&gt; I find some code easier to express with procedural&#x2F;mutable loops than recursion<p>This is usually a familiarity problem, IMO.<p>I often say: people think mastering Haskell is about mastering monads. But it&#x27;s actually about mastering folds.</div><br/><div id="41522574" class="c"><input type="checkbox" id="c-41522574" checked=""/><div class="controls bullet"><span class="by">1-more</span><span>|</span><a href="#41519694">root</a><span>|</span><a href="#41521728">parent</a><span>|</span><a href="#41520495">next</a><span>|</span><label class="collapse" for="c-41522574">[-]</label><label class="expand" for="c-41522574">[1 more]</label></div><br/><div class="children"><div class="content">the best intro to writing Haskell for me was writing Elm. The best intro to writing Elm was writing pointfree Codewars kata solutions in JS using<p><pre><code>    with(require(&quot;ramda&quot;)) fn = pipe(…)
</code></pre>
And yep, you end up with a lot of folds (well, reduces) where that ellipsis is. Or related functions that are really folds.<p>For those wondering `with` in JS is a bit like `extract` in PHP except it creates a new context right after itself rather than modify the context it finds itself in. It&#x27;s super deprecated because it&#x27;s inscrutable and silly except in this case and&#x2F;or when you need to solve Codewars katas in a limited number of characters.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;with" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p><a href="https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;function.extract.php" rel="nofollow">https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;function.extract.php</a><p>EDIT ramda is a nice utility library in JS that supports partial application of arguments in arbitrary order <a href="https:&#x2F;&#x2F;ramdajs.com&#x2F;docs&#x2F;#subtract" rel="nofollow">https:&#x2F;&#x2F;ramdajs.com&#x2F;docs&#x2F;#subtract</a></div><br/></div></div></div></div><div id="41520495" class="c"><input type="checkbox" id="c-41520495" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41521728">prev</a><span>|</span><a href="#41520240">next</a><span>|</span><label class="collapse" for="c-41520495">[-]</label><label class="expand" for="c-41520495">[1 more]</label></div><br/><div class="children"><div class="content">This has been researched. If you were educated with FP-langs first, you&#x27;d say it&#x27;s harder &quot;to express with procedural&#x2F;mutable loops&quot;.<p>&gt; I believe the vast majority of programmers.<p>Yups. We get educated with imperative langs. The majority of us do.</div><br/></div></div><div id="41520240" class="c"><input type="checkbox" id="c-41520240" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41519694">parent</a><span>|</span><a href="#41520495">prev</a><span>|</span><a href="#41520998">next</a><span>|</span><label class="collapse" for="c-41520240">[-]</label><label class="expand" for="c-41520240">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I feel like part of the problem is Haskell&#x27;s extremism towards purity and immutability</i><p>You missed &quot;lazy evaluation by default&quot; in that list ;) Those properties are kind of the definition of Haskell, so without all of them you&#x27;d have another language.<p>Like the sibling commenter mentions, this seems more of a &quot;I&#x27;m unfamiliar with this&quot; thing rather than a problem with Haskell...</div><br/></div></div></div></div><div id="41520998" class="c"><input type="checkbox" id="c-41520998" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41519694">prev</a><span>|</span><a href="#41521764">next</a><span>|</span><label class="collapse" for="c-41520998">[-]</label><label class="expand" for="c-41520998">[27 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really good for <i>boring, line of business software</i> (BLOBS).<p>The vast majority of business logic can be modelled with a handful of simple types and pattern matching. Very few design patterns are needed. And if you keep to the simple parts you can even teach the syntax (just the types) to non-technical contributors in an afternoon. Then they can read it and help verify that you implemented the business process correctly.<p>It&#x27;s also just nice for how my brain works. I like being able to substitute terms and get an equivalent program. Or that I can remember a handful of transformation rules that often get me from a first cut of a program to an efficient, fast one.<p>And it&#x27;s just fun.</div><br/><div id="41521323" class="c"><input type="checkbox" id="c-41521323" checked=""/><div class="controls bullet"><span class="by">mumblemumble</span><span>|</span><a href="#41520998">parent</a><span>|</span><a href="#41521434">next</a><span>|</span><label class="collapse" for="c-41521323">[-]</label><label class="expand" for="c-41521323">[9 more]</label></div><br/><div class="children"><div class="content">It is. But I think that, for that purpose, I like F# even better. Even beyond getting access to the .NET ecosystem, you also get some language design decisions that were specifically meant to make it easier to maintain large codebases that are shared among developers with varying skill levels.<p>Lack of typeclasses is a good example. Interface inheritance isn&#x27;t my favorite, but after years working as the technical lead on a Scala project I&#x27;ve been forced to concede that haranguing people who just want to do their job and go home to their family about how to use them properly isn&#x27;t a good use of anyone&#x27;s time. Everyone comes out of school already knowing how to use interfaces and parametric polymorphism, and that is <i>fine</i>.</div><br/><div id="41521465" class="c"><input type="checkbox" id="c-41521465" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521323">parent</a><span>|</span><a href="#41521499">next</a><span>|</span><label class="collapse" for="c-41521465">[-]</label><label class="expand" for="c-41521465">[3 more]</label></div><br/><div class="children"><div class="content">I adore Scott Wlaschin&#x27;s work [0] -- that&#x27;s where I picked up on the acronym, BLOBS! F# is super cool, I agree.<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Up7LcbGZFuo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Up7LcbGZFuo</a></div><br/><div id="41521559" class="c"><input type="checkbox" id="c-41521559" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521465">parent</a><span>|</span><a href="#41521499">next</a><span>|</span><label class="collapse" for="c-41521559">[-]</label><label class="expand" for="c-41521559">[2 more]</label></div><br/><div class="children"><div class="content">His book Domain Driven Design Made Functional is really good. It really opened my eyes on DDD.</div><br/><div id="41522007" class="c"><input type="checkbox" id="c-41522007" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521559">parent</a><span>|</span><a href="#41521499">next</a><span>|</span><label class="collapse" for="c-41522007">[-]</label><label class="expand" for="c-41522007">[1 more]</label></div><br/><div class="children"><div class="content">A book I find truly wonderful!  If I was going to recommend one book about how to design software, it would be this one.</div><br/></div></div></div></div></div></div><div id="41521499" class="c"><input type="checkbox" id="c-41521499" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521323">parent</a><span>|</span><a href="#41521465">prev</a><span>|</span><a href="#41521434">next</a><span>|</span><label class="collapse" for="c-41521499">[-]</label><label class="expand" for="c-41521499">[5 more]</label></div><br/><div class="children"><div class="content">Anecdotally, the handful of people I&#x27;ve known that worked in commercial Haskell shops, after the initial honeymoon period intensified by <i>actually finding a paying Haskell dev job</i>, wishes they were using a more practical &quot;happy medium&quot; FP language. I don&#x27;t know anyone that&#x27;s used F# in production, but nobody I know that&#x27;s worked in Elixir, erlang, or elm environments has expressed the same frustration.</div><br/><div id="41521584" class="c"><input type="checkbox" id="c-41521584" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521499">parent</a><span>|</span><a href="#41522463">next</a><span>|</span><label class="collapse" for="c-41521584">[-]</label><label class="expand" for="c-41521584">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. I wonder where you met them.  I&#x27;ve worked with tens of Haskell programmers in my career, most of whom were sad if they were required to stop working in Haskell.  I&#x27;ve never met anyone who actively sought out a Haskell job and then subsequently wanted to stop working in Haskell.</div><br/><div id="41526309" class="c"><input type="checkbox" id="c-41526309" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521584">parent</a><span>|</span><a href="#41522463">next</a><span>|</span><label class="collapse" for="c-41526309">[-]</label><label class="expand" for="c-41526309">[1 more]</label></div><br/><div class="children"><div class="content">Your sample size sounds much bigger than mine.</div><br/></div></div></div></div><div id="41522463" class="c"><input type="checkbox" id="c-41522463" checked=""/><div class="controls bullet"><span class="by">1-more</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521499">parent</a><span>|</span><a href="#41521584">prev</a><span>|</span><a href="#41521843">next</a><span>|</span><label class="collapse" for="c-41522463">[-]</label><label class="expand" for="c-41522463">[1 more]</label></div><br/><div class="children"><div class="content">Many of my colleagues would describe themselves as taking pay cuts to write Haskell provisioned with Nix with type-safe interop with Ruby and our frontend. If you&#x27;re into it, you&#x27;re into it. And it has the effect of putting absolute mutants on your team.</div><br/></div></div><div id="41521843" class="c"><input type="checkbox" id="c-41521843" checked=""/><div class="controls bullet"><span class="by">IWeldMelons</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521499">parent</a><span>|</span><a href="#41522463">prev</a><span>|</span><a href="#41521434">next</a><span>|</span><label class="collapse" for="c-41521843">[-]</label><label class="expand" for="c-41521843">[1 more]</label></div><br/><div class="children"><div class="content">Jane Street famously uses Ocaml, which is, granred, not F# but closee enough&#x2F;</div><br/></div></div></div></div></div></div><div id="41521434" class="c"><input type="checkbox" id="c-41521434" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#41520998">parent</a><span>|</span><a href="#41521323">prev</a><span>|</span><a href="#41521365">next</a><span>|</span><label class="collapse" for="c-41521434">[-]</label><label class="expand" for="c-41521434">[10 more]</label></div><br/><div class="children"><div class="content">Only on HN will you read someone unironically suggest writing LOB software in Haskell.</div><br/><div id="41521830" class="c"><input type="checkbox" id="c-41521830" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521434">parent</a><span>|</span><a href="#41521565">next</a><span>|</span><label class="collapse" for="c-41521830">[-]</label><label class="expand" for="c-41521830">[1 more]</label></div><br/><div class="children"><div class="content">I am not prepared to hunt down the citation, but several years back I stumbled across a paper that was trying to compare the effectiveness of various languages for grinding out &quot;domain logic-y&quot; code. Among the ones they evaluated, Haskell came out on top in terms of both time to get the work done and correctness of the implementation.<p>IIRC this was testing with students, which would be both a strength and a weakness of the experimental design.</div><br/></div></div><div id="41521565" class="c"><input type="checkbox" id="c-41521565" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521434">parent</a><span>|</span><a href="#41521830">prev</a><span>|</span><a href="#41521812">next</a><span>|</span><label class="collapse" for="c-41521565">[-]</label><label class="expand" for="c-41521565">[6 more]</label></div><br/><div class="children"><div class="content">Why not? Many of us do it every day.</div><br/><div id="41521662" class="c"><input type="checkbox" id="c-41521662" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521565">parent</a><span>|</span><a href="#41521812">next</a><span>|</span><label class="collapse" for="c-41521662">[-]</label><label class="expand" for="c-41521662">[5 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s suppose that you and I are non-technical founders of some medium-size software product.<p>If we were to rank the most important factors in choosing how to build our product, I think we may be able to agree that they&#x27;re likely:<p>- The talent pool and availability of the language<p>- The ecosystem of libraries and ancillary tools like monitoring&#x2F;debugging&#x2F;observability<p>- The speed-of-development vs cost-of-maintenance tradeoff of the language<p>I will give Haskell that it can be rapidly written by those proficient, and tends to have less bugs if it compiles than many languages.<p>But for &quot;what language is easy to employ and has an expansive ecosystem + tooling&quot;, I feel like you have to hand it to Java, .NET, Python, TypeScript, Go, etc...</div><br/><div id="41521839" class="c"><input type="checkbox" id="c-41521839" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521662">parent</a><span>|</span><a href="#41522014">next</a><span>|</span><label class="collapse" for="c-41521839">[-]</label><label class="expand" for="c-41521839">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s shifting the goalposts somewhat!  Can Haskell be used for LOB software.  Yes! In fact it&#x27;s the one I am most effective in for that purpose.  If I was starting a startup, it would be in Haskell, no question. &quot;Let&#x27;s suppose that you and I are non-technical founders of some medium-size software product ...&quot;  Well, that&#x27;s something else entirely.</div><br/></div></div><div id="41522014" class="c"><input type="checkbox" id="c-41522014" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521662">parent</a><span>|</span><a href="#41521839">prev</a><span>|</span><a href="#41521950">next</a><span>|</span><label class="collapse" for="c-41522014">[-]</label><label class="expand" for="c-41522014">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re taking a particular view of things that can work, but it&#x27;s not the only correct view.<p>&gt; The talent pool and availability of the language<p>There are certainly more Javascript or Python developers out there than Haskell developers, but I think it&#x27;s wrong to imply that Haskell is a hard language to hire for. There are more people out there who want to work with Haskell than there are Haskell jobs, and picking Haskell can be a really great way to recruit high quality talent. It&#x27;s also quite possible to train developers on Haskell. A lot of companies hire people who don&#x27;t have experience with their particular language. The learning curve for Haskell may be a bit steeper, but it&#x27;s certainly tractable if you are hiring people who are eager to learn.<p>&gt; The ecosystem of libraries and ancillary tools like monitoring&#x2F;debugging&#x2F;observability<p>Other languages have _more_ of these, but it&#x27;s not like Haskell is missing basic ecosystem things. I actually find that Haskell is pretty nice with this stuff overall. It&#x27;s not quite as automatic as what you might get with running something in the JVM, but it&#x27;s not that big of a lift, and for a lot of teams the marginal extra effort here is more than worth it because of the other benefits you get from Haskell.<p>&gt; The speed-of-development vs cost-of-maintenance tradeoff of the language<p>Haskell is really excellent here in my experience. You can write unmaintainable code in any language, but Haskell gives you a lot of choice in how you build your application, and it makes refactoring a lot nicer than in any other language I&#x27;ve used. You don&#x27;t get some of the nice IDE features to rename things or move code around automatically, but working in a large Haskell codebase you really do start to see ways that the language makes structural and architectural refactoring a lot easier.<p>&gt; But for &quot;what language is easy to employ and has an expansive ecosystem + tooling&quot;, I feel like you have to hand it to Java, .NET, Python, TypeScript, Go, etc...<p>Those are all perfectly good choices. I think what people tend to overlook is that Haskell is _also_ a perfectly good choice. Everything has tradeoffs, but Haskell isn&#x27;t some terrible esoteric choice that forces you to leave everything practical on the table. It really is useful day to day as a general purpose language.</div><br/></div></div><div id="41521950" class="c"><input type="checkbox" id="c-41521950" checked=""/><div class="controls bullet"><span class="by">mchaver</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521662">parent</a><span>|</span><a href="#41522014">prev</a><span>|</span><a href="#41521985">next</a><span>|</span><label class="collapse" for="c-41521950">[-]</label><label class="expand" for="c-41521950">[1 more]</label></div><br/><div class="children"><div class="content">I am unironically being paid to do it!<p>My experience is Haskell is one of those ecosystems that has a greater talent pool than there are available positions. I feel like cost of maintenance is pretty nice because you have less bugs. You may have to roll up your sleeves and get your hands dirty to update open source libraries or make stuff that is missing, but code reliability seems to be worth it.</div><br/></div></div></div></div></div></div><div id="41521812" class="c"><input type="checkbox" id="c-41521812" checked=""/><div class="controls bullet"><span class="by">jose_zap</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521434">parent</a><span>|</span><a href="#41521565">prev</a><span>|</span><a href="#41521904">next</a><span>|</span><label class="collapse" for="c-41521812">[-]</label><label class="expand" for="c-41521812">[1 more]</label></div><br/><div class="children"><div class="content">We do that at our company, it&#x27;s been great</div><br/></div></div><div id="41521904" class="c"><input type="checkbox" id="c-41521904" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521434">parent</a><span>|</span><a href="#41521812">prev</a><span>|</span><a href="#41521365">next</a><span>|</span><label class="collapse" for="c-41521904">[-]</label><label class="expand" for="c-41521904">[1 more]</label></div><br/><div class="children"><div class="content">Not just HN, Cardano&#x27;s smart contract language, Plutus, is based on Haskell.</div><br/></div></div></div></div><div id="41521365" class="c"><input type="checkbox" id="c-41521365" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#41520998">parent</a><span>|</span><a href="#41521434">prev</a><span>|</span><a href="#41521818">next</a><span>|</span><label class="collapse" for="c-41521365">[-]</label><label class="expand" for="c-41521365">[4 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s what you&#x27;re looking for, why not rip out most of the language? You&#x27;ll end up with something that looks a lot like Elm. You&#x27;ll end up with a purely deterministic program with no i&#x2F;o (albeit with a kind of crappy debugging experience).</div><br/><div id="41521446" class="c"><input type="checkbox" id="c-41521446" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521365">parent</a><span>|</span><a href="#41521818">next</a><span>|</span><label class="collapse" for="c-41521446">[-]</label><label class="expand" for="c-41521446">[3 more]</label></div><br/><div class="children"><div class="content">Well because you need the rest of the language to make your program tell your system to do stuff.<p>Turns out `IO` is the most essential and useful bit of a Haskell program. That part can be left to the programmers. Haskell has a lot of facilities for making that nicer to work with as well.<p>I find that when I tell folks I work in Haskell full-time you can see their opinion of you change on their face. I&#x27;m not some kind of PhD genius programmer. I&#x27;m pretty middle-of-the-road to be honest.<p>It&#x27;s just nice to have a language that makes the work of writing BLOBS straight-forward.</div><br/><div id="41521717" class="c"><input type="checkbox" id="c-41521717" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521446">parent</a><span>|</span><a href="#41521818">next</a><span>|</span><label class="collapse" for="c-41521717">[-]</label><label class="expand" for="c-41521717">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Well because you need the rest of the language to make your program tell your system to do stuff.<p>That&#x27;s not necessary for business logic, though. This would presumably be embedded in infrastructure that handled i&#x2F;o separately.</div><br/><div id="41522053" class="c"><input type="checkbox" id="c-41522053" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521717">parent</a><span>|</span><a href="#41521818">next</a><span>|</span><label class="collapse" for="c-41522053">[-]</label><label class="expand" for="c-41522053">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard of systems like Roc + Nea taking this to the extreme [0]. Totally a way to go.<p>Haskell, to some extent, can help you structure your program in this way where the business logic is just simple, plain, old functional code. You can write the data marshalling, logging, and networking layers separately. There are a few ways to tackle that in Haskell in varying levels of complexity as you would expect coming from other general-purpose programming languages.<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zMRfCZo8eAc&amp;t=952s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zMRfCZo8eAc&amp;t=952s</a></div><br/></div></div></div></div></div></div></div></div><div id="41521818" class="c"><input type="checkbox" id="c-41521818" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41520998">parent</a><span>|</span><a href="#41521365">prev</a><span>|</span><a href="#41521933">next</a><span>|</span><label class="collapse" for="c-41521818">[-]</label><label class="expand" for="c-41521818">[2 more]</label></div><br/><div class="children"><div class="content">Haskell is just hard when you get to the advanced stuff. I mean beyond monads there’s the state monad, lenses, etc. a lot of these are not trivial to wrap your brain around. Like for Java head first design patterns I read it and I’m good. For monads it took me weeks to wrap my head around it and I still don’t understand every monad.<p>Yeah I get a bunch of basic apps can be modeled easily, you get unparalleled static safety but programmers will spend an inordinate amount of time figuring out mind bending algebraic patterns.<p>I think something like ocaml or f sharp are more down to earth.</div><br/><div id="41522220" class="c"><input type="checkbox" id="c-41522220" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#41520998">root</a><span>|</span><a href="#41521818">parent</a><span>|</span><a href="#41521933">next</a><span>|</span><label class="collapse" for="c-41522220">[-]</label><label class="expand" for="c-41522220">[1 more]</label></div><br/><div class="children"><div class="content">The advanced parts of most languages can get hairy. Don&#x27;t mistake familiarity with complexity. Even Java has hard, dense code that is difficult to work with and learn.<p>I tend to stay away from the advanced parts of Haskell when writing BLOBS.<p>The advanced stuff is there when you need to write libraries that need generic code that works with types you haven&#x27;t defined yourself. You learn it as you go when you need to.<p>But when I&#x27;m writing BLOBS I mostly stick to using libraries and that&#x27;s pretty straight-forward.</div><br/></div></div></div></div></div></div><div id="41521764" class="c"><input type="checkbox" id="c-41521764" checked=""/><div class="controls bullet"><span class="by">reidrac</span><span>|</span><a href="#41520998">prev</a><span>|</span><a href="#41519720">next</a><span>|</span><label class="collapse" for="c-41521764">[-]</label><label class="expand" for="c-41521764">[2 more]</label></div><br/><div class="children"><div class="content">I like haskell. Actually, let me rephrase that: I like GHC2021.<p>And I have found that&#x27;s one of the tricky bits with Haskell, together with the language being in very active development, wich makes upgrading your compiler a thing.</div><br/><div id="41528921" class="c"><input type="checkbox" id="c-41528921" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41521764">parent</a><span>|</span><a href="#41519720">next</a><span>|</span><label class="collapse" for="c-41528921">[-]</label><label class="expand" for="c-41528921">[1 more]</label></div><br/><div class="children"><div class="content">Actually, changes to the compiler hardly ever break anything.  I recently upgraded four compiler versions in a row and apart from a bug and some warnings the compiler didn&#x27;t force any changes at all. It&#x27;s primarily changes to libraries that introduce churn.<p><a href="https:&#x2F;&#x2F;h2.jaguarpaw.co.uk&#x2F;posts&#x2F;ghc-8.10-9.6-experience-report&#x2F;" rel="nofollow">https:&#x2F;&#x2F;h2.jaguarpaw.co.uk&#x2F;posts&#x2F;ghc-8.10-9.6-experience-rep...</a><p>(DeepSubsumption wouldn&#x27;t have been a problem if we&#x27;d specified Haskell2010, as we should have.)</div><br/></div></div></div></div><div id="41519720" class="c"><input type="checkbox" id="c-41519720" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#41521764">prev</a><span>|</span><a href="#41523476">next</a><span>|</span><label class="collapse" for="c-41519720">[-]</label><label class="expand" for="c-41519720">[7 more]</label></div><br/><div class="children"><div class="content">My biggest gripe with Haskell, especially when dealing with lower level code, is that there is no implicit enforcement of dealing with error states. I like golang far more in this regard. All of the “if error” guards may be ugly but they sure impose a culture of dealing with problems that will arise.<p>I’ve come across plenty of Haskell code that just expects a happy path all of the time and can’t deal with any other situation. That’s great for POC work but horrible in production.</div><br/><div id="41519799" class="c"><input type="checkbox" id="c-41519799" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519720">parent</a><span>|</span><a href="#41519790">next</a><span>|</span><label class="collapse" for="c-41519799">[-]</label><label class="expand" for="c-41519799">[5 more]</label></div><br/><div class="children"><div class="content">I write about this at some length in the essay, perhaps you can help me by telling me why the section on &quot;Make fewer mistakes&quot; _doesn&#x27;t_ satisfy?</div><br/><div id="41522913" class="c"><input type="checkbox" id="c-41522913" checked=""/><div class="controls bullet"><span class="by">YuukiRey</span><span>|</span><a href="#41519720">root</a><span>|</span><a href="#41519799">parent</a><span>|</span><a href="#41520058">next</a><span>|</span><label class="collapse" for="c-41522913">[-]</label><label class="expand" for="c-41522913">[3 more]</label></div><br/><div class="children"><div class="content">You wrote<p>&gt; Haskell solves the problem of the representation of computations which may fail very differently: explicitly through the type system.<p>In my experience this is very hit and miss. Some libraries use exceptions for lots of error states that in Go would be a returned error value. I&#x27;m therefore left to decipher the docs (which are often incomplete) to understand which exceptions I can except and why and when.<p>Last library I remember is <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;modern-uri" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;modern-uri</a><p>From their docs:
&gt; If the argument of mkURI is not a valid URI, then an exception will be thrown. The exception will contain full context and the actual parse error.<p>The pit of success would be if every function that can fail because of something reasonable (such as a URI parser for user supplied input) makes it a compile time message (warning, error, whatever you prefer) if I fail to consider the error case. But there&#x27;s nothing that warns me if I fail to catch an exception, so in the end, in spite of all of Haskell&#x27;s fancy type machinery, in this case, I&#x27;m worse off than in Golang.</div><br/><div id="41529301" class="c"><input type="checkbox" id="c-41529301" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519720">root</a><span>|</span><a href="#41522913">parent</a><span>|</span><a href="#41529159">next</a><span>|</span><label class="collapse" for="c-41529301">[-]</label><label class="expand" for="c-41529301">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some libraries use exceptions for lots of error states that in Go would be a returned error value.<p>This just seems like bad libraries, I&#x27;d agree that this is bad and sort of defeats the point. I haven&#x27;t actually encountered this with any libraries I&#x27;ve used, and we tend to avoid MonadThrow &#x2F; Catch except in particular circumstances.<p>&gt; in this case, I&#x27;m worse off than in Golang.<p>Having (unfortunately) had to write some Golang, I don&#x27;t think this is true -- I&#x27;ve encountered plenty of code in Golang in which it seems idiomatic to return things like empty strings and empty objects instead of error values which, I think, it&#x27;s still possible to mishandle.<p>Perhaps this can be summarised as: you can still write bad Haskell, but I don&#x27;t think it&#x27;s particularly idiomatic looking at the libraries I&#x27;ve spent most of my time using, and the machinery you are provided allows you to do much, much better.</div><br/></div></div><div id="41529159" class="c"><input type="checkbox" id="c-41529159" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41519720">root</a><span>|</span><a href="#41522913">parent</a><span>|</span><a href="#41529301">prev</a><span>|</span><a href="#41520058">next</a><span>|</span><label class="collapse" for="c-41529159">[-]</label><label class="expand" for="c-41529159">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some libraries use exceptions for lots of error states that in Go would be a returned error value<p>Yes. This is a very very bad aspect of the design of many Haskell libraries.  They just throw away the whole point of doing Haskell.</div><br/></div></div></div></div><div id="41520058" class="c"><input type="checkbox" id="c-41520058" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#41519720">root</a><span>|</span><a href="#41519799">parent</a><span>|</span><a href="#41522913">prev</a><span>|</span><a href="#41519790">next</a><span>|</span><label class="collapse" for="c-41520058">[-]</label><label class="expand" for="c-41520058">[1 more]</label></div><br/><div class="children"><div class="content">I think one of the big takeaways from Haskell for me was that errors don&#x27;t always need to be explicitly handled. Sometimes returning a safe sentinel value is enough.<p>For example, if the function call returns some data collection, returning an empty collection can be a safe way to allow the program to continue in the case of something unexpected.  I don&#x27;t need to ABORT. I can let the program unwind naturally as all the code that would work on that collection would realise there&#x27;s nothing to do.<p>Debugging that can be a pain, but traces and logging tend to fix that.</div><br/></div></div></div></div><div id="41519790" class="c"><input type="checkbox" id="c-41519790" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#41519720">parent</a><span>|</span><a href="#41519799">prev</a><span>|</span><a href="#41523476">next</a><span>|</span><label class="collapse" for="c-41519790">[-]</label><label class="expand" for="c-41519790">[1 more]</label></div><br/><div class="children"><div class="content">And also horrible for the typical functional programmer that likes clever &quot;solutions&quot; but hates the &quot;boring&quot; parts of actual good software.</div><br/></div></div></div></div><div id="41523476" class="c"><input type="checkbox" id="c-41523476" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#41519720">prev</a><span>|</span><a href="#41519893">next</a><span>|</span><label class="collapse" for="c-41523476">[-]</label><label class="expand" for="c-41523476">[4 more]</label></div><br/><div class="children"><div class="content">in general, I am in favor of language features that make it easy to prove that common errors will not happen. Conversely, I am against language features that make it easy to make new classes of errors that are hard to reason about.<p>Haskell manages to do a <i>lot</i> of both. The kinds of problems I ran into in my Haskell error were much, much weirder than the problems I run into in other environments - things that when I explain them to other programmers <i>they often don&#x27;t even believe me.</i><p>On balance, for me, the new problems were worse than the old problems, but your mileage may vary.</div><br/><div id="41526940" class="c"><input type="checkbox" id="c-41526940" checked=""/><div class="controls bullet"><span class="by">alxmng</span><span>|</span><a href="#41523476">parent</a><span>|</span><a href="#41519893">next</a><span>|</span><label class="collapse" for="c-41526940">[-]</label><label class="expand" for="c-41526940">[3 more]</label></div><br/><div class="children"><div class="content">This is my experience as well. Referential transparency and immutability have many advantages, with few disadvantages (if any). Type checking is great as a way to enforce constraints. However, nominal types create unnecessary incompatibility and endless type shuffling every time you want to make even simple changes. I maintain a web app written in Haskell and there’s 3 or 4 different types for URLs in the codebase, even though there’s no real difference between them. Nominal typing is terrible for code reuse via third-party modules. So many hours wasted wrapping types or shuffling between them.<p>A functional language with a simple set of structural types would be the sweet spot for me. Clojure is probably the closest to this.</div><br/><div id="41528040" class="c"><input type="checkbox" id="c-41528040" checked=""/><div class="controls bullet"><span class="by">birdfood</span><span>|</span><a href="#41523476">root</a><span>|</span><a href="#41526940">parent</a><span>|</span><a href="#41528215">next</a><span>|</span><label class="collapse" for="c-41528040">[-]</label><label class="expand" for="c-41528040">[1 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;m at the same conclusion. I basically want ocaml but with structural &#x2F; compile time duck typing of all types (I know about objects but they don&#x27;t seem widely used). And some sort of reflection mechanism to cover 80% of the cases where you&#x27;d reach for ppx &#x2F; macros (i.e. database interface code gen of types).</div><br/></div></div><div id="41528215" class="c"><input type="checkbox" id="c-41528215" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#41523476">root</a><span>|</span><a href="#41526940">parent</a><span>|</span><a href="#41528040">prev</a><span>|</span><a href="#41519893">next</a><span>|</span><label class="collapse" for="c-41528215">[-]</label><label class="expand" for="c-41528215">[1 more]</label></div><br/><div class="children"><div class="content">What kinds of things led to multiple types of URL&#x27;s in the same codebase?</div><br/></div></div></div></div></div></div><div id="41519893" class="c"><input type="checkbox" id="c-41519893" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#41523476">prev</a><span>|</span><a href="#41525788">next</a><span>|</span><label class="collapse" for="c-41519893">[-]</label><label class="expand" for="c-41519893">[3 more]</label></div><br/><div class="children"><div class="content">Not a word about laziness? This is at this point the most interesting thing about Haskell. As many others have pointed out, the type system has hugely influenced other languages, but laziness by default, for everything, seems like an equally big deal, and equally hard to get one’s head around.</div><br/><div id="41526269" class="c"><input type="checkbox" id="c-41526269" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#41519893">parent</a><span>|</span><a href="#41521179">next</a><span>|</span><label class="collapse" for="c-41526269">[-]</label><label class="expand" for="c-41526269">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even notice the laziness most of the time. Even if you are benefiting from it.</div><br/></div></div><div id="41521179" class="c"><input type="checkbox" id="c-41521179" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519893">parent</a><span>|</span><a href="#41526269">prev</a><span>|</span><a href="#41525788">next</a><span>|</span><label class="collapse" for="c-41521179">[-]</label><label class="expand" for="c-41521179">[1 more]</label></div><br/><div class="children"><div class="content">Nope: I think the laziness aspect is very interesting, but it&#x27;s not something that makes Haskell (for me) a great programming language. Or, at least, it&#x27;s not in my list of the top reasons (it is in there somewhere).</div><br/></div></div></div></div><div id="41525788" class="c"><input type="checkbox" id="c-41525788" checked=""/><div class="controls bullet"><span class="by">hugodan</span><span>|</span><a href="#41519893">prev</a><span>|</span><a href="#41523477">next</a><span>|</span><label class="collapse" for="c-41525788">[-]</label><label class="expand" for="c-41525788">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll tell you why, it is simply the best refactoring experience out there. This.</div><br/></div></div><div id="41523477" class="c"><input type="checkbox" id="c-41523477" checked=""/><div class="controls bullet"><span class="by">me_vinayakakv</span><span>|</span><a href="#41525788">prev</a><span>|</span><a href="#41519348">next</a><span>|</span><label class="collapse" for="c-41523477">[-]</label><label class="expand" for="c-41523477">[8 more]</label></div><br/><div class="children"><div class="content">I was looking into the pattern matching example in the article with `Either` type. If we need to unwrap and check for all the cases one by one would it become a callback hell?<p>I was going through a Scala codebase at work that uses `Future`s and `map`ing and `flatMap`ing them. Sometimes the callbacks went 5-6 levels deep. Is there a way to &quot;linearlize&quot; such code?<p>I come from JS&#x2F;TS background and have not much experience with pufe functional languages. But I love how TS handles discriminated unions - if we handle a branch and `return` early, that branch is removed from the union for the subsequent scope, and I was wondering if something of that sort can be achieved in Haskell&#x2F;Scala.</div><br/><div id="41523926" class="c"><input type="checkbox" id="c-41523926" checked=""/><div class="controls bullet"><span class="by">TJSomething</span><span>|</span><a href="#41523477">parent</a><span>|</span><a href="#41523679">next</a><span>|</span><label class="collapse" for="c-41523926">[-]</label><label class="expand" for="c-41523926">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been out of the Scala game for a few years, but I would use a for comprehension with the cats EitherT monad transformer.<p><a href="https:&#x2F;&#x2F;typelevel.org&#x2F;cats&#x2F;datatypes&#x2F;eithert.html" rel="nofollow">https:&#x2F;&#x2F;typelevel.org&#x2F;cats&#x2F;datatypes&#x2F;eithert.html</a><p><pre><code>    def divisionProgramAsync(inputA: String, inputB: String): EitherT[Future, String, Double] =
      for {
        a &lt;- EitherT(parseDoubleAsync(inputA))
        b &lt;- EitherT(parseDoubleAsync(inputB))
        result &lt;- EitherT(divideAsync(a, b))
      } yield result</code></pre></div><br/><div id="41524415" class="c"><input type="checkbox" id="c-41524415" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#41523477">root</a><span>|</span><a href="#41523926">parent</a><span>|</span><a href="#41523679">next</a><span>|</span><label class="collapse" for="c-41524415">[-]</label><label class="expand" for="c-41524415">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but Usually we just use something like ZIO nowadays. So the code becomes:<p><pre><code>    def divisionProgramAsync(inputA: String, inputB: String): IO[String, Double] =
      for {
        a      &lt;- parseDoubleAsync(inputA)
        b      &lt;- parseDoubleAsync(inputB)
        result &lt;- divideAsync(a, b)
      } yield result
</code></pre>
(the annoying wrapping&#x2F;unwrapping isn&#x27;t necessary with ZIO here)<p>You can also write this shorter if you want:<p><pre><code>    def divisionProgramAsync(inputA: String, inputB: String): IO[String, Double] =
      for {
        (a, b) &lt;- parseDoubleAsync(inputA) &lt;*&gt; parseDoubleAsync(inputB)
        result &lt;- divideAsync(a, b)
      } yield result</code></pre></div><br/></div></div></div></div><div id="41523679" class="c"><input type="checkbox" id="c-41523679" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#41523477">parent</a><span>|</span><a href="#41523926">prev</a><span>|</span><a href="#41523753">next</a><span>|</span><label class="collapse" for="c-41523679">[-]</label><label class="expand" for="c-41523679">[3 more]</label></div><br/><div class="children"><div class="content">In Haskell, that&#x27;s usually that&#x27;s done using `do` syntax.<p><pre><code>    do
      a &lt;- somePartialResult
      b &lt;- partialFunction1 a
      c &lt;- partialFunction2 a b
      return c
</code></pre>
where we assume signatures like<p><pre><code>    somePartialResult : Either&lt;A, Error&gt;
    partialFunction1 : A -&gt; Either&lt;B, Error&gt;
    partialFunction2 : A -&gt; B -&gt; Either&lt;C, Error&gt;
</code></pre>
this overall computation has a signature Either&lt;C, Error&gt;. The way it works is that the first failing computation (the first Either that&#x27;s actually Left-y) will short-circuit and become the final result value. Only if all of the partial computations succeed (are Right-y) will the final result by Right(c).<p>In Haskell we don&#x27;t have an early return syntax like `return` and function scope. Instead, we construct something equivalent using `do` syntax. This can be a little weightier than `return`, but the upside is that you can construct other variants of things like early returns that can be more flexible.</div><br/><div id="41527657" class="c"><input type="checkbox" id="c-41527657" checked=""/><div class="controls bullet"><span class="by">me_vinayakakv</span><span>|</span><a href="#41523477">root</a><span>|</span><a href="#41523679">parent</a><span>|</span><a href="#41523753">next</a><span>|</span><label class="collapse" for="c-41527657">[-]</label><label class="expand" for="c-41527657">[2 more]</label></div><br/><div class="children"><div class="content">Nice! Would it be possible to transform an error to something else using this syntax?<p>Or, should we resort to a method of `Either` that transforms its `Left` in that case?</div><br/><div id="41527795" class="c"><input type="checkbox" id="c-41527795" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#41523477">root</a><span>|</span><a href="#41527657">parent</a><span>|</span><a href="#41523753">next</a><span>|</span><label class="collapse" for="c-41527795">[-]</label><label class="expand" for="c-41527795">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, no. Or, rather, I&#x27;m sure there&#x27;s a way to make it happen although that&#x27;s not typical practice. Typically you&#x27;d resort to mapping the left sides of your eithers so that the error types match.<p>Rust offers a similar facility (though specialized to just handle a couple kinds of error handling) using its `?` syntax. This works essentially identically to the do syntax above, but <i>also</i> includes a call to transform whatever error type is provided into the error type of the function return.<p>Note that in Rust (a) this technique only, today, works at function boundaries and (b) will always be explicitly annotated since all functions require an explicit type. This helps a bit over Haskell&#x27;s more general approach as it provides some additional data to help type inference along.<p>That said, if you were interested, it&#x27;s likely possible to emulate something very similar to Rust&#x27;s technique in Haskell, too.<p>But I don&#x27;t think I&#x27;ve ever seen that. It just doesn&#x27;t feel as stylish in Haskell. The From&#x2F;Into traits define a behavior that&#x27;s much more pervasive than most type classes in Haskell. It works well for Rust, but is I think less compelling to the Haskell community.</div><br/></div></div></div></div></div></div><div id="41523753" class="c"><input type="checkbox" id="c-41523753" checked=""/><div class="controls bullet"><span class="by">jose_zap</span><span>|</span><a href="#41523477">parent</a><span>|</span><a href="#41523679">prev</a><span>|</span><a href="#41523794">next</a><span>|</span><label class="collapse" for="c-41523753">[-]</label><label class="expand" for="c-41523753">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is possible to linearize it. You can, for example use do notation:<p><pre><code>    result &lt;- do
        a &lt;- someEitherValue
        b &lt;- anotherEitherValue
        return (doStuff a b)
</code></pre>
In the above example the do notation will unwrap the values as an and b, but if one of the results is Left, the computation is aborted, returning the Left value.<p>This is one just of the many techniques available to make error checking linear.</div><br/></div></div></div></div><div id="41519348" class="c"><input type="checkbox" id="c-41519348" checked=""/><div class="controls bullet"><span class="by">bwidlar</span><span>|</span><a href="#41523477">prev</a><span>|</span><a href="#41527164">next</a><span>|</span><label class="collapse" for="c-41519348">[-]</label><label class="expand" for="c-41519348">[2 more]</label></div><br/><div class="children"><div class="content">An implementation of an extended subset of Haskell. It uses combinators for the runtime execution:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;augustss&#x2F;MicroHs">https:&#x2F;&#x2F;github.com&#x2F;augustss&#x2F;MicroHs</a><p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?app=desktop&amp;v=uMurx1a6Zck&amp;t=36m" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?app=desktop&amp;v=uMurx1a6Zck&amp;t=36...</a></div><br/><div id="41519478" class="c"><input type="checkbox" id="c-41519478" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#41519348">parent</a><span>|</span><a href="#41527164">next</a><span>|</span><label class="collapse" for="c-41519478">[-]</label><label class="expand" for="c-41519478">[1 more]</label></div><br/><div class="children"><div class="content">An even more minimal Haskell compiler and combinatory logic runtime won in the 26th IOCCC:<p><a href="https:&#x2F;&#x2F;crypto.stanford.edu&#x2F;~blynn&#x2F;compiler&#x2F;ioccc.htm" rel="nofollow">https:&#x2F;&#x2F;crypto.stanford.edu&#x2F;~blynn&#x2F;compiler&#x2F;ioccc.htm</a></div><br/></div></div></div></div><div id="41527164" class="c"><input type="checkbox" id="c-41527164" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#41519348">prev</a><span>|</span><a href="#41519892">next</a><span>|</span><label class="collapse" for="c-41527164">[-]</label><label class="expand" for="c-41527164">[2 more]</label></div><br/><div class="children"><div class="content">I think Haskell is fundamentally a bad design, because there is no reason to not have dependent types and totality checking in such a language, and also laziness is bad as it makes memory usage unpredictable and potentially asymptotically broken.<p>Basically Rust is much better at producing efficient code with zero abstraction cost (while still doing a decent job at controlling mutation and having an expressive non-dependent type system) and having a large package ecosystem, and Lean, Agda and Idris are much better at being theoretically perfect languages while sacrificing code efficiency, so why use Haskell?</div><br/><div id="41528789" class="c"><input type="checkbox" id="c-41528789" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41527164">parent</a><span>|</span><a href="#41519892">next</a><span>|</span><label class="collapse" for="c-41528789">[-]</label><label class="expand" for="c-41528789">[1 more]</label></div><br/><div class="children"><div class="content">I think (s&#x2F;Haskell&#x2F;Rust) is fundamentally a bad design, because there is no reason to not have dependent types and totality checking in such a language</div><br/></div></div></div></div><div id="41519892" class="c"><input type="checkbox" id="c-41519892" checked=""/><div class="controls bullet"><span class="by">Vosporos</span><span>|</span><a href="#41527164">prev</a><span>|</span><a href="#41519002">next</a><span>|</span><label class="collapse" for="c-41519892">[-]</label><label class="expand" for="c-41519892">[1 more]</label></div><br/><div class="children"><div class="content">At work we use Haskell, and have been for around 10 years. It&#x27;s a delight for iterations and refactoring, as the solid foundations it bring relieve you of spending your time writing tests checking for rogue nils or undefined.</div><br/></div></div><div id="41519002" class="c"><input type="checkbox" id="c-41519002" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#41519892">prev</a><span>|</span><a href="#41519150">next</a><span>|</span><label class="collapse" for="c-41519002">[-]</label><label class="expand" for="c-41519002">[3 more]</label></div><br/><div class="children"><div class="content">Whenever I see Haskell stuff, Steve Yegge&#x27;s famous 2010 blog post instantly comes to mind:<p>&quot;Haskell Researchers Announce Discovery of Industry Programmer Who Gives a Shit&quot;<p><a href="http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2010&#x2F;12&#x2F;haskell-researchers-announce-discovery.html" rel="nofollow">http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2010&#x2F;12&#x2F;haskell-researchers-...</a></div><br/><div id="41519442" class="c"><input type="checkbox" id="c-41519442" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#41519002">parent</a><span>|</span><a href="#41519398">next</a><span>|</span><label class="collapse" for="c-41519442">[-]</label><label class="expand" for="c-41519442">[1 more]</label></div><br/><div class="children"><div class="content">And he got it completely wrong, as more and more Haskell features end up in industrial programming languages. Oracle&#x27;s Java architect even publically stated he was influenced by Haskell.</div><br/></div></div><div id="41519398" class="c"><input type="checkbox" id="c-41519398" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#41519002">parent</a><span>|</span><a href="#41519442">prev</a><span>|</span><a href="#41519150">next</a><span>|</span><label class="collapse" for="c-41519398">[-]</label><label class="expand" for="c-41519398">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a classic and Steve Yegge hasn&#x27;t been nice to Haskell with that one. As a Java programmer I used to love an even older blog making fun of Java and its ecosystem called, IIRC, &quot;The bile blog&quot;. It was trashy, mean, using lots of swear words and it was really good.</div><br/></div></div></div></div><div id="41519150" class="c"><input type="checkbox" id="c-41519150" checked=""/><div class="controls bullet"><span class="by">fbn79</span><span>|</span><a href="#41519002">prev</a><span>|</span><a href="#41523940">next</a><span>|</span><label class="collapse" for="c-41519150">[-]</label><label class="expand" for="c-41519150">[9 more]</label></div><br/><div class="children"><div class="content">We need a language with Haskell syntax, Rust memory management and Typescript toolchain&#x2F;ecosystem :))</div><br/><div id="41519267" class="c"><input type="checkbox" id="c-41519267" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#41519150">parent</a><span>|</span><a href="#41527535">next</a><span>|</span><label class="collapse" for="c-41519267">[-]</label><label class="expand" for="c-41519267">[3 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;ve specifically picked the worst part of each language here.<p>Haskell&#x27;s syntax, like many FP syntaxes, is inscrutable on first acquaintance. There&#x27;s a reason hybrid languages like Elixir thrive...<p>Rust&#x27;s memory management is a great boon for a close-to-the-metal language, but if all your types are immutable you don&#x27;t actually need&#x2F;want to deal with the borrow checker.<p>Typescripts toolchain and ecosystem are... ok, at best? I&#x27;d give a solid pitch for the Rust ecosystem having reproduced the best parts thereof (and there is still room for improvement even so)</div><br/><div id="41519559" class="c"><input type="checkbox" id="c-41519559" checked=""/><div class="controls bullet"><span class="by">fbn79</span><span>|</span><a href="#41519150">root</a><span>|</span><a href="#41519267">parent</a><span>|</span><a href="#41527535">next</a><span>|</span><label class="collapse" for="c-41519559">[-]</label><label class="expand" for="c-41519559">[2 more]</label></div><br/><div class="children"><div class="content">Haskell have a garbage collector (and it have a lot or work to do). So even if you are in the context of immutability, if you don&#x27;t want a gc, you still need to take care of memory yourself using RAII like Rust or any other low level technique. About syntax for me haskell is beautiful. But maybe it&#x27;s just my love for having type notation aside from function declaration and not mixed.</div><br/><div id="41525271" class="c"><input type="checkbox" id="c-41525271" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#41519150">root</a><span>|</span><a href="#41519559">parent</a><span>|</span><a href="#41527535">next</a><span>|</span><label class="collapse" for="c-41525271">[-]</label><label class="expand" for="c-41525271">[1 more]</label></div><br/><div class="children"><div class="content">Garbage collectors can really be very efficient in languages that are both strongly-typed and truly immutable.<p>The type system means you don&#x27;t have to worry about folks hiding pointers in arbitrary pointer-sized integers, so you know all the roots ahead of time.<p>Immutability means you can only ever create references in one direction (i.e from new objects to old objects), and you can&#x27;t ever create cycles.<p>This lets you do fun shit like a mark&amp;sweep garbage collector in a single pass (rather than the usual two) - and if you have process isolation guarantees (a la Erlang), you don&#x27;t necessarily have to suspend execution while it runs. Or maybe a generational collector where the generations are entirely implicit.</div><br/></div></div></div></div></div></div><div id="41527535" class="c"><input type="checkbox" id="c-41527535" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#41519150">parent</a><span>|</span><a href="#41519267">prev</a><span>|</span><a href="#41519187">next</a><span>|</span><label class="collapse" for="c-41527535">[-]</label><label class="expand" for="c-41527535">[1 more]</label></div><br/><div class="children"><div class="content">Haskell has linear types now, which can give you something similar to rusts affine types. The library ecosystem for it isn’t very mature yet though.</div><br/></div></div><div id="41519187" class="c"><input type="checkbox" id="c-41519187" checked=""/><div class="controls bullet"><span class="by">joelthelion</span><span>|</span><a href="#41519150">parent</a><span>|</span><a href="#41527535">prev</a><span>|</span><a href="#41521210">next</a><span>|</span><label class="collapse" for="c-41519187">[-]</label><label class="expand" for="c-41519187">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue the syntax is the worst part of haskell. In particular, the lack of object notation for accessing fields (e.g. car.doors) is particularly frustrating.<p>I still love the language, BTW.</div><br/><div id="41527546" class="c"><input type="checkbox" id="c-41527546" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#41519150">root</a><span>|</span><a href="#41519187">parent</a><span>|</span><a href="#41519207">next</a><span>|</span><label class="collapse" for="c-41527546">[-]</label><label class="expand" for="c-41527546">[1 more]</label></div><br/><div class="children"><div class="content">There is an extension that lets you do this now (OverloadedRecordDotSyntax) but truthfully I think it’s a really bad idea. The (.) operator already has a very concrete meaning in Haskell, and record dot notation means that you suddenly need to care about the specific details of how values are calculated. Field accessor functions are much better imo even if they seem a little odd.</div><br/></div></div><div id="41519207" class="c"><input type="checkbox" id="c-41519207" checked=""/><div class="controls bullet"><span class="by">gtf21</span><span>|</span><a href="#41519150">root</a><span>|</span><a href="#41519187">parent</a><span>|</span><a href="#41527546">prev</a><span>|</span><a href="#41521210">next</a><span>|</span><label class="collapse" for="c-41519207">[-]</label><label class="expand" for="c-41519207">[1 more]</label></div><br/><div class="children"><div class="content">You can have that syntax if you want it via `OverloadedRecordDot`.<p>I actually really like the syntax as it makes it easy to write DSLs which are actually just Haskell functions.</div><br/></div></div></div></div><div id="41521210" class="c"><input type="checkbox" id="c-41521210" checked=""/><div class="controls bullet"><span class="by">empath75</span><span>|</span><a href="#41519150">parent</a><span>|</span><a href="#41519187">prev</a><span>|</span><a href="#41523940">next</a><span>|</span><label class="collapse" for="c-41521210">[-]</label><label class="expand" for="c-41521210">[1 more]</label></div><br/><div class="children"><div class="content">I think you just want Rust.<p>You can write extremely haskell-like code with Rust.<p>Here&#x27;s the first example in rust:<p><pre><code>    fn safe_head&lt;T&gt;(list: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
        match list {
            [first, ..] =&gt; Some(first),  
            [] =&gt; None,                  
        }
    }

    fn print_the_first_thing(my_list: &amp;[String]) {
        match safe_head(my_list) {
            Some(something) =&gt; println!(&quot;{}&quot;, something),
            None =&gt; println!(&quot;You don&#x27;t have any favourite things? How sad.&quot;),
        }
    }

    fn main() {
        let my_favourite_things = vec![&quot;raindrops on roses&quot;.to_string(), &quot;whiskers on kittens&quot;.to_string()];
        let empty_list: Vec&lt;String&gt; = vec![];

        print_the_first_thing(&amp;my_favourite_things);
    
        print_the_first_thing(&amp;empty_list);
    }
</code></pre>
(of course Rust has a lot of helper functions that avoid all that verbosity -- you can do the whole thing in one expression, if you want)<p><pre><code>    println!(
        &quot;{}&quot;,
        my_favourite_things.get(0).map_or(
            &quot;You don&#x27;t have any favourite things? How sad.&quot;.to_string(),
            |something| something.to_string()
        )
    );</code></pre></div><br/></div></div></div></div><div id="41523940" class="c"><input type="checkbox" id="c-41523940" checked=""/><div class="controls bullet"><span class="by">nazka</span><span>|</span><a href="#41519150">prev</a><span>|</span><a href="#41528483">next</a><span>|</span><label class="collapse" for="c-41523940">[-]</label><label class="expand" for="c-41523940">[3 more]</label></div><br/><div class="children"><div class="content">Is it still true that writing optimized Haskell is extremely hard? Since Haskell is GC, can I write code as fast as say Java or Go?</div><br/><div id="41527526" class="c"><input type="checkbox" id="c-41527526" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#41523940">parent</a><span>|</span><a href="#41524194">next</a><span>|</span><label class="collapse" for="c-41527526">[-]</label><label class="expand" for="c-41527526">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think optimization in Haskell is much different from any other language. In most cases naive Haskell is pretty fast and memory efficient, but there are some patterns that will make it more or less so. There are a handful of common patterns you can learn that are idiomatic and will generally result in faster or more memory efficient code, and some common libraries that you can use that are more efficient.<p>There are also some common patterns for less idiomatic but more performant code that you can use as a first pass when you need to optimize things further. Usually that’s sufficient, but when you need to go even further with optimization then it can get hard. Every language can. In Haskell, it usually means starting by dumping core and seeing what the compiler is doing, and getting familiar with the different passes the compiler makes. As a last resort you can also just write in C and use the ffi.</div><br/></div></div><div id="41524194" class="c"><input type="checkbox" id="c-41524194" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#41523940">parent</a><span>|</span><a href="#41527526">prev</a><span>|</span><a href="#41528483">next</a><span>|</span><label class="collapse" for="c-41524194">[-]</label><label class="expand" for="c-41524194">[1 more]</label></div><br/><div class="children"><div class="content">This varies by use case and how much &#x2F; which extensions you&#x27;re including in your Haskell source (and, to a lesser extent, which libraries being included in the equivalent Java or Go source).<p>I haven&#x27;t taken a lot of measurements and my production code is biased to Go, C++, Python and Java, with most of my Haskell experience being side projects and toys for learning from, and writing a type-unifier for a production project.  I can summarize what I learned but I would be interested in seeing better measurements.<p>First, though, let&#x27;s be more specific about what you mean by &quot;writing code as fast,&quot; which I think should be refined to &quot;time spent writing code&quot; + &quot;time compiling code&quot; + &quot;time spent in language runtime&quot; + &quot;time spent debugging &#x2F; reading code&quot;.  Depending on your project, and who if anyone is collaborating, each of these might be more or less important.  Sometimes runtime speeds dwarf the needs of development or even debugging time.  Sometimes compilation speeds afford the quick feedback loop that contributes to flow in development time.<p>Within that framing, Haskell can excel at development time with small teams and limited scopes.  It affords writing a domain-specific language within the code, including very custom operators, and this carries the risk of overburdening with complexity, and strongly proportional to the number of people on the team.  Things can get complex fast and it can contribute some to compilation time if there is a lot of recursive complexity to the type system.  But if the source is organized well and doesn&#x27;t need to be very dynamic, this may not be much of a concern.  As an underlying engine for very dynamic data inputs and sufficiently complex numerical analysis or IO management as its primary purpose, it would probably do well.<p>The packaging system (Hackage) is pretty good, and that benefits the development time considerably.  Adding some modules may impede compilation times, for much of the same reason as above, the type inference can become expensive.  And undisciplined source management can lead to a lot of type implementations that are near copies of each other.  Obviously this also ties into the reading&#x2F;debugging time, too.<p>For runtime, though, yes Haskell can be competitive with bare-metal C implementations.  I think there have been a few papers written about that going back a decade or so.</div><br/></div></div></div></div><div id="41528483" class="c"><input type="checkbox" id="c-41528483" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#41523940">prev</a><span>|</span><a href="#41522889">next</a><span>|</span><label class="collapse" for="c-41528483">[-]</label><label class="expand" for="c-41528483">[1 more]</label></div><br/><div class="children"><div class="content">It is all about monad.</div><br/></div></div><div id="41522889" class="c"><input type="checkbox" id="c-41522889" checked=""/><div class="controls bullet"><span class="by">semiinfinitely</span><span>|</span><a href="#41528483">prev</a><span>|</span><a href="#41523534">next</a><span>|</span><label class="collapse" for="c-41522889">[-]</label><label class="expand" for="c-41522889">[1 more]</label></div><br/><div class="children"><div class="content">Haskell had a large impact on the design of JAX which is probably the future of ML development frameworks.</div><br/></div></div><div id="41523534" class="c"><input type="checkbox" id="c-41523534" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#41522889">prev</a><span>|</span><a href="#41525346">next</a><span>|</span><label class="collapse" for="c-41523534">[-]</label><label class="expand" for="c-41523534">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s one big web facing application which handles modern authentication protocols?</div><br/><div id="41526274" class="c"><input type="checkbox" id="c-41526274" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#41523534">parent</a><span>|</span><a href="#41525346">next</a><span>|</span><label class="collapse" for="c-41526274">[-]</label><label class="expand" for="c-41526274">[2 more]</label></div><br/><div class="children"><div class="content">mercury.com ?</div><br/><div id="41528543" class="c"><input type="checkbox" id="c-41528543" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#41523534">root</a><span>|</span><a href="#41526274">parent</a><span>|</span><a href="#41525346">next</a><span>|</span><label class="collapse" for="c-41528543">[-]</label><label class="expand" for="c-41528543">[1 more]</label></div><br/><div class="children"><div class="content">For a bit more context, iirc mercury is at ~2m lines of Haskell over ~10k modules.</div><br/></div></div></div></div></div></div><div id="41525346" class="c"><input type="checkbox" id="c-41525346" checked=""/><div class="controls bullet"><span class="by">adamddev1</span><span>|</span><a href="#41523534">prev</a><span>|</span><a href="#41523026">next</a><span>|</span><label class="collapse" for="c-41525346">[-]</label><label class="expand" for="c-41525346">[2 more]</label></div><br/><div class="children"><div class="content">I want Haskell with the tooling, DX, and packages of TypeScript.</div><br/><div id="41528539" class="c"><input type="checkbox" id="c-41528539" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#41525346">parent</a><span>|</span><a href="#41523026">next</a><span>|</span><label class="collapse" for="c-41528539">[-]</label><label class="expand" for="c-41528539">[1 more]</label></div><br/><div class="children"><div class="content">I don’t. I don’t think gradual typing is enough to cover for the unprincipled mess that I’ve observed in the JS world over the past 15 years.</div><br/></div></div></div></div><div id="41523026" class="c"><input type="checkbox" id="c-41523026" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#41525346">prev</a><span>|</span><a href="#41522169">next</a><span>|</span><label class="collapse" for="c-41523026">[-]</label><label class="expand" for="c-41523026">[3 more]</label></div><br/><div class="children"><div class="content">The thing that always amuses me when I read articles like this is that the things they point out as differentiating the language are usually, at best, small time-savers.<p>1. the lack of nullable types<p>I very rarely write these bugs, and when I do I can typically fix them in 5 minutes.  This is because I typically do (2) in my projects, which does largely eliminate this error.<p>2. representations of “failable” computations<p>Basically any modern language can do this.  It might not be 100% as ergonomic as it is in Haskell, but it also isn&#x27;t a large source of bugs in my experience.<p>3. pattern matching and completeness checks<p>Okay, these are nice and ergonomic in Haskell.  Other languages get pretty close.  Again, not a source of time-consuming bugs.<p>4. the avoidance of “primitive obsession”<p>The example he gave for this is innanely contrived, and the bug would likely take a small amount of time to fix, even for a junior.  Admittedly, this is a nice convenience feature and I would love having types for different color spaces, or radians vs degrees, but at the end of the day I spend basically 0% of my time on bugs like this, so it&#x27;s barely worth mentioning.<p>You know what I&#x27;d like a language to help me with?  Keeping track of inter-data dependencies so I don&#x27;t have to litter my code with a million assertions to make sure the sub-type of the sum type I&#x27;m working with is correct.  Or giving me a way to express structural dependencies between pieces of code when writing multithreaded programs.  Like saying &quot;hey, this render pass has to happen after &#x27;DoEntitySimulation&#x27; has completed&quot; .. or whatever.  I&#x27;m not aware of any language that even tries to do that, although I think Bungie wrote something like this in their engine for Destiny2.<p>And metaprogramming.  I ended up writing my own metaprogramming language because none of the ones I tried could even do the basics of what I wanted in an ergonomic way, and be runtime-performant.<p>For reference, my language of choice is typically C++99.  Maybe I&#x27;m not the intended target audience.</div><br/><div id="41524530" class="c"><input type="checkbox" id="c-41524530" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#41523026">parent</a><span>|</span><a href="#41522169">next</a><span>|</span><label class="collapse" for="c-41524530">[-]</label><label class="expand" for="c-41524530">[2 more]</label></div><br/><div class="children"><div class="content">This is actually a very good comment. Haskell has had these features since early ~2000s and it was a major competitive advantage in the language space, but today I would argue that if you&#x27;re using a modern language then they don&#x27;t stand out as much. Nevertheless, not all popular languages provide all the above mentioned features and in case they implement them it&#x27;s usually in a compromised fashion. For example, nullable types are still an open issue in Java, while C# and Typescript provide easy ways to circumvent them, a lot of times by accident (the main issue is that they&#x27;re mostly annotations, not runtime checks).<p>On the other hand, you mention several features which Haskell provides, usually through libraries that can only be implemented due to the features provided by the base language:<p>- Refinement types [1] allow to add runtime invariants to existing types in an ergonomic fashion, or you can go even further and use something like LiquidHaskell[2] to enforce properties at compile time.<p>- For multithreaded programs, the existence of STM[3] allows to to write mutable variables which are safe to use across threads. Very few languages offer something like this.<p>- For structural dependencies, you can apply the techniques of &quot;ghost of departed proofs&quot;[4]. Personally I don&#x27;t like to go that route since programming becomes an act of &quot;proving&quot; rather than &quot;doing&quot; but I appreciate the fact that you can encode it if you want&#x2F;need to.<p>- Metaprogramming in Haskell is not as ergonomic as in a LISP yet you have the full access to the language through TemplateHaskell[5]. A more constrained form is available as QuasiQuotations that allow you, for example to write a regex[6] string and have it compiled alongside the rest of the code.<p>There are other features that I personally think are still far ahead from the competition, like lenses[7] to traverse nested data, the async[8] package for ergonomic concurrent programs, effect systems[9] for more granular dependency injection, immutability by default to avoid corrupting state, full type inference, top level functions and values (I can&#x27;t believe the amount of times I find myself missing them in OOP languages like Java and C#), among others.<p>---<p>[1] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;refined" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;refined</a>
[2] <a href="https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell&#x2F;</a>
[3] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;stm" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;stm</a>
[4] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;gdp" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;gdp</a>
[5] <a href="https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;introduction-to-template-haskell" rel="nofollow">https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;introduction-to-template-haskell</a>
[6] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;regexqq" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;regexqq</a>
[7] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;lens" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;lens</a>
[8] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;async" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;async</a>
[9] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;effectful" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;effectful</a></div><br/><div id="41526790" class="c"><input type="checkbox" id="c-41526790" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#41523026">root</a><span>|</span><a href="#41524530">parent</a><span>|</span><a href="#41522169">next</a><span>|</span><label class="collapse" for="c-41526790">[-]</label><label class="expand" for="c-41526790">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is actually a very good comment.<p>Thank you, I appreciate that.  And that you took the time to write such a complete response.<p>At the end of the day, Haskell is just way too slow (at runtime) for me to consider using, so debating that these features satisfy my requirements is purely an academic exercise.  One which I don&#x27;t have much interest in doing.<p>I am glad to hear that you seem to enjoy using Haskell, and I hope it continues to bring you joy :)</div><br/></div></div></div></div></div></div><div id="41522169" class="c"><input type="checkbox" id="c-41522169" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#41523026">prev</a><span>|</span><label class="collapse" for="c-41522169">[-]</label><label class="expand" for="c-41522169">[1 more]</label></div><br/><div class="children"><div class="content">Awaiting part 2 — Why not to use Haskell?</div><br/></div></div></div></div></div></div></div></body></html>