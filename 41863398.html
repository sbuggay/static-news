<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729155666290" as="style"/><link rel="stylesheet" href="styles.css?v=1729155666290"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/hugohadfield/kalmangrad">Show HN: Automated smooth Nth order derivatives of noisy data</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>hugohadfield</span> | <span>21 comments</span></div><br/><div><div id="41866942" class="c"><input type="checkbox" id="c-41866942" checked=""/><div class="controls bullet"><span class="by">brody_slade_ai</span><span>|</span><a href="#41866638">next</a><span>|</span><label class="collapse" for="c-41866942">[-]</label><label class="expand" for="c-41866942">[1 more]</label></div><br/><div class="children"><div class="content">Kalman Filter helped me understand the mathematical concepts that make it a powerful tool for estimating values from noisy data<p>I made a simulation that forecasted a greenhouse&#x27;s temperature and humidity to help me understand the idea. I began by going over the basics of Gaussians and normal distribution once more. After that, I used NumPy and SciPy to develop the Kalman Filter in Python. To represent the system, I defined noise matrices (Q and R), a state transition matrix (F), and a control input matrix (B).</div><br/></div></div><div id="41866638" class="c"><input type="checkbox" id="c-41866638" checked=""/><div class="controls bullet"><span class="by">fisian</span><span>|</span><a href="#41866942">prev</a><span>|</span><a href="#41865327">next</a><span>|</span><label class="collapse" for="c-41866638">[-]</label><label class="expand" for="c-41866638">[1 more]</label></div><br/><div class="children"><div class="content">Great work!<p>I would&#x27;ve needed this recently for some data analysis, to estimate the mass of an object based on position measurments. I tried calculating the 2nd derivative with a Savitzky-Golay filter, but still had some problems and ended up using a different approach (also using a Kalman filter, but with a physics-based model of my setup).<p>My main problem was that I had repeated values in my measurements (sensor had a lower, non-integer divisible sampling rate than the acquisition pipeline).
This especially made clear that np.gradient wasn&#x27;t suitable, because it resulted in erratic switches between zero and the calculated derivative. Applying, np.gradient twice made the data look like random noise.<p>I will try using this library, when I next get the chance.</div><br/></div></div><div id="41865327" class="c"><input type="checkbox" id="c-41865327" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#41866638">prev</a><span>|</span><a href="#41864206">next</a><span>|</span><label class="collapse" for="c-41865327">[-]</label><label class="expand" for="c-41865327">[2 more]</label></div><br/><div class="children"><div class="content">This is great! I&#x27;ve taken sort of a passive interest in this topic over the years, some papers which come to mind are [1] and [2] but I don&#x27;t think I&#x27;ve seen a real life example of using the Kalman filter before.<p>[1] <a href="https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;abs&#x2F;pii&#x2F;0021929081900762" rel="nofollow">https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;abs&#x2F;pii&#x2F;002192...</a><p>[2] <a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;stamp&#x2F;stamp.jsp?tp=&amp;arnumber=9241009" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;stamp&#x2F;stamp.jsp?tp=&amp;arnumber=924...</a></div><br/></div></div><div id="41864206" class="c"><input type="checkbox" id="c-41864206" checked=""/><div class="controls bullet"><span class="by">pm</span><span>|</span><a href="#41865327">prev</a><span>|</span><a href="#41866406">next</a><span>|</span><label class="collapse" for="c-41864206">[-]</label><label class="expand" for="c-41864206">[10 more]</label></div><br/><div class="children"><div class="content">Congratulations! Pardon my ignorance, as my understanding of mathematics at this level is beyond rusty, but what are the applications of this kind of functionality?</div><br/><div id="41864774" class="c"><input type="checkbox" id="c-41864774" checked=""/><div class="controls bullet"><span class="by">thatcherc</span><span>|</span><a href="#41864206">parent</a><span>|</span><a href="#41864688">next</a><span>|</span><label class="collapse" for="c-41864774">[-]</label><label class="expand" for="c-41864774">[3 more]</label></div><br/><div class="children"><div class="content">I actually have one for this! Last week I had something really specific - a GeoTIFF image where each pixel represents the speed in &quot;x&quot; direction of the ice sheet surface in Antarctica and I wanted to get the derivative of that velocity field so I could look at the strain rate of the ice.<p>A common way to do that is to use a Savitzky-Golay filter [0], which does a similar thing - it can smooth out data and also provide smooth derivatives of the input data. It looks like this post&#x27;s technique can also do that, so maybe it&#x27;d be useful for my ice strain-rate field project.<p>[0] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Savitzky%E2%80%93Golay_filter" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Savitzky%E2%80%93Golay_filter</a></div><br/><div id="41865298" class="c"><input type="checkbox" id="c-41865298" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#41864206">root</a><span>|</span><a href="#41864774">parent</a><span>|</span><a href="#41864872">next</a><span>|</span><label class="collapse" for="c-41865298">[-]</label><label class="expand" for="c-41865298">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been a heavy user of Savitzky-Golay filters (linear time series, rectangular grid images, cubic space domains | first, second and third derivitives | balanced and unbalanced (returning central region smoothed values and values at edges)) since the 1980s.<p>The usual implementation is as a convolution filter based on the premise that the underlying data is regularly sampled.<p>The pain in the arse occassional reality is missing data and|or present but glitched|spiked data .. both of which require a &quot;sensible infill&quot; to continue with a convolution.<p>This is a nice implementation and a potentially useful bit of kit- the elephant in the room (from my PoV) is &quot;how come the application domain is irregularly sampled data&quot;?<p>Generally (engineering, geophysics, etc) great lengths are taken to clock data samples like a metronome (in time and|or space (as required most)).<p>I&#x27;m <i>assuming</i> that your gridded GeoTIFF data field is regularly sampled in both the X and Y axis?</div><br/></div></div><div id="41864872" class="c"><input type="checkbox" id="c-41864872" checked=""/><div class="controls bullet"><span class="by">pm</span><span>|</span><a href="#41864206">root</a><span>|</span><a href="#41864774">parent</a><span>|</span><a href="#41865298">prev</a><span>|</span><a href="#41864688">next</a><span>|</span><label class="collapse" for="c-41864872">[-]</label><label class="expand" for="c-41864872">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for that, it looks like my research today is cut out for me.</div><br/></div></div></div></div><div id="41864688" class="c"><input type="checkbox" id="c-41864688" checked=""/><div class="controls bullet"><span class="by">hugohadfield</span><span>|</span><a href="#41864206">parent</a><span>|</span><a href="#41864774">prev</a><span>|</span><a href="#41865843">next</a><span>|</span><label class="collapse" for="c-41864688">[-]</label><label class="expand" for="c-41864688">[3 more]</label></div><br/><div class="children"><div class="content">No problem! Let&#x27;s dream up a little use case:<p>Imagine you have a speed sensor eg. on your car and you would like to calculate the jerk (2nd derivative of speed) of your motion (useful in a range of driving comfort metrics etc.). The speed sensor on your car is probably not all that accurate, it will give some slightly randomly wrong output and it may not give that output at exactly 10 times per second, you will have some jitter in the rate you receive data. If you naiively attempt to calculate jerk by doing central differences on the signal twice (using np.gradient twice) you will amplify the noise in the signal and end up with something that looks totally wrong which you will then have to post process and maybe resample to get it at the rate that you want. If instead of np.gradient you use kalmangrad.grad you will get a nice smooth jerk signal (and a fixed up speed signal too).
There are many ways to do this kind of thing, but I personally like this one as its fast, can be run online, and if you want you can get uncertainties in your derivatives too :)</div><br/><div id="41864859" class="c"><input type="checkbox" id="c-41864859" checked=""/><div class="controls bullet"><span class="by">pm</span><span>|</span><a href="#41864206">root</a><span>|</span><a href="#41864688">parent</a><span>|</span><a href="#41865843">next</a><span>|</span><label class="collapse" for="c-41864859">[-]</label><label class="expand" for="c-41864859">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d been researching Kalman filters to smooth out some sampling values (working on mobile: anything from accelerometer values to voice activation detection), but hadn&#x27;t got around to revising the mathematics, so I appreciate the explanation.  Out of curiosity, what other ways might this be achieved? I haven&#x27;t seen much else beyond Kalman filters.</div><br/><div id="41867618" class="c"><input type="checkbox" id="c-41867618" checked=""/><div class="controls bullet"><span class="by">nihzm</span><span>|</span><a href="#41864206">root</a><span>|</span><a href="#41864859">parent</a><span>|</span><a href="#41865843">next</a><span>|</span><label class="collapse" for="c-41867618">[-]</label><label class="expand" for="c-41867618">[1 more]</label></div><br/><div class="children"><div class="content">Kalman filters are usually the way to go because for some cases it is mathematically proven that they are optimal, in the sense that they minimize the noise. About alternatives, not sure if people actually do this but I think Savitzky-Golay filters could be used for the same purpose.</div><br/></div></div></div></div></div></div><div id="41865843" class="c"><input type="checkbox" id="c-41865843" checked=""/><div class="controls bullet"><span class="by">caseyy</span><span>|</span><a href="#41864206">parent</a><span>|</span><a href="#41864688">prev</a><span>|</span><a href="#41864699">next</a><span>|</span><label class="collapse" for="c-41865843">[-]</label><label class="expand" for="c-41865843">[1 more]</label></div><br/><div class="children"><div class="content">This is very important in controllers using feedback loops. The output of a controller is measured, a function is applied to it, and the result is fed back into the controller. The output becomes self-balancing.<p>The applications in this case involve self-driving cars, rocketry, homeostatic medical devices like insulin pumps, cruise control, HVAC controllers, life support systems, satellites, and other scenarios.<p>This is mainly due to a type of controller called the PID controller which involves a feedback loop and is self-balancing. The purpose of a PID controller is to induce a target value of a measurement in a system by adjusting the systemâs inputs, at least some of which are outputs of the said controller. Particularly, the derivative term of a PID controller involves a first order derivative. The smoother its values are over time, the better such a controller performs. A problem where derivative values are not smooth or second degree derivative is not continuous, is called a âderivative kickâ.<p>The people building these controllers have long sought after algorithms that produce at least a good approximation of a measurement from a noisy sensor. A good approximation of derivatives is the next level, a bit harder, and overall good approximations of the derivative are a relatively recent development.<p>There is a lot of business here. For example, Abbott Laboratories and Dexcom are building continuous blood glucose monitors that use a small transdermal sensor to sense someoneâs blood glucose. This is tremendously important for management of peopleâs diabetes. And yet algorithms like what GP presents are some of the biggest hurdles. The sensors are small and ridiculously susceptible to noise. Yet it is safety-critical that the data they produce is reliable and up to date (canât use historical smoothing) because devices like insulin pumps can consume it at real time. I wonât go into this in further detail, but incorrect data can and has killed patients. So a good algorithm for cleaning up this noisy sensor data is both a serious matter and challenging.<p>The same can be said about self-driving cars - real-time data from noisy sensors must be fed into various systems, some using PID controllers. These systems are often safety-critical and can kill people in a garbage in-garbage out scenario.<p>There are about a million applications to this algorithm. It is likely an improvement on at least some previous implementations in the aforementioned fields. Of course, these algorithms also often donât handle certain edge cases well. Itâs an ongoing area of research.<p>In short â take any important and technically advanced sensor-controller system. Thereâs a good chance it benefits from advancements like what GP posted.<p>P.S. itâs more solved with uniformly sampled data (i.e. every N seconds) than non-uniformly sampled data (i.e. as available). So once again, what GP posted is really useful.<p>I think they could get a job at pretty big medical and automotive industry companies with this, it is âthe sauceâ. If they werenât already working for a research group of a self-driving car company, that is ;)</div><br/></div></div><div id="41864699" class="c"><input type="checkbox" id="c-41864699" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#41864206">parent</a><span>|</span><a href="#41865843">prev</a><span>|</span><a href="#41866406">next</a><span>|</span><label class="collapse" for="c-41864699">[-]</label><label class="expand" for="c-41864699">[2 more]</label></div><br/><div class="children"><div class="content">Basically, approximating calculus operations on noisy, discrete-in-time data streams.</div><br/><div id="41864883" class="c"><input type="checkbox" id="c-41864883" checked=""/><div class="controls bullet"><span class="by">pm</span><span>|</span><a href="#41864206">root</a><span>|</span><a href="#41864699">parent</a><span>|</span><a href="#41866406">next</a><span>|</span><label class="collapse" for="c-41864883">[-]</label><label class="expand" for="c-41864883">[1 more]</label></div><br/><div class="children"><div class="content">This is what I was thinking, but stated much clearer than I&#x27;d have managed.</div><br/></div></div></div></div></div></div><div id="41866406" class="c"><input type="checkbox" id="c-41866406" checked=""/><div class="controls bullet"><span class="by">marmaduke</span><span>|</span><a href="#41864206">prev</a><span>|</span><a href="#41864541">next</a><span>|</span><label class="collapse" for="c-41866406">[-]</label><label class="expand" for="c-41866406">[1 more]</label></div><br/><div class="children"><div class="content">This is really nice approach.  We are doing some nonlinear system id, and faced with this  kinda problem (not irregular spacing but low sample rate and noisy).  Definitely will check it out.<p>Whatâs your opinion on ensemble KF? Weâd like to use that for parameter estimations.  I saw unscented in your bayesfilter, but not ensemble, so Iâm curious. Thanks!</div><br/></div></div><div id="41864541" class="c"><input type="checkbox" id="c-41864541" checked=""/><div class="controls bullet"><span class="by">theaussiestew</span><span>|</span><a href="#41866406">prev</a><span>|</span><a href="#41864781">next</a><span>|</span><label class="collapse" for="c-41864541">[-]</label><label class="expand" for="c-41864541">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m looking to calculate jerk from accelerometer data, I&#x27;m assuming this would be the perfect use case?</div><br/><div id="41864612" class="c"><input type="checkbox" id="c-41864612" checked=""/><div class="controls bullet"><span class="by">hugohadfield</span><span>|</span><a href="#41864541">parent</a><span>|</span><a href="#41864781">next</a><span>|</span><label class="collapse" for="c-41864612">[-]</label><label class="expand" for="c-41864612">[1 more]</label></div><br/><div class="children"><div class="content">this is a perfect use case, let me know how it goes!</div><br/></div></div></div></div><div id="41864781" class="c"><input type="checkbox" id="c-41864781" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41864541">prev</a><span>|</span><a href="#41866448">next</a><span>|</span><label class="collapse" for="c-41864781">[-]</label><label class="expand" for="c-41864781">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s useful. Can it generate a simple filter for later real-time use, based on the statistics of the noise? That would be useful for self-tuning controllers.</div><br/></div></div><div id="41866448" class="c"><input type="checkbox" id="c-41866448" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#41864781">prev</a><span>|</span><a href="#41864025">next</a><span>|</span><label class="collapse" for="c-41866448">[-]</label><label class="expand" for="c-41866448">[1 more]</label></div><br/><div class="children"><div class="content">This got me thinking, is this used in supply chain problems?</div><br/></div></div></div></div></div></div></div></body></html>