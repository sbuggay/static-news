<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684832454008" as="style"/><link rel="stylesheet" href="styles.css?v=1684832454008"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://samwho.dev/memory-allocation/">Memory Allocation</a>Â <span class="domain">(<a href="https://samwho.dev">samwho.dev</a>)</span></div><div class="subtext"><span>thecoppinger</span> | <span>119 comments</span></div><br/><div><div id="36031183" class="c"><input type="checkbox" id="c-36031183" checked=""/><div class="controls bullet"><span class="by">alex7734</span><span>|</span><a href="#36030782">next</a><span>|</span><label class="collapse" for="c-36031183">[-]</label><label class="expand" for="c-36031183">[20 more]</label></div><br/><div class="children"><div class="content">&gt; When we free memory, we should make sure that if the block we return to the free list is next to any other free blocks, we combine them together. This is called &quot;coalescing.&quot;<p>A little offtopic but the default Delphi 7 memory allocator did this, except that it also merged blocks that it obtained from different OS allocation calls.<p>This worked fine for regular usage, but if that memory was ever used for Bitmaps for UI stuff, it wouldn&#x27;t work: Since Windows does some of its UI stuff in kernel mode, before doing anything Windows would attempt to lock the entire allocation&#x27;s VAD entry to prevent you from messing with it in another thread while it was using it. If the Bitmap you were working on happened to belong to two different OS-level allocations, this lock function would fail since it wasn&#x27;t meant to handle that case.<p>This would lead to random, extremely cryptic errors such as ERROR_NO_SCROLLBARS &quot;The window does not have scroll bars.&quot; since the lock call was deep in the stack and the callers replaced the error with another one as it bubbled up.<p>In the end we had to replace the allocator to avoid that issue. That was a fun day I spent debugging that.</div><br/><div id="36033181" class="c"><input type="checkbox" id="c-36033181" checked=""/><div class="controls bullet"><span class="by">meekaaku</span><span>|</span><a href="#36031183">parent</a><span>|</span><a href="#36033655">next</a><span>|</span><label class="collapse" for="c-36033181">[-]</label><label class="expand" for="c-36033181">[10 more]</label></div><br/><div class="children"><div class="content">You mean a bug this deep took one day to debug?</div><br/><div id="36034351" class="c"><input type="checkbox" id="c-36034351" checked=""/><div class="controls bullet"><span class="by">alex7734</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36033181">parent</a><span>|</span><a href="#36033655">next</a><span>|</span><label class="collapse" for="c-36034351">[-]</label><label class="expand" for="c-36034351">[9 more]</label></div><br/><div class="children"><div class="content">Yes and no, it took me from 8am to 3am once we decided it needed to get fixed but really it sat on the app for years, it only happened on a background process that sent print jobs on a timer, since it used Windows GDI to compose the image we sent to the printer it was affected (our &quot;frontend&quot; should&#x27;ve been affected too but never was, I guess because it had a different memory usage pattern).<p>We just had it restart itself and try again whenever it got one of those errors when printing but eventually we wanted to add a feature that required the process to not die, and by that time I was already 99% sure that it wasn&#x27;t something in our code and I had already ruled out threading issues.<p>I ended up putting it in a VM with a kernel debugger attached and having a script make a snapshot and make it print over and over until it errored, then following along in IDA until I saw what was going on.<p>Having a way to trigger it (by restoring the snapshot) on demand helped a lot, otherwise it would have taken forever to make sense of it as it could sit without crashing for nearly an hour.</div><br/><div id="36035742" class="c"><input type="checkbox" id="c-36035742" checked=""/><div class="controls bullet"><span class="by">zeusk</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36034351">parent</a><span>|</span><a href="#36037098">next</a><span>|</span><label class="collapse" for="c-36035742">[-]</label><label class="expand" for="c-36035742">[6 more]</label></div><br/><div class="children"><div class="content">How do you attach kd to VM?<p>While I was at MS, it was such a big PITA - we just had a bunch of IT managed machines with KVM console access and KDNET for debugging.</div><br/><div id="36035833" class="c"><input type="checkbox" id="c-36035833" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36035742">parent</a><span>|</span><a href="#36037098">next</a><span>|</span><label class="collapse" for="c-36035833">[-]</label><label class="expand" for="c-36035833">[5 more]</label></div><br/><div class="children"><div class="content">In Hyper-V it&#x27;s fairly easy. You make a virtual serial port (&quot;COMPort&quot;), set the bootloader to enable kernel debugging over serial, then connect to the virtual serial port from the host via a named pipe.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;debugger&#x2F;attaching-to-a-virtual-machine--kernel-mode-" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;d...</a><p>I haven&#x27;t tried it with vSphere but I suspect it&#x27;d be similar.</div><br/><div id="36038937" class="c"><input type="checkbox" id="c-36038937" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36035833">parent</a><span>|</span><a href="#36037793">next</a><span>|</span><label class="collapse" for="c-36038937">[-]</label><label class="expand" for="c-36038937">[1 more]</label></div><br/><div class="children"><div class="content">Kernel debugging over serial should be possible in vSphere, but Ethernet is easier to set up:<p>1. Make sure at least one virtual NIC on the target VM (with IP connectivity to the debug host machine&#x2F;VM) is on Microsoft&#x27;s NIC whitelist[1]. I use e1000e; note that vmxnet3 is not on the list.<p>2. Follow Microsoft&#x27;s directions[2] to connect.<p>I can confirm this works on vSphere[3] and there&#x27;s no reason it shouldn&#x27;t also work on VMware Workstation, Player, and Fusion.<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;debugger&#x2F;supported-ethernet-nics-for-network-kernel-debugging-in-windows-10" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;d...</a><p>[2] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;debugger&#x2F;setting-up-a-network-debugging-connection-automatically" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;d...</a><p>[3] Tested last week with a Windows Server 2022 target (e1000e virtual NIC) and Windows 10 debug host (vmxnet3 virtual NIC), both running on ESXi 8.0 Update 1 VM hosts.</div><br/></div></div><div id="36037793" class="c"><input type="checkbox" id="c-36037793" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36035833">parent</a><span>|</span><a href="#36038937">prev</a><span>|</span><a href="#36037098">next</a><span>|</span><label class="collapse" for="c-36037793">[-]</label><label class="expand" for="c-36037793">[3 more]</label></div><br/><div class="children"><div class="content">Delphi 7 was 2002. Was hyper-v around back then? Or is this just a legacy app still running?</div><br/><div id="36040987" class="c"><input type="checkbox" id="c-36040987" checked=""/><div class="controls bullet"><span class="by">alex7734</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36037793">parent</a><span>|</span><a href="#36038820">next</a><span>|</span><label class="collapse" for="c-36040987">[-]</label><label class="expand" for="c-36040987">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a legacy app</div><br/></div></div><div id="36038820" class="c"><input type="checkbox" id="c-36038820" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36037793">parent</a><span>|</span><a href="#36040987">prev</a><span>|</span><a href="#36037098">next</a><span>|</span><label class="collapse" for="c-36038820">[-]</label><label class="expand" for="c-36038820">[1 more]</label></div><br/><div class="children"><div class="content">Hyper-V wasn&#x27;t until Windows Server 2008. I know you could do virtual serial ports w&#x2F; VMware GSX and ESX (and later ESXi) forwarded to real hardware serial ports on the host.</div><br/></div></div></div></div></div></div></div></div><div id="36037098" class="c"><input type="checkbox" id="c-36037098" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36034351">parent</a><span>|</span><a href="#36035742">prev</a><span>|</span><a href="#36033655">next</a><span>|</span><label class="collapse" for="c-36037098">[-]</label><label class="expand" for="c-36037098">[2 more]</label></div><br/><div class="children"><div class="content">Owch, Iâm guessing that wasnât -5 hours of debugging.</div><br/><div id="36038872" class="c"><input type="checkbox" id="c-36038872" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36037098">parent</a><span>|</span><a href="#36033655">next</a><span>|</span><label class="collapse" for="c-36038872">[-]</label><label class="expand" for="c-36038872">[1 more]</label></div><br/><div class="children"><div class="content">It was actually 250 hours</div><br/></div></div></div></div></div></div></div></div><div id="36033655" class="c"><input type="checkbox" id="c-36033655" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36031183">parent</a><span>|</span><a href="#36033181">prev</a><span>|</span><a href="#36030782">next</a><span>|</span><label class="collapse" for="c-36033655">[-]</label><label class="expand" for="c-36033655">[9 more]</label></div><br/><div class="children"><div class="content">I think the far weirder part of this was the kernel-side handling of scrollbars</div><br/><div id="36034396" class="c"><input type="checkbox" id="c-36034396" checked=""/><div class="controls bullet"><span class="by">alex7734</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36033655">parent</a><span>|</span><a href="#36034437">next</a><span>|</span><label class="collapse" for="c-36034396">[-]</label><label class="expand" for="c-36034396">[1 more]</label></div><br/><div class="children"><div class="content">If I recall correctly the kernel part of things would return an out of memory error which the user mode DLL translated to that weird error (sometimes, other times it would just say &quot;out of system resources&quot;, it depended on what widget the bitmap that overlapped the two memory regions belonged to).<p>Here&#x27;s a 2003 forum post from someone else having the same problem: <a href="http:&#x2F;&#x2F;www.delphigroups.info&#x2F;2&#x2F;1&#x2F;749064.html" rel="nofollow">http:&#x2F;&#x2F;www.delphigroups.info&#x2F;2&#x2F;1&#x2F;749064.html</a></div><br/></div></div><div id="36034437" class="c"><input type="checkbox" id="c-36034437" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36033655">parent</a><span>|</span><a href="#36034396">prev</a><span>|</span><a href="#36030782">next</a><span>|</span><label class="collapse" for="c-36034437">[-]</label><label class="expand" for="c-36034437">[7 more]</label></div><br/><div class="children"><div class="content">Until Windows 95, Windows was essentially just a DOS application that grabbed the framebuffer and ran an event loop where it drew &quot;controls&quot; (which includes windows, buttons, text views, and yes, scrollbars.) That was the whole point of it. It wasn&#x27;t an &quot;OS&quot; per se; DOS was the OS. Windows was what a Linux-head would think of as a combination of an X server and window manager. And Windows loaded your &quot;application&quot; as essentially a DLL, with the Windows global event loop calling into your application&#x27;s event-loop delegate handler (WndProc) whenever it has an interesting event that your application might like to react to.<p>(Your application wasn&#x27;t even a &quot;process&quot; per se. Until Windows 95, everything was just happening in one shared address space, in real mode. In fact, it was only in Windows 3.1 where user applications stopped running in ring 0!)<p>If you think about it, this &quot;the kernel is a game engine and your application is the game&quot; approach isn&#x27;t necessarily a <i>bad</i> design... for a single-tasking OS&#x27;s library exokernel, like the Wii&#x27;s <a href="https:&#x2F;&#x2F;wiibrew.org&#x2F;wiki&#x2F;IOS" rel="nofollow">https:&#x2F;&#x2F;wiibrew.org&#x2F;wiki&#x2F;IOS</a>.<p>But, of course, Windows claimed to be a multitasking OS. But it actually wasn&#x27;t! And I don&#x27;t mean the obvious thing about it not having pre-emption. Lots of multitasking OSes didn&#x27;t have pre-emption.<p>No, what I mean is that the concurrency primitive for the cooperative scheduling wasn&#x27;t the &quot;task&quot; (i.e. the process or thread. Which, again, there weren&#x27;t any of.) Instead, the concurrency primitive was the <i>window</i>. Until Windows 95, Windows was a multi-<i>windowing</i> OS.<p>Each control was owned by a window. Each window had a WndProc. If your Windows executable (i.e. application delegate module) set up two windows, then each window participated separately in the global Windows event loop, up-to-and-including things like having its own set of loaded fonts, its own clipboard state, and its own <i>interned strings table</i>. In OOP termsâ , your application was just a dead &quot;class object&quot;, running no logic of its own save for one-time load and unload hooks. It was the windows themselves that were the &quot;instances&quot; of your class.<p>This might make you realize why MDI (or Multiple Document Interface, where there are multiple small per-document &quot;windows&quot; inside one big window) was so popular back then. The MDI &quot;windows&quot; weren&#x27;t actually windows â they didn&#x27;t have their own WndProc. They were just controls, like a tab view is a control. Only the big container window was a real window, and so all the <i>resources</i> within that big window were shared between all the virtual windows. MDI was a memory-saving trick!<p>---<p>â  The actual more interesting analogy is that Windows was essentially a (single-threaded, cooperatively-scheduled) <i>actor system</i>, where windows were the actors. There is a very close parallel between (Windows 3.1 executables, Windows 3.1 windows) and (Erlang modules, Erlang processes).</div><br/><div id="36034983" class="c"><input type="checkbox" id="c-36034983" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36034437">parent</a><span>|</span><a href="#36035542">next</a><span>|</span><label class="collapse" for="c-36034983">[-]</label><label class="expand" for="c-36034983">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This might make you realize why MDI (or Multiple Document Interface, where there are multiple small per-document &quot;windows&quot; inside one big window) was so popular back then. The MDI &quot;windows&quot; weren&#x27;t actually windows â they didn&#x27;t have their own WndProc. They were just controls, like a tab view is a control. Only the big container window was a real window, and so all the resources within that big window were shared between all the virtual windows. MDI was a memory-saving trick!</i><p>MDI may have saved some memory - I can&#x27;t say one way or the other on that - but the mechanism you describe is incorrect.<p>Every MDI child window was a window of its own with its own WndProc. Every <i>control</i> inside those windows was also a window with its own WndProc. Every dialog box was also - yes - a window with its own WndProc.<p>You wouldn&#x27;t always be aware of the WndProc in your code, but it was there.<p>If you ran WinSight or Spy++, you could see the entire window hierarchy including all the child windows, child control windows, and so on.<p>Later on, a few applications implemented &quot;windowless controls&quot; to save memory, but this was uncommon, especially in the early days. For example, there was an optional windowless version of the Rich Edit control:<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;controls&#x2F;windowless-rich-edit-controls" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;controls&#x2F;win...</a><p>Fun fact: an early informal name for MDI was &quot;Mac in a box&quot;, because if you maximized the top level window, you had a somewhat Mac-like environment, with one menu bar at the top that was shared by the child windows.<p>Source: I was the author of WinSight and the VBX (Visual Basic eXtension) API.</div><br/><div id="36038298" class="c"><input type="checkbox" id="c-36038298" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36034983">parent</a><span>|</span><a href="#36035542">next</a><span>|</span><label class="collapse" for="c-36038298">[-]</label><label class="expand" for="c-36038298">[2 more]</label></div><br/><div class="children"><div class="content">Interesting; through the fog of time, I may have misremembered some &quot;tip&quot; I was given for Windows 3.1 programming efficiency, as being a more definitive statement about the internal structure of Windows than it really was.<p>That tip, as I recall it, was that the developer should minimize the number of top-level windows they create, because each top-level window in the system gets opted automatically into various things that regular controls don&#x27;t (including having a bunch of default child controls that probably keep a lot of state and pump a lot of messages.) But MDI child windows don&#x27;t have the same window-class as top-level windows, and are instead pruned down to be much &quot;lighter&quot;, both in doing things like:<p>- not having a some child controls (e.g. a menu bar) by default (you&#x27;re supposed to attach the menu bar to the MDI frame instead, and change it to reflect the menu of the active child â as you say, it&#x27;s &quot;a Mac in a box&quot; behavior);<p>- implementing behaviors that <i>seem</i> like their own child controls, but which are actually parts of the MDI child&#x27;s own geometry, to reduce the number of event loops that need to be pumped. (I believe an MDI child&#x27;s default-styled title bar might be this way, only becoming a full-on child control tree if the MDI child is given non-default styles.)<p>- &quot;Sharing&quot; child controls, where the control (I think an MDI child window&#x27;s caption buttons might be this way?)<p>- routing messages to only the active child, with the others essentially frozen except when they need to redraw<p>Digging around, evidence to corroborate this is pretty scant, but there is some:<p>- <a href="https:&#x2F;&#x2F;jeffpar.github.io&#x2F;kbarchive&#x2F;kb&#x2F;095&#x2F;Q95578&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jeffpar.github.io&#x2F;kbarchive&#x2F;kb&#x2F;095&#x2F;Q95578&#x2F;</a> is a bug that is evidence of the MDI child window class having most of its behaviors programmed separately, rather than there being any code reuse between top-level windows and MDI child windows<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;TransmissionZero&#x2F;Win16-MDI-Application&#x2F;blob&#x2F;master&#x2F;MDIChWnd.c">https:&#x2F;&#x2F;github.com&#x2F;TransmissionZero&#x2F;Win16-MDI-Application&#x2F;bl...</a> shows that MDI child windows have to be created through a special handler in the MDI frame (WM_MDICREATE); you can&#x27;t just create regular windows with the MDI frame as their parent</div><br/><div id="36039019" class="c"><input type="checkbox" id="c-36039019" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36038298">parent</a><span>|</span><a href="#36035542">next</a><span>|</span><label class="collapse" for="c-36039019">[-]</label><label class="expand" for="c-36039019">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the interesting discussion. Yes, the fog of time affects us all.<p>Funny you mention caption buttons (min&#x2F;max&#x2F;close&#x2F;etc.) and menus and such. I meant to add a &quot;Fun fact #2&quot; in my first comment. So here we go...<p>In traditional Windows applications, none of those are child windows (or child controls, same thing). They are all part of the &quot;non-client area&quot;. You may recall there being a whole series of WM_NC... messages like WM_NCMOUSEMOVE and WM_NCPAINT, with the same names as your usual messages except for the NC prefix. Your WndProc would receive all of these messages, but generally would just pass them along to DefWindowProc which handled this &quot;non-client&quot; activity.<p>Now here is the fun fact. OS&#x2F;2 Presentation Manager took a different and cleaner approach. It removed the &quot;non-client area&quot; concept entirely, along with all those messages. Instead, all of those window doo-dads were child windows. The minimize button was a child window. Your &quot;client area&quot; was a child window. And so on. It was all child windows.<p>On this point:<p>&gt; <i>implementing behaviors that seem like their own child controls, but which are actually parts of the MDI child&#x27;s own geometry, to reduce the number of event loops that need to be pumped.</i><p>To be clear, a typical application had only one event loop. It was your classic GetMessage&#x2F;TranslateMessage&#x2F;DispatchMessage loop. DispatchMessage would pass the message off to whatever WndProc it should be directed to.</div><br/></div></div></div></div></div></div><div id="36035542" class="c"><input type="checkbox" id="c-36035542" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36034437">parent</a><span>|</span><a href="#36034983">prev</a><span>|</span><a href="#36038895">next</a><span>|</span><label class="collapse" for="c-36035542">[-]</label><label class="expand" for="c-36035542">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Until Windows 95, everything was just happening in one shared address space, in real mode. In fact, it was only in Windows 3.1 where user applications stopped running in ring 0!<p>Windows 3.0 and predecessors runs in processor which had no concept of &quot;ring 0&quot;, so that should not be surprising at all...<p>&gt; Your application wasn&#x27;t even a &quot;process&quot; per se<p>I think this is a bit of a &quot;modernistic&quot;, &quot;win32y&quot; view of the definition of a process. Surely there are processes&#x2F;tasks in 3.x -- you can launch multiple instances of a module, each of them can allocate memory separately, each of them have different resources&#x2F;handles, and the OS will cleanup for you once each instance terminates (cleanly). Obviously, without any type of virtual address space or memory protection, any such process can write to and destroy the memory of any other process, but they are still processes. The existence of Yield&#x2F;DirectedYield , which do not take&#x2F;need a window, is also a hint of that. (Note there are no threads in 3.x).<p>Many platforms (that either predate VM or decide not to use VM for e.g. power usage concerns) worked like this. MacOS, Windows CE, PalmOS, etc.</div><br/><div id="36038431" class="c"><input type="checkbox" id="c-36038431" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36035542">parent</a><span>|</span><a href="#36038895">next</a><span>|</span><label class="collapse" for="c-36038431">[-]</label><label class="expand" for="c-36038431">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can launch multiple instances of a module, each of them can allocate memory separately<p>I don&#x27;t think this is true, though? You&#x27;re not getting separate <i>processes</i>; you&#x27;re just getting separate <i>hInstances</i>. Which don&#x27;t map cleanly to a process-like abstraction.<p>Consider: while you <i>can</i> (in theory) spawn multiple copies of a Win16 executable, with each spawn getting its own hInstance and therefore its own locals heap, this isn&#x27;t an inherent part of Win16&#x27;s architecture, but rather is something specific to its handling of spawning executables. <i>DLLs</i> weren&#x27;t included in this handling, and so only get <i>one</i> hInstance+heap each. This means that if you load and call into the same DLL from two separate actively-running Win16 programs, then that DLL must juggle any state it wants to keep for its N active callers on its own single heap. A function call crossing semantically-distinct memory protection domains, without any kind of IPC serialization, is not very &quot;process&quot;-y. It&#x27;s more of an object system, like the JVM.<p>(In both Windows and the JVM: each &quot;object&quot; has its own private heap, and a module wrapping access to that heap; and <i>some</i> &quot;objects&quot; additionally have their own concurrent execution thread. But a given execution thread isn&#x27;t &quot;bottled up in&quot; a particular heap; it just has a &quot;home&quot; heap. If an execution thread calls another object&#x27;s API, then that execution thread, through that API, manipulates that other object&#x27;s heap. There&#x27;s no concept of IPC â of manipulations of other objects&#x27; heaps requiring you to ask <i>the other object whose execution thread owns that heap</i> to do the manipulation for you.)<p>&gt; The existence of Yield&#x2F;DirectedYield , which do not take&#x2F;need a window, is also a hint of that.<p>DirectedYield is an attempt to make Windows tasks <i>seem</i> to act like &quot;processes&quot;... in the Communicating Sequential Processes sense, at least.<p>But it doesn&#x27;t really accomplish this. From the <i>Windows 3.1 API Reference Guide</i>:<p>&gt; If an application uses DirectedYield for a task with no events scheduled,
the task will not be executed. Instead, Windows searches the task queue.
In some cases, however, you may want the application to force a specific
task to be scheduled. The application can do this by calling the
PostAppMessage function, specifying a WM_NULL message identifier.
Then, when the application calls DirectedYield, the scheduler will run the
task regardless of the task&#x27;s event status.<p>In other words, what&#x27;s really acting as CSPs here, are the windows. :)</div><br/></div></div></div></div><div id="36038895" class="c"><input type="checkbox" id="c-36038895" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36031183">root</a><span>|</span><a href="#36034437">parent</a><span>|</span><a href="#36035542">prev</a><span>|</span><a href="#36030782">next</a><span>|</span><label class="collapse" for="c-36038895">[-]</label><label class="expand" for="c-36038895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That was the whole point of it. It wasn&#x27;t an &quot;OS&quot; per se; DOS was the OS. Windows was what a Linux-head would think of as a combination of an X server and window manager.<p>This seems like a very post-3.0 (i.e. 386-only) view of thingsâthe 8086 and 286 versions of Windows were also fairly advanced memory allocator&#x2F;overlay manager hybrids.<p>They parcelled out memory, compacted it to avoid external fragmentation (take that, dlmalloc!), expelled pieces that could be read back from executables, and discarded segments that the application programmer said could be recovered, as necessary. (Yet they couldnât actually <i>swap</i> mutable memory, as far as I can tell. Why?) For data, they required your cooperation by only revealing addresses between *Lock and *Unlock calls and requiring you to store handle+offset pairs otherwise; for code, the 8086 kernel would <i>reach into your stack and walk the frame pointer chains</i> in order to redirect return addresses to swap-in thunks. (Maintaining LRU lists along the way in either case.) Things became better on the 286 when it could just hand out segment selectors and arrange for accesses to fault as required, but this is the problem statement that Windows 1.0, running on the 8086, set out for itself.<p>Now, none of this is impossibly difficult (although I shudder at the thought of doing it without good debugging tools), but it feels pretty damn OS-like to me. You might argue there isnât much virtualization of hardware going onâexcept for RAM, CPU, display, keyboard, and mouseâbut Iâd say there is at least as much of it in Win16 as there is in DOS.<p>One would hope things would get easier on the 386. And then one gets to DPMI and VDMs and still wants to support 16-bit drivers that hooked BIOS calls as though that would help and now the system cannot interact with the user while itâs formatting a floppy[1].<p>&gt; [T]he concurrency primitive wasnât the âtaskâ [but instead] the window. Until Windows 95, Windows was a multi-<i>windowing</i> OS. [... E]ach window participated separately in the global Windows event loop, up-to-and-including things like having its own set of loaded fonts, its own clipboard state, and its own <i>interned strings table</i>. In OOP termsâ , your application was just a dead &quot;class object&quot;, running no logic of its own save for one-time load and unload hooks.<p>That... doesnât sound correct on the implementation level. If youâre an instance of a Win16 executable module, you own a copy of your executable imageâs mutable data, you own your memory allocations (that are not marked GMEM_SHARE), you own a stack, <i>you</i> get all (âpostedâ, i.e. asynchronous) messages for all windows you (or your library dependencies) created and <i>you</i> ask the system to munge and route them to the message dispatch routines of the windows you createdâor not, if you donât want to.<p>Now, the overall <i>effect</i> is very much like what you described, and often it may feel that you could as well throw out all those tedious GetMessage-TranslateMessage-DispatchMessage loops and replace them with a standard implementation of a vat[2]. Then a puny message handler decides to hijack the whole thing and go into a modal dialog loop. And damned if I could describe what that means in terms of an object model.<p>(What would you say about Symbian? Now thereâs a system that throws out processes and only runs objects. Except it doesnât run inside of a DOS or anything; thereâs a kernel and on top of that there are objects. Boom. ... I think?)<p>&gt; The actual more interesting analogy is that Windows was essentially a (single-threaded, cooperatively-scheduled) actor system, where windows were the actors.<p>Yeah, that Iâll wholeheartedly agree with. Nevermind the drawing part, it even has separate synchronous sends (SendMessage) and asynchronous ones (PostMessage)! Of course, unlike Eâs[3], these have <i>completely insane</i> interactions with the concurrency parts, especially once you get to Win32.<p>[1] <a href="http:&#x2F;&#x2F;bytepointer.com&#x2F;resources&#x2F;old_new_thing&#x2F;20090102_002_why_doesnt_windows_95_format_floppy_disks_smoothly.htm" rel="nofollow">http:&#x2F;&#x2F;bytepointer.com&#x2F;resources&#x2F;old_new_thing&#x2F;20090102_002_...</a><p>[2] <a href="http:&#x2F;&#x2F;www.erights.org&#x2F;elib&#x2F;concurrency&#x2F;vat.html" rel="nofollow">http:&#x2F;&#x2F;www.erights.org&#x2F;elib&#x2F;concurrency&#x2F;vat.html</a><p>[3] <a href="http:&#x2F;&#x2F;www.erights.org&#x2F;elib&#x2F;concurrency&#x2F;msg-passing.html" rel="nofollow">http:&#x2F;&#x2F;www.erights.org&#x2F;elib&#x2F;concurrency&#x2F;msg-passing.html</a></div><br/></div></div></div></div></div></div></div></div><div id="36030782" class="c"><input type="checkbox" id="c-36030782" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#36031183">prev</a><span>|</span><a href="#36029902">next</a><span>|</span><label class="collapse" for="c-36030782">[-]</label><label class="expand" for="c-36030782">[4 more]</label></div><br/><div class="children"><div class="content">The article claims that an allocator that splits memory based on allocation size is called a &quot;buddy allocator&quot;. That&#x27;s misleading: an allocator that allocates an area for each size class is usually called a &quot;slab allocator&quot;, while a &quot;buddy allocator&quot; is one that when needed subdivides a memory area with a power of two size into two half-sized areas that are &quot;buddies&quot;, does so recursively to satisfy allocations, and coalesces them again when they are free.<p>E.g. the Linux kernel used (not sure if it&#x27;s still like this) a buddy allocator to allocate pages and power-of-two blocks of pages and slab allocators to subdivide those pages and allocate data structures.<p>Another thing that the article doesn&#x27;t mention that is important is that most production allocators make use of thread-local storage and either have per-thread caches of free blocks or sometimes whole per-thread memory regions. This is to reduce lock contention and provide memory that is more likely to be in the current core&#x27;s cache.</div><br/><div id="36030844" class="c"><input type="checkbox" id="c-36030844" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36030782">parent</a><span>|</span><a href="#36034337">next</a><span>|</span><label class="collapse" for="c-36030844">[-]</label><label class="expand" for="c-36030844">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely right, I&#x27;ve corrected this. Thank you!<p>I had originally written about threading and locality but it made the post too long and complicated, so I cut it out for the final draft. You can see remnants of it if you check the HTML comments in the post :D</div><br/></div></div><div id="36034337" class="c"><input type="checkbox" id="c-36034337" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#36030782">parent</a><span>|</span><a href="#36030844">prev</a><span>|</span><a href="#36029902">next</a><span>|</span><label class="collapse" for="c-36034337">[-]</label><label class="expand" for="c-36034337">[2 more]</label></div><br/><div class="children"><div class="content">linux had a bitmap based &quot;buddy allocator&quot; (power of two), now it is not bitmap based anymore (complexity not worth it anymore, performance wise, namely simplicty was restored).<p>Then linux has various slabs(slub&#x2F;slob&#x2F;slab), built on top of the &quot;buddy allocator&quot;.<p>Userlevel code shoud use non virtual address stable mmap-ed regions (slabs + offsets). Legacy &quot;libc&quot; services were built as virtual address stable services... which are kind of expensive to manage on a modern paginated system. Virtual address stable regions should be kept to a minimum (that horrible ELF static TLS). There is a workaround though (but linux overcommit default policy could kill your process): a user process would query the amount of ram on the system and mmap a region of roughly (care of the overcommit policy) the same size, only once per process life-time. Then you could have a virtual address stable region which could use most if not all the available ram (excluding hot-memory addition...). Should be very easy to manage with lists.</div><br/><div id="36041300" class="c"><input type="checkbox" id="c-36041300" checked=""/><div class="controls bullet"><span class="by">ogurechny</span><span>|</span><a href="#36030782">root</a><span>|</span><a href="#36034337">parent</a><span>|</span><a href="#36029902">next</a><span>|</span><label class="collapse" for="c-36041300">[-]</label><label class="expand" for="c-36041300">[1 more]</label></div><br/><div class="children"><div class="content">In this case, one should start with implementing -Xmx switch, then gradually adding the rest.</div><br/></div></div></div></div></div></div><div id="36029902" class="c"><input type="checkbox" id="c-36029902" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#36030782">prev</a><span>|</span><a href="#36032726">next</a><span>|</span><label class="collapse" for="c-36029902">[-]</label><label class="expand" for="c-36029902">[16 more]</label></div><br/><div class="children"><div class="content">This is absolute gold. When I use things like this, I am reminded how powerful digital learning can be. So much more capable then just text or video. But very little content is this well put together. Probably because it is so time intensive.</div><br/><div id="36029939" class="c"><input type="checkbox" id="c-36029939" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36029902">parent</a><span>|</span><a href="#36031015">next</a><span>|</span><label class="collapse" for="c-36029939">[-]</label><label class="expand" for="c-36029939">[12 more]</label></div><br/><div class="children"><div class="content">This feedback has made my day. Thank you.<p>I&#x27;m inspired by Bartosz Ciechanowski and Julia Evans. The web is such a powerful toolbox. So many concepts are more complex than text alone can hope to explain. Those two are so creative and full of energy.<p>And you&#x27;re right, it&#x27;s incredibly time intensive to put these together. Thousands of lines of code, plus the text content, plus reaching out to domain experts for reviews (shout out Chris Down, kernel wizard extraordinaire).</div><br/><div id="36032760" class="c"><input type="checkbox" id="c-36032760" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029939">parent</a><span>|</span><a href="#36032057">next</a><span>|</span><label class="collapse" for="c-36032760">[-]</label><label class="expand" for="c-36032760">[1 more]</label></div><br/><div class="children"><div class="content">Such great work. I learned things and have a clearer understanding that I think I will come back to in the future. And I say that as someone who has programmed for 15 years! I think your effort paid off, and the inspiration shows through.</div><br/></div></div><div id="36032057" class="c"><input type="checkbox" id="c-36032057" checked=""/><div class="controls bullet"><span class="by">couchand</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029939">parent</a><span>|</span><a href="#36032760">prev</a><span>|</span><a href="#36029978">next</a><span>|</span><label class="collapse" for="c-36032057">[-]</label><label class="expand" for="c-36032057">[1 more]</label></div><br/><div class="children"><div class="content">One more name I&#x27;dd add to this list is Mike Bostock. The care and attention he gives to  data visualization examples comes through in the finished product.<p>Communicating complex subjects through interactive visual displays is very effective -- it&#x27;s worth the effort. Thank you!</div><br/></div></div><div id="36029978" class="c"><input type="checkbox" id="c-36029978" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029939">parent</a><span>|</span><a href="#36032057">prev</a><span>|</span><a href="#36038395">next</a><span>|</span><label class="collapse" for="c-36029978">[-]</label><label class="expand" for="c-36029978">[2 more]</label></div><br/><div class="children"><div class="content">Also shout out Anton Verinov (<a href="https:&#x2F;&#x2F;anton.codes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;anton.codes&#x2F;</a>): the only reason this web page doesn&#x27;t drain your battery before you get to the end of it.</div><br/><div id="36030669" class="c"><input type="checkbox" id="c-36030669" checked=""/><div class="controls bullet"><span class="by">rozularen</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029978">parent</a><span>|</span><a href="#36038395">next</a><span>|</span><label class="collapse" for="c-36030669">[-]</label><label class="expand" for="c-36030669">[1 more]</label></div><br/><div class="children"><div class="content">why is it mind you?</div><br/></div></div></div></div><div id="36038395" class="c"><input type="checkbox" id="c-36038395" checked=""/><div class="controls bullet"><span class="by">pvorb</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029939">parent</a><span>|</span><a href="#36029978">prev</a><span>|</span><a href="#36034188">next</a><span>|</span><label class="collapse" for="c-36038395">[-]</label><label class="expand" for="c-36038395">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a nice little example for &quot;Explorable Explanations&quot;, a term coined by Bret Victor in his eponymous essay[1] from 2011.<p>[1]: <a href="http:&#x2F;&#x2F;worrydream.com&#x2F;ExplorableExplanations&#x2F;" rel="nofollow">http:&#x2F;&#x2F;worrydream.com&#x2F;ExplorableExplanations&#x2F;</a></div><br/><div id="36039018" class="c"><input type="checkbox" id="c-36039018" checked=""/><div class="controls bullet"><span class="by">BHSPitMonkey</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36038395">parent</a><span>|</span><a href="#36034188">next</a><span>|</span><label class="collapse" for="c-36039018">[-]</label><label class="expand" for="c-36039018">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been admiring this trend since I started seeing these kinds of essays posted here, and felt motivated to start collecting them in a curated list[0]. Happy to accept new entries or volunteers to help maintain it!<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;BHSPitMonkey&#x2F;awesome-explanations">https:&#x2F;&#x2F;github.com&#x2F;BHSPitMonkey&#x2F;awesome-explanations</a></div><br/><div id="36040640" class="c"><input type="checkbox" id="c-36040640" checked=""/><div class="controls bullet"><span class="by">rents</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36039018">parent</a><span>|</span><a href="#36034188">next</a><span>|</span><label class="collapse" for="c-36040640">[-]</label><label class="expand" for="c-36040640">[2 more]</label></div><br/><div class="children"><div class="content">This links does not work, typo?</div><br/><div id="36041286" class="c"><input type="checkbox" id="c-36041286" checked=""/><div class="controls bullet"><span class="by">BHSPitMonkey</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36040640">parent</a><span>|</span><a href="#36034188">next</a><span>|</span><label class="collapse" for="c-36041286">[-]</label><label class="expand" for="c-36041286">[1 more]</label></div><br/><div class="children"><div class="content">Forgot to make it public. Fixed now!</div><br/></div></div></div></div></div></div></div></div><div id="36034188" class="c"><input type="checkbox" id="c-36034188" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029939">parent</a><span>|</span><a href="#36038395">prev</a><span>|</span><a href="#36031057">next</a><span>|</span><label class="collapse" for="c-36034188">[-]</label><label class="expand" for="c-36034188">[2 more]</label></div><br/><div class="children"><div class="content">The writing is very clear and the concepts are explained well.  Not too much information and not too little.  Excellent post.</div><br/><div id="36034558" class="c"><input type="checkbox" id="c-36034558" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36034188">parent</a><span>|</span><a href="#36031057">next</a><span>|</span><label class="collapse" for="c-36034558">[-]</label><label class="expand" for="c-36034558">[1 more]</label></div><br/><div class="children"><div class="content">Deja vu. :D</div><br/></div></div></div></div><div id="36031057" class="c"><input type="checkbox" id="c-36031057" checked=""/><div class="controls bullet"><span class="by">naillo</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36029939">parent</a><span>|</span><a href="#36034188">prev</a><span>|</span><a href="#36031015">next</a><span>|</span><label class="collapse" for="c-36031057">[-]</label><label class="expand" for="c-36031057">[1 more]</label></div><br/><div class="children"><div class="content">Great job Sam</div><br/></div></div></div></div><div id="36031015" class="c"><input type="checkbox" id="c-36031015" checked=""/><div class="controls bullet"><span class="by">dmd</span><span>|</span><a href="#36029902">parent</a><span>|</span><a href="#36029939">prev</a><span>|</span><a href="#36031431">next</a><span>|</span><label class="collapse" for="c-36031015">[-]</label><label class="expand" for="c-36031015">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re not yet familiar with it - <a href="https:&#x2F;&#x2F;ciechanow.ski&#x2F;archives&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ciechanow.ski&#x2F;archives&#x2F;</a> is for you (and everyone!)</div><br/><div id="36031038" class="c"><input type="checkbox" id="c-36031038" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36029902">root</a><span>|</span><a href="#36031015">parent</a><span>|</span><a href="#36031431">next</a><span>|</span><label class="collapse" for="c-36031038">[-]</label><label class="expand" for="c-36031038">[1 more]</label></div><br/><div class="children"><div class="content">The master of this artform.</div><br/></div></div></div></div><div id="36031431" class="c"><input type="checkbox" id="c-36031431" checked=""/><div class="controls bullet"><span class="by">throwaway689236</span><span>|</span><a href="#36029902">parent</a><span>|</span><a href="#36031015">prev</a><span>|</span><a href="#36032726">next</a><span>|</span><label class="collapse" for="c-36031431">[-]</label><label class="expand" for="c-36031431">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I wish I had more thing like this growing up.</div><br/></div></div></div></div><div id="36032726" class="c"><input type="checkbox" id="c-36032726" checked=""/><div class="controls bullet"><span class="by">OliverJones</span><span>|</span><a href="#36029902">prev</a><span>|</span><a href="#36038295">next</a><span>|</span><label class="collapse" for="c-36032726">[-]</label><label class="expand" for="c-36032726">[1 more]</label></div><br/><div class="children"><div class="content">Oh man, this brings back the days when I wrote special debug-version malloc and free code to try to track down heap corruption due to malloc &#x2F; free misuse (in code I had contributed to). Stuff like kbyte-long boundary buffers with bit patterns in them, and all sorts of lookaside lists run in parallel with libc&#x27;s default code. Those bug-detectors worked OK. Hard-nosed code inspection worked far better.<p>As an old-timer in writing code, I think my generation&#x27;s most-challenging legacies (=== the things we f**ked up) are the non-robust malloc&#x2F;free concept and null-terminated text strings. Bugs in code using those conventions have been exploitable to a really damaging extent.  I learned to program in C from K&amp;R. And getting data-structure code right, and safe to deploy, in that language and its derivatives is HARD.<p>The C inventors are (were in Dennis Ritchie&#x27;s case) brilliant and Bell Labs was great.  Their ideas shaped the the stuff the global internet runs on.  But these parts of what thy invented .....  ouch.  (All OSs had the same problems.)<p>I wish the wonderful article presented here carried a more prominent warning about this. Many will read it as they learn to code. The history of our profession can teach about what NOT to do as well as what to do.</div><br/></div></div><div id="36038295" class="c"><input type="checkbox" id="c-36038295" checked=""/><div class="controls bullet"><span class="by">Damogran6</span><span>|</span><a href="#36032726">prev</a><span>|</span><a href="#36029853">next</a><span>|</span><label class="collapse" for="c-36038295">[-]</label><label class="expand" for="c-36038295">[1 more]</label></div><br/><div class="children"><div class="content">Not really related, but the feeling of elation when I alloc&#x27;d 1M of RAM in OS&#x2F;2 and it _didn&#x27;t_ swap changed me.<p>This was on a 386sx with 8M RAM and it was pretty much all the available memory after the OS was loaded and settled down.<p>A MILLION BYTES!!<p>Didn&#x27;t do anything with it, but still, after DOS and EMS&#x2F;XMS memory and all the other falderol of managing memory. (At the time, it was also the only x86 OS that would format a floppy drive without bringing all the other threads to a crawl. UI was still available-ish, BiModem was still BiModeming...</div><br/></div></div><div id="36029853" class="c"><input type="checkbox" id="c-36029853" checked=""/><div class="controls bullet"><span class="by">thecoppinger</span><span>|</span><a href="#36038295">prev</a><span>|</span><a href="#36029865">next</a><span>|</span><label class="collapse" for="c-36029853">[-]</label><label class="expand" for="c-36029853">[2 more]</label></div><br/><div class="children"><div class="content">All credit goes to my wonderful friend Sam Who: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;samwhoo" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;samwhoo</a><p>He recently published a similar guide on load balancing that is equally intuitive and insightful: <a href="https:&#x2F;&#x2F;samwho.dev&#x2F;load-balancing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;samwho.dev&#x2F;load-balancing&#x2F;</a><p>I can&#x27;t wait to see what he puts out next!</div><br/><div id="36031964" class="c"><input type="checkbox" id="c-36031964" checked=""/><div class="controls bullet"><span class="by">terrycody</span><span>|</span><a href="#36029853">parent</a><span>|</span><a href="#36029865">next</a><span>|</span><label class="collapse" for="c-36031964">[-]</label><label class="expand" for="c-36031964">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35588797" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35588797</a><p>We never missed good things lol!</div><br/></div></div></div></div><div id="36029865" class="c"><input type="checkbox" id="c-36029865" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36029853">prev</a><span>|</span><a href="#36032708">next</a><span>|</span><label class="collapse" for="c-36029865">[-]</label><label class="expand" for="c-36029865">[8 more]</label></div><br/><div class="children"><div class="content">Thank you for this, this is helpful.<p>I wrote a JIT compiler and I didn&#x27;t bother calling free much, I just let the operating system free up all allocated memory.<p>I got into this situation often:<p><pre><code>   return_struct = do_something(mystruct);
   return_struct-&gt;inner_struct = malloc(sizeof(struct my_inner_struct));
</code></pre>
Now, who owns inner_struct? Who is responsible for freeing it? Do I free it when I assign to it?<p>I feel this ownership complicates cross-language FFI API calls, because who is responsible for freeing structures depends on the application and the platform you&#x27;re running under. For example, Rust code being called from Erlang. You have to be extra careful when memory is managed by a different language runtime.<p>I feel I am at the beginning of intuitively understanding what memory really is: memory is just a huge contiguous region of numbered locations. Bump allocators allocate in one direction and free all at once. Arena allocators allocate to a preallocated region, I think.<p>Memory is a logistical problem of how you arrange and allocate finite resources.<p>I am thinking of alternative visualizations of understanding memory, for example, I started writing an animation of binary search:<p><a href="https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;ProgrammingRTS">https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;ProgrammingRTS</a><p>The idea is that you see values and memory locations move around with the final goal being able to command memory to move around and be computed, such as real time strategy game.<p>I think if we could visualise memory as cars on a road, we would see obvious traffic jams.</div><br/><div id="36030142" class="c"><input type="checkbox" id="c-36030142" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36029865">parent</a><span>|</span><a href="#36032188">next</a><span>|</span><label class="collapse" for="c-36030142">[-]</label><label class="expand" for="c-36030142">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I hear you. I&#x27;ve not done a lot of FFI stuff directly, it scares me.<p>Arena allocators are cool, the idea is you allocate a large-ish region of memory and sub-allocate into it (often with a fast, simple allocator like a bump allocator) and then free the large-ish block when you&#x27;re done. It&#x27;s a way to take knowing how much memory you need as a whole and optimise that to a single call to malloc&#x2F;free.<p>You may enjoy looking through <a href="https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.ht...</a>.</div><br/><div id="36030229" class="c"><input type="checkbox" id="c-36030229" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36029865">root</a><span>|</span><a href="#36030142">parent</a><span>|</span><a href="#36032188">next</a><span>|</span><label class="collapse" for="c-36030229">[-]</label><label class="expand" for="c-36030229">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link to the animations.<p>I want an extremely performant deep copy solution, I&#x27;ve been thinking of using an allocator to implement it.<p>If we have a tree data structure or a nested hashmap, then we want to copy it cheaply, there is copy on write. But most copies of hashmaps are slow because they instantiate every child object in a recursive loop.<p>So I want to be able to memcpy a complicated data structure for cheap copies.</div><br/></div></div></div></div><div id="36032188" class="c"><input type="checkbox" id="c-36032188" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#36029865">parent</a><span>|</span><a href="#36030142">prev</a><span>|</span><a href="#36031772">next</a><span>|</span><label class="collapse" for="c-36032188">[-]</label><label class="expand" for="c-36032188">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I feel I am at the beginning of intuitively understanding what memory really is: memory is just a huge contiguous region of numbered locations.<p>There might be an analogy here that could help you reason about your nested structure allocationsâ¦<p>Memory is an array of bytes owned by the OS. While there are all kinds of implementation details about addressing and storage and performance and paging and virtual memory, itâs really just an array. The OS gives you a way to reserve pieces of the array for your own use, and youâre responsible for giving them back if you want to play nice and&#x2F;or run for a long time, otherwise (as a safety net) the OS will take them back as soon as you exit.<p>This is, in a sense, very similar to the question you posed. An outer routine owns the outer structure, and an inner routine allocates some inner structure. The simplest, most intuitive, and generally best advice is that whoever allocates is also responsible for freeing memory. In other words, one way to <i>define</i> ownership of memory is by who allocates it. Implicitly and automatically the responsibility to free that memory belongs to owner that allocated it. Itâs okay to explicitly transfer ownership, but can easily get complicated and unintuitive. You can also consider letting the parent free your struct to be similar to not calling free() in your JIT compiler - itâs a âlazyâ optimization to have the parent clean up - and I donât mean that in a judgemental sense, I mean itâs valid to let the parent handle it, if you know that it will, and this can be done without getting confused about who owns the memory and who was actually responsible for freeing it. Note that when you leave the parent to clean it up, you are foregoing the ability to re-use the memory - this is true in your JIT compiler and itâs true for malloc() and free() as well. If you let the OS handle it, youâre in effect declaring that you believe you do not need to recycle the memory allocated in your program during itâs execution. (This might be true, and it might stay that way, but itâs always worth asking if it will remain true, since lots of people have been eventually bitten and had to retroactively refactor for memory management when their requirements change.)</div><br/></div></div><div id="36031772" class="c"><input type="checkbox" id="c-36031772" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#36029865">parent</a><span>|</span><a href="#36032188">prev</a><span>|</span><a href="#36030176">next</a><span>|</span><label class="collapse" for="c-36031772">[-]</label><label class="expand" for="c-36031772">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You have to be extra careful when memory is managed by a different language runtime.<p>While it would be <i>nice</i> to have next to no overhead for FFI, it&#x27;s not always tractable. That&#x27;s why you have to serialize across boundaries, the same as if you&#x27;re serializing across processes or the network. At least in a single virtual memory space you can have a caller allocate a buffer and the callee fill it, with the caller being responsible for deserializing and freeing later. That gets you pretty far, and is relatively safe.<p>The alternative is to be callee managed, and for the callee to return things by handle and not necessarily by pointer, but that is also fraught.</div><br/></div></div><div id="36030176" class="c"><input type="checkbox" id="c-36030176" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#36029865">parent</a><span>|</span><a href="#36031772">prev</a><span>|</span><a href="#36038371">next</a><span>|</span><label class="collapse" for="c-36030176">[-]</label><label class="expand" for="c-36030176">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Now, who owns inner_struct?<p>return_struct does since it is the only thing that knows the address.<p>&gt; Who is responsible for freeing it?<p>return_struct is, unless you hand that responsibility over to something else.<p>&gt; Do I free it when I assign to it?<p>Yes, unless you want leaks.<p>&gt; I think if we could visualise memory as cars on a road, we would see obvious traffic jams.<p>That visualisation is helpful for threads, where the program is the road&#x2F;map and the cars are the threads. I don&#x27;t see how it&#x27;s useful for memory.</div><br/><div id="36037601" class="c"><input type="checkbox" id="c-36037601" checked=""/><div class="controls bullet"><span class="by">jacobsenscott</span><span>|</span><a href="#36029865">root</a><span>|</span><a href="#36030176">parent</a><span>|</span><a href="#36038371">next</a><span>|</span><label class="collapse" for="c-36037601">[-]</label><label class="expand" for="c-36037601">[1 more]</label></div><br/><div class="children"><div class="content">A struct can&#x27;t own something - it isn&#x27;t a class with a destructor or anything. So it isn&#x27;t quite so obvious. There are only two lines of code here, but the implication is a function is running that code and then returning `return_struct`, which might get passed around to more functions, and even returned further up the call stack. Somewhere there needs to be code that knows &quot;hey - nobody else is using return_struct, and by the way you need to free return_struct-&gt;inner_struct before freeing return_struct.</div><br/></div></div></div></div><div id="36038371" class="c"><input type="checkbox" id="c-36038371" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36029865">parent</a><span>|</span><a href="#36030176">prev</a><span>|</span><a href="#36032708">next</a><span>|</span><label class="collapse" for="c-36038371">[-]</label><label class="expand" for="c-36038371">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly why you should use reference counting</div><br/></div></div></div></div><div id="36032708" class="c"><input type="checkbox" id="c-36032708" checked=""/><div class="controls bullet"><span class="by">jesselawson</span><span>|</span><a href="#36029865">prev</a><span>|</span><a href="#36030043">next</a><span>|</span><label class="collapse" for="c-36032708">[-]</label><label class="expand" for="c-36032708">[1 more]</label></div><br/><div class="children"><div class="content">Sam, this is such a wonderful resource that you&#x27;ve put out into the world. Thank you for the time and care you&#x27;ve put into each paragraph and interactive component. You&#x27;ve not only given me a lot to think about in terms of my basic assumptions about memory, but also about how to write and teach better online. I&#x27;m really excited to start following you!</div><br/></div></div><div id="36030043" class="c"><input type="checkbox" id="c-36030043" checked=""/><div class="controls bullet"><span class="by">davidgrenier</span><span>|</span><a href="#36032708">prev</a><span>|</span><a href="#36033871">next</a><span>|</span><label class="collapse" for="c-36030043">[-]</label><label class="expand" for="c-36030043">[17 more]</label></div><br/><div class="children"><div class="content">The only thing that confused me is how it said we can know the location of the block after and before by calculating:<p><pre><code>    address + &lt;value at address&gt;
    address - &lt;value at address-1&gt;
</code></pre>
Shouldn&#x27;t this be?<p><pre><code>    address + &lt;value at address&gt; + 3
    address - &lt;value at address-1&gt; - 3</code></pre></div><br/><div id="36030056" class="c"><input type="checkbox" id="c-36030056" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36030043">parent</a><span>|</span><a href="#36032194">next</a><span>|</span><label class="collapse" for="c-36030056">[-]</label><label class="expand" for="c-36030056">[15 more]</label></div><br/><div class="children"><div class="content">Well shit. I think you&#x27;re right.</div><br/><div id="36030094" class="c"><input type="checkbox" id="c-36030094" checked=""/><div class="controls bullet"><span class="by">davidgrenier</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030056">parent</a><span>|</span><a href="#36030067">next</a><span>|</span><label class="collapse" for="c-36030094">[-]</label><label class="expand" for="c-36030094">[13 more]</label></div><br/><div class="children"><div class="content">Oh another thing, I&#x27;m not a fan of the premise:<p>&quot;As a general-purpose memory allocator, though, we can&#x27;t get away with having no free implementation.&quot;<p>I have a belief that the future of software are short-lived programs that never free memory. Programs allocate and terminate. Short-lived program communicate with each other via blocking CSP-style channels (see Reppy&#x27;s Concurrent Programming in ML).<p>If you could also educate me on why this is a bad idea I would appreciate.</div><br/><div id="36030334" class="c"><input type="checkbox" id="c-36030334" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36037689">next</a><span>|</span><label class="collapse" for="c-36030334">[-]</label><label class="expand" for="c-36030334">[1 more]</label></div><br/><div class="children"><div class="content">My first large scale web application was a webmail service built in C++ (!) where I early on decided we&#x27;d ditch <i>nearly</i> all freeing of memory, as it was running as a CGI, and it was much faster to just let the OS free memory on termination. The exception was for any particularly large buffers. Coupled with statically linking it, it reduced the overhead sufficiently that running it as a CGI performed well enough to save us the massive pain of guaranteeing sufficient isolation and ensuring we were free of memory leaks.<p><i>Especially</i> in a request&#x2F;reply style environment, long running application servers is largely a workaround for high startup costs, and it&#x27;s only a &quot;bad idea&quot; in the instances where removing that high startup cost is too difficult to be practical. Overall I love avoiding long running programs.</div><br/></div></div><div id="36037689" class="c"><input type="checkbox" id="c-36037689" checked=""/><div class="controls bullet"><span class="by">jacobsenscott</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36030334">prev</a><span>|</span><a href="#36030243">next</a><span>|</span><label class="collapse" for="c-36037689">[-]</label><label class="expand" for="c-36037689">[1 more]</label></div><br/><div class="children"><div class="content">I suspect this would cause the same performance issues as a long running application that constantly malloc&#x27;d and free&#x27;d memory? Many application runtimes allocate but don&#x27;t free memory - they just reuse it internally - for this reason. For example in a ruby application you&#x27;ll see memory usage climb after boot, and eventually level off when it has all it will need for its lifetime, but never go down.</div><br/></div></div><div id="36030243" class="c"><input type="checkbox" id="c-36030243" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36037689">prev</a><span>|</span><a href="#36036130">next</a><span>|</span><label class="collapse" for="c-36030243">[-]</label><label class="expand" for="c-36030243">[1 more]</label></div><br/><div class="children"><div class="content">I agree with your point but disagree with your reasoning. I think programs should always free memory at <i>some point</i> because then it&#x27;s easier to reason about debugging memory leaks.<p>Practically speaking though, there <i>are</i> arena allocators that do exactly this - you allocate a bunch of memory at once, assign like-typed instances to &quot;slots&quot; in that memory region, and then deallocate everything all at once. Thus, the individual instance `free()` is a no-op.</div><br/></div></div><div id="36036130" class="c"><input type="checkbox" id="c-36036130" checked=""/><div class="controls bullet"><span class="by">e_y_</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36030243">prev</a><span>|</span><a href="#36034210">next</a><span>|</span><label class="collapse" for="c-36036130">[-]</label><label class="expand" for="c-36036130">[1 more]</label></div><br/><div class="children"><div class="content">This would probably be something closer to actors (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Actor_model" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Actor_model</a>) rather than programs since programs are traditionally implemented as OS processes which are relatively expensive to spin up and terminate. At some level, though, <i>somebody</i> has to deal with freeing the memory, and they may do it less efficiently than you can.</div><br/></div></div><div id="36034210" class="c"><input type="checkbox" id="c-36034210" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36036130">prev</a><span>|</span><a href="#36030325">next</a><span>|</span><label class="collapse" for="c-36034210">[-]</label><label class="expand" for="c-36034210">[1 more]</label></div><br/><div class="children"><div class="content">With a simple enough allocator, freeing things could maybe even be beneficial even for short-lived programs, purely from the memory being in cache already, instead of needing to ask the OS for more (incl. page faulting &amp; zeroing, besides being limited by RAM throughput). For a buddy allocator without coalescing, a free() that just adds the argument to the corresponding freelist can be as simple as 5 or so x86-64 instructions (the fast path of the allocator being ~8 or so instructions; certainly more than a bump allocator, but not by much, and the reuse benefits can easily be pretty big).</div><br/></div></div><div id="36030325" class="c"><input type="checkbox" id="c-36030325" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36034210">prev</a><span>|</span><a href="#36033948">next</a><span>|</span><label class="collapse" for="c-36030325">[-]</label><label class="expand" for="c-36030325">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not general purpose, and lots of programs that were designed to be short-lived often end up not being so in the future. People used to point at compilers as a typical example of this kind of thing, well, now we have compilers as libraries sitting resident in every popular developer tool.</div><br/></div></div><div id="36033948" class="c"><input type="checkbox" id="c-36033948" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36030325">prev</a><span>|</span><a href="#36030112">next</a><span>|</span><label class="collapse" for="c-36033948">[-]</label><label class="expand" for="c-36033948">[1 more]</label></div><br/><div class="children"><div class="content">My take on this is that code should always match up malloc and free, but your application may use an allocator where free is noop, if that&#x27;s appropriate for the application you write. This way your code is more generic and can be reused in an other application with different constraints.<p>And as soon as you are replacing free, you can replace malloc as well to be optimized for your use case. No need to build difficult bookkeeping hierarchies when they will never get used.</div><br/></div></div><div id="36030112" class="c"><input type="checkbox" id="c-36030112" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36033948">prev</a><span>|</span><a href="#36035484">next</a><span>|</span><label class="collapse" for="c-36030112">[-]</label><label class="expand" for="c-36030112">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny, I saw and retweeted this while writing this post: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;samwhoo&#x2F;status&#x2F;1650572915770036225?s=20" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;samwhoo&#x2F;status&#x2F;1650572915770036225?s=20</a><p>Not sure the future you describe is where we&#x27;ll end up, haven&#x27;t given it a huge amount of thought. Would be interesting to see, though.<p>Things like web servers could probably get away with doing some sort of arena allocation per request (I&#x27;d be surprised if some don&#x27;t already do this).</div><br/><div id="36030297" class="c"><input type="checkbox" id="c-36030297" checked=""/><div class="controls bullet"><span class="by">williamcotton</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030112">parent</a><span>|</span><a href="#36035484">next</a><span>|</span><label class="collapse" for="c-36030297">[-]</label><label class="expand" for="c-36030297">[1 more]</label></div><br/><div class="children"><div class="content">Apache does this! And I do this in my own C web framework:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;williamcotton&#x2F;express-c&#x2F;blob&#x2F;master&#x2F;deps&#x2F;memory-manager&#x2F;memory-manager.c">https:&#x2F;&#x2F;github.com&#x2F;williamcotton&#x2F;express-c&#x2F;blob&#x2F;master&#x2F;deps&#x2F;...</a></div><br/></div></div></div></div><div id="36035484" class="c"><input type="checkbox" id="c-36035484" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36030112">prev</a><span>|</span><a href="#36032024">next</a><span>|</span><label class="collapse" for="c-36035484">[-]</label><label class="expand" for="c-36035484">[2 more]</label></div><br/><div class="children"><div class="content">So basically garbage collection via just terminating and letting the OS handle it?</div><br/><div id="36038274" class="c"><input type="checkbox" id="c-36038274" checked=""/><div class="controls bullet"><span class="by">davidgrenier</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36035484">parent</a><span>|</span><a href="#36032024">next</a><span>|</span><label class="collapse" for="c-36038274">[-]</label><label class="expand" for="c-36038274">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is what Ur&#x2F;Web does albeit this is limited to Web Server requests. I&#x27;d argue all programs could be short lived and memory management becomes a matter of sizing program&#x27;s scope&#x2F;role to the amount of memory you can greedily consume. Certainly many sorting program (for e.g.) can leak until they terminate. Then, cheap instantiation and communication between programs.</div><br/></div></div></div></div><div id="36032024" class="c"><input type="checkbox" id="c-36032024" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030094">parent</a><span>|</span><a href="#36035484">prev</a><span>|</span><a href="#36030067">next</a><span>|</span><label class="collapse" for="c-36032024">[-]</label><label class="expand" for="c-36032024">[1 more]</label></div><br/><div class="children"><div class="content">Even if the programs don&#x27;t free memory, something has to allocate and free memory for the programs and channels.</div><br/></div></div></div></div><div id="36030067" class="c"><input type="checkbox" id="c-36030067" checked=""/><div class="controls bullet"><span class="by">davidgrenier</span><span>|</span><a href="#36030043">root</a><span>|</span><a href="#36030056">parent</a><span>|</span><a href="#36030094">prev</a><span>|</span><a href="#36032194">next</a><span>|</span><label class="collapse" for="c-36030067">[-]</label><label class="expand" for="c-36030067">[1 more]</label></div><br/><div class="children"><div class="content">Well otherwise, I learned a lot and the basics are much simpler than I expected, thank you for the article.</div><br/></div></div></div></div><div id="36032194" class="c"><input type="checkbox" id="c-36032194" checked=""/><div class="controls bullet"><span class="by">ho_schi</span><span>|</span><a href="#36030043">parent</a><span>|</span><a href="#36030056">prev</a><span>|</span><a href="#36033871">next</a><span>|</span><label class="collapse" for="c-36032194">[-]</label><label class="expand" for="c-36032194">[1 more]</label></div><br/><div class="children"><div class="content">This also trapped me.</div><br/></div></div></div></div><div id="36033871" class="c"><input type="checkbox" id="c-36033871" checked=""/><div class="controls bullet"><span class="by">ftxbro</span><span>|</span><a href="#36030043">prev</a><span>|</span><a href="#36033511">next</a><span>|</span><label class="collapse" for="c-36033871">[-]</label><label class="expand" for="c-36033871">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;There&#x27;s no shortage of information about memory allocators on the Internet, and if you&#x27;ve read this far you should be well-placed to dive in to it.
Join the discussion on Hacker News! <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36029087" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36029087</a> &quot;<p>Interesting to use hacker news as the blog&#x27;s own comment section in this way.</div><br/><div id="36035801" class="c"><input type="checkbox" id="c-36035801" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36033871">parent</a><span>|</span><a href="#36033511">next</a><span>|</span><label class="collapse" for="c-36035801">[-]</label><label class="expand" for="c-36035801">[1 more]</label></div><br/><div class="children"><div class="content">Iâve seen a few people doing it, seems to work well.</div><br/></div></div></div></div><div id="36033511" class="c"><input type="checkbox" id="c-36033511" checked=""/><div class="controls bullet"><span class="by">CliffStoll</span><span>|</span><a href="#36033871">prev</a><span>|</span><a href="#36033187">next</a><span>|</span><label class="collapse" for="c-36033511">[-]</label><label class="expand" for="c-36033511">[1 more]</label></div><br/><div class="children"><div class="content">A delightful page, written in a wonderfully interactive way.<p>My high congratulations for creating a most friendly, readable and useful lesson!</div><br/></div></div><div id="36033187" class="c"><input type="checkbox" id="c-36033187" checked=""/><div class="controls bullet"><span class="by">FrankyHollywood</span><span>|</span><a href="#36033511">prev</a><span>|</span><a href="#36030214">next</a><span>|</span><label class="collapse" for="c-36033187">[-]</label><label class="expand" for="c-36033187">[1 more]</label></div><br/><div class="children"><div class="content">This is a nice read too (the whole blog actually)<p><a href="http:&#x2F;&#x2F;igoro.com&#x2F;archive&#x2F;volatile-keyword-in-c-memory-model-explained&#x2F;" rel="nofollow">http:&#x2F;&#x2F;igoro.com&#x2F;archive&#x2F;volatile-keyword-in-c-memory-model-...</a><p>It&#x27;s a bit old by now (2010), but I always remembered the mental model Igor created.</div><br/></div></div><div id="36030214" class="c"><input type="checkbox" id="c-36030214" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36033187">prev</a><span>|</span><a href="#36040217">next</a><span>|</span><label class="collapse" for="c-36030214">[-]</label><label class="expand" for="c-36030214">[6 more]</label></div><br/><div class="children"><div class="content">Seems to be a bug on the first interactive graph, at least for me. Unless I&#x27;m misunderstanding the point of the graph, `malloc(7)` only allocates 2 bytes.</div><br/><div id="36030280" class="c"><input type="checkbox" id="c-36030280" checked=""/><div class="controls bullet"><span class="by">ozfive</span><span>|</span><a href="#36030214">parent</a><span>|</span><a href="#36030327">next</a><span>|</span><label class="collapse" for="c-36030280">[-]</label><label class="expand" for="c-36030280">[3 more]</label></div><br/><div class="children"><div class="content">I came here to see if anyone else noticed this and am confirming that there is a bug in the first slider on malloc(7). Indeed it only allocates two bytes instead of seven.</div><br/><div id="36030318" class="c"><input type="checkbox" id="c-36030318" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36030214">root</a><span>|</span><a href="#36030280">parent</a><span>|</span><a href="#36030327">next</a><span>|</span><label class="collapse" for="c-36030318">[-]</label><label class="expand" for="c-36030318">[2 more]</label></div><br/><div class="children"><div class="content">Good spot! Thank you. Fix on its way out now. :)</div><br/><div id="36033806" class="c"><input type="checkbox" id="c-36033806" checked=""/><div class="controls bullet"><span class="by">ozfive</span><span>|</span><a href="#36030214">root</a><span>|</span><a href="#36030318">parent</a><span>|</span><a href="#36030327">next</a><span>|</span><label class="collapse" for="c-36033806">[-]</label><label class="expand" for="c-36033806">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for building this! It&#x27;s helped a lot for me to wrap my head around the concept even more deeply than before.</div><br/></div></div></div></div></div></div><div id="36030327" class="c"><input type="checkbox" id="c-36030327" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#36030214">parent</a><span>|</span><a href="#36030280">prev</a><span>|</span><a href="#36040217">next</a><span>|</span><label class="collapse" for="c-36030327">[-]</label><label class="expand" for="c-36030327">[2 more]</label></div><br/><div class="children"><div class="content">True, it might be cut-off from screen?</div><br/><div id="36030339" class="c"><input type="checkbox" id="c-36030339" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36030214">root</a><span>|</span><a href="#36030327">parent</a><span>|</span><a href="#36040217">next</a><span>|</span><label class="collapse" for="c-36030339">[-]</label><label class="expand" for="c-36030339">[1 more]</label></div><br/><div class="children"><div class="content">Nah, I just failed at basic arithmetic :D<p>I wrote this:<p><pre><code>  &lt;div class=&quot;memory&quot; bytes=&quot;32&quot;&gt;
    &lt;malloc size=&quot;4&quot; addr=&quot;0x0&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;malloc size=&quot;5&quot; addr=&quot;0x4&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;malloc size=&quot;6&quot; addr=&quot;0x9&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;malloc size=&quot;7&quot; addr=&quot;0xa&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;free addr=&quot;0x0&quot;&gt;&lt;&#x2F;free&gt;
    &lt;free addr=&quot;0x4&quot;&gt;&lt;&#x2F;free&gt;
    &lt;free addr=&quot;0x9&quot;&gt;&lt;&#x2F;free&gt;
    &lt;free addr=&quot;0xa&quot;&gt;&lt;&#x2F;free&gt;
  &lt;&#x2F;div&gt;

</code></pre>
Instead of this:<p><pre><code>  &lt;div class=&quot;memory&quot; bytes=&quot;32&quot;&gt;
    &lt;malloc size=&quot;4&quot; addr=&quot;0x0&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;malloc size=&quot;5&quot; addr=&quot;0x4&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;malloc size=&quot;6&quot; addr=&quot;0x9&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;malloc size=&quot;7&quot; addr=&quot;0xf&quot;&gt;&lt;&#x2F;malloc&gt;
    &lt;free addr=&quot;0x0&quot;&gt;&lt;&#x2F;free&gt;
    &lt;free addr=&quot;0x4&quot;&gt;&lt;&#x2F;free&gt;
    &lt;free addr=&quot;0x9&quot;&gt;&lt;&#x2F;free&gt;
    &lt;free addr=&quot;0xf&quot;&gt;&lt;&#x2F;free&gt;
  &lt;&#x2F;div&gt;</code></pre></div><br/></div></div></div></div></div></div><div id="36040217" class="c"><input type="checkbox" id="c-36040217" checked=""/><div class="controls bullet"><span class="by">jackphilson</span><span>|</span><a href="#36030214">prev</a><span>|</span><a href="#36031546">next</a><span>|</span><label class="collapse" for="c-36040217">[-]</label><label class="expand" for="c-36040217">[1 more]</label></div><br/><div class="children"><div class="content">This is the future of learning. You have a skill in it, learn to monetize it. Will benefit both of us, as you are more incentivized to do it if you can make money</div><br/></div></div><div id="36031546" class="c"><input type="checkbox" id="c-36031546" checked=""/><div class="controls bullet"><span class="by">spatter</span><span>|</span><a href="#36040217">prev</a><span>|</span><a href="#36030647">next</a><span>|</span><label class="collapse" for="c-36031546">[-]</label><label class="expand" for="c-36031546">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Others will return what&#x27;s called a &quot;null pointer&quot;, a special pointer that will crash your program if you try to read or write the memory it points to.</i><p>This is not strictly true, it depends on the environment you&#x27;re using. Some older operating systems and some modern embedded systems have memory mapped at the zero address.</div><br/><div id="36040962" class="c"><input type="checkbox" id="c-36040962" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36031546">parent</a><span>|</span><a href="#36030647">next</a><span>|</span><label class="collapse" for="c-36040962">[-]</label><label class="expand" for="c-36040962">[1 more]</label></div><br/><div class="children"><div class="content">If weâre gonna be pedantic, isnât memory mapping itself an optional property? Ie you can have a pointer to 0x00..00 refer to the actual physical bytes at that address, without any mapping, no?</div><br/></div></div></div></div><div id="36030647" class="c"><input type="checkbox" id="c-36030647" checked=""/><div class="controls bullet"><span class="by">jxf</span><span>|</span><a href="#36031546">prev</a><span>|</span><a href="#36040010">next</a><span>|</span><label class="collapse" for="c-36030647">[-]</label><label class="expand" for="c-36030647">[1 more]</label></div><br/><div class="children"><div class="content">A great example of why I&#x27;ll always read a post over watching a video.</div><br/></div></div><div id="36040010" class="c"><input type="checkbox" id="c-36040010" checked=""/><div class="controls bullet"><span class="by">NeuroCoder</span><span>|</span><a href="#36030647">prev</a><span>|</span><a href="#36029689">next</a><span>|</span><label class="collapse" for="c-36040010">[-]</label><label class="expand" for="c-36040010">[1 more]</label></div><br/><div class="children"><div class="content">Love the visualizations. It would be great to have `realloc` covered too but I&#x27;m not sure how much that varies by system, potentially making it too complicated for this sort of post.</div><br/></div></div><div id="36029689" class="c"><input type="checkbox" id="c-36029689" checked=""/><div class="controls bullet"><span class="by">N-Krause</span><span>|</span><a href="#36040010">prev</a><span>|</span><a href="#36032328">next</a><span>|</span><label class="collapse" for="c-36029689">[-]</label><label class="expand" for="c-36029689">[3 more]</label></div><br/><div class="children"><div class="content">It even has a playground! <a href="https:&#x2F;&#x2F;samwho.dev&#x2F;allocator-playground&#x2F;" rel="nofollow">https:&#x2F;&#x2F;samwho.dev&#x2F;allocator-playground&#x2F;</a><p>How I wish I had something like that when I first learned C.</div><br/><div id="36029704" class="c"><input type="checkbox" id="c-36029704" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36029689">parent</a><span>|</span><a href="#36032328">next</a><span>|</span><label class="collapse" for="c-36029704">[-]</label><label class="expand" for="c-36029704">[2 more]</label></div><br/><div class="children"><div class="content">The playground was the inspiration for the post. I always wanted to be able to fiddle with malloc implementations and see how they work in this way.<p>Admittedly the playground is hard to understand at first, and a touch janky in places. But the workloads are taken from for-real malloc&#x2F;free traces on programs!</div><br/><div id="36029772" class="c"><input type="checkbox" id="c-36029772" checked=""/><div class="controls bullet"><span class="by">N-Krause</span><span>|</span><a href="#36029689">root</a><span>|</span><a href="#36029704">parent</a><span>|</span><a href="#36032328">next</a><span>|</span><label class="collapse" for="c-36029772">[-]</label><label class="expand" for="c-36029772">[1 more]</label></div><br/><div class="children"><div class="content">When you think that I (and probably the vast majority of developers) used a pen and a paper for the first few years every time I tried to visualize more complex memory, then that&#x27;s a big upgrade.<p>Especially because you can scroll through all the steps.</div><br/></div></div></div></div></div></div><div id="36032328" class="c"><input type="checkbox" id="c-36032328" checked=""/><div class="controls bullet"><span class="by">jamesgill</span><span>|</span><a href="#36029689">prev</a><span>|</span><a href="#36032189">next</a><span>|</span><label class="collapse" for="c-36032328">[-]</label><label class="expand" for="c-36032328">[5 more]</label></div><br/><div class="children"><div class="content">This is incredibly well done. I&#x27;ve never seen malloc&#x2F;memory allocation explained so clearly. I&#x27;d buy a book written like this.</div><br/><div id="36034466" class="c"><input type="checkbox" id="c-36034466" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36032328">parent</a><span>|</span><a href="#36032189">next</a><span>|</span><label class="collapse" for="c-36034466">[-]</label><label class="expand" for="c-36034466">[4 more]</label></div><br/><div class="children"><div class="content">I have some bad news for you about books.</div><br/><div id="36036610" class="c"><input type="checkbox" id="c-36036610" checked=""/><div class="controls bullet"><span class="by">imtany</span><span>|</span><a href="#36032328">root</a><span>|</span><a href="#36034466">parent</a><span>|</span><a href="#36032189">next</a><span>|</span><label class="collapse" for="c-36036610">[-]</label><label class="expand" for="c-36036610">[3 more]</label></div><br/><div class="children"><div class="content">Could you elaborate?</div><br/><div id="36037575" class="c"><input type="checkbox" id="c-36037575" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36032328">root</a><span>|</span><a href="#36036610">parent</a><span>|</span><a href="#36037715">next</a><span>|</span><label class="collapse" for="c-36037575">[-]</label><label class="expand" for="c-36037575">[1 more]</label></div><br/><div class="children"><div class="content">You canât really have the interactivity with a book. I do wish you could.</div><br/></div></div><div id="36037715" class="c"><input type="checkbox" id="c-36037715" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#36032328">root</a><span>|</span><a href="#36036610">parent</a><span>|</span><a href="#36037575">prev</a><span>|</span><a href="#36032189">next</a><span>|</span><label class="collapse" for="c-36037715">[-]</label><label class="expand" for="c-36037715">[1 more]</label></div><br/><div class="children"><div class="content">Books can&#x27;t have interactive sliders.</div><br/></div></div></div></div></div></div></div></div><div id="36032189" class="c"><input type="checkbox" id="c-36032189" checked=""/><div class="controls bullet"><span class="by">patleeman</span><span>|</span><a href="#36032328">prev</a><span>|</span><a href="#36030035">next</a><span>|</span><label class="collapse" for="c-36032189">[-]</label><label class="expand" for="c-36032189">[4 more]</label></div><br/><div class="children"><div class="content">I love this so much, thank you for putting this together!<p>My only piece of feedback would be for the &quot;Inline Bookkeeping&quot; section (<a href="https:&#x2F;&#x2F;samwho.dev&#x2F;memory-allocation&#x2F;#inline-bookkeeping" rel="nofollow">https:&#x2F;&#x2F;samwho.dev&#x2F;memory-allocation&#x2F;#inline-bookkeeping</a>), it took a while for me to grok the numbered list to figure out which block corresponded to address + X. I wonder if there is a better way to visualize the 4 numbered bullet points? Maybe just arrows and text pointing to the visualization?<p>Thanks again for this wonderful article!</div><br/><div id="36032300" class="c"><input type="checkbox" id="c-36032300" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36032189">parent</a><span>|</span><a href="#36030035">next</a><span>|</span><label class="collapse" for="c-36032300">[-]</label><label class="expand" for="c-36032300">[3 more]</label></div><br/><div class="children"><div class="content">Yes, this is one of the things I look back on as a weak point in the writing. I wanted to make this a lot more clear but by the time I&#x27;d gotten to this point in the article, I&#x27;d sort of coded myself into a corner with the visualisation code.<p>In another universe I&#x27;d hook in to the page scroll and highlight each block being referred to as I talk about it in the text. I&#x27;m probably not explaining that well here, but imagine something like the way this article works: <a href="https:&#x2F;&#x2F;pudding.cool&#x2F;2017&#x2F;05&#x2F;song-repetition&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pudding.cool&#x2F;2017&#x2F;05&#x2F;song-repetition&#x2F;</a>.</div><br/><div id="36033345" class="c"><input type="checkbox" id="c-36033345" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#36032189">root</a><span>|</span><a href="#36032300">parent</a><span>|</span><a href="#36030035">next</a><span>|</span><label class="collapse" for="c-36033345">[-]</label><label class="expand" for="c-36033345">[2 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you highlight each block being referred to as you mouse over &#x2F; click on relevant text? (The latter might not be <i>terribly</i> hard to do with &lt;a&gt; and CSS :target, if you can give the blocks ids.)</div><br/><div id="36033521" class="c"><input type="checkbox" id="c-36033521" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36032189">root</a><span>|</span><a href="#36033345">parent</a><span>|</span><a href="#36030035">next</a><span>|</span><label class="collapse" for="c-36033521">[-]</label><label class="expand" for="c-36033521">[1 more]</label></div><br/><div class="children"><div class="content">The blocks aren&#x27;t HTML elements, they&#x27;re drawn on to a canvas. It _could_ be possible regardless, though. I may revisit this. Thanks for the idea! :)</div><br/></div></div></div></div></div></div></div></div><div id="36030035" class="c"><input type="checkbox" id="c-36030035" checked=""/><div class="controls bullet"><span class="by">shreyshnaccount</span><span>|</span><a href="#36032189">prev</a><span>|</span><a href="#36035746">next</a><span>|</span><label class="collapse" for="c-36030035">[-]</label><label class="expand" for="c-36030035">[2 more]</label></div><br/><div class="children"><div class="content">Someone needs to make an awesome list for visual guides</div><br/><div id="36030069" class="c"><input type="checkbox" id="c-36030069" checked=""/><div class="controls bullet"><span class="by">ocay</span><span>|</span><a href="#36030035">parent</a><span>|</span><a href="#36035746">next</a><span>|</span><label class="collapse" for="c-36030069">[-]</label><label class="expand" for="c-36030069">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely, this is so helpful</div><br/></div></div></div></div><div id="36035746" class="c"><input type="checkbox" id="c-36035746" checked=""/><div class="controls bullet"><span class="by">thangalin</span><span>|</span><a href="#36030035">prev</a><span>|</span><a href="#36038647">next</a><span>|</span><label class="collapse" for="c-36035746">[-]</label><label class="expand" for="c-36035746">[1 more]</label></div><br/><div class="children"><div class="content">When writing C, I tend to avoid calling malloc and free directly.<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;memory.c">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;memory....</a><p>I then apply this same principle of &quot;opening&quot; and &quot;closing&quot; structures throughout the application. Generally, I can quickly verify that the calls are balanced:<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;threads.c">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;threads...</a><p>What&#x27;s nice about this pattern is that the underlying implementation of exactly how the memory is maintained for a particular data structure (e.g., whether malloc or gdImageCreateTrueColor is called) becomes an implementation detail:<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;image.c">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;image.c</a><p>The main application opens then closes structures in the reverse order:<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;main.c">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;main.c</a><p>This means there&#x27;s only one call to malloc and one call to free throughout the entire application (third-party libraries notwithstanding), allowing them to be swapped out with ease.<p>Aside, logging can follow this same idea by restricting where any text is written to the console to a single location in the code base:<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;logging.c#L30">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;mandelbrot&#x2F;blob&#x2F;master&#x2F;logging...</a></div><br/></div></div><div id="36038647" class="c"><input type="checkbox" id="c-36038647" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#36035746">prev</a><span>|</span><a href="#36030808">next</a><span>|</span><label class="collapse" for="c-36038647">[-]</label><label class="expand" for="c-36038647">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve played around quite a bit with slab allocation in C to get my interpreters to run faster, and this post inspired me to do a quick benchmark of a design I&#x27;ve been iterating.<p>malloc&#x2F;free: 207294429ns<p>slab: 74795526ns<p>A 74% reduction in runtime is pretty nice.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;codr7&#x2F;libcnabl">https:&#x2F;&#x2F;github.com&#x2F;codr7&#x2F;libcnabl</a></div><br/></div></div><div id="36030808" class="c"><input type="checkbox" id="c-36030808" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#36038647">prev</a><span>|</span><a href="#36031920">next</a><span>|</span><label class="collapse" for="c-36030808">[-]</label><label class="expand" for="c-36030808">[2 more]</label></div><br/><div class="children"><div class="content">Great webpage, but it somehow left me more confused.<p>It seems to imply that malloc&#x2F;free works by boundary tag? Which I don&#x27;t think is the case? (and if not, it leaves the reader confused as to how it then actually works).<p>I know &quot;some&quot; languages use the tag technique (e.g. julia), but the article seems to imply that this also applies to the c code above? Or am I wrong and c also makes use of such a scheme when you use pointer arithmetic??  (I don&#x27;t see how that would work with arrays if that&#x27;s the case though)</div><br/><div id="36030890" class="c"><input type="checkbox" id="c-36030890" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36030808">parent</a><span>|</span><a href="#36031920">next</a><span>|</span><label class="collapse" for="c-36030890">[-]</label><label class="expand" for="c-36030890">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry you&#x27;re more confused than you were when you started!<p>The post is intending to talk about the topic of memory allocation in a general sense. The way that malloc works on any given system is implementation dependent, it&#x27;s not possible to say &quot;malloc works in this way&quot; because Debian can differ from Arch can differ from BSD, etc.<p>It&#x27;s not my goal to tell you exactly how modern malloc&#x2F;free implementations work. I could probably be more clear about this at the start of the post.</div><br/></div></div></div></div><div id="36031920" class="c"><input type="checkbox" id="c-36031920" checked=""/><div class="controls bullet"><span class="by">terrycody</span><span>|</span><a href="#36030808">prev</a><span>|</span><a href="#36035166">next</a><span>|</span><label class="collapse" for="c-36031920">[-]</label><label class="expand" for="c-36031920">[1 more]</label></div><br/><div class="children"><div class="content">Glad there are always talent people and great guide like him&#x2F;this exist! Great people and guides will help tremendous learners along the way, timeless, priceless.</div><br/></div></div><div id="36035166" class="c"><input type="checkbox" id="c-36035166" checked=""/><div class="controls bullet"><span class="by">bambax</span><span>|</span><a href="#36031920">prev</a><span>|</span><a href="#36031513">next</a><span>|</span><label class="collapse" for="c-36035166">[-]</label><label class="expand" for="c-36035166">[9 more]</label></div><br/><div class="children"><div class="content">Excellent, excellent article! I have a question though.<p>&gt; <i>Couldn&#x27;t we rearrange the memory to get a block of 6 contiguous bytes? Some sort of defragmentation process?</i><p>&gt; <i>Sadly not. Remember earlier we talked about how the return value of malloc is the address of a byte in memory? Moving allocations won&#x27;t change the pointers we have already returned from malloc. We would change the value those pointers are pointed at, effectively breaking them. This is one of the downsides of the malloc&#x2F;free API.</i><p>But why not? Couldn&#x27;t we store information about old pointers somewhere and match them with new addresses when defragmenting? Some kind of virtual memory driver that would map old pointers to new adresses transparently for the programs? Or would it be too much overhead for too little benefit?</div><br/><div id="36035992" class="c"><input type="checkbox" id="c-36035992" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035222">next</a><span>|</span><label class="collapse" for="c-36035992">[-]</label><label class="expand" for="c-36035992">[1 more]</label></div><br/><div class="children"><div class="content">Most OSes today do that &quot;transparently&quot; with virtual memory, but usually with a coarse granularity (e.g. 4k). A page table is just a translation of &quot;pointers&quot; to &quot;memory addresses&quot;; the OS can rearrange physical memory as it sees fit without the program having to update its pointers.<p>In OSes without virtual memory, one option is to do the same non-transparently: instead of returning pointers, malloc and friends work with &quot;pointers to pointers&quot; (called handles), so there is one extra level of indirection, and now the OS is free to rearrange this 2nd level as it sees fit. Whenever a program wants to read&#x2F;write the data behind a handle, it must dereference the handle to get to the real pointer, but it also must let the OS know that it is currently using the real pointer -- this is to avoid the OS moving it around.
This is usually called &quot;locking&#x2F;unlocking&quot; the handle.<p>Some classic examples are Windows 3.x, Mac OS (toolbox), PalmOS, etc.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Classic_Mac_OS_memory_management" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Classic_Mac_OS_memory_manageme...</a></div><br/></div></div><div id="36035222" class="c"><input type="checkbox" id="c-36035222" checked=""/><div class="controls bullet"><span class="by">alex7734</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035992">prev</a><span>|</span><a href="#36035980">next</a><span>|</span><label class="collapse" for="c-36035222">[-]</label><label class="expand" for="c-36035222">[1 more]</label></div><br/><div class="children"><div class="content">To do that you either need a structure that you update every time a pointer is created, copied, moved or deleted (too much overhead), or you need a way to scan the entire memory 
 and get all the pointers. And at the point where you have a piece of code that knows where every pointer is, you already know which pointers aren&#x27;t used anywhere anymore so it&#x27;s a waste to not have it also call free() for you.<p>Once you have it call free() for you, your piece of code is now a compacting GC, like Java&#x27;s for example.</div><br/></div></div><div id="36035980" class="c"><input type="checkbox" id="c-36035980" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035222">prev</a><span>|</span><a href="#36035793">next</a><span>|</span><label class="collapse" for="c-36035980">[-]</label><label class="expand" for="c-36035980">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But why not? Couldn&#x27;t we store information about old pointers somewhere and match them with new addresses when defragmenting? Some kind of virtual memory driver that would map old pointers to new adresses transparently for the programs? Or would it be too much overhead for too little benefit?<p>In languages where memory is managed for you, you can absolutely do this, since the runtime can find every single pointer to an object and rewrite it.<p>Virtual memory <i>can</i> let you do this, but would require a separate page for each allocation (since virtual memory operates on a page-level).  Given that the smallest page on modern architectures is 4k, this would mean using 4k of ram for each allocation (and rounding up each allocation to a 4k page boundary).<p>On top of that, it&#x27;s an OS system call to map and unmap pages, which means you incur a system-call on every allocation and deallocation, which is much slower than using a user-space allocator.</div><br/></div></div><div id="36035793" class="c"><input type="checkbox" id="c-36035793" checked=""/><div class="controls bullet"><span class="by">samwho</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035980">prev</a><span>|</span><a href="#36035254">next</a><span>|</span><label class="collapse" for="c-36035793">[-]</label><label class="expand" for="c-36035793">[1 more]</label></div><br/><div class="children"><div class="content">Youâd need cooperation between your malloc implementation and the application code. Itâs possible, but tricky. If your malloc returned a pointer to a pointer, and promised to keep the first level pointer up to date, and was able to lock your application whenever it moved things around, it could work.<p>Someone else already mentioned, but garbage collected languages do actually do this. Because theyâre fully in control of memory (the language exposes no raw pointers), theyâre able to create the layer of indirection youâve suggested and move things around as they please. I know at minimum the JVM does this. The term to search for is âheap compaction.â<p>Thereâs also the weird and wonderful work of Emery Berger et al with their âMeshâ malloc implementation, which blows my mind: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;XRAP3lBivYM" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;XRAP3lBivYM</a>.</div><br/></div></div><div id="36035254" class="c"><input type="checkbox" id="c-36035254" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035793">prev</a><span>|</span><a href="#36035225">next</a><span>|</span><label class="collapse" for="c-36035254">[-]</label><label class="expand" for="c-36035254">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some kind of virtual memory driver that would map old pointers to new adresses transparently for the programs<p>You would need hardware support for this, since the hardware is what decides what gets returned when a program attempts to read from a memory location.<p>Hardware already does support virtual memory but the granularity is the page (which are a minimum of 4KiB in most OSs).</div><br/></div></div><div id="36035225" class="c"><input type="checkbox" id="c-36035225" checked=""/><div class="controls bullet"><span class="by">cconstantine</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035254">prev</a><span>|</span><a href="#36036853">next</a><span>|</span><label class="collapse" for="c-36035225">[-]</label><label class="expand" for="c-36035225">[1 more]</label></div><br/><div class="children"><div class="content">In a language like C that isn&#x27;t really possible because the language can&#x27;t keep track of all of the places that memory address is stored.<p>If malloc were to return something like an address that holds the address of memory allocated there is nothing preventing the program from reading that address, doing math on it, and storing it somewhere else.</div><br/></div></div><div id="36036853" class="c"><input type="checkbox" id="c-36036853" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36035225">prev</a><span>|</span><a href="#36035226">next</a><span>|</span><label class="collapse" for="c-36036853">[-]</label><label class="expand" for="c-36036853">[1 more]</label></div><br/><div class="children"><div class="content">Early MacOS did this with handles (basically pointers to pointers.) You&#x27;d lock them to read&#x2F;write and when they were unlocked, the OS was free to move the underlying memory and change the pointer in the handle.</div><br/></div></div><div id="36035226" class="c"><input type="checkbox" id="c-36035226" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36035166">parent</a><span>|</span><a href="#36036853">prev</a><span>|</span><a href="#36031513">next</a><span>|</span><label class="collapse" for="c-36035226">[-]</label><label class="expand" for="c-36035226">[1 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s what some GCs do, and they do indeed defragment the heap.</div><br/></div></div></div></div><div id="36031513" class="c"><input type="checkbox" id="c-36031513" checked=""/><div class="controls bullet"><span class="by">cromulent</span><span>|</span><a href="#36035166">prev</a><span>|</span><a href="#36033467">next</a><span>|</span><label class="collapse" for="c-36031513">[-]</label><label class="expand" for="c-36031513">[1 more]</label></div><br/><div class="children"><div class="content">Nice article, but highly editorialized title, not sure what is intuitive about it.</div><br/></div></div><div id="36033467" class="c"><input type="checkbox" id="c-36033467" checked=""/><div class="controls bullet"><span class="by">a257</span><span>|</span><a href="#36031513">prev</a><span>|</span><a href="#36030444">next</a><span>|</span><label class="collapse" for="c-36033467">[-]</label><label class="expand" for="c-36033467">[1 more]</label></div><br/><div class="children"><div class="content">I think it will be helpful if it discusses internal fragmentation, where the payload is smaller than the allocated block. I observed that this was important in understanding the purpose of various memory allocation algorithms when undertaking the malloc lab in college.</div><br/></div></div><div id="36030444" class="c"><input type="checkbox" id="c-36030444" checked=""/><div class="controls bullet"><span class="by">RamiAwar</span><span>|</span><a href="#36033467">prev</a><span>|</span><a href="#36029856">next</a><span>|</span><label class="collapse" for="c-36030444">[-]</label><label class="expand" for="c-36030444">[2 more]</label></div><br/><div class="children"><div class="content">I love this! I wish it existed back when I was writing my first memory allocators in university or when building a custom EntityComponentSystem implementation.<p>I&#x27;d love to also see applications of custom memory allocations. I know about usecases in building game engines and the importance of hitting cache there, but I&#x27;m not sure where else in the world this would be as useful.</div><br/><div id="36030515" class="c"><input type="checkbox" id="c-36030515" checked=""/><div class="controls bullet"><span class="by">erwincoumans</span><span>|</span><a href="#36030444">parent</a><span>|</span><a href="#36029856">next</a><span>|</span><label class="collapse" for="c-36030515">[-]</label><label class="expand" for="c-36030515">[1 more]</label></div><br/><div class="children"><div class="content">Robotics, embedded systems, CUDA&#x2F;gpgpu, AI&#x2F;Deep learning&#x2F;Reinforcement Learning&#x2F;LLM (PyTorch) for example.</div><br/></div></div></div></div><div id="36029856" class="c"><input type="checkbox" id="c-36029856" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#36030444">prev</a><span>|</span><label class="collapse" for="c-36029856">[-]</label><label class="expand" for="c-36029856">[1 more]</label></div><br/><div class="children"><div class="content">Ahh yes. Back at university we had a class called efficient programming where we had to implement a Unix utility and optimize it for speed, meaning cpu cycles.<p>While aggressively optimizing we replaced malloc in the end with a function we called &quot;cooloc&quot;, that traded portability and security for speed. The debug tool here would have been useful.</div><br/></div></div></div></div></div></div></div></body></html>